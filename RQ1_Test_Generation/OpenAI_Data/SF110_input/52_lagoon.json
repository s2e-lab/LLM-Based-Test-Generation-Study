[
	{
		"original_code": "// FTPClient.java\n/*\n * Copyright (c) 2002, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.ftp;\n\nimport java.io.*;\nimport java.net.*;\n\n/**\n * An FTP client. See RFC-959.\n *\n * Pathnames must be specified using '/' for directory separator.\n * Passive mode will be used for all transfers.\n * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in\n * progress.\n *\n * <strong>Note:</strong> This class will transmit password in clear text over\n * the network.\n */\npublic class FTPClient {\n\n    private static final boolean DEBUG = false;\n\n    private Socket control;\n\n    private InputStream controlIn;\n\n    private OutputStream controlOut;\n\n    private String respString;\n\n    private String lastPath = \"\";\n\n    private int lastPathLen = 0;\n\n    private void sendLine(String str) throws IOException {\n        controlOut.write(str.getBytes(\"US-ASCII\"));\n        controlOut.write('\\r');\n        controlOut.write('\\n');\n        controlOut.flush();\n    }\n\n    private String recvLine() throws EOFException, IOException {\n        StringBuffer sb = new StringBuffer();\n        while (true) {\n            int i = controlIn.read();\n            if (i < 0)\n                throw new EOFException(\"Unexpected EOF when reading socket\");\n            byte b = (byte) i;\n            if (b == '\\n')\n                break;\n            if (b != '\\r')\n                sb.append((char) b);\n        }\n        return sb.toString();\n    }\n\n    private int recvResponse() throws EOFException, IOException {\n        respString = recvLine();\n        String code = respString.substring(0, 3);\n        if (// multiline response\n        respString.charAt(3) == '-') {\n            String endMark = code + ' ';\n            while (true) {\n                respString = recvLine();\n                if (respString.startsWith(endMark))\n                    break;\n            }\n        }\n        return Integer.parseInt(code);\n    }\n\n    /**\n     * Connect to an FTP server and login.\n     *\n     * @param url  an URL specifying host, port, username and optionally\n     *             an initial path to change to\n     * @param password  the password to use for logging in\n     *\n     * @throws MalformedURLException  if there are any syntactic error in the URL\n     * @throws UnknownHostException  if the hostname specified doesn't exist\n     * @throws FTPAuthenticationException  if the password is wrong\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public FTPClient(String url, String password) throws MalformedURLException, UnknownHostException, FTPAuthenticationException, FTPException, IOException {\n        if (!url.startsWith(\"ftp://\"))\n            throw new MalformedURLException(url);\n        int userPos = 5;\n        int hostPos = url.indexOf('@', userPos + 1);\n        if (hostPos < 0)\n            throw new MalformedURLException(url);\n        int portPos = url.indexOf(':', hostPos + 1);\n        int pathPos = url.indexOf('/', ((portPos < 0) ? hostPos : portPos) + 1);\n        String username;\n        String host;\n        int port;\n        String path;\n        try {\n            username = url.substring(userPos + 1, hostPos);\n            host = url.substring(hostPos + 1, (portPos < 0) ? pathPos : portPos);\n            port = (portPos < 0) ? 21 : Integer.parseInt(url.substring(portPos + 1, pathPos));\n            path = url.substring(pathPos + 1);\n        } catch (NumberFormatException e) {\n            throw new MalformedURLException(url);\n        }\n        if (port < 0 || port > 65535 || username.length() < 1 || host.length() < 1 || (path.length() > 0 && path.charAt(path.length() - 1) != '/'))\n            throw new MalformedURLException(url);\n        connect(host, port, username, password);\n        initialDir(path);\n    }\n\n    /**\n     * Connect to an FTP server and login.\n     *\n     * @param host  the host to connect to, may be a domain name or IP address\n     * @param port  the control channel port (default 21)\n     * @param username  the username to use for logging in\n     * @param password  the password to use for logging in\n     * @param path  initial path, realtive to home directory unless starting with '/',\n     *              may be <code>null</code> to use home directory\n     *\n     * @throws UnknownHostException  if the hostname specified doesn't exist\n     * @throws FTPAuthenticationException  if the password is wrong\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public FTPClient(String host, int port, String username, String password, String path) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {\n        connect(host, port, username, password);\n        initialDir(path);\n    }\n\n    private void connect(String host, int port, String username, String password) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {\n        if (port < 0 || port > 65535)\n            port = 21;\n        control = new Socket(host, port);\n        controlIn = control.getInputStream();\n        controlOut = control.getOutputStream();\n        int resp;\n        // Receive greeting message\n        greeting: while (true) {\n            resp = recvResponse();\n            switch(resp) {\n                case 120:\n                    continue greeting;\n                case 220:\n                    break greeting;\n                case 421:\n                    throw new FTPException(\"FTP server not avaliable (421)\");\n                default:\n                    throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n            }\n        }\n        sendLine(\"USER \" + username);\n        resp = recvResponse();\n        switch(resp) {\n            case 230:\n                break;\n            case 331:\n                sendLine(\"PASS \" + password);\n                resp = recvResponse();\n                switch(resp) {\n                    case 230:\n                        break;\n                    case 530:\n                        throw new FTPAuthenticationException();\n                    case 421:\n                        throw new FTPException(\"FTP server not avaliable (421)\");\n                    default:\n                        throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n                }\n                break;\n            case 530:\n                throw new FTPException(\"Invalid username\");\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n    }\n\n    private void initialDir(String path) throws FTPException, IOException {\n        if (path == null)\n            return;\n        int pos, oldPos = 0;\n        while (true) {\n            pos = path.indexOf('/', oldPos);\n            if (pos < 0)\n                break;\n            String comp = path.substring(oldPos, pos);\n            if (!chdir(comp))\n                throw new FTPException(\"Path not found: \" + path);\n            oldPos = pos + 1;\n        }\n    }\n\n    /**\n     * Logout and disconnect from the FTP server.\n     *\n     * After this method has been invoked, no other method may be invoked.\n     */\n    public void close() throws IOException {\n        sendLine(\"QUIT\");\n        int resp = recvResponse();\n        control.close();\n        control = null;\n    }\n\n    /**\n     * Change the current directory.\n     *\n     * @param dir  the directory to change into\n     *\n     * @return true if successful, false otherwise\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    private boolean chdir(String dir) throws FTPException, IOException {\n        if (DEBUG)\n            System.out.println(\"CWD \" + dir);\n        sendLine(\"CWD \" + dir);\n        int resp = recvResponse();\n        switch(resp) {\n            case 250:\n                return true;\n            case 550:\n                return false;\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n    }\n\n    /**\n     * Change the current directory to the parent directory.\n     *\n     * @return true if successful, false otherwise\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    private boolean cdup() throws FTPException, IOException {\n        if (DEBUG)\n            System.out.println(\"CDUP\");\n        sendLine(\"CDUP\");\n        int resp = recvResponse();\n        switch(resp) {\n            case 200:\n            case 250:\n                return true;\n            case 550:\n                return false;\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n    }\n\n    /**\n     * Create a new directory.\n     *\n     * @param dir  the directory to create\n     *\n     * @return true if successful, false otherwise\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    private boolean mkdir(String dir) throws FTPException, IOException {\n        if (DEBUG)\n            System.out.println(\"MKD \" + dir);\n        sendLine(\"MKD \" + dir);\n        int resp = recvResponse();\n        switch(resp) {\n            case 257:\n                return true;\n            case 550:\n                return false;\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n    }\n\n    /**\n     * Create a new file, or overwrite an existing file.\n     * Will create directories as nessesary.\n     *\n     * @param pathname  path to the file\n     *\n     * @return an OutputStream to write to, close() it when finished\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public OutputStream store(String pathname) throws FTPException, IOException {\n        return store(pathname, false);\n    }\n\n    /**\n     * Create a new file, or overwrite an existing file.\n     * Will create directories as nessesary.\n     *\n     * @param pathname  path to the file\n     * @param last  close the FTPClient after transferring this file\n     *\n     * @return an OutputStream to write to, close() it when finished\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public OutputStream store(String pathname, boolean last) throws FTPException, IOException {\n        int pos = pathname.lastIndexOf('/');\n        String path = pathname.substring(0, pos + 1);\n        String filename = pathname.substring(pos + 1);\n        changeDir(path);\n        return upload(\"STOR\", filename, last);\n    }\n\n    /**\n     * Create a new file, or append to an existing file.\n     * Will create directories as nessesary.\n     *\n     * @param pathname  path to the file\n     *\n     * @return an OutputStream to write to, close() it when finished\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public OutputStream append(String pathname) throws FTPException, IOException {\n        return append(pathname, false);\n    }\n\n    /**\n     * Create a new file, or append to an existing file.\n     * Will create directories as nessesary.\n     *\n     * @param pathname  path to the file\n     * @param last  close the FTPClient after transferring this file\n     *\n     * @return an OutputStream to write to, close() it when finished\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public OutputStream append(String pathname, boolean last) throws FTPException, IOException {\n        int pos = pathname.lastIndexOf('/');\n        String path = pathname.substring(0, pos + 1);\n        String filename = pathname.substring(pos + 1);\n        changeDir(path);\n        return upload(\"APPE\", filename, last);\n    }\n\n    /**\n     * Create a new file with an unique name.\n     * Will create directories as nessesary.\n     *\n     * @param path  path to the file, must end with '/' or be empty\n     *\n     * @return an OutputStream to write to, close() it when finished\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public OutputStream storeUnique(String path) throws FTPException, IOException {\n        return storeUnique(path, false);\n    }\n\n    /**\n     * Create a new file with an unique name.\n     * Will create directories as nessesary.\n     *\n     * @param path  path to the file, must end with '/' or be empty\n     * @param last  close the FTPClient after transferring this file\n     *\n     * @return an OutputStream to write to, close() it when finished\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public OutputStream storeUnique(String path, boolean last) throws FTPException, IOException {\n        changeDir(path);\n        return upload(\"STOU\", null, last);\n    }\n\n    private void changeDir(String path) throws FTPException, IOException {\n        if (!path.equals(lastPath)) {\n            if (path.length() > 0 && path.charAt(0) != '/')\n                path = '/' + path;\n            // change directory\n            for (int i = 0; i < lastPathLen; i++) if (!cdup())\n                throw new FTPException(\"Unable to change to parent directory\");\n            lastPathLen = 0;\n            int pos, oldPos = 1;\n            boolean mkd = false;\n            while (true) {\n                pos = path.indexOf('/', oldPos);\n                if (pos < 0)\n                    break;\n                lastPathLen++;\n                String comp = path.substring(oldPos, pos);\n                if (mkd) {\n                    if (!mkdir(comp))\n                        throw new FTPException(\"Unable to create directory: \" + comp);\n                    if (!chdir(comp))\n                        throw new FTPException(\"Unable to change into newly created directory: \" + comp);\n                } else {\n                    if (!chdir(comp)) {\n                        if (!mkdir(comp))\n                            throw new FTPException(\"Unable to create directory: \" + comp);\n                        if (!chdir(comp))\n                            throw new FTPException(\"Unable to change into newly created directory: \" + comp);\n                        mkd = true;\n                    }\n                }\n                oldPos = pos + 1;\n            }\n        }\n        lastPath = path;\n    }\n\n    private OutputStream upload(String cmd, String filename, boolean last) throws FTPException, IOException {\n        int resp;\n        sendLine(\"TYPE I\");\n        resp = recvResponse();\n        switch(resp) {\n            case 200:\n                break;\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n        sendLine(\"PASV\");\n        resp = recvResponse();\n        switch(resp) {\n            case 227:\n                break;\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n        InetAddress addr;\n        int port;\n        String s = respString.replace(',', '.');\n        int i = 3;\n        while (i < s.length() && !Character.isDigit(s.charAt(i))) i++;\n        if (i == s.length())\n            throw new FTPException(\"invalid response to PASV command\");\n        int c1 = s.indexOf('.', i);\n        if (c1 < 0)\n            throw new FTPException(\"invalid response to PASV command\");\n        int c2 = s.indexOf('.', c1 + 2);\n        if (c2 < 0)\n            throw new FTPException(\"invalid response to PASV command\");\n        int c3 = s.indexOf('.', c2 + 1);\n        if (c3 < 0)\n            throw new FTPException(\"invalid response to PASV command\");\n        int c4 = s.indexOf('.', c3 + 1);\n        if (c4 < 0)\n            throw new FTPException(\"invalid response to PASV command\");\n        int c5 = s.indexOf('.', c4 + 1);\n        if (c5 < 0)\n            throw new FTPException(\"invalid response to PASV command\");\n        try {\n            addr = InetAddress.getByName(s.substring(i, c4));\n            i = c5 + 1;\n            while (i < s.length() && Character.isDigit(s.charAt(i))) i++;\n            int portA = Integer.parseInt(s.substring(c4 + 1, c5));\n            int portB = Integer.parseInt(s.substring(c5 + 1, i));\n            port = (portA << 8) + portB;\n        } catch (UnknownHostException e) {\n            throw new FTPException(\"invalid response to PASV command\");\n        } catch (NumberFormatException e) {\n            throw new FTPException(\"invalid response to PASV command\");\n        }\n        if (cmd == null)\n            sendLine(cmd);\n        else\n            sendLine(cmd + \" \" + filename);\n        Socket data = new Socket(addr, port);\n        resp = recvResponse();\n        switch(resp) {\n            case 125:\n            case 150:\n                break;\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n        return new FTPOutputStream(data.getOutputStream(), data, last ? this : null);\n    }\n\n    /**\n     * Deletes a file.\n     *\n     * @param pathname  path to the file\n     *\n     * @return true if successful, false otherwise (file didn't exsist)\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public boolean deleteFile(String pathname) throws FTPException, IOException {\n        String path;\n        String fn;\n        int pos = pathname.lastIndexOf('/');\n        path = pathname.substring(0, pos + 1);\n        fn = pathname.substring(pos + 1);\n        if (!path.equals(lastPath)) {\n            // change directory\n            for (int i = 0; i < lastPathLen; i++) if (!cdup())\n                throw new FTPException(\"Unable to change to parent directory\");\n            lastPathLen = 0;\n            int oldPos = 1;\n            while (true) {\n                pos = path.indexOf('/', oldPos);\n                if (pos < 0)\n                    break;\n                lastPathLen++;\n                String comp = path.substring(oldPos, pos);\n                if (!chdir(comp)) {\n                    // file doesn't exist\n                    return false;\n                }\n                oldPos = pos + 1;\n            }\n        }\n        lastPath = path;\n        sendLine(\"DELE \" + fn);\n        int resp = recvResponse();\n        switch(resp) {\n            case 250:\n                return true;\n            case 550:\n                return false;\n            case 450:\n                throw new FTPException(\"Unable to delete file: \" + respString);\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n    }\n\n    class FTPOutputStream extends OutputStream {\n\n        private Socket data;\n\n        private OutputStream out;\n\n        private FTPClient ftp;\n\n        FTPOutputStream(OutputStream out, Socket data, FTPClient ftp) {\n            this.out = out;\n            this.data = data;\n            this.ftp = ftp;\n        }\n\n        public void write(int b) throws IOException {\n            out.write(b);\n        }\n\n        public void write(byte[] b) throws IOException {\n            out.write(b);\n        }\n\n        public void write(byte[] b, int off, int len) throws IOException {\n            out.write(b, off, len);\n        }\n\n        public void flush() throws IOException {\n            out.flush();\n        }\n\n        public void close() throws IOException {\n            out.close();\n            if (data != null) {\n                data.close();\n                data = null;\n            }\n            theLoop: while (true) {\n                int resp = recvResponse();\n                switch(resp) {\n                    case 226:\n                    case 250:\n                        break;\n                    case 425:\n                    case 426:\n                    case 451:\n                    case 551:\n                    case 552:\n                        throw new FTPException(\"Error in file transfer (\" + resp + \")\");\n                    case 421:\n                        throw new FTPException(\"FTP server not avaliable (421)\");\n                    default:\n                        throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n                }\n                break;\n            }\n            if (ftp != null)\n                ftp.close();\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/ftp/FTPClientTest0.java",
		"test_prompt": "// FTPClientTest0.java\npackage nu.staldal.ftp;\n\nimport java.io.*;\nimport java.net.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FTPClient}.\n* It contains ten unit test cases for the {@link FTPClient#store(String)} method.\n*/\nclass FTPClientTest0 {"
	},
	{
		"original_code": "// FTPClient.java\n/*\n * Copyright (c) 2002, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.ftp;\n\nimport java.io.*;\nimport java.net.*;\n\n/**\n * An FTP client. See RFC-959.\n *\n * Pathnames must be specified using '/' for directory separator.\n * Passive mode will be used for all transfers.\n * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in\n * progress.\n *\n * <strong>Note:</strong> This class will transmit password in clear text over\n * the network.\n */\npublic class FTPClient {\n\n    private static final boolean DEBUG = false;\n\n    private Socket control;\n\n    private InputStream controlIn;\n\n    private OutputStream controlOut;\n\n    private String respString;\n\n    private String lastPath = \"\";\n\n    private int lastPathLen = 0;\n\n    private void sendLine(String str) throws IOException {\n        controlOut.write(str.getBytes(\"US-ASCII\"));\n        controlOut.write('\\r');\n        controlOut.write('\\n');\n        controlOut.flush();\n    }\n\n    private String recvLine() throws EOFException, IOException {\n        StringBuffer sb = new StringBuffer();\n        while (true) {\n            int i = controlIn.read();\n            if (i < 0)\n                throw new EOFException(\"Unexpected EOF when reading socket\");\n            byte b = (byte) i;\n            if (b == '\\n')\n                break;\n            if (b != '\\r')\n                sb.append((char) b);\n        }\n        return sb.toString();\n    }\n\n    private int recvResponse() throws EOFException, IOException {\n        respString = recvLine();\n        String code = respString.substring(0, 3);\n        if (// multiline response\n        respString.charAt(3) == '-') {\n            String endMark = code + ' ';\n            while (true) {\n                respString = recvLine();\n                if (respString.startsWith(endMark))\n                    break;\n            }\n        }\n        return Integer.parseInt(code);\n    }\n\n    /**\n     * Connect to an FTP server and login.\n     *\n     * @param url  an URL specifying host, port, username and optionally\n     *             an initial path to change to\n     * @param password  the password to use for logging in\n     *\n     * @throws MalformedURLException  if there are any syntactic error in the URL\n     * @throws UnknownHostException  if the hostname specified doesn't exist\n     * @throws FTPAuthenticationException  if the password is wrong\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public FTPClient(String url, String password) throws MalformedURLException, UnknownHostException, FTPAuthenticationException, FTPException, IOException {\n        if (!url.startsWith(\"ftp://\"))\n            throw new MalformedURLException(url);\n        int userPos = 5;\n        int hostPos = url.indexOf('@', userPos + 1);\n        if (hostPos < 0)\n            throw new MalformedURLException(url);\n        int portPos = url.indexOf(':', hostPos + 1);\n        int pathPos = url.indexOf('/', ((portPos < 0) ? hostPos : portPos) + 1);\n        String username;\n        String host;\n        int port;\n        String path;\n        try {\n            username = url.substring(userPos + 1, hostPos);\n            host = url.substring(hostPos + 1, (portPos < 0) ? pathPos : portPos);\n            port = (portPos < 0) ? 21 : Integer.parseInt(url.substring(portPos + 1, pathPos));\n            path = url.substring(pathPos + 1);\n        } catch (NumberFormatException e) {\n            throw new MalformedURLException(url);\n        }\n        if (port < 0 || port > 65535 || username.length() < 1 || host.length() < 1 || (path.length() > 0 && path.charAt(path.length() - 1) != '/'))\n            throw new MalformedURLException(url);\n        connect(host, port, username, password);\n        initialDir(path);\n    }\n\n    /**\n     * Connect to an FTP server and login.\n     *\n     * @param host  the host to connect to, may be a domain name or IP address\n     * @param port  the control channel port (default 21)\n     * @param username  the username to use for logging in\n     * @param password  the password to use for logging in\n     * @param path  initial path, realtive to home directory unless starting with '/',\n     *              may be <code>null</code> to use home directory\n     *\n     * @throws UnknownHostException  if the hostname specified doesn't exist\n     * @throws FTPAuthenticationException  if the password is wrong\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public FTPClient(String host, int port, String username, String password, String path) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {\n        connect(host, port, username, password);\n        initialDir(path);\n    }\n\n    private void connect(String host, int port, String username, String password) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {\n        if (port < 0 || port > 65535)\n            port = 21;\n        control = new Socket(host, port);\n        controlIn = control.getInputStream();\n        controlOut = control.getOutputStream();\n        int resp;\n        // Receive greeting message\n        greeting: while (true) {\n            resp = recvResponse();\n            switch(resp) {\n                case 120:\n                    continue greeting;\n                case 220:\n                    break greeting;\n                case 421:\n                    throw new FTPException(\"FTP server not avaliable (421)\");\n                default:\n                    throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n            }\n        }\n        sendLine(\"USER \" + username);\n        resp = recvResponse();\n        switch(resp) {\n            case 230:\n                break;\n            case 331:\n                sendLine(\"PASS \" + password);\n                resp = recvResponse();\n                switch(resp) {\n                    case 230:\n                        break;\n                    case 530:\n                        throw new FTPAuthenticationException();\n                    case 421:\n                        throw new FTPException(\"FTP server not avaliable (421)\");\n                    default:\n                        throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n                }\n                break;\n            case 530:\n                throw new FTPException(\"Invalid username\");\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n    }\n\n    private void initialDir(String path) throws FTPException, IOException {\n        if (path == null)\n            return;\n        int pos, oldPos = 0;\n        while (true) {\n            pos = path.indexOf('/', oldPos);\n            if (pos < 0)\n                break;\n            String comp = path.substring(oldPos, pos);\n            if (!chdir(comp))\n                throw new FTPException(\"Path not found: \" + path);\n            oldPos = pos + 1;\n        }\n    }\n\n    /**\n     * Logout and disconnect from the FTP server.\n     *\n     * After this method has been invoked, no other method may be invoked.\n     */\n    public void close() throws IOException {\n        sendLine(\"QUIT\");\n        int resp = recvResponse();\n        control.close();\n        control = null;\n    }\n\n    /**\n     * Change the current directory.\n     *\n     * @param dir  the directory to change into\n     *\n     * @return true if successful, false otherwise\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    private boolean chdir(String dir) throws FTPException, IOException {\n        if (DEBUG)\n            System.out.println(\"CWD \" + dir);\n        sendLine(\"CWD \" + dir);\n        int resp = recvResponse();\n        switch(resp) {\n            case 250:\n                return true;\n            case 550:\n                return false;\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n    }\n\n    /**\n     * Change the current directory to the parent directory.\n     *\n     * @return true if successful, false otherwise\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    private boolean cdup() throws FTPException, IOException {\n        if (DEBUG)\n            System.out.println(\"CDUP\");\n        sendLine(\"CDUP\");\n        int resp = recvResponse();\n        switch(resp) {\n            case 200:\n            case 250:\n                return true;\n            case 550:\n                return false;\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n    }\n\n    /**\n     * Create a new directory.\n     *\n     * @param dir  the directory to create\n     *\n     * @return true if successful, false otherwise\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    private boolean mkdir(String dir) throws FTPException, IOException {\n        if (DEBUG)\n            System.out.println(\"MKD \" + dir);\n        sendLine(\"MKD \" + dir);\n        int resp = recvResponse();\n        switch(resp) {\n            case 257:\n                return true;\n            case 550:\n                return false;\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n    }\n\n    /**\n     * Create a new file, or overwrite an existing file.\n     * Will create directories as nessesary.\n     *\n     * @param pathname  path to the file\n     *\n     * @return an OutputStream to write to, close() it when finished\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public OutputStream store(String pathname) throws FTPException, IOException {\n        return store(pathname, false);\n    }\n\n    /**\n     * Create a new file, or overwrite an existing file.\n     * Will create directories as nessesary.\n     *\n     * @param pathname  path to the file\n     * @param last  close the FTPClient after transferring this file\n     *\n     * @return an OutputStream to write to, close() it when finished\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public OutputStream store(String pathname, boolean last) throws FTPException, IOException {\n        int pos = pathname.lastIndexOf('/');\n        String path = pathname.substring(0, pos + 1);\n        String filename = pathname.substring(pos + 1);\n        changeDir(path);\n        return upload(\"STOR\", filename, last);\n    }\n\n    /**\n     * Create a new file, or append to an existing file.\n     * Will create directories as nessesary.\n     *\n     * @param pathname  path to the file\n     *\n     * @return an OutputStream to write to, close() it when finished\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public OutputStream append(String pathname) throws FTPException, IOException {\n        return append(pathname, false);\n    }\n\n    /**\n     * Create a new file, or append to an existing file.\n     * Will create directories as nessesary.\n     *\n     * @param pathname  path to the file\n     * @param last  close the FTPClient after transferring this file\n     *\n     * @return an OutputStream to write to, close() it when finished\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public OutputStream append(String pathname, boolean last) throws FTPException, IOException {\n        int pos = pathname.lastIndexOf('/');\n        String path = pathname.substring(0, pos + 1);\n        String filename = pathname.substring(pos + 1);\n        changeDir(path);\n        return upload(\"APPE\", filename, last);\n    }\n\n    /**\n     * Create a new file with an unique name.\n     * Will create directories as nessesary.\n     *\n     * @param path  path to the file, must end with '/' or be empty\n     *\n     * @return an OutputStream to write to, close() it when finished\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public OutputStream storeUnique(String path) throws FTPException, IOException {\n        return storeUnique(path, false);\n    }\n\n    /**\n     * Create a new file with an unique name.\n     * Will create directories as nessesary.\n     *\n     * @param path  path to the file, must end with '/' or be empty\n     * @param last  close the FTPClient after transferring this file\n     *\n     * @return an OutputStream to write to, close() it when finished\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public OutputStream storeUnique(String path, boolean last) throws FTPException, IOException {\n        changeDir(path);\n        return upload(\"STOU\", null, last);\n    }\n\n    private void changeDir(String path) throws FTPException, IOException {\n        if (!path.equals(lastPath)) {\n            if (path.length() > 0 && path.charAt(0) != '/')\n                path = '/' + path;\n            // change directory\n            for (int i = 0; i < lastPathLen; i++) if (!cdup())\n                throw new FTPException(\"Unable to change to parent directory\");\n            lastPathLen = 0;\n            int pos, oldPos = 1;\n            boolean mkd = false;\n            while (true) {\n                pos = path.indexOf('/', oldPos);\n                if (pos < 0)\n                    break;\n                lastPathLen++;\n                String comp = path.substring(oldPos, pos);\n                if (mkd) {\n                    if (!mkdir(comp))\n                        throw new FTPException(\"Unable to create directory: \" + comp);\n                    if (!chdir(comp))\n                        throw new FTPException(\"Unable to change into newly created directory: \" + comp);\n                } else {\n                    if (!chdir(comp)) {\n                        if (!mkdir(comp))\n                            throw new FTPException(\"Unable to create directory: \" + comp);\n                        if (!chdir(comp))\n                            throw new FTPException(\"Unable to change into newly created directory: \" + comp);\n                        mkd = true;\n                    }\n                }\n                oldPos = pos + 1;\n            }\n        }\n        lastPath = path;\n    }\n\n    private OutputStream upload(String cmd, String filename, boolean last) throws FTPException, IOException {\n        int resp;\n        sendLine(\"TYPE I\");\n        resp = recvResponse();\n        switch(resp) {\n            case 200:\n                break;\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n        sendLine(\"PASV\");\n        resp = recvResponse();\n        switch(resp) {\n            case 227:\n                break;\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n        InetAddress addr;\n        int port;\n        String s = respString.replace(',', '.');\n        int i = 3;\n        while (i < s.length() && !Character.isDigit(s.charAt(i))) i++;\n        if (i == s.length())\n            throw new FTPException(\"invalid response to PASV command\");\n        int c1 = s.indexOf('.', i);\n        if (c1 < 0)\n            throw new FTPException(\"invalid response to PASV command\");\n        int c2 = s.indexOf('.', c1 + 2);\n        if (c2 < 0)\n            throw new FTPException(\"invalid response to PASV command\");\n        int c3 = s.indexOf('.', c2 + 1);\n        if (c3 < 0)\n            throw new FTPException(\"invalid response to PASV command\");\n        int c4 = s.indexOf('.', c3 + 1);\n        if (c4 < 0)\n            throw new FTPException(\"invalid response to PASV command\");\n        int c5 = s.indexOf('.', c4 + 1);\n        if (c5 < 0)\n            throw new FTPException(\"invalid response to PASV command\");\n        try {\n            addr = InetAddress.getByName(s.substring(i, c4));\n            i = c5 + 1;\n            while (i < s.length() && Character.isDigit(s.charAt(i))) i++;\n            int portA = Integer.parseInt(s.substring(c4 + 1, c5));\n            int portB = Integer.parseInt(s.substring(c5 + 1, i));\n            port = (portA << 8) + portB;\n        } catch (UnknownHostException e) {\n            throw new FTPException(\"invalid response to PASV command\");\n        } catch (NumberFormatException e) {\n            throw new FTPException(\"invalid response to PASV command\");\n        }\n        if (cmd == null)\n            sendLine(cmd);\n        else\n            sendLine(cmd + \" \" + filename);\n        Socket data = new Socket(addr, port);\n        resp = recvResponse();\n        switch(resp) {\n            case 125:\n            case 150:\n                break;\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n        return new FTPOutputStream(data.getOutputStream(), data, last ? this : null);\n    }\n\n    /**\n     * Deletes a file.\n     *\n     * @param pathname  path to the file\n     *\n     * @return true if successful, false otherwise (file didn't exsist)\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public boolean deleteFile(String pathname) throws FTPException, IOException {\n        String path;\n        String fn;\n        int pos = pathname.lastIndexOf('/');\n        path = pathname.substring(0, pos + 1);\n        fn = pathname.substring(pos + 1);\n        if (!path.equals(lastPath)) {\n            // change directory\n            for (int i = 0; i < lastPathLen; i++) if (!cdup())\n                throw new FTPException(\"Unable to change to parent directory\");\n            lastPathLen = 0;\n            int oldPos = 1;\n            while (true) {\n                pos = path.indexOf('/', oldPos);\n                if (pos < 0)\n                    break;\n                lastPathLen++;\n                String comp = path.substring(oldPos, pos);\n                if (!chdir(comp)) {\n                    // file doesn't exist\n                    return false;\n                }\n                oldPos = pos + 1;\n            }\n        }\n        lastPath = path;\n        sendLine(\"DELE \" + fn);\n        int resp = recvResponse();\n        switch(resp) {\n            case 250:\n                return true;\n            case 550:\n                return false;\n            case 450:\n                throw new FTPException(\"Unable to delete file: \" + respString);\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n    }\n\n    class FTPOutputStream extends OutputStream {\n\n        private Socket data;\n\n        private OutputStream out;\n\n        private FTPClient ftp;\n\n        FTPOutputStream(OutputStream out, Socket data, FTPClient ftp) {\n            this.out = out;\n            this.data = data;\n            this.ftp = ftp;\n        }\n\n        public void write(int b) throws IOException {\n            out.write(b);\n        }\n\n        public void write(byte[] b) throws IOException {\n            out.write(b);\n        }\n\n        public void write(byte[] b, int off, int len) throws IOException {\n            out.write(b, off, len);\n        }\n\n        public void flush() throws IOException {\n            out.flush();\n        }\n\n        public void close() throws IOException {\n            out.close();\n            if (data != null) {\n                data.close();\n                data = null;\n            }\n            theLoop: while (true) {\n                int resp = recvResponse();\n                switch(resp) {\n                    case 226:\n                    case 250:\n                        break;\n                    case 425:\n                    case 426:\n                    case 451:\n                    case 551:\n                    case 552:\n                        throw new FTPException(\"Error in file transfer (\" + resp + \")\");\n                    case 421:\n                        throw new FTPException(\"FTP server not avaliable (421)\");\n                    default:\n                        throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n                }\n                break;\n            }\n            if (ftp != null)\n                ftp.close();\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/ftp/FTPClientTest1.java",
		"test_prompt": "// FTPClientTest1.java\npackage nu.staldal.ftp;\n\nimport java.io.*;\nimport java.net.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FTPClient}.\n* It contains ten unit test cases for the {@link FTPClient#store(String, boolean)} method.\n*/\nclass FTPClientTest1 {"
	},
	{
		"original_code": "// FTPClient.java\n/*\n * Copyright (c) 2002, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.ftp;\n\nimport java.io.*;\nimport java.net.*;\n\n/**\n * An FTP client. See RFC-959.\n *\n * Pathnames must be specified using '/' for directory separator.\n * Passive mode will be used for all transfers.\n * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in\n * progress.\n *\n * <strong>Note:</strong> This class will transmit password in clear text over\n * the network.\n */\npublic class FTPClient {\n\n    private static final boolean DEBUG = false;\n\n    private Socket control;\n\n    private InputStream controlIn;\n\n    private OutputStream controlOut;\n\n    private String respString;\n\n    private String lastPath = \"\";\n\n    private int lastPathLen = 0;\n\n    private void sendLine(String str) throws IOException {\n        controlOut.write(str.getBytes(\"US-ASCII\"));\n        controlOut.write('\\r');\n        controlOut.write('\\n');\n        controlOut.flush();\n    }\n\n    private String recvLine() throws EOFException, IOException {\n        StringBuffer sb = new StringBuffer();\n        while (true) {\n            int i = controlIn.read();\n            if (i < 0)\n                throw new EOFException(\"Unexpected EOF when reading socket\");\n            byte b = (byte) i;\n            if (b == '\\n')\n                break;\n            if (b != '\\r')\n                sb.append((char) b);\n        }\n        return sb.toString();\n    }\n\n    private int recvResponse() throws EOFException, IOException {\n        respString = recvLine();\n        String code = respString.substring(0, 3);\n        if (// multiline response\n        respString.charAt(3) == '-') {\n            String endMark = code + ' ';\n            while (true) {\n                respString = recvLine();\n                if (respString.startsWith(endMark))\n                    break;\n            }\n        }\n        return Integer.parseInt(code);\n    }\n\n    /**\n     * Connect to an FTP server and login.\n     *\n     * @param url  an URL specifying host, port, username and optionally\n     *             an initial path to change to\n     * @param password  the password to use for logging in\n     *\n     * @throws MalformedURLException  if there are any syntactic error in the URL\n     * @throws UnknownHostException  if the hostname specified doesn't exist\n     * @throws FTPAuthenticationException  if the password is wrong\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public FTPClient(String url, String password) throws MalformedURLException, UnknownHostException, FTPAuthenticationException, FTPException, IOException {\n        if (!url.startsWith(\"ftp://\"))\n            throw new MalformedURLException(url);\n        int userPos = 5;\n        int hostPos = url.indexOf('@', userPos + 1);\n        if (hostPos < 0)\n            throw new MalformedURLException(url);\n        int portPos = url.indexOf(':', hostPos + 1);\n        int pathPos = url.indexOf('/', ((portPos < 0) ? hostPos : portPos) + 1);\n        String username;\n        String host;\n        int port;\n        String path;\n        try {\n            username = url.substring(userPos + 1, hostPos);\n            host = url.substring(hostPos + 1, (portPos < 0) ? pathPos : portPos);\n            port = (portPos < 0) ? 21 : Integer.parseInt(url.substring(portPos + 1, pathPos));\n            path = url.substring(pathPos + 1);\n        } catch (NumberFormatException e) {\n            throw new MalformedURLException(url);\n        }\n        if (port < 0 || port > 65535 || username.length() < 1 || host.length() < 1 || (path.length() > 0 && path.charAt(path.length() - 1) != '/'))\n            throw new MalformedURLException(url);\n        connect(host, port, username, password);\n        initialDir(path);\n    }\n\n    /**\n     * Connect to an FTP server and login.\n     *\n     * @param host  the host to connect to, may be a domain name or IP address\n     * @param port  the control channel port (default 21)\n     * @param username  the username to use for logging in\n     * @param password  the password to use for logging in\n     * @param path  initial path, realtive to home directory unless starting with '/',\n     *              may be <code>null</code> to use home directory\n     *\n     * @throws UnknownHostException  if the hostname specified doesn't exist\n     * @throws FTPAuthenticationException  if the password is wrong\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public FTPClient(String host, int port, String username, String password, String path) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {\n        connect(host, port, username, password);\n        initialDir(path);\n    }\n\n    private void connect(String host, int port, String username, String password) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {\n        if (port < 0 || port > 65535)\n            port = 21;\n        control = new Socket(host, port);\n        controlIn = control.getInputStream();\n        controlOut = control.getOutputStream();\n        int resp;\n        // Receive greeting message\n        greeting: while (true) {\n            resp = recvResponse();\n            switch(resp) {\n                case 120:\n                    continue greeting;\n                case 220:\n                    break greeting;\n                case 421:\n                    throw new FTPException(\"FTP server not avaliable (421)\");\n                default:\n                    throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n            }\n        }\n        sendLine(\"USER \" + username);\n        resp = recvResponse();\n        switch(resp) {\n            case 230:\n                break;\n            case 331:\n                sendLine(\"PASS \" + password);\n                resp = recvResponse();\n                switch(resp) {\n                    case 230:\n                        break;\n                    case 530:\n                        throw new FTPAuthenticationException();\n                    case 421:\n                        throw new FTPException(\"FTP server not avaliable (421)\");\n                    default:\n                        throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n                }\n                break;\n            case 530:\n                throw new FTPException(\"Invalid username\");\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n    }\n\n    private void initialDir(String path) throws FTPException, IOException {\n        if (path == null)\n            return;\n        int pos, oldPos = 0;\n        while (true) {\n            pos = path.indexOf('/', oldPos);\n            if (pos < 0)\n                break;\n            String comp = path.substring(oldPos, pos);\n            if (!chdir(comp))\n                throw new FTPException(\"Path not found: \" + path);\n            oldPos = pos + 1;\n        }\n    }\n\n    /**\n     * Logout and disconnect from the FTP server.\n     *\n     * After this method has been invoked, no other method may be invoked.\n     */\n    public void close() throws IOException {\n        sendLine(\"QUIT\");\n        int resp = recvResponse();\n        control.close();\n        control = null;\n    }\n\n    /**\n     * Change the current directory.\n     *\n     * @param dir  the directory to change into\n     *\n     * @return true if successful, false otherwise\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    private boolean chdir(String dir) throws FTPException, IOException {\n        if (DEBUG)\n            System.out.println(\"CWD \" + dir);\n        sendLine(\"CWD \" + dir);\n        int resp = recvResponse();\n        switch(resp) {\n            case 250:\n                return true;\n            case 550:\n                return false;\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n    }\n\n    /**\n     * Change the current directory to the parent directory.\n     *\n     * @return true if successful, false otherwise\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    private boolean cdup() throws FTPException, IOException {\n        if (DEBUG)\n            System.out.println(\"CDUP\");\n        sendLine(\"CDUP\");\n        int resp = recvResponse();\n        switch(resp) {\n            case 200:\n            case 250:\n                return true;\n            case 550:\n                return false;\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n    }\n\n    /**\n     * Create a new directory.\n     *\n     * @param dir  the directory to create\n     *\n     * @return true if successful, false otherwise\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    private boolean mkdir(String dir) throws FTPException, IOException {\n        if (DEBUG)\n            System.out.println(\"MKD \" + dir);\n        sendLine(\"MKD \" + dir);\n        int resp = recvResponse();\n        switch(resp) {\n            case 257:\n                return true;\n            case 550:\n                return false;\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n    }\n\n    /**\n     * Create a new file, or overwrite an existing file.\n     * Will create directories as nessesary.\n     *\n     * @param pathname  path to the file\n     *\n     * @return an OutputStream to write to, close() it when finished\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public OutputStream store(String pathname) throws FTPException, IOException {\n        return store(pathname, false);\n    }\n\n    /**\n     * Create a new file, or overwrite an existing file.\n     * Will create directories as nessesary.\n     *\n     * @param pathname  path to the file\n     * @param last  close the FTPClient after transferring this file\n     *\n     * @return an OutputStream to write to, close() it when finished\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public OutputStream store(String pathname, boolean last) throws FTPException, IOException {\n        int pos = pathname.lastIndexOf('/');\n        String path = pathname.substring(0, pos + 1);\n        String filename = pathname.substring(pos + 1);\n        changeDir(path);\n        return upload(\"STOR\", filename, last);\n    }\n\n    /**\n     * Create a new file, or append to an existing file.\n     * Will create directories as nessesary.\n     *\n     * @param pathname  path to the file\n     *\n     * @return an OutputStream to write to, close() it when finished\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public OutputStream append(String pathname) throws FTPException, IOException {\n        return append(pathname, false);\n    }\n\n    /**\n     * Create a new file, or append to an existing file.\n     * Will create directories as nessesary.\n     *\n     * @param pathname  path to the file\n     * @param last  close the FTPClient after transferring this file\n     *\n     * @return an OutputStream to write to, close() it when finished\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public OutputStream append(String pathname, boolean last) throws FTPException, IOException {\n        int pos = pathname.lastIndexOf('/');\n        String path = pathname.substring(0, pos + 1);\n        String filename = pathname.substring(pos + 1);\n        changeDir(path);\n        return upload(\"APPE\", filename, last);\n    }\n\n    /**\n     * Create a new file with an unique name.\n     * Will create directories as nessesary.\n     *\n     * @param path  path to the file, must end with '/' or be empty\n     *\n     * @return an OutputStream to write to, close() it when finished\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public OutputStream storeUnique(String path) throws FTPException, IOException {\n        return storeUnique(path, false);\n    }\n\n    /**\n     * Create a new file with an unique name.\n     * Will create directories as nessesary.\n     *\n     * @param path  path to the file, must end with '/' or be empty\n     * @param last  close the FTPClient after transferring this file\n     *\n     * @return an OutputStream to write to, close() it when finished\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public OutputStream storeUnique(String path, boolean last) throws FTPException, IOException {\n        changeDir(path);\n        return upload(\"STOU\", null, last);\n    }\n\n    private void changeDir(String path) throws FTPException, IOException {\n        if (!path.equals(lastPath)) {\n            if (path.length() > 0 && path.charAt(0) != '/')\n                path = '/' + path;\n            // change directory\n            for (int i = 0; i < lastPathLen; i++) if (!cdup())\n                throw new FTPException(\"Unable to change to parent directory\");\n            lastPathLen = 0;\n            int pos, oldPos = 1;\n            boolean mkd = false;\n            while (true) {\n                pos = path.indexOf('/', oldPos);\n                if (pos < 0)\n                    break;\n                lastPathLen++;\n                String comp = path.substring(oldPos, pos);\n                if (mkd) {\n                    if (!mkdir(comp))\n                        throw new FTPException(\"Unable to create directory: \" + comp);\n                    if (!chdir(comp))\n                        throw new FTPException(\"Unable to change into newly created directory: \" + comp);\n                } else {\n                    if (!chdir(comp)) {\n                        if (!mkdir(comp))\n                            throw new FTPException(\"Unable to create directory: \" + comp);\n                        if (!chdir(comp))\n                            throw new FTPException(\"Unable to change into newly created directory: \" + comp);\n                        mkd = true;\n                    }\n                }\n                oldPos = pos + 1;\n            }\n        }\n        lastPath = path;\n    }\n\n    private OutputStream upload(String cmd, String filename, boolean last) throws FTPException, IOException {\n        int resp;\n        sendLine(\"TYPE I\");\n        resp = recvResponse();\n        switch(resp) {\n            case 200:\n                break;\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n        sendLine(\"PASV\");\n        resp = recvResponse();\n        switch(resp) {\n            case 227:\n                break;\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n        InetAddress addr;\n        int port;\n        String s = respString.replace(',', '.');\n        int i = 3;\n        while (i < s.length() && !Character.isDigit(s.charAt(i))) i++;\n        if (i == s.length())\n            throw new FTPException(\"invalid response to PASV command\");\n        int c1 = s.indexOf('.', i);\n        if (c1 < 0)\n            throw new FTPException(\"invalid response to PASV command\");\n        int c2 = s.indexOf('.', c1 + 2);\n        if (c2 < 0)\n            throw new FTPException(\"invalid response to PASV command\");\n        int c3 = s.indexOf('.', c2 + 1);\n        if (c3 < 0)\n            throw new FTPException(\"invalid response to PASV command\");\n        int c4 = s.indexOf('.', c3 + 1);\n        if (c4 < 0)\n            throw new FTPException(\"invalid response to PASV command\");\n        int c5 = s.indexOf('.', c4 + 1);\n        if (c5 < 0)\n            throw new FTPException(\"invalid response to PASV command\");\n        try {\n            addr = InetAddress.getByName(s.substring(i, c4));\n            i = c5 + 1;\n            while (i < s.length() && Character.isDigit(s.charAt(i))) i++;\n            int portA = Integer.parseInt(s.substring(c4 + 1, c5));\n            int portB = Integer.parseInt(s.substring(c5 + 1, i));\n            port = (portA << 8) + portB;\n        } catch (UnknownHostException e) {\n            throw new FTPException(\"invalid response to PASV command\");\n        } catch (NumberFormatException e) {\n            throw new FTPException(\"invalid response to PASV command\");\n        }\n        if (cmd == null)\n            sendLine(cmd);\n        else\n            sendLine(cmd + \" \" + filename);\n        Socket data = new Socket(addr, port);\n        resp = recvResponse();\n        switch(resp) {\n            case 125:\n            case 150:\n                break;\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n        return new FTPOutputStream(data.getOutputStream(), data, last ? this : null);\n    }\n\n    /**\n     * Deletes a file.\n     *\n     * @param pathname  path to the file\n     *\n     * @return true if successful, false otherwise (file didn't exsist)\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public boolean deleteFile(String pathname) throws FTPException, IOException {\n        String path;\n        String fn;\n        int pos = pathname.lastIndexOf('/');\n        path = pathname.substring(0, pos + 1);\n        fn = pathname.substring(pos + 1);\n        if (!path.equals(lastPath)) {\n            // change directory\n            for (int i = 0; i < lastPathLen; i++) if (!cdup())\n                throw new FTPException(\"Unable to change to parent directory\");\n            lastPathLen = 0;\n            int oldPos = 1;\n            while (true) {\n                pos = path.indexOf('/', oldPos);\n                if (pos < 0)\n                    break;\n                lastPathLen++;\n                String comp = path.substring(oldPos, pos);\n                if (!chdir(comp)) {\n                    // file doesn't exist\n                    return false;\n                }\n                oldPos = pos + 1;\n            }\n        }\n        lastPath = path;\n        sendLine(\"DELE \" + fn);\n        int resp = recvResponse();\n        switch(resp) {\n            case 250:\n                return true;\n            case 550:\n                return false;\n            case 450:\n                throw new FTPException(\"Unable to delete file: \" + respString);\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n    }\n\n    class FTPOutputStream extends OutputStream {\n\n        private Socket data;\n\n        private OutputStream out;\n\n        private FTPClient ftp;\n\n        FTPOutputStream(OutputStream out, Socket data, FTPClient ftp) {\n            this.out = out;\n            this.data = data;\n            this.ftp = ftp;\n        }\n\n        public void write(int b) throws IOException {\n            out.write(b);\n        }\n\n        public void write(byte[] b) throws IOException {\n            out.write(b);\n        }\n\n        public void write(byte[] b, int off, int len) throws IOException {\n            out.write(b, off, len);\n        }\n\n        public void flush() throws IOException {\n            out.flush();\n        }\n\n        public void close() throws IOException {\n            out.close();\n            if (data != null) {\n                data.close();\n                data = null;\n            }\n            theLoop: while (true) {\n                int resp = recvResponse();\n                switch(resp) {\n                    case 226:\n                    case 250:\n                        break;\n                    case 425:\n                    case 426:\n                    case 451:\n                    case 551:\n                    case 552:\n                        throw new FTPException(\"Error in file transfer (\" + resp + \")\");\n                    case 421:\n                        throw new FTPException(\"FTP server not avaliable (421)\");\n                    default:\n                        throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n                }\n                break;\n            }\n            if (ftp != null)\n                ftp.close();\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/ftp/FTPClientTest2.java",
		"test_prompt": "// FTPClientTest2.java\npackage nu.staldal.ftp;\n\nimport java.io.*;\nimport java.net.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FTPClient}.\n* It contains ten unit test cases for the {@link FTPClient#append(String)} method.\n*/\nclass FTPClientTest2 {"
	},
	{
		"original_code": "// FTPClient.java\n/*\n * Copyright (c) 2002, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.ftp;\n\nimport java.io.*;\nimport java.net.*;\n\n/**\n * An FTP client. See RFC-959.\n *\n * Pathnames must be specified using '/' for directory separator.\n * Passive mode will be used for all transfers.\n * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in\n * progress.\n *\n * <strong>Note:</strong> This class will transmit password in clear text over\n * the network.\n */\npublic class FTPClient {\n\n    private static final boolean DEBUG = false;\n\n    private Socket control;\n\n    private InputStream controlIn;\n\n    private OutputStream controlOut;\n\n    private String respString;\n\n    private String lastPath = \"\";\n\n    private int lastPathLen = 0;\n\n    private void sendLine(String str) throws IOException {\n        controlOut.write(str.getBytes(\"US-ASCII\"));\n        controlOut.write('\\r');\n        controlOut.write('\\n');\n        controlOut.flush();\n    }\n\n    private String recvLine() throws EOFException, IOException {\n        StringBuffer sb = new StringBuffer();\n        while (true) {\n            int i = controlIn.read();\n            if (i < 0)\n                throw new EOFException(\"Unexpected EOF when reading socket\");\n            byte b = (byte) i;\n            if (b == '\\n')\n                break;\n            if (b != '\\r')\n                sb.append((char) b);\n        }\n        return sb.toString();\n    }\n\n    private int recvResponse() throws EOFException, IOException {\n        respString = recvLine();\n        String code = respString.substring(0, 3);\n        if (// multiline response\n        respString.charAt(3) == '-') {\n            String endMark = code + ' ';\n            while (true) {\n                respString = recvLine();\n                if (respString.startsWith(endMark))\n                    break;\n            }\n        }\n        return Integer.parseInt(code);\n    }\n\n    /**\n     * Connect to an FTP server and login.\n     *\n     * @param url  an URL specifying host, port, username and optionally\n     *             an initial path to change to\n     * @param password  the password to use for logging in\n     *\n     * @throws MalformedURLException  if there are any syntactic error in the URL\n     * @throws UnknownHostException  if the hostname specified doesn't exist\n     * @throws FTPAuthenticationException  if the password is wrong\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public FTPClient(String url, String password) throws MalformedURLException, UnknownHostException, FTPAuthenticationException, FTPException, IOException {\n        if (!url.startsWith(\"ftp://\"))\n            throw new MalformedURLException(url);\n        int userPos = 5;\n        int hostPos = url.indexOf('@', userPos + 1);\n        if (hostPos < 0)\n            throw new MalformedURLException(url);\n        int portPos = url.indexOf(':', hostPos + 1);\n        int pathPos = url.indexOf('/', ((portPos < 0) ? hostPos : portPos) + 1);\n        String username;\n        String host;\n        int port;\n        String path;\n        try {\n            username = url.substring(userPos + 1, hostPos);\n            host = url.substring(hostPos + 1, (portPos < 0) ? pathPos : portPos);\n            port = (portPos < 0) ? 21 : Integer.parseInt(url.substring(portPos + 1, pathPos));\n            path = url.substring(pathPos + 1);\n        } catch (NumberFormatException e) {\n            throw new MalformedURLException(url);\n        }\n        if (port < 0 || port > 65535 || username.length() < 1 || host.length() < 1 || (path.length() > 0 && path.charAt(path.length() - 1) != '/'))\n            throw new MalformedURLException(url);\n        connect(host, port, username, password);\n        initialDir(path);\n    }\n\n    /**\n     * Connect to an FTP server and login.\n     *\n     * @param host  the host to connect to, may be a domain name or IP address\n     * @param port  the control channel port (default 21)\n     * @param username  the username to use for logging in\n     * @param password  the password to use for logging in\n     * @param path  initial path, realtive to home directory unless starting with '/',\n     *              may be <code>null</code> to use home directory\n     *\n     * @throws UnknownHostException  if the hostname specified doesn't exist\n     * @throws FTPAuthenticationException  if the password is wrong\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public FTPClient(String host, int port, String username, String password, String path) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {\n        connect(host, port, username, password);\n        initialDir(path);\n    }\n\n    private void connect(String host, int port, String username, String password) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {\n        if (port < 0 || port > 65535)\n            port = 21;\n        control = new Socket(host, port);\n        controlIn = control.getInputStream();\n        controlOut = control.getOutputStream();\n        int resp;\n        // Receive greeting message\n        greeting: while (true) {\n            resp = recvResponse();\n            switch(resp) {\n                case 120:\n                    continue greeting;\n                case 220:\n                    break greeting;\n                case 421:\n                    throw new FTPException(\"FTP server not avaliable (421)\");\n                default:\n                    throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n            }\n        }\n        sendLine(\"USER \" + username);\n        resp = recvResponse();\n        switch(resp) {\n            case 230:\n                break;\n            case 331:\n                sendLine(\"PASS \" + password);\n                resp = recvResponse();\n                switch(resp) {\n                    case 230:\n                        break;\n                    case 530:\n                        throw new FTPAuthenticationException();\n                    case 421:\n                        throw new FTPException(\"FTP server not avaliable (421)\");\n                    default:\n                        throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n                }\n                break;\n            case 530:\n                throw new FTPException(\"Invalid username\");\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n    }\n\n    private void initialDir(String path) throws FTPException, IOException {\n        if (path == null)\n            return;\n        int pos, oldPos = 0;\n        while (true) {\n            pos = path.indexOf('/', oldPos);\n            if (pos < 0)\n                break;\n            String comp = path.substring(oldPos, pos);\n            if (!chdir(comp))\n                throw new FTPException(\"Path not found: \" + path);\n            oldPos = pos + 1;\n        }\n    }\n\n    /**\n     * Logout and disconnect from the FTP server.\n     *\n     * After this method has been invoked, no other method may be invoked.\n     */\n    public void close() throws IOException {\n        sendLine(\"QUIT\");\n        int resp = recvResponse();\n        control.close();\n        control = null;\n    }\n\n    /**\n     * Change the current directory.\n     *\n     * @param dir  the directory to change into\n     *\n     * @return true if successful, false otherwise\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    private boolean chdir(String dir) throws FTPException, IOException {\n        if (DEBUG)\n            System.out.println(\"CWD \" + dir);\n        sendLine(\"CWD \" + dir);\n        int resp = recvResponse();\n        switch(resp) {\n            case 250:\n                return true;\n            case 550:\n                return false;\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n    }\n\n    /**\n     * Change the current directory to the parent directory.\n     *\n     * @return true if successful, false otherwise\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    private boolean cdup() throws FTPException, IOException {\n        if (DEBUG)\n            System.out.println(\"CDUP\");\n        sendLine(\"CDUP\");\n        int resp = recvResponse();\n        switch(resp) {\n            case 200:\n            case 250:\n                return true;\n            case 550:\n                return false;\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n    }\n\n    /**\n     * Create a new directory.\n     *\n     * @param dir  the directory to create\n     *\n     * @return true if successful, false otherwise\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    private boolean mkdir(String dir) throws FTPException, IOException {\n        if (DEBUG)\n            System.out.println(\"MKD \" + dir);\n        sendLine(\"MKD \" + dir);\n        int resp = recvResponse();\n        switch(resp) {\n            case 257:\n                return true;\n            case 550:\n                return false;\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n    }\n\n    /**\n     * Create a new file, or overwrite an existing file.\n     * Will create directories as nessesary.\n     *\n     * @param pathname  path to the file\n     *\n     * @return an OutputStream to write to, close() it when finished\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public OutputStream store(String pathname) throws FTPException, IOException {\n        return store(pathname, false);\n    }\n\n    /**\n     * Create a new file, or overwrite an existing file.\n     * Will create directories as nessesary.\n     *\n     * @param pathname  path to the file\n     * @param last  close the FTPClient after transferring this file\n     *\n     * @return an OutputStream to write to, close() it when finished\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public OutputStream store(String pathname, boolean last) throws FTPException, IOException {\n        int pos = pathname.lastIndexOf('/');\n        String path = pathname.substring(0, pos + 1);\n        String filename = pathname.substring(pos + 1);\n        changeDir(path);\n        return upload(\"STOR\", filename, last);\n    }\n\n    /**\n     * Create a new file, or append to an existing file.\n     * Will create directories as nessesary.\n     *\n     * @param pathname  path to the file\n     *\n     * @return an OutputStream to write to, close() it when finished\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public OutputStream append(String pathname) throws FTPException, IOException {\n        return append(pathname, false);\n    }\n\n    /**\n     * Create a new file, or append to an existing file.\n     * Will create directories as nessesary.\n     *\n     * @param pathname  path to the file\n     * @param last  close the FTPClient after transferring this file\n     *\n     * @return an OutputStream to write to, close() it when finished\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public OutputStream append(String pathname, boolean last) throws FTPException, IOException {\n        int pos = pathname.lastIndexOf('/');\n        String path = pathname.substring(0, pos + 1);\n        String filename = pathname.substring(pos + 1);\n        changeDir(path);\n        return upload(\"APPE\", filename, last);\n    }\n\n    /**\n     * Create a new file with an unique name.\n     * Will create directories as nessesary.\n     *\n     * @param path  path to the file, must end with '/' or be empty\n     *\n     * @return an OutputStream to write to, close() it when finished\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public OutputStream storeUnique(String path) throws FTPException, IOException {\n        return storeUnique(path, false);\n    }\n\n    /**\n     * Create a new file with an unique name.\n     * Will create directories as nessesary.\n     *\n     * @param path  path to the file, must end with '/' or be empty\n     * @param last  close the FTPClient after transferring this file\n     *\n     * @return an OutputStream to write to, close() it when finished\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public OutputStream storeUnique(String path, boolean last) throws FTPException, IOException {\n        changeDir(path);\n        return upload(\"STOU\", null, last);\n    }\n\n    private void changeDir(String path) throws FTPException, IOException {\n        if (!path.equals(lastPath)) {\n            if (path.length() > 0 && path.charAt(0) != '/')\n                path = '/' + path;\n            // change directory\n            for (int i = 0; i < lastPathLen; i++) if (!cdup())\n                throw new FTPException(\"Unable to change to parent directory\");\n            lastPathLen = 0;\n            int pos, oldPos = 1;\n            boolean mkd = false;\n            while (true) {\n                pos = path.indexOf('/', oldPos);\n                if (pos < 0)\n                    break;\n                lastPathLen++;\n                String comp = path.substring(oldPos, pos);\n                if (mkd) {\n                    if (!mkdir(comp))\n                        throw new FTPException(\"Unable to create directory: \" + comp);\n                    if (!chdir(comp))\n                        throw new FTPException(\"Unable to change into newly created directory: \" + comp);\n                } else {\n                    if (!chdir(comp)) {\n                        if (!mkdir(comp))\n                            throw new FTPException(\"Unable to create directory: \" + comp);\n                        if (!chdir(comp))\n                            throw new FTPException(\"Unable to change into newly created directory: \" + comp);\n                        mkd = true;\n                    }\n                }\n                oldPos = pos + 1;\n            }\n        }\n        lastPath = path;\n    }\n\n    private OutputStream upload(String cmd, String filename, boolean last) throws FTPException, IOException {\n        int resp;\n        sendLine(\"TYPE I\");\n        resp = recvResponse();\n        switch(resp) {\n            case 200:\n                break;\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n        sendLine(\"PASV\");\n        resp = recvResponse();\n        switch(resp) {\n            case 227:\n                break;\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n        InetAddress addr;\n        int port;\n        String s = respString.replace(',', '.');\n        int i = 3;\n        while (i < s.length() && !Character.isDigit(s.charAt(i))) i++;\n        if (i == s.length())\n            throw new FTPException(\"invalid response to PASV command\");\n        int c1 = s.indexOf('.', i);\n        if (c1 < 0)\n            throw new FTPException(\"invalid response to PASV command\");\n        int c2 = s.indexOf('.', c1 + 2);\n        if (c2 < 0)\n            throw new FTPException(\"invalid response to PASV command\");\n        int c3 = s.indexOf('.', c2 + 1);\n        if (c3 < 0)\n            throw new FTPException(\"invalid response to PASV command\");\n        int c4 = s.indexOf('.', c3 + 1);\n        if (c4 < 0)\n            throw new FTPException(\"invalid response to PASV command\");\n        int c5 = s.indexOf('.', c4 + 1);\n        if (c5 < 0)\n            throw new FTPException(\"invalid response to PASV command\");\n        try {\n            addr = InetAddress.getByName(s.substring(i, c4));\n            i = c5 + 1;\n            while (i < s.length() && Character.isDigit(s.charAt(i))) i++;\n            int portA = Integer.parseInt(s.substring(c4 + 1, c5));\n            int portB = Integer.parseInt(s.substring(c5 + 1, i));\n            port = (portA << 8) + portB;\n        } catch (UnknownHostException e) {\n            throw new FTPException(\"invalid response to PASV command\");\n        } catch (NumberFormatException e) {\n            throw new FTPException(\"invalid response to PASV command\");\n        }\n        if (cmd == null)\n            sendLine(cmd);\n        else\n            sendLine(cmd + \" \" + filename);\n        Socket data = new Socket(addr, port);\n        resp = recvResponse();\n        switch(resp) {\n            case 125:\n            case 150:\n                break;\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n        return new FTPOutputStream(data.getOutputStream(), data, last ? this : null);\n    }\n\n    /**\n     * Deletes a file.\n     *\n     * @param pathname  path to the file\n     *\n     * @return true if successful, false otherwise (file didn't exsist)\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public boolean deleteFile(String pathname) throws FTPException, IOException {\n        String path;\n        String fn;\n        int pos = pathname.lastIndexOf('/');\n        path = pathname.substring(0, pos + 1);\n        fn = pathname.substring(pos + 1);\n        if (!path.equals(lastPath)) {\n            // change directory\n            for (int i = 0; i < lastPathLen; i++) if (!cdup())\n                throw new FTPException(\"Unable to change to parent directory\");\n            lastPathLen = 0;\n            int oldPos = 1;\n            while (true) {\n                pos = path.indexOf('/', oldPos);\n                if (pos < 0)\n                    break;\n                lastPathLen++;\n                String comp = path.substring(oldPos, pos);\n                if (!chdir(comp)) {\n                    // file doesn't exist\n                    return false;\n                }\n                oldPos = pos + 1;\n            }\n        }\n        lastPath = path;\n        sendLine(\"DELE \" + fn);\n        int resp = recvResponse();\n        switch(resp) {\n            case 250:\n                return true;\n            case 550:\n                return false;\n            case 450:\n                throw new FTPException(\"Unable to delete file: \" + respString);\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n    }\n\n    class FTPOutputStream extends OutputStream {\n\n        private Socket data;\n\n        private OutputStream out;\n\n        private FTPClient ftp;\n\n        FTPOutputStream(OutputStream out, Socket data, FTPClient ftp) {\n            this.out = out;\n            this.data = data;\n            this.ftp = ftp;\n        }\n\n        public void write(int b) throws IOException {\n            out.write(b);\n        }\n\n        public void write(byte[] b) throws IOException {\n            out.write(b);\n        }\n\n        public void write(byte[] b, int off, int len) throws IOException {\n            out.write(b, off, len);\n        }\n\n        public void flush() throws IOException {\n            out.flush();\n        }\n\n        public void close() throws IOException {\n            out.close();\n            if (data != null) {\n                data.close();\n                data = null;\n            }\n            theLoop: while (true) {\n                int resp = recvResponse();\n                switch(resp) {\n                    case 226:\n                    case 250:\n                        break;\n                    case 425:\n                    case 426:\n                    case 451:\n                    case 551:\n                    case 552:\n                        throw new FTPException(\"Error in file transfer (\" + resp + \")\");\n                    case 421:\n                        throw new FTPException(\"FTP server not avaliable (421)\");\n                    default:\n                        throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n                }\n                break;\n            }\n            if (ftp != null)\n                ftp.close();\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/ftp/FTPClientTest3.java",
		"test_prompt": "// FTPClientTest3.java\npackage nu.staldal.ftp;\n\nimport java.io.*;\nimport java.net.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FTPClient}.\n* It contains ten unit test cases for the {@link FTPClient#append(String, boolean)} method.\n*/\nclass FTPClientTest3 {"
	},
	{
		"original_code": "// FTPClient.java\n/*\n * Copyright (c) 2002, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.ftp;\n\nimport java.io.*;\nimport java.net.*;\n\n/**\n * An FTP client. See RFC-959.\n *\n * Pathnames must be specified using '/' for directory separator.\n * Passive mode will be used for all transfers.\n * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in\n * progress.\n *\n * <strong>Note:</strong> This class will transmit password in clear text over\n * the network.\n */\npublic class FTPClient {\n\n    private static final boolean DEBUG = false;\n\n    private Socket control;\n\n    private InputStream controlIn;\n\n    private OutputStream controlOut;\n\n    private String respString;\n\n    private String lastPath = \"\";\n\n    private int lastPathLen = 0;\n\n    private void sendLine(String str) throws IOException {\n        controlOut.write(str.getBytes(\"US-ASCII\"));\n        controlOut.write('\\r');\n        controlOut.write('\\n');\n        controlOut.flush();\n    }\n\n    private String recvLine() throws EOFException, IOException {\n        StringBuffer sb = new StringBuffer();\n        while (true) {\n            int i = controlIn.read();\n            if (i < 0)\n                throw new EOFException(\"Unexpected EOF when reading socket\");\n            byte b = (byte) i;\n            if (b == '\\n')\n                break;\n            if (b != '\\r')\n                sb.append((char) b);\n        }\n        return sb.toString();\n    }\n\n    private int recvResponse() throws EOFException, IOException {\n        respString = recvLine();\n        String code = respString.substring(0, 3);\n        if (// multiline response\n        respString.charAt(3) == '-') {\n            String endMark = code + ' ';\n            while (true) {\n                respString = recvLine();\n                if (respString.startsWith(endMark))\n                    break;\n            }\n        }\n        return Integer.parseInt(code);\n    }\n\n    /**\n     * Connect to an FTP server and login.\n     *\n     * @param url  an URL specifying host, port, username and optionally\n     *             an initial path to change to\n     * @param password  the password to use for logging in\n     *\n     * @throws MalformedURLException  if there are any syntactic error in the URL\n     * @throws UnknownHostException  if the hostname specified doesn't exist\n     * @throws FTPAuthenticationException  if the password is wrong\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public FTPClient(String url, String password) throws MalformedURLException, UnknownHostException, FTPAuthenticationException, FTPException, IOException {\n        if (!url.startsWith(\"ftp://\"))\n            throw new MalformedURLException(url);\n        int userPos = 5;\n        int hostPos = url.indexOf('@', userPos + 1);\n        if (hostPos < 0)\n            throw new MalformedURLException(url);\n        int portPos = url.indexOf(':', hostPos + 1);\n        int pathPos = url.indexOf('/', ((portPos < 0) ? hostPos : portPos) + 1);\n        String username;\n        String host;\n        int port;\n        String path;\n        try {\n            username = url.substring(userPos + 1, hostPos);\n            host = url.substring(hostPos + 1, (portPos < 0) ? pathPos : portPos);\n            port = (portPos < 0) ? 21 : Integer.parseInt(url.substring(portPos + 1, pathPos));\n            path = url.substring(pathPos + 1);\n        } catch (NumberFormatException e) {\n            throw new MalformedURLException(url);\n        }\n        if (port < 0 || port > 65535 || username.length() < 1 || host.length() < 1 || (path.length() > 0 && path.charAt(path.length() - 1) != '/'))\n            throw new MalformedURLException(url);\n        connect(host, port, username, password);\n        initialDir(path);\n    }\n\n    /**\n     * Connect to an FTP server and login.\n     *\n     * @param host  the host to connect to, may be a domain name or IP address\n     * @param port  the control channel port (default 21)\n     * @param username  the username to use for logging in\n     * @param password  the password to use for logging in\n     * @param path  initial path, realtive to home directory unless starting with '/',\n     *              may be <code>null</code> to use home directory\n     *\n     * @throws UnknownHostException  if the hostname specified doesn't exist\n     * @throws FTPAuthenticationException  if the password is wrong\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public FTPClient(String host, int port, String username, String password, String path) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {\n        connect(host, port, username, password);\n        initialDir(path);\n    }\n\n    private void connect(String host, int port, String username, String password) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {\n        if (port < 0 || port > 65535)\n            port = 21;\n        control = new Socket(host, port);\n        controlIn = control.getInputStream();\n        controlOut = control.getOutputStream();\n        int resp;\n        // Receive greeting message\n        greeting: while (true) {\n            resp = recvResponse();\n            switch(resp) {\n                case 120:\n                    continue greeting;\n                case 220:\n                    break greeting;\n                case 421:\n                    throw new FTPException(\"FTP server not avaliable (421)\");\n                default:\n                    throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n            }\n        }\n        sendLine(\"USER \" + username);\n        resp = recvResponse();\n        switch(resp) {\n            case 230:\n                break;\n            case 331:\n                sendLine(\"PASS \" + password);\n                resp = recvResponse();\n                switch(resp) {\n                    case 230:\n                        break;\n                    case 530:\n                        throw new FTPAuthenticationException();\n                    case 421:\n                        throw new FTPException(\"FTP server not avaliable (421)\");\n                    default:\n                        throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n                }\n                break;\n            case 530:\n                throw new FTPException(\"Invalid username\");\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n    }\n\n    private void initialDir(String path) throws FTPException, IOException {\n        if (path == null)\n            return;\n        int pos, oldPos = 0;\n        while (true) {\n            pos = path.indexOf('/', oldPos);\n            if (pos < 0)\n                break;\n            String comp = path.substring(oldPos, pos);\n            if (!chdir(comp))\n                throw new FTPException(\"Path not found: \" + path);\n            oldPos = pos + 1;\n        }\n    }\n\n    /**\n     * Logout and disconnect from the FTP server.\n     *\n     * After this method has been invoked, no other method may be invoked.\n     */\n    public void close() throws IOException {\n        sendLine(\"QUIT\");\n        int resp = recvResponse();\n        control.close();\n        control = null;\n    }\n\n    /**\n     * Change the current directory.\n     *\n     * @param dir  the directory to change into\n     *\n     * @return true if successful, false otherwise\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    private boolean chdir(String dir) throws FTPException, IOException {\n        if (DEBUG)\n            System.out.println(\"CWD \" + dir);\n        sendLine(\"CWD \" + dir);\n        int resp = recvResponse();\n        switch(resp) {\n            case 250:\n                return true;\n            case 550:\n                return false;\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n    }\n\n    /**\n     * Change the current directory to the parent directory.\n     *\n     * @return true if successful, false otherwise\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    private boolean cdup() throws FTPException, IOException {\n        if (DEBUG)\n            System.out.println(\"CDUP\");\n        sendLine(\"CDUP\");\n        int resp = recvResponse();\n        switch(resp) {\n            case 200:\n            case 250:\n                return true;\n            case 550:\n                return false;\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n    }\n\n    /**\n     * Create a new directory.\n     *\n     * @param dir  the directory to create\n     *\n     * @return true if successful, false otherwise\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    private boolean mkdir(String dir) throws FTPException, IOException {\n        if (DEBUG)\n            System.out.println(\"MKD \" + dir);\n        sendLine(\"MKD \" + dir);\n        int resp = recvResponse();\n        switch(resp) {\n            case 257:\n                return true;\n            case 550:\n                return false;\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n    }\n\n    /**\n     * Create a new file, or overwrite an existing file.\n     * Will create directories as nessesary.\n     *\n     * @param pathname  path to the file\n     *\n     * @return an OutputStream to write to, close() it when finished\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public OutputStream store(String pathname) throws FTPException, IOException {\n        return store(pathname, false);\n    }\n\n    /**\n     * Create a new file, or overwrite an existing file.\n     * Will create directories as nessesary.\n     *\n     * @param pathname  path to the file\n     * @param last  close the FTPClient after transferring this file\n     *\n     * @return an OutputStream to write to, close() it when finished\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public OutputStream store(String pathname, boolean last) throws FTPException, IOException {\n        int pos = pathname.lastIndexOf('/');\n        String path = pathname.substring(0, pos + 1);\n        String filename = pathname.substring(pos + 1);\n        changeDir(path);\n        return upload(\"STOR\", filename, last);\n    }\n\n    /**\n     * Create a new file, or append to an existing file.\n     * Will create directories as nessesary.\n     *\n     * @param pathname  path to the file\n     *\n     * @return an OutputStream to write to, close() it when finished\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public OutputStream append(String pathname) throws FTPException, IOException {\n        return append(pathname, false);\n    }\n\n    /**\n     * Create a new file, or append to an existing file.\n     * Will create directories as nessesary.\n     *\n     * @param pathname  path to the file\n     * @param last  close the FTPClient after transferring this file\n     *\n     * @return an OutputStream to write to, close() it when finished\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public OutputStream append(String pathname, boolean last) throws FTPException, IOException {\n        int pos = pathname.lastIndexOf('/');\n        String path = pathname.substring(0, pos + 1);\n        String filename = pathname.substring(pos + 1);\n        changeDir(path);\n        return upload(\"APPE\", filename, last);\n    }\n\n    /**\n     * Create a new file with an unique name.\n     * Will create directories as nessesary.\n     *\n     * @param path  path to the file, must end with '/' or be empty\n     *\n     * @return an OutputStream to write to, close() it when finished\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public OutputStream storeUnique(String path) throws FTPException, IOException {\n        return storeUnique(path, false);\n    }\n\n    /**\n     * Create a new file with an unique name.\n     * Will create directories as nessesary.\n     *\n     * @param path  path to the file, must end with '/' or be empty\n     * @param last  close the FTPClient after transferring this file\n     *\n     * @return an OutputStream to write to, close() it when finished\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public OutputStream storeUnique(String path, boolean last) throws FTPException, IOException {\n        changeDir(path);\n        return upload(\"STOU\", null, last);\n    }\n\n    private void changeDir(String path) throws FTPException, IOException {\n        if (!path.equals(lastPath)) {\n            if (path.length() > 0 && path.charAt(0) != '/')\n                path = '/' + path;\n            // change directory\n            for (int i = 0; i < lastPathLen; i++) if (!cdup())\n                throw new FTPException(\"Unable to change to parent directory\");\n            lastPathLen = 0;\n            int pos, oldPos = 1;\n            boolean mkd = false;\n            while (true) {\n                pos = path.indexOf('/', oldPos);\n                if (pos < 0)\n                    break;\n                lastPathLen++;\n                String comp = path.substring(oldPos, pos);\n                if (mkd) {\n                    if (!mkdir(comp))\n                        throw new FTPException(\"Unable to create directory: \" + comp);\n                    if (!chdir(comp))\n                        throw new FTPException(\"Unable to change into newly created directory: \" + comp);\n                } else {\n                    if (!chdir(comp)) {\n                        if (!mkdir(comp))\n                            throw new FTPException(\"Unable to create directory: \" + comp);\n                        if (!chdir(comp))\n                            throw new FTPException(\"Unable to change into newly created directory: \" + comp);\n                        mkd = true;\n                    }\n                }\n                oldPos = pos + 1;\n            }\n        }\n        lastPath = path;\n    }\n\n    private OutputStream upload(String cmd, String filename, boolean last) throws FTPException, IOException {\n        int resp;\n        sendLine(\"TYPE I\");\n        resp = recvResponse();\n        switch(resp) {\n            case 200:\n                break;\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n        sendLine(\"PASV\");\n        resp = recvResponse();\n        switch(resp) {\n            case 227:\n                break;\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n        InetAddress addr;\n        int port;\n        String s = respString.replace(',', '.');\n        int i = 3;\n        while (i < s.length() && !Character.isDigit(s.charAt(i))) i++;\n        if (i == s.length())\n            throw new FTPException(\"invalid response to PASV command\");\n        int c1 = s.indexOf('.', i);\n        if (c1 < 0)\n            throw new FTPException(\"invalid response to PASV command\");\n        int c2 = s.indexOf('.', c1 + 2);\n        if (c2 < 0)\n            throw new FTPException(\"invalid response to PASV command\");\n        int c3 = s.indexOf('.', c2 + 1);\n        if (c3 < 0)\n            throw new FTPException(\"invalid response to PASV command\");\n        int c4 = s.indexOf('.', c3 + 1);\n        if (c4 < 0)\n            throw new FTPException(\"invalid response to PASV command\");\n        int c5 = s.indexOf('.', c4 + 1);\n        if (c5 < 0)\n            throw new FTPException(\"invalid response to PASV command\");\n        try {\n            addr = InetAddress.getByName(s.substring(i, c4));\n            i = c5 + 1;\n            while (i < s.length() && Character.isDigit(s.charAt(i))) i++;\n            int portA = Integer.parseInt(s.substring(c4 + 1, c5));\n            int portB = Integer.parseInt(s.substring(c5 + 1, i));\n            port = (portA << 8) + portB;\n        } catch (UnknownHostException e) {\n            throw new FTPException(\"invalid response to PASV command\");\n        } catch (NumberFormatException e) {\n            throw new FTPException(\"invalid response to PASV command\");\n        }\n        if (cmd == null)\n            sendLine(cmd);\n        else\n            sendLine(cmd + \" \" + filename);\n        Socket data = new Socket(addr, port);\n        resp = recvResponse();\n        switch(resp) {\n            case 125:\n            case 150:\n                break;\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n        return new FTPOutputStream(data.getOutputStream(), data, last ? this : null);\n    }\n\n    /**\n     * Deletes a file.\n     *\n     * @param pathname  path to the file\n     *\n     * @return true if successful, false otherwise (file didn't exsist)\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public boolean deleteFile(String pathname) throws FTPException, IOException {\n        String path;\n        String fn;\n        int pos = pathname.lastIndexOf('/');\n        path = pathname.substring(0, pos + 1);\n        fn = pathname.substring(pos + 1);\n        if (!path.equals(lastPath)) {\n            // change directory\n            for (int i = 0; i < lastPathLen; i++) if (!cdup())\n                throw new FTPException(\"Unable to change to parent directory\");\n            lastPathLen = 0;\n            int oldPos = 1;\n            while (true) {\n                pos = path.indexOf('/', oldPos);\n                if (pos < 0)\n                    break;\n                lastPathLen++;\n                String comp = path.substring(oldPos, pos);\n                if (!chdir(comp)) {\n                    // file doesn't exist\n                    return false;\n                }\n                oldPos = pos + 1;\n            }\n        }\n        lastPath = path;\n        sendLine(\"DELE \" + fn);\n        int resp = recvResponse();\n        switch(resp) {\n            case 250:\n                return true;\n            case 550:\n                return false;\n            case 450:\n                throw new FTPException(\"Unable to delete file: \" + respString);\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n    }\n\n    class FTPOutputStream extends OutputStream {\n\n        private Socket data;\n\n        private OutputStream out;\n\n        private FTPClient ftp;\n\n        FTPOutputStream(OutputStream out, Socket data, FTPClient ftp) {\n            this.out = out;\n            this.data = data;\n            this.ftp = ftp;\n        }\n\n        public void write(int b) throws IOException {\n            out.write(b);\n        }\n\n        public void write(byte[] b) throws IOException {\n            out.write(b);\n        }\n\n        public void write(byte[] b, int off, int len) throws IOException {\n            out.write(b, off, len);\n        }\n\n        public void flush() throws IOException {\n            out.flush();\n        }\n\n        public void close() throws IOException {\n            out.close();\n            if (data != null) {\n                data.close();\n                data = null;\n            }\n            theLoop: while (true) {\n                int resp = recvResponse();\n                switch(resp) {\n                    case 226:\n                    case 250:\n                        break;\n                    case 425:\n                    case 426:\n                    case 451:\n                    case 551:\n                    case 552:\n                        throw new FTPException(\"Error in file transfer (\" + resp + \")\");\n                    case 421:\n                        throw new FTPException(\"FTP server not avaliable (421)\");\n                    default:\n                        throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n                }\n                break;\n            }\n            if (ftp != null)\n                ftp.close();\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/ftp/FTPClientTest4.java",
		"test_prompt": "// FTPClientTest4.java\npackage nu.staldal.ftp;\n\nimport java.io.*;\nimport java.net.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FTPClient}.\n* It contains ten unit test cases for the {@link FTPClient#storeUnique(String)} method.\n*/\nclass FTPClientTest4 {"
	},
	{
		"original_code": "// FTPClient.java\n/*\n * Copyright (c) 2002, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.ftp;\n\nimport java.io.*;\nimport java.net.*;\n\n/**\n * An FTP client. See RFC-959.\n *\n * Pathnames must be specified using '/' for directory separator.\n * Passive mode will be used for all transfers.\n * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in\n * progress.\n *\n * <strong>Note:</strong> This class will transmit password in clear text over\n * the network.\n */\npublic class FTPClient {\n\n    private static final boolean DEBUG = false;\n\n    private Socket control;\n\n    private InputStream controlIn;\n\n    private OutputStream controlOut;\n\n    private String respString;\n\n    private String lastPath = \"\";\n\n    private int lastPathLen = 0;\n\n    private void sendLine(String str) throws IOException {\n        controlOut.write(str.getBytes(\"US-ASCII\"));\n        controlOut.write('\\r');\n        controlOut.write('\\n');\n        controlOut.flush();\n    }\n\n    private String recvLine() throws EOFException, IOException {\n        StringBuffer sb = new StringBuffer();\n        while (true) {\n            int i = controlIn.read();\n            if (i < 0)\n                throw new EOFException(\"Unexpected EOF when reading socket\");\n            byte b = (byte) i;\n            if (b == '\\n')\n                break;\n            if (b != '\\r')\n                sb.append((char) b);\n        }\n        return sb.toString();\n    }\n\n    private int recvResponse() throws EOFException, IOException {\n        respString = recvLine();\n        String code = respString.substring(0, 3);\n        if (// multiline response\n        respString.charAt(3) == '-') {\n            String endMark = code + ' ';\n            while (true) {\n                respString = recvLine();\n                if (respString.startsWith(endMark))\n                    break;\n            }\n        }\n        return Integer.parseInt(code);\n    }\n\n    /**\n     * Connect to an FTP server and login.\n     *\n     * @param url  an URL specifying host, port, username and optionally\n     *             an initial path to change to\n     * @param password  the password to use for logging in\n     *\n     * @throws MalformedURLException  if there are any syntactic error in the URL\n     * @throws UnknownHostException  if the hostname specified doesn't exist\n     * @throws FTPAuthenticationException  if the password is wrong\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public FTPClient(String url, String password) throws MalformedURLException, UnknownHostException, FTPAuthenticationException, FTPException, IOException {\n        if (!url.startsWith(\"ftp://\"))\n            throw new MalformedURLException(url);\n        int userPos = 5;\n        int hostPos = url.indexOf('@', userPos + 1);\n        if (hostPos < 0)\n            throw new MalformedURLException(url);\n        int portPos = url.indexOf(':', hostPos + 1);\n        int pathPos = url.indexOf('/', ((portPos < 0) ? hostPos : portPos) + 1);\n        String username;\n        String host;\n        int port;\n        String path;\n        try {\n            username = url.substring(userPos + 1, hostPos);\n            host = url.substring(hostPos + 1, (portPos < 0) ? pathPos : portPos);\n            port = (portPos < 0) ? 21 : Integer.parseInt(url.substring(portPos + 1, pathPos));\n            path = url.substring(pathPos + 1);\n        } catch (NumberFormatException e) {\n            throw new MalformedURLException(url);\n        }\n        if (port < 0 || port > 65535 || username.length() < 1 || host.length() < 1 || (path.length() > 0 && path.charAt(path.length() - 1) != '/'))\n            throw new MalformedURLException(url);\n        connect(host, port, username, password);\n        initialDir(path);\n    }\n\n    /**\n     * Connect to an FTP server and login.\n     *\n     * @param host  the host to connect to, may be a domain name or IP address\n     * @param port  the control channel port (default 21)\n     * @param username  the username to use for logging in\n     * @param password  the password to use for logging in\n     * @param path  initial path, realtive to home directory unless starting with '/',\n     *              may be <code>null</code> to use home directory\n     *\n     * @throws UnknownHostException  if the hostname specified doesn't exist\n     * @throws FTPAuthenticationException  if the password is wrong\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public FTPClient(String host, int port, String username, String password, String path) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {\n        connect(host, port, username, password);\n        initialDir(path);\n    }\n\n    private void connect(String host, int port, String username, String password) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {\n        if (port < 0 || port > 65535)\n            port = 21;\n        control = new Socket(host, port);\n        controlIn = control.getInputStream();\n        controlOut = control.getOutputStream();\n        int resp;\n        // Receive greeting message\n        greeting: while (true) {\n            resp = recvResponse();\n            switch(resp) {\n                case 120:\n                    continue greeting;\n                case 220:\n                    break greeting;\n                case 421:\n                    throw new FTPException(\"FTP server not avaliable (421)\");\n                default:\n                    throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n            }\n        }\n        sendLine(\"USER \" + username);\n        resp = recvResponse();\n        switch(resp) {\n            case 230:\n                break;\n            case 331:\n                sendLine(\"PASS \" + password);\n                resp = recvResponse();\n                switch(resp) {\n                    case 230:\n                        break;\n                    case 530:\n                        throw new FTPAuthenticationException();\n                    case 421:\n                        throw new FTPException(\"FTP server not avaliable (421)\");\n                    default:\n                        throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n                }\n                break;\n            case 530:\n                throw new FTPException(\"Invalid username\");\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n    }\n\n    private void initialDir(String path) throws FTPException, IOException {\n        if (path == null)\n            return;\n        int pos, oldPos = 0;\n        while (true) {\n            pos = path.indexOf('/', oldPos);\n            if (pos < 0)\n                break;\n            String comp = path.substring(oldPos, pos);\n            if (!chdir(comp))\n                throw new FTPException(\"Path not found: \" + path);\n            oldPos = pos + 1;\n        }\n    }\n\n    /**\n     * Logout and disconnect from the FTP server.\n     *\n     * After this method has been invoked, no other method may be invoked.\n     */\n    public void close() throws IOException {\n        sendLine(\"QUIT\");\n        int resp = recvResponse();\n        control.close();\n        control = null;\n    }\n\n    /**\n     * Change the current directory.\n     *\n     * @param dir  the directory to change into\n     *\n     * @return true if successful, false otherwise\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    private boolean chdir(String dir) throws FTPException, IOException {\n        if (DEBUG)\n            System.out.println(\"CWD \" + dir);\n        sendLine(\"CWD \" + dir);\n        int resp = recvResponse();\n        switch(resp) {\n            case 250:\n                return true;\n            case 550:\n                return false;\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n    }\n\n    /**\n     * Change the current directory to the parent directory.\n     *\n     * @return true if successful, false otherwise\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    private boolean cdup() throws FTPException, IOException {\n        if (DEBUG)\n            System.out.println(\"CDUP\");\n        sendLine(\"CDUP\");\n        int resp = recvResponse();\n        switch(resp) {\n            case 200:\n            case 250:\n                return true;\n            case 550:\n                return false;\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n    }\n\n    /**\n     * Create a new directory.\n     *\n     * @param dir  the directory to create\n     *\n     * @return true if successful, false otherwise\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    private boolean mkdir(String dir) throws FTPException, IOException {\n        if (DEBUG)\n            System.out.println(\"MKD \" + dir);\n        sendLine(\"MKD \" + dir);\n        int resp = recvResponse();\n        switch(resp) {\n            case 257:\n                return true;\n            case 550:\n                return false;\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n    }\n\n    /**\n     * Create a new file, or overwrite an existing file.\n     * Will create directories as nessesary.\n     *\n     * @param pathname  path to the file\n     *\n     * @return an OutputStream to write to, close() it when finished\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public OutputStream store(String pathname) throws FTPException, IOException {\n        return store(pathname, false);\n    }\n\n    /**\n     * Create a new file, or overwrite an existing file.\n     * Will create directories as nessesary.\n     *\n     * @param pathname  path to the file\n     * @param last  close the FTPClient after transferring this file\n     *\n     * @return an OutputStream to write to, close() it when finished\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public OutputStream store(String pathname, boolean last) throws FTPException, IOException {\n        int pos = pathname.lastIndexOf('/');\n        String path = pathname.substring(0, pos + 1);\n        String filename = pathname.substring(pos + 1);\n        changeDir(path);\n        return upload(\"STOR\", filename, last);\n    }\n\n    /**\n     * Create a new file, or append to an existing file.\n     * Will create directories as nessesary.\n     *\n     * @param pathname  path to the file\n     *\n     * @return an OutputStream to write to, close() it when finished\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public OutputStream append(String pathname) throws FTPException, IOException {\n        return append(pathname, false);\n    }\n\n    /**\n     * Create a new file, or append to an existing file.\n     * Will create directories as nessesary.\n     *\n     * @param pathname  path to the file\n     * @param last  close the FTPClient after transferring this file\n     *\n     * @return an OutputStream to write to, close() it when finished\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public OutputStream append(String pathname, boolean last) throws FTPException, IOException {\n        int pos = pathname.lastIndexOf('/');\n        String path = pathname.substring(0, pos + 1);\n        String filename = pathname.substring(pos + 1);\n        changeDir(path);\n        return upload(\"APPE\", filename, last);\n    }\n\n    /**\n     * Create a new file with an unique name.\n     * Will create directories as nessesary.\n     *\n     * @param path  path to the file, must end with '/' or be empty\n     *\n     * @return an OutputStream to write to, close() it when finished\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public OutputStream storeUnique(String path) throws FTPException, IOException {\n        return storeUnique(path, false);\n    }\n\n    /**\n     * Create a new file with an unique name.\n     * Will create directories as nessesary.\n     *\n     * @param path  path to the file, must end with '/' or be empty\n     * @param last  close the FTPClient after transferring this file\n     *\n     * @return an OutputStream to write to, close() it when finished\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public OutputStream storeUnique(String path, boolean last) throws FTPException, IOException {\n        changeDir(path);\n        return upload(\"STOU\", null, last);\n    }\n\n    private void changeDir(String path) throws FTPException, IOException {\n        if (!path.equals(lastPath)) {\n            if (path.length() > 0 && path.charAt(0) != '/')\n                path = '/' + path;\n            // change directory\n            for (int i = 0; i < lastPathLen; i++) if (!cdup())\n                throw new FTPException(\"Unable to change to parent directory\");\n            lastPathLen = 0;\n            int pos, oldPos = 1;\n            boolean mkd = false;\n            while (true) {\n                pos = path.indexOf('/', oldPos);\n                if (pos < 0)\n                    break;\n                lastPathLen++;\n                String comp = path.substring(oldPos, pos);\n                if (mkd) {\n                    if (!mkdir(comp))\n                        throw new FTPException(\"Unable to create directory: \" + comp);\n                    if (!chdir(comp))\n                        throw new FTPException(\"Unable to change into newly created directory: \" + comp);\n                } else {\n                    if (!chdir(comp)) {\n                        if (!mkdir(comp))\n                            throw new FTPException(\"Unable to create directory: \" + comp);\n                        if (!chdir(comp))\n                            throw new FTPException(\"Unable to change into newly created directory: \" + comp);\n                        mkd = true;\n                    }\n                }\n                oldPos = pos + 1;\n            }\n        }\n        lastPath = path;\n    }\n\n    private OutputStream upload(String cmd, String filename, boolean last) throws FTPException, IOException {\n        int resp;\n        sendLine(\"TYPE I\");\n        resp = recvResponse();\n        switch(resp) {\n            case 200:\n                break;\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n        sendLine(\"PASV\");\n        resp = recvResponse();\n        switch(resp) {\n            case 227:\n                break;\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n        InetAddress addr;\n        int port;\n        String s = respString.replace(',', '.');\n        int i = 3;\n        while (i < s.length() && !Character.isDigit(s.charAt(i))) i++;\n        if (i == s.length())\n            throw new FTPException(\"invalid response to PASV command\");\n        int c1 = s.indexOf('.', i);\n        if (c1 < 0)\n            throw new FTPException(\"invalid response to PASV command\");\n        int c2 = s.indexOf('.', c1 + 2);\n        if (c2 < 0)\n            throw new FTPException(\"invalid response to PASV command\");\n        int c3 = s.indexOf('.', c2 + 1);\n        if (c3 < 0)\n            throw new FTPException(\"invalid response to PASV command\");\n        int c4 = s.indexOf('.', c3 + 1);\n        if (c4 < 0)\n            throw new FTPException(\"invalid response to PASV command\");\n        int c5 = s.indexOf('.', c4 + 1);\n        if (c5 < 0)\n            throw new FTPException(\"invalid response to PASV command\");\n        try {\n            addr = InetAddress.getByName(s.substring(i, c4));\n            i = c5 + 1;\n            while (i < s.length() && Character.isDigit(s.charAt(i))) i++;\n            int portA = Integer.parseInt(s.substring(c4 + 1, c5));\n            int portB = Integer.parseInt(s.substring(c5 + 1, i));\n            port = (portA << 8) + portB;\n        } catch (UnknownHostException e) {\n            throw new FTPException(\"invalid response to PASV command\");\n        } catch (NumberFormatException e) {\n            throw new FTPException(\"invalid response to PASV command\");\n        }\n        if (cmd == null)\n            sendLine(cmd);\n        else\n            sendLine(cmd + \" \" + filename);\n        Socket data = new Socket(addr, port);\n        resp = recvResponse();\n        switch(resp) {\n            case 125:\n            case 150:\n                break;\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n        return new FTPOutputStream(data.getOutputStream(), data, last ? this : null);\n    }\n\n    /**\n     * Deletes a file.\n     *\n     * @param pathname  path to the file\n     *\n     * @return true if successful, false otherwise (file didn't exsist)\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public boolean deleteFile(String pathname) throws FTPException, IOException {\n        String path;\n        String fn;\n        int pos = pathname.lastIndexOf('/');\n        path = pathname.substring(0, pos + 1);\n        fn = pathname.substring(pos + 1);\n        if (!path.equals(lastPath)) {\n            // change directory\n            for (int i = 0; i < lastPathLen; i++) if (!cdup())\n                throw new FTPException(\"Unable to change to parent directory\");\n            lastPathLen = 0;\n            int oldPos = 1;\n            while (true) {\n                pos = path.indexOf('/', oldPos);\n                if (pos < 0)\n                    break;\n                lastPathLen++;\n                String comp = path.substring(oldPos, pos);\n                if (!chdir(comp)) {\n                    // file doesn't exist\n                    return false;\n                }\n                oldPos = pos + 1;\n            }\n        }\n        lastPath = path;\n        sendLine(\"DELE \" + fn);\n        int resp = recvResponse();\n        switch(resp) {\n            case 250:\n                return true;\n            case 550:\n                return false;\n            case 450:\n                throw new FTPException(\"Unable to delete file: \" + respString);\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n    }\n\n    class FTPOutputStream extends OutputStream {\n\n        private Socket data;\n\n        private OutputStream out;\n\n        private FTPClient ftp;\n\n        FTPOutputStream(OutputStream out, Socket data, FTPClient ftp) {\n            this.out = out;\n            this.data = data;\n            this.ftp = ftp;\n        }\n\n        public void write(int b) throws IOException {\n            out.write(b);\n        }\n\n        public void write(byte[] b) throws IOException {\n            out.write(b);\n        }\n\n        public void write(byte[] b, int off, int len) throws IOException {\n            out.write(b, off, len);\n        }\n\n        public void flush() throws IOException {\n            out.flush();\n        }\n\n        public void close() throws IOException {\n            out.close();\n            if (data != null) {\n                data.close();\n                data = null;\n            }\n            theLoop: while (true) {\n                int resp = recvResponse();\n                switch(resp) {\n                    case 226:\n                    case 250:\n                        break;\n                    case 425:\n                    case 426:\n                    case 451:\n                    case 551:\n                    case 552:\n                        throw new FTPException(\"Error in file transfer (\" + resp + \")\");\n                    case 421:\n                        throw new FTPException(\"FTP server not avaliable (421)\");\n                    default:\n                        throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n                }\n                break;\n            }\n            if (ftp != null)\n                ftp.close();\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/ftp/FTPClientTest5.java",
		"test_prompt": "// FTPClientTest5.java\npackage nu.staldal.ftp;\n\nimport java.io.*;\nimport java.net.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FTPClient}.\n* It contains ten unit test cases for the {@link FTPClient#storeUnique(String, boolean)} method.\n*/\nclass FTPClientTest5 {"
	},
	{
		"original_code": "// FTPClient.java\n/*\n * Copyright (c) 2002, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.ftp;\n\nimport java.io.*;\nimport java.net.*;\n\n/**\n * An FTP client. See RFC-959.\n *\n * Pathnames must be specified using '/' for directory separator.\n * Passive mode will be used for all transfers.\n * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in\n * progress.\n *\n * <strong>Note:</strong> This class will transmit password in clear text over\n * the network.\n */\npublic class FTPClient {\n\n    private static final boolean DEBUG = false;\n\n    private Socket control;\n\n    private InputStream controlIn;\n\n    private OutputStream controlOut;\n\n    private String respString;\n\n    private String lastPath = \"\";\n\n    private int lastPathLen = 0;\n\n    private void sendLine(String str) throws IOException {\n        controlOut.write(str.getBytes(\"US-ASCII\"));\n        controlOut.write('\\r');\n        controlOut.write('\\n');\n        controlOut.flush();\n    }\n\n    private String recvLine() throws EOFException, IOException {\n        StringBuffer sb = new StringBuffer();\n        while (true) {\n            int i = controlIn.read();\n            if (i < 0)\n                throw new EOFException(\"Unexpected EOF when reading socket\");\n            byte b = (byte) i;\n            if (b == '\\n')\n                break;\n            if (b != '\\r')\n                sb.append((char) b);\n        }\n        return sb.toString();\n    }\n\n    private int recvResponse() throws EOFException, IOException {\n        respString = recvLine();\n        String code = respString.substring(0, 3);\n        if (// multiline response\n        respString.charAt(3) == '-') {\n            String endMark = code + ' ';\n            while (true) {\n                respString = recvLine();\n                if (respString.startsWith(endMark))\n                    break;\n            }\n        }\n        return Integer.parseInt(code);\n    }\n\n    /**\n     * Connect to an FTP server and login.\n     *\n     * @param url  an URL specifying host, port, username and optionally\n     *             an initial path to change to\n     * @param password  the password to use for logging in\n     *\n     * @throws MalformedURLException  if there are any syntactic error in the URL\n     * @throws UnknownHostException  if the hostname specified doesn't exist\n     * @throws FTPAuthenticationException  if the password is wrong\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public FTPClient(String url, String password) throws MalformedURLException, UnknownHostException, FTPAuthenticationException, FTPException, IOException {\n        if (!url.startsWith(\"ftp://\"))\n            throw new MalformedURLException(url);\n        int userPos = 5;\n        int hostPos = url.indexOf('@', userPos + 1);\n        if (hostPos < 0)\n            throw new MalformedURLException(url);\n        int portPos = url.indexOf(':', hostPos + 1);\n        int pathPos = url.indexOf('/', ((portPos < 0) ? hostPos : portPos) + 1);\n        String username;\n        String host;\n        int port;\n        String path;\n        try {\n            username = url.substring(userPos + 1, hostPos);\n            host = url.substring(hostPos + 1, (portPos < 0) ? pathPos : portPos);\n            port = (portPos < 0) ? 21 : Integer.parseInt(url.substring(portPos + 1, pathPos));\n            path = url.substring(pathPos + 1);\n        } catch (NumberFormatException e) {\n            throw new MalformedURLException(url);\n        }\n        if (port < 0 || port > 65535 || username.length() < 1 || host.length() < 1 || (path.length() > 0 && path.charAt(path.length() - 1) != '/'))\n            throw new MalformedURLException(url);\n        connect(host, port, username, password);\n        initialDir(path);\n    }\n\n    /**\n     * Connect to an FTP server and login.\n     *\n     * @param host  the host to connect to, may be a domain name or IP address\n     * @param port  the control channel port (default 21)\n     * @param username  the username to use for logging in\n     * @param password  the password to use for logging in\n     * @param path  initial path, realtive to home directory unless starting with '/',\n     *              may be <code>null</code> to use home directory\n     *\n     * @throws UnknownHostException  if the hostname specified doesn't exist\n     * @throws FTPAuthenticationException  if the password is wrong\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public FTPClient(String host, int port, String username, String password, String path) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {\n        connect(host, port, username, password);\n        initialDir(path);\n    }\n\n    private void connect(String host, int port, String username, String password) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {\n        if (port < 0 || port > 65535)\n            port = 21;\n        control = new Socket(host, port);\n        controlIn = control.getInputStream();\n        controlOut = control.getOutputStream();\n        int resp;\n        // Receive greeting message\n        greeting: while (true) {\n            resp = recvResponse();\n            switch(resp) {\n                case 120:\n                    continue greeting;\n                case 220:\n                    break greeting;\n                case 421:\n                    throw new FTPException(\"FTP server not avaliable (421)\");\n                default:\n                    throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n            }\n        }\n        sendLine(\"USER \" + username);\n        resp = recvResponse();\n        switch(resp) {\n            case 230:\n                break;\n            case 331:\n                sendLine(\"PASS \" + password);\n                resp = recvResponse();\n                switch(resp) {\n                    case 230:\n                        break;\n                    case 530:\n                        throw new FTPAuthenticationException();\n                    case 421:\n                        throw new FTPException(\"FTP server not avaliable (421)\");\n                    default:\n                        throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n                }\n                break;\n            case 530:\n                throw new FTPException(\"Invalid username\");\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n    }\n\n    private void initialDir(String path) throws FTPException, IOException {\n        if (path == null)\n            return;\n        int pos, oldPos = 0;\n        while (true) {\n            pos = path.indexOf('/', oldPos);\n            if (pos < 0)\n                break;\n            String comp = path.substring(oldPos, pos);\n            if (!chdir(comp))\n                throw new FTPException(\"Path not found: \" + path);\n            oldPos = pos + 1;\n        }\n    }\n\n    /**\n     * Logout and disconnect from the FTP server.\n     *\n     * After this method has been invoked, no other method may be invoked.\n     */\n    public void close() throws IOException {\n        sendLine(\"QUIT\");\n        int resp = recvResponse();\n        control.close();\n        control = null;\n    }\n\n    /**\n     * Change the current directory.\n     *\n     * @param dir  the directory to change into\n     *\n     * @return true if successful, false otherwise\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    private boolean chdir(String dir) throws FTPException, IOException {\n        if (DEBUG)\n            System.out.println(\"CWD \" + dir);\n        sendLine(\"CWD \" + dir);\n        int resp = recvResponse();\n        switch(resp) {\n            case 250:\n                return true;\n            case 550:\n                return false;\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n    }\n\n    /**\n     * Change the current directory to the parent directory.\n     *\n     * @return true if successful, false otherwise\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    private boolean cdup() throws FTPException, IOException {\n        if (DEBUG)\n            System.out.println(\"CDUP\");\n        sendLine(\"CDUP\");\n        int resp = recvResponse();\n        switch(resp) {\n            case 200:\n            case 250:\n                return true;\n            case 550:\n                return false;\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n    }\n\n    /**\n     * Create a new directory.\n     *\n     * @param dir  the directory to create\n     *\n     * @return true if successful, false otherwise\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    private boolean mkdir(String dir) throws FTPException, IOException {\n        if (DEBUG)\n            System.out.println(\"MKD \" + dir);\n        sendLine(\"MKD \" + dir);\n        int resp = recvResponse();\n        switch(resp) {\n            case 257:\n                return true;\n            case 550:\n                return false;\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n    }\n\n    /**\n     * Create a new file, or overwrite an existing file.\n     * Will create directories as nessesary.\n     *\n     * @param pathname  path to the file\n     *\n     * @return an OutputStream to write to, close() it when finished\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public OutputStream store(String pathname) throws FTPException, IOException {\n        return store(pathname, false);\n    }\n\n    /**\n     * Create a new file, or overwrite an existing file.\n     * Will create directories as nessesary.\n     *\n     * @param pathname  path to the file\n     * @param last  close the FTPClient after transferring this file\n     *\n     * @return an OutputStream to write to, close() it when finished\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public OutputStream store(String pathname, boolean last) throws FTPException, IOException {\n        int pos = pathname.lastIndexOf('/');\n        String path = pathname.substring(0, pos + 1);\n        String filename = pathname.substring(pos + 1);\n        changeDir(path);\n        return upload(\"STOR\", filename, last);\n    }\n\n    /**\n     * Create a new file, or append to an existing file.\n     * Will create directories as nessesary.\n     *\n     * @param pathname  path to the file\n     *\n     * @return an OutputStream to write to, close() it when finished\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public OutputStream append(String pathname) throws FTPException, IOException {\n        return append(pathname, false);\n    }\n\n    /**\n     * Create a new file, or append to an existing file.\n     * Will create directories as nessesary.\n     *\n     * @param pathname  path to the file\n     * @param last  close the FTPClient after transferring this file\n     *\n     * @return an OutputStream to write to, close() it when finished\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public OutputStream append(String pathname, boolean last) throws FTPException, IOException {\n        int pos = pathname.lastIndexOf('/');\n        String path = pathname.substring(0, pos + 1);\n        String filename = pathname.substring(pos + 1);\n        changeDir(path);\n        return upload(\"APPE\", filename, last);\n    }\n\n    /**\n     * Create a new file with an unique name.\n     * Will create directories as nessesary.\n     *\n     * @param path  path to the file, must end with '/' or be empty\n     *\n     * @return an OutputStream to write to, close() it when finished\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public OutputStream storeUnique(String path) throws FTPException, IOException {\n        return storeUnique(path, false);\n    }\n\n    /**\n     * Create a new file with an unique name.\n     * Will create directories as nessesary.\n     *\n     * @param path  path to the file, must end with '/' or be empty\n     * @param last  close the FTPClient after transferring this file\n     *\n     * @return an OutputStream to write to, close() it when finished\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public OutputStream storeUnique(String path, boolean last) throws FTPException, IOException {\n        changeDir(path);\n        return upload(\"STOU\", null, last);\n    }\n\n    private void changeDir(String path) throws FTPException, IOException {\n        if (!path.equals(lastPath)) {\n            if (path.length() > 0 && path.charAt(0) != '/')\n                path = '/' + path;\n            // change directory\n            for (int i = 0; i < lastPathLen; i++) if (!cdup())\n                throw new FTPException(\"Unable to change to parent directory\");\n            lastPathLen = 0;\n            int pos, oldPos = 1;\n            boolean mkd = false;\n            while (true) {\n                pos = path.indexOf('/', oldPos);\n                if (pos < 0)\n                    break;\n                lastPathLen++;\n                String comp = path.substring(oldPos, pos);\n                if (mkd) {\n                    if (!mkdir(comp))\n                        throw new FTPException(\"Unable to create directory: \" + comp);\n                    if (!chdir(comp))\n                        throw new FTPException(\"Unable to change into newly created directory: \" + comp);\n                } else {\n                    if (!chdir(comp)) {\n                        if (!mkdir(comp))\n                            throw new FTPException(\"Unable to create directory: \" + comp);\n                        if (!chdir(comp))\n                            throw new FTPException(\"Unable to change into newly created directory: \" + comp);\n                        mkd = true;\n                    }\n                }\n                oldPos = pos + 1;\n            }\n        }\n        lastPath = path;\n    }\n\n    private OutputStream upload(String cmd, String filename, boolean last) throws FTPException, IOException {\n        int resp;\n        sendLine(\"TYPE I\");\n        resp = recvResponse();\n        switch(resp) {\n            case 200:\n                break;\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n        sendLine(\"PASV\");\n        resp = recvResponse();\n        switch(resp) {\n            case 227:\n                break;\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n        InetAddress addr;\n        int port;\n        String s = respString.replace(',', '.');\n        int i = 3;\n        while (i < s.length() && !Character.isDigit(s.charAt(i))) i++;\n        if (i == s.length())\n            throw new FTPException(\"invalid response to PASV command\");\n        int c1 = s.indexOf('.', i);\n        if (c1 < 0)\n            throw new FTPException(\"invalid response to PASV command\");\n        int c2 = s.indexOf('.', c1 + 2);\n        if (c2 < 0)\n            throw new FTPException(\"invalid response to PASV command\");\n        int c3 = s.indexOf('.', c2 + 1);\n        if (c3 < 0)\n            throw new FTPException(\"invalid response to PASV command\");\n        int c4 = s.indexOf('.', c3 + 1);\n        if (c4 < 0)\n            throw new FTPException(\"invalid response to PASV command\");\n        int c5 = s.indexOf('.', c4 + 1);\n        if (c5 < 0)\n            throw new FTPException(\"invalid response to PASV command\");\n        try {\n            addr = InetAddress.getByName(s.substring(i, c4));\n            i = c5 + 1;\n            while (i < s.length() && Character.isDigit(s.charAt(i))) i++;\n            int portA = Integer.parseInt(s.substring(c4 + 1, c5));\n            int portB = Integer.parseInt(s.substring(c5 + 1, i));\n            port = (portA << 8) + portB;\n        } catch (UnknownHostException e) {\n            throw new FTPException(\"invalid response to PASV command\");\n        } catch (NumberFormatException e) {\n            throw new FTPException(\"invalid response to PASV command\");\n        }\n        if (cmd == null)\n            sendLine(cmd);\n        else\n            sendLine(cmd + \" \" + filename);\n        Socket data = new Socket(addr, port);\n        resp = recvResponse();\n        switch(resp) {\n            case 125:\n            case 150:\n                break;\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n        return new FTPOutputStream(data.getOutputStream(), data, last ? this : null);\n    }\n\n    /**\n     * Deletes a file.\n     *\n     * @param pathname  path to the file\n     *\n     * @return true if successful, false otherwise (file didn't exsist)\n     * @throws FTPException if any FTP protocol error occurs\n     * @throws IOException if any other IO error occurs\n     */\n    public boolean deleteFile(String pathname) throws FTPException, IOException {\n        String path;\n        String fn;\n        int pos = pathname.lastIndexOf('/');\n        path = pathname.substring(0, pos + 1);\n        fn = pathname.substring(pos + 1);\n        if (!path.equals(lastPath)) {\n            // change directory\n            for (int i = 0; i < lastPathLen; i++) if (!cdup())\n                throw new FTPException(\"Unable to change to parent directory\");\n            lastPathLen = 0;\n            int oldPos = 1;\n            while (true) {\n                pos = path.indexOf('/', oldPos);\n                if (pos < 0)\n                    break;\n                lastPathLen++;\n                String comp = path.substring(oldPos, pos);\n                if (!chdir(comp)) {\n                    // file doesn't exist\n                    return false;\n                }\n                oldPos = pos + 1;\n            }\n        }\n        lastPath = path;\n        sendLine(\"DELE \" + fn);\n        int resp = recvResponse();\n        switch(resp) {\n            case 250:\n                return true;\n            case 550:\n                return false;\n            case 450:\n                throw new FTPException(\"Unable to delete file: \" + respString);\n            case 421:\n                throw new FTPException(\"FTP server not avaliable (421)\");\n            default:\n                throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n        }\n    }\n\n    class FTPOutputStream extends OutputStream {\n\n        private Socket data;\n\n        private OutputStream out;\n\n        private FTPClient ftp;\n\n        FTPOutputStream(OutputStream out, Socket data, FTPClient ftp) {\n            this.out = out;\n            this.data = data;\n            this.ftp = ftp;\n        }\n\n        public void write(int b) throws IOException {\n            out.write(b);\n        }\n\n        public void write(byte[] b) throws IOException {\n            out.write(b);\n        }\n\n        public void write(byte[] b, int off, int len) throws IOException {\n            out.write(b, off, len);\n        }\n\n        public void flush() throws IOException {\n            out.flush();\n        }\n\n        public void close() throws IOException {\n            out.close();\n            if (data != null) {\n                data.close();\n                data = null;\n            }\n            theLoop: while (true) {\n                int resp = recvResponse();\n                switch(resp) {\n                    case 226:\n                    case 250:\n                        break;\n                    case 425:\n                    case 426:\n                    case 451:\n                    case 551:\n                    case 552:\n                        throw new FTPException(\"Error in file transfer (\" + resp + \")\");\n                    case 421:\n                        throw new FTPException(\"FTP server not avaliable (421)\");\n                    default:\n                        throw new FTPException(\"Unexpected response from FTP server: \" + respString);\n                }\n                break;\n            }\n            if (ftp != null)\n                ftp.close();\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/ftp/FTPClientTest6.java",
		"test_prompt": "// FTPClientTest6.java\npackage nu.staldal.ftp;\n\nimport java.io.*;\nimport java.net.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FTPClient}.\n* It contains ten unit test cases for the {@link FTPClient#deleteFile(String)} method.\n*/\nclass FTPClientTest6 {"
	},
	{
		"original_code": "// Utils.java\n/*\n * Copyright (c) 2002, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.util;\n\n/**\n * Some utility methods. All methods in this class are static.\n */\npublic final class Utils {\n\n    /**\n     * Private default constructor to prevent instantiation.\n     */\n    private Utils() {\n    }\n\n    /**\n     * Encode a path name or URL into a filename.\n     *\n     * The encoding function is not intended to be inversible.\n     */\n    public static String encodePath(String path) {\n        StringBuffer sb = new StringBuffer(path.length());\n        for (int i = 0; i < path.length(); i++) {\n            char c = path.charAt(i);\n            switch(c) {\n                case '-':\n                    sb.append(\"--\");\n                    break;\n                case '_':\n                    sb.append(\"__\");\n                    break;\n                case '$':\n                    sb.append(\"$$\");\n                    break;\n                case '~':\n                    sb.append(\"~~\");\n                    break;\n                case '/':\n                    sb.append('-');\n                    break;\n                case '\\\\':\n                    sb.append('-');\n                    break;\n                case '*':\n                    sb.append('_');\n                    break;\n                case '?':\n                    sb.append('$');\n                    break;\n                case ':':\n                    sb.append('~');\n                    break;\n                default:\n                    sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Encode a path name or URL into a Java identifier.\n     *\n     * The encoding function is not intended to be inversible.\n     */\n    public static String encodePathAsIdentifier(String path) {\n        StringBuffer sb = new StringBuffer(path.length());\n        char c = path.charAt(0);\n        if (Character.isJavaIdentifierStart(c))\n            sb.append(c);\n        else\n            sb.append(\"_\" + ((int) c) + \"_\");\n        for (int i = 1; i < path.length(); i++) {\n            c = path.charAt(i);\n            if (Character.isJavaIdentifierPart(c))\n                sb.append(c);\n            else\n                sb.append(\"_\" + ((int) c) + \"_\");\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Check whether an URL is absolute.\n     * Returns true if the URL contains at least one colon, and\n     * the first colon is before the first slash (if any).\n     */\n    public static boolean absoluteURL(String url) {\n        int colon = url.indexOf(':');\n        if (colon < 0)\n            return false;\n        int slash = url.indexOf('/');\n        if (slash < 0)\n            return true;\n        return colon < slash;\n    }\n\n    /**\n     * Check whether an URL is pseudo-absolute.\n     * Returns true if the URL start with a slash.\n     */\n    public static boolean pseudoAbsoluteURL(String url) {\n        return (url.length() > 0) && (url.charAt(0) == '/');\n    }\n\n    /**\n     * Generate a {@link java.lang.String} with a specified number\n     * of a given character.\n     */\n    public static String nChars(int n, char c) {\n        StringBuffer sb = new StringBuffer(n);\n        for (int i = 0; i < n; i++) sb.append(c);\n        return sb.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/util/UtilsTest0.java",
		"test_prompt": "// UtilsTest0.java\npackage nu.staldal.util;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Utils}.\n* It contains ten unit test cases for the {@link Utils#encodePath(String)} method.\n*/\nclass UtilsTest0 {"
	},
	{
		"original_code": "// Utils.java\n/*\n * Copyright (c) 2002, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.util;\n\n/**\n * Some utility methods. All methods in this class are static.\n */\npublic final class Utils {\n\n    /**\n     * Private default constructor to prevent instantiation.\n     */\n    private Utils() {\n    }\n\n    /**\n     * Encode a path name or URL into a filename.\n     *\n     * The encoding function is not intended to be inversible.\n     */\n    public static String encodePath(String path) {\n        StringBuffer sb = new StringBuffer(path.length());\n        for (int i = 0; i < path.length(); i++) {\n            char c = path.charAt(i);\n            switch(c) {\n                case '-':\n                    sb.append(\"--\");\n                    break;\n                case '_':\n                    sb.append(\"__\");\n                    break;\n                case '$':\n                    sb.append(\"$$\");\n                    break;\n                case '~':\n                    sb.append(\"~~\");\n                    break;\n                case '/':\n                    sb.append('-');\n                    break;\n                case '\\\\':\n                    sb.append('-');\n                    break;\n                case '*':\n                    sb.append('_');\n                    break;\n                case '?':\n                    sb.append('$');\n                    break;\n                case ':':\n                    sb.append('~');\n                    break;\n                default:\n                    sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Encode a path name or URL into a Java identifier.\n     *\n     * The encoding function is not intended to be inversible.\n     */\n    public static String encodePathAsIdentifier(String path) {\n        StringBuffer sb = new StringBuffer(path.length());\n        char c = path.charAt(0);\n        if (Character.isJavaIdentifierStart(c))\n            sb.append(c);\n        else\n            sb.append(\"_\" + ((int) c) + \"_\");\n        for (int i = 1; i < path.length(); i++) {\n            c = path.charAt(i);\n            if (Character.isJavaIdentifierPart(c))\n                sb.append(c);\n            else\n                sb.append(\"_\" + ((int) c) + \"_\");\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Check whether an URL is absolute.\n     * Returns true if the URL contains at least one colon, and\n     * the first colon is before the first slash (if any).\n     */\n    public static boolean absoluteURL(String url) {\n        int colon = url.indexOf(':');\n        if (colon < 0)\n            return false;\n        int slash = url.indexOf('/');\n        if (slash < 0)\n            return true;\n        return colon < slash;\n    }\n\n    /**\n     * Check whether an URL is pseudo-absolute.\n     * Returns true if the URL start with a slash.\n     */\n    public static boolean pseudoAbsoluteURL(String url) {\n        return (url.length() > 0) && (url.charAt(0) == '/');\n    }\n\n    /**\n     * Generate a {@link java.lang.String} with a specified number\n     * of a given character.\n     */\n    public static String nChars(int n, char c) {\n        StringBuffer sb = new StringBuffer(n);\n        for (int i = 0; i < n; i++) sb.append(c);\n        return sb.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/util/UtilsTest1.java",
		"test_prompt": "// UtilsTest1.java\npackage nu.staldal.util;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Utils}.\n* It contains ten unit test cases for the {@link Utils#encodePathAsIdentifier(String)} method.\n*/\nclass UtilsTest1 {"
	},
	{
		"original_code": "// Utils.java\n/*\n * Copyright (c) 2002, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.util;\n\n/**\n * Some utility methods. All methods in this class are static.\n */\npublic final class Utils {\n\n    /**\n     * Private default constructor to prevent instantiation.\n     */\n    private Utils() {\n    }\n\n    /**\n     * Encode a path name or URL into a filename.\n     *\n     * The encoding function is not intended to be inversible.\n     */\n    public static String encodePath(String path) {\n        StringBuffer sb = new StringBuffer(path.length());\n        for (int i = 0; i < path.length(); i++) {\n            char c = path.charAt(i);\n            switch(c) {\n                case '-':\n                    sb.append(\"--\");\n                    break;\n                case '_':\n                    sb.append(\"__\");\n                    break;\n                case '$':\n                    sb.append(\"$$\");\n                    break;\n                case '~':\n                    sb.append(\"~~\");\n                    break;\n                case '/':\n                    sb.append('-');\n                    break;\n                case '\\\\':\n                    sb.append('-');\n                    break;\n                case '*':\n                    sb.append('_');\n                    break;\n                case '?':\n                    sb.append('$');\n                    break;\n                case ':':\n                    sb.append('~');\n                    break;\n                default:\n                    sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Encode a path name or URL into a Java identifier.\n     *\n     * The encoding function is not intended to be inversible.\n     */\n    public static String encodePathAsIdentifier(String path) {\n        StringBuffer sb = new StringBuffer(path.length());\n        char c = path.charAt(0);\n        if (Character.isJavaIdentifierStart(c))\n            sb.append(c);\n        else\n            sb.append(\"_\" + ((int) c) + \"_\");\n        for (int i = 1; i < path.length(); i++) {\n            c = path.charAt(i);\n            if (Character.isJavaIdentifierPart(c))\n                sb.append(c);\n            else\n                sb.append(\"_\" + ((int) c) + \"_\");\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Check whether an URL is absolute.\n     * Returns true if the URL contains at least one colon, and\n     * the first colon is before the first slash (if any).\n     */\n    public static boolean absoluteURL(String url) {\n        int colon = url.indexOf(':');\n        if (colon < 0)\n            return false;\n        int slash = url.indexOf('/');\n        if (slash < 0)\n            return true;\n        return colon < slash;\n    }\n\n    /**\n     * Check whether an URL is pseudo-absolute.\n     * Returns true if the URL start with a slash.\n     */\n    public static boolean pseudoAbsoluteURL(String url) {\n        return (url.length() > 0) && (url.charAt(0) == '/');\n    }\n\n    /**\n     * Generate a {@link java.lang.String} with a specified number\n     * of a given character.\n     */\n    public static String nChars(int n, char c) {\n        StringBuffer sb = new StringBuffer(n);\n        for (int i = 0; i < n; i++) sb.append(c);\n        return sb.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/util/UtilsTest2.java",
		"test_prompt": "// UtilsTest2.java\npackage nu.staldal.util;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Utils}.\n* It contains ten unit test cases for the {@link Utils#absoluteURL(String)} method.\n*/\nclass UtilsTest2 {"
	},
	{
		"original_code": "// Utils.java\n/*\n * Copyright (c) 2002, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.util;\n\n/**\n * Some utility methods. All methods in this class are static.\n */\npublic final class Utils {\n\n    /**\n     * Private default constructor to prevent instantiation.\n     */\n    private Utils() {\n    }\n\n    /**\n     * Encode a path name or URL into a filename.\n     *\n     * The encoding function is not intended to be inversible.\n     */\n    public static String encodePath(String path) {\n        StringBuffer sb = new StringBuffer(path.length());\n        for (int i = 0; i < path.length(); i++) {\n            char c = path.charAt(i);\n            switch(c) {\n                case '-':\n                    sb.append(\"--\");\n                    break;\n                case '_':\n                    sb.append(\"__\");\n                    break;\n                case '$':\n                    sb.append(\"$$\");\n                    break;\n                case '~':\n                    sb.append(\"~~\");\n                    break;\n                case '/':\n                    sb.append('-');\n                    break;\n                case '\\\\':\n                    sb.append('-');\n                    break;\n                case '*':\n                    sb.append('_');\n                    break;\n                case '?':\n                    sb.append('$');\n                    break;\n                case ':':\n                    sb.append('~');\n                    break;\n                default:\n                    sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Encode a path name or URL into a Java identifier.\n     *\n     * The encoding function is not intended to be inversible.\n     */\n    public static String encodePathAsIdentifier(String path) {\n        StringBuffer sb = new StringBuffer(path.length());\n        char c = path.charAt(0);\n        if (Character.isJavaIdentifierStart(c))\n            sb.append(c);\n        else\n            sb.append(\"_\" + ((int) c) + \"_\");\n        for (int i = 1; i < path.length(); i++) {\n            c = path.charAt(i);\n            if (Character.isJavaIdentifierPart(c))\n                sb.append(c);\n            else\n                sb.append(\"_\" + ((int) c) + \"_\");\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Check whether an URL is absolute.\n     * Returns true if the URL contains at least one colon, and\n     * the first colon is before the first slash (if any).\n     */\n    public static boolean absoluteURL(String url) {\n        int colon = url.indexOf(':');\n        if (colon < 0)\n            return false;\n        int slash = url.indexOf('/');\n        if (slash < 0)\n            return true;\n        return colon < slash;\n    }\n\n    /**\n     * Check whether an URL is pseudo-absolute.\n     * Returns true if the URL start with a slash.\n     */\n    public static boolean pseudoAbsoluteURL(String url) {\n        return (url.length() > 0) && (url.charAt(0) == '/');\n    }\n\n    /**\n     * Generate a {@link java.lang.String} with a specified number\n     * of a given character.\n     */\n    public static String nChars(int n, char c) {\n        StringBuffer sb = new StringBuffer(n);\n        for (int i = 0; i < n; i++) sb.append(c);\n        return sb.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/util/UtilsTest3.java",
		"test_prompt": "// UtilsTest3.java\npackage nu.staldal.util;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Utils}.\n* It contains ten unit test cases for the {@link Utils#pseudoAbsoluteURL(String)} method.\n*/\nclass UtilsTest3 {"
	},
	{
		"original_code": "// Utils.java\n/*\n * Copyright (c) 2002, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.util;\n\n/**\n * Some utility methods. All methods in this class are static.\n */\npublic final class Utils {\n\n    /**\n     * Private default constructor to prevent instantiation.\n     */\n    private Utils() {\n    }\n\n    /**\n     * Encode a path name or URL into a filename.\n     *\n     * The encoding function is not intended to be inversible.\n     */\n    public static String encodePath(String path) {\n        StringBuffer sb = new StringBuffer(path.length());\n        for (int i = 0; i < path.length(); i++) {\n            char c = path.charAt(i);\n            switch(c) {\n                case '-':\n                    sb.append(\"--\");\n                    break;\n                case '_':\n                    sb.append(\"__\");\n                    break;\n                case '$':\n                    sb.append(\"$$\");\n                    break;\n                case '~':\n                    sb.append(\"~~\");\n                    break;\n                case '/':\n                    sb.append('-');\n                    break;\n                case '\\\\':\n                    sb.append('-');\n                    break;\n                case '*':\n                    sb.append('_');\n                    break;\n                case '?':\n                    sb.append('$');\n                    break;\n                case ':':\n                    sb.append('~');\n                    break;\n                default:\n                    sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Encode a path name or URL into a Java identifier.\n     *\n     * The encoding function is not intended to be inversible.\n     */\n    public static String encodePathAsIdentifier(String path) {\n        StringBuffer sb = new StringBuffer(path.length());\n        char c = path.charAt(0);\n        if (Character.isJavaIdentifierStart(c))\n            sb.append(c);\n        else\n            sb.append(\"_\" + ((int) c) + \"_\");\n        for (int i = 1; i < path.length(); i++) {\n            c = path.charAt(i);\n            if (Character.isJavaIdentifierPart(c))\n                sb.append(c);\n            else\n                sb.append(\"_\" + ((int) c) + \"_\");\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Check whether an URL is absolute.\n     * Returns true if the URL contains at least one colon, and\n     * the first colon is before the first slash (if any).\n     */\n    public static boolean absoluteURL(String url) {\n        int colon = url.indexOf(':');\n        if (colon < 0)\n            return false;\n        int slash = url.indexOf('/');\n        if (slash < 0)\n            return true;\n        return colon < slash;\n    }\n\n    /**\n     * Check whether an URL is pseudo-absolute.\n     * Returns true if the URL start with a slash.\n     */\n    public static boolean pseudoAbsoluteURL(String url) {\n        return (url.length() > 0) && (url.charAt(0) == '/');\n    }\n\n    /**\n     * Generate a {@link java.lang.String} with a specified number\n     * of a given character.\n     */\n    public static String nChars(int n, char c) {\n        StringBuffer sb = new StringBuffer(n);\n        for (int i = 0; i < n; i++) sb.append(c);\n        return sb.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/util/UtilsTest4.java",
		"test_prompt": "// UtilsTest4.java\npackage nu.staldal.util;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Utils}.\n* It contains ten unit test cases for the {@link Utils#nChars(int, char)} method.\n*/\nclass UtilsTest4 {"
	},
	{
		"original_code": "// LSSITransformer.java\n/*\n * Copyright (c) 2003, Mikael Stï¿½ldal\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without \n * modification, are permitted provided that the following conditions \n * are met:\n * \n * 1. Redistributions of source code must retain the above copyright \n * notice, this list of conditions and the following disclaimer.\n * \n * 2. Redistributions in binary form must reproduce the above copyright \n * notice, this list of conditions and the following disclaimer in the \n * documentation and/or other materials provided with the distribution.\n * \n * 3. Neither the name of the author nor the names of its contributors \n * may be used to endorse or promote products derived from this software \n * without specific prior written permission. \n * \n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR \n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR \n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, \n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, \n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR \n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY \n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n * \n * \n * Note: This is known as \"the modified BSD license\". It's an approved \n * Open Source and Free Software license, see \n * http://www.opensource.org/licenses/ \n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.lagoon.producer;\n\nimport java.io.*;\nimport java.util.*;\nimport java.text.*;\nimport org.xml.sax.*;\nimport nu.staldal.lagoon.core.*;\nimport nu.staldal.xmlutil.*;\nimport nu.staldal.util.Utils;\n\npublic class LSSITransformer extends Transform {\n\n    public void init() throws LagoonException, IOException {\n        // nothing to do\n    }\n\n    public void start(org.xml.sax.ContentHandler sax, final Target target) throws IOException, SAXException {\n        sax.startDocument();\n        Set includedFiles = new HashSet();\n        getNext().start(new LSSIHandler(getSourceMan(), sax, target, includedFiles), target);\n        putObjectIntoRepository(\"includedFiles-\" + Utils.encodePath(getSourceMan().getSourceURL()), includedFiles);\n        sax.endDocument();\n    }\n\n    public boolean hasBeenUpdated(long when) throws LagoonException, IOException {\n        Set includedFiles = (Set) getObjectFromRepository(\"includedFiles-\" + Utils.encodePath(getSourceMan().getSourceURL()));\n        if (includedFiles == null)\n            return true;\n        for (Iterator it = includedFiles.iterator(); it.hasNext(); ) {\n            String file = (String) it.next();\n            if (getSourceMan().fileHasBeenUpdated(file, when))\n                return true;\n        }\n        return getNext().hasBeenUpdated(when);\n    }\n}\n\nclass LSSIHandler implements ContentHandler {\n\n    private static final String LSSI_NS = \"http://staldal.nu/Lagoon/LSSI\";\n\n    private SourceManager sourceMan;\n\n    private ContentHandler sax;\n\n    private Target target;\n\n    private Locator locator;\n\n    private int inDirective;\n\n    private Set includedFiles;\n\n    LSSIHandler(SourceManager sourceMan, ContentHandler sax, Target target, Set includedFiles) {\n        this.sourceMan = sourceMan;\n        this.sax = sax;\n        this.target = target;\n        this.locator = null;\n        this.includedFiles = includedFiles;\n        inDirective = 0;\n    }\n\n    public void setDocumentLocator(Locator locator) {\n        this.locator = locator;\n        sax.setDocumentLocator(locator);\n    }\n\n    public void startDocument() throws SAXException {\n        // ignore\n    }\n\n    public void endDocument() throws SAXException {\n        // ignore\n    }\n\n    public void startElement(String namespaceURI, String localName, String qName, Attributes atts) throws SAXException {\n        if (namespaceURI.equals(LSSI_NS)) {\n            inDirective++;\n            if (localName.equals(\"include\")) {\n                String file = atts.getValue(\"file\");\n                if (file == null)\n                    throw new SAXParseException(\"lssi:include missing parameter\", locator);\n                includedFiles.add(file);\n                try {\n                    sourceMan.getFileAsSAX(file, new LSSIHandler(sourceMan, sax, target, includedFiles), target);\n                } catch (FileNotFoundException e) {\n                    throw new SAXParseException(e.getMessage(), locator);\n                } catch (IOException e) {\n                    throw new SAXException(e);\n                }\n            } else if (localName.equals(\"date\")) {\n                String format = atts.getValue(\"format\");\n                if (format == null)\n                    format = \"yyyy-MM-dd\";\n                DateFormat df = new SimpleDateFormat(format);\n                String tz = atts.getValue(\"tz\");\n                if (tz != null)\n                    df.setTimeZone(TimeZone.getTimeZone(tz));\n                String theDate = df.format(new Date());\n                sax.characters(theDate.toCharArray(), 0, theDate.length());\n            } else if (localName.equals(\"lastmod\")) {\n                String format = atts.getValue(\"format\");\n                if (format == null)\n                    format = \"yyyy-MM-dd\";\n                DateFormat df = new SimpleDateFormat(format);\n                String tz = atts.getValue(\"tz\");\n                if (tz != null)\n                    df.setTimeZone(TimeZone.getTimeZone(tz));\n                try {\n                    String url = atts.getValue(\"file\");\n                    if (url == null)\n                        url = sourceMan.getSourceURL();\n                    File file = sourceMan.getFile(url);\n                    if (file == null) {\n                        throw new SAXParseException(\"No file to check timestamp on\", locator);\n                    }\n                    String theDate = df.format(new Date(file.lastModified()));\n                    sax.characters(theDate.toCharArray(), 0, theDate.length());\n                } catch (FileNotFoundException e) {\n                    throw new SAXException(e);\n                }\n            } else if (localName.equals(\"root\")) {\n                // just ignore\n            } else {\n                throw new SAXParseException(\"Unknown LSSI element: \" + localName, locator);\n            }\n        } else {\n            sax.startElement(namespaceURI, localName, qName, atts);\n        }\n    }\n\n    public void endElement(String namespaceURI, String localName, String qName) throws SAXException {\n        if (namespaceURI.equals(LSSI_NS)) {\n            inDirective--;\n        } else {\n            sax.endElement(namespaceURI, localName, qName);\n        }\n    }\n\n    public void startPrefixMapping(String prefix, String uri) throws SAXException {\n        sax.startPrefixMapping(prefix, uri);\n    }\n\n    public void endPrefixMapping(String prefix) throws SAXException {\n        sax.endPrefixMapping(prefix);\n    }\n\n    public void characters(char[] ch, int start, int length) throws SAXException {\n        sax.characters(ch, start, length);\n    }\n\n    public void ignorableWhitespace(char[] ch, int start, int length) throws SAXException {\n        sax.ignorableWhitespace(ch, start, length);\n    }\n\n    public void processingInstruction(String target, String data) throws SAXException {\n        sax.processingInstruction(target, data);\n    }\n\n    public void skippedEntity(String name) throws SAXException {\n        sax.skippedEntity(name);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/producer/LSSITransformerTest.java",
		"test_prompt": "// LSSITransformerTest.java\npackage nu.staldal.lagoon.producer;\n\nimport java.io.*;\nimport java.util.*;\nimport java.text.*;\nimport org.xml.sax.*;\nimport nu.staldal.lagoon.core.*;\nimport nu.staldal.xmlutil.*;\nimport nu.staldal.util.Utils;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link LSSITransformer}.\n* It contains ten unit test cases for the {@link LSSITransformer#hasBeenUpdated(long)} method.\n*/\nclass LSSITransformerTest {"
	},
	{
		"original_code": "// XSLTransformer.java\n/*\n * Copyright (c) 2001-2005, Mikael Stï¿½ldal\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without \n * modification, are permitted provided that the following conditions \n * are met:\n * \n * 1. Redistributions of source code must retain the above copyright \n * notice, this list of conditions and the following disclaimer.\n * \n * 2. Redistributions in binary form must reproduce the above copyright \n * notice, this list of conditions and the following disclaimer in the \n * documentation and/or other materials provided with the distribution.\n * \n * 3. Neither the name of the author nor the names of its contributors \n * may be used to endorse or promote products derived from this software \n * without specific prior written permission. \n * \n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR \n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR \n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, \n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, \n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR \n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY \n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n * \n * \n * Note: This is known as \"the modified BSD license\". It's an approved \n * Open Source and Free Software license, see \n * http://www.opensource.org/licenses/ \n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.lagoon.producer;\n\nimport java.io.*;\nimport java.util.*;\nimport javax.xml.transform.*;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.sax.*;\nimport javax.xml.transform.stream.StreamSource;\nimport org.xml.sax.*;\nimport nu.staldal.lagoon.core.*;\nimport nu.staldal.xmlutil.*;\n\npublic class XSLTransformer extends Transform {\n\n    private static final boolean DEBUG = false;\n\n    private String xslFile;\n\n    private SAXTransformerFactory tfactory;\n\n    private boolean always;\n\n    private long stylesheetRead = 0;\n\n    private StylesheetContainer stylesheetInfo;\n\n    private Templates stylesheet;\n\n    public void init() throws LagoonException, IOException {\n        xslFile = getParam(\"stylesheet\");\n        if (xslFile == null) {\n            throw new LagoonException(\"stylesheet parameter not specified\");\n        }\n        String a = getParam(\"always\");\n        always = (a != null) && (a.length() > 0);\n        try {\n            TransformerFactory tf = TransformerFactory.newInstance();\n            if (!(tf.getFeature(SAXTransformerFactory.FEATURE) && tf.getFeature(SAXSource.FEATURE) && tf.getFeature(SAXResult.FEATURE) && tf.getFeature(StreamSource.FEATURE))) {\n                throw new LagoonException(\"The transformer factory \" + tf.getClass().getName() + \" doesn't support SAX\");\n            }\n            tfactory = (SAXTransformerFactory) tf;\n            stylesheetInfo = (StylesheetContainer) getObjectFromRepository(\"stylesheetInfo\");\n        } catch (LagoonException e) {\n            throw e;\n        } catch (SAXException e) {\n            throw new LagoonException(e.getMessage());\n        }\n        stylesheet = null;\n    }\n\n    public void afterBuild() throws IOException {\n        if (stylesheetRead > 0) {\n            stylesheetInfo.stylesheetRead = System.currentTimeMillis();\n            putObjectIntoRepository(\"stylesheetInfo\", stylesheetInfo);\n        }\n    }\n\n    private void readStylesheet(final Target target) throws IOException, SAXException {\n        stylesheetInfo = new StylesheetContainer(always);\n        final String xslPath = getSourceMan().getFileURL(xslFile);\n        if (!getContext().canCheckFileHasBeenUpdated(xslPath))\n            stylesheetInfo.compileDynamic = true;\n        if (DEBUG)\n            System.out.println(\"Read stylesheet: \" + xslPath);\n        tfactory.setURIResolver(new URIResolver() {\n\n            public Source resolve(String href, String base) {\n                String thisFile = getContext().getFileURLRelativeTo(href, xslPath);\n                try {\n                    if (!getContext().canCheckFileHasBeenUpdated(thisFile)) {\n                        stylesheetInfo.compileDynamic = true;\n                    } else {\n                        stylesheetInfo.importedFiles.put(thisFile, \"\");\n                    }\n                    return getSourceMan().getFileAsJAXPSource(thisFile, target);\n                } catch (FileNotFoundException e) {\n                    // let XSLT processor discover error\n                    return null;\n                }\n            }\n        });\n        Source ss = getSourceMan().getFileAsJAXPSource(xslPath, target);\n        try {\n            stylesheet = tfactory.newTemplates(ss);\n            stylesheetRead = System.currentTimeMillis();\n            putObjectIntoRepository(\"stylesheetInfo\", stylesheetInfo);\n        } catch (TransformerConfigurationException e) {\n            throw new SAXException(e);\n        }\n        if (DEBUG) {\n            System.out.println(\"---depends on files:\");\n            for (Enumeration e = stylesheetInfo.importedFiles.keys(); e.hasMoreElements(); ) {\n                System.out.println(\"\\t\" + e.nextElement());\n            }\n            System.out.println(\"---\");\n        }\n    }\n\n    private boolean stylesheetUpdated() throws LagoonException, IOException {\n        if (stylesheetInfo == null)\n            return true;\n        if (stylesheetInfo.compileDynamic)\n            return true;\n        if (getSourceMan().fileHasBeenUpdated(xslFile, stylesheetInfo.stylesheetRead)) {\n            return true;\n        }\n        for (Enumeration e = stylesheetInfo.importedFiles.keys(); e.hasMoreElements(); ) {\n            if (getSourceMan().fileHasBeenUpdated((String) e.nextElement(), stylesheetInfo.stylesheetRead)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public void start(org.xml.sax.ContentHandler sax, final Target target) throws IOException, SAXException {\n        if (stylesheet == null || stylesheetUpdated()) {\n            readStylesheet(target);\n        }\n        if (DEBUG)\n            System.out.println(\"Transforming\");\n        TransformerHandler th;\n        try {\n            th = tfactory.newTransformerHandler(stylesheet);\n        } catch (TransformerConfigurationException e) {\n            throw new SAXException(e);\n        }\n        th.setResult(new SAXResult(sax));\n        for (Enumeration e = getParamNames(); e.hasMoreElements(); ) {\n            String paramName = (String) e.nextElement();\n            if (!paramName.equals(\"stylesheet\") && !paramName.equals(\"always\")) {\n                th.getTransformer().setParameter(paramName, getParam(paramName));\n            }\n        }\n        th.getTransformer().setURIResolver(new URIResolver() {\n\n            public Source resolve(String href, String base) {\n                try {\n                    if (!getContext().canCheckFileHasBeenUpdated(href)) {\n                        stylesheetInfo.executeDynamic = true;\n                    } else {\n                        stylesheetInfo.readFiles.put(getSourceMan().getFileURL(href), \"\");\n                    }\n                    return getSourceMan().getFileAsJAXPSource(href, target);\n                } catch (FileNotFoundException e) {\n                    // let XSLT processor discover error\n                    return null;\n                }\n            }\n        });\n        getNext().start(new ContentHandlerFixer(th), target);\n        putObjectIntoRepository(\"stylesheetInfo\", stylesheetInfo);\n        if (DEBUG) {\n            System.out.println(\"---execute depends on files:\");\n            for (Enumeration e = stylesheetInfo.readFiles.keys(); e.hasMoreElements(); ) {\n                System.out.println(\"\\t\" + e.nextElement());\n            }\n            System.out.println(\"---\");\n        }\n    }\n\n    public boolean hasBeenUpdated(long when) throws LagoonException, IOException {\n        if (stylesheetUpdated()) {\n            return true;\n        }\n        if (stylesheetInfo.executeDynamic)\n            return true;\n        for (Enumeration e = stylesheetInfo.readFiles.keys(); e.hasMoreElements(); ) {\n            String f = (String) e.nextElement();\n            if (getSourceMan().fileHasBeenUpdated(f, when)) {\n                return true;\n            }\n        }\n        return getNext().hasBeenUpdated(when);\n    }\n}\n\nclass StylesheetContainer implements Serializable {\n\n    long stylesheetRead;\n\n    boolean executeDynamic;\n\n    boolean compileDynamic;\n\n    Hashtable importedFiles;\n\n    Hashtable readFiles;\n\n    StylesheetContainer(boolean always) {\n        executeDynamic = always;\n        compileDynamic = false;\n        importedFiles = new Hashtable();\n        readFiles = new Hashtable();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/producer/XSLTransformerTest.java",
		"test_prompt": "// XSLTransformerTest.java\npackage nu.staldal.lagoon.producer;\n\nimport java.io.*;\nimport java.util.*;\nimport javax.xml.transform.*;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.sax.*;\nimport javax.xml.transform.stream.StreamSource;\nimport org.xml.sax.*;\nimport nu.staldal.lagoon.core.*;\nimport nu.staldal.xmlutil.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XSLTransformer}.\n* It contains ten unit test cases for the {@link XSLTransformer#hasBeenUpdated(long)} method.\n*/\nclass XSLTransformerTest {"
	},
	{
		"original_code": "// XMLFormatter.java\n/*\n * Copyright (c) 2001-2005, Mikael Stï¿½ldal\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without \n * modification, are permitted provided that the following conditions \n * are met:\n * \n * 1. Redistributions of source code must retain the above copyright \n * notice, this list of conditions and the following disclaimer.\n * \n * 2. Redistributions in binary form must reproduce the above copyright \n * notice, this list of conditions and the following disclaimer in the \n * documentation and/or other materials provided with the distribution.\n * \n * 3. Neither the name of the author nor the names of its contributors \n * may be used to endorse or promote products derived from this software \n * without specific prior written permission. \n * \n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR \n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR \n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, \n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, \n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR \n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY \n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n * \n * \n * Note: This is known as \"the modified BSD license\". It's an approved \n * Open Source and Free Software license, see \n * http://www.opensource.org/licenses/ \n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.lagoon.producer;\n\nimport java.io.*;\nimport java.util.Properties;\nimport javax.xml.transform.*;\nimport javax.xml.transform.sax.*;\nimport javax.xml.transform.stream.StreamResult;\nimport org.xml.sax.*;\nimport nu.staldal.lagoon.core.*;\nimport nu.staldal.xmlutil.ContentHandlerFixer;\nimport nu.staldal.xodus.*;\n\npublic class XMLFormatter extends Format {\n\n    private Properties outputProperties;\n\n    public void init() throws LagoonException {\n        outputProperties = new Properties();\n        String method = getParam(\"method\");\n        if (method == null)\n            method = \"XML\";\n        int _html;\n        String html = getParam(\"html\");\n        if (html == null)\n            _html = 1;\n        else if (html.equals(\"transitional\"))\n            _html = 1;\n        else if (html.equals(\"frameset\"))\n            _html = 2;\n        else if (html.equals(\"strict\"))\n            _html = 3;\n        else\n            throw new LagoonException(\"Unknown html variant\");\n        if (method.equals(\"XML\")) {\n            outputProperties.setProperty(OutputKeys.METHOD, \"xml\");\n            outputProperties.setProperty(OutputKeys.ENCODING, \"UTF-8\");\n        } else if (method.equals(\"HTML\")) {\n            outputProperties.setProperty(OutputKeys.METHOD, \"html\");\n            switch(_html) {\n                case 1:\n                    outputProperties.setProperty(OutputKeys.DOCTYPE_PUBLIC, \"-//W3C//DTD HTML 4.01 Transitional//EN\");\n                    outputProperties.setProperty(OutputKeys.DOCTYPE_SYSTEM, \"http://www.w3.org/TR/html4/loose.dtd\");\n                    break;\n                case 2:\n                    outputProperties.setProperty(OutputKeys.DOCTYPE_PUBLIC, \"-//W3C//DTD HTML 4.01 Frameset//EN\");\n                    outputProperties.setProperty(OutputKeys.DOCTYPE_SYSTEM, \"http://www.w3.org/TR/html4/frameset.dtd\");\n                    break;\n                case 3:\n                    outputProperties.setProperty(OutputKeys.DOCTYPE_PUBLIC, \"-//W3C//DTD HTML 4.01//EN\");\n                    outputProperties.setProperty(OutputKeys.DOCTYPE_SYSTEM, \"http://www.w3.org/TR/html4/strict.dtd\");\n                    break;\n            }\n            outputProperties.setProperty(OutputKeys.ENCODING, \"iso-8859-1\");\n        } else if (method.equals(\"XHTML\")) {\n            outputProperties.setProperty(OutputKeys.METHOD, \"xhtml\");\n            switch(_html) {\n                case 1:\n                    outputProperties.setProperty(OutputKeys.DOCTYPE_PUBLIC, \"-//W3C//DTD XHTML 1.0 Transitional//EN\");\n                    outputProperties.setProperty(OutputKeys.DOCTYPE_SYSTEM, \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\");\n                    break;\n                case 2:\n                    outputProperties.setProperty(OutputKeys.DOCTYPE_PUBLIC, \"-//W3C//DTD XHTML 1.0 Frameset//EN\");\n                    outputProperties.setProperty(OutputKeys.DOCTYPE_SYSTEM, \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd\");\n                    break;\n                case 3:\n                    outputProperties.setProperty(OutputKeys.DOCTYPE_PUBLIC, \"-//W3C//DTD XHTML 1.0 Strict//EN\");\n                    outputProperties.setProperty(OutputKeys.DOCTYPE_SYSTEM, \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\");\n                    break;\n            }\n            outputProperties.setProperty(OutputKeys.ENCODING, \"UTF-8\");\n        } else if (method.equals(\"TEXT\")) {\n            outputProperties.setProperty(OutputKeys.METHOD, \"text\");\n            outputProperties.setProperty(OutputKeys.ENCODING, \"iso-8859-1\");\n        } else\n            throw new LagoonException(\"Unknown serializing method\");\n        String enc = getParam(\"encoding\");\n        if (enc != null)\n            outputProperties.setProperty(OutputKeys.ENCODING, enc);\n        String docPub = getParam(\"doctype-public\");\n        if (docPub != null)\n            outputProperties.setProperty(OutputKeys.DOCTYPE_PUBLIC, docPub);\n        String docSys = getParam(\"doctype-system\");\n        if (docSys != null)\n            outputProperties.setProperty(OutputKeys.DOCTYPE_SYSTEM, docSys);\n        String indent = getParam(\"indent\");\n        if (indent != null)\n            outputProperties.setProperty(OutputKeys.INDENT, \"yes\");\n        else\n            outputProperties.setProperty(OutputKeys.INDENT, \"no\");\n        String omitXmlDeclaration = getParam(\"omit-xml-declaration\");\n        if (omitXmlDeclaration != null)\n            outputProperties.setProperty(OutputKeys.OMIT_XML_DECLARATION, \"yes\");\n        else\n            outputProperties.setProperty(OutputKeys.OMIT_XML_DECLARATION, \"no\");\n    }\n\n    public void start(OutputStream bytes, Target target) throws IOException, SAXException {\n        Serializer ser;\n        try {\n            ser = Serializer.createSerializer(new StreamResult(bytes), outputProperties);\n        } catch (IllegalArgumentException e) {\n            throw new LagoonException(e.getMessage());\n        }\n        getNext().start(ser, target);\n    }\n\n    public boolean hasBeenUpdated(long when) throws LagoonException, IOException {\n        return getNext().hasBeenUpdated(when);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/producer/XMLFormatterTest.java",
		"test_prompt": "// XMLFormatterTest.java\npackage nu.staldal.lagoon.producer;\n\nimport java.io.*;\nimport java.util.Properties;\nimport javax.xml.transform.*;\nimport javax.xml.transform.sax.*;\nimport javax.xml.transform.stream.StreamResult;\nimport org.xml.sax.*;\nimport nu.staldal.lagoon.core.*;\nimport nu.staldal.xmlutil.ContentHandlerFixer;\nimport nu.staldal.xodus.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XMLFormatter}.\n* It contains ten unit test cases for the {@link XMLFormatter#hasBeenUpdated(long)} method.\n*/\nclass XMLFormatterTest {"
	},
	{
		"original_code": "// FileRead.java\n/*\n * Copyright (c) 2001, Mikael Stï¿½ldal\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without \n * modification, are permitted provided that the following conditions \n * are met:\n * \n * 1. Redistributions of source code must retain the above copyright \n * notice, this list of conditions and the following disclaimer.\n * \n * 2. Redistributions in binary form must reproduce the above copyright \n * notice, this list of conditions and the following disclaimer in the \n * documentation and/or other materials provided with the distribution.\n * \n * 3. Neither the name of the author nor the names of its contributors \n * may be used to endorse or promote products derived from this software \n * without specific prior written permission. \n * \n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR \n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR \n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, \n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, \n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR \n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY \n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n * \n * \n * Note: This is known as \"the modified BSD license\". It's an approved \n * Open Source and Free Software license, see \n * http://www.opensource.org/licenses/ \n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.lagoon.producer;\n\nimport java.io.*;\nimport nu.staldal.lagoon.core.*;\n\npublic class FileRead extends Read {\n\n    public void init() {\n        // nothing to do\n    }\n\n    public void start(OutputStream bytes, Target target) throws IOException {\n        InputStream fis = getSourceMan().openFile(getSourceMan().getSourceURL());\n        byte[] buf = new byte[8192];\n        while (true) {\n            int bytesRead = fis.read(buf);\n            if (bytesRead < 1)\n                break;\n            bytes.write(buf, 0, bytesRead);\n        }\n        fis.close();\n    }\n\n    public boolean hasBeenUpdated(long when) throws FileNotFoundException, IOException, LagoonException {\n        return getSourceMan().fileHasBeenUpdated(getSourceMan().getSourceURL(), when);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/producer/FileReadTest.java",
		"test_prompt": "// FileReadTest.java\npackage nu.staldal.lagoon.producer;\n\nimport java.io.*;\nimport nu.staldal.lagoon.core.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileRead}.\n* It contains ten unit test cases for the {@link FileRead#hasBeenUpdated(long)} method.\n*/\nclass FileReadTest {"
	},
	{
		"original_code": "// DirSource.java\n/*\n * Copyright (c) 2001-2005, Mikael Stï¿½ldal\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without \n * modification, are permitted provided that the following conditions \n * are met:\n * \n * 1. Redistributions of source code must retain the above copyright \n * notice, this list of conditions and the following disclaimer.\n * \n * 2. Redistributions in binary form must reproduce the above copyright \n * notice, this list of conditions and the following disclaimer in the \n * documentation and/or other materials provided with the distribution.\n * \n * 3. Neither the name of the author nor the names of its contributors \n * may be used to endorse or promote products derived from this software \n * without specific prior written permission. \n * \n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR \n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR \n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, \n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, \n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR \n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY \n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n * \n * \n * Note: This is known as \"the modified BSD license\". It's an approved \n * Open Source and Free Software license, see \n * http://www.opensource.org/licenses/ \n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.lagoon.producer;\n\nimport java.io.*;\nimport java.util.Hashtable;\nimport java.util.Enumeration;\nimport java.util.Date;\nimport java.text.SimpleDateFormat;\nimport org.xml.sax.*;\nimport org.xml.sax.helpers.AttributesImpl;\nimport nu.staldal.lagoon.core.*;\nimport nu.staldal.lagoon.util.Wildcard;\n\npublic class DirSource extends Source {\n\n    private String pattern = null;\n\n    private Hashtable dirlist = null;\n\n    public void init() throws IOException {\n        pattern = getParam(\"pattern\");\n        dirlist = (Hashtable) getObjectFromRepository(\"dirlist\");\n    }\n\n    public void start(ContentHandler sax, Target target) throws IOException, SAXException {\n        File dir = getSourceMan().getFile(getSourceMan().getSourceURL());\n        if (!dir.isDirectory())\n            throw new IOException(\"The source is not a directory\");\n        String[] files = dir.list();\n        dirlist = new Hashtable();\n        for (int i = 0; i < files.length; i++) {\n            dirlist.put(files[i], \"washere\");\n        }\n        putObjectIntoRepository(\"dirlist\", dirlist);\n        sax.startDocument();\n        sax.startElement(\"\", \"dirlist\", \"\", new AttributesImpl());\n        for (int i = 0; i < files.length; i++) {\n            if ((pattern != null) && (Wildcard.matchWildcard(pattern, files[i]) == null))\n                continue;\n            File file = new File(dir, files[i]);\n            AttributesImpl atts = new AttributesImpl();\n            atts.addAttribute(\"\", \"filename\", \"\", \"CDATA\", files[i]);\n            atts.addAttribute(\"\", \"url\", \"\", \"CDATA\", getSourceMan().getFileURL(files[i]) + (file.isDirectory() ? \"/\" : \"\"));\n            long timestamp = file.lastModified();\n            SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n            SimpleDateFormat timeFormat = new SimpleDateFormat(\"HH:mm:ss\");\n            Date date = new Date(timestamp);\n            atts.addAttribute(\"\", \"timestamp\", \"\", \"CDATA\", String.valueOf(timestamp));\n            atts.addAttribute(\"\", \"date\", \"\", \"CDATA\", dateFormat.format(date));\n            atts.addAttribute(\"\", \"time\", \"\", \"CDATA\", timeFormat.format(date));\n            if (file.isFile()) {\n                atts.addAttribute(\"\", \"size\", \"\", \"CDATA\", String.valueOf(file.length()));\n                sax.startElement(\"\", \"file\", \"\", atts);\n                sax.endElement(\"\", \"file\", \"\");\n            } else if (file.isDirectory()) {\n                sax.startElement(\"\", \"directory\", \"\", atts);\n                sax.endElement(\"\", \"directory\", \"\");\n            } else\n                // do nothing\n                ;\n        }\n        sax.endElement(\"\", \"dirlist\", \"\");\n        sax.endDocument();\n    }\n\n    public boolean hasBeenUpdated(long when) throws LagoonException, IOException {\n        if (getSourceMan().fileHasBeenUpdated(getSourceMan().getSourceURL(), when))\n            return true;\n        File dir = getSourceMan().getFile(getSourceMan().getSourceURL());\n        if (dirlist == null)\n            return true;\n        String[] files = dir.list();\n        for (int i = 0; i < files.length; i++) {\n            if (dirlist.put(files[i], \"ishere\") == null) {\n                // file added\n                return true;\n            }\n        }\n        for (Enumeration en = dirlist.keys(); en.hasMoreElements(); ) {\n            Object o = en.nextElement();\n            if (dirlist.get(o) != \"ishere\") {\n                // file removed\n                return true;\n            }\n        }\n        return false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/producer/DirSourceTest.java",
		"test_prompt": "// DirSourceTest.java\npackage nu.staldal.lagoon.producer;\n\nimport java.io.*;\nimport java.util.Hashtable;\nimport java.util.Enumeration;\nimport java.util.Date;\nimport java.text.SimpleDateFormat;\nimport org.xml.sax.*;\nimport org.xml.sax.helpers.AttributesImpl;\nimport nu.staldal.lagoon.core.*;\nimport nu.staldal.lagoon.util.Wildcard;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DirSource}.\n* It contains ten unit test cases for the {@link DirSource#hasBeenUpdated(long)} method.\n*/\nclass DirSourceTest {"
	},
	{
		"original_code": "// BasicSplit.java\n/*\n * Copyright (c) 2001, Mikael Stï¿½ldal\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without \n * modification, are permitted provided that the following conditions \n * are met:\n * \n * 1. Redistributions of source code must retain the above copyright \n * notice, this list of conditions and the following disclaimer.\n * \n * 2. Redistributions in binary form must reproduce the above copyright \n * notice, this list of conditions and the following disclaimer in the \n * documentation and/or other materials provided with the distribution.\n * \n * 3. Neither the name of the author nor the names of its contributors \n * may be used to endorse or promote products derived from this software \n * without specific prior written permission. \n * \n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR \n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR \n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, \n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, \n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR \n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY \n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n * \n * \n * Note: This is known as \"the modified BSD license\". It's an approved \n * Open Source and Free Software license, see \n * http://www.opensource.org/licenses/ \n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.lagoon.producer;\n\nimport nu.staldal.lagoon.core.*;\nimport nu.staldal.lagoon.util.*;\nimport java.util.*;\nimport java.io.*;\nimport org.xml.sax.*;\n\npublic class BasicSplit extends Transform implements ContentHandler, Runnable {\n\n    private static final boolean DEBUG = false;\n\n    private ContentHandler sax;\n\n    private Target target;\n\n    private Thread myThread;\n\n    private Thread mainThread;\n\n    private boolean inPart;\n\n    private String myNS;\n\n    private String myElement;\n\n    private String outputname;\n\n    private Exception myException;\n\n    private Hashtable prefixDict;\n\n    private static void sleepUntilInterrupted() {\n        try {\n            while (true) // Sleep one minute\n            Thread.sleep(1000 * 60);\n        } catch (InterruptedException e) {\n        }\n    }\n\n    public void init() throws LagoonException {\n        this.myThread = null;\n        this.myNS = getParam(\"namespace\");\n        if (this.myNS == null)\n            throw new LagoonException(\"parameter \\'namespace\\' must be set\");\n        this.myElement = getParam(\"element\");\n        if (this.myElement == null)\n            throw new LagoonException(\"parameter \\'element\\' must be set\");\n        this.outputname = getParam(\"outputname\");\n        if (this.outputname == null)\n            throw new LagoonException(\"parameter \\'outputname\\' must be set\");\n        this.myException = null;\n        this.sax = null;\n        this.target = null;\n        if (DEBUG)\n            System.out.println(\"BasicSplit: namespace=\\'\" + myNS + \"\\'  element=\\'\" + myElement + \"\\'  outputname=\\'\" + outputname + \"\\'\");\n    }\n\n    public void start(ContentHandler sax, Target target) throws IOException, SAXException {\n        this.sax = sax;\n        this.target = target;\n        mainThread = Thread.currentThread();\n        if (myThread == null) {\n            inPart = false;\n            prefixDict = new Hashtable();\n            sax.startDocument();\n            // Dummy document\n            sax.endDocument();\n            myThread = new Thread(this);\n            myThread.start();\n        } else {\n            myThread.interrupt();\n        }\n        sleepUntilInterrupted();\n        this.target = null;\n        this.sax = null;\n        if (myException != null) {\n            if (myException instanceof SAXException)\n                throw (SAXException) myException;\n            else\n                throw new SAXException(myException);\n        }\n    }\n\n    public boolean hasBeenUpdated(long when) throws LagoonException, IOException {\n        return getNext().hasBeenUpdated(when);\n    }\n\n    /**\n     * Thread run method.\n     */\n    public void run() {\n        try {\n            getNext().start(this, target);\n        } catch (Exception e) {\n            myException = e;\n            mainThread.interrupt();\n        } finally {\n            myThread = null;\n        }\n    }\n\n    // SAX ContentHandler implementation\n    public void setDocumentLocator(Locator locator) {\n        // nothing to do\n    }\n\n    public void startDocument() {\n    }\n\n    public void endDocument() {\n        mainThread.interrupt();\n    }\n\n    public void startElement(String namespaceURI, String localName, String qName, Attributes atts) throws SAXException {\n        if (inPart)\n            sax.startElement(namespaceURI, localName, qName, atts);\n        else if (namespaceURI.equals(myNS) && localName.equals(myElement)) {\n            ((FileTarget) target).newTarget(instantiateAtts(outputname, atts), false);\n            mainThread.interrupt();\n            sleepUntilInterrupted();\n            sax.startDocument();\n            for (Enumeration e = prefixDict.keys(); e.hasMoreElements(); ) {\n                String prefix = (String) e.nextElement();\n                String uri = (String) prefixDict.get(prefix);\n                sax.startPrefixMapping(prefix, uri);\n            }\n            sax.startElement(namespaceURI, localName, qName, atts);\n            inPart = true;\n        }\n    }\n\n    public void endElement(String namespaceURI, String localName, String qName) throws SAXException {\n        if (inPart)\n            sax.endElement(namespaceURI, localName, qName);\n        if (namespaceURI.equals(myNS) && localName.equals(myElement)) {\n            inPart = false;\n            for (Enumeration e = prefixDict.keys(); e.hasMoreElements(); ) {\n                String prefix = (String) e.nextElement();\n                sax.endPrefixMapping(prefix);\n            }\n            sax.endDocument();\n        }\n    }\n\n    public void startPrefixMapping(String prefix, String uri) throws SAXException {\n        if (inPart)\n            sax.startPrefixMapping(prefix, uri);\n        else {\n            prefixDict.put(prefix, uri);\n        }\n    }\n\n    public void endPrefixMapping(String prefix) throws SAXException {\n        if (inPart)\n            sax.endPrefixMapping(prefix);\n        {\n            prefixDict.remove(prefix);\n        }\n    }\n\n    public void characters(char[] ch, int start, int length) throws SAXException {\n        if (inPart)\n            sax.characters(ch, start, length);\n    }\n\n    public void ignorableWhitespace(char[] ch, int start, int length) throws SAXException {\n        if (inPart)\n            sax.ignorableWhitespace(ch, start, length);\n    }\n\n    public void processingInstruction(String target, String data) throws SAXException {\n        if (inPart)\n            sax.processingInstruction(target, data);\n    }\n\n    public void skippedEntity(String name) throws SAXException {\n        if (inPart)\n            sax.skippedEntity(name);\n    }\n\n    /**\n     * Instantiate a filename template to a filename.\n     *\n     * @param template   the filename template\n     * @param atts      the Attributes\n     *\n     * @return  the filename\n     */\n    private static String instantiateAtts(String template, final Attributes atts) throws SAXException {\n        try {\n            return TemplateProcessor.processTemplate('[', ']', '\\'', '\\\"', template, new ExpressionEvaluator() {\n\n                public String eval(String expr) throws SAXException {\n                    String value = atts.getValue(\"\", expr);\n                    if (value == null)\n                        throw new SAXException(\"Attribute not found: \" + expr);\n                    else\n                        return value;\n                }\n            });\n        } catch (TemplateException e) {\n            Exception ee = e.getException();\n            if (ee != null)\n                throw (SAXException) ee;\n            else\n                throw new SAXException(\"Illegal attribute template: \" + e.getMessage());\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/producer/BasicSplitTest.java",
		"test_prompt": "// BasicSplitTest.java\npackage nu.staldal.lagoon.producer;\n\nimport nu.staldal.lagoon.core.*;\nimport nu.staldal.lagoon.util.*;\nimport java.util.*;\nimport java.io.*;\nimport org.xml.sax.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BasicSplit}.\n* It contains ten unit test cases for the {@link BasicSplit#hasBeenUpdated(long)} method.\n*/\nclass BasicSplitTest {"
	},
	{
		"original_code": "// FOPFormatter.java\n/*\n * Copyright (c) 2001-2002, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.lagoon.producer;\n\nimport java.io.*;\nimport org.xml.sax.*;\nimport org.apache.fop.apps.*;\nimport org.apache.log.*;\nimport org.apache.log.format.*;\nimport nu.staldal.lagoon.core.*;\n\n/**\n * Uses Apache FOP version 0.20.3.\n */\npublic class FOPFormatter extends Format {\n\n    private Driver driver;\n\n    public void init() {\n        driver = new Driver();\n        Hierarchy hierarchy = Hierarchy.getDefaultHierarchy();\n        PatternFormatter formatter = new PatternFormatter(\"[%{priority}]: %{message}\\n%{throwable}\");\n        LogTarget logTarget = new org.apache.log.output.io.StreamTarget(System.err, formatter);\n        hierarchy.setDefaultLogTarget(logTarget);\n        Logger log = hierarchy.getLoggerFor(\"fop\");\n        log.setPriority(Priority.ERROR);\n        // driver.setLogger(log);\n    }\n\n    public void start(OutputStream out, Target target) throws IOException, SAXException {\n        driver.reset();\n        driver.setRenderer(Driver.RENDER_PDF);\n        driver.setOutputStream(out);\n        getNext().start(driver.getContentHandler(), target);\n        /*\n\t\tcatch (SAXException e)\n\t\t{\n\t\t\tSystem.err.println(\"SAXException: \" + e.toString());\n\t\t\tException ee = e.getException();\n\t\t\tif (ee != null)\n\t\t\t\tee.printStackTrace();\n\t\t\telse\n\t\t\t\te.printStackTrace();\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\te.printStackTrace();\n\t\t}\n*/\n    }\n\n    public boolean hasBeenUpdated(long when) throws LagoonException, IOException {\n        return getNext().hasBeenUpdated(when);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/producer/FOPFormatterTest.java",
		"test_prompt": "// FOPFormatterTest.java\npackage nu.staldal.lagoon.producer;\n\nimport java.io.*;\nimport org.xml.sax.*;\nimport org.apache.fop.apps.*;\nimport org.apache.log.*;\nimport org.apache.log.format.*;\nimport nu.staldal.lagoon.core.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FOPFormatter}.\n* It contains ten unit test cases for the {@link FOPFormatter#hasBeenUpdated(long)} method.\n*/\nclass FOPFormatterTest {"
	},
	{
		"original_code": "// BatikFormatter.java\n/*\n * Copyright (c) 2001-2004, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.lagoon.producer;\n\nimport java.io.*;\nimport java.net.URL;\nimport org.xml.sax.*;\nimport org.apache.batik.transcoder.*;\nimport org.apache.batik.transcoder.image.*;\nimport org.apache.batik.dom.svg.*;\nimport org.apache.batik.util.XMLResourceDescriptor;\nimport org.apache.batik.util.SVGConstants;\nimport nu.staldal.lagoon.core.*;\nimport nu.staldal.lagoon.util.*;\nimport nu.staldal.util.Utils;\nimport nu.staldal.xmlutil.*;\n\n/**\n * Uses Apache Batik version 1.5.1.\n */\npublic class BatikFormatter extends Format {\n\n    private static boolean DEBUG = false;\n\n    private ImageTranscoder transcoder;\n\n    public void init() throws LagoonException {\n        String format = getParam(\"format\");\n        if (format == null)\n            throw new LagoonException(\"Image format must be specified\");\n        if (format.equalsIgnoreCase(\"jpeg\")) {\n            transcoder = new JPEGTranscoder();\n            Float quality;\n            String q = getParam(\"quality\");\n            try {\n                quality = new Float(q);\n            } catch (NumberFormatException e) {\n                throw new LagoonException(\"Quality must be a number\");\n            } catch (NullPointerException e) {\n                quality = new Float(0.8);\n            }\n            transcoder.addTranscodingHint(JPEGTranscoder.KEY_QUALITY, quality);\n        } else if (format.equalsIgnoreCase(\"png\")) {\n            transcoder = new PNGTranscoder();\n        } else if (format.equalsIgnoreCase(\"tiff\")) {\n            transcoder = new TIFFTranscoder();\n        } else\n            throw new LagoonException(\"Unknown image format: \" + format);\n    }\n\n    public void start(OutputStream out, final Target target) throws IOException, SAXException {\n        URL sourceURL;\n        String _sourceURL = getSourceMan().getSourceURL();\n        if (Utils.absoluteURL(_sourceURL))\n            sourceURL = new URL(_sourceURL);\n        else if (Utils.pseudoAbsoluteURL(_sourceURL))\n            sourceURL = new java.net.URL(getContext().getSourceRootDir().toURL(), _sourceURL.substring(1));\n        else\n            sourceURL = new java.net.URL(getContext().getSourceRootDir().toURL(), _sourceURL);\n        if (DEBUG)\n            System.out.println(\"The source URL: \" + sourceURL.toString());\n        // Hack to work-around error in Batik 1.5.1\n        SVGOMDocument doc;\n        {\n            String parserClassname = XMLResourceDescriptor.getXMLParserClassName();\n            String namespaceURI = SVGConstants.SVG_NAMESPACE_URI;\n            String documentElement = SVGConstants.SVG_SVG_TAG;\n            SAXSVGDocumentFactory f = new SAXSVGDocumentFactory(parserClassname);\n            f.setValidating(false);\n            doc = (SVGOMDocument) f.createDocument(namespaceURI, documentElement, sourceURL.toString(), new XMLReaderImpl() {\n\n                public void parse(InputSource is) throws SAXException, IOException {\n                    getNext().start(contentHandler, target);\n                }\n            });\n            doc.setURLObject(sourceURL);\n        }\n        TranscoderInput input = new TranscoderInput(doc);\n        /*\n        // This should have been enough         \n\t\tTranscoderInput input = new TranscoderInput(sourceURL.toString());\n        input.setXMLReader(\n\t\t\tnew XMLReaderImpl() {\n\t\t\t\t\tpublic void parse(InputSource is) \n\t\t\t\t\t\tthrows SAXException, IOException\n\t\t\t\t\t{\n\t\t\t\t\t\tgetNext().start(contentHandler, target);\t\t\t\t\t\t\t\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t}); \n*/\n        TranscoderOutput output = new TranscoderOutput(out);\n        try {\n            if (DEBUG)\n                System.out.println(\"about to transcode\");\n            transcoder.transcode(input, output);\n            if (DEBUG)\n                System.out.println(\"transcoding complete\");\n        } catch (TranscoderException e) {\n            throw new SAXException(e);\n        }\n    }\n\n    public boolean hasBeenUpdated(long when) throws LagoonException, IOException {\n        return getNext().hasBeenUpdated(when);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/producer/BatikFormatterTest.java",
		"test_prompt": "// BatikFormatterTest.java\npackage nu.staldal.lagoon.producer;\n\nimport java.io.*;\nimport java.net.URL;\nimport org.xml.sax.*;\nimport org.apache.batik.transcoder.*;\nimport org.apache.batik.transcoder.image.*;\nimport org.apache.batik.dom.svg.*;\nimport org.apache.batik.util.XMLResourceDescriptor;\nimport org.apache.batik.util.SVGConstants;\nimport nu.staldal.lagoon.core.*;\nimport nu.staldal.lagoon.util.*;\nimport nu.staldal.util.Utils;\nimport nu.staldal.xmlutil.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BatikFormatter}.\n* It contains ten unit test cases for the {@link BatikFormatter#hasBeenUpdated(long)} method.\n*/\nclass BatikFormatterTest {"
	},
	{
		"original_code": "// FileSource.java\n/*\n * Copyright (c) 2001, Mikael Stï¿½ldal\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without \n * modification, are permitted provided that the following conditions \n * are met:\n * \n * 1. Redistributions of source code must retain the above copyright \n * notice, this list of conditions and the following disclaimer.\n * \n * 2. Redistributions in binary form must reproduce the above copyright \n * notice, this list of conditions and the following disclaimer in the \n * documentation and/or other materials provided with the distribution.\n * \n * 3. Neither the name of the author nor the names of its contributors \n * may be used to endorse or promote products derived from this software \n * without specific prior written permission. \n * \n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR \n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR \n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, \n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, \n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR \n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY \n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n * \n * \n * Note: This is known as \"the modified BSD license\". It's an approved \n * Open Source and Free Software license, see \n * http://www.opensource.org/licenses/ \n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.lagoon.producer;\n\nimport java.io.*;\nimport org.xml.sax.*;\nimport nu.staldal.lagoon.core.*;\n\npublic class FileSource extends Source {\n\n    public void init() {\n        // nothing to do\n    }\n\n    public void start(ContentHandler sax, Target target) throws IOException, SAXException {\n        getSourceMan().getFileAsSAX(getSourceMan().getSourceURL(), sax, target);\n    }\n\n    public boolean hasBeenUpdated(long when) throws FileNotFoundException, IOException, LagoonException {\n        return getSourceMan().fileHasBeenUpdated(getSourceMan().getSourceURL(), when);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/producer/FileSourceTest.java",
		"test_prompt": "// FileSourceTest.java\npackage nu.staldal.lagoon.producer;\n\nimport java.io.*;\nimport org.xml.sax.*;\nimport nu.staldal.lagoon.core.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileSource}.\n* It contains ten unit test cases for the {@link FileSource#hasBeenUpdated(long)} method.\n*/\nclass FileSourceTest {"
	},
	{
		"original_code": "// XMLParse.java\n/*\n * Copyright (c) 2001-2003, Mikael Stï¿½ldal\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without \n * modification, are permitted provided that the following conditions \n * are met:\n * \n * 1. Redistributions of source code must retain the above copyright \n * notice, this list of conditions and the following disclaimer.\n * \n * 2. Redistributions in binary form must reproduce the above copyright \n * notice, this list of conditions and the following disclaimer in the \n * documentation and/or other materials provided with the distribution.\n * \n * 3. Neither the name of the author nor the names of its contributors \n * may be used to endorse or promote products derived from this software \n * without specific prior written permission. \n * \n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR \n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR \n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, \n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, \n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR \n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY \n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n * \n * \n * Note: This is known as \"the modified BSD license\". It's an approved \n * Open Source and Free Software license, see \n * http://www.opensource.org/licenses/ \n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.lagoon.producer;\n\nimport java.io.*;\nimport javax.xml.parsers.*;\nimport org.xml.sax.*;\nimport nu.staldal.lagoon.core.*;\n\npublic class XMLParse extends Parse implements Runnable {\n\n    private Thread thread;\n\n    private Exception exception;\n\n    private MyInputStream mis;\n\n    private MyOutputStream mos;\n\n    private Target target;\n\n    private SAXParserFactory spf;\n\n    public void init() throws LagoonException {\n        try {\n            spf = SAXParserFactory.newInstance();\n            spf.setNamespaceAware(true);\n            spf.setValidating(false);\n            spf.setFeature(\"http://xml.org/sax/features/namespaces\", true);\n            spf.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", false);\n            spf.setFeature(\"http://xml.org/sax/features/validation\", false);\n        } catch (ParserConfigurationException e) {\n            throw new Error(\"Unable to configure XML parser\");\n        } catch (SAXException e) {\n            throw new Error(\"Unable to configure XML parser\");\n        }\n        target = null;\n    }\n\n    public void start(ContentHandler sax, Target target) throws IOException, SAXException {\n        this.target = target;\n        XMLReader parser;\n        try {\n            parser = spf.newSAXParser().getXMLReader();\n        } catch (ParserConfigurationException e) {\n            throw new LagoonException(e.getMessage());\n        }\n        parser.setContentHandler(sax);\n        parser.setEntityResolver(new EntityResolver() {\n\n            public InputSource resolveEntity(String publicId, String systemId) throws SAXException, IOException {\n                InputSource is = new InputSource(getSourceMan().getFileURL(systemId));\n                File fil = getSourceMan().getFile(systemId);\n                if (fil != null) {\n                    InputStream istr = new FileInputStream(fil);\n                    is.setByteStream(istr);\n                }\n                return is;\n            }\n        });\n        exception = null;\n        mis = new MyInputStream();\n        mos = new MyOutputStream(mis);\n        thread = new Thread(this);\n        thread.start();\n        parser.parse(new InputSource(mis));\n        mis.close();\n        try {\n            thread.join(1000);\n        } catch (InterruptedException e) {\n        }\n        if (thread.isAlive()) {\n            thread.interrupt();\n        }\n        this.target = null;\n        if (exception != null) {\n            if (exception instanceof SAXException) {\n                throw (SAXException) exception;\n            } else if (exception instanceof IOException) {\n                throw (IOException) exception;\n            }\n        }\n    }\n\n    /**\n     * Thread run method.\n     */\n    public void run() {\n        try {\n            getNext().start(mos, target);\n            mos.close();\n        } catch (SAXException e) {\n            exception = e;\n        }// catch (InterruptedIOException e)\n        // {\n        // }\n         catch (IOException e) {\n            exception = e;\n        }\n    }\n\n    public boolean hasBeenUpdated(long when) throws LagoonException, IOException {\n        return getNext().hasBeenUpdated(when);\n    }\n}\n\nclass MyInputStream extends InputStream {\n\n    private int buf;\n\n    private boolean eof;\n\n    private boolean closed;\n\n    MyInputStream() {\n        eof = false;\n        closed = false;\n        buf = -1;\n    }\n\n    public int avaliable() {\n        if (eof || (buf == -1)) {\n            return 0;\n        } else {\n            return 1;\n        }\n    }\n\n    public synchronized int read() throws IOException {\n        if (closed)\n            throw new IOException(\"Attempt to read from closed stream\");\n        if (eof)\n            return -1;\n        while (buf == -1) {\n            try {\n                wait(1000);\n            } catch (InterruptedException e) {\n                throw new InterruptedIOException();\n            }\n            if (eof)\n                return -1;\n        }\n        int b = buf;\n        buf = -1;\n        notify();\n        return b;\n    }\n\n    public void close() {\n        closed = true;\n    }\n\n    synchronized void deliver(int b) throws IOException {\n        if (eof)\n            return;\n        if (closed)\n            throw new IOException(\"Attempt to write to broken pipe\");\n        while (buf != -1) {\n            try {\n                wait(1000);\n            } catch (InterruptedException e) {\n                throw new InterruptedIOException();\n            }\n            if (eof)\n                return;\n            if (closed)\n                throw new IOException(\"Attempt to write to broken pipe\");\n        }\n        buf = b;\n        notify();\n    }\n\n    void eof() {\n        eof = true;\n    }\n}\n\nclass MyOutputStream extends OutputStream {\n\n    private MyInputStream sink;\n\n    private boolean eof;\n\n    MyOutputStream(MyInputStream sink) {\n        this.sink = sink;\n        eof = false;\n    }\n\n    public void write(int b) throws IOException {\n        if (eof)\n            throw new IOException(\"Attempt to write to closed stream\");\n        sink.deliver(b);\n    }\n\n    // public void flush() {}\n    public void close() {\n        if (eof)\n            return;\n        // flush();\n        eof = true;\n        sink.eof();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/producer/XMLParseTest.java",
		"test_prompt": "// XMLParseTest.java\npackage nu.staldal.lagoon.producer;\n\nimport java.io.*;\nimport javax.xml.parsers.*;\nimport org.xml.sax.*;\nimport nu.staldal.lagoon.core.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XMLParse}.\n* It contains ten unit test cases for the {@link XMLParse#hasBeenUpdated(long)} method.\n*/\nclass XMLParseTest {"
	},
	{
		"original_code": "// LSPTransformer.java\n/*\n * Copyright (c) 2001-2003, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.lagoon.producer;\n\nimport java.io.*;\nimport java.util.*;\nimport org.xml.sax.*;\nimport nu.staldal.lsp.*;\nimport nu.staldal.lsp.compiler.*;\nimport nu.staldal.lagoon.core.*;\nimport nu.staldal.util.Utils;\n\npublic class LSPTransformer extends Transform {\n\n    private static final boolean DEBUG = false;\n\n    private LSPCompiler compiler;\n\n    private LSPPage theCompiledPage;\n\n    private HashMap params;\n\n    private String pageName;\n\n    public void init() throws LagoonException, IOException {\n        compiler = new LSPCompiler();\n        pageName = Utils.encodePathAsIdentifier(getEntryName()) + \"_\" + getPosition();\n        theCompiledPage = loadLSPPage();\n        if (DEBUG)\n            if (theCompiledPage == null)\n                System.out.println(\"No compiled page found\");\n        params = new HashMap();\n        for (Enumeration e = getParamNames(); e.hasMoreElements(); ) {\n            String paramName = (String) e.nextElement();\n            params.put(paramName, getParam(paramName));\n        }\n    }\n\n    private LSPPage loadLSPPage() throws LagoonException {\n        try {\n            Class theCompiledPageClass = getContext().loadClassFromRepository(\"_LSP_\" + pageName);\n            LSPPage thePage = (LSPPage) theCompiledPageClass.newInstance();\n            return thePage;\n        } catch (ClassNotFoundException e) {\n            return null;\n        } catch (InstantiationException e) {\n            throw new LagoonException(e.getMessage());\n        } catch (IllegalAccessException e) {\n            throw new LagoonException(e.getMessage());\n        }\n    }\n\n    private boolean sourceUpdated(long when) throws LagoonException, IOException {\n        if (DEBUG)\n            System.out.println(\"Checking compile dynamic\");\n        if (theCompiledPage.isCompileDynamic())\n            return true;\n        if (DEBUG)\n            System.out.println(\"Checking next\");\n        if (getNext().hasBeenUpdated(when)) {\n            return true;\n        }\n        if (DEBUG)\n            System.out.println(\"Checking imported files\");\n        String[] importedFiles = theCompiledPage.getCompileDependentFiles();\n        for (int i = 0; i < importedFiles.length; i++) {\n            String f = importedFiles[i];\n            if (DEBUG)\n                System.out.println(\"Checking imported file: \" + f);\n            if (getSourceMan().fileHasBeenUpdated(f, when)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private void readSource(XMLStreamProducer next, final Target target) throws SAXException, IOException {\n        if (DEBUG)\n            System.out.println(\"LSP compile\");\n        OutputStream out = null;\n        try {\n            ContentHandler ch = compiler.startCompile(pageName, new URLResolver() {\n\n                public void resolve(String url, ContentHandler ch) throws IOException, SAXException {\n                    getSourceMan().getFileAsSAX(url, ch, target);\n                }\n            });\n            next.start(ch, target);\n            out = getContext().storeClassInRepository(\"_LSP_\" + pageName);\n            compiler.finishCompile(out);\n            out.close();\n        } catch (SAXException e) {\n            if (out != null) {\n                out.close();\n                getContext().deleteClassInRepository(\"_LSP_\" + pageName);\n            }\n            throw e;\n        }\n        getContext().reloadClasses();\n        theCompiledPage = loadLSPPage();\n        if (theCompiledPage == null) {\n            throw new LagoonException(\"Unable to load compiled page\");\n        }\n    }\n\n    public void start(ContentHandler ch, final Target target) throws IOException, SAXException {\n        if (target instanceof FileTarget && ((FileTarget) target).isWildcard())\n            throw new LagoonException(\"Cannot use with wildcard pattern\");\n        if ((theCompiledPage == null) || sourceUpdated(theCompiledPage.getTimeCompiled())) {\n            readSource(getNext(), target);\n        }\n        ch.startDocument();\n        theCompiledPage.execute(ch, params, getContext());\n        ch.endDocument();\n    }\n\n    public boolean hasBeenUpdated(long when) throws LagoonException, IOException {\n        // always rebuild (but not always recompile)\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/producer/LSPTransformerTest.java",
		"test_prompt": "// LSPTransformerTest.java\npackage nu.staldal.lagoon.producer;\n\nimport java.io.*;\nimport java.util.*;\nimport org.xml.sax.*;\nimport nu.staldal.lsp.*;\nimport nu.staldal.lsp.compiler.*;\nimport nu.staldal.lagoon.core.*;\nimport nu.staldal.util.Utils;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link LSPTransformer}.\n* It contains ten unit test cases for the {@link LSPTransformer#hasBeenUpdated(long)} method.\n*/\nclass LSPTransformerTest {"
	},
	{
		"original_code": "// IslandSplit.java\n/*\n * Copyright (c) 2002-2004, Mikael Stï¿½ldal\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without \n * modification, are permitted provided that the following conditions \n * are met:\n * \n * 1. Redistributions of source code must retain the above copyright \n * notice, this list of conditions and the following disclaimer.\n * \n * 2. Redistributions in binary form must reproduce the above copyright \n * notice, this list of conditions and the following disclaimer in the \n * documentation and/or other materials provided with the distribution.\n * \n * 3. Neither the name of the author nor the names of its contributors \n * may be used to endorse or promote products derived from this software \n * without specific prior written permission. \n * \n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR \n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR \n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, \n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, \n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR \n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY \n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n * \n * \n * Note: This is known as \"the modified BSD license\". It's an approved \n * Open Source and Free Software license, see \n * http://www.opensource.org/licenses/ \n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.lagoon.producer;\n\nimport java.util.*;\nimport java.io.*;\nimport org.xml.sax.*;\nimport org.xml.sax.helpers.AttributesImpl;\nimport nu.staldal.lagoon.core.*;\nimport nu.staldal.lagoon.util.*;\n\npublic class IslandSplit extends Transform implements ContentHandler {\n\n    private static final boolean DEBUG = false;\n\n    // (String)namespace -> (String)outputName\n    private Hashtable outputDict;\n\n    // (String)namespace -> (String)outputExt\n    private Hashtable outputExtDict;\n\n    private ContentHandler mainSax;\n\n    private ContentHandler sax;\n\n    private Target target;\n\n    private String targetName;\n\n    private int inPart;\n\n    private int imageNumber;\n\n    private String rootNS;\n\n    private Vector prefixVector;\n\n    private Vector uriVector;\n\n    public void init() throws LagoonException {\n        outputDict = new Hashtable();\n        outputExtDict = new Hashtable();\n        for (int i = 1; ; i++) {\n            String ns = getParam(\"namespace\" + i);\n            if (ns == null)\n                break;\n            String output = getParam(\"output\" + i);\n            if (output == null)\n                throw new LagoonException(\"parameter \\'output\" + i + \"\\' must be set\");\n            String outputExt = getParam(\"outputext\" + i);\n            if (outputExt == null)\n                throw new LagoonException(\"parameter \\'outputext\" + i + \"\\' must be set\");\n            outputDict.put(ns, output);\n            outputExtDict.put(ns, outputExt);\n        }\n        mainSax = null;\n        sax = null;\n        target = null;\n    }\n\n    public void start(ContentHandler sax, Target target) throws IOException, SAXException {\n        this.mainSax = sax;\n        this.sax = sax;\n        this.target = target;\n        inPart = 0;\n        imageNumber = 0;\n        rootNS = null;\n        prefixVector = new Vector();\n        uriVector = new Vector();\n        String targetURL = target.getCurrentTargetURL();\n        int slash = targetURL.lastIndexOf('/');\n        targetName = (slash < 0) ? targetURL : targetURL.substring(slash + 1);\n        getNext().start(this, target);\n        this.target = null;\n        this.sax = null;\n        this.mainSax = null;\n    }\n\n    public boolean hasBeenUpdated(long when) throws LagoonException, IOException {\n        return getNext().hasBeenUpdated(when);\n    }\n\n    // SAX ContentHandler implementation\n    public void setDocumentLocator(Locator locator) {\n        sax.setDocumentLocator(locator);\n    }\n\n    public void startDocument() throws SAXException {\n        sax.startDocument();\n    }\n\n    public void endDocument() throws SAXException {\n        sax.endDocument();\n    }\n\n    public void startPrefixMapping(String prefix, String uri) throws SAXException {\n        prefixVector.addElement(prefix);\n        uriVector.addElement(uri);\n    }\n\n    public void startElement(String namespaceURI, String localName, String qName, Attributes atts) throws SAXException {\n        if (rootNS == null)\n            rootNS = namespaceURI;\n        if (DEBUG)\n            System.out.println(\"rootNS = \" + rootNS);\n        String output = (String) outputDict.get(namespaceURI);\n        String outputExt = (String) outputExtDict.get(namespaceURI);\n        if (inPart > 0) {\n            inPart++;\n        } else if (output != null) {\n            try {\n                inPart++;\n                String imageName = targetName + \"_image\" + (++imageNumber) + outputExt;\n                AttributesImpl imgAtts = new AttributesImpl();\n                imgAtts.addAttribute(\"\", \"src\", \"\", \"CDATA\", imageName);\n                imgAtts.addAttribute(\"\", \"alt\", \"\", \"CDATA\", \"\");\n                mainSax.startElement(rootNS, \"img\", \"\", imgAtts);\n                mainSax.endElement(rootNS, \"img\", \"\");\n                sax = ((FileTarget) target).newAsyncTargetWithOutput(imageName, false, output);\n                sax.startDocument();\n            } catch (IOException e) {\n                throw new SAXException(e);\n            }\n        }\n        for (int i = 0; i < prefixVector.size(); i++) {\n            sax.startPrefixMapping((String) prefixVector.elementAt(i), (String) uriVector.elementAt(i));\n        }\n        prefixVector.clear();\n        uriVector.clear();\n        // clear interrupted status\n        Thread.interrupted();\n        sax.startElement(namespaceURI, localName, qName, atts);\n    }\n\n    public void endElement(String namespaceURI, String localName, String qName) throws SAXException {\n        sax.endElement(namespaceURI, localName, qName);\n        if (inPart > 0) {\n            inPart--;\n            if (inPart == 0) {\n                sax.endDocument();\n                sax = mainSax;\n            }\n        }\n    }\n\n    public void endPrefixMapping(String prefix) throws SAXException {\n        // ***\n    }\n\n    public void characters(char[] ch, int start, int length) throws SAXException {\n        sax.characters(ch, start, length);\n    }\n\n    public void ignorableWhitespace(char[] ch, int start, int length) throws SAXException {\n        sax.ignorableWhitespace(ch, start, length);\n    }\n\n    public void processingInstruction(String target, String data) throws SAXException {\n        sax.processingInstruction(target, data);\n    }\n\n    public void skippedEntity(String name) throws SAXException {\n        sax.skippedEntity(name);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/producer/IslandSplitTest.java",
		"test_prompt": "// IslandSplitTest.java\npackage nu.staldal.lagoon.producer;\n\nimport java.util.*;\nimport java.io.*;\nimport org.xml.sax.*;\nimport org.xml.sax.helpers.AttributesImpl;\nimport nu.staldal.lagoon.core.*;\nimport nu.staldal.lagoon.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link IslandSplit}.\n* It contains ten unit test cases for the {@link IslandSplit#hasBeenUpdated(long)} method.\n*/\nclass IslandSplitTest {"
	},
	{
		"original_code": "// DeleteEntry.java\n/*\n * Copyright (c) 2001-2004, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.lagoon.core;\n\nimport java.io.*;\n\n/**\n * An entry in the sitemap to delete a file in the target.\n *\n * @see nu.staldal.lagoon.core.Sitemap\n */\nclass DeleteEntry implements SitemapEntry {\n\n    private static final boolean DEBUG = false;\n\n    private final LagoonProcessor processor;\n\n    private final String targetURL;\n\n    /**\n     * Constructor.\n     *\n     * @param targetURL  the file to create, may contain wildcard anywhere,\n     *                   must be pseudo-absolute.\n     * @param targetStorage  where to store generated files\n     */\n    public DeleteEntry(LagoonProcessor processor, String targetURL) {\n        this.processor = processor;\n        this.targetURL = targetURL;\n    }\n\n    public void destroy() throws IOException {\n        // nothing to do\n    }\n\n    public void beforeBuild(boolean always) throws IOException {\n        // nothing to do\n    }\n\n    public boolean build(boolean always) throws IOException {\n        processor.log.println(\"Deleting: \" + targetURL);\n        processor.getTargetLocation().deleteFile(targetURL);\n        return true;\n    }\n\n    public void afterBuild(boolean always) throws IOException {\n        // nothing to do\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/core/DeleteEntryTest.java",
		"test_prompt": "// DeleteEntryTest.java\npackage nu.staldal.lagoon.core;\n\nimport java.io.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DeleteEntry}.\n* It contains ten unit test cases for the {@link DeleteEntry#build(boolean)} method.\n*/\nclass DeleteEntryTest {"
	},
	{
		"original_code": "// RemoteFileStorage.java\n/*\n * Copyright (c) 2001-2002, Mikael Stï¿½ldal\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without \n * modification, are permitted provided that the following conditions \n * are met:\n * \n * 1. Redistributions of source code must retain the above copyright \n * notice, this list of conditions and the following disclaimer.\n * \n * 2. Redistributions in binary form must reproduce the above copyright \n * notice, this list of conditions and the following disclaimer in the \n * documentation and/or other materials provided with the distribution.\n * \n * 3. Neither the name of the author nor the names of its contributors \n * may be used to endorse or promote products derived from this software \n * without specific prior written permission. \n * \n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR \n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR \n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, \n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, \n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR \n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY \n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n * \n * \n * Note: This is known as \"the modified BSD license\". It's an approved \n * Open Source and Free Software license, see \n * http://www.opensource.org/licenses/ \n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.lagoon.core;\n\nimport java.io.*;\nimport java.util.Hashtable;\n\n/**\n * Helper class to implement a FileStorage which stores file modification\n * dates locally in the Lagoon working directory.\n */\npublic abstract class RemoteFileStorage implements FileStorage {\n\n    private static final boolean DEBUG = false;\n\n    private LagoonContext context;\n\n    private Hashtable lastModTable;\n\n    /**\n     * Open the file to store last update dates locally.\n     * Invoke this from the {@link nu.staldal.lagoon.core.FileStorage#open} method.\n     */\n    protected void openDateFile(LagoonContext context) throws IOException {\n        if (DEBUG)\n            System.out.println(\"RemoteFileStorage.init()\");\n        this.context = context;\n        try {\n            lastModTable = (Hashtable) context.getObjectFromRepository(\"nu.staldal.lagoon.filestorage.RemoteFileStorage\");\n            if (lastModTable == null)\n                lastModTable = new Hashtable();\n        } catch (ClassCastException e) {\n            throw new IOException(\"Date file is corrupt\");\n        }\n    }\n\n    /**\n     * Close the file to store last update dates locally.\n     * Invoke this in the {@link nu.staldal.lagoon.core.FileStorage#close} method.\n     */\n    protected void closeDateFile() throws IOException {\n        context.putObjectIntoRepository(\"nu.staldal.lagoon.filestorage.RemoteFileStorage\", lastModTable);\n    }\n\n    /**\n     * Signals that a file has been created or updated.\n     * Invoke this after successful commitment in the\n     * {@link nu.staldal.lagoon.core.OutputHandler#commit} method.\n     */\n    protected void fileModified(String pathname) {\n        lastModTable.put(pathname, new Long(System.currentTimeMillis()));\n    }\n\n    /**\n     * Check if a file exists and when it was last modified.\n     *\n     * @param pathname  path to the file\n     *\n     * @return  the time when the file was last modified,\n     * or -1 if that information is not avaliable.\n     */\n    public final long fileLastModified(String pathname) // throws java.io.IOException\n    {\n        Long l = (Long) lastModTable.get(pathname);\n        if (l == null)\n            return -1;\n        else\n            return l.longValue();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/core/RemoteFileStorageTest.java",
		"test_prompt": "// RemoteFileStorageTest.java\npackage nu.staldal.lagoon.core;\n\nimport java.io.*;\nimport java.util.Hashtable;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RemoteFileStorage}.\n* It contains ten unit test cases for the {@link RemoteFileStorage#fileLastModified(String)} method.\n*/\nclass RemoteFileStorageTest {"
	},
	{
		"original_code": "// Sitemap.java\n/*\n * Copyright (c) 2001-2004, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.lagoon.core;\n\nimport java.util.*;\nimport org.xml.sax.*;\nimport nu.staldal.xtree.*;\n\n/**\n * Contains the information needed to (re)build a website.\n *\n * Initialized with a sitemap description file.\n * Can then be used to (re)build the website several times.\n */\nclass Sitemap {\n\n    // Associations\n    private Hashtable entries;\n\n    private Vector entryVector;\n\n    private Hashtable parts;\n\n    private Hashtable outputs;\n\n    private Hashtable projectProperties;\n\n    // Attributes\n    private LagoonProcessor processor;\n\n    private java.io.File sourceDir;\n\n    private String siteName;\n\n    // Work attributes\n    private String currentTargetName;\n\n    private SourceManagerProvider currentFile;\n\n    private int depth;\n\n    private Producer bottomProducer;\n\n    private Element sitemapTree;\n\n    /**\n     * The constructor\n     *\n     * @param processor  the processor\n     * @param input  XTree representation of the sitemap\n     * @param sourceDir  where the source files are\n     */\n    public Sitemap(LagoonProcessor processor, Element sitemapTree, java.io.File sourceDir) throws LagoonException {\n        if (!sitemapTree.getLocalName().equals(\"sitemap\")) {\n            throw new LagoonException(\"root element must be <sitemap>\");\n        }\n        siteName = sitemapTree.getAttrValueOrNull(\"name\");\n        this.processor = processor;\n        this.sourceDir = sourceDir;\n        this.sitemapTree = sitemapTree;\n        entries = new Hashtable();\n        entryVector = new Vector();\n        parts = new Hashtable();\n        outputs = new Hashtable();\n        projectProperties = new Hashtable();\n    }\n\n    public void init() throws LagoonException, java.io.IOException {\n        currentFile = null;\n        for (int i = 0; i < sitemapTree.numberOfChildren(); i++) {\n            Node node = sitemapTree.getChild(i);\n            if (!(node instanceof Element))\n                continue;\n            Element entry = (Element) node;\n            if (entry.getLocalName().equals(\"file\")) {\n                currentTargetName = entry.getAttrValueOrNull(\"target\");\n                if (currentTargetName == null || currentTargetName.length() < 1 || currentTargetName.charAt(0) != '/') {\n                    throw new LagoonException(\"invalid target specification: \" + currentTargetName);\n                }\n                String theSource = entry.getAttrValueOrNull(\"source\");\n                if (theSource == null || theSource.length() < 1)\n                    theSource = currentTargetName;\n                currentFile = new FileEntry(processor, this, currentTargetName, theSource, sourceDir, processor.getTempDir());\n                String useOutput = entry.getAttrValueOrNull(\"output\");\n                if (entry.numberOfChildren() == 0) {\n                    if (useOutput == null)\n                        entry.addChild(new Element(\"\", \"read\", 0, 0));\n                    else\n                        entry.addChild(new Element(\"\", \"source\", 0, 0));\n                }\n                depth = 0;\n                Object o = handleProducer(entry);\n                if (o instanceof ByteStreamProducer && (useOutput == null)) {\n                    ((FileEntry) currentFile).setMyProducer((Producer) o);\n                } else if (o instanceof XMLStreamProducer && (useOutput != null)) {\n                    ((FileEntry) currentFile).setMyProducer((Producer) o);\n                    OutputEntry theOutput = (OutputEntry) outputs.get(useOutput);\n                    if (theOutput == null)\n                        throw new LagoonException(\"Output not found: \" + useOutput);\n                    ((FileEntry) currentFile).setMyOutput(theOutput);\n                } else {\n                    throw new LagoonException(\"Inconsistent producer chain: \" + currentTargetName);\n                }\n                entries.put(currentTargetName, currentFile);\n                entryVector.addElement(currentFile);\n            } else if (entry.getLocalName().equals(\"part\")) {\n                currentTargetName = entry.getAttrValueOrNull(\"name\");\n                if (currentTargetName == null || currentTargetName.length() < 1) {\n                    throw new LagoonException(\"part name missing\");\n                }\n                currentFile = new PartEntry(processor, this, entry.getAttrValueOrNull(\"source\"), sourceDir);\n                depth = 0;\n                Object o = handleProducer(entry);\n                if (o instanceof XMLStreamProducer) {\n                    ((PartEntry) currentFile).setMyProducer((XMLStreamProducer) o);\n                } else {\n                    throw new LagoonException(\"Part must contain a XML stream producer: \" + currentTargetName);\n                }\n                parts.put(currentTargetName, currentFile);\n            } else if (entry.getLocalName().equals(\"delete\")) {\n                currentTargetName = entry.getAttrValueOrNull(\"target\");\n                if (currentTargetName == null || currentTargetName.length() < 1 || currentTargetName.charAt(0) != '/') {\n                    throw new LagoonException(\"invalid target specification: \" + currentTargetName);\n                }\n                DeleteEntry currentEnt = new DeleteEntry(processor, currentTargetName);\n                entries.put(currentTargetName, currentEnt);\n                entryVector.addElement(currentEnt);\n            } else if (entry.getLocalName().equals(\"output\")) {\n                currentTargetName = entry.getAttrValueOrNull(\"name\");\n                if (currentTargetName == null || currentTargetName.length() < 1) {\n                    throw new LagoonException(\"output name missing\");\n                }\n                currentFile = new OutputEntry();\n                depth = 0;\n                Object o = handleProducer(entry);\n                if (bottomProducer instanceof XMLStreamConsumer) {\n                    ((OutputEntry) currentFile).setBottomProducer((XMLStreamConsumer) bottomProducer);\n                } else {\n                    throw new LagoonException(\"Output must contain a byte stream producer: \" + currentTargetName);\n                }\n                if (o instanceof ByteStreamProducer) {\n                    ((OutputEntry) currentFile).setMyProducer((ByteStreamProducer) o);\n                } else {\n                    throw new LagoonException(\"Inconsistent producer chain: \" + currentTargetName);\n                }\n                outputs.put(currentTargetName, currentFile);\n            } else if (entry.getLocalName().equals(\"property\")) {\n                String propName = entry.getAttrValueOrNull(\"name\");\n                if (propName == null || propName.length() < 1) {\n                    throw new LagoonException(\"property name missing\");\n                }\n                String propValue = entry.getTextContentOrNull();\n                if (propValue != null)\n                    projectProperties.put(propName, propValue);\n            } else {\n                throw new LagoonException(\"Unknown entry in sitemap: \" + entry.getLocalName());\n            }\n            currentTargetName = null;\n            currentFile = null;\n        }\n        sitemapTree = null;\n    }\n\n    public void destroy() throws java.io.IOException {\n        for (Enumeration e = getEntries(); e.hasMoreElements(); ) {\n            SitemapEntry ent = (SitemapEntry) e.nextElement();\n            ent.destroy();\n        }\n    }\n\n    /**\n     * Get the site name. Or <code>null</code> if no name is defined.\n     */\n    public String getSiteName() {\n        return siteName;\n    }\n\n    /**\n     * Get an Enumeration of all targets in this sitemap.\n     */\n    public Enumeration getTargets() {\n        return entries.keys();\n    }\n\n    /**\n     * Get an Enumeration of all entries in this sitemap.\n     */\n    public Enumeration getEntries() {\n        return entryVector.elements();\n    }\n\n    /**\n     * Lookup a specific entry in the sitemap.\n     *\n     * @param target  the target, a pseudo-absolute URL (starting with '/').\n     *\n     * @returns the entry for the specified target,\n     *  or <code>null</code> if not found.\n     */\n    public SitemapEntry lookupEntry(String target) {\n        return (SitemapEntry) entries.get(target);\n    }\n\n    /**\n     * Lookup a specific part in the sitemap.\n     *\n     * @param name  the name of the part to obtain.\n     *\n     * @returns the part entry with the specified name,\n     *  or <code>null</code> if not found.\n     */\n    public PartEntry lookupPart(String name) {\n        return (PartEntry) parts.get(name);\n    }\n\n    /**\n     * Lookup a specific output entry in the sitemap.\n     *\n     * @param name  the name of the output to obtain.\n     *\n     * @returns the output entry with the specified name,\n     *  or <code>null</code> if not found.\n     */\n    OutputEntry lookupOutput(String name) {\n        return (OutputEntry) outputs.get(name);\n    }\n\n    /**\n     * Return the value of a project property in the Sitemap.\n     *\n     * @param key  the property name\n     *\n     * @return the property value, or <code>null</code> if the property is\n     * \tnot defined.\n     */\n    String getProperty(String key) {\n        return (String) projectProperties.get(key);\n    }\n\n    private Object handleProducer(Element parentEl) throws LagoonException, java.io.IOException {\n        Element el = parentEl.getFirstChildElementOrNull();\n        if (el == null)\n            return parentEl.getTextContentOrNull();\n        if (el.getLocalName().equals(\"format\") || el.getLocalName().equals(\"transform\") || el.getLocalName().equals(\"source\") || el.getLocalName().equals(\"read\") || el.getLocalName().equals(\"parse\") || el.getLocalName().equals(\"process\")) {\n            String type = el.getAttrValueOrNull(\"type\");\n            if (type == null)\n                type = \"\";\n            String prodName = el.getLocalName() + '-' + ((type.length() == 0) ? \"(default)\" : type);\n            Producer prod = processor.createProducer(el.getLocalName(), type);\n            if (prod == null)\n                throw new LagoonException(\"Producer \" + prodName + \" not found\");\n            prod.setEntryName(currentTargetName);\n            prod.setProcessor(processor);\n            prod.setSourceManager(currentFile);\n            prod.setPosition(depth);\n            for (int i = 0; i < el.numberOfAttributes(); i++) {\n                if ((el.getAttributeNamespaceURI(i).length() > 0) || el.getAttributeLocalName(i).equals(\"type\"))\n                    continue;\n                prod.addParam(el.getAttributeLocalName(i), el.getAttributeValue(i));\n            }\n            depth++;\n            Object o = handleProducer(el);\n            if (o == null) {\n                bottomProducer = prod;\n            } else if (o instanceof String) {\n                bottomProducer = prod;\n                String nameParam = ((String) o).trim();\n                if (nameParam.length() > 0)\n                    prod.addParam(\"name\", nameParam);\n            } else if (o instanceof Producer) {\n                try {\n                    Producer nextProd = (Producer) o;\n                    if (prod instanceof ByteStreamConsumer) {\n                        ((ByteStreamConsumer) prod).setNext((ByteStreamProducer) nextProd);\n                    } else if (prod instanceof XMLStreamConsumer) {\n                        ((XMLStreamConsumer) prod).setNext((XMLStreamProducer) nextProd);\n                    } else {\n                        throw new ClassCastException();\n                    }\n                } catch (ClassCastException e) {\n                    throw new LagoonException(prodName + \": Inconsistent Producer chain\");\n                }\n            }\n            try {\n                prod.init();\n            } catch (LagoonException e) {\n                throw new LagoonException(prodName + \": \" + e.getMessage());\n            }\n            return prod;\n        } else {\n            throw new LagoonException(\"Error in Sitemap, unexpected element: \" + el.getLocalName());\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/core/SitemapTest0.java",
		"test_prompt": "// SitemapTest0.java\npackage nu.staldal.lagoon.core;\n\nimport java.util.*;\nimport org.xml.sax.*;\nimport nu.staldal.xtree.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Sitemap}.\n* It contains ten unit test cases for the {@link Sitemap#lookupEntry(String)} method.\n*/\nclass SitemapTest0 {"
	},
	{
		"original_code": "// Sitemap.java\n/*\n * Copyright (c) 2001-2004, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.lagoon.core;\n\nimport java.util.*;\nimport org.xml.sax.*;\nimport nu.staldal.xtree.*;\n\n/**\n * Contains the information needed to (re)build a website.\n *\n * Initialized with a sitemap description file.\n * Can then be used to (re)build the website several times.\n */\nclass Sitemap {\n\n    // Associations\n    private Hashtable entries;\n\n    private Vector entryVector;\n\n    private Hashtable parts;\n\n    private Hashtable outputs;\n\n    private Hashtable projectProperties;\n\n    // Attributes\n    private LagoonProcessor processor;\n\n    private java.io.File sourceDir;\n\n    private String siteName;\n\n    // Work attributes\n    private String currentTargetName;\n\n    private SourceManagerProvider currentFile;\n\n    private int depth;\n\n    private Producer bottomProducer;\n\n    private Element sitemapTree;\n\n    /**\n     * The constructor\n     *\n     * @param processor  the processor\n     * @param input  XTree representation of the sitemap\n     * @param sourceDir  where the source files are\n     */\n    public Sitemap(LagoonProcessor processor, Element sitemapTree, java.io.File sourceDir) throws LagoonException {\n        if (!sitemapTree.getLocalName().equals(\"sitemap\")) {\n            throw new LagoonException(\"root element must be <sitemap>\");\n        }\n        siteName = sitemapTree.getAttrValueOrNull(\"name\");\n        this.processor = processor;\n        this.sourceDir = sourceDir;\n        this.sitemapTree = sitemapTree;\n        entries = new Hashtable();\n        entryVector = new Vector();\n        parts = new Hashtable();\n        outputs = new Hashtable();\n        projectProperties = new Hashtable();\n    }\n\n    public void init() throws LagoonException, java.io.IOException {\n        currentFile = null;\n        for (int i = 0; i < sitemapTree.numberOfChildren(); i++) {\n            Node node = sitemapTree.getChild(i);\n            if (!(node instanceof Element))\n                continue;\n            Element entry = (Element) node;\n            if (entry.getLocalName().equals(\"file\")) {\n                currentTargetName = entry.getAttrValueOrNull(\"target\");\n                if (currentTargetName == null || currentTargetName.length() < 1 || currentTargetName.charAt(0) != '/') {\n                    throw new LagoonException(\"invalid target specification: \" + currentTargetName);\n                }\n                String theSource = entry.getAttrValueOrNull(\"source\");\n                if (theSource == null || theSource.length() < 1)\n                    theSource = currentTargetName;\n                currentFile = new FileEntry(processor, this, currentTargetName, theSource, sourceDir, processor.getTempDir());\n                String useOutput = entry.getAttrValueOrNull(\"output\");\n                if (entry.numberOfChildren() == 0) {\n                    if (useOutput == null)\n                        entry.addChild(new Element(\"\", \"read\", 0, 0));\n                    else\n                        entry.addChild(new Element(\"\", \"source\", 0, 0));\n                }\n                depth = 0;\n                Object o = handleProducer(entry);\n                if (o instanceof ByteStreamProducer && (useOutput == null)) {\n                    ((FileEntry) currentFile).setMyProducer((Producer) o);\n                } else if (o instanceof XMLStreamProducer && (useOutput != null)) {\n                    ((FileEntry) currentFile).setMyProducer((Producer) o);\n                    OutputEntry theOutput = (OutputEntry) outputs.get(useOutput);\n                    if (theOutput == null)\n                        throw new LagoonException(\"Output not found: \" + useOutput);\n                    ((FileEntry) currentFile).setMyOutput(theOutput);\n                } else {\n                    throw new LagoonException(\"Inconsistent producer chain: \" + currentTargetName);\n                }\n                entries.put(currentTargetName, currentFile);\n                entryVector.addElement(currentFile);\n            } else if (entry.getLocalName().equals(\"part\")) {\n                currentTargetName = entry.getAttrValueOrNull(\"name\");\n                if (currentTargetName == null || currentTargetName.length() < 1) {\n                    throw new LagoonException(\"part name missing\");\n                }\n                currentFile = new PartEntry(processor, this, entry.getAttrValueOrNull(\"source\"), sourceDir);\n                depth = 0;\n                Object o = handleProducer(entry);\n                if (o instanceof XMLStreamProducer) {\n                    ((PartEntry) currentFile).setMyProducer((XMLStreamProducer) o);\n                } else {\n                    throw new LagoonException(\"Part must contain a XML stream producer: \" + currentTargetName);\n                }\n                parts.put(currentTargetName, currentFile);\n            } else if (entry.getLocalName().equals(\"delete\")) {\n                currentTargetName = entry.getAttrValueOrNull(\"target\");\n                if (currentTargetName == null || currentTargetName.length() < 1 || currentTargetName.charAt(0) != '/') {\n                    throw new LagoonException(\"invalid target specification: \" + currentTargetName);\n                }\n                DeleteEntry currentEnt = new DeleteEntry(processor, currentTargetName);\n                entries.put(currentTargetName, currentEnt);\n                entryVector.addElement(currentEnt);\n            } else if (entry.getLocalName().equals(\"output\")) {\n                currentTargetName = entry.getAttrValueOrNull(\"name\");\n                if (currentTargetName == null || currentTargetName.length() < 1) {\n                    throw new LagoonException(\"output name missing\");\n                }\n                currentFile = new OutputEntry();\n                depth = 0;\n                Object o = handleProducer(entry);\n                if (bottomProducer instanceof XMLStreamConsumer) {\n                    ((OutputEntry) currentFile).setBottomProducer((XMLStreamConsumer) bottomProducer);\n                } else {\n                    throw new LagoonException(\"Output must contain a byte stream producer: \" + currentTargetName);\n                }\n                if (o instanceof ByteStreamProducer) {\n                    ((OutputEntry) currentFile).setMyProducer((ByteStreamProducer) o);\n                } else {\n                    throw new LagoonException(\"Inconsistent producer chain: \" + currentTargetName);\n                }\n                outputs.put(currentTargetName, currentFile);\n            } else if (entry.getLocalName().equals(\"property\")) {\n                String propName = entry.getAttrValueOrNull(\"name\");\n                if (propName == null || propName.length() < 1) {\n                    throw new LagoonException(\"property name missing\");\n                }\n                String propValue = entry.getTextContentOrNull();\n                if (propValue != null)\n                    projectProperties.put(propName, propValue);\n            } else {\n                throw new LagoonException(\"Unknown entry in sitemap: \" + entry.getLocalName());\n            }\n            currentTargetName = null;\n            currentFile = null;\n        }\n        sitemapTree = null;\n    }\n\n    public void destroy() throws java.io.IOException {\n        for (Enumeration e = getEntries(); e.hasMoreElements(); ) {\n            SitemapEntry ent = (SitemapEntry) e.nextElement();\n            ent.destroy();\n        }\n    }\n\n    /**\n     * Get the site name. Or <code>null</code> if no name is defined.\n     */\n    public String getSiteName() {\n        return siteName;\n    }\n\n    /**\n     * Get an Enumeration of all targets in this sitemap.\n     */\n    public Enumeration getTargets() {\n        return entries.keys();\n    }\n\n    /**\n     * Get an Enumeration of all entries in this sitemap.\n     */\n    public Enumeration getEntries() {\n        return entryVector.elements();\n    }\n\n    /**\n     * Lookup a specific entry in the sitemap.\n     *\n     * @param target  the target, a pseudo-absolute URL (starting with '/').\n     *\n     * @returns the entry for the specified target,\n     *  or <code>null</code> if not found.\n     */\n    public SitemapEntry lookupEntry(String target) {\n        return (SitemapEntry) entries.get(target);\n    }\n\n    /**\n     * Lookup a specific part in the sitemap.\n     *\n     * @param name  the name of the part to obtain.\n     *\n     * @returns the part entry with the specified name,\n     *  or <code>null</code> if not found.\n     */\n    public PartEntry lookupPart(String name) {\n        return (PartEntry) parts.get(name);\n    }\n\n    /**\n     * Lookup a specific output entry in the sitemap.\n     *\n     * @param name  the name of the output to obtain.\n     *\n     * @returns the output entry with the specified name,\n     *  or <code>null</code> if not found.\n     */\n    OutputEntry lookupOutput(String name) {\n        return (OutputEntry) outputs.get(name);\n    }\n\n    /**\n     * Return the value of a project property in the Sitemap.\n     *\n     * @param key  the property name\n     *\n     * @return the property value, or <code>null</code> if the property is\n     * \tnot defined.\n     */\n    String getProperty(String key) {\n        return (String) projectProperties.get(key);\n    }\n\n    private Object handleProducer(Element parentEl) throws LagoonException, java.io.IOException {\n        Element el = parentEl.getFirstChildElementOrNull();\n        if (el == null)\n            return parentEl.getTextContentOrNull();\n        if (el.getLocalName().equals(\"format\") || el.getLocalName().equals(\"transform\") || el.getLocalName().equals(\"source\") || el.getLocalName().equals(\"read\") || el.getLocalName().equals(\"parse\") || el.getLocalName().equals(\"process\")) {\n            String type = el.getAttrValueOrNull(\"type\");\n            if (type == null)\n                type = \"\";\n            String prodName = el.getLocalName() + '-' + ((type.length() == 0) ? \"(default)\" : type);\n            Producer prod = processor.createProducer(el.getLocalName(), type);\n            if (prod == null)\n                throw new LagoonException(\"Producer \" + prodName + \" not found\");\n            prod.setEntryName(currentTargetName);\n            prod.setProcessor(processor);\n            prod.setSourceManager(currentFile);\n            prod.setPosition(depth);\n            for (int i = 0; i < el.numberOfAttributes(); i++) {\n                if ((el.getAttributeNamespaceURI(i).length() > 0) || el.getAttributeLocalName(i).equals(\"type\"))\n                    continue;\n                prod.addParam(el.getAttributeLocalName(i), el.getAttributeValue(i));\n            }\n            depth++;\n            Object o = handleProducer(el);\n            if (o == null) {\n                bottomProducer = prod;\n            } else if (o instanceof String) {\n                bottomProducer = prod;\n                String nameParam = ((String) o).trim();\n                if (nameParam.length() > 0)\n                    prod.addParam(\"name\", nameParam);\n            } else if (o instanceof Producer) {\n                try {\n                    Producer nextProd = (Producer) o;\n                    if (prod instanceof ByteStreamConsumer) {\n                        ((ByteStreamConsumer) prod).setNext((ByteStreamProducer) nextProd);\n                    } else if (prod instanceof XMLStreamConsumer) {\n                        ((XMLStreamConsumer) prod).setNext((XMLStreamProducer) nextProd);\n                    } else {\n                        throw new ClassCastException();\n                    }\n                } catch (ClassCastException e) {\n                    throw new LagoonException(prodName + \": Inconsistent Producer chain\");\n                }\n            }\n            try {\n                prod.init();\n            } catch (LagoonException e) {\n                throw new LagoonException(prodName + \": \" + e.getMessage());\n            }\n            return prod;\n        } else {\n            throw new LagoonException(\"Error in Sitemap, unexpected element: \" + el.getLocalName());\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/core/SitemapTest1.java",
		"test_prompt": "// SitemapTest1.java\npackage nu.staldal.lagoon.core;\n\nimport java.util.*;\nimport org.xml.sax.*;\nimport nu.staldal.xtree.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Sitemap}.\n* It contains ten unit test cases for the {@link Sitemap#lookupPart(String)} method.\n*/\nclass SitemapTest1 {"
	},
	{
		"original_code": "// Producer.java\n/*\n * Copyright (c) 2001-2002, Mikael Stï¿½ldal\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without \n * modification, are permitted provided that the following conditions \n * are met:\n * \n * 1. Redistributions of source code must retain the above copyright \n * notice, this list of conditions and the following disclaimer.\n * \n * 2. Redistributions in binary form must reproduce the above copyright \n * notice, this list of conditions and the following disclaimer in the \n * documentation and/or other materials provided with the distribution.\n * \n * 3. Neither the name of the author nor the names of its contributors \n * may be used to endorse or promote products derived from this software \n * without specific prior written permission. \n * \n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR \n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR \n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, \n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, \n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR \n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY \n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n * \n * \n * Note: This is known as \"the modified BSD license\". It's an approved \n * Open Source and Free Software license, see \n * http://www.opensource.org/licenses/ \n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.lagoon.core;\n\nimport java.io.*;\nimport java.util.*;\nimport nu.staldal.util.Utils;\n\n/**\n * A Producer is one step in the pipeline process to build a\n * file in a website.\n */\npublic abstract class Producer implements ProducerInterface {\n\n    /**\n     * Parameters to this producer.\n     */\n    private Hashtable params = new Hashtable();\n\n    private String entryName;\n\n    private SourceManagerProvider sourceMan = null;\n\n    private LagoonProcessor processor = null;\n\n    private int position = 0;\n\n    public void destroy() throws java.io.IOException {\n        // empty default implementation\n    }\n\n    public void beforeBuild() throws java.io.IOException {\n        // empty default implementation\n    }\n\n    public void afterBuild() throws java.io.IOException {\n        // empty default implementation\n    }\n\n    void doDestroy() throws java.io.IOException {\n        destroy();\n    }\n\n    void doBeforeBuild() throws java.io.IOException {\n        beforeBuild();\n    }\n\n    void doAfterBuild() throws java.io.IOException {\n        afterBuild();\n    }\n\n    /**\n     * Set the name of the sitemap entry this producer is associated with.\n     * Used during initialization.\n     */\n    void setEntryName(String entryName) {\n        this.entryName = entryName;\n    }\n\n    /**\n     * Get the name of the sitemap entry this producer is associated with.\n     */\n    public String getEntryName() {\n        return entryName;\n    }\n\n    /**\n     * Set the SourceManagerProvider this producer is associated with.\n     * Used during initialization.\n     */\n    void setSourceManager(SourceManagerProvider sourceMan) {\n        this.sourceMan = sourceMan;\n    }\n\n    /**\n     * Set the position of this producer in the pipeline.\n     * Used during initialization.\n     */\n    void setPosition(int pos) {\n        this.position = pos;\n    }\n\n    /**\n     * Get the position of this producer in the pipeline.\n     */\n    public int getPosition() {\n        return position;\n    }\n\n    /**\n     * Set the LagoonProcessor this producer is associated with.\n     * Used during initialization.\n     */\n    void setProcessor(LagoonProcessor processor) {\n        this.processor = processor;\n    }\n\n    /**\n     * Get the SourceManager this producer is associated with.\n     */\n    public SourceManager getSourceMan() {\n        if (sourceMan == null)\n            throw new RuntimeException(\"No SourceManager avaliable\");\n        SourceManager sm = sourceMan.getSourceManager();\n        if (sm == null)\n            throw new RuntimeException(\"No SourceManager avaliable\");\n        return sm;\n    }\n\n    /**\n     * Get the LagoonContext this producer is associated with.\n     */\n    public LagoonContext getContext() {\n        return processor;\n    }\n\n    /**\n     * Add a parameter to this producer.\n     * Used during initialization.\n     *\n     * @param name  the name of the paramter\n     * @param value  the value of the parameter\n     */\n    void addParam(String name, String value) {\n        params.put(name, value);\n    }\n\n    /**\n     * Get a parameter.\n     *\n     * @param name  the name of the parameter to get\n     * @return  the value of the requested parameter,\n     *           or null if the parameter doesn't exitst\n     */\n    public String getParam(String name) {\n        return (String) params.get(name);\n    }\n\n    /**\n     * Get an Enumeration of all parameter names.\n     */\n    public Enumeration getParamNames() {\n        return params.keys();\n    }\n\n    private String makeKey(String key) {\n        return getClass().getName() + \".\" + position + \".\" + key;\n    }\n\n    /**\n     * Read from a file in the repository.\n     * Read from the returned InputStream and close() it.\n     *\n     * @param key  the key to locate the file\n     *\n     * @return an InputStream to read the file from, or <code>null</code>\n     * if the file wasn't found.\n     */\n    public InputStream readFileFromRepository(String key) {\n        return processor.readFileFromRepository(Utils.encodePath(entryName), makeKey(key));\n    }\n\n    /**\n     * Store a file in the repository.\n     * Write to the returned OutputStream and close() it.\n     *\n     * @param key  the key to locate the file\n     *\n     * @return  an OutputStream to write to the file, or <code>null</code>\n     *          if the repository is unavailable.\n     */\n    public OutputStream storeFileInRepository(String key) throws IOException {\n        return processor.storeFileInRepository(Utils.encodePath(entryName), makeKey(key));\n    }\n\n    /**\n     * Get an object from the repository.\n     *\n     * @param key  the key to locate the object\n     *\n     * @return  the object, or <code>null</code> if not found\n     */\n    public Object getObjectFromRepository(String key) throws java.io.IOException {\n        return processor.getObjectFromRepository(Utils.encodePath(entryName), makeKey(key));\n    }\n\n    /**\n     *  Store an object into the repository.\n     *\n     *  @param key  the key to locate the object\n     *  @param obj  the object to store, must be Serializable\n     *\n     *  @return <code>true</code> if successful,\n     * \t\t   <code>false</code> if the repository is unavailable.\n     */\n    public boolean putObjectIntoRepository(String key, Object obj) throws java.io.IOException {\n        return processor.putObjectIntoRepository(Utils.encodePath(entryName), makeKey(key), obj);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/core/ProducerTest0.java",
		"test_prompt": "// ProducerTest0.java\npackage nu.staldal.lagoon.core;\n\nimport java.io.*;\nimport java.util.*;\nimport nu.staldal.util.Utils;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Producer}.\n* It contains ten unit test cases for the {@link Producer#readFileFromRepository(String)} method.\n*/\nclass ProducerTest0 {"
	},
	{
		"original_code": "// Producer.java\n/*\n * Copyright (c) 2001-2002, Mikael Stï¿½ldal\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without \n * modification, are permitted provided that the following conditions \n * are met:\n * \n * 1. Redistributions of source code must retain the above copyright \n * notice, this list of conditions and the following disclaimer.\n * \n * 2. Redistributions in binary form must reproduce the above copyright \n * notice, this list of conditions and the following disclaimer in the \n * documentation and/or other materials provided with the distribution.\n * \n * 3. Neither the name of the author nor the names of its contributors \n * may be used to endorse or promote products derived from this software \n * without specific prior written permission. \n * \n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR \n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR \n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, \n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, \n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR \n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY \n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n * \n * \n * Note: This is known as \"the modified BSD license\". It's an approved \n * Open Source and Free Software license, see \n * http://www.opensource.org/licenses/ \n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.lagoon.core;\n\nimport java.io.*;\nimport java.util.*;\nimport nu.staldal.util.Utils;\n\n/**\n * A Producer is one step in the pipeline process to build a\n * file in a website.\n */\npublic abstract class Producer implements ProducerInterface {\n\n    /**\n     * Parameters to this producer.\n     */\n    private Hashtable params = new Hashtable();\n\n    private String entryName;\n\n    private SourceManagerProvider sourceMan = null;\n\n    private LagoonProcessor processor = null;\n\n    private int position = 0;\n\n    public void destroy() throws java.io.IOException {\n        // empty default implementation\n    }\n\n    public void beforeBuild() throws java.io.IOException {\n        // empty default implementation\n    }\n\n    public void afterBuild() throws java.io.IOException {\n        // empty default implementation\n    }\n\n    void doDestroy() throws java.io.IOException {\n        destroy();\n    }\n\n    void doBeforeBuild() throws java.io.IOException {\n        beforeBuild();\n    }\n\n    void doAfterBuild() throws java.io.IOException {\n        afterBuild();\n    }\n\n    /**\n     * Set the name of the sitemap entry this producer is associated with.\n     * Used during initialization.\n     */\n    void setEntryName(String entryName) {\n        this.entryName = entryName;\n    }\n\n    /**\n     * Get the name of the sitemap entry this producer is associated with.\n     */\n    public String getEntryName() {\n        return entryName;\n    }\n\n    /**\n     * Set the SourceManagerProvider this producer is associated with.\n     * Used during initialization.\n     */\n    void setSourceManager(SourceManagerProvider sourceMan) {\n        this.sourceMan = sourceMan;\n    }\n\n    /**\n     * Set the position of this producer in the pipeline.\n     * Used during initialization.\n     */\n    void setPosition(int pos) {\n        this.position = pos;\n    }\n\n    /**\n     * Get the position of this producer in the pipeline.\n     */\n    public int getPosition() {\n        return position;\n    }\n\n    /**\n     * Set the LagoonProcessor this producer is associated with.\n     * Used during initialization.\n     */\n    void setProcessor(LagoonProcessor processor) {\n        this.processor = processor;\n    }\n\n    /**\n     * Get the SourceManager this producer is associated with.\n     */\n    public SourceManager getSourceMan() {\n        if (sourceMan == null)\n            throw new RuntimeException(\"No SourceManager avaliable\");\n        SourceManager sm = sourceMan.getSourceManager();\n        if (sm == null)\n            throw new RuntimeException(\"No SourceManager avaliable\");\n        return sm;\n    }\n\n    /**\n     * Get the LagoonContext this producer is associated with.\n     */\n    public LagoonContext getContext() {\n        return processor;\n    }\n\n    /**\n     * Add a parameter to this producer.\n     * Used during initialization.\n     *\n     * @param name  the name of the paramter\n     * @param value  the value of the parameter\n     */\n    void addParam(String name, String value) {\n        params.put(name, value);\n    }\n\n    /**\n     * Get a parameter.\n     *\n     * @param name  the name of the parameter to get\n     * @return  the value of the requested parameter,\n     *           or null if the parameter doesn't exitst\n     */\n    public String getParam(String name) {\n        return (String) params.get(name);\n    }\n\n    /**\n     * Get an Enumeration of all parameter names.\n     */\n    public Enumeration getParamNames() {\n        return params.keys();\n    }\n\n    private String makeKey(String key) {\n        return getClass().getName() + \".\" + position + \".\" + key;\n    }\n\n    /**\n     * Read from a file in the repository.\n     * Read from the returned InputStream and close() it.\n     *\n     * @param key  the key to locate the file\n     *\n     * @return an InputStream to read the file from, or <code>null</code>\n     * if the file wasn't found.\n     */\n    public InputStream readFileFromRepository(String key) {\n        return processor.readFileFromRepository(Utils.encodePath(entryName), makeKey(key));\n    }\n\n    /**\n     * Store a file in the repository.\n     * Write to the returned OutputStream and close() it.\n     *\n     * @param key  the key to locate the file\n     *\n     * @return  an OutputStream to write to the file, or <code>null</code>\n     *          if the repository is unavailable.\n     */\n    public OutputStream storeFileInRepository(String key) throws IOException {\n        return processor.storeFileInRepository(Utils.encodePath(entryName), makeKey(key));\n    }\n\n    /**\n     * Get an object from the repository.\n     *\n     * @param key  the key to locate the object\n     *\n     * @return  the object, or <code>null</code> if not found\n     */\n    public Object getObjectFromRepository(String key) throws java.io.IOException {\n        return processor.getObjectFromRepository(Utils.encodePath(entryName), makeKey(key));\n    }\n\n    /**\n     *  Store an object into the repository.\n     *\n     *  @param key  the key to locate the object\n     *  @param obj  the object to store, must be Serializable\n     *\n     *  @return <code>true</code> if successful,\n     * \t\t   <code>false</code> if the repository is unavailable.\n     */\n    public boolean putObjectIntoRepository(String key, Object obj) throws java.io.IOException {\n        return processor.putObjectIntoRepository(Utils.encodePath(entryName), makeKey(key), obj);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/core/ProducerTest1.java",
		"test_prompt": "// ProducerTest1.java\npackage nu.staldal.lagoon.core;\n\nimport java.io.*;\nimport java.util.*;\nimport nu.staldal.util.Utils;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Producer}.\n* It contains ten unit test cases for the {@link Producer#storeFileInRepository(String)} method.\n*/\nclass ProducerTest1 {"
	},
	{
		"original_code": "// Producer.java\n/*\n * Copyright (c) 2001-2002, Mikael Stï¿½ldal\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without \n * modification, are permitted provided that the following conditions \n * are met:\n * \n * 1. Redistributions of source code must retain the above copyright \n * notice, this list of conditions and the following disclaimer.\n * \n * 2. Redistributions in binary form must reproduce the above copyright \n * notice, this list of conditions and the following disclaimer in the \n * documentation and/or other materials provided with the distribution.\n * \n * 3. Neither the name of the author nor the names of its contributors \n * may be used to endorse or promote products derived from this software \n * without specific prior written permission. \n * \n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR \n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR \n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, \n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, \n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR \n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY \n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n * \n * \n * Note: This is known as \"the modified BSD license\". It's an approved \n * Open Source and Free Software license, see \n * http://www.opensource.org/licenses/ \n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.lagoon.core;\n\nimport java.io.*;\nimport java.util.*;\nimport nu.staldal.util.Utils;\n\n/**\n * A Producer is one step in the pipeline process to build a\n * file in a website.\n */\npublic abstract class Producer implements ProducerInterface {\n\n    /**\n     * Parameters to this producer.\n     */\n    private Hashtable params = new Hashtable();\n\n    private String entryName;\n\n    private SourceManagerProvider sourceMan = null;\n\n    private LagoonProcessor processor = null;\n\n    private int position = 0;\n\n    public void destroy() throws java.io.IOException {\n        // empty default implementation\n    }\n\n    public void beforeBuild() throws java.io.IOException {\n        // empty default implementation\n    }\n\n    public void afterBuild() throws java.io.IOException {\n        // empty default implementation\n    }\n\n    void doDestroy() throws java.io.IOException {\n        destroy();\n    }\n\n    void doBeforeBuild() throws java.io.IOException {\n        beforeBuild();\n    }\n\n    void doAfterBuild() throws java.io.IOException {\n        afterBuild();\n    }\n\n    /**\n     * Set the name of the sitemap entry this producer is associated with.\n     * Used during initialization.\n     */\n    void setEntryName(String entryName) {\n        this.entryName = entryName;\n    }\n\n    /**\n     * Get the name of the sitemap entry this producer is associated with.\n     */\n    public String getEntryName() {\n        return entryName;\n    }\n\n    /**\n     * Set the SourceManagerProvider this producer is associated with.\n     * Used during initialization.\n     */\n    void setSourceManager(SourceManagerProvider sourceMan) {\n        this.sourceMan = sourceMan;\n    }\n\n    /**\n     * Set the position of this producer in the pipeline.\n     * Used during initialization.\n     */\n    void setPosition(int pos) {\n        this.position = pos;\n    }\n\n    /**\n     * Get the position of this producer in the pipeline.\n     */\n    public int getPosition() {\n        return position;\n    }\n\n    /**\n     * Set the LagoonProcessor this producer is associated with.\n     * Used during initialization.\n     */\n    void setProcessor(LagoonProcessor processor) {\n        this.processor = processor;\n    }\n\n    /**\n     * Get the SourceManager this producer is associated with.\n     */\n    public SourceManager getSourceMan() {\n        if (sourceMan == null)\n            throw new RuntimeException(\"No SourceManager avaliable\");\n        SourceManager sm = sourceMan.getSourceManager();\n        if (sm == null)\n            throw new RuntimeException(\"No SourceManager avaliable\");\n        return sm;\n    }\n\n    /**\n     * Get the LagoonContext this producer is associated with.\n     */\n    public LagoonContext getContext() {\n        return processor;\n    }\n\n    /**\n     * Add a parameter to this producer.\n     * Used during initialization.\n     *\n     * @param name  the name of the paramter\n     * @param value  the value of the parameter\n     */\n    void addParam(String name, String value) {\n        params.put(name, value);\n    }\n\n    /**\n     * Get a parameter.\n     *\n     * @param name  the name of the parameter to get\n     * @return  the value of the requested parameter,\n     *           or null if the parameter doesn't exitst\n     */\n    public String getParam(String name) {\n        return (String) params.get(name);\n    }\n\n    /**\n     * Get an Enumeration of all parameter names.\n     */\n    public Enumeration getParamNames() {\n        return params.keys();\n    }\n\n    private String makeKey(String key) {\n        return getClass().getName() + \".\" + position + \".\" + key;\n    }\n\n    /**\n     * Read from a file in the repository.\n     * Read from the returned InputStream and close() it.\n     *\n     * @param key  the key to locate the file\n     *\n     * @return an InputStream to read the file from, or <code>null</code>\n     * if the file wasn't found.\n     */\n    public InputStream readFileFromRepository(String key) {\n        return processor.readFileFromRepository(Utils.encodePath(entryName), makeKey(key));\n    }\n\n    /**\n     * Store a file in the repository.\n     * Write to the returned OutputStream and close() it.\n     *\n     * @param key  the key to locate the file\n     *\n     * @return  an OutputStream to write to the file, or <code>null</code>\n     *          if the repository is unavailable.\n     */\n    public OutputStream storeFileInRepository(String key) throws IOException {\n        return processor.storeFileInRepository(Utils.encodePath(entryName), makeKey(key));\n    }\n\n    /**\n     * Get an object from the repository.\n     *\n     * @param key  the key to locate the object\n     *\n     * @return  the object, or <code>null</code> if not found\n     */\n    public Object getObjectFromRepository(String key) throws java.io.IOException {\n        return processor.getObjectFromRepository(Utils.encodePath(entryName), makeKey(key));\n    }\n\n    /**\n     *  Store an object into the repository.\n     *\n     *  @param key  the key to locate the object\n     *  @param obj  the object to store, must be Serializable\n     *\n     *  @return <code>true</code> if successful,\n     * \t\t   <code>false</code> if the repository is unavailable.\n     */\n    public boolean putObjectIntoRepository(String key, Object obj) throws java.io.IOException {\n        return processor.putObjectIntoRepository(Utils.encodePath(entryName), makeKey(key), obj);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/core/ProducerTest2.java",
		"test_prompt": "// ProducerTest2.java\npackage nu.staldal.lagoon.core;\n\nimport java.io.*;\nimport java.util.*;\nimport nu.staldal.util.Utils;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Producer}.\n* It contains ten unit test cases for the {@link Producer#putObjectIntoRepository(String, Object)} method.\n*/\nclass ProducerTest2 {"
	},
	{
		"original_code": "// FileEntry.java\n/*\n * Copyright (c) 2001-2004, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.lagoon.core;\n\nimport java.io.*;\nimport java.util.*;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport javax.xml.parsers.*;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.stream.StreamSource;\nimport org.xml.sax.*;\nimport nu.staldal.lagoon.util.*;\nimport nu.staldal.util.Utils;\n\n/**\n * A file in the sitemap.\n *\n * Contains information on how to (re)build a single file in a website.\n *\n * @see nu.staldal.lagoon.core.Sitemap\n */\nclass FileEntry extends EntryWithSource implements SitemapEntry, FileTarget {\n\n    private static final boolean DEBUG = true;\n\n    private Producer myProducer;\n\n    private OutputEntry outputEntry;\n\n    private final FileStorage targetStorage;\n\n    private final File tempDir;\n\n    private final String targetURL;\n\n    private String currentSourceURL;\n\n    private String currentTargetURL;\n\n    private String currentTargetDir;\n\n    private String currentTargetName;\n\n    private long targetLastMod;\n\n    private String newTarget;\n\n    private Vector tempFiles;\n\n    private Vector targetThreads;\n\n    /**\n     * Constructor.\n     *\n     * @param processor the LagoonProcessor.\n     * @param sitemap  the Sitemap.\n     * @param targetURL  the file to create, may contain wildcard anywhere,\n     *                   must be pseudo-absolute.\n     * @param sourceURL  the file to use, may contain wildcard in filename,\n     *                  must absolute or pseudo-absolute, may be <code>null</code>.\n     * @param sourceRootDir  absolute path to the source directory\n     * @param tempDir\twhere to store temporary files\n     */\n    public FileEntry(LagoonProcessor processor, Sitemap sitemap, String targetURL, String sourceURL, File sourceRootDir, File tempDir) throws LagoonException {\n        super(processor, sitemap, sourceURL, sourceRootDir);\n        this.targetStorage = processor.getTargetLocation();\n        this.tempDir = tempDir;\n        this.targetURL = targetURL;\n        this.myProducer = null;\n        this.outputEntry = null;\n        this.currentSourceURL = null;\n        this.currentTargetURL = null;\n        this.targetLastMod = -1;\n        this.newTarget = null;\n        this.targetThreads = new Vector();\n    }\n\n    public void destroy() throws IOException {\n        if (myProducer != null)\n            myProducer.doDestroy();\n    }\n\n    public void beforeBuild(boolean always) throws IOException {\n        if (myProducer != null)\n            myProducer.doBeforeBuild();\n    }\n\n    public void afterBuild(boolean always) throws IOException {\n        if (myProducer != null)\n            myProducer.doAfterBuild();\n    }\n\n    /**\n     * Set the ByteStreamProducer that produces the final output for this\n     * FileEntry.\n     * Used during initialization.\n     */\n    void setMyProducer(Producer prod) {\n        myProducer = prod;\n    }\n\n    void setMyOutput(OutputEntry outputEntry) {\n        this.outputEntry = outputEntry;\n    }\n\n    public boolean build(boolean always) throws IOException {\n        if (sourceURL == null) {\n            // no main source\n            currentSourceURL = null;\n            currentTargetURL = targetURL;\n            return buildFile(always);\n        } else if (Utils.absoluteURL(sourceURL)) {\n            // absolute URL\n            currentSourceURL = sourceURL;\n            currentTargetURL = targetURL;\n            return buildFile(always);\n        } else if (Wildcard.isWildcard(sourceURL)) {\n            // main source is a wildcard pattern\n            int slash = sourceURL.lastIndexOf('/');\n            String sourceDirURL = sourceURL.substring(0, slash + 1);\n            String sourceMask = sourceURL.substring(slash + 1);\n            File sourceDir = new File(sourceRootDir, sourceDirURL);\n            String[] files = sourceDir.list();\n            if (files == null) {\n                throw new FileNotFoundException(sourceDir.getAbsolutePath() + \" (directory not found)\");\n            }\n            boolean success = true;\n            for (int i = 0; i < files.length; i++) {\n                File currentSourceFile = new File(sourceDir, files[i]);\n                if (!currentSourceFile.isFile())\n                    continue;\n                String part = Wildcard.matchWildcard(sourceMask, files[i]);\n                if (part == null)\n                    continue;\n                currentSourceURL = sourceDirURL + files[i];\n                currentTargetURL = Wildcard.instantiateWildcard(targetURL, part);\n                if (!buildFile(always))\n                    success = false;\n            }\n            return success;\n        } else {\n            // main source is a regular file\n            currentSourceURL = sourceURL;\n            currentTargetURL = targetURL;\n            return buildFile(always);\n        }\n    }\n\n    private boolean buildFile(boolean always) throws IOException {\n        targetLastMod = targetStorage.fileLastModified(currentTargetURL);\n        if (always || (targetLastMod <= 0)) {\n            return buildAlways();\n        }\n        boolean success = true;\n        boolean updated = false;\n        try {\n            updated = myProducer.hasBeenUpdated(targetLastMod);\n        } catch (LagoonException e) {\n            reportException(e);\n            success = false;\n        } catch (IOException e) {\n            reportException(e);\n            success = false;\n        }\n        if (updated) {\n            if (!buildAlways())\n                success = false;\n        }\n        return success;\n    }\n\n    /**\n     * The actual building of this file.\n     * Used after any dependency checking indicates the file needs rebuilding.\n     */\n    private boolean buildAlways() throws IOException {\n        processor.log.println(\"Building: \" + currentTargetURL);\n        int slash = currentTargetURL.lastIndexOf('/');\n        currentTargetDir = currentTargetURL.substring(0, slash + 1);\n        currentTargetName = currentTargetURL.substring(slash + 1);\n        String thisTargetURL;\n        OutputHandler out = null;\n        String exceptionType = null;\n        boolean bailOut = false;\n        boolean success = true;\n        ByteStreamProducer theProducer;\n        if (outputEntry == null) {\n            theProducer = (ByteStreamProducer) myProducer;\n        } else {\n            outputEntry.setNext((XMLStreamProducer) myProducer);\n            outputEntry.setSourceManager(this);\n            theProducer = outputEntry.getByteProducer();\n        }\n        tempFiles = new Vector();\n        newTarget = currentTargetName;\n        do {\n            thisTargetURL = currentTargetDir + newTarget;\n            newTarget = null;\n            out = targetStorage.createFile(thisTargetURL);\n            try {\n                theProducer.start(out.getOutputStream(), this);\n                // no exception thrown\n                exceptionType = null;\n            } catch (Exception e) {\n                success = false;\n                if (DEBUG)\n                    e.printStackTrace();\n                String thisExceptionType = e.getClass().getName();\n                // the same type of exception thrown twice in a row\n                if (thisExceptionType.equals(exceptionType)) {\n                    bailOut = true;\n                }\n                exceptionType = thisExceptionType;\n                e = reportException(e);\n                if (out != null)\n                    out.discard();\n                if (e instanceof RuntimeException) {\n                    throw (RuntimeException) e;\n                }\n                if (bailOut) {\n                    processor.err.println(\"Error building \" + currentTargetURL + \": Too many exceptions, bailing out\");\n                    break;\n                } else {\n                    continue;\n                }\n            }\n            out.commit();\n        } while (newTarget != null);\n        byte[] buf = new byte[8192];\n        for (int i = 0; i < tempFiles.size(); i++) {\n            String path = (String) tempFiles.elementAt(i);\n            File tempFile = new File(tempDir, \"temp\" + i);\n            FileInputStream fis = new FileInputStream(tempFile);\n            OutputHandler oh = targetStorage.createFile(path);\n            try {\n                while (true) {\n                    int bytesRead = fis.read(buf);\n                    if (bytesRead < 1)\n                        break;\n                    oh.getOutputStream().write(buf, 0, bytesRead);\n                }\n                fis.close();\n                tempFile.delete();\n            } catch (IOException e) {\n                success = false;\n                reportException(e);\n                oh.discard();\n                break;\n            }\n            oh.commit();\n        }\n        for (Enumeration en = targetThreads.elements(); en.hasMoreElements(); ) {\n            Thread t = (Thread) en.nextElement();\n            try {\n                if (t != null)\n                    t.join();\n            } catch (InterruptedException e) {\n            }\n        }\n        targetThreads.clear();\n        return success;\n    }\n\n    private Exception reportException(Exception e) {\n        if (e instanceof RuntimeException) {\n            return e;\n        }\n        if (e instanceof SAXParseException) {\n            SAXParseException spe = (SAXParseException) e;\n            Exception ee = spe.getException();\n            if (ee instanceof RuntimeException) {\n                return ee;\n            }\n            String sysId = (spe.getSystemId() == null) ? (\"(\" + currentTargetURL + \")\") : spe.getSystemId();\n            processor.err.println(sysId + \":\" + spe.getLineNumber() + \":\" + spe.getColumnNumber() + \": \" + spe.getMessage());\n        } else if (e instanceof SAXException) {\n            SAXException se = (SAXException) e;\n            Exception ee = se.getException();\n            if (ee instanceof RuntimeException) {\n                return ee;\n            } else if (ee != null) {\n                processor.err.println(\"Error building \" + currentTargetURL + \": \" + ee.toString());\n                if (DEBUG)\n                    ee.printStackTrace(System.out);\n            } else {\n                processor.err.println(\"Error building \" + currentTargetURL + \": \" + se.getMessage());\n                if (DEBUG)\n                    se.printStackTrace(System.out);\n            }\n        } else if (e instanceof IOException) {\n            processor.err.println(\"Error building \" + currentTargetURL + \": \" + e.toString());\n            if (DEBUG)\n                e.printStackTrace(System.out);\n        } else {\n            processor.err.println(\"Error building \" + currentTargetURL + \":\");\n            e.printStackTrace(processor.err);\n        }\n        return e;\n    }\n\n    // Partial SourceManager implemenation\n    public String getSourceURL() throws FileNotFoundException {\n        if (currentSourceURL == null)\n            throw new FileNotFoundException(\"no source file specified\");\n        return currentSourceURL;\n    }\n\n    // FileTarget implemenation\n    public String getCurrentTargetURL() {\n        return currentTargetURL;\n    }\n\n    public void newTarget(String filename, boolean prependFilename) {\n        if (prependFilename) {\n            this.newTarget = currentTargetName + '_' + filename;\n        } else {\n            this.newTarget = filename;\n        }\n    }\n\n    public OutputHandler newAsyncTarget(String filename, boolean prependFilename) throws IOException {\n        if (filename.charAt(0) != '/' && !prependFilename) {\n            filename = currentTargetDir + filename;\n        } else if (filename.charAt(0) != '/' && prependFilename) {\n            filename = currentTargetDir + currentTargetName + '_' + filename;\n        }\n        if (DEBUG)\n            System.out.println(\"New async target: \" + filename);\n        if (targetStorage.isReentrant()) {\n            return targetStorage.createFile(filename);\n        } else {\n            tempFiles.addElement(filename);\n            File currentFile = new File(tempDir, \"temp\" + (tempFiles.size() - 1));\n            return new TempOutputHandler(currentFile, new FileOutputStream(currentFile));\n        }\n    }\n\n    private static void sleepUntilInterrupted() {\n        try {\n            while (true) // Sleep one minute\n            Thread.sleep(1000 * 60);\n        } catch (InterruptedException e) {\n        }\n    }\n\n    private Thread mainThread;\n\n    private ContentHandler asyncSAX;\n\n    private Exception asyncException;\n\n    public ContentHandler newAsyncTargetWithOutput(String filename, boolean prependFilename, String outputName) throws java.io.IOException, SAXException {\n        mainThread = Thread.currentThread();\n        asyncSAX = null;\n        asyncException = null;\n        final OutputHandler oh = newAsyncTarget(filename, prependFilename);\n        final OutputEntry outputEntry = sitemap.lookupOutput(outputName);\n        if (outputEntry == null)\n            throw new LagoonException(\"Output entry \" + outputName + \" not found in Sitemap\");\n        outputEntry.setSourceManager(this);\n        outputEntry.setNext(new XMLStreamProducer() {\n\n            public void start(ContentHandler sax, Target target) throws SAXException, IOException {\n                asyncSAX = sax;\n                mainThread.interrupt();\n            }\n\n            public void init() {\n                throw new RuntimeException(\"Invalid context\");\n            }\n\n            public void destroy() {\n                throw new RuntimeException(\"Invalid context\");\n            }\n\n            public boolean hasBeenUpdated(long lastBuild) {\n                throw new RuntimeException(\"Invalid context\");\n            }\n        });\n        Thread targetThread = new Thread(new Runnable() {\n\n            public void run() {\n                if (DEBUG)\n                    System.out.println(\"TargetThread just started\");\n                try {\n                    try {\n                        outputEntry.getByteProducer().start(oh.getOutputStream(), FileEntry.this);\n                    } catch (Exception e) {\n                        oh.discard();\n                        throw e;\n                    }\n                    oh.commit();\n                } catch (Exception e) {\n                    asyncException = e;\n                    mainThread.interrupt();\n                }\n                if (DEBUG)\n                    System.out.println(\"TargetThread about to end\");\n            }\n        }, \"TargetThread\");\n        targetThreads.addElement(targetThread);\n        targetThread.start();\n        if (DEBUG)\n            System.out.println(\"Waiting for TargetThread...\");\n        sleepUntilInterrupted();\n        if (DEBUG)\n            System.out.println(\"...finished waiting for TargetThread\");\n        if (asyncException != null) {\n            if (asyncException instanceof IOException)\n                throw (IOException) asyncException;\n            else if (asyncException instanceof SAXException)\n                throw (SAXException) asyncException;\n            else if (asyncException instanceof RuntimeException)\n                throw (RuntimeException) asyncException;\n            else\n                throw new SAXException(asyncException);\n        }\n        return asyncSAX;\n    }\n\n    public boolean isWildcard() {\n        return Wildcard.isWildcard(sourceURL);\n    }\n\n    static class TempOutputHandler extends OutputHandler {\n\n        private File currentFile;\n\n        TempOutputHandler(File currentFile, OutputStream out) {\n            super(out);\n            this.currentFile = currentFile;\n        }\n\n        public void commit() throws java.io.IOException {\n            out.close();\n        }\n\n        public void discard() throws java.io.IOException {\n            out.close();\n            if (!currentFile.exists())\n                return;\n            if (currentFile.delete()) {\n                return;\n            } else {\n                throw new IOException(\"Unable to delete file: \" + currentFile);\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/core/FileEntryTest0.java",
		"test_prompt": "// FileEntryTest0.java\npackage nu.staldal.lagoon.core;\n\nimport java.io.*;\nimport java.util.*;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport javax.xml.parsers.*;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.stream.StreamSource;\nimport org.xml.sax.*;\nimport nu.staldal.lagoon.util.*;\nimport nu.staldal.util.Utils;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileEntry}.\n* It contains ten unit test cases for the {@link FileEntry#build(boolean)} method.\n*/\nclass FileEntryTest0 {"
	},
	{
		"original_code": "// FileEntry.java\n/*\n * Copyright (c) 2001-2004, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.lagoon.core;\n\nimport java.io.*;\nimport java.util.*;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport javax.xml.parsers.*;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.stream.StreamSource;\nimport org.xml.sax.*;\nimport nu.staldal.lagoon.util.*;\nimport nu.staldal.util.Utils;\n\n/**\n * A file in the sitemap.\n *\n * Contains information on how to (re)build a single file in a website.\n *\n * @see nu.staldal.lagoon.core.Sitemap\n */\nclass FileEntry extends EntryWithSource implements SitemapEntry, FileTarget {\n\n    private static final boolean DEBUG = true;\n\n    private Producer myProducer;\n\n    private OutputEntry outputEntry;\n\n    private final FileStorage targetStorage;\n\n    private final File tempDir;\n\n    private final String targetURL;\n\n    private String currentSourceURL;\n\n    private String currentTargetURL;\n\n    private String currentTargetDir;\n\n    private String currentTargetName;\n\n    private long targetLastMod;\n\n    private String newTarget;\n\n    private Vector tempFiles;\n\n    private Vector targetThreads;\n\n    /**\n     * Constructor.\n     *\n     * @param processor the LagoonProcessor.\n     * @param sitemap  the Sitemap.\n     * @param targetURL  the file to create, may contain wildcard anywhere,\n     *                   must be pseudo-absolute.\n     * @param sourceURL  the file to use, may contain wildcard in filename,\n     *                  must absolute or pseudo-absolute, may be <code>null</code>.\n     * @param sourceRootDir  absolute path to the source directory\n     * @param tempDir\twhere to store temporary files\n     */\n    public FileEntry(LagoonProcessor processor, Sitemap sitemap, String targetURL, String sourceURL, File sourceRootDir, File tempDir) throws LagoonException {\n        super(processor, sitemap, sourceURL, sourceRootDir);\n        this.targetStorage = processor.getTargetLocation();\n        this.tempDir = tempDir;\n        this.targetURL = targetURL;\n        this.myProducer = null;\n        this.outputEntry = null;\n        this.currentSourceURL = null;\n        this.currentTargetURL = null;\n        this.targetLastMod = -1;\n        this.newTarget = null;\n        this.targetThreads = new Vector();\n    }\n\n    public void destroy() throws IOException {\n        if (myProducer != null)\n            myProducer.doDestroy();\n    }\n\n    public void beforeBuild(boolean always) throws IOException {\n        if (myProducer != null)\n            myProducer.doBeforeBuild();\n    }\n\n    public void afterBuild(boolean always) throws IOException {\n        if (myProducer != null)\n            myProducer.doAfterBuild();\n    }\n\n    /**\n     * Set the ByteStreamProducer that produces the final output for this\n     * FileEntry.\n     * Used during initialization.\n     */\n    void setMyProducer(Producer prod) {\n        myProducer = prod;\n    }\n\n    void setMyOutput(OutputEntry outputEntry) {\n        this.outputEntry = outputEntry;\n    }\n\n    public boolean build(boolean always) throws IOException {\n        if (sourceURL == null) {\n            // no main source\n            currentSourceURL = null;\n            currentTargetURL = targetURL;\n            return buildFile(always);\n        } else if (Utils.absoluteURL(sourceURL)) {\n            // absolute URL\n            currentSourceURL = sourceURL;\n            currentTargetURL = targetURL;\n            return buildFile(always);\n        } else if (Wildcard.isWildcard(sourceURL)) {\n            // main source is a wildcard pattern\n            int slash = sourceURL.lastIndexOf('/');\n            String sourceDirURL = sourceURL.substring(0, slash + 1);\n            String sourceMask = sourceURL.substring(slash + 1);\n            File sourceDir = new File(sourceRootDir, sourceDirURL);\n            String[] files = sourceDir.list();\n            if (files == null) {\n                throw new FileNotFoundException(sourceDir.getAbsolutePath() + \" (directory not found)\");\n            }\n            boolean success = true;\n            for (int i = 0; i < files.length; i++) {\n                File currentSourceFile = new File(sourceDir, files[i]);\n                if (!currentSourceFile.isFile())\n                    continue;\n                String part = Wildcard.matchWildcard(sourceMask, files[i]);\n                if (part == null)\n                    continue;\n                currentSourceURL = sourceDirURL + files[i];\n                currentTargetURL = Wildcard.instantiateWildcard(targetURL, part);\n                if (!buildFile(always))\n                    success = false;\n            }\n            return success;\n        } else {\n            // main source is a regular file\n            currentSourceURL = sourceURL;\n            currentTargetURL = targetURL;\n            return buildFile(always);\n        }\n    }\n\n    private boolean buildFile(boolean always) throws IOException {\n        targetLastMod = targetStorage.fileLastModified(currentTargetURL);\n        if (always || (targetLastMod <= 0)) {\n            return buildAlways();\n        }\n        boolean success = true;\n        boolean updated = false;\n        try {\n            updated = myProducer.hasBeenUpdated(targetLastMod);\n        } catch (LagoonException e) {\n            reportException(e);\n            success = false;\n        } catch (IOException e) {\n            reportException(e);\n            success = false;\n        }\n        if (updated) {\n            if (!buildAlways())\n                success = false;\n        }\n        return success;\n    }\n\n    /**\n     * The actual building of this file.\n     * Used after any dependency checking indicates the file needs rebuilding.\n     */\n    private boolean buildAlways() throws IOException {\n        processor.log.println(\"Building: \" + currentTargetURL);\n        int slash = currentTargetURL.lastIndexOf('/');\n        currentTargetDir = currentTargetURL.substring(0, slash + 1);\n        currentTargetName = currentTargetURL.substring(slash + 1);\n        String thisTargetURL;\n        OutputHandler out = null;\n        String exceptionType = null;\n        boolean bailOut = false;\n        boolean success = true;\n        ByteStreamProducer theProducer;\n        if (outputEntry == null) {\n            theProducer = (ByteStreamProducer) myProducer;\n        } else {\n            outputEntry.setNext((XMLStreamProducer) myProducer);\n            outputEntry.setSourceManager(this);\n            theProducer = outputEntry.getByteProducer();\n        }\n        tempFiles = new Vector();\n        newTarget = currentTargetName;\n        do {\n            thisTargetURL = currentTargetDir + newTarget;\n            newTarget = null;\n            out = targetStorage.createFile(thisTargetURL);\n            try {\n                theProducer.start(out.getOutputStream(), this);\n                // no exception thrown\n                exceptionType = null;\n            } catch (Exception e) {\n                success = false;\n                if (DEBUG)\n                    e.printStackTrace();\n                String thisExceptionType = e.getClass().getName();\n                // the same type of exception thrown twice in a row\n                if (thisExceptionType.equals(exceptionType)) {\n                    bailOut = true;\n                }\n                exceptionType = thisExceptionType;\n                e = reportException(e);\n                if (out != null)\n                    out.discard();\n                if (e instanceof RuntimeException) {\n                    throw (RuntimeException) e;\n                }\n                if (bailOut) {\n                    processor.err.println(\"Error building \" + currentTargetURL + \": Too many exceptions, bailing out\");\n                    break;\n                } else {\n                    continue;\n                }\n            }\n            out.commit();\n        } while (newTarget != null);\n        byte[] buf = new byte[8192];\n        for (int i = 0; i < tempFiles.size(); i++) {\n            String path = (String) tempFiles.elementAt(i);\n            File tempFile = new File(tempDir, \"temp\" + i);\n            FileInputStream fis = new FileInputStream(tempFile);\n            OutputHandler oh = targetStorage.createFile(path);\n            try {\n                while (true) {\n                    int bytesRead = fis.read(buf);\n                    if (bytesRead < 1)\n                        break;\n                    oh.getOutputStream().write(buf, 0, bytesRead);\n                }\n                fis.close();\n                tempFile.delete();\n            } catch (IOException e) {\n                success = false;\n                reportException(e);\n                oh.discard();\n                break;\n            }\n            oh.commit();\n        }\n        for (Enumeration en = targetThreads.elements(); en.hasMoreElements(); ) {\n            Thread t = (Thread) en.nextElement();\n            try {\n                if (t != null)\n                    t.join();\n            } catch (InterruptedException e) {\n            }\n        }\n        targetThreads.clear();\n        return success;\n    }\n\n    private Exception reportException(Exception e) {\n        if (e instanceof RuntimeException) {\n            return e;\n        }\n        if (e instanceof SAXParseException) {\n            SAXParseException spe = (SAXParseException) e;\n            Exception ee = spe.getException();\n            if (ee instanceof RuntimeException) {\n                return ee;\n            }\n            String sysId = (spe.getSystemId() == null) ? (\"(\" + currentTargetURL + \")\") : spe.getSystemId();\n            processor.err.println(sysId + \":\" + spe.getLineNumber() + \":\" + spe.getColumnNumber() + \": \" + spe.getMessage());\n        } else if (e instanceof SAXException) {\n            SAXException se = (SAXException) e;\n            Exception ee = se.getException();\n            if (ee instanceof RuntimeException) {\n                return ee;\n            } else if (ee != null) {\n                processor.err.println(\"Error building \" + currentTargetURL + \": \" + ee.toString());\n                if (DEBUG)\n                    ee.printStackTrace(System.out);\n            } else {\n                processor.err.println(\"Error building \" + currentTargetURL + \": \" + se.getMessage());\n                if (DEBUG)\n                    se.printStackTrace(System.out);\n            }\n        } else if (e instanceof IOException) {\n            processor.err.println(\"Error building \" + currentTargetURL + \": \" + e.toString());\n            if (DEBUG)\n                e.printStackTrace(System.out);\n        } else {\n            processor.err.println(\"Error building \" + currentTargetURL + \":\");\n            e.printStackTrace(processor.err);\n        }\n        return e;\n    }\n\n    // Partial SourceManager implemenation\n    public String getSourceURL() throws FileNotFoundException {\n        if (currentSourceURL == null)\n            throw new FileNotFoundException(\"no source file specified\");\n        return currentSourceURL;\n    }\n\n    // FileTarget implemenation\n    public String getCurrentTargetURL() {\n        return currentTargetURL;\n    }\n\n    public void newTarget(String filename, boolean prependFilename) {\n        if (prependFilename) {\n            this.newTarget = currentTargetName + '_' + filename;\n        } else {\n            this.newTarget = filename;\n        }\n    }\n\n    public OutputHandler newAsyncTarget(String filename, boolean prependFilename) throws IOException {\n        if (filename.charAt(0) != '/' && !prependFilename) {\n            filename = currentTargetDir + filename;\n        } else if (filename.charAt(0) != '/' && prependFilename) {\n            filename = currentTargetDir + currentTargetName + '_' + filename;\n        }\n        if (DEBUG)\n            System.out.println(\"New async target: \" + filename);\n        if (targetStorage.isReentrant()) {\n            return targetStorage.createFile(filename);\n        } else {\n            tempFiles.addElement(filename);\n            File currentFile = new File(tempDir, \"temp\" + (tempFiles.size() - 1));\n            return new TempOutputHandler(currentFile, new FileOutputStream(currentFile));\n        }\n    }\n\n    private static void sleepUntilInterrupted() {\n        try {\n            while (true) // Sleep one minute\n            Thread.sleep(1000 * 60);\n        } catch (InterruptedException e) {\n        }\n    }\n\n    private Thread mainThread;\n\n    private ContentHandler asyncSAX;\n\n    private Exception asyncException;\n\n    public ContentHandler newAsyncTargetWithOutput(String filename, boolean prependFilename, String outputName) throws java.io.IOException, SAXException {\n        mainThread = Thread.currentThread();\n        asyncSAX = null;\n        asyncException = null;\n        final OutputHandler oh = newAsyncTarget(filename, prependFilename);\n        final OutputEntry outputEntry = sitemap.lookupOutput(outputName);\n        if (outputEntry == null)\n            throw new LagoonException(\"Output entry \" + outputName + \" not found in Sitemap\");\n        outputEntry.setSourceManager(this);\n        outputEntry.setNext(new XMLStreamProducer() {\n\n            public void start(ContentHandler sax, Target target) throws SAXException, IOException {\n                asyncSAX = sax;\n                mainThread.interrupt();\n            }\n\n            public void init() {\n                throw new RuntimeException(\"Invalid context\");\n            }\n\n            public void destroy() {\n                throw new RuntimeException(\"Invalid context\");\n            }\n\n            public boolean hasBeenUpdated(long lastBuild) {\n                throw new RuntimeException(\"Invalid context\");\n            }\n        });\n        Thread targetThread = new Thread(new Runnable() {\n\n            public void run() {\n                if (DEBUG)\n                    System.out.println(\"TargetThread just started\");\n                try {\n                    try {\n                        outputEntry.getByteProducer().start(oh.getOutputStream(), FileEntry.this);\n                    } catch (Exception e) {\n                        oh.discard();\n                        throw e;\n                    }\n                    oh.commit();\n                } catch (Exception e) {\n                    asyncException = e;\n                    mainThread.interrupt();\n                }\n                if (DEBUG)\n                    System.out.println(\"TargetThread about to end\");\n            }\n        }, \"TargetThread\");\n        targetThreads.addElement(targetThread);\n        targetThread.start();\n        if (DEBUG)\n            System.out.println(\"Waiting for TargetThread...\");\n        sleepUntilInterrupted();\n        if (DEBUG)\n            System.out.println(\"...finished waiting for TargetThread\");\n        if (asyncException != null) {\n            if (asyncException instanceof IOException)\n                throw (IOException) asyncException;\n            else if (asyncException instanceof SAXException)\n                throw (SAXException) asyncException;\n            else if (asyncException instanceof RuntimeException)\n                throw (RuntimeException) asyncException;\n            else\n                throw new SAXException(asyncException);\n        }\n        return asyncSAX;\n    }\n\n    public boolean isWildcard() {\n        return Wildcard.isWildcard(sourceURL);\n    }\n\n    static class TempOutputHandler extends OutputHandler {\n\n        private File currentFile;\n\n        TempOutputHandler(File currentFile, OutputStream out) {\n            super(out);\n            this.currentFile = currentFile;\n        }\n\n        public void commit() throws java.io.IOException {\n            out.close();\n        }\n\n        public void discard() throws java.io.IOException {\n            out.close();\n            if (!currentFile.exists())\n                return;\n            if (currentFile.delete()) {\n                return;\n            } else {\n                throw new IOException(\"Unable to delete file: \" + currentFile);\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/core/FileEntryTest1.java",
		"test_prompt": "// FileEntryTest1.java\npackage nu.staldal.lagoon.core;\n\nimport java.io.*;\nimport java.util.*;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport javax.xml.parsers.*;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.stream.StreamSource;\nimport org.xml.sax.*;\nimport nu.staldal.lagoon.util.*;\nimport nu.staldal.util.Utils;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileEntry}.\n* It contains ten unit test cases for the {@link FileEntry#newAsyncTarget(String, boolean)} method.\n*/\nclass FileEntryTest1 {"
	},
	{
		"original_code": "// FileEntry.java\n/*\n * Copyright (c) 2001-2004, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.lagoon.core;\n\nimport java.io.*;\nimport java.util.*;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport javax.xml.parsers.*;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.stream.StreamSource;\nimport org.xml.sax.*;\nimport nu.staldal.lagoon.util.*;\nimport nu.staldal.util.Utils;\n\n/**\n * A file in the sitemap.\n *\n * Contains information on how to (re)build a single file in a website.\n *\n * @see nu.staldal.lagoon.core.Sitemap\n */\nclass FileEntry extends EntryWithSource implements SitemapEntry, FileTarget {\n\n    private static final boolean DEBUG = true;\n\n    private Producer myProducer;\n\n    private OutputEntry outputEntry;\n\n    private final FileStorage targetStorage;\n\n    private final File tempDir;\n\n    private final String targetURL;\n\n    private String currentSourceURL;\n\n    private String currentTargetURL;\n\n    private String currentTargetDir;\n\n    private String currentTargetName;\n\n    private long targetLastMod;\n\n    private String newTarget;\n\n    private Vector tempFiles;\n\n    private Vector targetThreads;\n\n    /**\n     * Constructor.\n     *\n     * @param processor the LagoonProcessor.\n     * @param sitemap  the Sitemap.\n     * @param targetURL  the file to create, may contain wildcard anywhere,\n     *                   must be pseudo-absolute.\n     * @param sourceURL  the file to use, may contain wildcard in filename,\n     *                  must absolute or pseudo-absolute, may be <code>null</code>.\n     * @param sourceRootDir  absolute path to the source directory\n     * @param tempDir\twhere to store temporary files\n     */\n    public FileEntry(LagoonProcessor processor, Sitemap sitemap, String targetURL, String sourceURL, File sourceRootDir, File tempDir) throws LagoonException {\n        super(processor, sitemap, sourceURL, sourceRootDir);\n        this.targetStorage = processor.getTargetLocation();\n        this.tempDir = tempDir;\n        this.targetURL = targetURL;\n        this.myProducer = null;\n        this.outputEntry = null;\n        this.currentSourceURL = null;\n        this.currentTargetURL = null;\n        this.targetLastMod = -1;\n        this.newTarget = null;\n        this.targetThreads = new Vector();\n    }\n\n    public void destroy() throws IOException {\n        if (myProducer != null)\n            myProducer.doDestroy();\n    }\n\n    public void beforeBuild(boolean always) throws IOException {\n        if (myProducer != null)\n            myProducer.doBeforeBuild();\n    }\n\n    public void afterBuild(boolean always) throws IOException {\n        if (myProducer != null)\n            myProducer.doAfterBuild();\n    }\n\n    /**\n     * Set the ByteStreamProducer that produces the final output for this\n     * FileEntry.\n     * Used during initialization.\n     */\n    void setMyProducer(Producer prod) {\n        myProducer = prod;\n    }\n\n    void setMyOutput(OutputEntry outputEntry) {\n        this.outputEntry = outputEntry;\n    }\n\n    public boolean build(boolean always) throws IOException {\n        if (sourceURL == null) {\n            // no main source\n            currentSourceURL = null;\n            currentTargetURL = targetURL;\n            return buildFile(always);\n        } else if (Utils.absoluteURL(sourceURL)) {\n            // absolute URL\n            currentSourceURL = sourceURL;\n            currentTargetURL = targetURL;\n            return buildFile(always);\n        } else if (Wildcard.isWildcard(sourceURL)) {\n            // main source is a wildcard pattern\n            int slash = sourceURL.lastIndexOf('/');\n            String sourceDirURL = sourceURL.substring(0, slash + 1);\n            String sourceMask = sourceURL.substring(slash + 1);\n            File sourceDir = new File(sourceRootDir, sourceDirURL);\n            String[] files = sourceDir.list();\n            if (files == null) {\n                throw new FileNotFoundException(sourceDir.getAbsolutePath() + \" (directory not found)\");\n            }\n            boolean success = true;\n            for (int i = 0; i < files.length; i++) {\n                File currentSourceFile = new File(sourceDir, files[i]);\n                if (!currentSourceFile.isFile())\n                    continue;\n                String part = Wildcard.matchWildcard(sourceMask, files[i]);\n                if (part == null)\n                    continue;\n                currentSourceURL = sourceDirURL + files[i];\n                currentTargetURL = Wildcard.instantiateWildcard(targetURL, part);\n                if (!buildFile(always))\n                    success = false;\n            }\n            return success;\n        } else {\n            // main source is a regular file\n            currentSourceURL = sourceURL;\n            currentTargetURL = targetURL;\n            return buildFile(always);\n        }\n    }\n\n    private boolean buildFile(boolean always) throws IOException {\n        targetLastMod = targetStorage.fileLastModified(currentTargetURL);\n        if (always || (targetLastMod <= 0)) {\n            return buildAlways();\n        }\n        boolean success = true;\n        boolean updated = false;\n        try {\n            updated = myProducer.hasBeenUpdated(targetLastMod);\n        } catch (LagoonException e) {\n            reportException(e);\n            success = false;\n        } catch (IOException e) {\n            reportException(e);\n            success = false;\n        }\n        if (updated) {\n            if (!buildAlways())\n                success = false;\n        }\n        return success;\n    }\n\n    /**\n     * The actual building of this file.\n     * Used after any dependency checking indicates the file needs rebuilding.\n     */\n    private boolean buildAlways() throws IOException {\n        processor.log.println(\"Building: \" + currentTargetURL);\n        int slash = currentTargetURL.lastIndexOf('/');\n        currentTargetDir = currentTargetURL.substring(0, slash + 1);\n        currentTargetName = currentTargetURL.substring(slash + 1);\n        String thisTargetURL;\n        OutputHandler out = null;\n        String exceptionType = null;\n        boolean bailOut = false;\n        boolean success = true;\n        ByteStreamProducer theProducer;\n        if (outputEntry == null) {\n            theProducer = (ByteStreamProducer) myProducer;\n        } else {\n            outputEntry.setNext((XMLStreamProducer) myProducer);\n            outputEntry.setSourceManager(this);\n            theProducer = outputEntry.getByteProducer();\n        }\n        tempFiles = new Vector();\n        newTarget = currentTargetName;\n        do {\n            thisTargetURL = currentTargetDir + newTarget;\n            newTarget = null;\n            out = targetStorage.createFile(thisTargetURL);\n            try {\n                theProducer.start(out.getOutputStream(), this);\n                // no exception thrown\n                exceptionType = null;\n            } catch (Exception e) {\n                success = false;\n                if (DEBUG)\n                    e.printStackTrace();\n                String thisExceptionType = e.getClass().getName();\n                // the same type of exception thrown twice in a row\n                if (thisExceptionType.equals(exceptionType)) {\n                    bailOut = true;\n                }\n                exceptionType = thisExceptionType;\n                e = reportException(e);\n                if (out != null)\n                    out.discard();\n                if (e instanceof RuntimeException) {\n                    throw (RuntimeException) e;\n                }\n                if (bailOut) {\n                    processor.err.println(\"Error building \" + currentTargetURL + \": Too many exceptions, bailing out\");\n                    break;\n                } else {\n                    continue;\n                }\n            }\n            out.commit();\n        } while (newTarget != null);\n        byte[] buf = new byte[8192];\n        for (int i = 0; i < tempFiles.size(); i++) {\n            String path = (String) tempFiles.elementAt(i);\n            File tempFile = new File(tempDir, \"temp\" + i);\n            FileInputStream fis = new FileInputStream(tempFile);\n            OutputHandler oh = targetStorage.createFile(path);\n            try {\n                while (true) {\n                    int bytesRead = fis.read(buf);\n                    if (bytesRead < 1)\n                        break;\n                    oh.getOutputStream().write(buf, 0, bytesRead);\n                }\n                fis.close();\n                tempFile.delete();\n            } catch (IOException e) {\n                success = false;\n                reportException(e);\n                oh.discard();\n                break;\n            }\n            oh.commit();\n        }\n        for (Enumeration en = targetThreads.elements(); en.hasMoreElements(); ) {\n            Thread t = (Thread) en.nextElement();\n            try {\n                if (t != null)\n                    t.join();\n            } catch (InterruptedException e) {\n            }\n        }\n        targetThreads.clear();\n        return success;\n    }\n\n    private Exception reportException(Exception e) {\n        if (e instanceof RuntimeException) {\n            return e;\n        }\n        if (e instanceof SAXParseException) {\n            SAXParseException spe = (SAXParseException) e;\n            Exception ee = spe.getException();\n            if (ee instanceof RuntimeException) {\n                return ee;\n            }\n            String sysId = (spe.getSystemId() == null) ? (\"(\" + currentTargetURL + \")\") : spe.getSystemId();\n            processor.err.println(sysId + \":\" + spe.getLineNumber() + \":\" + spe.getColumnNumber() + \": \" + spe.getMessage());\n        } else if (e instanceof SAXException) {\n            SAXException se = (SAXException) e;\n            Exception ee = se.getException();\n            if (ee instanceof RuntimeException) {\n                return ee;\n            } else if (ee != null) {\n                processor.err.println(\"Error building \" + currentTargetURL + \": \" + ee.toString());\n                if (DEBUG)\n                    ee.printStackTrace(System.out);\n            } else {\n                processor.err.println(\"Error building \" + currentTargetURL + \": \" + se.getMessage());\n                if (DEBUG)\n                    se.printStackTrace(System.out);\n            }\n        } else if (e instanceof IOException) {\n            processor.err.println(\"Error building \" + currentTargetURL + \": \" + e.toString());\n            if (DEBUG)\n                e.printStackTrace(System.out);\n        } else {\n            processor.err.println(\"Error building \" + currentTargetURL + \":\");\n            e.printStackTrace(processor.err);\n        }\n        return e;\n    }\n\n    // Partial SourceManager implemenation\n    public String getSourceURL() throws FileNotFoundException {\n        if (currentSourceURL == null)\n            throw new FileNotFoundException(\"no source file specified\");\n        return currentSourceURL;\n    }\n\n    // FileTarget implemenation\n    public String getCurrentTargetURL() {\n        return currentTargetURL;\n    }\n\n    public void newTarget(String filename, boolean prependFilename) {\n        if (prependFilename) {\n            this.newTarget = currentTargetName + '_' + filename;\n        } else {\n            this.newTarget = filename;\n        }\n    }\n\n    public OutputHandler newAsyncTarget(String filename, boolean prependFilename) throws IOException {\n        if (filename.charAt(0) != '/' && !prependFilename) {\n            filename = currentTargetDir + filename;\n        } else if (filename.charAt(0) != '/' && prependFilename) {\n            filename = currentTargetDir + currentTargetName + '_' + filename;\n        }\n        if (DEBUG)\n            System.out.println(\"New async target: \" + filename);\n        if (targetStorage.isReentrant()) {\n            return targetStorage.createFile(filename);\n        } else {\n            tempFiles.addElement(filename);\n            File currentFile = new File(tempDir, \"temp\" + (tempFiles.size() - 1));\n            return new TempOutputHandler(currentFile, new FileOutputStream(currentFile));\n        }\n    }\n\n    private static void sleepUntilInterrupted() {\n        try {\n            while (true) // Sleep one minute\n            Thread.sleep(1000 * 60);\n        } catch (InterruptedException e) {\n        }\n    }\n\n    private Thread mainThread;\n\n    private ContentHandler asyncSAX;\n\n    private Exception asyncException;\n\n    public ContentHandler newAsyncTargetWithOutput(String filename, boolean prependFilename, String outputName) throws java.io.IOException, SAXException {\n        mainThread = Thread.currentThread();\n        asyncSAX = null;\n        asyncException = null;\n        final OutputHandler oh = newAsyncTarget(filename, prependFilename);\n        final OutputEntry outputEntry = sitemap.lookupOutput(outputName);\n        if (outputEntry == null)\n            throw new LagoonException(\"Output entry \" + outputName + \" not found in Sitemap\");\n        outputEntry.setSourceManager(this);\n        outputEntry.setNext(new XMLStreamProducer() {\n\n            public void start(ContentHandler sax, Target target) throws SAXException, IOException {\n                asyncSAX = sax;\n                mainThread.interrupt();\n            }\n\n            public void init() {\n                throw new RuntimeException(\"Invalid context\");\n            }\n\n            public void destroy() {\n                throw new RuntimeException(\"Invalid context\");\n            }\n\n            public boolean hasBeenUpdated(long lastBuild) {\n                throw new RuntimeException(\"Invalid context\");\n            }\n        });\n        Thread targetThread = new Thread(new Runnable() {\n\n            public void run() {\n                if (DEBUG)\n                    System.out.println(\"TargetThread just started\");\n                try {\n                    try {\n                        outputEntry.getByteProducer().start(oh.getOutputStream(), FileEntry.this);\n                    } catch (Exception e) {\n                        oh.discard();\n                        throw e;\n                    }\n                    oh.commit();\n                } catch (Exception e) {\n                    asyncException = e;\n                    mainThread.interrupt();\n                }\n                if (DEBUG)\n                    System.out.println(\"TargetThread about to end\");\n            }\n        }, \"TargetThread\");\n        targetThreads.addElement(targetThread);\n        targetThread.start();\n        if (DEBUG)\n            System.out.println(\"Waiting for TargetThread...\");\n        sleepUntilInterrupted();\n        if (DEBUG)\n            System.out.println(\"...finished waiting for TargetThread\");\n        if (asyncException != null) {\n            if (asyncException instanceof IOException)\n                throw (IOException) asyncException;\n            else if (asyncException instanceof SAXException)\n                throw (SAXException) asyncException;\n            else if (asyncException instanceof RuntimeException)\n                throw (RuntimeException) asyncException;\n            else\n                throw new SAXException(asyncException);\n        }\n        return asyncSAX;\n    }\n\n    public boolean isWildcard() {\n        return Wildcard.isWildcard(sourceURL);\n    }\n\n    static class TempOutputHandler extends OutputHandler {\n\n        private File currentFile;\n\n        TempOutputHandler(File currentFile, OutputStream out) {\n            super(out);\n            this.currentFile = currentFile;\n        }\n\n        public void commit() throws java.io.IOException {\n            out.close();\n        }\n\n        public void discard() throws java.io.IOException {\n            out.close();\n            if (!currentFile.exists())\n                return;\n            if (currentFile.delete()) {\n                return;\n            } else {\n                throw new IOException(\"Unable to delete file: \" + currentFile);\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/core/FileEntryTest2.java",
		"test_prompt": "// FileEntryTest2.java\npackage nu.staldal.lagoon.core;\n\nimport java.io.*;\nimport java.util.*;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport javax.xml.parsers.*;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.stream.StreamSource;\nimport org.xml.sax.*;\nimport nu.staldal.lagoon.util.*;\nimport nu.staldal.util.Utils;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileEntry}.\n* It contains ten unit test cases for the {@link FileEntry#newAsyncTargetWithOutput(String, boolean, String)} method.\n*/\nclass FileEntryTest2 {"
	},
	{
		"original_code": "// FileEntry.java\n/*\n * Copyright (c) 2001-2004, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.lagoon.core;\n\nimport java.io.*;\nimport java.util.*;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport javax.xml.parsers.*;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.stream.StreamSource;\nimport org.xml.sax.*;\nimport nu.staldal.lagoon.util.*;\nimport nu.staldal.util.Utils;\n\n/**\n * A file in the sitemap.\n *\n * Contains information on how to (re)build a single file in a website.\n *\n * @see nu.staldal.lagoon.core.Sitemap\n */\nclass FileEntry extends EntryWithSource implements SitemapEntry, FileTarget {\n\n    private static final boolean DEBUG = true;\n\n    private Producer myProducer;\n\n    private OutputEntry outputEntry;\n\n    private final FileStorage targetStorage;\n\n    private final File tempDir;\n\n    private final String targetURL;\n\n    private String currentSourceURL;\n\n    private String currentTargetURL;\n\n    private String currentTargetDir;\n\n    private String currentTargetName;\n\n    private long targetLastMod;\n\n    private String newTarget;\n\n    private Vector tempFiles;\n\n    private Vector targetThreads;\n\n    /**\n     * Constructor.\n     *\n     * @param processor the LagoonProcessor.\n     * @param sitemap  the Sitemap.\n     * @param targetURL  the file to create, may contain wildcard anywhere,\n     *                   must be pseudo-absolute.\n     * @param sourceURL  the file to use, may contain wildcard in filename,\n     *                  must absolute or pseudo-absolute, may be <code>null</code>.\n     * @param sourceRootDir  absolute path to the source directory\n     * @param tempDir\twhere to store temporary files\n     */\n    public FileEntry(LagoonProcessor processor, Sitemap sitemap, String targetURL, String sourceURL, File sourceRootDir, File tempDir) throws LagoonException {\n        super(processor, sitemap, sourceURL, sourceRootDir);\n        this.targetStorage = processor.getTargetLocation();\n        this.tempDir = tempDir;\n        this.targetURL = targetURL;\n        this.myProducer = null;\n        this.outputEntry = null;\n        this.currentSourceURL = null;\n        this.currentTargetURL = null;\n        this.targetLastMod = -1;\n        this.newTarget = null;\n        this.targetThreads = new Vector();\n    }\n\n    public void destroy() throws IOException {\n        if (myProducer != null)\n            myProducer.doDestroy();\n    }\n\n    public void beforeBuild(boolean always) throws IOException {\n        if (myProducer != null)\n            myProducer.doBeforeBuild();\n    }\n\n    public void afterBuild(boolean always) throws IOException {\n        if (myProducer != null)\n            myProducer.doAfterBuild();\n    }\n\n    /**\n     * Set the ByteStreamProducer that produces the final output for this\n     * FileEntry.\n     * Used during initialization.\n     */\n    void setMyProducer(Producer prod) {\n        myProducer = prod;\n    }\n\n    void setMyOutput(OutputEntry outputEntry) {\n        this.outputEntry = outputEntry;\n    }\n\n    public boolean build(boolean always) throws IOException {\n        if (sourceURL == null) {\n            // no main source\n            currentSourceURL = null;\n            currentTargetURL = targetURL;\n            return buildFile(always);\n        } else if (Utils.absoluteURL(sourceURL)) {\n            // absolute URL\n            currentSourceURL = sourceURL;\n            currentTargetURL = targetURL;\n            return buildFile(always);\n        } else if (Wildcard.isWildcard(sourceURL)) {\n            // main source is a wildcard pattern\n            int slash = sourceURL.lastIndexOf('/');\n            String sourceDirURL = sourceURL.substring(0, slash + 1);\n            String sourceMask = sourceURL.substring(slash + 1);\n            File sourceDir = new File(sourceRootDir, sourceDirURL);\n            String[] files = sourceDir.list();\n            if (files == null) {\n                throw new FileNotFoundException(sourceDir.getAbsolutePath() + \" (directory not found)\");\n            }\n            boolean success = true;\n            for (int i = 0; i < files.length; i++) {\n                File currentSourceFile = new File(sourceDir, files[i]);\n                if (!currentSourceFile.isFile())\n                    continue;\n                String part = Wildcard.matchWildcard(sourceMask, files[i]);\n                if (part == null)\n                    continue;\n                currentSourceURL = sourceDirURL + files[i];\n                currentTargetURL = Wildcard.instantiateWildcard(targetURL, part);\n                if (!buildFile(always))\n                    success = false;\n            }\n            return success;\n        } else {\n            // main source is a regular file\n            currentSourceURL = sourceURL;\n            currentTargetURL = targetURL;\n            return buildFile(always);\n        }\n    }\n\n    private boolean buildFile(boolean always) throws IOException {\n        targetLastMod = targetStorage.fileLastModified(currentTargetURL);\n        if (always || (targetLastMod <= 0)) {\n            return buildAlways();\n        }\n        boolean success = true;\n        boolean updated = false;\n        try {\n            updated = myProducer.hasBeenUpdated(targetLastMod);\n        } catch (LagoonException e) {\n            reportException(e);\n            success = false;\n        } catch (IOException e) {\n            reportException(e);\n            success = false;\n        }\n        if (updated) {\n            if (!buildAlways())\n                success = false;\n        }\n        return success;\n    }\n\n    /**\n     * The actual building of this file.\n     * Used after any dependency checking indicates the file needs rebuilding.\n     */\n    private boolean buildAlways() throws IOException {\n        processor.log.println(\"Building: \" + currentTargetURL);\n        int slash = currentTargetURL.lastIndexOf('/');\n        currentTargetDir = currentTargetURL.substring(0, slash + 1);\n        currentTargetName = currentTargetURL.substring(slash + 1);\n        String thisTargetURL;\n        OutputHandler out = null;\n        String exceptionType = null;\n        boolean bailOut = false;\n        boolean success = true;\n        ByteStreamProducer theProducer;\n        if (outputEntry == null) {\n            theProducer = (ByteStreamProducer) myProducer;\n        } else {\n            outputEntry.setNext((XMLStreamProducer) myProducer);\n            outputEntry.setSourceManager(this);\n            theProducer = outputEntry.getByteProducer();\n        }\n        tempFiles = new Vector();\n        newTarget = currentTargetName;\n        do {\n            thisTargetURL = currentTargetDir + newTarget;\n            newTarget = null;\n            out = targetStorage.createFile(thisTargetURL);\n            try {\n                theProducer.start(out.getOutputStream(), this);\n                // no exception thrown\n                exceptionType = null;\n            } catch (Exception e) {\n                success = false;\n                if (DEBUG)\n                    e.printStackTrace();\n                String thisExceptionType = e.getClass().getName();\n                // the same type of exception thrown twice in a row\n                if (thisExceptionType.equals(exceptionType)) {\n                    bailOut = true;\n                }\n                exceptionType = thisExceptionType;\n                e = reportException(e);\n                if (out != null)\n                    out.discard();\n                if (e instanceof RuntimeException) {\n                    throw (RuntimeException) e;\n                }\n                if (bailOut) {\n                    processor.err.println(\"Error building \" + currentTargetURL + \": Too many exceptions, bailing out\");\n                    break;\n                } else {\n                    continue;\n                }\n            }\n            out.commit();\n        } while (newTarget != null);\n        byte[] buf = new byte[8192];\n        for (int i = 0; i < tempFiles.size(); i++) {\n            String path = (String) tempFiles.elementAt(i);\n            File tempFile = new File(tempDir, \"temp\" + i);\n            FileInputStream fis = new FileInputStream(tempFile);\n            OutputHandler oh = targetStorage.createFile(path);\n            try {\n                while (true) {\n                    int bytesRead = fis.read(buf);\n                    if (bytesRead < 1)\n                        break;\n                    oh.getOutputStream().write(buf, 0, bytesRead);\n                }\n                fis.close();\n                tempFile.delete();\n            } catch (IOException e) {\n                success = false;\n                reportException(e);\n                oh.discard();\n                break;\n            }\n            oh.commit();\n        }\n        for (Enumeration en = targetThreads.elements(); en.hasMoreElements(); ) {\n            Thread t = (Thread) en.nextElement();\n            try {\n                if (t != null)\n                    t.join();\n            } catch (InterruptedException e) {\n            }\n        }\n        targetThreads.clear();\n        return success;\n    }\n\n    private Exception reportException(Exception e) {\n        if (e instanceof RuntimeException) {\n            return e;\n        }\n        if (e instanceof SAXParseException) {\n            SAXParseException spe = (SAXParseException) e;\n            Exception ee = spe.getException();\n            if (ee instanceof RuntimeException) {\n                return ee;\n            }\n            String sysId = (spe.getSystemId() == null) ? (\"(\" + currentTargetURL + \")\") : spe.getSystemId();\n            processor.err.println(sysId + \":\" + spe.getLineNumber() + \":\" + spe.getColumnNumber() + \": \" + spe.getMessage());\n        } else if (e instanceof SAXException) {\n            SAXException se = (SAXException) e;\n            Exception ee = se.getException();\n            if (ee instanceof RuntimeException) {\n                return ee;\n            } else if (ee != null) {\n                processor.err.println(\"Error building \" + currentTargetURL + \": \" + ee.toString());\n                if (DEBUG)\n                    ee.printStackTrace(System.out);\n            } else {\n                processor.err.println(\"Error building \" + currentTargetURL + \": \" + se.getMessage());\n                if (DEBUG)\n                    se.printStackTrace(System.out);\n            }\n        } else if (e instanceof IOException) {\n            processor.err.println(\"Error building \" + currentTargetURL + \": \" + e.toString());\n            if (DEBUG)\n                e.printStackTrace(System.out);\n        } else {\n            processor.err.println(\"Error building \" + currentTargetURL + \":\");\n            e.printStackTrace(processor.err);\n        }\n        return e;\n    }\n\n    // Partial SourceManager implemenation\n    public String getSourceURL() throws FileNotFoundException {\n        if (currentSourceURL == null)\n            throw new FileNotFoundException(\"no source file specified\");\n        return currentSourceURL;\n    }\n\n    // FileTarget implemenation\n    public String getCurrentTargetURL() {\n        return currentTargetURL;\n    }\n\n    public void newTarget(String filename, boolean prependFilename) {\n        if (prependFilename) {\n            this.newTarget = currentTargetName + '_' + filename;\n        } else {\n            this.newTarget = filename;\n        }\n    }\n\n    public OutputHandler newAsyncTarget(String filename, boolean prependFilename) throws IOException {\n        if (filename.charAt(0) != '/' && !prependFilename) {\n            filename = currentTargetDir + filename;\n        } else if (filename.charAt(0) != '/' && prependFilename) {\n            filename = currentTargetDir + currentTargetName + '_' + filename;\n        }\n        if (DEBUG)\n            System.out.println(\"New async target: \" + filename);\n        if (targetStorage.isReentrant()) {\n            return targetStorage.createFile(filename);\n        } else {\n            tempFiles.addElement(filename);\n            File currentFile = new File(tempDir, \"temp\" + (tempFiles.size() - 1));\n            return new TempOutputHandler(currentFile, new FileOutputStream(currentFile));\n        }\n    }\n\n    private static void sleepUntilInterrupted() {\n        try {\n            while (true) // Sleep one minute\n            Thread.sleep(1000 * 60);\n        } catch (InterruptedException e) {\n        }\n    }\n\n    private Thread mainThread;\n\n    private ContentHandler asyncSAX;\n\n    private Exception asyncException;\n\n    public ContentHandler newAsyncTargetWithOutput(String filename, boolean prependFilename, String outputName) throws java.io.IOException, SAXException {\n        mainThread = Thread.currentThread();\n        asyncSAX = null;\n        asyncException = null;\n        final OutputHandler oh = newAsyncTarget(filename, prependFilename);\n        final OutputEntry outputEntry = sitemap.lookupOutput(outputName);\n        if (outputEntry == null)\n            throw new LagoonException(\"Output entry \" + outputName + \" not found in Sitemap\");\n        outputEntry.setSourceManager(this);\n        outputEntry.setNext(new XMLStreamProducer() {\n\n            public void start(ContentHandler sax, Target target) throws SAXException, IOException {\n                asyncSAX = sax;\n                mainThread.interrupt();\n            }\n\n            public void init() {\n                throw new RuntimeException(\"Invalid context\");\n            }\n\n            public void destroy() {\n                throw new RuntimeException(\"Invalid context\");\n            }\n\n            public boolean hasBeenUpdated(long lastBuild) {\n                throw new RuntimeException(\"Invalid context\");\n            }\n        });\n        Thread targetThread = new Thread(new Runnable() {\n\n            public void run() {\n                if (DEBUG)\n                    System.out.println(\"TargetThread just started\");\n                try {\n                    try {\n                        outputEntry.getByteProducer().start(oh.getOutputStream(), FileEntry.this);\n                    } catch (Exception e) {\n                        oh.discard();\n                        throw e;\n                    }\n                    oh.commit();\n                } catch (Exception e) {\n                    asyncException = e;\n                    mainThread.interrupt();\n                }\n                if (DEBUG)\n                    System.out.println(\"TargetThread about to end\");\n            }\n        }, \"TargetThread\");\n        targetThreads.addElement(targetThread);\n        targetThread.start();\n        if (DEBUG)\n            System.out.println(\"Waiting for TargetThread...\");\n        sleepUntilInterrupted();\n        if (DEBUG)\n            System.out.println(\"...finished waiting for TargetThread\");\n        if (asyncException != null) {\n            if (asyncException instanceof IOException)\n                throw (IOException) asyncException;\n            else if (asyncException instanceof SAXException)\n                throw (SAXException) asyncException;\n            else if (asyncException instanceof RuntimeException)\n                throw (RuntimeException) asyncException;\n            else\n                throw new SAXException(asyncException);\n        }\n        return asyncSAX;\n    }\n\n    public boolean isWildcard() {\n        return Wildcard.isWildcard(sourceURL);\n    }\n\n    static class TempOutputHandler extends OutputHandler {\n\n        private File currentFile;\n\n        TempOutputHandler(File currentFile, OutputStream out) {\n            super(out);\n            this.currentFile = currentFile;\n        }\n\n        public void commit() throws java.io.IOException {\n            out.close();\n        }\n\n        public void discard() throws java.io.IOException {\n            out.close();\n            if (!currentFile.exists())\n                return;\n            if (currentFile.delete()) {\n                return;\n            } else {\n                throw new IOException(\"Unable to delete file: \" + currentFile);\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/core/FileEntryTest3.java",
		"test_prompt": "// FileEntryTest3.java\npackage nu.staldal.lagoon.core;\n\nimport java.io.*;\nimport java.util.*;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport javax.xml.parsers.*;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.stream.StreamSource;\nimport org.xml.sax.*;\nimport nu.staldal.lagoon.util.*;\nimport nu.staldal.util.Utils;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileEntry}.\n* It contains ten unit test cases for the {@link FileEntry#isWildcard()} method.\n*/\nclass FileEntryTest3 {"
	},
	{
		"original_code": "// LagoonProcessor.java\n/*\n * Copyright (c) 2001-2004, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.lagoon.core;\n\nimport java.io.*;\nimport java.util.*;\nimport nu.staldal.xtree.*;\nimport nu.staldal.util.Utils;\n\n/**\n * The main worker class of the Lagoon core.\n *\n * Initialized with the sitemap,\n * a source dir and a target storage URL.\n * Then building the website may be done several times,\n * until destroy() is invoked.\n *\n * This class is not thread-safe. The methods must not\n * be invoked concurrently from different threads.\n */\npublic class LagoonProcessor implements LagoonContext {\n\n    private static final boolean DEBUG = false;\n\n    private final String targetURL;\n\n    private final FileStorage targetLocation;\n\n    private File repositoryDir;\n\n    private File tempDir;\n\n    private File classDir;\n\n    private File sourceRootDir;\n\n    private java.net.URL[] classLoaderURLs;\n\n    private ClassLoader repositoryClassLoader;\n\n    private final Hashtable classDict;\n\n    private final Hashtable paramDict;\n\n    private final Hashtable filestorageDict;\n\n    private Sitemap sitemap;\n\n    PrintWriter log;\n\n    PrintWriter err;\n\n    /**\n     * Constructs and initializes a LagoonProcessor.\n     *\n     * @param targetURL  where to put the generated files,\n     *                   must be an absolute URL or a local file path\n     * @param sitemapTree  the Sitemap as an XTree\n     * @param sourceDir  where the source files are\n     * @param password  password to access the target storage, or\n     *                  <code>null</code> if not nessesary.\n     * @param log  where to write progress messages.\n     * @param err  where to write error messages.\n     */\n    public LagoonProcessor(String targetURL, Element sitemapTree, File sourceDir, String password, PrintWriter log, PrintWriter err) throws IOException, LagoonException, AuthenticationException, AuthenticationMissingException {\n        this.targetURL = targetURL;\n        this.log = log;\n        this.err = err;\n        classDict = new Hashtable();\n        paramDict = new Hashtable();\n        filestorageDict = new Hashtable();\n        targetLocation = createFileStorage(targetURL);\n        if (targetLocation == null)\n            throw new LagoonException(\"Cannot find FileStorage for URL \" + targetURL);\n        if (targetLocation.needPassword() && (password == null)) {\n            throw new AuthenticationMissingException();\n        }\n        String absPath = sourceDir.getAbsolutePath();\n        this.sourceRootDir = new File(absPath);\n        if (!this.sourceRootDir.isDirectory())\n            throw new LagoonException(\"sourceDir must be an existing directory: \" + sourceDir);\n        sitemap = new Sitemap(this, sitemapTree, sourceRootDir);\n        File workDir = new File(System.getProperty(\"user.home\"), \".lagoon\");\n        if (!workDir.exists()) {\n            if (!workDir.mkdir())\n                throw new IOException(\"Unable to create directory: \" + workDir);\n        } else {\n            if (!workDir.isDirectory()) {\n                throw new IOException(\"Unable to create directory (a file with that name exists): \" + workDir);\n            }\n        }\n        if (sitemap.getSiteName() != null) {\n            repositoryDir = new File(workDir, sitemap.getSiteName());\n            if (!repositoryDir.exists()) {\n                if (!repositoryDir.mkdir())\n                    throw new IOException(\"Unable to create directory: \" + repositoryDir);\n            } else {\n                if (!repositoryDir.isDirectory()) {\n                    throw new IOException(\"Unable to create directory (a file with that name exists): \" + repositoryDir);\n                }\n            }\n        } else {\n            repositoryDir = null;\n        }\n        if (repositoryDir != null) {\n            tempDir = new File(repositoryDir, \"temp\");\n            classDir = new File(repositoryDir, \"classes\");\n        } else {\n            tempDir = new File(workDir, \"temp\");\n        }\n        if (!tempDir.exists()) {\n            if (!tempDir.mkdir())\n                throw new IOException(\"Unable to create directory: \" + tempDir);\n        } else {\n            if (!tempDir.isDirectory()) {\n                throw new IOException(\"Unable to create directory (a file with that name exists): \" + tempDir);\n            }\n        }\n        if (classDir == null) {\n            classDir = new File(tempDir, \"classes\");\n        }\n        if (!classDir.exists()) {\n            if (!classDir.mkdir())\n                throw new IOException(\"Unable to create directory: \" + classDir);\n        } else {\n            if (!classDir.isDirectory()) {\n                throw new IOException(\"Unable to create directory (a file with that name exists): \" + classDir);\n            }\n        }\n        classLoaderURLs = new java.net.URL[] { classDir.toURL() };\n        reloadClasses();\n        sitemap.init();\n        targetLocation.open(targetURL, this, password);\n    }\n\n    /**\n     * Get the Sitemap.\n     *\n     * @return the Sitemap.\n     */\n    Sitemap getSitemap() {\n        return sitemap;\n    }\n\n    /**\n     * Get the target location.\n     *\n     * @return the target location.\n     */\n    FileStorage getTargetLocation() {\n        return targetLocation;\n    }\n\n    /**\n     * Perform the building of the website.\n     * May be invoked multiple times.\n     * Synchronous, returns when the building is complete.\n     *\n     * @param force force a rebuild of all files, otherwise dependency\n     *        checking is used to check which files that needs rebuilding.\n     *\n     * @return true if successful, false if any non-fatal error occured\n     * @throws IOException  if any fatal error occur\n     */\n    public boolean build(boolean force) throws IOException {\n        boolean success = true;\n        for (Enumeration e = sitemap.getEntries(); e.hasMoreElements(); ) {\n            SitemapEntry ent = (SitemapEntry) e.nextElement();\n            ent.beforeBuild(force);\n        }\n        for (Enumeration e = sitemap.getEntries(); e.hasMoreElements(); ) {\n            SitemapEntry ent = (SitemapEntry) e.nextElement();\n            if (!ent.build(force))\n                success = false;\n        }\n        for (Enumeration e = sitemap.getEntries(); e.hasMoreElements(); ) {\n            SitemapEntry ent = (SitemapEntry) e.nextElement();\n            ent.afterBuild(force);\n        }\n        return success;\n    }\n\n    /**\n     * Dispose this object and release any resources it holds.\n     * This causes the FileStorage to be closed.\n     */\n    public void destroy() throws IOException {\n        sitemap.destroy();\n        targetLocation.close();\n        repositoryClassLoader = null;\n        if (repositoryDir == null) {\n            File[] classFiles = classDir.listFiles();\n            for (int i = 0; i < classFiles.length; i++) {\n                classFiles[i].delete();\n            }\n        }\n    }\n\n    public File getTempDir() {\n        return tempDir;\n    }\n\n    public InputStream readFileFromRepository(String key) {\n        return readFileFromRepository(null, key);\n    }\n\n    InputStream readFileFromRepository(String dir, String key) {\n        if (repositoryDir == null)\n            return null;\n        File theDir = (dir == null) ? repositoryDir : new File(repositoryDir, dir);\n        File theFile = new File(theDir, key);\n        if (DEBUG)\n            System.out.println(\"readFileFromRepository: \" + theFile);\n        try {\n            return new FileInputStream(theFile);\n        } catch (FileNotFoundException e) {\n            return null;\n        }\n    }\n\n    public OutputStream storeFileInRepository(String key) throws IOException {\n        return storeFileInRepository(null, key);\n    }\n\n    OutputStream storeFileInRepository(String dir, String key) throws IOException {\n        if (repositoryDir == null)\n            return null;\n        File theDir = (dir == null) ? repositoryDir : new File(repositoryDir, dir);\n        theDir.mkdir();\n        File theFile = new File(theDir, key);\n        if (DEBUG)\n            System.out.println(\"storeFileInRepository: \" + theFile);\n        return new FileOutputStream(theFile);\n    }\n\n    public Class loadClassFromRepository(String className) throws ClassNotFoundException {\n        if (DEBUG)\n            System.out.println(\"loadClassFromRepository: \" + className);\n        try {\n            return Class.forName(className, true, repositoryClassLoader);\n        } catch (ClassFormatError e) {\n            File classFile = new File(classDir, className + \".class\");\n            classFile.delete();\n            err.println(e.toString());\n            throw new ClassNotFoundException(className + \" is malformed\");\n        } catch (VerifyError e) {\n            File classFile = new File(classDir, className + \".class\");\n            classFile.delete();\n            err.println(e.toString());\n            throw new ClassNotFoundException(className + \" does not verify\");\n        }\n    }\n\n    public OutputStream storeClassInRepository(String className) throws IOException {\n        if (classDir == null)\n            return null;\n        File theFile = new File(classDir, className + \".class\");\n        if (DEBUG)\n            System.out.println(\"storeClassInRepository: \" + theFile);\n        return new FileOutputStream(theFile);\n    }\n\n    public void deleteClassInRepository(String className) throws IOException {\n        if (classDir == null)\n            return;\n        File theFile = new File(classDir, className + \".class\");\n        if (DEBUG)\n            System.out.println(\"deleteClassInRepository: \" + theFile);\n        if (theFile.isFile() && !theFile.delete())\n            throw new IOException(\"Unable to delete file: \" + theFile);\n    }\n\n    public void reloadClasses() {\n        repositoryClassLoader = new java.net.URLClassLoader(classLoaderURLs);\n    }\n\n    public Object getObjectFromRepository(String key) throws IOException {\n        return getObjectFromRepository(null, key);\n    }\n\n    Object getObjectFromRepository(String dir, String key) throws IOException {\n        InputStream is = readFileFromRepository(dir, key);\n        if (is == null)\n            return null;\n        ObjectInputStream ois = new ObjectInputStream(is);\n        try {\n            return ois.readObject();\n        } catch (ClassNotFoundException e) {\n            if (DEBUG)\n                System.out.println(e);\n            return null;\n        } catch (ObjectStreamException e) {\n            if (DEBUG)\n                System.out.println(e);\n            return null;\n        } catch (ClassCastException e) {\n            if (DEBUG)\n                System.out.println(e);\n            return null;\n        } catch (EOFException e) {\n            if (DEBUG)\n                System.out.println(e);\n            return null;\n        } finally {\n            is.close();\n        }\n    }\n\n    public boolean putObjectIntoRepository(String key, Object obj) throws IOException {\n        return putObjectIntoRepository(null, key, obj);\n    }\n\n    boolean putObjectIntoRepository(String dir, String key, Object obj) throws IOException {\n        OutputStream os = storeFileInRepository(dir, key);\n        if (os == null)\n            return false;\n        ObjectOutputStream oos = new ObjectOutputStream(os);\n        try {\n            oos.writeObject(obj);\n            return true;\n        } finally {\n            oos.close();\n        }\n    }\n\n    /**\n     * Create a new producer.\n     *\n     * @param cat  the producer category (format, transform, source,\n     *             read, parse or process).\n     * @param type the producer type, use \"\" for default.\n     *\n     * @return  a new Producer\n     *          or <code>null</code> if it cannot be found.\n     */\n    Producer createProducer(String cat, String type) throws LagoonException {\n        Class cls = (Class) classDict.get(cat + \":\" + type);\n        if (cls == null)\n            try {\n                String fileName = \"/nu/staldal/lagoon/producer/\" + cat + ((type == \"\") ? \"\" : (\"-\" + type));\n                InputStream is = getClass().getResourceAsStream(fileName);\n                if (is == null)\n                    return null;\n                BufferedReader br = new BufferedReader(new InputStreamReader(is));\n                String className = br.readLine();\n                if (className == null)\n                    throw new LagoonException(\"Illegal Producer config file: \" + fileName);\n                String baseClassName = \"nu.staldal.lagoon.core.\" + Character.toUpperCase(cat.charAt(0)) + cat.substring(1);\n                try {\n                    cls = Class.forName(className);\n                    if (!Class.forName(baseClassName).isAssignableFrom(cls))\n                        throw new LagoonException(cat + \" class must derive from \" + baseClassName);\n                    classDict.put(cat + \":\" + type, cls);\n                } catch (ClassNotFoundException e) {\n                    throw new LagoonException(\"Producer class cannot be found:\" + e.getMessage());\n                }\n                Hashtable params = new Hashtable();\n                for (; ; ) {\n                    String s = br.readLine();\n                    if (s == null)\n                        break;\n                    int colon = s.indexOf(':');\n                    if (colon < 1)\n                        throw new LagoonException(\"Illegal producer config file: \" + fileName);\n                    String paramName = s.substring(0, colon).trim();\n                    String paramValue = s.substring(colon + 1).trim();\n                    params.put(paramName, paramValue);\n                }\n                br.close();\n                paramDict.put(cat + \":\" + type, params);\n            } catch (IOException e) {\n                throw new LagoonException(\"Unable to read producer config file: \" + e.toString());\n            }\n        try {\n            Producer prod = (Producer) cls.newInstance();\n            Hashtable params = (Hashtable) paramDict.get(cat + \":\" + type);\n            for (Enumeration e = params.keys(); e.hasMoreElements(); ) {\n                String name = (String) e.nextElement();\n                String value = (String) params.get(name);\n                prod.addParam(name, value);\n            }\n            return prod;\n        } catch (IllegalAccessException e) {\n            throw new LagoonException(\"Unable to instantiate producer class (illegal access): \" + e.getMessage());\n        } catch (InstantiationException e) {\n            throw new LagoonException(\"Unable to instantiate producer class (instantiation failed): \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Create a new file storage\n     *\n     * @param url  the URL\n     *\n     * @return  a new FileStorage\n     *          or <code>null</code> if it cannot be found.\n     */\n    FileStorage createFileStorage(String url) throws LagoonException {\n        Class cls = null;\n        String prefix;\n        int colon = url.indexOf(':');\n        if (colon < 1) {\n            prefix = \"\";\n            cls = (Class) filestorageDict.get(\"\");\n        } else {\n            prefix = url.substring(0, colon);\n            cls = (Class) filestorageDict.get(prefix);\n            if (cls == null) {\n                cls = (Class) filestorageDict.get(\"\");\n            }\n        }\n        if (cls == null)\n            try {\n                String fileName = \"/nu/staldal/lagoon/filestorage/FileStorage\" + ((prefix == \"\") ? \"\" : (\"-\" + prefix));\n                InputStream is = getClass().getResourceAsStream(fileName);\n                if (is == null) {\n                    fileName = \"/nu/staldal/lagoon/filestorage/FileStorage\";\n                    is = getClass().getResourceAsStream(fileName);\n                    prefix = \"\";\n                }\n                if (is == null)\n                    return null;\n                BufferedReader br = new BufferedReader(new InputStreamReader(is));\n                String className = br.readLine();\n                br.close();\n                if (className == null)\n                    throw new LagoonException(\"Illegal FileStorage config file: \" + fileName);\n                String baseClassName = \"nu.staldal.lagoon.core.FileStorage\";\n                try {\n                    cls = Class.forName(className);\n                    if (!Class.forName(baseClassName).isAssignableFrom(cls))\n                        throw new LagoonException(\"file storage class must derive from \" + baseClassName);\n                    filestorageDict.put(prefix, cls);\n                } catch (ClassNotFoundException e) {\n                    throw new LagoonException(\"FileStorage class cannot be found:\" + e.getMessage());\n                }\n            } catch (IOException e) {\n                throw new LagoonException(\"Unable to read producer config file: \" + e.toString());\n            }\n        try {\n            return (FileStorage) cls.newInstance();\n        } catch (IllegalAccessException e) {\n            throw new LagoonException(\"Unable to instantiate file storage class (illegal access): \" + e.getMessage());\n        } catch (InstantiationException e) {\n            throw new LagoonException(\"Unable to instantiate file storage class (instantiation failed): \" + e.getMessage());\n        }\n    }\n\n    public boolean canCheckFileHasBeenUpdated(String url) {\n        return !Utils.absoluteURL(url) || url.startsWith(\"part:\") || url.startsWith(\"file:\") || url.startsWith(\"res:\");\n    }\n\n    public File getSourceRootDir() {\n        return sourceRootDir;\n    }\n\n    public String getFileURLRelativeTo(String url, String base) {\n        if (Utils.absoluteURL(url) || Utils.pseudoAbsoluteURL(url)) {\n            return url;\n        } else {\n            if (!Utils.pseudoAbsoluteURL(base))\n                throw new IllegalArgumentException(\"base must be a pseudo-absolute URL\");\n            int slash = base.lastIndexOf('/');\n            String baseDir = base.substring(0, slash + 1);\n            return baseDir + url;\n        }\n    }\n\n    public String getProperty(String key) {\n        return sitemap.getProperty(key);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/core/LagoonProcessorTest0.java",
		"test_prompt": "// LagoonProcessorTest0.java\npackage nu.staldal.lagoon.core;\n\nimport java.io.*;\nimport java.util.*;\nimport nu.staldal.xtree.*;\nimport nu.staldal.util.Utils;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link LagoonProcessor}.\n* It contains ten unit test cases for the {@link LagoonProcessor#build(boolean)} method.\n*/\nclass LagoonProcessorTest0 {"
	},
	{
		"original_code": "// LagoonProcessor.java\n/*\n * Copyright (c) 2001-2004, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.lagoon.core;\n\nimport java.io.*;\nimport java.util.*;\nimport nu.staldal.xtree.*;\nimport nu.staldal.util.Utils;\n\n/**\n * The main worker class of the Lagoon core.\n *\n * Initialized with the sitemap,\n * a source dir and a target storage URL.\n * Then building the website may be done several times,\n * until destroy() is invoked.\n *\n * This class is not thread-safe. The methods must not\n * be invoked concurrently from different threads.\n */\npublic class LagoonProcessor implements LagoonContext {\n\n    private static final boolean DEBUG = false;\n\n    private final String targetURL;\n\n    private final FileStorage targetLocation;\n\n    private File repositoryDir;\n\n    private File tempDir;\n\n    private File classDir;\n\n    private File sourceRootDir;\n\n    private java.net.URL[] classLoaderURLs;\n\n    private ClassLoader repositoryClassLoader;\n\n    private final Hashtable classDict;\n\n    private final Hashtable paramDict;\n\n    private final Hashtable filestorageDict;\n\n    private Sitemap sitemap;\n\n    PrintWriter log;\n\n    PrintWriter err;\n\n    /**\n     * Constructs and initializes a LagoonProcessor.\n     *\n     * @param targetURL  where to put the generated files,\n     *                   must be an absolute URL or a local file path\n     * @param sitemapTree  the Sitemap as an XTree\n     * @param sourceDir  where the source files are\n     * @param password  password to access the target storage, or\n     *                  <code>null</code> if not nessesary.\n     * @param log  where to write progress messages.\n     * @param err  where to write error messages.\n     */\n    public LagoonProcessor(String targetURL, Element sitemapTree, File sourceDir, String password, PrintWriter log, PrintWriter err) throws IOException, LagoonException, AuthenticationException, AuthenticationMissingException {\n        this.targetURL = targetURL;\n        this.log = log;\n        this.err = err;\n        classDict = new Hashtable();\n        paramDict = new Hashtable();\n        filestorageDict = new Hashtable();\n        targetLocation = createFileStorage(targetURL);\n        if (targetLocation == null)\n            throw new LagoonException(\"Cannot find FileStorage for URL \" + targetURL);\n        if (targetLocation.needPassword() && (password == null)) {\n            throw new AuthenticationMissingException();\n        }\n        String absPath = sourceDir.getAbsolutePath();\n        this.sourceRootDir = new File(absPath);\n        if (!this.sourceRootDir.isDirectory())\n            throw new LagoonException(\"sourceDir must be an existing directory: \" + sourceDir);\n        sitemap = new Sitemap(this, sitemapTree, sourceRootDir);\n        File workDir = new File(System.getProperty(\"user.home\"), \".lagoon\");\n        if (!workDir.exists()) {\n            if (!workDir.mkdir())\n                throw new IOException(\"Unable to create directory: \" + workDir);\n        } else {\n            if (!workDir.isDirectory()) {\n                throw new IOException(\"Unable to create directory (a file with that name exists): \" + workDir);\n            }\n        }\n        if (sitemap.getSiteName() != null) {\n            repositoryDir = new File(workDir, sitemap.getSiteName());\n            if (!repositoryDir.exists()) {\n                if (!repositoryDir.mkdir())\n                    throw new IOException(\"Unable to create directory: \" + repositoryDir);\n            } else {\n                if (!repositoryDir.isDirectory()) {\n                    throw new IOException(\"Unable to create directory (a file with that name exists): \" + repositoryDir);\n                }\n            }\n        } else {\n            repositoryDir = null;\n        }\n        if (repositoryDir != null) {\n            tempDir = new File(repositoryDir, \"temp\");\n            classDir = new File(repositoryDir, \"classes\");\n        } else {\n            tempDir = new File(workDir, \"temp\");\n        }\n        if (!tempDir.exists()) {\n            if (!tempDir.mkdir())\n                throw new IOException(\"Unable to create directory: \" + tempDir);\n        } else {\n            if (!tempDir.isDirectory()) {\n                throw new IOException(\"Unable to create directory (a file with that name exists): \" + tempDir);\n            }\n        }\n        if (classDir == null) {\n            classDir = new File(tempDir, \"classes\");\n        }\n        if (!classDir.exists()) {\n            if (!classDir.mkdir())\n                throw new IOException(\"Unable to create directory: \" + classDir);\n        } else {\n            if (!classDir.isDirectory()) {\n                throw new IOException(\"Unable to create directory (a file with that name exists): \" + classDir);\n            }\n        }\n        classLoaderURLs = new java.net.URL[] { classDir.toURL() };\n        reloadClasses();\n        sitemap.init();\n        targetLocation.open(targetURL, this, password);\n    }\n\n    /**\n     * Get the Sitemap.\n     *\n     * @return the Sitemap.\n     */\n    Sitemap getSitemap() {\n        return sitemap;\n    }\n\n    /**\n     * Get the target location.\n     *\n     * @return the target location.\n     */\n    FileStorage getTargetLocation() {\n        return targetLocation;\n    }\n\n    /**\n     * Perform the building of the website.\n     * May be invoked multiple times.\n     * Synchronous, returns when the building is complete.\n     *\n     * @param force force a rebuild of all files, otherwise dependency\n     *        checking is used to check which files that needs rebuilding.\n     *\n     * @return true if successful, false if any non-fatal error occured\n     * @throws IOException  if any fatal error occur\n     */\n    public boolean build(boolean force) throws IOException {\n        boolean success = true;\n        for (Enumeration e = sitemap.getEntries(); e.hasMoreElements(); ) {\n            SitemapEntry ent = (SitemapEntry) e.nextElement();\n            ent.beforeBuild(force);\n        }\n        for (Enumeration e = sitemap.getEntries(); e.hasMoreElements(); ) {\n            SitemapEntry ent = (SitemapEntry) e.nextElement();\n            if (!ent.build(force))\n                success = false;\n        }\n        for (Enumeration e = sitemap.getEntries(); e.hasMoreElements(); ) {\n            SitemapEntry ent = (SitemapEntry) e.nextElement();\n            ent.afterBuild(force);\n        }\n        return success;\n    }\n\n    /**\n     * Dispose this object and release any resources it holds.\n     * This causes the FileStorage to be closed.\n     */\n    public void destroy() throws IOException {\n        sitemap.destroy();\n        targetLocation.close();\n        repositoryClassLoader = null;\n        if (repositoryDir == null) {\n            File[] classFiles = classDir.listFiles();\n            for (int i = 0; i < classFiles.length; i++) {\n                classFiles[i].delete();\n            }\n        }\n    }\n\n    public File getTempDir() {\n        return tempDir;\n    }\n\n    public InputStream readFileFromRepository(String key) {\n        return readFileFromRepository(null, key);\n    }\n\n    InputStream readFileFromRepository(String dir, String key) {\n        if (repositoryDir == null)\n            return null;\n        File theDir = (dir == null) ? repositoryDir : new File(repositoryDir, dir);\n        File theFile = new File(theDir, key);\n        if (DEBUG)\n            System.out.println(\"readFileFromRepository: \" + theFile);\n        try {\n            return new FileInputStream(theFile);\n        } catch (FileNotFoundException e) {\n            return null;\n        }\n    }\n\n    public OutputStream storeFileInRepository(String key) throws IOException {\n        return storeFileInRepository(null, key);\n    }\n\n    OutputStream storeFileInRepository(String dir, String key) throws IOException {\n        if (repositoryDir == null)\n            return null;\n        File theDir = (dir == null) ? repositoryDir : new File(repositoryDir, dir);\n        theDir.mkdir();\n        File theFile = new File(theDir, key);\n        if (DEBUG)\n            System.out.println(\"storeFileInRepository: \" + theFile);\n        return new FileOutputStream(theFile);\n    }\n\n    public Class loadClassFromRepository(String className) throws ClassNotFoundException {\n        if (DEBUG)\n            System.out.println(\"loadClassFromRepository: \" + className);\n        try {\n            return Class.forName(className, true, repositoryClassLoader);\n        } catch (ClassFormatError e) {\n            File classFile = new File(classDir, className + \".class\");\n            classFile.delete();\n            err.println(e.toString());\n            throw new ClassNotFoundException(className + \" is malformed\");\n        } catch (VerifyError e) {\n            File classFile = new File(classDir, className + \".class\");\n            classFile.delete();\n            err.println(e.toString());\n            throw new ClassNotFoundException(className + \" does not verify\");\n        }\n    }\n\n    public OutputStream storeClassInRepository(String className) throws IOException {\n        if (classDir == null)\n            return null;\n        File theFile = new File(classDir, className + \".class\");\n        if (DEBUG)\n            System.out.println(\"storeClassInRepository: \" + theFile);\n        return new FileOutputStream(theFile);\n    }\n\n    public void deleteClassInRepository(String className) throws IOException {\n        if (classDir == null)\n            return;\n        File theFile = new File(classDir, className + \".class\");\n        if (DEBUG)\n            System.out.println(\"deleteClassInRepository: \" + theFile);\n        if (theFile.isFile() && !theFile.delete())\n            throw new IOException(\"Unable to delete file: \" + theFile);\n    }\n\n    public void reloadClasses() {\n        repositoryClassLoader = new java.net.URLClassLoader(classLoaderURLs);\n    }\n\n    public Object getObjectFromRepository(String key) throws IOException {\n        return getObjectFromRepository(null, key);\n    }\n\n    Object getObjectFromRepository(String dir, String key) throws IOException {\n        InputStream is = readFileFromRepository(dir, key);\n        if (is == null)\n            return null;\n        ObjectInputStream ois = new ObjectInputStream(is);\n        try {\n            return ois.readObject();\n        } catch (ClassNotFoundException e) {\n            if (DEBUG)\n                System.out.println(e);\n            return null;\n        } catch (ObjectStreamException e) {\n            if (DEBUG)\n                System.out.println(e);\n            return null;\n        } catch (ClassCastException e) {\n            if (DEBUG)\n                System.out.println(e);\n            return null;\n        } catch (EOFException e) {\n            if (DEBUG)\n                System.out.println(e);\n            return null;\n        } finally {\n            is.close();\n        }\n    }\n\n    public boolean putObjectIntoRepository(String key, Object obj) throws IOException {\n        return putObjectIntoRepository(null, key, obj);\n    }\n\n    boolean putObjectIntoRepository(String dir, String key, Object obj) throws IOException {\n        OutputStream os = storeFileInRepository(dir, key);\n        if (os == null)\n            return false;\n        ObjectOutputStream oos = new ObjectOutputStream(os);\n        try {\n            oos.writeObject(obj);\n            return true;\n        } finally {\n            oos.close();\n        }\n    }\n\n    /**\n     * Create a new producer.\n     *\n     * @param cat  the producer category (format, transform, source,\n     *             read, parse or process).\n     * @param type the producer type, use \"\" for default.\n     *\n     * @return  a new Producer\n     *          or <code>null</code> if it cannot be found.\n     */\n    Producer createProducer(String cat, String type) throws LagoonException {\n        Class cls = (Class) classDict.get(cat + \":\" + type);\n        if (cls == null)\n            try {\n                String fileName = \"/nu/staldal/lagoon/producer/\" + cat + ((type == \"\") ? \"\" : (\"-\" + type));\n                InputStream is = getClass().getResourceAsStream(fileName);\n                if (is == null)\n                    return null;\n                BufferedReader br = new BufferedReader(new InputStreamReader(is));\n                String className = br.readLine();\n                if (className == null)\n                    throw new LagoonException(\"Illegal Producer config file: \" + fileName);\n                String baseClassName = \"nu.staldal.lagoon.core.\" + Character.toUpperCase(cat.charAt(0)) + cat.substring(1);\n                try {\n                    cls = Class.forName(className);\n                    if (!Class.forName(baseClassName).isAssignableFrom(cls))\n                        throw new LagoonException(cat + \" class must derive from \" + baseClassName);\n                    classDict.put(cat + \":\" + type, cls);\n                } catch (ClassNotFoundException e) {\n                    throw new LagoonException(\"Producer class cannot be found:\" + e.getMessage());\n                }\n                Hashtable params = new Hashtable();\n                for (; ; ) {\n                    String s = br.readLine();\n                    if (s == null)\n                        break;\n                    int colon = s.indexOf(':');\n                    if (colon < 1)\n                        throw new LagoonException(\"Illegal producer config file: \" + fileName);\n                    String paramName = s.substring(0, colon).trim();\n                    String paramValue = s.substring(colon + 1).trim();\n                    params.put(paramName, paramValue);\n                }\n                br.close();\n                paramDict.put(cat + \":\" + type, params);\n            } catch (IOException e) {\n                throw new LagoonException(\"Unable to read producer config file: \" + e.toString());\n            }\n        try {\n            Producer prod = (Producer) cls.newInstance();\n            Hashtable params = (Hashtable) paramDict.get(cat + \":\" + type);\n            for (Enumeration e = params.keys(); e.hasMoreElements(); ) {\n                String name = (String) e.nextElement();\n                String value = (String) params.get(name);\n                prod.addParam(name, value);\n            }\n            return prod;\n        } catch (IllegalAccessException e) {\n            throw new LagoonException(\"Unable to instantiate producer class (illegal access): \" + e.getMessage());\n        } catch (InstantiationException e) {\n            throw new LagoonException(\"Unable to instantiate producer class (instantiation failed): \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Create a new file storage\n     *\n     * @param url  the URL\n     *\n     * @return  a new FileStorage\n     *          or <code>null</code> if it cannot be found.\n     */\n    FileStorage createFileStorage(String url) throws LagoonException {\n        Class cls = null;\n        String prefix;\n        int colon = url.indexOf(':');\n        if (colon < 1) {\n            prefix = \"\";\n            cls = (Class) filestorageDict.get(\"\");\n        } else {\n            prefix = url.substring(0, colon);\n            cls = (Class) filestorageDict.get(prefix);\n            if (cls == null) {\n                cls = (Class) filestorageDict.get(\"\");\n            }\n        }\n        if (cls == null)\n            try {\n                String fileName = \"/nu/staldal/lagoon/filestorage/FileStorage\" + ((prefix == \"\") ? \"\" : (\"-\" + prefix));\n                InputStream is = getClass().getResourceAsStream(fileName);\n                if (is == null) {\n                    fileName = \"/nu/staldal/lagoon/filestorage/FileStorage\";\n                    is = getClass().getResourceAsStream(fileName);\n                    prefix = \"\";\n                }\n                if (is == null)\n                    return null;\n                BufferedReader br = new BufferedReader(new InputStreamReader(is));\n                String className = br.readLine();\n                br.close();\n                if (className == null)\n                    throw new LagoonException(\"Illegal FileStorage config file: \" + fileName);\n                String baseClassName = \"nu.staldal.lagoon.core.FileStorage\";\n                try {\n                    cls = Class.forName(className);\n                    if (!Class.forName(baseClassName).isAssignableFrom(cls))\n                        throw new LagoonException(\"file storage class must derive from \" + baseClassName);\n                    filestorageDict.put(prefix, cls);\n                } catch (ClassNotFoundException e) {\n                    throw new LagoonException(\"FileStorage class cannot be found:\" + e.getMessage());\n                }\n            } catch (IOException e) {\n                throw new LagoonException(\"Unable to read producer config file: \" + e.toString());\n            }\n        try {\n            return (FileStorage) cls.newInstance();\n        } catch (IllegalAccessException e) {\n            throw new LagoonException(\"Unable to instantiate file storage class (illegal access): \" + e.getMessage());\n        } catch (InstantiationException e) {\n            throw new LagoonException(\"Unable to instantiate file storage class (instantiation failed): \" + e.getMessage());\n        }\n    }\n\n    public boolean canCheckFileHasBeenUpdated(String url) {\n        return !Utils.absoluteURL(url) || url.startsWith(\"part:\") || url.startsWith(\"file:\") || url.startsWith(\"res:\");\n    }\n\n    public File getSourceRootDir() {\n        return sourceRootDir;\n    }\n\n    public String getFileURLRelativeTo(String url, String base) {\n        if (Utils.absoluteURL(url) || Utils.pseudoAbsoluteURL(url)) {\n            return url;\n        } else {\n            if (!Utils.pseudoAbsoluteURL(base))\n                throw new IllegalArgumentException(\"base must be a pseudo-absolute URL\");\n            int slash = base.lastIndexOf('/');\n            String baseDir = base.substring(0, slash + 1);\n            return baseDir + url;\n        }\n    }\n\n    public String getProperty(String key) {\n        return sitemap.getProperty(key);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/core/LagoonProcessorTest1.java",
		"test_prompt": "// LagoonProcessorTest1.java\npackage nu.staldal.lagoon.core;\n\nimport java.io.*;\nimport java.util.*;\nimport nu.staldal.xtree.*;\nimport nu.staldal.util.Utils;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link LagoonProcessor}.\n* It contains ten unit test cases for the {@link LagoonProcessor#readFileFromRepository(String)} method.\n*/\nclass LagoonProcessorTest1 {"
	},
	{
		"original_code": "// LagoonProcessor.java\n/*\n * Copyright (c) 2001-2004, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.lagoon.core;\n\nimport java.io.*;\nimport java.util.*;\nimport nu.staldal.xtree.*;\nimport nu.staldal.util.Utils;\n\n/**\n * The main worker class of the Lagoon core.\n *\n * Initialized with the sitemap,\n * a source dir and a target storage URL.\n * Then building the website may be done several times,\n * until destroy() is invoked.\n *\n * This class is not thread-safe. The methods must not\n * be invoked concurrently from different threads.\n */\npublic class LagoonProcessor implements LagoonContext {\n\n    private static final boolean DEBUG = false;\n\n    private final String targetURL;\n\n    private final FileStorage targetLocation;\n\n    private File repositoryDir;\n\n    private File tempDir;\n\n    private File classDir;\n\n    private File sourceRootDir;\n\n    private java.net.URL[] classLoaderURLs;\n\n    private ClassLoader repositoryClassLoader;\n\n    private final Hashtable classDict;\n\n    private final Hashtable paramDict;\n\n    private final Hashtable filestorageDict;\n\n    private Sitemap sitemap;\n\n    PrintWriter log;\n\n    PrintWriter err;\n\n    /**\n     * Constructs and initializes a LagoonProcessor.\n     *\n     * @param targetURL  where to put the generated files,\n     *                   must be an absolute URL or a local file path\n     * @param sitemapTree  the Sitemap as an XTree\n     * @param sourceDir  where the source files are\n     * @param password  password to access the target storage, or\n     *                  <code>null</code> if not nessesary.\n     * @param log  where to write progress messages.\n     * @param err  where to write error messages.\n     */\n    public LagoonProcessor(String targetURL, Element sitemapTree, File sourceDir, String password, PrintWriter log, PrintWriter err) throws IOException, LagoonException, AuthenticationException, AuthenticationMissingException {\n        this.targetURL = targetURL;\n        this.log = log;\n        this.err = err;\n        classDict = new Hashtable();\n        paramDict = new Hashtable();\n        filestorageDict = new Hashtable();\n        targetLocation = createFileStorage(targetURL);\n        if (targetLocation == null)\n            throw new LagoonException(\"Cannot find FileStorage for URL \" + targetURL);\n        if (targetLocation.needPassword() && (password == null)) {\n            throw new AuthenticationMissingException();\n        }\n        String absPath = sourceDir.getAbsolutePath();\n        this.sourceRootDir = new File(absPath);\n        if (!this.sourceRootDir.isDirectory())\n            throw new LagoonException(\"sourceDir must be an existing directory: \" + sourceDir);\n        sitemap = new Sitemap(this, sitemapTree, sourceRootDir);\n        File workDir = new File(System.getProperty(\"user.home\"), \".lagoon\");\n        if (!workDir.exists()) {\n            if (!workDir.mkdir())\n                throw new IOException(\"Unable to create directory: \" + workDir);\n        } else {\n            if (!workDir.isDirectory()) {\n                throw new IOException(\"Unable to create directory (a file with that name exists): \" + workDir);\n            }\n        }\n        if (sitemap.getSiteName() != null) {\n            repositoryDir = new File(workDir, sitemap.getSiteName());\n            if (!repositoryDir.exists()) {\n                if (!repositoryDir.mkdir())\n                    throw new IOException(\"Unable to create directory: \" + repositoryDir);\n            } else {\n                if (!repositoryDir.isDirectory()) {\n                    throw new IOException(\"Unable to create directory (a file with that name exists): \" + repositoryDir);\n                }\n            }\n        } else {\n            repositoryDir = null;\n        }\n        if (repositoryDir != null) {\n            tempDir = new File(repositoryDir, \"temp\");\n            classDir = new File(repositoryDir, \"classes\");\n        } else {\n            tempDir = new File(workDir, \"temp\");\n        }\n        if (!tempDir.exists()) {\n            if (!tempDir.mkdir())\n                throw new IOException(\"Unable to create directory: \" + tempDir);\n        } else {\n            if (!tempDir.isDirectory()) {\n                throw new IOException(\"Unable to create directory (a file with that name exists): \" + tempDir);\n            }\n        }\n        if (classDir == null) {\n            classDir = new File(tempDir, \"classes\");\n        }\n        if (!classDir.exists()) {\n            if (!classDir.mkdir())\n                throw new IOException(\"Unable to create directory: \" + classDir);\n        } else {\n            if (!classDir.isDirectory()) {\n                throw new IOException(\"Unable to create directory (a file with that name exists): \" + classDir);\n            }\n        }\n        classLoaderURLs = new java.net.URL[] { classDir.toURL() };\n        reloadClasses();\n        sitemap.init();\n        targetLocation.open(targetURL, this, password);\n    }\n\n    /**\n     * Get the Sitemap.\n     *\n     * @return the Sitemap.\n     */\n    Sitemap getSitemap() {\n        return sitemap;\n    }\n\n    /**\n     * Get the target location.\n     *\n     * @return the target location.\n     */\n    FileStorage getTargetLocation() {\n        return targetLocation;\n    }\n\n    /**\n     * Perform the building of the website.\n     * May be invoked multiple times.\n     * Synchronous, returns when the building is complete.\n     *\n     * @param force force a rebuild of all files, otherwise dependency\n     *        checking is used to check which files that needs rebuilding.\n     *\n     * @return true if successful, false if any non-fatal error occured\n     * @throws IOException  if any fatal error occur\n     */\n    public boolean build(boolean force) throws IOException {\n        boolean success = true;\n        for (Enumeration e = sitemap.getEntries(); e.hasMoreElements(); ) {\n            SitemapEntry ent = (SitemapEntry) e.nextElement();\n            ent.beforeBuild(force);\n        }\n        for (Enumeration e = sitemap.getEntries(); e.hasMoreElements(); ) {\n            SitemapEntry ent = (SitemapEntry) e.nextElement();\n            if (!ent.build(force))\n                success = false;\n        }\n        for (Enumeration e = sitemap.getEntries(); e.hasMoreElements(); ) {\n            SitemapEntry ent = (SitemapEntry) e.nextElement();\n            ent.afterBuild(force);\n        }\n        return success;\n    }\n\n    /**\n     * Dispose this object and release any resources it holds.\n     * This causes the FileStorage to be closed.\n     */\n    public void destroy() throws IOException {\n        sitemap.destroy();\n        targetLocation.close();\n        repositoryClassLoader = null;\n        if (repositoryDir == null) {\n            File[] classFiles = classDir.listFiles();\n            for (int i = 0; i < classFiles.length; i++) {\n                classFiles[i].delete();\n            }\n        }\n    }\n\n    public File getTempDir() {\n        return tempDir;\n    }\n\n    public InputStream readFileFromRepository(String key) {\n        return readFileFromRepository(null, key);\n    }\n\n    InputStream readFileFromRepository(String dir, String key) {\n        if (repositoryDir == null)\n            return null;\n        File theDir = (dir == null) ? repositoryDir : new File(repositoryDir, dir);\n        File theFile = new File(theDir, key);\n        if (DEBUG)\n            System.out.println(\"readFileFromRepository: \" + theFile);\n        try {\n            return new FileInputStream(theFile);\n        } catch (FileNotFoundException e) {\n            return null;\n        }\n    }\n\n    public OutputStream storeFileInRepository(String key) throws IOException {\n        return storeFileInRepository(null, key);\n    }\n\n    OutputStream storeFileInRepository(String dir, String key) throws IOException {\n        if (repositoryDir == null)\n            return null;\n        File theDir = (dir == null) ? repositoryDir : new File(repositoryDir, dir);\n        theDir.mkdir();\n        File theFile = new File(theDir, key);\n        if (DEBUG)\n            System.out.println(\"storeFileInRepository: \" + theFile);\n        return new FileOutputStream(theFile);\n    }\n\n    public Class loadClassFromRepository(String className) throws ClassNotFoundException {\n        if (DEBUG)\n            System.out.println(\"loadClassFromRepository: \" + className);\n        try {\n            return Class.forName(className, true, repositoryClassLoader);\n        } catch (ClassFormatError e) {\n            File classFile = new File(classDir, className + \".class\");\n            classFile.delete();\n            err.println(e.toString());\n            throw new ClassNotFoundException(className + \" is malformed\");\n        } catch (VerifyError e) {\n            File classFile = new File(classDir, className + \".class\");\n            classFile.delete();\n            err.println(e.toString());\n            throw new ClassNotFoundException(className + \" does not verify\");\n        }\n    }\n\n    public OutputStream storeClassInRepository(String className) throws IOException {\n        if (classDir == null)\n            return null;\n        File theFile = new File(classDir, className + \".class\");\n        if (DEBUG)\n            System.out.println(\"storeClassInRepository: \" + theFile);\n        return new FileOutputStream(theFile);\n    }\n\n    public void deleteClassInRepository(String className) throws IOException {\n        if (classDir == null)\n            return;\n        File theFile = new File(classDir, className + \".class\");\n        if (DEBUG)\n            System.out.println(\"deleteClassInRepository: \" + theFile);\n        if (theFile.isFile() && !theFile.delete())\n            throw new IOException(\"Unable to delete file: \" + theFile);\n    }\n\n    public void reloadClasses() {\n        repositoryClassLoader = new java.net.URLClassLoader(classLoaderURLs);\n    }\n\n    public Object getObjectFromRepository(String key) throws IOException {\n        return getObjectFromRepository(null, key);\n    }\n\n    Object getObjectFromRepository(String dir, String key) throws IOException {\n        InputStream is = readFileFromRepository(dir, key);\n        if (is == null)\n            return null;\n        ObjectInputStream ois = new ObjectInputStream(is);\n        try {\n            return ois.readObject();\n        } catch (ClassNotFoundException e) {\n            if (DEBUG)\n                System.out.println(e);\n            return null;\n        } catch (ObjectStreamException e) {\n            if (DEBUG)\n                System.out.println(e);\n            return null;\n        } catch (ClassCastException e) {\n            if (DEBUG)\n                System.out.println(e);\n            return null;\n        } catch (EOFException e) {\n            if (DEBUG)\n                System.out.println(e);\n            return null;\n        } finally {\n            is.close();\n        }\n    }\n\n    public boolean putObjectIntoRepository(String key, Object obj) throws IOException {\n        return putObjectIntoRepository(null, key, obj);\n    }\n\n    boolean putObjectIntoRepository(String dir, String key, Object obj) throws IOException {\n        OutputStream os = storeFileInRepository(dir, key);\n        if (os == null)\n            return false;\n        ObjectOutputStream oos = new ObjectOutputStream(os);\n        try {\n            oos.writeObject(obj);\n            return true;\n        } finally {\n            oos.close();\n        }\n    }\n\n    /**\n     * Create a new producer.\n     *\n     * @param cat  the producer category (format, transform, source,\n     *             read, parse or process).\n     * @param type the producer type, use \"\" for default.\n     *\n     * @return  a new Producer\n     *          or <code>null</code> if it cannot be found.\n     */\n    Producer createProducer(String cat, String type) throws LagoonException {\n        Class cls = (Class) classDict.get(cat + \":\" + type);\n        if (cls == null)\n            try {\n                String fileName = \"/nu/staldal/lagoon/producer/\" + cat + ((type == \"\") ? \"\" : (\"-\" + type));\n                InputStream is = getClass().getResourceAsStream(fileName);\n                if (is == null)\n                    return null;\n                BufferedReader br = new BufferedReader(new InputStreamReader(is));\n                String className = br.readLine();\n                if (className == null)\n                    throw new LagoonException(\"Illegal Producer config file: \" + fileName);\n                String baseClassName = \"nu.staldal.lagoon.core.\" + Character.toUpperCase(cat.charAt(0)) + cat.substring(1);\n                try {\n                    cls = Class.forName(className);\n                    if (!Class.forName(baseClassName).isAssignableFrom(cls))\n                        throw new LagoonException(cat + \" class must derive from \" + baseClassName);\n                    classDict.put(cat + \":\" + type, cls);\n                } catch (ClassNotFoundException e) {\n                    throw new LagoonException(\"Producer class cannot be found:\" + e.getMessage());\n                }\n                Hashtable params = new Hashtable();\n                for (; ; ) {\n                    String s = br.readLine();\n                    if (s == null)\n                        break;\n                    int colon = s.indexOf(':');\n                    if (colon < 1)\n                        throw new LagoonException(\"Illegal producer config file: \" + fileName);\n                    String paramName = s.substring(0, colon).trim();\n                    String paramValue = s.substring(colon + 1).trim();\n                    params.put(paramName, paramValue);\n                }\n                br.close();\n                paramDict.put(cat + \":\" + type, params);\n            } catch (IOException e) {\n                throw new LagoonException(\"Unable to read producer config file: \" + e.toString());\n            }\n        try {\n            Producer prod = (Producer) cls.newInstance();\n            Hashtable params = (Hashtable) paramDict.get(cat + \":\" + type);\n            for (Enumeration e = params.keys(); e.hasMoreElements(); ) {\n                String name = (String) e.nextElement();\n                String value = (String) params.get(name);\n                prod.addParam(name, value);\n            }\n            return prod;\n        } catch (IllegalAccessException e) {\n            throw new LagoonException(\"Unable to instantiate producer class (illegal access): \" + e.getMessage());\n        } catch (InstantiationException e) {\n            throw new LagoonException(\"Unable to instantiate producer class (instantiation failed): \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Create a new file storage\n     *\n     * @param url  the URL\n     *\n     * @return  a new FileStorage\n     *          or <code>null</code> if it cannot be found.\n     */\n    FileStorage createFileStorage(String url) throws LagoonException {\n        Class cls = null;\n        String prefix;\n        int colon = url.indexOf(':');\n        if (colon < 1) {\n            prefix = \"\";\n            cls = (Class) filestorageDict.get(\"\");\n        } else {\n            prefix = url.substring(0, colon);\n            cls = (Class) filestorageDict.get(prefix);\n            if (cls == null) {\n                cls = (Class) filestorageDict.get(\"\");\n            }\n        }\n        if (cls == null)\n            try {\n                String fileName = \"/nu/staldal/lagoon/filestorage/FileStorage\" + ((prefix == \"\") ? \"\" : (\"-\" + prefix));\n                InputStream is = getClass().getResourceAsStream(fileName);\n                if (is == null) {\n                    fileName = \"/nu/staldal/lagoon/filestorage/FileStorage\";\n                    is = getClass().getResourceAsStream(fileName);\n                    prefix = \"\";\n                }\n                if (is == null)\n                    return null;\n                BufferedReader br = new BufferedReader(new InputStreamReader(is));\n                String className = br.readLine();\n                br.close();\n                if (className == null)\n                    throw new LagoonException(\"Illegal FileStorage config file: \" + fileName);\n                String baseClassName = \"nu.staldal.lagoon.core.FileStorage\";\n                try {\n                    cls = Class.forName(className);\n                    if (!Class.forName(baseClassName).isAssignableFrom(cls))\n                        throw new LagoonException(\"file storage class must derive from \" + baseClassName);\n                    filestorageDict.put(prefix, cls);\n                } catch (ClassNotFoundException e) {\n                    throw new LagoonException(\"FileStorage class cannot be found:\" + e.getMessage());\n                }\n            } catch (IOException e) {\n                throw new LagoonException(\"Unable to read producer config file: \" + e.toString());\n            }\n        try {\n            return (FileStorage) cls.newInstance();\n        } catch (IllegalAccessException e) {\n            throw new LagoonException(\"Unable to instantiate file storage class (illegal access): \" + e.getMessage());\n        } catch (InstantiationException e) {\n            throw new LagoonException(\"Unable to instantiate file storage class (instantiation failed): \" + e.getMessage());\n        }\n    }\n\n    public boolean canCheckFileHasBeenUpdated(String url) {\n        return !Utils.absoluteURL(url) || url.startsWith(\"part:\") || url.startsWith(\"file:\") || url.startsWith(\"res:\");\n    }\n\n    public File getSourceRootDir() {\n        return sourceRootDir;\n    }\n\n    public String getFileURLRelativeTo(String url, String base) {\n        if (Utils.absoluteURL(url) || Utils.pseudoAbsoluteURL(url)) {\n            return url;\n        } else {\n            if (!Utils.pseudoAbsoluteURL(base))\n                throw new IllegalArgumentException(\"base must be a pseudo-absolute URL\");\n            int slash = base.lastIndexOf('/');\n            String baseDir = base.substring(0, slash + 1);\n            return baseDir + url;\n        }\n    }\n\n    public String getProperty(String key) {\n        return sitemap.getProperty(key);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/core/LagoonProcessorTest2.java",
		"test_prompt": "// LagoonProcessorTest2.java\npackage nu.staldal.lagoon.core;\n\nimport java.io.*;\nimport java.util.*;\nimport nu.staldal.xtree.*;\nimport nu.staldal.util.Utils;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link LagoonProcessor}.\n* It contains ten unit test cases for the {@link LagoonProcessor#storeFileInRepository(String)} method.\n*/\nclass LagoonProcessorTest2 {"
	},
	{
		"original_code": "// LagoonProcessor.java\n/*\n * Copyright (c) 2001-2004, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.lagoon.core;\n\nimport java.io.*;\nimport java.util.*;\nimport nu.staldal.xtree.*;\nimport nu.staldal.util.Utils;\n\n/**\n * The main worker class of the Lagoon core.\n *\n * Initialized with the sitemap,\n * a source dir and a target storage URL.\n * Then building the website may be done several times,\n * until destroy() is invoked.\n *\n * This class is not thread-safe. The methods must not\n * be invoked concurrently from different threads.\n */\npublic class LagoonProcessor implements LagoonContext {\n\n    private static final boolean DEBUG = false;\n\n    private final String targetURL;\n\n    private final FileStorage targetLocation;\n\n    private File repositoryDir;\n\n    private File tempDir;\n\n    private File classDir;\n\n    private File sourceRootDir;\n\n    private java.net.URL[] classLoaderURLs;\n\n    private ClassLoader repositoryClassLoader;\n\n    private final Hashtable classDict;\n\n    private final Hashtable paramDict;\n\n    private final Hashtable filestorageDict;\n\n    private Sitemap sitemap;\n\n    PrintWriter log;\n\n    PrintWriter err;\n\n    /**\n     * Constructs and initializes a LagoonProcessor.\n     *\n     * @param targetURL  where to put the generated files,\n     *                   must be an absolute URL or a local file path\n     * @param sitemapTree  the Sitemap as an XTree\n     * @param sourceDir  where the source files are\n     * @param password  password to access the target storage, or\n     *                  <code>null</code> if not nessesary.\n     * @param log  where to write progress messages.\n     * @param err  where to write error messages.\n     */\n    public LagoonProcessor(String targetURL, Element sitemapTree, File sourceDir, String password, PrintWriter log, PrintWriter err) throws IOException, LagoonException, AuthenticationException, AuthenticationMissingException {\n        this.targetURL = targetURL;\n        this.log = log;\n        this.err = err;\n        classDict = new Hashtable();\n        paramDict = new Hashtable();\n        filestorageDict = new Hashtable();\n        targetLocation = createFileStorage(targetURL);\n        if (targetLocation == null)\n            throw new LagoonException(\"Cannot find FileStorage for URL \" + targetURL);\n        if (targetLocation.needPassword() && (password == null)) {\n            throw new AuthenticationMissingException();\n        }\n        String absPath = sourceDir.getAbsolutePath();\n        this.sourceRootDir = new File(absPath);\n        if (!this.sourceRootDir.isDirectory())\n            throw new LagoonException(\"sourceDir must be an existing directory: \" + sourceDir);\n        sitemap = new Sitemap(this, sitemapTree, sourceRootDir);\n        File workDir = new File(System.getProperty(\"user.home\"), \".lagoon\");\n        if (!workDir.exists()) {\n            if (!workDir.mkdir())\n                throw new IOException(\"Unable to create directory: \" + workDir);\n        } else {\n            if (!workDir.isDirectory()) {\n                throw new IOException(\"Unable to create directory (a file with that name exists): \" + workDir);\n            }\n        }\n        if (sitemap.getSiteName() != null) {\n            repositoryDir = new File(workDir, sitemap.getSiteName());\n            if (!repositoryDir.exists()) {\n                if (!repositoryDir.mkdir())\n                    throw new IOException(\"Unable to create directory: \" + repositoryDir);\n            } else {\n                if (!repositoryDir.isDirectory()) {\n                    throw new IOException(\"Unable to create directory (a file with that name exists): \" + repositoryDir);\n                }\n            }\n        } else {\n            repositoryDir = null;\n        }\n        if (repositoryDir != null) {\n            tempDir = new File(repositoryDir, \"temp\");\n            classDir = new File(repositoryDir, \"classes\");\n        } else {\n            tempDir = new File(workDir, \"temp\");\n        }\n        if (!tempDir.exists()) {\n            if (!tempDir.mkdir())\n                throw new IOException(\"Unable to create directory: \" + tempDir);\n        } else {\n            if (!tempDir.isDirectory()) {\n                throw new IOException(\"Unable to create directory (a file with that name exists): \" + tempDir);\n            }\n        }\n        if (classDir == null) {\n            classDir = new File(tempDir, \"classes\");\n        }\n        if (!classDir.exists()) {\n            if (!classDir.mkdir())\n                throw new IOException(\"Unable to create directory: \" + classDir);\n        } else {\n            if (!classDir.isDirectory()) {\n                throw new IOException(\"Unable to create directory (a file with that name exists): \" + classDir);\n            }\n        }\n        classLoaderURLs = new java.net.URL[] { classDir.toURL() };\n        reloadClasses();\n        sitemap.init();\n        targetLocation.open(targetURL, this, password);\n    }\n\n    /**\n     * Get the Sitemap.\n     *\n     * @return the Sitemap.\n     */\n    Sitemap getSitemap() {\n        return sitemap;\n    }\n\n    /**\n     * Get the target location.\n     *\n     * @return the target location.\n     */\n    FileStorage getTargetLocation() {\n        return targetLocation;\n    }\n\n    /**\n     * Perform the building of the website.\n     * May be invoked multiple times.\n     * Synchronous, returns when the building is complete.\n     *\n     * @param force force a rebuild of all files, otherwise dependency\n     *        checking is used to check which files that needs rebuilding.\n     *\n     * @return true if successful, false if any non-fatal error occured\n     * @throws IOException  if any fatal error occur\n     */\n    public boolean build(boolean force) throws IOException {\n        boolean success = true;\n        for (Enumeration e = sitemap.getEntries(); e.hasMoreElements(); ) {\n            SitemapEntry ent = (SitemapEntry) e.nextElement();\n            ent.beforeBuild(force);\n        }\n        for (Enumeration e = sitemap.getEntries(); e.hasMoreElements(); ) {\n            SitemapEntry ent = (SitemapEntry) e.nextElement();\n            if (!ent.build(force))\n                success = false;\n        }\n        for (Enumeration e = sitemap.getEntries(); e.hasMoreElements(); ) {\n            SitemapEntry ent = (SitemapEntry) e.nextElement();\n            ent.afterBuild(force);\n        }\n        return success;\n    }\n\n    /**\n     * Dispose this object and release any resources it holds.\n     * This causes the FileStorage to be closed.\n     */\n    public void destroy() throws IOException {\n        sitemap.destroy();\n        targetLocation.close();\n        repositoryClassLoader = null;\n        if (repositoryDir == null) {\n            File[] classFiles = classDir.listFiles();\n            for (int i = 0; i < classFiles.length; i++) {\n                classFiles[i].delete();\n            }\n        }\n    }\n\n    public File getTempDir() {\n        return tempDir;\n    }\n\n    public InputStream readFileFromRepository(String key) {\n        return readFileFromRepository(null, key);\n    }\n\n    InputStream readFileFromRepository(String dir, String key) {\n        if (repositoryDir == null)\n            return null;\n        File theDir = (dir == null) ? repositoryDir : new File(repositoryDir, dir);\n        File theFile = new File(theDir, key);\n        if (DEBUG)\n            System.out.println(\"readFileFromRepository: \" + theFile);\n        try {\n            return new FileInputStream(theFile);\n        } catch (FileNotFoundException e) {\n            return null;\n        }\n    }\n\n    public OutputStream storeFileInRepository(String key) throws IOException {\n        return storeFileInRepository(null, key);\n    }\n\n    OutputStream storeFileInRepository(String dir, String key) throws IOException {\n        if (repositoryDir == null)\n            return null;\n        File theDir = (dir == null) ? repositoryDir : new File(repositoryDir, dir);\n        theDir.mkdir();\n        File theFile = new File(theDir, key);\n        if (DEBUG)\n            System.out.println(\"storeFileInRepository: \" + theFile);\n        return new FileOutputStream(theFile);\n    }\n\n    public Class loadClassFromRepository(String className) throws ClassNotFoundException {\n        if (DEBUG)\n            System.out.println(\"loadClassFromRepository: \" + className);\n        try {\n            return Class.forName(className, true, repositoryClassLoader);\n        } catch (ClassFormatError e) {\n            File classFile = new File(classDir, className + \".class\");\n            classFile.delete();\n            err.println(e.toString());\n            throw new ClassNotFoundException(className + \" is malformed\");\n        } catch (VerifyError e) {\n            File classFile = new File(classDir, className + \".class\");\n            classFile.delete();\n            err.println(e.toString());\n            throw new ClassNotFoundException(className + \" does not verify\");\n        }\n    }\n\n    public OutputStream storeClassInRepository(String className) throws IOException {\n        if (classDir == null)\n            return null;\n        File theFile = new File(classDir, className + \".class\");\n        if (DEBUG)\n            System.out.println(\"storeClassInRepository: \" + theFile);\n        return new FileOutputStream(theFile);\n    }\n\n    public void deleteClassInRepository(String className) throws IOException {\n        if (classDir == null)\n            return;\n        File theFile = new File(classDir, className + \".class\");\n        if (DEBUG)\n            System.out.println(\"deleteClassInRepository: \" + theFile);\n        if (theFile.isFile() && !theFile.delete())\n            throw new IOException(\"Unable to delete file: \" + theFile);\n    }\n\n    public void reloadClasses() {\n        repositoryClassLoader = new java.net.URLClassLoader(classLoaderURLs);\n    }\n\n    public Object getObjectFromRepository(String key) throws IOException {\n        return getObjectFromRepository(null, key);\n    }\n\n    Object getObjectFromRepository(String dir, String key) throws IOException {\n        InputStream is = readFileFromRepository(dir, key);\n        if (is == null)\n            return null;\n        ObjectInputStream ois = new ObjectInputStream(is);\n        try {\n            return ois.readObject();\n        } catch (ClassNotFoundException e) {\n            if (DEBUG)\n                System.out.println(e);\n            return null;\n        } catch (ObjectStreamException e) {\n            if (DEBUG)\n                System.out.println(e);\n            return null;\n        } catch (ClassCastException e) {\n            if (DEBUG)\n                System.out.println(e);\n            return null;\n        } catch (EOFException e) {\n            if (DEBUG)\n                System.out.println(e);\n            return null;\n        } finally {\n            is.close();\n        }\n    }\n\n    public boolean putObjectIntoRepository(String key, Object obj) throws IOException {\n        return putObjectIntoRepository(null, key, obj);\n    }\n\n    boolean putObjectIntoRepository(String dir, String key, Object obj) throws IOException {\n        OutputStream os = storeFileInRepository(dir, key);\n        if (os == null)\n            return false;\n        ObjectOutputStream oos = new ObjectOutputStream(os);\n        try {\n            oos.writeObject(obj);\n            return true;\n        } finally {\n            oos.close();\n        }\n    }\n\n    /**\n     * Create a new producer.\n     *\n     * @param cat  the producer category (format, transform, source,\n     *             read, parse or process).\n     * @param type the producer type, use \"\" for default.\n     *\n     * @return  a new Producer\n     *          or <code>null</code> if it cannot be found.\n     */\n    Producer createProducer(String cat, String type) throws LagoonException {\n        Class cls = (Class) classDict.get(cat + \":\" + type);\n        if (cls == null)\n            try {\n                String fileName = \"/nu/staldal/lagoon/producer/\" + cat + ((type == \"\") ? \"\" : (\"-\" + type));\n                InputStream is = getClass().getResourceAsStream(fileName);\n                if (is == null)\n                    return null;\n                BufferedReader br = new BufferedReader(new InputStreamReader(is));\n                String className = br.readLine();\n                if (className == null)\n                    throw new LagoonException(\"Illegal Producer config file: \" + fileName);\n                String baseClassName = \"nu.staldal.lagoon.core.\" + Character.toUpperCase(cat.charAt(0)) + cat.substring(1);\n                try {\n                    cls = Class.forName(className);\n                    if (!Class.forName(baseClassName).isAssignableFrom(cls))\n                        throw new LagoonException(cat + \" class must derive from \" + baseClassName);\n                    classDict.put(cat + \":\" + type, cls);\n                } catch (ClassNotFoundException e) {\n                    throw new LagoonException(\"Producer class cannot be found:\" + e.getMessage());\n                }\n                Hashtable params = new Hashtable();\n                for (; ; ) {\n                    String s = br.readLine();\n                    if (s == null)\n                        break;\n                    int colon = s.indexOf(':');\n                    if (colon < 1)\n                        throw new LagoonException(\"Illegal producer config file: \" + fileName);\n                    String paramName = s.substring(0, colon).trim();\n                    String paramValue = s.substring(colon + 1).trim();\n                    params.put(paramName, paramValue);\n                }\n                br.close();\n                paramDict.put(cat + \":\" + type, params);\n            } catch (IOException e) {\n                throw new LagoonException(\"Unable to read producer config file: \" + e.toString());\n            }\n        try {\n            Producer prod = (Producer) cls.newInstance();\n            Hashtable params = (Hashtable) paramDict.get(cat + \":\" + type);\n            for (Enumeration e = params.keys(); e.hasMoreElements(); ) {\n                String name = (String) e.nextElement();\n                String value = (String) params.get(name);\n                prod.addParam(name, value);\n            }\n            return prod;\n        } catch (IllegalAccessException e) {\n            throw new LagoonException(\"Unable to instantiate producer class (illegal access): \" + e.getMessage());\n        } catch (InstantiationException e) {\n            throw new LagoonException(\"Unable to instantiate producer class (instantiation failed): \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Create a new file storage\n     *\n     * @param url  the URL\n     *\n     * @return  a new FileStorage\n     *          or <code>null</code> if it cannot be found.\n     */\n    FileStorage createFileStorage(String url) throws LagoonException {\n        Class cls = null;\n        String prefix;\n        int colon = url.indexOf(':');\n        if (colon < 1) {\n            prefix = \"\";\n            cls = (Class) filestorageDict.get(\"\");\n        } else {\n            prefix = url.substring(0, colon);\n            cls = (Class) filestorageDict.get(prefix);\n            if (cls == null) {\n                cls = (Class) filestorageDict.get(\"\");\n            }\n        }\n        if (cls == null)\n            try {\n                String fileName = \"/nu/staldal/lagoon/filestorage/FileStorage\" + ((prefix == \"\") ? \"\" : (\"-\" + prefix));\n                InputStream is = getClass().getResourceAsStream(fileName);\n                if (is == null) {\n                    fileName = \"/nu/staldal/lagoon/filestorage/FileStorage\";\n                    is = getClass().getResourceAsStream(fileName);\n                    prefix = \"\";\n                }\n                if (is == null)\n                    return null;\n                BufferedReader br = new BufferedReader(new InputStreamReader(is));\n                String className = br.readLine();\n                br.close();\n                if (className == null)\n                    throw new LagoonException(\"Illegal FileStorage config file: \" + fileName);\n                String baseClassName = \"nu.staldal.lagoon.core.FileStorage\";\n                try {\n                    cls = Class.forName(className);\n                    if (!Class.forName(baseClassName).isAssignableFrom(cls))\n                        throw new LagoonException(\"file storage class must derive from \" + baseClassName);\n                    filestorageDict.put(prefix, cls);\n                } catch (ClassNotFoundException e) {\n                    throw new LagoonException(\"FileStorage class cannot be found:\" + e.getMessage());\n                }\n            } catch (IOException e) {\n                throw new LagoonException(\"Unable to read producer config file: \" + e.toString());\n            }\n        try {\n            return (FileStorage) cls.newInstance();\n        } catch (IllegalAccessException e) {\n            throw new LagoonException(\"Unable to instantiate file storage class (illegal access): \" + e.getMessage());\n        } catch (InstantiationException e) {\n            throw new LagoonException(\"Unable to instantiate file storage class (instantiation failed): \" + e.getMessage());\n        }\n    }\n\n    public boolean canCheckFileHasBeenUpdated(String url) {\n        return !Utils.absoluteURL(url) || url.startsWith(\"part:\") || url.startsWith(\"file:\") || url.startsWith(\"res:\");\n    }\n\n    public File getSourceRootDir() {\n        return sourceRootDir;\n    }\n\n    public String getFileURLRelativeTo(String url, String base) {\n        if (Utils.absoluteURL(url) || Utils.pseudoAbsoluteURL(url)) {\n            return url;\n        } else {\n            if (!Utils.pseudoAbsoluteURL(base))\n                throw new IllegalArgumentException(\"base must be a pseudo-absolute URL\");\n            int slash = base.lastIndexOf('/');\n            String baseDir = base.substring(0, slash + 1);\n            return baseDir + url;\n        }\n    }\n\n    public String getProperty(String key) {\n        return sitemap.getProperty(key);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/core/LagoonProcessorTest3.java",
		"test_prompt": "// LagoonProcessorTest3.java\npackage nu.staldal.lagoon.core;\n\nimport java.io.*;\nimport java.util.*;\nimport nu.staldal.xtree.*;\nimport nu.staldal.util.Utils;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link LagoonProcessor}.\n* It contains ten unit test cases for the {@link LagoonProcessor#loadClassFromRepository(String)} method.\n*/\nclass LagoonProcessorTest3 {"
	},
	{
		"original_code": "// LagoonProcessor.java\n/*\n * Copyright (c) 2001-2004, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.lagoon.core;\n\nimport java.io.*;\nimport java.util.*;\nimport nu.staldal.xtree.*;\nimport nu.staldal.util.Utils;\n\n/**\n * The main worker class of the Lagoon core.\n *\n * Initialized with the sitemap,\n * a source dir and a target storage URL.\n * Then building the website may be done several times,\n * until destroy() is invoked.\n *\n * This class is not thread-safe. The methods must not\n * be invoked concurrently from different threads.\n */\npublic class LagoonProcessor implements LagoonContext {\n\n    private static final boolean DEBUG = false;\n\n    private final String targetURL;\n\n    private final FileStorage targetLocation;\n\n    private File repositoryDir;\n\n    private File tempDir;\n\n    private File classDir;\n\n    private File sourceRootDir;\n\n    private java.net.URL[] classLoaderURLs;\n\n    private ClassLoader repositoryClassLoader;\n\n    private final Hashtable classDict;\n\n    private final Hashtable paramDict;\n\n    private final Hashtable filestorageDict;\n\n    private Sitemap sitemap;\n\n    PrintWriter log;\n\n    PrintWriter err;\n\n    /**\n     * Constructs and initializes a LagoonProcessor.\n     *\n     * @param targetURL  where to put the generated files,\n     *                   must be an absolute URL or a local file path\n     * @param sitemapTree  the Sitemap as an XTree\n     * @param sourceDir  where the source files are\n     * @param password  password to access the target storage, or\n     *                  <code>null</code> if not nessesary.\n     * @param log  where to write progress messages.\n     * @param err  where to write error messages.\n     */\n    public LagoonProcessor(String targetURL, Element sitemapTree, File sourceDir, String password, PrintWriter log, PrintWriter err) throws IOException, LagoonException, AuthenticationException, AuthenticationMissingException {\n        this.targetURL = targetURL;\n        this.log = log;\n        this.err = err;\n        classDict = new Hashtable();\n        paramDict = new Hashtable();\n        filestorageDict = new Hashtable();\n        targetLocation = createFileStorage(targetURL);\n        if (targetLocation == null)\n            throw new LagoonException(\"Cannot find FileStorage for URL \" + targetURL);\n        if (targetLocation.needPassword() && (password == null)) {\n            throw new AuthenticationMissingException();\n        }\n        String absPath = sourceDir.getAbsolutePath();\n        this.sourceRootDir = new File(absPath);\n        if (!this.sourceRootDir.isDirectory())\n            throw new LagoonException(\"sourceDir must be an existing directory: \" + sourceDir);\n        sitemap = new Sitemap(this, sitemapTree, sourceRootDir);\n        File workDir = new File(System.getProperty(\"user.home\"), \".lagoon\");\n        if (!workDir.exists()) {\n            if (!workDir.mkdir())\n                throw new IOException(\"Unable to create directory: \" + workDir);\n        } else {\n            if (!workDir.isDirectory()) {\n                throw new IOException(\"Unable to create directory (a file with that name exists): \" + workDir);\n            }\n        }\n        if (sitemap.getSiteName() != null) {\n            repositoryDir = new File(workDir, sitemap.getSiteName());\n            if (!repositoryDir.exists()) {\n                if (!repositoryDir.mkdir())\n                    throw new IOException(\"Unable to create directory: \" + repositoryDir);\n            } else {\n                if (!repositoryDir.isDirectory()) {\n                    throw new IOException(\"Unable to create directory (a file with that name exists): \" + repositoryDir);\n                }\n            }\n        } else {\n            repositoryDir = null;\n        }\n        if (repositoryDir != null) {\n            tempDir = new File(repositoryDir, \"temp\");\n            classDir = new File(repositoryDir, \"classes\");\n        } else {\n            tempDir = new File(workDir, \"temp\");\n        }\n        if (!tempDir.exists()) {\n            if (!tempDir.mkdir())\n                throw new IOException(\"Unable to create directory: \" + tempDir);\n        } else {\n            if (!tempDir.isDirectory()) {\n                throw new IOException(\"Unable to create directory (a file with that name exists): \" + tempDir);\n            }\n        }\n        if (classDir == null) {\n            classDir = new File(tempDir, \"classes\");\n        }\n        if (!classDir.exists()) {\n            if (!classDir.mkdir())\n                throw new IOException(\"Unable to create directory: \" + classDir);\n        } else {\n            if (!classDir.isDirectory()) {\n                throw new IOException(\"Unable to create directory (a file with that name exists): \" + classDir);\n            }\n        }\n        classLoaderURLs = new java.net.URL[] { classDir.toURL() };\n        reloadClasses();\n        sitemap.init();\n        targetLocation.open(targetURL, this, password);\n    }\n\n    /**\n     * Get the Sitemap.\n     *\n     * @return the Sitemap.\n     */\n    Sitemap getSitemap() {\n        return sitemap;\n    }\n\n    /**\n     * Get the target location.\n     *\n     * @return the target location.\n     */\n    FileStorage getTargetLocation() {\n        return targetLocation;\n    }\n\n    /**\n     * Perform the building of the website.\n     * May be invoked multiple times.\n     * Synchronous, returns when the building is complete.\n     *\n     * @param force force a rebuild of all files, otherwise dependency\n     *        checking is used to check which files that needs rebuilding.\n     *\n     * @return true if successful, false if any non-fatal error occured\n     * @throws IOException  if any fatal error occur\n     */\n    public boolean build(boolean force) throws IOException {\n        boolean success = true;\n        for (Enumeration e = sitemap.getEntries(); e.hasMoreElements(); ) {\n            SitemapEntry ent = (SitemapEntry) e.nextElement();\n            ent.beforeBuild(force);\n        }\n        for (Enumeration e = sitemap.getEntries(); e.hasMoreElements(); ) {\n            SitemapEntry ent = (SitemapEntry) e.nextElement();\n            if (!ent.build(force))\n                success = false;\n        }\n        for (Enumeration e = sitemap.getEntries(); e.hasMoreElements(); ) {\n            SitemapEntry ent = (SitemapEntry) e.nextElement();\n            ent.afterBuild(force);\n        }\n        return success;\n    }\n\n    /**\n     * Dispose this object and release any resources it holds.\n     * This causes the FileStorage to be closed.\n     */\n    public void destroy() throws IOException {\n        sitemap.destroy();\n        targetLocation.close();\n        repositoryClassLoader = null;\n        if (repositoryDir == null) {\n            File[] classFiles = classDir.listFiles();\n            for (int i = 0; i < classFiles.length; i++) {\n                classFiles[i].delete();\n            }\n        }\n    }\n\n    public File getTempDir() {\n        return tempDir;\n    }\n\n    public InputStream readFileFromRepository(String key) {\n        return readFileFromRepository(null, key);\n    }\n\n    InputStream readFileFromRepository(String dir, String key) {\n        if (repositoryDir == null)\n            return null;\n        File theDir = (dir == null) ? repositoryDir : new File(repositoryDir, dir);\n        File theFile = new File(theDir, key);\n        if (DEBUG)\n            System.out.println(\"readFileFromRepository: \" + theFile);\n        try {\n            return new FileInputStream(theFile);\n        } catch (FileNotFoundException e) {\n            return null;\n        }\n    }\n\n    public OutputStream storeFileInRepository(String key) throws IOException {\n        return storeFileInRepository(null, key);\n    }\n\n    OutputStream storeFileInRepository(String dir, String key) throws IOException {\n        if (repositoryDir == null)\n            return null;\n        File theDir = (dir == null) ? repositoryDir : new File(repositoryDir, dir);\n        theDir.mkdir();\n        File theFile = new File(theDir, key);\n        if (DEBUG)\n            System.out.println(\"storeFileInRepository: \" + theFile);\n        return new FileOutputStream(theFile);\n    }\n\n    public Class loadClassFromRepository(String className) throws ClassNotFoundException {\n        if (DEBUG)\n            System.out.println(\"loadClassFromRepository: \" + className);\n        try {\n            return Class.forName(className, true, repositoryClassLoader);\n        } catch (ClassFormatError e) {\n            File classFile = new File(classDir, className + \".class\");\n            classFile.delete();\n            err.println(e.toString());\n            throw new ClassNotFoundException(className + \" is malformed\");\n        } catch (VerifyError e) {\n            File classFile = new File(classDir, className + \".class\");\n            classFile.delete();\n            err.println(e.toString());\n            throw new ClassNotFoundException(className + \" does not verify\");\n        }\n    }\n\n    public OutputStream storeClassInRepository(String className) throws IOException {\n        if (classDir == null)\n            return null;\n        File theFile = new File(classDir, className + \".class\");\n        if (DEBUG)\n            System.out.println(\"storeClassInRepository: \" + theFile);\n        return new FileOutputStream(theFile);\n    }\n\n    public void deleteClassInRepository(String className) throws IOException {\n        if (classDir == null)\n            return;\n        File theFile = new File(classDir, className + \".class\");\n        if (DEBUG)\n            System.out.println(\"deleteClassInRepository: \" + theFile);\n        if (theFile.isFile() && !theFile.delete())\n            throw new IOException(\"Unable to delete file: \" + theFile);\n    }\n\n    public void reloadClasses() {\n        repositoryClassLoader = new java.net.URLClassLoader(classLoaderURLs);\n    }\n\n    public Object getObjectFromRepository(String key) throws IOException {\n        return getObjectFromRepository(null, key);\n    }\n\n    Object getObjectFromRepository(String dir, String key) throws IOException {\n        InputStream is = readFileFromRepository(dir, key);\n        if (is == null)\n            return null;\n        ObjectInputStream ois = new ObjectInputStream(is);\n        try {\n            return ois.readObject();\n        } catch (ClassNotFoundException e) {\n            if (DEBUG)\n                System.out.println(e);\n            return null;\n        } catch (ObjectStreamException e) {\n            if (DEBUG)\n                System.out.println(e);\n            return null;\n        } catch (ClassCastException e) {\n            if (DEBUG)\n                System.out.println(e);\n            return null;\n        } catch (EOFException e) {\n            if (DEBUG)\n                System.out.println(e);\n            return null;\n        } finally {\n            is.close();\n        }\n    }\n\n    public boolean putObjectIntoRepository(String key, Object obj) throws IOException {\n        return putObjectIntoRepository(null, key, obj);\n    }\n\n    boolean putObjectIntoRepository(String dir, String key, Object obj) throws IOException {\n        OutputStream os = storeFileInRepository(dir, key);\n        if (os == null)\n            return false;\n        ObjectOutputStream oos = new ObjectOutputStream(os);\n        try {\n            oos.writeObject(obj);\n            return true;\n        } finally {\n            oos.close();\n        }\n    }\n\n    /**\n     * Create a new producer.\n     *\n     * @param cat  the producer category (format, transform, source,\n     *             read, parse or process).\n     * @param type the producer type, use \"\" for default.\n     *\n     * @return  a new Producer\n     *          or <code>null</code> if it cannot be found.\n     */\n    Producer createProducer(String cat, String type) throws LagoonException {\n        Class cls = (Class) classDict.get(cat + \":\" + type);\n        if (cls == null)\n            try {\n                String fileName = \"/nu/staldal/lagoon/producer/\" + cat + ((type == \"\") ? \"\" : (\"-\" + type));\n                InputStream is = getClass().getResourceAsStream(fileName);\n                if (is == null)\n                    return null;\n                BufferedReader br = new BufferedReader(new InputStreamReader(is));\n                String className = br.readLine();\n                if (className == null)\n                    throw new LagoonException(\"Illegal Producer config file: \" + fileName);\n                String baseClassName = \"nu.staldal.lagoon.core.\" + Character.toUpperCase(cat.charAt(0)) + cat.substring(1);\n                try {\n                    cls = Class.forName(className);\n                    if (!Class.forName(baseClassName).isAssignableFrom(cls))\n                        throw new LagoonException(cat + \" class must derive from \" + baseClassName);\n                    classDict.put(cat + \":\" + type, cls);\n                } catch (ClassNotFoundException e) {\n                    throw new LagoonException(\"Producer class cannot be found:\" + e.getMessage());\n                }\n                Hashtable params = new Hashtable();\n                for (; ; ) {\n                    String s = br.readLine();\n                    if (s == null)\n                        break;\n                    int colon = s.indexOf(':');\n                    if (colon < 1)\n                        throw new LagoonException(\"Illegal producer config file: \" + fileName);\n                    String paramName = s.substring(0, colon).trim();\n                    String paramValue = s.substring(colon + 1).trim();\n                    params.put(paramName, paramValue);\n                }\n                br.close();\n                paramDict.put(cat + \":\" + type, params);\n            } catch (IOException e) {\n                throw new LagoonException(\"Unable to read producer config file: \" + e.toString());\n            }\n        try {\n            Producer prod = (Producer) cls.newInstance();\n            Hashtable params = (Hashtable) paramDict.get(cat + \":\" + type);\n            for (Enumeration e = params.keys(); e.hasMoreElements(); ) {\n                String name = (String) e.nextElement();\n                String value = (String) params.get(name);\n                prod.addParam(name, value);\n            }\n            return prod;\n        } catch (IllegalAccessException e) {\n            throw new LagoonException(\"Unable to instantiate producer class (illegal access): \" + e.getMessage());\n        } catch (InstantiationException e) {\n            throw new LagoonException(\"Unable to instantiate producer class (instantiation failed): \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Create a new file storage\n     *\n     * @param url  the URL\n     *\n     * @return  a new FileStorage\n     *          or <code>null</code> if it cannot be found.\n     */\n    FileStorage createFileStorage(String url) throws LagoonException {\n        Class cls = null;\n        String prefix;\n        int colon = url.indexOf(':');\n        if (colon < 1) {\n            prefix = \"\";\n            cls = (Class) filestorageDict.get(\"\");\n        } else {\n            prefix = url.substring(0, colon);\n            cls = (Class) filestorageDict.get(prefix);\n            if (cls == null) {\n                cls = (Class) filestorageDict.get(\"\");\n            }\n        }\n        if (cls == null)\n            try {\n                String fileName = \"/nu/staldal/lagoon/filestorage/FileStorage\" + ((prefix == \"\") ? \"\" : (\"-\" + prefix));\n                InputStream is = getClass().getResourceAsStream(fileName);\n                if (is == null) {\n                    fileName = \"/nu/staldal/lagoon/filestorage/FileStorage\";\n                    is = getClass().getResourceAsStream(fileName);\n                    prefix = \"\";\n                }\n                if (is == null)\n                    return null;\n                BufferedReader br = new BufferedReader(new InputStreamReader(is));\n                String className = br.readLine();\n                br.close();\n                if (className == null)\n                    throw new LagoonException(\"Illegal FileStorage config file: \" + fileName);\n                String baseClassName = \"nu.staldal.lagoon.core.FileStorage\";\n                try {\n                    cls = Class.forName(className);\n                    if (!Class.forName(baseClassName).isAssignableFrom(cls))\n                        throw new LagoonException(\"file storage class must derive from \" + baseClassName);\n                    filestorageDict.put(prefix, cls);\n                } catch (ClassNotFoundException e) {\n                    throw new LagoonException(\"FileStorage class cannot be found:\" + e.getMessage());\n                }\n            } catch (IOException e) {\n                throw new LagoonException(\"Unable to read producer config file: \" + e.toString());\n            }\n        try {\n            return (FileStorage) cls.newInstance();\n        } catch (IllegalAccessException e) {\n            throw new LagoonException(\"Unable to instantiate file storage class (illegal access): \" + e.getMessage());\n        } catch (InstantiationException e) {\n            throw new LagoonException(\"Unable to instantiate file storage class (instantiation failed): \" + e.getMessage());\n        }\n    }\n\n    public boolean canCheckFileHasBeenUpdated(String url) {\n        return !Utils.absoluteURL(url) || url.startsWith(\"part:\") || url.startsWith(\"file:\") || url.startsWith(\"res:\");\n    }\n\n    public File getSourceRootDir() {\n        return sourceRootDir;\n    }\n\n    public String getFileURLRelativeTo(String url, String base) {\n        if (Utils.absoluteURL(url) || Utils.pseudoAbsoluteURL(url)) {\n            return url;\n        } else {\n            if (!Utils.pseudoAbsoluteURL(base))\n                throw new IllegalArgumentException(\"base must be a pseudo-absolute URL\");\n            int slash = base.lastIndexOf('/');\n            String baseDir = base.substring(0, slash + 1);\n            return baseDir + url;\n        }\n    }\n\n    public String getProperty(String key) {\n        return sitemap.getProperty(key);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/core/LagoonProcessorTest4.java",
		"test_prompt": "// LagoonProcessorTest4.java\npackage nu.staldal.lagoon.core;\n\nimport java.io.*;\nimport java.util.*;\nimport nu.staldal.xtree.*;\nimport nu.staldal.util.Utils;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link LagoonProcessor}.\n* It contains ten unit test cases for the {@link LagoonProcessor#storeClassInRepository(String)} method.\n*/\nclass LagoonProcessorTest4 {"
	},
	{
		"original_code": "// LagoonProcessor.java\n/*\n * Copyright (c) 2001-2004, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.lagoon.core;\n\nimport java.io.*;\nimport java.util.*;\nimport nu.staldal.xtree.*;\nimport nu.staldal.util.Utils;\n\n/**\n * The main worker class of the Lagoon core.\n *\n * Initialized with the sitemap,\n * a source dir and a target storage URL.\n * Then building the website may be done several times,\n * until destroy() is invoked.\n *\n * This class is not thread-safe. The methods must not\n * be invoked concurrently from different threads.\n */\npublic class LagoonProcessor implements LagoonContext {\n\n    private static final boolean DEBUG = false;\n\n    private final String targetURL;\n\n    private final FileStorage targetLocation;\n\n    private File repositoryDir;\n\n    private File tempDir;\n\n    private File classDir;\n\n    private File sourceRootDir;\n\n    private java.net.URL[] classLoaderURLs;\n\n    private ClassLoader repositoryClassLoader;\n\n    private final Hashtable classDict;\n\n    private final Hashtable paramDict;\n\n    private final Hashtable filestorageDict;\n\n    private Sitemap sitemap;\n\n    PrintWriter log;\n\n    PrintWriter err;\n\n    /**\n     * Constructs and initializes a LagoonProcessor.\n     *\n     * @param targetURL  where to put the generated files,\n     *                   must be an absolute URL or a local file path\n     * @param sitemapTree  the Sitemap as an XTree\n     * @param sourceDir  where the source files are\n     * @param password  password to access the target storage, or\n     *                  <code>null</code> if not nessesary.\n     * @param log  where to write progress messages.\n     * @param err  where to write error messages.\n     */\n    public LagoonProcessor(String targetURL, Element sitemapTree, File sourceDir, String password, PrintWriter log, PrintWriter err) throws IOException, LagoonException, AuthenticationException, AuthenticationMissingException {\n        this.targetURL = targetURL;\n        this.log = log;\n        this.err = err;\n        classDict = new Hashtable();\n        paramDict = new Hashtable();\n        filestorageDict = new Hashtable();\n        targetLocation = createFileStorage(targetURL);\n        if (targetLocation == null)\n            throw new LagoonException(\"Cannot find FileStorage for URL \" + targetURL);\n        if (targetLocation.needPassword() && (password == null)) {\n            throw new AuthenticationMissingException();\n        }\n        String absPath = sourceDir.getAbsolutePath();\n        this.sourceRootDir = new File(absPath);\n        if (!this.sourceRootDir.isDirectory())\n            throw new LagoonException(\"sourceDir must be an existing directory: \" + sourceDir);\n        sitemap = new Sitemap(this, sitemapTree, sourceRootDir);\n        File workDir = new File(System.getProperty(\"user.home\"), \".lagoon\");\n        if (!workDir.exists()) {\n            if (!workDir.mkdir())\n                throw new IOException(\"Unable to create directory: \" + workDir);\n        } else {\n            if (!workDir.isDirectory()) {\n                throw new IOException(\"Unable to create directory (a file with that name exists): \" + workDir);\n            }\n        }\n        if (sitemap.getSiteName() != null) {\n            repositoryDir = new File(workDir, sitemap.getSiteName());\n            if (!repositoryDir.exists()) {\n                if (!repositoryDir.mkdir())\n                    throw new IOException(\"Unable to create directory: \" + repositoryDir);\n            } else {\n                if (!repositoryDir.isDirectory()) {\n                    throw new IOException(\"Unable to create directory (a file with that name exists): \" + repositoryDir);\n                }\n            }\n        } else {\n            repositoryDir = null;\n        }\n        if (repositoryDir != null) {\n            tempDir = new File(repositoryDir, \"temp\");\n            classDir = new File(repositoryDir, \"classes\");\n        } else {\n            tempDir = new File(workDir, \"temp\");\n        }\n        if (!tempDir.exists()) {\n            if (!tempDir.mkdir())\n                throw new IOException(\"Unable to create directory: \" + tempDir);\n        } else {\n            if (!tempDir.isDirectory()) {\n                throw new IOException(\"Unable to create directory (a file with that name exists): \" + tempDir);\n            }\n        }\n        if (classDir == null) {\n            classDir = new File(tempDir, \"classes\");\n        }\n        if (!classDir.exists()) {\n            if (!classDir.mkdir())\n                throw new IOException(\"Unable to create directory: \" + classDir);\n        } else {\n            if (!classDir.isDirectory()) {\n                throw new IOException(\"Unable to create directory (a file with that name exists): \" + classDir);\n            }\n        }\n        classLoaderURLs = new java.net.URL[] { classDir.toURL() };\n        reloadClasses();\n        sitemap.init();\n        targetLocation.open(targetURL, this, password);\n    }\n\n    /**\n     * Get the Sitemap.\n     *\n     * @return the Sitemap.\n     */\n    Sitemap getSitemap() {\n        return sitemap;\n    }\n\n    /**\n     * Get the target location.\n     *\n     * @return the target location.\n     */\n    FileStorage getTargetLocation() {\n        return targetLocation;\n    }\n\n    /**\n     * Perform the building of the website.\n     * May be invoked multiple times.\n     * Synchronous, returns when the building is complete.\n     *\n     * @param force force a rebuild of all files, otherwise dependency\n     *        checking is used to check which files that needs rebuilding.\n     *\n     * @return true if successful, false if any non-fatal error occured\n     * @throws IOException  if any fatal error occur\n     */\n    public boolean build(boolean force) throws IOException {\n        boolean success = true;\n        for (Enumeration e = sitemap.getEntries(); e.hasMoreElements(); ) {\n            SitemapEntry ent = (SitemapEntry) e.nextElement();\n            ent.beforeBuild(force);\n        }\n        for (Enumeration e = sitemap.getEntries(); e.hasMoreElements(); ) {\n            SitemapEntry ent = (SitemapEntry) e.nextElement();\n            if (!ent.build(force))\n                success = false;\n        }\n        for (Enumeration e = sitemap.getEntries(); e.hasMoreElements(); ) {\n            SitemapEntry ent = (SitemapEntry) e.nextElement();\n            ent.afterBuild(force);\n        }\n        return success;\n    }\n\n    /**\n     * Dispose this object and release any resources it holds.\n     * This causes the FileStorage to be closed.\n     */\n    public void destroy() throws IOException {\n        sitemap.destroy();\n        targetLocation.close();\n        repositoryClassLoader = null;\n        if (repositoryDir == null) {\n            File[] classFiles = classDir.listFiles();\n            for (int i = 0; i < classFiles.length; i++) {\n                classFiles[i].delete();\n            }\n        }\n    }\n\n    public File getTempDir() {\n        return tempDir;\n    }\n\n    public InputStream readFileFromRepository(String key) {\n        return readFileFromRepository(null, key);\n    }\n\n    InputStream readFileFromRepository(String dir, String key) {\n        if (repositoryDir == null)\n            return null;\n        File theDir = (dir == null) ? repositoryDir : new File(repositoryDir, dir);\n        File theFile = new File(theDir, key);\n        if (DEBUG)\n            System.out.println(\"readFileFromRepository: \" + theFile);\n        try {\n            return new FileInputStream(theFile);\n        } catch (FileNotFoundException e) {\n            return null;\n        }\n    }\n\n    public OutputStream storeFileInRepository(String key) throws IOException {\n        return storeFileInRepository(null, key);\n    }\n\n    OutputStream storeFileInRepository(String dir, String key) throws IOException {\n        if (repositoryDir == null)\n            return null;\n        File theDir = (dir == null) ? repositoryDir : new File(repositoryDir, dir);\n        theDir.mkdir();\n        File theFile = new File(theDir, key);\n        if (DEBUG)\n            System.out.println(\"storeFileInRepository: \" + theFile);\n        return new FileOutputStream(theFile);\n    }\n\n    public Class loadClassFromRepository(String className) throws ClassNotFoundException {\n        if (DEBUG)\n            System.out.println(\"loadClassFromRepository: \" + className);\n        try {\n            return Class.forName(className, true, repositoryClassLoader);\n        } catch (ClassFormatError e) {\n            File classFile = new File(classDir, className + \".class\");\n            classFile.delete();\n            err.println(e.toString());\n            throw new ClassNotFoundException(className + \" is malformed\");\n        } catch (VerifyError e) {\n            File classFile = new File(classDir, className + \".class\");\n            classFile.delete();\n            err.println(e.toString());\n            throw new ClassNotFoundException(className + \" does not verify\");\n        }\n    }\n\n    public OutputStream storeClassInRepository(String className) throws IOException {\n        if (classDir == null)\n            return null;\n        File theFile = new File(classDir, className + \".class\");\n        if (DEBUG)\n            System.out.println(\"storeClassInRepository: \" + theFile);\n        return new FileOutputStream(theFile);\n    }\n\n    public void deleteClassInRepository(String className) throws IOException {\n        if (classDir == null)\n            return;\n        File theFile = new File(classDir, className + \".class\");\n        if (DEBUG)\n            System.out.println(\"deleteClassInRepository: \" + theFile);\n        if (theFile.isFile() && !theFile.delete())\n            throw new IOException(\"Unable to delete file: \" + theFile);\n    }\n\n    public void reloadClasses() {\n        repositoryClassLoader = new java.net.URLClassLoader(classLoaderURLs);\n    }\n\n    public Object getObjectFromRepository(String key) throws IOException {\n        return getObjectFromRepository(null, key);\n    }\n\n    Object getObjectFromRepository(String dir, String key) throws IOException {\n        InputStream is = readFileFromRepository(dir, key);\n        if (is == null)\n            return null;\n        ObjectInputStream ois = new ObjectInputStream(is);\n        try {\n            return ois.readObject();\n        } catch (ClassNotFoundException e) {\n            if (DEBUG)\n                System.out.println(e);\n            return null;\n        } catch (ObjectStreamException e) {\n            if (DEBUG)\n                System.out.println(e);\n            return null;\n        } catch (ClassCastException e) {\n            if (DEBUG)\n                System.out.println(e);\n            return null;\n        } catch (EOFException e) {\n            if (DEBUG)\n                System.out.println(e);\n            return null;\n        } finally {\n            is.close();\n        }\n    }\n\n    public boolean putObjectIntoRepository(String key, Object obj) throws IOException {\n        return putObjectIntoRepository(null, key, obj);\n    }\n\n    boolean putObjectIntoRepository(String dir, String key, Object obj) throws IOException {\n        OutputStream os = storeFileInRepository(dir, key);\n        if (os == null)\n            return false;\n        ObjectOutputStream oos = new ObjectOutputStream(os);\n        try {\n            oos.writeObject(obj);\n            return true;\n        } finally {\n            oos.close();\n        }\n    }\n\n    /**\n     * Create a new producer.\n     *\n     * @param cat  the producer category (format, transform, source,\n     *             read, parse or process).\n     * @param type the producer type, use \"\" for default.\n     *\n     * @return  a new Producer\n     *          or <code>null</code> if it cannot be found.\n     */\n    Producer createProducer(String cat, String type) throws LagoonException {\n        Class cls = (Class) classDict.get(cat + \":\" + type);\n        if (cls == null)\n            try {\n                String fileName = \"/nu/staldal/lagoon/producer/\" + cat + ((type == \"\") ? \"\" : (\"-\" + type));\n                InputStream is = getClass().getResourceAsStream(fileName);\n                if (is == null)\n                    return null;\n                BufferedReader br = new BufferedReader(new InputStreamReader(is));\n                String className = br.readLine();\n                if (className == null)\n                    throw new LagoonException(\"Illegal Producer config file: \" + fileName);\n                String baseClassName = \"nu.staldal.lagoon.core.\" + Character.toUpperCase(cat.charAt(0)) + cat.substring(1);\n                try {\n                    cls = Class.forName(className);\n                    if (!Class.forName(baseClassName).isAssignableFrom(cls))\n                        throw new LagoonException(cat + \" class must derive from \" + baseClassName);\n                    classDict.put(cat + \":\" + type, cls);\n                } catch (ClassNotFoundException e) {\n                    throw new LagoonException(\"Producer class cannot be found:\" + e.getMessage());\n                }\n                Hashtable params = new Hashtable();\n                for (; ; ) {\n                    String s = br.readLine();\n                    if (s == null)\n                        break;\n                    int colon = s.indexOf(':');\n                    if (colon < 1)\n                        throw new LagoonException(\"Illegal producer config file: \" + fileName);\n                    String paramName = s.substring(0, colon).trim();\n                    String paramValue = s.substring(colon + 1).trim();\n                    params.put(paramName, paramValue);\n                }\n                br.close();\n                paramDict.put(cat + \":\" + type, params);\n            } catch (IOException e) {\n                throw new LagoonException(\"Unable to read producer config file: \" + e.toString());\n            }\n        try {\n            Producer prod = (Producer) cls.newInstance();\n            Hashtable params = (Hashtable) paramDict.get(cat + \":\" + type);\n            for (Enumeration e = params.keys(); e.hasMoreElements(); ) {\n                String name = (String) e.nextElement();\n                String value = (String) params.get(name);\n                prod.addParam(name, value);\n            }\n            return prod;\n        } catch (IllegalAccessException e) {\n            throw new LagoonException(\"Unable to instantiate producer class (illegal access): \" + e.getMessage());\n        } catch (InstantiationException e) {\n            throw new LagoonException(\"Unable to instantiate producer class (instantiation failed): \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Create a new file storage\n     *\n     * @param url  the URL\n     *\n     * @return  a new FileStorage\n     *          or <code>null</code> if it cannot be found.\n     */\n    FileStorage createFileStorage(String url) throws LagoonException {\n        Class cls = null;\n        String prefix;\n        int colon = url.indexOf(':');\n        if (colon < 1) {\n            prefix = \"\";\n            cls = (Class) filestorageDict.get(\"\");\n        } else {\n            prefix = url.substring(0, colon);\n            cls = (Class) filestorageDict.get(prefix);\n            if (cls == null) {\n                cls = (Class) filestorageDict.get(\"\");\n            }\n        }\n        if (cls == null)\n            try {\n                String fileName = \"/nu/staldal/lagoon/filestorage/FileStorage\" + ((prefix == \"\") ? \"\" : (\"-\" + prefix));\n                InputStream is = getClass().getResourceAsStream(fileName);\n                if (is == null) {\n                    fileName = \"/nu/staldal/lagoon/filestorage/FileStorage\";\n                    is = getClass().getResourceAsStream(fileName);\n                    prefix = \"\";\n                }\n                if (is == null)\n                    return null;\n                BufferedReader br = new BufferedReader(new InputStreamReader(is));\n                String className = br.readLine();\n                br.close();\n                if (className == null)\n                    throw new LagoonException(\"Illegal FileStorage config file: \" + fileName);\n                String baseClassName = \"nu.staldal.lagoon.core.FileStorage\";\n                try {\n                    cls = Class.forName(className);\n                    if (!Class.forName(baseClassName).isAssignableFrom(cls))\n                        throw new LagoonException(\"file storage class must derive from \" + baseClassName);\n                    filestorageDict.put(prefix, cls);\n                } catch (ClassNotFoundException e) {\n                    throw new LagoonException(\"FileStorage class cannot be found:\" + e.getMessage());\n                }\n            } catch (IOException e) {\n                throw new LagoonException(\"Unable to read producer config file: \" + e.toString());\n            }\n        try {\n            return (FileStorage) cls.newInstance();\n        } catch (IllegalAccessException e) {\n            throw new LagoonException(\"Unable to instantiate file storage class (illegal access): \" + e.getMessage());\n        } catch (InstantiationException e) {\n            throw new LagoonException(\"Unable to instantiate file storage class (instantiation failed): \" + e.getMessage());\n        }\n    }\n\n    public boolean canCheckFileHasBeenUpdated(String url) {\n        return !Utils.absoluteURL(url) || url.startsWith(\"part:\") || url.startsWith(\"file:\") || url.startsWith(\"res:\");\n    }\n\n    public File getSourceRootDir() {\n        return sourceRootDir;\n    }\n\n    public String getFileURLRelativeTo(String url, String base) {\n        if (Utils.absoluteURL(url) || Utils.pseudoAbsoluteURL(url)) {\n            return url;\n        } else {\n            if (!Utils.pseudoAbsoluteURL(base))\n                throw new IllegalArgumentException(\"base must be a pseudo-absolute URL\");\n            int slash = base.lastIndexOf('/');\n            String baseDir = base.substring(0, slash + 1);\n            return baseDir + url;\n        }\n    }\n\n    public String getProperty(String key) {\n        return sitemap.getProperty(key);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/core/LagoonProcessorTest5.java",
		"test_prompt": "// LagoonProcessorTest5.java\npackage nu.staldal.lagoon.core;\n\nimport java.io.*;\nimport java.util.*;\nimport nu.staldal.xtree.*;\nimport nu.staldal.util.Utils;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link LagoonProcessor}.\n* It contains ten unit test cases for the {@link LagoonProcessor#putObjectIntoRepository(String, Object)} method.\n*/\nclass LagoonProcessorTest5 {"
	},
	{
		"original_code": "// LagoonProcessor.java\n/*\n * Copyright (c) 2001-2004, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.lagoon.core;\n\nimport java.io.*;\nimport java.util.*;\nimport nu.staldal.xtree.*;\nimport nu.staldal.util.Utils;\n\n/**\n * The main worker class of the Lagoon core.\n *\n * Initialized with the sitemap,\n * a source dir and a target storage URL.\n * Then building the website may be done several times,\n * until destroy() is invoked.\n *\n * This class is not thread-safe. The methods must not\n * be invoked concurrently from different threads.\n */\npublic class LagoonProcessor implements LagoonContext {\n\n    private static final boolean DEBUG = false;\n\n    private final String targetURL;\n\n    private final FileStorage targetLocation;\n\n    private File repositoryDir;\n\n    private File tempDir;\n\n    private File classDir;\n\n    private File sourceRootDir;\n\n    private java.net.URL[] classLoaderURLs;\n\n    private ClassLoader repositoryClassLoader;\n\n    private final Hashtable classDict;\n\n    private final Hashtable paramDict;\n\n    private final Hashtable filestorageDict;\n\n    private Sitemap sitemap;\n\n    PrintWriter log;\n\n    PrintWriter err;\n\n    /**\n     * Constructs and initializes a LagoonProcessor.\n     *\n     * @param targetURL  where to put the generated files,\n     *                   must be an absolute URL or a local file path\n     * @param sitemapTree  the Sitemap as an XTree\n     * @param sourceDir  where the source files are\n     * @param password  password to access the target storage, or\n     *                  <code>null</code> if not nessesary.\n     * @param log  where to write progress messages.\n     * @param err  where to write error messages.\n     */\n    public LagoonProcessor(String targetURL, Element sitemapTree, File sourceDir, String password, PrintWriter log, PrintWriter err) throws IOException, LagoonException, AuthenticationException, AuthenticationMissingException {\n        this.targetURL = targetURL;\n        this.log = log;\n        this.err = err;\n        classDict = new Hashtable();\n        paramDict = new Hashtable();\n        filestorageDict = new Hashtable();\n        targetLocation = createFileStorage(targetURL);\n        if (targetLocation == null)\n            throw new LagoonException(\"Cannot find FileStorage for URL \" + targetURL);\n        if (targetLocation.needPassword() && (password == null)) {\n            throw new AuthenticationMissingException();\n        }\n        String absPath = sourceDir.getAbsolutePath();\n        this.sourceRootDir = new File(absPath);\n        if (!this.sourceRootDir.isDirectory())\n            throw new LagoonException(\"sourceDir must be an existing directory: \" + sourceDir);\n        sitemap = new Sitemap(this, sitemapTree, sourceRootDir);\n        File workDir = new File(System.getProperty(\"user.home\"), \".lagoon\");\n        if (!workDir.exists()) {\n            if (!workDir.mkdir())\n                throw new IOException(\"Unable to create directory: \" + workDir);\n        } else {\n            if (!workDir.isDirectory()) {\n                throw new IOException(\"Unable to create directory (a file with that name exists): \" + workDir);\n            }\n        }\n        if (sitemap.getSiteName() != null) {\n            repositoryDir = new File(workDir, sitemap.getSiteName());\n            if (!repositoryDir.exists()) {\n                if (!repositoryDir.mkdir())\n                    throw new IOException(\"Unable to create directory: \" + repositoryDir);\n            } else {\n                if (!repositoryDir.isDirectory()) {\n                    throw new IOException(\"Unable to create directory (a file with that name exists): \" + repositoryDir);\n                }\n            }\n        } else {\n            repositoryDir = null;\n        }\n        if (repositoryDir != null) {\n            tempDir = new File(repositoryDir, \"temp\");\n            classDir = new File(repositoryDir, \"classes\");\n        } else {\n            tempDir = new File(workDir, \"temp\");\n        }\n        if (!tempDir.exists()) {\n            if (!tempDir.mkdir())\n                throw new IOException(\"Unable to create directory: \" + tempDir);\n        } else {\n            if (!tempDir.isDirectory()) {\n                throw new IOException(\"Unable to create directory (a file with that name exists): \" + tempDir);\n            }\n        }\n        if (classDir == null) {\n            classDir = new File(tempDir, \"classes\");\n        }\n        if (!classDir.exists()) {\n            if (!classDir.mkdir())\n                throw new IOException(\"Unable to create directory: \" + classDir);\n        } else {\n            if (!classDir.isDirectory()) {\n                throw new IOException(\"Unable to create directory (a file with that name exists): \" + classDir);\n            }\n        }\n        classLoaderURLs = new java.net.URL[] { classDir.toURL() };\n        reloadClasses();\n        sitemap.init();\n        targetLocation.open(targetURL, this, password);\n    }\n\n    /**\n     * Get the Sitemap.\n     *\n     * @return the Sitemap.\n     */\n    Sitemap getSitemap() {\n        return sitemap;\n    }\n\n    /**\n     * Get the target location.\n     *\n     * @return the target location.\n     */\n    FileStorage getTargetLocation() {\n        return targetLocation;\n    }\n\n    /**\n     * Perform the building of the website.\n     * May be invoked multiple times.\n     * Synchronous, returns when the building is complete.\n     *\n     * @param force force a rebuild of all files, otherwise dependency\n     *        checking is used to check which files that needs rebuilding.\n     *\n     * @return true if successful, false if any non-fatal error occured\n     * @throws IOException  if any fatal error occur\n     */\n    public boolean build(boolean force) throws IOException {\n        boolean success = true;\n        for (Enumeration e = sitemap.getEntries(); e.hasMoreElements(); ) {\n            SitemapEntry ent = (SitemapEntry) e.nextElement();\n            ent.beforeBuild(force);\n        }\n        for (Enumeration e = sitemap.getEntries(); e.hasMoreElements(); ) {\n            SitemapEntry ent = (SitemapEntry) e.nextElement();\n            if (!ent.build(force))\n                success = false;\n        }\n        for (Enumeration e = sitemap.getEntries(); e.hasMoreElements(); ) {\n            SitemapEntry ent = (SitemapEntry) e.nextElement();\n            ent.afterBuild(force);\n        }\n        return success;\n    }\n\n    /**\n     * Dispose this object and release any resources it holds.\n     * This causes the FileStorage to be closed.\n     */\n    public void destroy() throws IOException {\n        sitemap.destroy();\n        targetLocation.close();\n        repositoryClassLoader = null;\n        if (repositoryDir == null) {\n            File[] classFiles = classDir.listFiles();\n            for (int i = 0; i < classFiles.length; i++) {\n                classFiles[i].delete();\n            }\n        }\n    }\n\n    public File getTempDir() {\n        return tempDir;\n    }\n\n    public InputStream readFileFromRepository(String key) {\n        return readFileFromRepository(null, key);\n    }\n\n    InputStream readFileFromRepository(String dir, String key) {\n        if (repositoryDir == null)\n            return null;\n        File theDir = (dir == null) ? repositoryDir : new File(repositoryDir, dir);\n        File theFile = new File(theDir, key);\n        if (DEBUG)\n            System.out.println(\"readFileFromRepository: \" + theFile);\n        try {\n            return new FileInputStream(theFile);\n        } catch (FileNotFoundException e) {\n            return null;\n        }\n    }\n\n    public OutputStream storeFileInRepository(String key) throws IOException {\n        return storeFileInRepository(null, key);\n    }\n\n    OutputStream storeFileInRepository(String dir, String key) throws IOException {\n        if (repositoryDir == null)\n            return null;\n        File theDir = (dir == null) ? repositoryDir : new File(repositoryDir, dir);\n        theDir.mkdir();\n        File theFile = new File(theDir, key);\n        if (DEBUG)\n            System.out.println(\"storeFileInRepository: \" + theFile);\n        return new FileOutputStream(theFile);\n    }\n\n    public Class loadClassFromRepository(String className) throws ClassNotFoundException {\n        if (DEBUG)\n            System.out.println(\"loadClassFromRepository: \" + className);\n        try {\n            return Class.forName(className, true, repositoryClassLoader);\n        } catch (ClassFormatError e) {\n            File classFile = new File(classDir, className + \".class\");\n            classFile.delete();\n            err.println(e.toString());\n            throw new ClassNotFoundException(className + \" is malformed\");\n        } catch (VerifyError e) {\n            File classFile = new File(classDir, className + \".class\");\n            classFile.delete();\n            err.println(e.toString());\n            throw new ClassNotFoundException(className + \" does not verify\");\n        }\n    }\n\n    public OutputStream storeClassInRepository(String className) throws IOException {\n        if (classDir == null)\n            return null;\n        File theFile = new File(classDir, className + \".class\");\n        if (DEBUG)\n            System.out.println(\"storeClassInRepository: \" + theFile);\n        return new FileOutputStream(theFile);\n    }\n\n    public void deleteClassInRepository(String className) throws IOException {\n        if (classDir == null)\n            return;\n        File theFile = new File(classDir, className + \".class\");\n        if (DEBUG)\n            System.out.println(\"deleteClassInRepository: \" + theFile);\n        if (theFile.isFile() && !theFile.delete())\n            throw new IOException(\"Unable to delete file: \" + theFile);\n    }\n\n    public void reloadClasses() {\n        repositoryClassLoader = new java.net.URLClassLoader(classLoaderURLs);\n    }\n\n    public Object getObjectFromRepository(String key) throws IOException {\n        return getObjectFromRepository(null, key);\n    }\n\n    Object getObjectFromRepository(String dir, String key) throws IOException {\n        InputStream is = readFileFromRepository(dir, key);\n        if (is == null)\n            return null;\n        ObjectInputStream ois = new ObjectInputStream(is);\n        try {\n            return ois.readObject();\n        } catch (ClassNotFoundException e) {\n            if (DEBUG)\n                System.out.println(e);\n            return null;\n        } catch (ObjectStreamException e) {\n            if (DEBUG)\n                System.out.println(e);\n            return null;\n        } catch (ClassCastException e) {\n            if (DEBUG)\n                System.out.println(e);\n            return null;\n        } catch (EOFException e) {\n            if (DEBUG)\n                System.out.println(e);\n            return null;\n        } finally {\n            is.close();\n        }\n    }\n\n    public boolean putObjectIntoRepository(String key, Object obj) throws IOException {\n        return putObjectIntoRepository(null, key, obj);\n    }\n\n    boolean putObjectIntoRepository(String dir, String key, Object obj) throws IOException {\n        OutputStream os = storeFileInRepository(dir, key);\n        if (os == null)\n            return false;\n        ObjectOutputStream oos = new ObjectOutputStream(os);\n        try {\n            oos.writeObject(obj);\n            return true;\n        } finally {\n            oos.close();\n        }\n    }\n\n    /**\n     * Create a new producer.\n     *\n     * @param cat  the producer category (format, transform, source,\n     *             read, parse or process).\n     * @param type the producer type, use \"\" for default.\n     *\n     * @return  a new Producer\n     *          or <code>null</code> if it cannot be found.\n     */\n    Producer createProducer(String cat, String type) throws LagoonException {\n        Class cls = (Class) classDict.get(cat + \":\" + type);\n        if (cls == null)\n            try {\n                String fileName = \"/nu/staldal/lagoon/producer/\" + cat + ((type == \"\") ? \"\" : (\"-\" + type));\n                InputStream is = getClass().getResourceAsStream(fileName);\n                if (is == null)\n                    return null;\n                BufferedReader br = new BufferedReader(new InputStreamReader(is));\n                String className = br.readLine();\n                if (className == null)\n                    throw new LagoonException(\"Illegal Producer config file: \" + fileName);\n                String baseClassName = \"nu.staldal.lagoon.core.\" + Character.toUpperCase(cat.charAt(0)) + cat.substring(1);\n                try {\n                    cls = Class.forName(className);\n                    if (!Class.forName(baseClassName).isAssignableFrom(cls))\n                        throw new LagoonException(cat + \" class must derive from \" + baseClassName);\n                    classDict.put(cat + \":\" + type, cls);\n                } catch (ClassNotFoundException e) {\n                    throw new LagoonException(\"Producer class cannot be found:\" + e.getMessage());\n                }\n                Hashtable params = new Hashtable();\n                for (; ; ) {\n                    String s = br.readLine();\n                    if (s == null)\n                        break;\n                    int colon = s.indexOf(':');\n                    if (colon < 1)\n                        throw new LagoonException(\"Illegal producer config file: \" + fileName);\n                    String paramName = s.substring(0, colon).trim();\n                    String paramValue = s.substring(colon + 1).trim();\n                    params.put(paramName, paramValue);\n                }\n                br.close();\n                paramDict.put(cat + \":\" + type, params);\n            } catch (IOException e) {\n                throw new LagoonException(\"Unable to read producer config file: \" + e.toString());\n            }\n        try {\n            Producer prod = (Producer) cls.newInstance();\n            Hashtable params = (Hashtable) paramDict.get(cat + \":\" + type);\n            for (Enumeration e = params.keys(); e.hasMoreElements(); ) {\n                String name = (String) e.nextElement();\n                String value = (String) params.get(name);\n                prod.addParam(name, value);\n            }\n            return prod;\n        } catch (IllegalAccessException e) {\n            throw new LagoonException(\"Unable to instantiate producer class (illegal access): \" + e.getMessage());\n        } catch (InstantiationException e) {\n            throw new LagoonException(\"Unable to instantiate producer class (instantiation failed): \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Create a new file storage\n     *\n     * @param url  the URL\n     *\n     * @return  a new FileStorage\n     *          or <code>null</code> if it cannot be found.\n     */\n    FileStorage createFileStorage(String url) throws LagoonException {\n        Class cls = null;\n        String prefix;\n        int colon = url.indexOf(':');\n        if (colon < 1) {\n            prefix = \"\";\n            cls = (Class) filestorageDict.get(\"\");\n        } else {\n            prefix = url.substring(0, colon);\n            cls = (Class) filestorageDict.get(prefix);\n            if (cls == null) {\n                cls = (Class) filestorageDict.get(\"\");\n            }\n        }\n        if (cls == null)\n            try {\n                String fileName = \"/nu/staldal/lagoon/filestorage/FileStorage\" + ((prefix == \"\") ? \"\" : (\"-\" + prefix));\n                InputStream is = getClass().getResourceAsStream(fileName);\n                if (is == null) {\n                    fileName = \"/nu/staldal/lagoon/filestorage/FileStorage\";\n                    is = getClass().getResourceAsStream(fileName);\n                    prefix = \"\";\n                }\n                if (is == null)\n                    return null;\n                BufferedReader br = new BufferedReader(new InputStreamReader(is));\n                String className = br.readLine();\n                br.close();\n                if (className == null)\n                    throw new LagoonException(\"Illegal FileStorage config file: \" + fileName);\n                String baseClassName = \"nu.staldal.lagoon.core.FileStorage\";\n                try {\n                    cls = Class.forName(className);\n                    if (!Class.forName(baseClassName).isAssignableFrom(cls))\n                        throw new LagoonException(\"file storage class must derive from \" + baseClassName);\n                    filestorageDict.put(prefix, cls);\n                } catch (ClassNotFoundException e) {\n                    throw new LagoonException(\"FileStorage class cannot be found:\" + e.getMessage());\n                }\n            } catch (IOException e) {\n                throw new LagoonException(\"Unable to read producer config file: \" + e.toString());\n            }\n        try {\n            return (FileStorage) cls.newInstance();\n        } catch (IllegalAccessException e) {\n            throw new LagoonException(\"Unable to instantiate file storage class (illegal access): \" + e.getMessage());\n        } catch (InstantiationException e) {\n            throw new LagoonException(\"Unable to instantiate file storage class (instantiation failed): \" + e.getMessage());\n        }\n    }\n\n    public boolean canCheckFileHasBeenUpdated(String url) {\n        return !Utils.absoluteURL(url) || url.startsWith(\"part:\") || url.startsWith(\"file:\") || url.startsWith(\"res:\");\n    }\n\n    public File getSourceRootDir() {\n        return sourceRootDir;\n    }\n\n    public String getFileURLRelativeTo(String url, String base) {\n        if (Utils.absoluteURL(url) || Utils.pseudoAbsoluteURL(url)) {\n            return url;\n        } else {\n            if (!Utils.pseudoAbsoluteURL(base))\n                throw new IllegalArgumentException(\"base must be a pseudo-absolute URL\");\n            int slash = base.lastIndexOf('/');\n            String baseDir = base.substring(0, slash + 1);\n            return baseDir + url;\n        }\n    }\n\n    public String getProperty(String key) {\n        return sitemap.getProperty(key);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/core/LagoonProcessorTest6.java",
		"test_prompt": "// LagoonProcessorTest6.java\npackage nu.staldal.lagoon.core;\n\nimport java.io.*;\nimport java.util.*;\nimport nu.staldal.xtree.*;\nimport nu.staldal.util.Utils;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link LagoonProcessor}.\n* It contains ten unit test cases for the {@link LagoonProcessor#canCheckFileHasBeenUpdated(String)} method.\n*/\nclass LagoonProcessorTest6 {"
	},
	{
		"original_code": "// EntryWithSource.java\n/*\n * Copyright (c) 2001-2003, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.lagoon.core;\n\nimport java.io.*;\nimport java.util.*;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport javax.xml.parsers.*;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.stream.StreamSource;\nimport javax.xml.transform.sax.SAXSource;\nimport org.xml.sax.*;\nimport nu.staldal.xmlutil.*;\nimport nu.staldal.lagoon.util.*;\nimport nu.staldal.util.Utils;\n\n/**\n */\nabstract class EntryWithSource implements SourceManager, SourceManagerProvider {\n\n    private static final boolean DEBUG = false;\n\n    protected final LagoonProcessor processor;\n\n    protected final Sitemap sitemap;\n\n    protected final File sourceRootDir;\n\n    protected final String sourceURL;\n\n    protected final SAXParserFactory spf;\n\n    /**\n     *  Constructor.\n     *\n     *  @param processor the LagoonProcessor.\n     *  @param sitemap  the Sitemap.\n     *  @param sourceURL  the file to use, may contain wildcard in filename,\n     *                    must absolute or pseudo-absolute,\n     * \t\t\t\t\t may be <code>null</code>.\n     *  @param sourceRootDir  absolute path to the source directory\n     */\n    public EntryWithSource(LagoonProcessor processor, Sitemap sitemap, String sourceURL, File sourceRootDir) throws LagoonException {\n        this.processor = processor;\n        this.sitemap = sitemap;\n        this.sourceRootDir = sourceRootDir;\n        if (!Utils.absoluteURL(sourceURL) && !Utils.pseudoAbsoluteURL(sourceURL)) {\n            throw new LagoonException(\"source must be absolute or pseudo-absolute\");\n        }\n        this.sourceURL = sourceURL;\n        try {\n            spf = SAXParserFactory.newInstance();\n            spf.setNamespaceAware(true);\n            spf.setValidating(false);\n            spf.setFeature(\"http://xml.org/sax/features/namespaces\", true);\n            spf.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", false);\n            spf.setFeature(\"http://xml.org/sax/features/validation\", false);\n        } catch (ParserConfigurationException e) {\n            throw new Error(\"Unable to configure XML parser\");\n        } catch (SAXException e) {\n            throw new Error(\"Unable to configure XML parser\");\n        }\n    }\n\n    // SourceManager implemenation\n    public String getSourceURL() throws FileNotFoundException {\n        if (sourceURL == null)\n            throw new FileNotFoundException(\"no source file specified\");\n        return sourceURL;\n    }\n\n    public InputStream openFile(String url) throws FileNotFoundException, IOException {\n        File file = getFile(url);\n        if (file == null) {\n            if (url.startsWith(\"res:\")) {\n                return getClass().getResourceAsStream(url.substring(4));\n            } else {\n                URL theUrl = new URL(url);\n                URLConnection uc = theUrl.openConnection();\n                return uc.getInputStream();\n            }\n        } else {\n            return new FileInputStream(file);\n        }\n    }\n\n    public File getFile(String url) throws FileNotFoundException {\n        if (Utils.absoluteURL(url)) {\n            if (url.startsWith(\"file:\")) {\n                return new File(url.substring(5));\n            } else {\n                return null;\n            }\n        } else {\n            return new File(sourceRootDir, getFileURL(url).substring(1).replace('/', File.separatorChar));\n        }\n    }\n\n    public Source getFileAsJAXPSource(final String url, final Target target) throws FileNotFoundException {\n        File file = getFile(url);\n        if (file == null) {\n            if (Utils.absoluteURL(url) && url.startsWith(\"part:\")) {\n                final PartEntry pe = sitemap.lookupPart(url.substring(5));\n                if (pe == null)\n                    throw new FileNotFoundException(\"Part \" + url + \" not found\");\n                return new SAXSource(new XMLReaderImpl() {\n\n                    public void parse(InputSource is) throws SAXException, IOException {\n                        pe.getXMLProducer().start(contentHandler, target);\n                    }\n                }, new InputSource());\n            } else if (Utils.absoluteURL(url) && url.startsWith(\"res:\")) {\n                return new StreamSource(getClass().getResourceAsStream(url.substring(4)));\n            } else {\n                return new StreamSource(getFileURL(url));\n            }\n        } else\n            return new StreamSource(file);\n    }\n\n    public void getFileAsSAX(String url, ContentHandler ch, Target target) throws IOException, SAXException {\n        if (Utils.absoluteURL(url) && url.startsWith(\"part:\")) {\n            PartEntry pe = sitemap.lookupPart(url.substring(5));\n            if (pe == null)\n                throw new FileNotFoundException(\"Part \" + url + \" not found\");\n            pe.getXMLProducer().start(ch, target);\n            return;\n        }\n        InputSource is;\n        InputStream istream = null;\n        if (Utils.absoluteURL(url) && url.startsWith(\"res:\")) {\n            is = new InputSource(getClass().getResourceAsStream(url.substring(4)));\n        } else {\n            is = new InputSource(getFileURL(url));\n            File file = getFile(url);\n            if (file != null) {\n                istream = new FileInputStream(file);\n                is.setByteStream(istream);\n            }\n        }\n        try {\n            XMLReader parser = spf.newSAXParser().getXMLReader();\n            parser.setContentHandler(ch);\n            parser.setEntityResolver(new EntityResolver() {\n\n                public InputSource resolveEntity(String publicId, String systemId) throws SAXException, IOException {\n                    InputSource is = new InputSource(getFileURL(systemId));\n                    File fil = getFile(systemId);\n                    if (fil != null) {\n                        InputStream istr = new FileInputStream(fil);\n                        is.setByteStream(istr);\n                    }\n                    return is;\n                }\n            });\n            parser.parse(is);\n        } catch (ParserConfigurationException e) {\n            throw new SAXException(e);\n        } finally {\n            if (istream != null)\n                istream.close();\n        }\n    }\n\n    public String getFileURL(String url) throws FileNotFoundException {\n        return processor.getFileURLRelativeTo(url, getSourceURL());\n    }\n\n    public boolean fileHasBeenUpdated(String url, long when) throws FileNotFoundException, IOException, LagoonException {\n        File file = getFile(url);\n        if (file == null) {\n            if (Utils.absoluteURL(url) && url.startsWith(\"part:\")) {\n                PartEntry pe = sitemap.lookupPart(url.substring(5));\n                if (pe == null)\n                    throw new FileNotFoundException(\"Part \" + url + \" not found\");\n                return pe.getXMLProducer().hasBeenUpdated(when);\n            } else if (Utils.absoluteURL(url) && url.startsWith(\"res:\")) {\n                // cannot check\n                return false;\n            } else\n                // cannot check\n                return true;\n        }\n        long sourceDate = file.lastModified();\n        return (// source exsist\n        (sourceDate > 0) && // will also build if (when == -1) (i.e. unknown)\n        (sourceDate > when));\n    }\n\n    // SourceManagerProvider implementation\n    public SourceManager getSourceManager() {\n        return this;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/core/EntryWithSourceTest0.java",
		"test_prompt": "// EntryWithSourceTest0.java\npackage nu.staldal.lagoon.core;\n\nimport java.io.*;\nimport java.util.*;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport javax.xml.parsers.*;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.stream.StreamSource;\nimport javax.xml.transform.sax.SAXSource;\nimport org.xml.sax.*;\nimport nu.staldal.xmlutil.*;\nimport nu.staldal.lagoon.util.*;\nimport nu.staldal.util.Utils;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EntryWithSource}.\n* It contains ten unit test cases for the {@link EntryWithSource#openFile(String)} method.\n*/\nclass EntryWithSourceTest0 {"
	},
	{
		"original_code": "// EntryWithSource.java\n/*\n * Copyright (c) 2001-2003, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.lagoon.core;\n\nimport java.io.*;\nimport java.util.*;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport javax.xml.parsers.*;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.stream.StreamSource;\nimport javax.xml.transform.sax.SAXSource;\nimport org.xml.sax.*;\nimport nu.staldal.xmlutil.*;\nimport nu.staldal.lagoon.util.*;\nimport nu.staldal.util.Utils;\n\n/**\n */\nabstract class EntryWithSource implements SourceManager, SourceManagerProvider {\n\n    private static final boolean DEBUG = false;\n\n    protected final LagoonProcessor processor;\n\n    protected final Sitemap sitemap;\n\n    protected final File sourceRootDir;\n\n    protected final String sourceURL;\n\n    protected final SAXParserFactory spf;\n\n    /**\n     *  Constructor.\n     *\n     *  @param processor the LagoonProcessor.\n     *  @param sitemap  the Sitemap.\n     *  @param sourceURL  the file to use, may contain wildcard in filename,\n     *                    must absolute or pseudo-absolute,\n     * \t\t\t\t\t may be <code>null</code>.\n     *  @param sourceRootDir  absolute path to the source directory\n     */\n    public EntryWithSource(LagoonProcessor processor, Sitemap sitemap, String sourceURL, File sourceRootDir) throws LagoonException {\n        this.processor = processor;\n        this.sitemap = sitemap;\n        this.sourceRootDir = sourceRootDir;\n        if (!Utils.absoluteURL(sourceURL) && !Utils.pseudoAbsoluteURL(sourceURL)) {\n            throw new LagoonException(\"source must be absolute or pseudo-absolute\");\n        }\n        this.sourceURL = sourceURL;\n        try {\n            spf = SAXParserFactory.newInstance();\n            spf.setNamespaceAware(true);\n            spf.setValidating(false);\n            spf.setFeature(\"http://xml.org/sax/features/namespaces\", true);\n            spf.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", false);\n            spf.setFeature(\"http://xml.org/sax/features/validation\", false);\n        } catch (ParserConfigurationException e) {\n            throw new Error(\"Unable to configure XML parser\");\n        } catch (SAXException e) {\n            throw new Error(\"Unable to configure XML parser\");\n        }\n    }\n\n    // SourceManager implemenation\n    public String getSourceURL() throws FileNotFoundException {\n        if (sourceURL == null)\n            throw new FileNotFoundException(\"no source file specified\");\n        return sourceURL;\n    }\n\n    public InputStream openFile(String url) throws FileNotFoundException, IOException {\n        File file = getFile(url);\n        if (file == null) {\n            if (url.startsWith(\"res:\")) {\n                return getClass().getResourceAsStream(url.substring(4));\n            } else {\n                URL theUrl = new URL(url);\n                URLConnection uc = theUrl.openConnection();\n                return uc.getInputStream();\n            }\n        } else {\n            return new FileInputStream(file);\n        }\n    }\n\n    public File getFile(String url) throws FileNotFoundException {\n        if (Utils.absoluteURL(url)) {\n            if (url.startsWith(\"file:\")) {\n                return new File(url.substring(5));\n            } else {\n                return null;\n            }\n        } else {\n            return new File(sourceRootDir, getFileURL(url).substring(1).replace('/', File.separatorChar));\n        }\n    }\n\n    public Source getFileAsJAXPSource(final String url, final Target target) throws FileNotFoundException {\n        File file = getFile(url);\n        if (file == null) {\n            if (Utils.absoluteURL(url) && url.startsWith(\"part:\")) {\n                final PartEntry pe = sitemap.lookupPart(url.substring(5));\n                if (pe == null)\n                    throw new FileNotFoundException(\"Part \" + url + \" not found\");\n                return new SAXSource(new XMLReaderImpl() {\n\n                    public void parse(InputSource is) throws SAXException, IOException {\n                        pe.getXMLProducer().start(contentHandler, target);\n                    }\n                }, new InputSource());\n            } else if (Utils.absoluteURL(url) && url.startsWith(\"res:\")) {\n                return new StreamSource(getClass().getResourceAsStream(url.substring(4)));\n            } else {\n                return new StreamSource(getFileURL(url));\n            }\n        } else\n            return new StreamSource(file);\n    }\n\n    public void getFileAsSAX(String url, ContentHandler ch, Target target) throws IOException, SAXException {\n        if (Utils.absoluteURL(url) && url.startsWith(\"part:\")) {\n            PartEntry pe = sitemap.lookupPart(url.substring(5));\n            if (pe == null)\n                throw new FileNotFoundException(\"Part \" + url + \" not found\");\n            pe.getXMLProducer().start(ch, target);\n            return;\n        }\n        InputSource is;\n        InputStream istream = null;\n        if (Utils.absoluteURL(url) && url.startsWith(\"res:\")) {\n            is = new InputSource(getClass().getResourceAsStream(url.substring(4)));\n        } else {\n            is = new InputSource(getFileURL(url));\n            File file = getFile(url);\n            if (file != null) {\n                istream = new FileInputStream(file);\n                is.setByteStream(istream);\n            }\n        }\n        try {\n            XMLReader parser = spf.newSAXParser().getXMLReader();\n            parser.setContentHandler(ch);\n            parser.setEntityResolver(new EntityResolver() {\n\n                public InputSource resolveEntity(String publicId, String systemId) throws SAXException, IOException {\n                    InputSource is = new InputSource(getFileURL(systemId));\n                    File fil = getFile(systemId);\n                    if (fil != null) {\n                        InputStream istr = new FileInputStream(fil);\n                        is.setByteStream(istr);\n                    }\n                    return is;\n                }\n            });\n            parser.parse(is);\n        } catch (ParserConfigurationException e) {\n            throw new SAXException(e);\n        } finally {\n            if (istream != null)\n                istream.close();\n        }\n    }\n\n    public String getFileURL(String url) throws FileNotFoundException {\n        return processor.getFileURLRelativeTo(url, getSourceURL());\n    }\n\n    public boolean fileHasBeenUpdated(String url, long when) throws FileNotFoundException, IOException, LagoonException {\n        File file = getFile(url);\n        if (file == null) {\n            if (Utils.absoluteURL(url) && url.startsWith(\"part:\")) {\n                PartEntry pe = sitemap.lookupPart(url.substring(5));\n                if (pe == null)\n                    throw new FileNotFoundException(\"Part \" + url + \" not found\");\n                return pe.getXMLProducer().hasBeenUpdated(when);\n            } else if (Utils.absoluteURL(url) && url.startsWith(\"res:\")) {\n                // cannot check\n                return false;\n            } else\n                // cannot check\n                return true;\n        }\n        long sourceDate = file.lastModified();\n        return (// source exsist\n        (sourceDate > 0) && // will also build if (when == -1) (i.e. unknown)\n        (sourceDate > when));\n    }\n\n    // SourceManagerProvider implementation\n    public SourceManager getSourceManager() {\n        return this;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/core/EntryWithSourceTest1.java",
		"test_prompt": "// EntryWithSourceTest1.java\npackage nu.staldal.lagoon.core;\n\nimport java.io.*;\nimport java.util.*;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport javax.xml.parsers.*;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.stream.StreamSource;\nimport javax.xml.transform.sax.SAXSource;\nimport org.xml.sax.*;\nimport nu.staldal.xmlutil.*;\nimport nu.staldal.lagoon.util.*;\nimport nu.staldal.util.Utils;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EntryWithSource}.\n* It contains ten unit test cases for the {@link EntryWithSource#fileHasBeenUpdated(String, long)} method.\n*/\nclass EntryWithSourceTest1 {"
	},
	{
		"original_code": "// TemplateProcessor.java\n/*\n * Copyright (c) 2001, Mikael Stï¿½ldal\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without \n * modification, are permitted provided that the following conditions \n * are met:\n * \n * 1. Redistributions of source code must retain the above copyright \n * notice, this list of conditions and the following disclaimer.\n * \n * 2. Redistributions in binary form must reproduce the above copyright \n * notice, this list of conditions and the following disclaimer in the \n * documentation and/or other materials provided with the distribution.\n * \n * 3. Neither the name of the author nor the names of its contributors \n * may be used to endorse or promote products derived from this software \n * without specific prior written permission. \n * \n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR \n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR \n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, \n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, \n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR \n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY \n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n * \n * \n * Note: This is known as \"the modified BSD license\". It's an approved \n * Open Source and Free Software license, see \n * http://www.opensource.org/licenses/ \n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.lagoon.util;\n\npublic final class TemplateProcessor {\n\n    private static void throwIllegalTemplate(String template) throws TemplateException {\n        if (template.length() > 64)\n            throw new TemplateException();\n        else\n            throw new TemplateException(template);\n    }\n\n    public static String processTemplate(char left, char right, char quot1, char quot2, String template, ExpressionEvaluator evaluator) throws TemplateException {\n        if (evaluator == null)\n            throw new NullPointerException(\"evaluator is null\");\n        int len = (template.length() > 128) ? template.length() + 64 : template.length() * 2;\n        StringBuffer sb = new StringBuffer(len);\n        StringBuffer expr = null;\n        char quote = 0;\n        char brace = 0;\n        for (int i = 0; i < template.length(); i++) {\n            char c = template.charAt(i);\n            if (expr == null) {\n                if (c == left) {\n                    if (brace == 0) {\n                        brace = left;\n                    } else if (brace == left) {\n                        sb.append(left);\n                        brace = 0;\n                    } else if (brace == right) {\n                        throwIllegalTemplate(template);\n                    }\n                } else if (c == right) {\n                    if (brace == 0) {\n                        brace = right;\n                    } else if (brace == right) {\n                        sb.append(right);\n                        brace = 0;\n                    } else if (brace == left) {\n                        throwIllegalTemplate(template);\n                    }\n                } else {\n                    if (brace == left) {\n                        expr = new StringBuffer();\n                        expr.append(c);\n                        brace = 0;\n                    } else if (brace == right) {\n                        throwIllegalTemplate(template);\n                    } else {\n                        sb.append(c);\n                    }\n                }\n            } else // expr != null\n            {\n                if (c == quot1 || c == quot2) {\n                    expr.append(c);\n                    if (quote == 0) {\n                        quote = c;\n                    } else if (quote == c) {\n                        quote = 0;\n                    }\n                } else if (c == right) {\n                    if (quote == 0) {\n                        String exp = expr.toString();\n                        String res;\n                        try {\n                            res = evaluator.eval(exp);\n                        } catch (Exception e) {\n                            throw new TemplateException(e);\n                        }\n                        sb.append(res);\n                        expr = null;\n                    } else {\n                        expr.append(c);\n                    }\n                } else {\n                    expr.append(c);\n                }\n            }\n        }\n        if (brace != 0) {\n            throwIllegalTemplate(template);\n        }\n        return sb.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/util/TemplateProcessorTest.java",
		"test_prompt": "// TemplateProcessorTest.java\npackage nu.staldal.lagoon.util;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TemplateProcessor}.\n* It contains ten unit test cases for the {@link TemplateProcessor#processTemplate(char, char, char, char, String, ExpressionEvaluator)} method.\n*/\nclass TemplateProcessorTest {"
	},
	{
		"original_code": "// Wildcard.java\n/*\n * Copyright (c) 2001, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.lagoon.util;\n\nimport java.util.*;\n\n/**\n * Wildcard processing methods. All methods in this class are static.\n *\n * A wildcard pattern consists of one or more simple patterns, separated by ';'.\n * A simple pattern may contain one '*' which match any string\n * (including the empty string).\n */\npublic final class Wildcard {\n\n    /**\n     * Private default constructor to prevent instantiation.\n     */\n    private Wildcard() {\n    }\n\n    /**\n     * Check if a wildcard pattern can possibly match more than one filename.\n     *\n     * @param pattern  the wildcard pattern to test\n     */\n    public static boolean isWildcard(String pattern) {\n        return (pattern.indexOf('*') >= 0) || (pattern.indexOf(';') >= 0);\n    }\n\n    /**\n     * Attempt to match a filename matches to wildcard pattern.\n     *\n     * @param pattern   the wildcard pattern\n     * @param filename  the filename\n     *\n     * @return the string substituted into the pattern,\n     *         or null if no match could be made\n     */\n    public static String matchWildcard(String pattern, String filename) {\n        StringTokenizer st = new StringTokenizer(pattern, \";\");\n        while (st.hasMoreTokens()) {\n            String pat = st.nextToken();\n            int star = pat.indexOf('*');\n            if (star < 0) {\n                if (pat.equals(filename))\n                    return \"\";\n            } else {\n                if (!filename.startsWith(pat.substring(0, star)))\n                    continue;\n                if (!filename.endsWith(pat.substring(star + 1)))\n                    continue;\n                return filename.substring(star, star + filename.length() - pat.length() + 1);\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Instantiate a wildcard pattern to a filename.\n     *\n     * @param pattern   the wildcard pattern\n     * @param part      the string to substitue into the pattern\n     *                  (returned from matchWildcard)\n     *\n     * @return  the filename\n     *\n     * @see #matchWildcard\n     */\n    public static String instantiateWildcard(String pattern, String part) {\n        int star = pattern.indexOf('*');\n        if (star < 0)\n            return pattern;\n        return pattern.substring(0, star) + part + pattern.substring(star + 1);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/util/WildcardTest0.java",
		"test_prompt": "// WildcardTest0.java\npackage nu.staldal.lagoon.util;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Wildcard}.\n* It contains ten unit test cases for the {@link Wildcard#isWildcard(String)} method.\n*/\nclass WildcardTest0 {"
	},
	{
		"original_code": "// Wildcard.java\n/*\n * Copyright (c) 2001, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.lagoon.util;\n\nimport java.util.*;\n\n/**\n * Wildcard processing methods. All methods in this class are static.\n *\n * A wildcard pattern consists of one or more simple patterns, separated by ';'.\n * A simple pattern may contain one '*' which match any string\n * (including the empty string).\n */\npublic final class Wildcard {\n\n    /**\n     * Private default constructor to prevent instantiation.\n     */\n    private Wildcard() {\n    }\n\n    /**\n     * Check if a wildcard pattern can possibly match more than one filename.\n     *\n     * @param pattern  the wildcard pattern to test\n     */\n    public static boolean isWildcard(String pattern) {\n        return (pattern.indexOf('*') >= 0) || (pattern.indexOf(';') >= 0);\n    }\n\n    /**\n     * Attempt to match a filename matches to wildcard pattern.\n     *\n     * @param pattern   the wildcard pattern\n     * @param filename  the filename\n     *\n     * @return the string substituted into the pattern,\n     *         or null if no match could be made\n     */\n    public static String matchWildcard(String pattern, String filename) {\n        StringTokenizer st = new StringTokenizer(pattern, \";\");\n        while (st.hasMoreTokens()) {\n            String pat = st.nextToken();\n            int star = pat.indexOf('*');\n            if (star < 0) {\n                if (pat.equals(filename))\n                    return \"\";\n            } else {\n                if (!filename.startsWith(pat.substring(0, star)))\n                    continue;\n                if (!filename.endsWith(pat.substring(star + 1)))\n                    continue;\n                return filename.substring(star, star + filename.length() - pat.length() + 1);\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Instantiate a wildcard pattern to a filename.\n     *\n     * @param pattern   the wildcard pattern\n     * @param part      the string to substitue into the pattern\n     *                  (returned from matchWildcard)\n     *\n     * @return  the filename\n     *\n     * @see #matchWildcard\n     */\n    public static String instantiateWildcard(String pattern, String part) {\n        int star = pattern.indexOf('*');\n        if (star < 0)\n            return pattern;\n        return pattern.substring(0, star) + part + pattern.substring(star + 1);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/util/WildcardTest1.java",
		"test_prompt": "// WildcardTest1.java\npackage nu.staldal.lagoon.util;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Wildcard}.\n* It contains ten unit test cases for the {@link Wildcard#matchWildcard(String, String)} method.\n*/\nclass WildcardTest1 {"
	},
	{
		"original_code": "// Wildcard.java\n/*\n * Copyright (c) 2001, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.lagoon.util;\n\nimport java.util.*;\n\n/**\n * Wildcard processing methods. All methods in this class are static.\n *\n * A wildcard pattern consists of one or more simple patterns, separated by ';'.\n * A simple pattern may contain one '*' which match any string\n * (including the empty string).\n */\npublic final class Wildcard {\n\n    /**\n     * Private default constructor to prevent instantiation.\n     */\n    private Wildcard() {\n    }\n\n    /**\n     * Check if a wildcard pattern can possibly match more than one filename.\n     *\n     * @param pattern  the wildcard pattern to test\n     */\n    public static boolean isWildcard(String pattern) {\n        return (pattern.indexOf('*') >= 0) || (pattern.indexOf(';') >= 0);\n    }\n\n    /**\n     * Attempt to match a filename matches to wildcard pattern.\n     *\n     * @param pattern   the wildcard pattern\n     * @param filename  the filename\n     *\n     * @return the string substituted into the pattern,\n     *         or null if no match could be made\n     */\n    public static String matchWildcard(String pattern, String filename) {\n        StringTokenizer st = new StringTokenizer(pattern, \";\");\n        while (st.hasMoreTokens()) {\n            String pat = st.nextToken();\n            int star = pat.indexOf('*');\n            if (star < 0) {\n                if (pat.equals(filename))\n                    return \"\";\n            } else {\n                if (!filename.startsWith(pat.substring(0, star)))\n                    continue;\n                if (!filename.endsWith(pat.substring(star + 1)))\n                    continue;\n                return filename.substring(star, star + filename.length() - pat.length() + 1);\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Instantiate a wildcard pattern to a filename.\n     *\n     * @param pattern   the wildcard pattern\n     * @param part      the string to substitue into the pattern\n     *                  (returned from matchWildcard)\n     *\n     * @return  the filename\n     *\n     * @see #matchWildcard\n     */\n    public static String instantiateWildcard(String pattern, String part) {\n        int star = pattern.indexOf('*');\n        if (star < 0)\n            return pattern;\n        return pattern.substring(0, star) + part + pattern.substring(star + 1);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/util/WildcardTest2.java",
		"test_prompt": "// WildcardTest2.java\npackage nu.staldal.lagoon.util;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Wildcard}.\n* It contains ten unit test cases for the {@link Wildcard#instantiateWildcard(String, String)} method.\n*/\nclass WildcardTest2 {"
	},
	{
		"original_code": "// FTPFileStorage.java\n/*\n * Copyright (c) 2001-2002, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.lagoon.filestorage;\n\nimport java.io.*;\nimport java.net.*;\nimport nu.staldal.lagoon.core.*;\nimport nu.staldal.ftp.*;\n\n/**\n * A FileStorage which transfers files to a remote site using FTP.\n *\n * <strong>Note:</strong> This class will transmit password in clear text over\n * the network.\n */\npublic class FTPFileStorage extends RemoteFileStorage {\n\n    private static final boolean DEBUG = false;\n\n    private FTPClient ftp;\n\n    private String url;\n\n    private String password;\n\n    /**\n     * Default constructor.\n     */\n    public FTPFileStorage() {\n    }\n\n    public boolean needPassword() {\n        return true;\n    }\n\n    public boolean isReentrant() {\n        return false;\n    }\n\n    public void open(String url, LagoonContext context, String password) throws MalformedURLException, UnknownHostException, FTPException, IOException, AuthenticationException {\n        this.url = url;\n        this.password = password;\n        ftp = new FTPClient(url, password);\n        openDateFile(context);\n    }\n\n    /**\n     * Close the file system and release any resources it holds.\n     *\n     * After this method has been invoked, no other method may be invoked.\n     */\n    public void close() throws IOException {\n        closeDateFile();\n        ftp.close();\n        ftp = null;\n    }\n\n    /**\n     * Create a new file, or overwrite an existing file.\n     *\n     * @param pathname  path to the file\n     */\n    public OutputHandler createFile(String pathname) throws IOException {\n        OutputStream os;\n        try {\n            os = ftp.store(pathname);\n        } catch (IOException e) {\n            if (DEBUG)\n                System.out.println(\"FTP reconnecting: \" + e.toString());\n            try {\n                ftp.close();\n            } catch (IOException ignore) {\n            }\n            ftp = new FTPClient(url, password);\n            os = ftp.store(pathname);\n        }\n        return new FTPOutputHandler(pathname, os);\n    }\n\n    /**\n     * Deletes a file.\n     * Does not signal any error if the file doesn't exist.\n     *\n     * @param pathname  path to the file\n     */\n    public void deleteFile(String pathname) throws java.io.IOException {\n        try {\n            ftp.deleteFile(pathname);\n        } catch (IOException e) {\n            if (DEBUG)\n                System.out.println(\"FTP reconnecting: \" + e.toString());\n            try {\n                ftp.close();\n            } catch (IOException ignore) {\n            }\n            ftp = new FTPClient(url, password);\n            ftp.deleteFile(pathname);\n        }\n    }\n\n    class FTPOutputHandler extends OutputHandler {\n\n        private String currentPathname;\n\n        FTPOutputHandler(String currentPathname, OutputStream out) {\n            super(out);\n            this.currentPathname = currentPathname;\n        }\n\n        public void commit() throws java.io.IOException {\n            out.close();\n            fileModified(currentPathname);\n        }\n\n        public void discard() throws java.io.IOException {\n            try {\n                commit();\n            } catch (FTPException e) {\n                // ignore exception\n            }\n            ftp.deleteFile(currentPathname);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/filestorage/FTPFileStorageTest0.java",
		"test_prompt": "// FTPFileStorageTest0.java\npackage nu.staldal.lagoon.filestorage;\n\nimport java.io.*;\nimport java.net.*;\nimport nu.staldal.lagoon.core.*;\nimport nu.staldal.ftp.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FTPFileStorage}.\n* It contains ten unit test cases for the {@link FTPFileStorage#needPassword()} method.\n*/\nclass FTPFileStorageTest0 {"
	},
	{
		"original_code": "// FTPFileStorage.java\n/*\n * Copyright (c) 2001-2002, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.lagoon.filestorage;\n\nimport java.io.*;\nimport java.net.*;\nimport nu.staldal.lagoon.core.*;\nimport nu.staldal.ftp.*;\n\n/**\n * A FileStorage which transfers files to a remote site using FTP.\n *\n * <strong>Note:</strong> This class will transmit password in clear text over\n * the network.\n */\npublic class FTPFileStorage extends RemoteFileStorage {\n\n    private static final boolean DEBUG = false;\n\n    private FTPClient ftp;\n\n    private String url;\n\n    private String password;\n\n    /**\n     * Default constructor.\n     */\n    public FTPFileStorage() {\n    }\n\n    public boolean needPassword() {\n        return true;\n    }\n\n    public boolean isReentrant() {\n        return false;\n    }\n\n    public void open(String url, LagoonContext context, String password) throws MalformedURLException, UnknownHostException, FTPException, IOException, AuthenticationException {\n        this.url = url;\n        this.password = password;\n        ftp = new FTPClient(url, password);\n        openDateFile(context);\n    }\n\n    /**\n     * Close the file system and release any resources it holds.\n     *\n     * After this method has been invoked, no other method may be invoked.\n     */\n    public void close() throws IOException {\n        closeDateFile();\n        ftp.close();\n        ftp = null;\n    }\n\n    /**\n     * Create a new file, or overwrite an existing file.\n     *\n     * @param pathname  path to the file\n     */\n    public OutputHandler createFile(String pathname) throws IOException {\n        OutputStream os;\n        try {\n            os = ftp.store(pathname);\n        } catch (IOException e) {\n            if (DEBUG)\n                System.out.println(\"FTP reconnecting: \" + e.toString());\n            try {\n                ftp.close();\n            } catch (IOException ignore) {\n            }\n            ftp = new FTPClient(url, password);\n            os = ftp.store(pathname);\n        }\n        return new FTPOutputHandler(pathname, os);\n    }\n\n    /**\n     * Deletes a file.\n     * Does not signal any error if the file doesn't exist.\n     *\n     * @param pathname  path to the file\n     */\n    public void deleteFile(String pathname) throws java.io.IOException {\n        try {\n            ftp.deleteFile(pathname);\n        } catch (IOException e) {\n            if (DEBUG)\n                System.out.println(\"FTP reconnecting: \" + e.toString());\n            try {\n                ftp.close();\n            } catch (IOException ignore) {\n            }\n            ftp = new FTPClient(url, password);\n            ftp.deleteFile(pathname);\n        }\n    }\n\n    class FTPOutputHandler extends OutputHandler {\n\n        private String currentPathname;\n\n        FTPOutputHandler(String currentPathname, OutputStream out) {\n            super(out);\n            this.currentPathname = currentPathname;\n        }\n\n        public void commit() throws java.io.IOException {\n            out.close();\n            fileModified(currentPathname);\n        }\n\n        public void discard() throws java.io.IOException {\n            try {\n                commit();\n            } catch (FTPException e) {\n                // ignore exception\n            }\n            ftp.deleteFile(currentPathname);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/filestorage/FTPFileStorageTest1.java",
		"test_prompt": "// FTPFileStorageTest1.java\npackage nu.staldal.lagoon.filestorage;\n\nimport java.io.*;\nimport java.net.*;\nimport nu.staldal.lagoon.core.*;\nimport nu.staldal.ftp.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FTPFileStorage}.\n* It contains ten unit test cases for the {@link FTPFileStorage#isReentrant()} method.\n*/\nclass FTPFileStorageTest1 {"
	},
	{
		"original_code": "// FTPFileStorage.java\n/*\n * Copyright (c) 2001-2002, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.lagoon.filestorage;\n\nimport java.io.*;\nimport java.net.*;\nimport nu.staldal.lagoon.core.*;\nimport nu.staldal.ftp.*;\n\n/**\n * A FileStorage which transfers files to a remote site using FTP.\n *\n * <strong>Note:</strong> This class will transmit password in clear text over\n * the network.\n */\npublic class FTPFileStorage extends RemoteFileStorage {\n\n    private static final boolean DEBUG = false;\n\n    private FTPClient ftp;\n\n    private String url;\n\n    private String password;\n\n    /**\n     * Default constructor.\n     */\n    public FTPFileStorage() {\n    }\n\n    public boolean needPassword() {\n        return true;\n    }\n\n    public boolean isReentrant() {\n        return false;\n    }\n\n    public void open(String url, LagoonContext context, String password) throws MalformedURLException, UnknownHostException, FTPException, IOException, AuthenticationException {\n        this.url = url;\n        this.password = password;\n        ftp = new FTPClient(url, password);\n        openDateFile(context);\n    }\n\n    /**\n     * Close the file system and release any resources it holds.\n     *\n     * After this method has been invoked, no other method may be invoked.\n     */\n    public void close() throws IOException {\n        closeDateFile();\n        ftp.close();\n        ftp = null;\n    }\n\n    /**\n     * Create a new file, or overwrite an existing file.\n     *\n     * @param pathname  path to the file\n     */\n    public OutputHandler createFile(String pathname) throws IOException {\n        OutputStream os;\n        try {\n            os = ftp.store(pathname);\n        } catch (IOException e) {\n            if (DEBUG)\n                System.out.println(\"FTP reconnecting: \" + e.toString());\n            try {\n                ftp.close();\n            } catch (IOException ignore) {\n            }\n            ftp = new FTPClient(url, password);\n            os = ftp.store(pathname);\n        }\n        return new FTPOutputHandler(pathname, os);\n    }\n\n    /**\n     * Deletes a file.\n     * Does not signal any error if the file doesn't exist.\n     *\n     * @param pathname  path to the file\n     */\n    public void deleteFile(String pathname) throws java.io.IOException {\n        try {\n            ftp.deleteFile(pathname);\n        } catch (IOException e) {\n            if (DEBUG)\n                System.out.println(\"FTP reconnecting: \" + e.toString());\n            try {\n                ftp.close();\n            } catch (IOException ignore) {\n            }\n            ftp = new FTPClient(url, password);\n            ftp.deleteFile(pathname);\n        }\n    }\n\n    class FTPOutputHandler extends OutputHandler {\n\n        private String currentPathname;\n\n        FTPOutputHandler(String currentPathname, OutputStream out) {\n            super(out);\n            this.currentPathname = currentPathname;\n        }\n\n        public void commit() throws java.io.IOException {\n            out.close();\n            fileModified(currentPathname);\n        }\n\n        public void discard() throws java.io.IOException {\n            try {\n                commit();\n            } catch (FTPException e) {\n                // ignore exception\n            }\n            ftp.deleteFile(currentPathname);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/filestorage/FTPFileStorageTest2.java",
		"test_prompt": "// FTPFileStorageTest2.java\npackage nu.staldal.lagoon.filestorage;\n\nimport java.io.*;\nimport java.net.*;\nimport nu.staldal.lagoon.core.*;\nimport nu.staldal.ftp.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FTPFileStorage}.\n* It contains ten unit test cases for the {@link FTPFileStorage#createFile(String)} method.\n*/\nclass FTPFileStorageTest2 {"
	},
	{
		"original_code": "// SSHFileStorage.java\n/*\n * Copyright (c) 2001-2002, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.lagoon.filestorage;\n\nimport java.io.*;\nimport java.net.MalformedURLException;\nimport nu.staldal.lagoon.core.FileStorage;\nimport nu.staldal.lagoon.core.OutputHandler;\nimport nu.staldal.lagoon.core.RemoteFileStorage;\nimport nu.staldal.lagoon.core.LagoonContext;\n\n/**\n * A FileStorage which transfers files to a remote site using SSH.\n */\npublic class SSHFileStorage extends RemoteFileStorage {\n\n    private static final boolean DEBUG = false;\n\n    private String host;\n\n    private int port;\n\n    private String username;\n\n    private String rootPath;\n\n    private Runtime rt;\n\n    private Process runSSH(String[] command) throws IOException {\n        String[] cmdline = new String[command.length + ((port > 0) ? 9 : 7)];\n        cmdline[0] = \"ssh\";\n        cmdline[1] = \"-q\";\n        cmdline[2] = \"-e\";\n        cmdline[3] = \"none\";\n        cmdline[4] = \"-l\";\n        cmdline[5] = username;\n        if (port > 0) {\n            cmdline[6] = \"-p\";\n            cmdline[7] = Integer.toString(port);\n        }\n        cmdline[(port > 0) ? 8 : 6] = host;\n        System.arraycopy(command, 0, cmdline, ((port > 0) ? 9 : 7), command.length);\n        if (DEBUG) {\n            System.out.println(\"Executing: \");\n            for (int i = 0; i < cmdline.length; i++) System.out.println(cmdline[i]);\n            System.out.println();\n        }\n        return rt.exec(cmdline);\n    }\n\n    /**\n     * Default constructor.\n     */\n    public SSHFileStorage() {\n    }\n\n    public boolean needPassword() {\n        return false;\n    }\n\n    public boolean isReentrant() {\n        return true;\n    }\n\n    public void open(String url, LagoonContext context, String passoword) throws MalformedURLException, IOException {\n        if (!url.startsWith(\"ssh://\"))\n            throw new MalformedURLException(url);\n        int userPos = 5;\n        int hostPos = url.lastIndexOf('@');\n        if (hostPos < 0)\n            throw new MalformedURLException(url);\n        int portPos = url.indexOf(':', hostPos + 1);\n        int pathPos = url.indexOf('/', ((portPos < 0) ? hostPos : portPos) + 1);\n        String path;\n        try {\n            username = url.substring(userPos + 1, hostPos);\n            host = url.substring(hostPos + 1, (portPos < 0) ? pathPos : portPos);\n            port = (portPos < 0) ? 0 : Integer.parseInt(url.substring(portPos + 1, pathPos));\n            path = url.substring(pathPos + 1);\n        } catch (NumberFormatException e) {\n            throw new MalformedURLException(url);\n        }\n        if (port < 0 || port > 65535 || username.length() < 1 || host.length() < 1 || (path.length() > 0 && path.charAt(path.length() - 1) != '/'))\n            throw new MalformedURLException(url);\n        if ((path.length() == 0) || (path.charAt(path.length() - 1) != '/')) {\n            this.rootPath = path;\n        } else {\n            this.rootPath = path.substring(0, path.length() - 1);\n        }\n        this.rt = Runtime.getRuntime();\n        openDateFile(context);\n    }\n\n    /**\n     * Close the file system and release any resources it holds.\n     *\n     * After this method has been invoked, no other method may be invoked.\n     */\n    public void close() throws IOException {\n        closeDateFile();\n    }\n\n    /**\n     * Create a new file, or overwrite an existing file.\n     * Use close() on the returned OutputStream when finished\n     * writing to the file, and then commitFile() or discardFile()\n     * on the FileStorage.\n     *\n     * @param path  path to the file\n     *\n     * @return an OutputStream to write to\n     *\n     * @see #commitFile\n     * @see #discardFile\n     */\n    public OutputHandler createFile(String path) throws java.io.IOException {\n        String currentPath = path;\n        String s = rootPath + path;\n        int i = s.lastIndexOf('/');\n        String dir = (i < 0) ? \".\" : s.substring(0, i);\n        if (DEBUG)\n            System.out.println(\"dir: \" + dir);\n        Process currentProc = runSSH(new String[] { \"mkdir\", \"-p\", dir, \"&&\", \"rm\", \"-f\", rootPath + path, \"&&\", \"cat\", \">\" + rootPath + path });\n        return new SSHOutputHandler(currentPath, currentProc, currentProc.getOutputStream());\n    }\n\n    /**\n     * Deletes a file.\n     * Does not signal any error if the file doesn't exist.\n     *\n     * @param path  path to the file\n     */\n    public void deleteFile(String path) throws java.io.IOException {\n        Process proc = runSSH(new String[] { \"rm\", \"-f\", rootPath + path });\n        proc.getOutputStream().close();\n        try {\n            proc.waitFor();\n        } catch (InterruptedException e) {\n        }\n    }\n\n    class SSHOutputHandler extends OutputHandler {\n\n        private String currentPath;\n\n        private Process currentProc;\n\n        SSHOutputHandler(String currentPath, Process currentProc, OutputStream out) {\n            super(out);\n            this.currentPath = currentPath;\n            this.currentProc = currentProc;\n        }\n\n        public void commit() throws java.io.IOException {\n            out.close();\n            try {\n                currentProc.waitFor();\n            } catch (InterruptedException e) {\n            }\n            fileModified(currentPath);\n        }\n\n        public void discard() throws java.io.IOException {\n            out.close();\n            try {\n                currentProc.waitFor();\n            } catch (InterruptedException e) {\n            }\n            Process proc = runSSH(new String[] { \"rm\", \"-f\", rootPath + currentPath });\n            proc.getOutputStream().close();\n            try {\n                proc.waitFor();\n            } catch (InterruptedException e) {\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/filestorage/SSHFileStorageTest0.java",
		"test_prompt": "// SSHFileStorageTest0.java\npackage nu.staldal.lagoon.filestorage;\n\nimport java.io.*;\nimport java.net.MalformedURLException;\nimport nu.staldal.lagoon.core.FileStorage;\nimport nu.staldal.lagoon.core.OutputHandler;\nimport nu.staldal.lagoon.core.RemoteFileStorage;\nimport nu.staldal.lagoon.core.LagoonContext;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SSHFileStorage}.\n* It contains ten unit test cases for the {@link SSHFileStorage#needPassword()} method.\n*/\nclass SSHFileStorageTest0 {"
	},
	{
		"original_code": "// SSHFileStorage.java\n/*\n * Copyright (c) 2001-2002, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.lagoon.filestorage;\n\nimport java.io.*;\nimport java.net.MalformedURLException;\nimport nu.staldal.lagoon.core.FileStorage;\nimport nu.staldal.lagoon.core.OutputHandler;\nimport nu.staldal.lagoon.core.RemoteFileStorage;\nimport nu.staldal.lagoon.core.LagoonContext;\n\n/**\n * A FileStorage which transfers files to a remote site using SSH.\n */\npublic class SSHFileStorage extends RemoteFileStorage {\n\n    private static final boolean DEBUG = false;\n\n    private String host;\n\n    private int port;\n\n    private String username;\n\n    private String rootPath;\n\n    private Runtime rt;\n\n    private Process runSSH(String[] command) throws IOException {\n        String[] cmdline = new String[command.length + ((port > 0) ? 9 : 7)];\n        cmdline[0] = \"ssh\";\n        cmdline[1] = \"-q\";\n        cmdline[2] = \"-e\";\n        cmdline[3] = \"none\";\n        cmdline[4] = \"-l\";\n        cmdline[5] = username;\n        if (port > 0) {\n            cmdline[6] = \"-p\";\n            cmdline[7] = Integer.toString(port);\n        }\n        cmdline[(port > 0) ? 8 : 6] = host;\n        System.arraycopy(command, 0, cmdline, ((port > 0) ? 9 : 7), command.length);\n        if (DEBUG) {\n            System.out.println(\"Executing: \");\n            for (int i = 0; i < cmdline.length; i++) System.out.println(cmdline[i]);\n            System.out.println();\n        }\n        return rt.exec(cmdline);\n    }\n\n    /**\n     * Default constructor.\n     */\n    public SSHFileStorage() {\n    }\n\n    public boolean needPassword() {\n        return false;\n    }\n\n    public boolean isReentrant() {\n        return true;\n    }\n\n    public void open(String url, LagoonContext context, String passoword) throws MalformedURLException, IOException {\n        if (!url.startsWith(\"ssh://\"))\n            throw new MalformedURLException(url);\n        int userPos = 5;\n        int hostPos = url.lastIndexOf('@');\n        if (hostPos < 0)\n            throw new MalformedURLException(url);\n        int portPos = url.indexOf(':', hostPos + 1);\n        int pathPos = url.indexOf('/', ((portPos < 0) ? hostPos : portPos) + 1);\n        String path;\n        try {\n            username = url.substring(userPos + 1, hostPos);\n            host = url.substring(hostPos + 1, (portPos < 0) ? pathPos : portPos);\n            port = (portPos < 0) ? 0 : Integer.parseInt(url.substring(portPos + 1, pathPos));\n            path = url.substring(pathPos + 1);\n        } catch (NumberFormatException e) {\n            throw new MalformedURLException(url);\n        }\n        if (port < 0 || port > 65535 || username.length() < 1 || host.length() < 1 || (path.length() > 0 && path.charAt(path.length() - 1) != '/'))\n            throw new MalformedURLException(url);\n        if ((path.length() == 0) || (path.charAt(path.length() - 1) != '/')) {\n            this.rootPath = path;\n        } else {\n            this.rootPath = path.substring(0, path.length() - 1);\n        }\n        this.rt = Runtime.getRuntime();\n        openDateFile(context);\n    }\n\n    /**\n     * Close the file system and release any resources it holds.\n     *\n     * After this method has been invoked, no other method may be invoked.\n     */\n    public void close() throws IOException {\n        closeDateFile();\n    }\n\n    /**\n     * Create a new file, or overwrite an existing file.\n     * Use close() on the returned OutputStream when finished\n     * writing to the file, and then commitFile() or discardFile()\n     * on the FileStorage.\n     *\n     * @param path  path to the file\n     *\n     * @return an OutputStream to write to\n     *\n     * @see #commitFile\n     * @see #discardFile\n     */\n    public OutputHandler createFile(String path) throws java.io.IOException {\n        String currentPath = path;\n        String s = rootPath + path;\n        int i = s.lastIndexOf('/');\n        String dir = (i < 0) ? \".\" : s.substring(0, i);\n        if (DEBUG)\n            System.out.println(\"dir: \" + dir);\n        Process currentProc = runSSH(new String[] { \"mkdir\", \"-p\", dir, \"&&\", \"rm\", \"-f\", rootPath + path, \"&&\", \"cat\", \">\" + rootPath + path });\n        return new SSHOutputHandler(currentPath, currentProc, currentProc.getOutputStream());\n    }\n\n    /**\n     * Deletes a file.\n     * Does not signal any error if the file doesn't exist.\n     *\n     * @param path  path to the file\n     */\n    public void deleteFile(String path) throws java.io.IOException {\n        Process proc = runSSH(new String[] { \"rm\", \"-f\", rootPath + path });\n        proc.getOutputStream().close();\n        try {\n            proc.waitFor();\n        } catch (InterruptedException e) {\n        }\n    }\n\n    class SSHOutputHandler extends OutputHandler {\n\n        private String currentPath;\n\n        private Process currentProc;\n\n        SSHOutputHandler(String currentPath, Process currentProc, OutputStream out) {\n            super(out);\n            this.currentPath = currentPath;\n            this.currentProc = currentProc;\n        }\n\n        public void commit() throws java.io.IOException {\n            out.close();\n            try {\n                currentProc.waitFor();\n            } catch (InterruptedException e) {\n            }\n            fileModified(currentPath);\n        }\n\n        public void discard() throws java.io.IOException {\n            out.close();\n            try {\n                currentProc.waitFor();\n            } catch (InterruptedException e) {\n            }\n            Process proc = runSSH(new String[] { \"rm\", \"-f\", rootPath + currentPath });\n            proc.getOutputStream().close();\n            try {\n                proc.waitFor();\n            } catch (InterruptedException e) {\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/filestorage/SSHFileStorageTest1.java",
		"test_prompt": "// SSHFileStorageTest1.java\npackage nu.staldal.lagoon.filestorage;\n\nimport java.io.*;\nimport java.net.MalformedURLException;\nimport nu.staldal.lagoon.core.FileStorage;\nimport nu.staldal.lagoon.core.OutputHandler;\nimport nu.staldal.lagoon.core.RemoteFileStorage;\nimport nu.staldal.lagoon.core.LagoonContext;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SSHFileStorage}.\n* It contains ten unit test cases for the {@link SSHFileStorage#isReentrant()} method.\n*/\nclass SSHFileStorageTest1 {"
	},
	{
		"original_code": "// SSHFileStorage.java\n/*\n * Copyright (c) 2001-2002, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.lagoon.filestorage;\n\nimport java.io.*;\nimport java.net.MalformedURLException;\nimport nu.staldal.lagoon.core.FileStorage;\nimport nu.staldal.lagoon.core.OutputHandler;\nimport nu.staldal.lagoon.core.RemoteFileStorage;\nimport nu.staldal.lagoon.core.LagoonContext;\n\n/**\n * A FileStorage which transfers files to a remote site using SSH.\n */\npublic class SSHFileStorage extends RemoteFileStorage {\n\n    private static final boolean DEBUG = false;\n\n    private String host;\n\n    private int port;\n\n    private String username;\n\n    private String rootPath;\n\n    private Runtime rt;\n\n    private Process runSSH(String[] command) throws IOException {\n        String[] cmdline = new String[command.length + ((port > 0) ? 9 : 7)];\n        cmdline[0] = \"ssh\";\n        cmdline[1] = \"-q\";\n        cmdline[2] = \"-e\";\n        cmdline[3] = \"none\";\n        cmdline[4] = \"-l\";\n        cmdline[5] = username;\n        if (port > 0) {\n            cmdline[6] = \"-p\";\n            cmdline[7] = Integer.toString(port);\n        }\n        cmdline[(port > 0) ? 8 : 6] = host;\n        System.arraycopy(command, 0, cmdline, ((port > 0) ? 9 : 7), command.length);\n        if (DEBUG) {\n            System.out.println(\"Executing: \");\n            for (int i = 0; i < cmdline.length; i++) System.out.println(cmdline[i]);\n            System.out.println();\n        }\n        return rt.exec(cmdline);\n    }\n\n    /**\n     * Default constructor.\n     */\n    public SSHFileStorage() {\n    }\n\n    public boolean needPassword() {\n        return false;\n    }\n\n    public boolean isReentrant() {\n        return true;\n    }\n\n    public void open(String url, LagoonContext context, String passoword) throws MalformedURLException, IOException {\n        if (!url.startsWith(\"ssh://\"))\n            throw new MalformedURLException(url);\n        int userPos = 5;\n        int hostPos = url.lastIndexOf('@');\n        if (hostPos < 0)\n            throw new MalformedURLException(url);\n        int portPos = url.indexOf(':', hostPos + 1);\n        int pathPos = url.indexOf('/', ((portPos < 0) ? hostPos : portPos) + 1);\n        String path;\n        try {\n            username = url.substring(userPos + 1, hostPos);\n            host = url.substring(hostPos + 1, (portPos < 0) ? pathPos : portPos);\n            port = (portPos < 0) ? 0 : Integer.parseInt(url.substring(portPos + 1, pathPos));\n            path = url.substring(pathPos + 1);\n        } catch (NumberFormatException e) {\n            throw new MalformedURLException(url);\n        }\n        if (port < 0 || port > 65535 || username.length() < 1 || host.length() < 1 || (path.length() > 0 && path.charAt(path.length() - 1) != '/'))\n            throw new MalformedURLException(url);\n        if ((path.length() == 0) || (path.charAt(path.length() - 1) != '/')) {\n            this.rootPath = path;\n        } else {\n            this.rootPath = path.substring(0, path.length() - 1);\n        }\n        this.rt = Runtime.getRuntime();\n        openDateFile(context);\n    }\n\n    /**\n     * Close the file system and release any resources it holds.\n     *\n     * After this method has been invoked, no other method may be invoked.\n     */\n    public void close() throws IOException {\n        closeDateFile();\n    }\n\n    /**\n     * Create a new file, or overwrite an existing file.\n     * Use close() on the returned OutputStream when finished\n     * writing to the file, and then commitFile() or discardFile()\n     * on the FileStorage.\n     *\n     * @param path  path to the file\n     *\n     * @return an OutputStream to write to\n     *\n     * @see #commitFile\n     * @see #discardFile\n     */\n    public OutputHandler createFile(String path) throws java.io.IOException {\n        String currentPath = path;\n        String s = rootPath + path;\n        int i = s.lastIndexOf('/');\n        String dir = (i < 0) ? \".\" : s.substring(0, i);\n        if (DEBUG)\n            System.out.println(\"dir: \" + dir);\n        Process currentProc = runSSH(new String[] { \"mkdir\", \"-p\", dir, \"&&\", \"rm\", \"-f\", rootPath + path, \"&&\", \"cat\", \">\" + rootPath + path });\n        return new SSHOutputHandler(currentPath, currentProc, currentProc.getOutputStream());\n    }\n\n    /**\n     * Deletes a file.\n     * Does not signal any error if the file doesn't exist.\n     *\n     * @param path  path to the file\n     */\n    public void deleteFile(String path) throws java.io.IOException {\n        Process proc = runSSH(new String[] { \"rm\", \"-f\", rootPath + path });\n        proc.getOutputStream().close();\n        try {\n            proc.waitFor();\n        } catch (InterruptedException e) {\n        }\n    }\n\n    class SSHOutputHandler extends OutputHandler {\n\n        private String currentPath;\n\n        private Process currentProc;\n\n        SSHOutputHandler(String currentPath, Process currentProc, OutputStream out) {\n            super(out);\n            this.currentPath = currentPath;\n            this.currentProc = currentProc;\n        }\n\n        public void commit() throws java.io.IOException {\n            out.close();\n            try {\n                currentProc.waitFor();\n            } catch (InterruptedException e) {\n            }\n            fileModified(currentPath);\n        }\n\n        public void discard() throws java.io.IOException {\n            out.close();\n            try {\n                currentProc.waitFor();\n            } catch (InterruptedException e) {\n            }\n            Process proc = runSSH(new String[] { \"rm\", \"-f\", rootPath + currentPath });\n            proc.getOutputStream().close();\n            try {\n                proc.waitFor();\n            } catch (InterruptedException e) {\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/filestorage/SSHFileStorageTest2.java",
		"test_prompt": "// SSHFileStorageTest2.java\npackage nu.staldal.lagoon.filestorage;\n\nimport java.io.*;\nimport java.net.MalformedURLException;\nimport nu.staldal.lagoon.core.FileStorage;\nimport nu.staldal.lagoon.core.OutputHandler;\nimport nu.staldal.lagoon.core.RemoteFileStorage;\nimport nu.staldal.lagoon.core.LagoonContext;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SSHFileStorage}.\n* It contains ten unit test cases for the {@link SSHFileStorage#createFile(String)} method.\n*/\nclass SSHFileStorageTest2 {"
	},
	{
		"original_code": "// LocalFileStorage.java\n/*\n * Copyright (c) 2001-2002, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.lagoon.filestorage;\n\nimport java.io.*;\nimport nu.staldal.lagoon.core.*;\n\n/**\n * A FileStorage using the local file system.\n */\npublic class LocalFileStorage implements FileStorage {\n\n    private File root;\n\n    /**\n     * Default constructor.\n     */\n    public LocalFileStorage() {\n        root = null;\n    }\n\n    public boolean needPassword() {\n        return false;\n    }\n\n    public boolean isReentrant() {\n        return true;\n    }\n\n    public void open(String loc, LagoonContext context, String password) throws java.io.IOException {\n        root = new File(loc);\n        if (root.exists()) {\n            if (!root.isDirectory())\n                throw new IOException(\"Location exists but is not a directory\");\n        } else {\n            if (!root.mkdir())\n                throw new IOException(\"Location didn't exist and couldn't be created\");\n        }\n    }\n\n    /**\n     * Close the file system and release any resources it holds.\n     *\n     * After this method has been invoked, no other method may be invoked.\n     */\n    public void close() // throws java.io.IOException;\n    {\n        root = null;\n    }\n\n    /**\n     * Check if a file exists and when it was last modified.\n     *\n     * @param path  path to the file\n     *\n     * @return  the time when the file was last modified,\n     * or -1 if that information is not avaliable,\n     * or 0 if the file doesn't exists.\n     */\n    public long fileLastModified(String path) // throws java.io.IOException\n    {\n        File file = root;\n        int oldPos = 1;\n        int pos;\n        while (true) {\n            pos = path.indexOf('/', oldPos);\n            if (pos < 0)\n                break;\n            String comp = path.substring(oldPos, pos);\n            file = new File(file, comp);\n            if (!file.exists())\n                return 0;\n            oldPos = pos + 1;\n        }\n        file = new File(file, path.substring(oldPos));\n        return file.lastModified();\n    }\n\n    /**\n     * Create a new file, or overwrite an existing file.\n     */\n    public OutputHandler createFile(String path) throws java.io.IOException {\n        File file = root;\n        int oldPos = 1;\n        int pos;\n        while (true) {\n            pos = path.indexOf('/', oldPos);\n            if (pos < 0)\n                break;\n            String comp = path.substring(oldPos, pos);\n            file = new File(file, comp);\n            if (!file.exists())\n                if (!file.mkdir())\n                    throw new IOException(\"Unable to create directory: \" + file);\n            oldPos = pos + 1;\n        }\n        File currentFile = new File(file, path.substring(oldPos));\n        return new LocalOutputHandler(currentFile, new FileOutputStream(currentFile));\n    }\n\n    /**\n     * Deletes a file.\n     * Does not signal any error if the file doesn't exist.\n     *\n     * @param path  path to the file\n     */\n    public void deleteFile(String path) throws java.io.IOException {\n        File file = root;\n        int oldPos = 1;\n        int pos;\n        while (true) {\n            pos = path.indexOf('/', oldPos);\n            if (pos < 0)\n                break;\n            String comp = path.substring(oldPos, pos);\n            file = new File(file, comp);\n            // file doesn't exist\n            if (!file.exists())\n                return;\n            oldPos = pos + 1;\n        }\n        file = new File(file, path.substring(oldPos));\n        if (!file.exists())\n            return;\n        if (file.delete()) {\n            return;\n        } else {\n            throw new IOException(\"Unable to delete file: \" + file);\n        }\n    }\n\n    static class LocalOutputHandler extends OutputHandler {\n\n        private File currentFile;\n\n        LocalOutputHandler(File currentFile, OutputStream out) {\n            super(out);\n            this.currentFile = currentFile;\n        }\n\n        public void commit() throws java.io.IOException {\n            out.close();\n        }\n\n        public void discard() throws java.io.IOException {\n            out.close();\n            if (!currentFile.exists())\n                return;\n            if (currentFile.delete()) {\n                return;\n            } else {\n                throw new IOException(\"Unable to delete file: \" + currentFile);\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/filestorage/LocalFileStorageTest0.java",
		"test_prompt": "// LocalFileStorageTest0.java\npackage nu.staldal.lagoon.filestorage;\n\nimport java.io.*;\nimport nu.staldal.lagoon.core.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link LocalFileStorage}.\n* It contains ten unit test cases for the {@link LocalFileStorage#needPassword()} method.\n*/\nclass LocalFileStorageTest0 {"
	},
	{
		"original_code": "// LocalFileStorage.java\n/*\n * Copyright (c) 2001-2002, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.lagoon.filestorage;\n\nimport java.io.*;\nimport nu.staldal.lagoon.core.*;\n\n/**\n * A FileStorage using the local file system.\n */\npublic class LocalFileStorage implements FileStorage {\n\n    private File root;\n\n    /**\n     * Default constructor.\n     */\n    public LocalFileStorage() {\n        root = null;\n    }\n\n    public boolean needPassword() {\n        return false;\n    }\n\n    public boolean isReentrant() {\n        return true;\n    }\n\n    public void open(String loc, LagoonContext context, String password) throws java.io.IOException {\n        root = new File(loc);\n        if (root.exists()) {\n            if (!root.isDirectory())\n                throw new IOException(\"Location exists but is not a directory\");\n        } else {\n            if (!root.mkdir())\n                throw new IOException(\"Location didn't exist and couldn't be created\");\n        }\n    }\n\n    /**\n     * Close the file system and release any resources it holds.\n     *\n     * After this method has been invoked, no other method may be invoked.\n     */\n    public void close() // throws java.io.IOException;\n    {\n        root = null;\n    }\n\n    /**\n     * Check if a file exists and when it was last modified.\n     *\n     * @param path  path to the file\n     *\n     * @return  the time when the file was last modified,\n     * or -1 if that information is not avaliable,\n     * or 0 if the file doesn't exists.\n     */\n    public long fileLastModified(String path) // throws java.io.IOException\n    {\n        File file = root;\n        int oldPos = 1;\n        int pos;\n        while (true) {\n            pos = path.indexOf('/', oldPos);\n            if (pos < 0)\n                break;\n            String comp = path.substring(oldPos, pos);\n            file = new File(file, comp);\n            if (!file.exists())\n                return 0;\n            oldPos = pos + 1;\n        }\n        file = new File(file, path.substring(oldPos));\n        return file.lastModified();\n    }\n\n    /**\n     * Create a new file, or overwrite an existing file.\n     */\n    public OutputHandler createFile(String path) throws java.io.IOException {\n        File file = root;\n        int oldPos = 1;\n        int pos;\n        while (true) {\n            pos = path.indexOf('/', oldPos);\n            if (pos < 0)\n                break;\n            String comp = path.substring(oldPos, pos);\n            file = new File(file, comp);\n            if (!file.exists())\n                if (!file.mkdir())\n                    throw new IOException(\"Unable to create directory: \" + file);\n            oldPos = pos + 1;\n        }\n        File currentFile = new File(file, path.substring(oldPos));\n        return new LocalOutputHandler(currentFile, new FileOutputStream(currentFile));\n    }\n\n    /**\n     * Deletes a file.\n     * Does not signal any error if the file doesn't exist.\n     *\n     * @param path  path to the file\n     */\n    public void deleteFile(String path) throws java.io.IOException {\n        File file = root;\n        int oldPos = 1;\n        int pos;\n        while (true) {\n            pos = path.indexOf('/', oldPos);\n            if (pos < 0)\n                break;\n            String comp = path.substring(oldPos, pos);\n            file = new File(file, comp);\n            // file doesn't exist\n            if (!file.exists())\n                return;\n            oldPos = pos + 1;\n        }\n        file = new File(file, path.substring(oldPos));\n        if (!file.exists())\n            return;\n        if (file.delete()) {\n            return;\n        } else {\n            throw new IOException(\"Unable to delete file: \" + file);\n        }\n    }\n\n    static class LocalOutputHandler extends OutputHandler {\n\n        private File currentFile;\n\n        LocalOutputHandler(File currentFile, OutputStream out) {\n            super(out);\n            this.currentFile = currentFile;\n        }\n\n        public void commit() throws java.io.IOException {\n            out.close();\n        }\n\n        public void discard() throws java.io.IOException {\n            out.close();\n            if (!currentFile.exists())\n                return;\n            if (currentFile.delete()) {\n                return;\n            } else {\n                throw new IOException(\"Unable to delete file: \" + currentFile);\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/filestorage/LocalFileStorageTest1.java",
		"test_prompt": "// LocalFileStorageTest1.java\npackage nu.staldal.lagoon.filestorage;\n\nimport java.io.*;\nimport nu.staldal.lagoon.core.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link LocalFileStorage}.\n* It contains ten unit test cases for the {@link LocalFileStorage#isReentrant()} method.\n*/\nclass LocalFileStorageTest1 {"
	},
	{
		"original_code": "// LocalFileStorage.java\n/*\n * Copyright (c) 2001-2002, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.lagoon.filestorage;\n\nimport java.io.*;\nimport nu.staldal.lagoon.core.*;\n\n/**\n * A FileStorage using the local file system.\n */\npublic class LocalFileStorage implements FileStorage {\n\n    private File root;\n\n    /**\n     * Default constructor.\n     */\n    public LocalFileStorage() {\n        root = null;\n    }\n\n    public boolean needPassword() {\n        return false;\n    }\n\n    public boolean isReentrant() {\n        return true;\n    }\n\n    public void open(String loc, LagoonContext context, String password) throws java.io.IOException {\n        root = new File(loc);\n        if (root.exists()) {\n            if (!root.isDirectory())\n                throw new IOException(\"Location exists but is not a directory\");\n        } else {\n            if (!root.mkdir())\n                throw new IOException(\"Location didn't exist and couldn't be created\");\n        }\n    }\n\n    /**\n     * Close the file system and release any resources it holds.\n     *\n     * After this method has been invoked, no other method may be invoked.\n     */\n    public void close() // throws java.io.IOException;\n    {\n        root = null;\n    }\n\n    /**\n     * Check if a file exists and when it was last modified.\n     *\n     * @param path  path to the file\n     *\n     * @return  the time when the file was last modified,\n     * or -1 if that information is not avaliable,\n     * or 0 if the file doesn't exists.\n     */\n    public long fileLastModified(String path) // throws java.io.IOException\n    {\n        File file = root;\n        int oldPos = 1;\n        int pos;\n        while (true) {\n            pos = path.indexOf('/', oldPos);\n            if (pos < 0)\n                break;\n            String comp = path.substring(oldPos, pos);\n            file = new File(file, comp);\n            if (!file.exists())\n                return 0;\n            oldPos = pos + 1;\n        }\n        file = new File(file, path.substring(oldPos));\n        return file.lastModified();\n    }\n\n    /**\n     * Create a new file, or overwrite an existing file.\n     */\n    public OutputHandler createFile(String path) throws java.io.IOException {\n        File file = root;\n        int oldPos = 1;\n        int pos;\n        while (true) {\n            pos = path.indexOf('/', oldPos);\n            if (pos < 0)\n                break;\n            String comp = path.substring(oldPos, pos);\n            file = new File(file, comp);\n            if (!file.exists())\n                if (!file.mkdir())\n                    throw new IOException(\"Unable to create directory: \" + file);\n            oldPos = pos + 1;\n        }\n        File currentFile = new File(file, path.substring(oldPos));\n        return new LocalOutputHandler(currentFile, new FileOutputStream(currentFile));\n    }\n\n    /**\n     * Deletes a file.\n     * Does not signal any error if the file doesn't exist.\n     *\n     * @param path  path to the file\n     */\n    public void deleteFile(String path) throws java.io.IOException {\n        File file = root;\n        int oldPos = 1;\n        int pos;\n        while (true) {\n            pos = path.indexOf('/', oldPos);\n            if (pos < 0)\n                break;\n            String comp = path.substring(oldPos, pos);\n            file = new File(file, comp);\n            // file doesn't exist\n            if (!file.exists())\n                return;\n            oldPos = pos + 1;\n        }\n        file = new File(file, path.substring(oldPos));\n        if (!file.exists())\n            return;\n        if (file.delete()) {\n            return;\n        } else {\n            throw new IOException(\"Unable to delete file: \" + file);\n        }\n    }\n\n    static class LocalOutputHandler extends OutputHandler {\n\n        private File currentFile;\n\n        LocalOutputHandler(File currentFile, OutputStream out) {\n            super(out);\n            this.currentFile = currentFile;\n        }\n\n        public void commit() throws java.io.IOException {\n            out.close();\n        }\n\n        public void discard() throws java.io.IOException {\n            out.close();\n            if (!currentFile.exists())\n                return;\n            if (currentFile.delete()) {\n                return;\n            } else {\n                throw new IOException(\"Unable to delete file: \" + currentFile);\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/filestorage/LocalFileStorageTest2.java",
		"test_prompt": "// LocalFileStorageTest2.java\npackage nu.staldal.lagoon.filestorage;\n\nimport java.io.*;\nimport nu.staldal.lagoon.core.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link LocalFileStorage}.\n* It contains ten unit test cases for the {@link LocalFileStorage#fileLastModified(String)} method.\n*/\nclass LocalFileStorageTest2 {"
	},
	{
		"original_code": "// LocalFileStorage.java\n/*\n * Copyright (c) 2001-2002, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.lagoon.filestorage;\n\nimport java.io.*;\nimport nu.staldal.lagoon.core.*;\n\n/**\n * A FileStorage using the local file system.\n */\npublic class LocalFileStorage implements FileStorage {\n\n    private File root;\n\n    /**\n     * Default constructor.\n     */\n    public LocalFileStorage() {\n        root = null;\n    }\n\n    public boolean needPassword() {\n        return false;\n    }\n\n    public boolean isReentrant() {\n        return true;\n    }\n\n    public void open(String loc, LagoonContext context, String password) throws java.io.IOException {\n        root = new File(loc);\n        if (root.exists()) {\n            if (!root.isDirectory())\n                throw new IOException(\"Location exists but is not a directory\");\n        } else {\n            if (!root.mkdir())\n                throw new IOException(\"Location didn't exist and couldn't be created\");\n        }\n    }\n\n    /**\n     * Close the file system and release any resources it holds.\n     *\n     * After this method has been invoked, no other method may be invoked.\n     */\n    public void close() // throws java.io.IOException;\n    {\n        root = null;\n    }\n\n    /**\n     * Check if a file exists and when it was last modified.\n     *\n     * @param path  path to the file\n     *\n     * @return  the time when the file was last modified,\n     * or -1 if that information is not avaliable,\n     * or 0 if the file doesn't exists.\n     */\n    public long fileLastModified(String path) // throws java.io.IOException\n    {\n        File file = root;\n        int oldPos = 1;\n        int pos;\n        while (true) {\n            pos = path.indexOf('/', oldPos);\n            if (pos < 0)\n                break;\n            String comp = path.substring(oldPos, pos);\n            file = new File(file, comp);\n            if (!file.exists())\n                return 0;\n            oldPos = pos + 1;\n        }\n        file = new File(file, path.substring(oldPos));\n        return file.lastModified();\n    }\n\n    /**\n     * Create a new file, or overwrite an existing file.\n     */\n    public OutputHandler createFile(String path) throws java.io.IOException {\n        File file = root;\n        int oldPos = 1;\n        int pos;\n        while (true) {\n            pos = path.indexOf('/', oldPos);\n            if (pos < 0)\n                break;\n            String comp = path.substring(oldPos, pos);\n            file = new File(file, comp);\n            if (!file.exists())\n                if (!file.mkdir())\n                    throw new IOException(\"Unable to create directory: \" + file);\n            oldPos = pos + 1;\n        }\n        File currentFile = new File(file, path.substring(oldPos));\n        return new LocalOutputHandler(currentFile, new FileOutputStream(currentFile));\n    }\n\n    /**\n     * Deletes a file.\n     * Does not signal any error if the file doesn't exist.\n     *\n     * @param path  path to the file\n     */\n    public void deleteFile(String path) throws java.io.IOException {\n        File file = root;\n        int oldPos = 1;\n        int pos;\n        while (true) {\n            pos = path.indexOf('/', oldPos);\n            if (pos < 0)\n                break;\n            String comp = path.substring(oldPos, pos);\n            file = new File(file, comp);\n            // file doesn't exist\n            if (!file.exists())\n                return;\n            oldPos = pos + 1;\n        }\n        file = new File(file, path.substring(oldPos));\n        if (!file.exists())\n            return;\n        if (file.delete()) {\n            return;\n        } else {\n            throw new IOException(\"Unable to delete file: \" + file);\n        }\n    }\n\n    static class LocalOutputHandler extends OutputHandler {\n\n        private File currentFile;\n\n        LocalOutputHandler(File currentFile, OutputStream out) {\n            super(out);\n            this.currentFile = currentFile;\n        }\n\n        public void commit() throws java.io.IOException {\n            out.close();\n        }\n\n        public void discard() throws java.io.IOException {\n            out.close();\n            if (!currentFile.exists())\n                return;\n            if (currentFile.delete()) {\n                return;\n            } else {\n                throw new IOException(\"Unable to delete file: \" + currentFile);\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/filestorage/LocalFileStorageTest3.java",
		"test_prompt": "// LocalFileStorageTest3.java\npackage nu.staldal.lagoon.filestorage;\n\nimport java.io.*;\nimport nu.staldal.lagoon.core.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link LocalFileStorage}.\n* It contains ten unit test cases for the {@link LocalFileStorage#createFile(String)} method.\n*/\nclass LocalFileStorageTest3 {"
	},
	{
		"original_code": "// Element.java\n/*\n * Copyright (c) 2001, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.xtree;\n\nimport java.util.Vector;\nimport java.net.URL;\nimport org.xml.sax.*;\nimport org.xml.sax.helpers.AttributesImpl;\n\n/**\n * An XML Element.\n */\npublic class Element extends NodeWithChildren {\n\n    static final long serialVersionUID = -1804355746259349573L;\n\n    final String namespaceURI;\n\n    final String localName;\n\n    URL baseURI = null;\n\n    Vector attrName;\n\n    Vector attrValue;\n\n    Vector attrType;\n\n    Vector namespacePrefixes;\n\n    Vector namespaceURIs;\n\n    char xmlSpaceAttribute = ' ';\n\n    /**\n     * Construct an element.\n     *\n     * @param namespaceURI  the namespace URI for this element,\n     *                      may be the empty string\n     * @param localName\tthe element name\n     */\n    public Element(String namespaceURI, String localName) {\n        this(namespaceURI, localName, -1, -1);\n    }\n\n    /**\n     * Construct an element.\n     *\n     * @param namespaceURI  the namespace URI for this element,\n     *                      may be the empty string\n     * @param localName\tthe element name\n     * @param numberOfAttributes  the number of attributes this element should have\n     */\n    public Element(String namespaceURI, String localName, int numberOfAttributes) {\n        this(namespaceURI, localName, numberOfAttributes, -1);\n    }\n\n    /**\n     * Construct an element.\n     *\n     * @param namespaceURI  the namespace URI for this element,\n     *                      may be the empty string\n     * @param localName\tthe name of this element (no namespace)\n     * @param numberOfAttributes  the number of attributes this element should have\n     * @param numberOfChildren  the number of children this element should have\n     */\n    public Element(String namespaceURI, String localName, int numberOfAttributes, int numberOfChildren) {\n        super(numberOfChildren);\n        if (namespaceURI == null)\n            namespaceURI = \"\";\n        if (localName == null)\n            throw new NullPointerException(\"LocalName may not be null\");\n        if (numberOfAttributes >= 0) {\n            attrName = new Vector(numberOfAttributes);\n            attrValue = new Vector(numberOfAttributes);\n            attrType = new Vector(numberOfAttributes);\n        } else {\n            attrName = new Vector();\n            attrValue = new Vector();\n            attrType = new Vector();\n        }\n        namespaceURIs = new Vector();\n        namespacePrefixes = new Vector();\n        this.namespaceURI = namespaceURI;\n        this.localName = localName;\n    }\n\n    /**\n     * Get the namespace URI for this element. May be the empty string.\n     */\n    public String getNamespaceURI() {\n        return namespaceURI;\n    }\n\n    /**\n     * Get the name of this element.\n     * The name does not include namespace URI or prefix.\n     */\n    public String getLocalName() {\n        return localName;\n    }\n\n    /**\n     * Lookup the index of an attribute to this element. The returned index\n     * may be used as argument to other methods in this class.\n     *\n     * @param namespaceURI  the namespace URI, may be the empty string\n     * @param localName  the name\n     * @return the index of the attribute, or -1 if no such attribute exists\n     *\n     * @see #getAttributeValue\n     * @see #getAttributeType\n     * @see #removeAttribute\n     */\n    public int lookupAttribute(String namespaceURI, String localName) {\n        return attrName.indexOf(localName + '^' + namespaceURI);\n    }\n\n    /**\n     * Add an attribute to this element.\n     *\n     * The attribute type is one of the strings\n     * \"CDATA\", \"ID\", \"IDREF\", \"IDREFS\", \"NMTOKEN\", \"NMTOKENS\",\n     * \"ENTITY\", \"ENTITIES\", or \"NOTATION\" (always in upper case).\n     *\n     * @param namespaceURI  the namespace URI, may be the empty string\n     * @param localName  the name\n     * @param type  the type (use \"CDATA\" if the type is irrelevant)\n     * @param value  the value\n     */\n    public void addAttribute(String namespaceURI, String localName, String type, String value) {\n        attrName.addElement(localName + '^' + namespaceURI);\n        attrType.addElement(type);\n        attrValue.addElement(value);\n        if (namespaceURI.equals(XML_NS) && localName.equals(\"space\")) {\n            if (value.equals(\"preserve\"))\n                xmlSpaceAttribute = 'p';\n            else if (value.equals(\"default\"))\n                xmlSpaceAttribute = 'd';\n        }\n    }\n\n    /**\n     * Remove an attribute at the specified index.\n     * This method is a bit inefficient.\n     *\n     * @param index  the index as returned from {@link #lookupAttribute}\n     * @throws IndexOutOfBoundException  if no such attribute exist.\n     */\n    public void removeAttribute(int index) throws IndexOutOfBoundsException {\n        attrName.removeElementAt(index);\n        attrType.removeElementAt(index);\n        attrValue.removeElementAt(index);\n    }\n\n    /**\n     * Return the number of attributes this element have.\n     */\n    public int numberOfAttributes() {\n        return attrName.size();\n    }\n\n    /**\n     * Get the namespace URI for the attribute at the specified index.\n     *\n     * @param index  the index as returned from {@link #lookupAttribute}\n     *\n     * @return the namespace URI, may be (and is usually) the empty string,\n     *         or <code>null</code> if index is -1\n     * @throws IndexOutOfBoundsException  if no such attribute exist.\n     */\n    public String getAttributeNamespaceURI(int index) throws IndexOutOfBoundsException {\n        if (index == -1)\n            return null;\n        String s = (String) attrName.elementAt(index);\n        return s.substring(s.indexOf('^') + 1);\n    }\n\n    /**\n     * Get the name of the attribute at the specified index.\n     *\n     * @param index  the index as returned from {@link #lookupAttribute}\n     *\n     * @return the localName,\n     *         or <code>null</code> if index is -1\n     * @throws IndexOutOfBoundsException  if no such attribute exist.\n     */\n    public String getAttributeLocalName(int index) throws IndexOutOfBoundsException {\n        if (index == -1)\n            return null;\n        String s = (String) attrName.elementAt(index);\n        return s.substring(0, s.indexOf('^'));\n    }\n\n    /**\n     * Get the type of the attribute at the specified index.\n     *\n     * The attribute type is one of the strings\n     * \"CDATA\", \"ID\", \"IDREF\", \"IDREFS\", \"NMTOKEN\", \"NMTOKENS\",\n     * \"ENTITY\", \"ENTITIES\", or \"NOTATION\" (always in upper case).\n     *\n     * @return the attribute type,\n     *         or <code>null</code> if index is -1\n     * @param index  the index as returned from {@link #lookupAttribute}\n     * @throws IndexOutOfBoundsException  if no such attribute exist.\n     */\n    public String getAttributeType(int index) throws IndexOutOfBoundsException {\n        if (index == -1)\n            return null;\n        return (String) attrType.elementAt(index);\n    }\n\n    /**\n     * Get the value of the attribute at the specified index.\n     *\n     * @return the attribute value,\n     *         or <code>null</code> if index is -1\n     * @param index  the index as returned from {@link #lookupAttribute}\n     * @throws IndexOutOfBoundsException  if no such attribute exist.\n     */\n    public String getAttributeValue(int index) throws IndexOutOfBoundsException {\n        if (index == -1)\n            return null;\n        return (String) attrValue.elementAt(index);\n    }\n\n    void setNamespaceMappings(Vector prefixes, Vector URIs) {\n        namespacePrefixes = prefixes;\n        namespaceURIs = URIs;\n    }\n\n    /**\n     * Add a namespace mapping to this element.\n     *\n     * @param prefix  the prefix\n     * @param URI  the namespace URI\n     */\n    public void addNamespaceMapping(String prefix, String URI) {\n        namespacePrefixes.addElement(prefix);\n        namespaceURIs.addElement(URI);\n    }\n\n    /**\n     * Return the number of namespace mapping for this element.\n     */\n    public int numberOfNamespaceMappings() {\n        return namespacePrefixes.size();\n    }\n\n    /**\n     * Return a namespace mapping at the specified index.\n     *\n     * @return a String[] with [0] = prefix, [1] = namespace URI\n     * @throws IndexOutOfBoundsException  if no such mapping exist.\n     */\n    public String[] getNamespaceMapping(int index) throws IndexOutOfBoundsException {\n        return new String[] { (String) namespacePrefixes.elementAt(index), (String) namespaceURIs.elementAt(index) };\n    }\n\n    public String lookupNamespaceURI(String prefix) {\n        int index = namespacePrefixes.indexOf(prefix);\n        if (index == -1) {\n            if (parent != null) {\n                return parent.lookupNamespaceURI(prefix);\n            } else {\n                if (prefix.length() == 0) {\n                    return \"\";\n                } else {\n                    return null;\n                }\n            }\n        } else {\n            return (String) namespaceURIs.elementAt(index);\n        }\n    }\n\n    public String lookupNamespacePrefix(String URI) {\n        int index = namespaceURI.indexOf(URI);\n        if (index == -1) {\n            if (parent != null) {\n                return parent.lookupNamespacePrefix(URI);\n            } else {\n                if (URI.length() == 0) {\n                    return \"\";\n                } else {\n                    return null;\n                }\n            }\n        } else {\n            return (String) namespacePrefixes.elementAt(index);\n        }\n    }\n\n    /**\n     * Set the baseURI property of this element.\n     *\n     * @param URI  the base URI, must be absolute\n     */\n    public void setBaseURI(URL URI) {\n        baseURI = URI;\n    }\n\n    public URL getBaseURI() {\n        if (baseURI != null) {\n            return baseURI;\n        } else {\n            if (parent != null) {\n                return parent.getBaseURI();\n            } else {\n                return null;\n            }\n        }\n    }\n\n    public boolean getPreserveSpace() {\n        switch(xmlSpaceAttribute) {\n            case 'p':\n                return true;\n            case 'd':\n                return false;\n            default:\n                if (parent != null) {\n                    return parent.getPreserveSpace();\n                } else {\n                    return false;\n                }\n        }\n    }\n\n    public String getInheritedAttribute(String namespaceURI, String localName) {\n        String val = getAttrValueOrNull(namespaceURI, localName);\n        if (val != null)\n            return val;\n        else if (parent == null)\n            return null;\n        else\n            return parent.getInheritedAttribute(namespaceURI, localName);\n    }\n\n    /**\n     * Fire the startElement event to the given SAX2 ContentHandler.\n     * Will also fire startPrefixMapping events.\n     */\n    public void outputStartElement(ContentHandler sax) throws SAXException {\n        for (int i = 0; i < namespacePrefixes.size(); i++) {\n            sax.startPrefixMapping((String) namespacePrefixes.elementAt(i), (String) namespaceURIs.elementAt(i));\n        }\n        AttributesImpl atts = new AttributesImpl();\n        for (int i = 0; i < attrName.size(); i++) {\n            String s = (String) attrName.elementAt(i);\n            String URI = s.substring(s.indexOf('^') + 1);\n            String local = s.substring(0, s.indexOf('^'));\n            atts.addAttribute(URI, local, \"\", (String) attrType.elementAt(i), (String) attrValue.elementAt(i));\n        }\n        sax.startElement(namespaceURI, localName, \"\", atts);\n    }\n\n    /**\n     * Fire the endElement event to the given SAX2 ContentHandler.\n     * Will also fire endPrefixMapping events.\n     */\n    public void outputEndElement(ContentHandler sax) throws SAXException {\n        sax.endElement(namespaceURI, localName, \"\");\n        for (int i = 0; i < namespacePrefixes.size(); i++) {\n            sax.endPrefixMapping((String) namespacePrefixes.elementAt(i));\n        }\n    }\n\n    public void toSAX(ContentHandler sax) throws SAXException {\n        outputStartElement(sax);\n        for (int i = 0; i < numberOfChildren(); i++) {\n            getChild(i).toSAX(sax);\n        }\n        outputEndElement(sax);\n    }\n\n    /**\n     * Shortcut method for getting the value of an attribute without\n     * namespace.\n     *\n     * @return the attrubute value, or <code>null</code>\n     * \t\tif the attribute doesn't exist\n     */\n    public String getAttrValueOrNull(String localName) {\n        return getAttributeValue(lookupAttribute(\"\", localName));\n    }\n\n    /**\n     * Shortcut method for getting the value of an attribute without\n     * namespace.\n     *\n     * @return the attrubute value, never <code>null</code>\n     * @throws SAXParseException if the attribute doesn't exist\n     */\n    public String getAttrValue(String localName) throws SAXParseException {\n        String v = getAttrValueOrNull(localName);\n        if (v == null)\n            throw new SAXParseException(\"Attribute \" + localName + \" expected\", this);\n        else\n            return v;\n    }\n\n    /**\n     * Shortcut method for getting the value of an attribute with\n     * namespace.\n     *\n     * @return the attrubute value, or <code>null</code>\n     * \t\tif the attribute doesn't exist\n     */\n    public String getAttrValueOrNull(String namespaceURI, String localName) {\n        return getAttributeValue(lookupAttribute(namespaceURI, localName));\n    }\n\n    /**\n     * Shortcut method for getting the value of an attribute with\n     * namespace.\n     *\n     * @return the attrubute value, never <code>null</code>\n     * @throws SAXParseException if the attribute doesn't exist\n     */\n    public String getAttrValue(String namespaceURI, String localName) throws SAXParseException {\n        String v = getAttrValueOrNull(namespaceURI, localName);\n        if (v == null)\n            throw new SAXParseException(\"Attribute {\" + namespaceURI + \"}\" + localName + \" expected\", this);\n        else\n            return v;\n    }\n\n    /**\n     * Shortcut method for getting the text content of an Element.\n     *\n     * @return if there is a single Text child, return its value,\n     *         if there is no children, return \"\",\n     *         or <code>null</code>\n     *         if there are more than one children or one non-Text child\n     */\n    public String getTextContentOrNull() {\n        if (numberOfChildren() == 0) {\n            return \"\";\n        } else if (numberOfChildren() > 1) {\n            return null;\n        } else {\n            Node node = getChild(0);\n            if (!(node instanceof Text))\n                return null;\n            return ((Text) node).getValue();\n        }\n    }\n\n    /**\n     * Shortcut method for getting the text content of an Element.\n     *\n     * @return if there is a single Text child, return its value,\n     *         if there is no children, return \"\",\n     *         never <code>null</code>.\n     * @throws SAXParseException\n     *         if there are more than one children or one non-Text child\n     */\n    public String getTextContent() throws SAXParseException {\n        String s = getTextContentOrNull();\n        if (s == null)\n            throw new SAXParseException(\"No text content\", this);\n        else\n            return s;\n    }\n\n    /**\n     * Shortcut method for getting the first Element child with a\n     * specified name.\n     *\n     * @return  the first child Element with the specified name,\n     *          or <code>null</code> if there is no such child.\n     */\n    public Element getFirstChildElementOrNull(String namespaceURI, String localName) {\n        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {\n            Element e = (Element) getChild(i);\n            if (e.getNamespaceURI().equals(namespaceURI) && e.getLocalName().equals(localName)) {\n                return e;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Shortcut method for getting the first Element child with a\n     * specified name.\n     *\n     * @return  the first child Element with the specified name,\n     *          never <code>null</code>.\n     * @throws SAXParseException\n     *         if there is no such child.\n     */\n    public Element getFirstChildElement(String namespaceURI, String localName) throws SAXParseException {\n        Element e = getFirstChildElementOrNull(namespaceURI, localName);\n        if (e == null)\n            throw new SAXParseException(\"Element {\" + namespaceURI + \"}\" + localName + \" expected\", this);\n        else\n            return e;\n    }\n\n    /**\n     * Shortcut method for getting the first Element children with any name.\n     *\n     * @return  the first child Element\n     *          or <code>null</code> if there are no Element children.\n     */\n    public Element getFirstChildElementOrNull() {\n        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {\n            return (Element) getChild(i);\n        }\n        return null;\n    }\n\n    /**\n     * Shortcut method for getting the first Element children with any name.\n     *\n     * @return  the first child Element\n     *          never <code>null</code>.\n     * @throws SAXParseException\n     *         if there are no Element children.\n     */\n    public Element getFirstChildElement() throws SAXParseException {\n        Element e = getFirstChildElementOrNull();\n        if (e == null)\n            throw new SAXParseException(\"Element expected\", this);\n        else\n            return e;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/xtree/ElementTest0.java",
		"test_prompt": "// ElementTest0.java\npackage nu.staldal.xtree;\n\nimport java.util.Vector;\nimport java.net.URL;\nimport org.xml.sax.*;\nimport org.xml.sax.helpers.AttributesImpl;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Element}.\n* It contains ten unit test cases for the {@link Element#lookupAttribute(String, String)} method.\n*/\nclass ElementTest0 {"
	},
	{
		"original_code": "// Element.java\n/*\n * Copyright (c) 2001, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.xtree;\n\nimport java.util.Vector;\nimport java.net.URL;\nimport org.xml.sax.*;\nimport org.xml.sax.helpers.AttributesImpl;\n\n/**\n * An XML Element.\n */\npublic class Element extends NodeWithChildren {\n\n    static final long serialVersionUID = -1804355746259349573L;\n\n    final String namespaceURI;\n\n    final String localName;\n\n    URL baseURI = null;\n\n    Vector attrName;\n\n    Vector attrValue;\n\n    Vector attrType;\n\n    Vector namespacePrefixes;\n\n    Vector namespaceURIs;\n\n    char xmlSpaceAttribute = ' ';\n\n    /**\n     * Construct an element.\n     *\n     * @param namespaceURI  the namespace URI for this element,\n     *                      may be the empty string\n     * @param localName\tthe element name\n     */\n    public Element(String namespaceURI, String localName) {\n        this(namespaceURI, localName, -1, -1);\n    }\n\n    /**\n     * Construct an element.\n     *\n     * @param namespaceURI  the namespace URI for this element,\n     *                      may be the empty string\n     * @param localName\tthe element name\n     * @param numberOfAttributes  the number of attributes this element should have\n     */\n    public Element(String namespaceURI, String localName, int numberOfAttributes) {\n        this(namespaceURI, localName, numberOfAttributes, -1);\n    }\n\n    /**\n     * Construct an element.\n     *\n     * @param namespaceURI  the namespace URI for this element,\n     *                      may be the empty string\n     * @param localName\tthe name of this element (no namespace)\n     * @param numberOfAttributes  the number of attributes this element should have\n     * @param numberOfChildren  the number of children this element should have\n     */\n    public Element(String namespaceURI, String localName, int numberOfAttributes, int numberOfChildren) {\n        super(numberOfChildren);\n        if (namespaceURI == null)\n            namespaceURI = \"\";\n        if (localName == null)\n            throw new NullPointerException(\"LocalName may not be null\");\n        if (numberOfAttributes >= 0) {\n            attrName = new Vector(numberOfAttributes);\n            attrValue = new Vector(numberOfAttributes);\n            attrType = new Vector(numberOfAttributes);\n        } else {\n            attrName = new Vector();\n            attrValue = new Vector();\n            attrType = new Vector();\n        }\n        namespaceURIs = new Vector();\n        namespacePrefixes = new Vector();\n        this.namespaceURI = namespaceURI;\n        this.localName = localName;\n    }\n\n    /**\n     * Get the namespace URI for this element. May be the empty string.\n     */\n    public String getNamespaceURI() {\n        return namespaceURI;\n    }\n\n    /**\n     * Get the name of this element.\n     * The name does not include namespace URI or prefix.\n     */\n    public String getLocalName() {\n        return localName;\n    }\n\n    /**\n     * Lookup the index of an attribute to this element. The returned index\n     * may be used as argument to other methods in this class.\n     *\n     * @param namespaceURI  the namespace URI, may be the empty string\n     * @param localName  the name\n     * @return the index of the attribute, or -1 if no such attribute exists\n     *\n     * @see #getAttributeValue\n     * @see #getAttributeType\n     * @see #removeAttribute\n     */\n    public int lookupAttribute(String namespaceURI, String localName) {\n        return attrName.indexOf(localName + '^' + namespaceURI);\n    }\n\n    /**\n     * Add an attribute to this element.\n     *\n     * The attribute type is one of the strings\n     * \"CDATA\", \"ID\", \"IDREF\", \"IDREFS\", \"NMTOKEN\", \"NMTOKENS\",\n     * \"ENTITY\", \"ENTITIES\", or \"NOTATION\" (always in upper case).\n     *\n     * @param namespaceURI  the namespace URI, may be the empty string\n     * @param localName  the name\n     * @param type  the type (use \"CDATA\" if the type is irrelevant)\n     * @param value  the value\n     */\n    public void addAttribute(String namespaceURI, String localName, String type, String value) {\n        attrName.addElement(localName + '^' + namespaceURI);\n        attrType.addElement(type);\n        attrValue.addElement(value);\n        if (namespaceURI.equals(XML_NS) && localName.equals(\"space\")) {\n            if (value.equals(\"preserve\"))\n                xmlSpaceAttribute = 'p';\n            else if (value.equals(\"default\"))\n                xmlSpaceAttribute = 'd';\n        }\n    }\n\n    /**\n     * Remove an attribute at the specified index.\n     * This method is a bit inefficient.\n     *\n     * @param index  the index as returned from {@link #lookupAttribute}\n     * @throws IndexOutOfBoundException  if no such attribute exist.\n     */\n    public void removeAttribute(int index) throws IndexOutOfBoundsException {\n        attrName.removeElementAt(index);\n        attrType.removeElementAt(index);\n        attrValue.removeElementAt(index);\n    }\n\n    /**\n     * Return the number of attributes this element have.\n     */\n    public int numberOfAttributes() {\n        return attrName.size();\n    }\n\n    /**\n     * Get the namespace URI for the attribute at the specified index.\n     *\n     * @param index  the index as returned from {@link #lookupAttribute}\n     *\n     * @return the namespace URI, may be (and is usually) the empty string,\n     *         or <code>null</code> if index is -1\n     * @throws IndexOutOfBoundsException  if no such attribute exist.\n     */\n    public String getAttributeNamespaceURI(int index) throws IndexOutOfBoundsException {\n        if (index == -1)\n            return null;\n        String s = (String) attrName.elementAt(index);\n        return s.substring(s.indexOf('^') + 1);\n    }\n\n    /**\n     * Get the name of the attribute at the specified index.\n     *\n     * @param index  the index as returned from {@link #lookupAttribute}\n     *\n     * @return the localName,\n     *         or <code>null</code> if index is -1\n     * @throws IndexOutOfBoundsException  if no such attribute exist.\n     */\n    public String getAttributeLocalName(int index) throws IndexOutOfBoundsException {\n        if (index == -1)\n            return null;\n        String s = (String) attrName.elementAt(index);\n        return s.substring(0, s.indexOf('^'));\n    }\n\n    /**\n     * Get the type of the attribute at the specified index.\n     *\n     * The attribute type is one of the strings\n     * \"CDATA\", \"ID\", \"IDREF\", \"IDREFS\", \"NMTOKEN\", \"NMTOKENS\",\n     * \"ENTITY\", \"ENTITIES\", or \"NOTATION\" (always in upper case).\n     *\n     * @return the attribute type,\n     *         or <code>null</code> if index is -1\n     * @param index  the index as returned from {@link #lookupAttribute}\n     * @throws IndexOutOfBoundsException  if no such attribute exist.\n     */\n    public String getAttributeType(int index) throws IndexOutOfBoundsException {\n        if (index == -1)\n            return null;\n        return (String) attrType.elementAt(index);\n    }\n\n    /**\n     * Get the value of the attribute at the specified index.\n     *\n     * @return the attribute value,\n     *         or <code>null</code> if index is -1\n     * @param index  the index as returned from {@link #lookupAttribute}\n     * @throws IndexOutOfBoundsException  if no such attribute exist.\n     */\n    public String getAttributeValue(int index) throws IndexOutOfBoundsException {\n        if (index == -1)\n            return null;\n        return (String) attrValue.elementAt(index);\n    }\n\n    void setNamespaceMappings(Vector prefixes, Vector URIs) {\n        namespacePrefixes = prefixes;\n        namespaceURIs = URIs;\n    }\n\n    /**\n     * Add a namespace mapping to this element.\n     *\n     * @param prefix  the prefix\n     * @param URI  the namespace URI\n     */\n    public void addNamespaceMapping(String prefix, String URI) {\n        namespacePrefixes.addElement(prefix);\n        namespaceURIs.addElement(URI);\n    }\n\n    /**\n     * Return the number of namespace mapping for this element.\n     */\n    public int numberOfNamespaceMappings() {\n        return namespacePrefixes.size();\n    }\n\n    /**\n     * Return a namespace mapping at the specified index.\n     *\n     * @return a String[] with [0] = prefix, [1] = namespace URI\n     * @throws IndexOutOfBoundsException  if no such mapping exist.\n     */\n    public String[] getNamespaceMapping(int index) throws IndexOutOfBoundsException {\n        return new String[] { (String) namespacePrefixes.elementAt(index), (String) namespaceURIs.elementAt(index) };\n    }\n\n    public String lookupNamespaceURI(String prefix) {\n        int index = namespacePrefixes.indexOf(prefix);\n        if (index == -1) {\n            if (parent != null) {\n                return parent.lookupNamespaceURI(prefix);\n            } else {\n                if (prefix.length() == 0) {\n                    return \"\";\n                } else {\n                    return null;\n                }\n            }\n        } else {\n            return (String) namespaceURIs.elementAt(index);\n        }\n    }\n\n    public String lookupNamespacePrefix(String URI) {\n        int index = namespaceURI.indexOf(URI);\n        if (index == -1) {\n            if (parent != null) {\n                return parent.lookupNamespacePrefix(URI);\n            } else {\n                if (URI.length() == 0) {\n                    return \"\";\n                } else {\n                    return null;\n                }\n            }\n        } else {\n            return (String) namespacePrefixes.elementAt(index);\n        }\n    }\n\n    /**\n     * Set the baseURI property of this element.\n     *\n     * @param URI  the base URI, must be absolute\n     */\n    public void setBaseURI(URL URI) {\n        baseURI = URI;\n    }\n\n    public URL getBaseURI() {\n        if (baseURI != null) {\n            return baseURI;\n        } else {\n            if (parent != null) {\n                return parent.getBaseURI();\n            } else {\n                return null;\n            }\n        }\n    }\n\n    public boolean getPreserveSpace() {\n        switch(xmlSpaceAttribute) {\n            case 'p':\n                return true;\n            case 'd':\n                return false;\n            default:\n                if (parent != null) {\n                    return parent.getPreserveSpace();\n                } else {\n                    return false;\n                }\n        }\n    }\n\n    public String getInheritedAttribute(String namespaceURI, String localName) {\n        String val = getAttrValueOrNull(namespaceURI, localName);\n        if (val != null)\n            return val;\n        else if (parent == null)\n            return null;\n        else\n            return parent.getInheritedAttribute(namespaceURI, localName);\n    }\n\n    /**\n     * Fire the startElement event to the given SAX2 ContentHandler.\n     * Will also fire startPrefixMapping events.\n     */\n    public void outputStartElement(ContentHandler sax) throws SAXException {\n        for (int i = 0; i < namespacePrefixes.size(); i++) {\n            sax.startPrefixMapping((String) namespacePrefixes.elementAt(i), (String) namespaceURIs.elementAt(i));\n        }\n        AttributesImpl atts = new AttributesImpl();\n        for (int i = 0; i < attrName.size(); i++) {\n            String s = (String) attrName.elementAt(i);\n            String URI = s.substring(s.indexOf('^') + 1);\n            String local = s.substring(0, s.indexOf('^'));\n            atts.addAttribute(URI, local, \"\", (String) attrType.elementAt(i), (String) attrValue.elementAt(i));\n        }\n        sax.startElement(namespaceURI, localName, \"\", atts);\n    }\n\n    /**\n     * Fire the endElement event to the given SAX2 ContentHandler.\n     * Will also fire endPrefixMapping events.\n     */\n    public void outputEndElement(ContentHandler sax) throws SAXException {\n        sax.endElement(namespaceURI, localName, \"\");\n        for (int i = 0; i < namespacePrefixes.size(); i++) {\n            sax.endPrefixMapping((String) namespacePrefixes.elementAt(i));\n        }\n    }\n\n    public void toSAX(ContentHandler sax) throws SAXException {\n        outputStartElement(sax);\n        for (int i = 0; i < numberOfChildren(); i++) {\n            getChild(i).toSAX(sax);\n        }\n        outputEndElement(sax);\n    }\n\n    /**\n     * Shortcut method for getting the value of an attribute without\n     * namespace.\n     *\n     * @return the attrubute value, or <code>null</code>\n     * \t\tif the attribute doesn't exist\n     */\n    public String getAttrValueOrNull(String localName) {\n        return getAttributeValue(lookupAttribute(\"\", localName));\n    }\n\n    /**\n     * Shortcut method for getting the value of an attribute without\n     * namespace.\n     *\n     * @return the attrubute value, never <code>null</code>\n     * @throws SAXParseException if the attribute doesn't exist\n     */\n    public String getAttrValue(String localName) throws SAXParseException {\n        String v = getAttrValueOrNull(localName);\n        if (v == null)\n            throw new SAXParseException(\"Attribute \" + localName + \" expected\", this);\n        else\n            return v;\n    }\n\n    /**\n     * Shortcut method for getting the value of an attribute with\n     * namespace.\n     *\n     * @return the attrubute value, or <code>null</code>\n     * \t\tif the attribute doesn't exist\n     */\n    public String getAttrValueOrNull(String namespaceURI, String localName) {\n        return getAttributeValue(lookupAttribute(namespaceURI, localName));\n    }\n\n    /**\n     * Shortcut method for getting the value of an attribute with\n     * namespace.\n     *\n     * @return the attrubute value, never <code>null</code>\n     * @throws SAXParseException if the attribute doesn't exist\n     */\n    public String getAttrValue(String namespaceURI, String localName) throws SAXParseException {\n        String v = getAttrValueOrNull(namespaceURI, localName);\n        if (v == null)\n            throw new SAXParseException(\"Attribute {\" + namespaceURI + \"}\" + localName + \" expected\", this);\n        else\n            return v;\n    }\n\n    /**\n     * Shortcut method for getting the text content of an Element.\n     *\n     * @return if there is a single Text child, return its value,\n     *         if there is no children, return \"\",\n     *         or <code>null</code>\n     *         if there are more than one children or one non-Text child\n     */\n    public String getTextContentOrNull() {\n        if (numberOfChildren() == 0) {\n            return \"\";\n        } else if (numberOfChildren() > 1) {\n            return null;\n        } else {\n            Node node = getChild(0);\n            if (!(node instanceof Text))\n                return null;\n            return ((Text) node).getValue();\n        }\n    }\n\n    /**\n     * Shortcut method for getting the text content of an Element.\n     *\n     * @return if there is a single Text child, return its value,\n     *         if there is no children, return \"\",\n     *         never <code>null</code>.\n     * @throws SAXParseException\n     *         if there are more than one children or one non-Text child\n     */\n    public String getTextContent() throws SAXParseException {\n        String s = getTextContentOrNull();\n        if (s == null)\n            throw new SAXParseException(\"No text content\", this);\n        else\n            return s;\n    }\n\n    /**\n     * Shortcut method for getting the first Element child with a\n     * specified name.\n     *\n     * @return  the first child Element with the specified name,\n     *          or <code>null</code> if there is no such child.\n     */\n    public Element getFirstChildElementOrNull(String namespaceURI, String localName) {\n        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {\n            Element e = (Element) getChild(i);\n            if (e.getNamespaceURI().equals(namespaceURI) && e.getLocalName().equals(localName)) {\n                return e;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Shortcut method for getting the first Element child with a\n     * specified name.\n     *\n     * @return  the first child Element with the specified name,\n     *          never <code>null</code>.\n     * @throws SAXParseException\n     *         if there is no such child.\n     */\n    public Element getFirstChildElement(String namespaceURI, String localName) throws SAXParseException {\n        Element e = getFirstChildElementOrNull(namespaceURI, localName);\n        if (e == null)\n            throw new SAXParseException(\"Element {\" + namespaceURI + \"}\" + localName + \" expected\", this);\n        else\n            return e;\n    }\n\n    /**\n     * Shortcut method for getting the first Element children with any name.\n     *\n     * @return  the first child Element\n     *          or <code>null</code> if there are no Element children.\n     */\n    public Element getFirstChildElementOrNull() {\n        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {\n            return (Element) getChild(i);\n        }\n        return null;\n    }\n\n    /**\n     * Shortcut method for getting the first Element children with any name.\n     *\n     * @return  the first child Element\n     *          never <code>null</code>.\n     * @throws SAXParseException\n     *         if there are no Element children.\n     */\n    public Element getFirstChildElement() throws SAXParseException {\n        Element e = getFirstChildElementOrNull();\n        if (e == null)\n            throw new SAXParseException(\"Element expected\", this);\n        else\n            return e;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/xtree/ElementTest1.java",
		"test_prompt": "// ElementTest1.java\npackage nu.staldal.xtree;\n\nimport java.util.Vector;\nimport java.net.URL;\nimport org.xml.sax.*;\nimport org.xml.sax.helpers.AttributesImpl;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Element}.\n* It contains ten unit test cases for the {@link Element#numberOfAttributes()} method.\n*/\nclass ElementTest1 {"
	},
	{
		"original_code": "// Element.java\n/*\n * Copyright (c) 2001, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.xtree;\n\nimport java.util.Vector;\nimport java.net.URL;\nimport org.xml.sax.*;\nimport org.xml.sax.helpers.AttributesImpl;\n\n/**\n * An XML Element.\n */\npublic class Element extends NodeWithChildren {\n\n    static final long serialVersionUID = -1804355746259349573L;\n\n    final String namespaceURI;\n\n    final String localName;\n\n    URL baseURI = null;\n\n    Vector attrName;\n\n    Vector attrValue;\n\n    Vector attrType;\n\n    Vector namespacePrefixes;\n\n    Vector namespaceURIs;\n\n    char xmlSpaceAttribute = ' ';\n\n    /**\n     * Construct an element.\n     *\n     * @param namespaceURI  the namespace URI for this element,\n     *                      may be the empty string\n     * @param localName\tthe element name\n     */\n    public Element(String namespaceURI, String localName) {\n        this(namespaceURI, localName, -1, -1);\n    }\n\n    /**\n     * Construct an element.\n     *\n     * @param namespaceURI  the namespace URI for this element,\n     *                      may be the empty string\n     * @param localName\tthe element name\n     * @param numberOfAttributes  the number of attributes this element should have\n     */\n    public Element(String namespaceURI, String localName, int numberOfAttributes) {\n        this(namespaceURI, localName, numberOfAttributes, -1);\n    }\n\n    /**\n     * Construct an element.\n     *\n     * @param namespaceURI  the namespace URI for this element,\n     *                      may be the empty string\n     * @param localName\tthe name of this element (no namespace)\n     * @param numberOfAttributes  the number of attributes this element should have\n     * @param numberOfChildren  the number of children this element should have\n     */\n    public Element(String namespaceURI, String localName, int numberOfAttributes, int numberOfChildren) {\n        super(numberOfChildren);\n        if (namespaceURI == null)\n            namespaceURI = \"\";\n        if (localName == null)\n            throw new NullPointerException(\"LocalName may not be null\");\n        if (numberOfAttributes >= 0) {\n            attrName = new Vector(numberOfAttributes);\n            attrValue = new Vector(numberOfAttributes);\n            attrType = new Vector(numberOfAttributes);\n        } else {\n            attrName = new Vector();\n            attrValue = new Vector();\n            attrType = new Vector();\n        }\n        namespaceURIs = new Vector();\n        namespacePrefixes = new Vector();\n        this.namespaceURI = namespaceURI;\n        this.localName = localName;\n    }\n\n    /**\n     * Get the namespace URI for this element. May be the empty string.\n     */\n    public String getNamespaceURI() {\n        return namespaceURI;\n    }\n\n    /**\n     * Get the name of this element.\n     * The name does not include namespace URI or prefix.\n     */\n    public String getLocalName() {\n        return localName;\n    }\n\n    /**\n     * Lookup the index of an attribute to this element. The returned index\n     * may be used as argument to other methods in this class.\n     *\n     * @param namespaceURI  the namespace URI, may be the empty string\n     * @param localName  the name\n     * @return the index of the attribute, or -1 if no such attribute exists\n     *\n     * @see #getAttributeValue\n     * @see #getAttributeType\n     * @see #removeAttribute\n     */\n    public int lookupAttribute(String namespaceURI, String localName) {\n        return attrName.indexOf(localName + '^' + namespaceURI);\n    }\n\n    /**\n     * Add an attribute to this element.\n     *\n     * The attribute type is one of the strings\n     * \"CDATA\", \"ID\", \"IDREF\", \"IDREFS\", \"NMTOKEN\", \"NMTOKENS\",\n     * \"ENTITY\", \"ENTITIES\", or \"NOTATION\" (always in upper case).\n     *\n     * @param namespaceURI  the namespace URI, may be the empty string\n     * @param localName  the name\n     * @param type  the type (use \"CDATA\" if the type is irrelevant)\n     * @param value  the value\n     */\n    public void addAttribute(String namespaceURI, String localName, String type, String value) {\n        attrName.addElement(localName + '^' + namespaceURI);\n        attrType.addElement(type);\n        attrValue.addElement(value);\n        if (namespaceURI.equals(XML_NS) && localName.equals(\"space\")) {\n            if (value.equals(\"preserve\"))\n                xmlSpaceAttribute = 'p';\n            else if (value.equals(\"default\"))\n                xmlSpaceAttribute = 'd';\n        }\n    }\n\n    /**\n     * Remove an attribute at the specified index.\n     * This method is a bit inefficient.\n     *\n     * @param index  the index as returned from {@link #lookupAttribute}\n     * @throws IndexOutOfBoundException  if no such attribute exist.\n     */\n    public void removeAttribute(int index) throws IndexOutOfBoundsException {\n        attrName.removeElementAt(index);\n        attrType.removeElementAt(index);\n        attrValue.removeElementAt(index);\n    }\n\n    /**\n     * Return the number of attributes this element have.\n     */\n    public int numberOfAttributes() {\n        return attrName.size();\n    }\n\n    /**\n     * Get the namespace URI for the attribute at the specified index.\n     *\n     * @param index  the index as returned from {@link #lookupAttribute}\n     *\n     * @return the namespace URI, may be (and is usually) the empty string,\n     *         or <code>null</code> if index is -1\n     * @throws IndexOutOfBoundsException  if no such attribute exist.\n     */\n    public String getAttributeNamespaceURI(int index) throws IndexOutOfBoundsException {\n        if (index == -1)\n            return null;\n        String s = (String) attrName.elementAt(index);\n        return s.substring(s.indexOf('^') + 1);\n    }\n\n    /**\n     * Get the name of the attribute at the specified index.\n     *\n     * @param index  the index as returned from {@link #lookupAttribute}\n     *\n     * @return the localName,\n     *         or <code>null</code> if index is -1\n     * @throws IndexOutOfBoundsException  if no such attribute exist.\n     */\n    public String getAttributeLocalName(int index) throws IndexOutOfBoundsException {\n        if (index == -1)\n            return null;\n        String s = (String) attrName.elementAt(index);\n        return s.substring(0, s.indexOf('^'));\n    }\n\n    /**\n     * Get the type of the attribute at the specified index.\n     *\n     * The attribute type is one of the strings\n     * \"CDATA\", \"ID\", \"IDREF\", \"IDREFS\", \"NMTOKEN\", \"NMTOKENS\",\n     * \"ENTITY\", \"ENTITIES\", or \"NOTATION\" (always in upper case).\n     *\n     * @return the attribute type,\n     *         or <code>null</code> if index is -1\n     * @param index  the index as returned from {@link #lookupAttribute}\n     * @throws IndexOutOfBoundsException  if no such attribute exist.\n     */\n    public String getAttributeType(int index) throws IndexOutOfBoundsException {\n        if (index == -1)\n            return null;\n        return (String) attrType.elementAt(index);\n    }\n\n    /**\n     * Get the value of the attribute at the specified index.\n     *\n     * @return the attribute value,\n     *         or <code>null</code> if index is -1\n     * @param index  the index as returned from {@link #lookupAttribute}\n     * @throws IndexOutOfBoundsException  if no such attribute exist.\n     */\n    public String getAttributeValue(int index) throws IndexOutOfBoundsException {\n        if (index == -1)\n            return null;\n        return (String) attrValue.elementAt(index);\n    }\n\n    void setNamespaceMappings(Vector prefixes, Vector URIs) {\n        namespacePrefixes = prefixes;\n        namespaceURIs = URIs;\n    }\n\n    /**\n     * Add a namespace mapping to this element.\n     *\n     * @param prefix  the prefix\n     * @param URI  the namespace URI\n     */\n    public void addNamespaceMapping(String prefix, String URI) {\n        namespacePrefixes.addElement(prefix);\n        namespaceURIs.addElement(URI);\n    }\n\n    /**\n     * Return the number of namespace mapping for this element.\n     */\n    public int numberOfNamespaceMappings() {\n        return namespacePrefixes.size();\n    }\n\n    /**\n     * Return a namespace mapping at the specified index.\n     *\n     * @return a String[] with [0] = prefix, [1] = namespace URI\n     * @throws IndexOutOfBoundsException  if no such mapping exist.\n     */\n    public String[] getNamespaceMapping(int index) throws IndexOutOfBoundsException {\n        return new String[] { (String) namespacePrefixes.elementAt(index), (String) namespaceURIs.elementAt(index) };\n    }\n\n    public String lookupNamespaceURI(String prefix) {\n        int index = namespacePrefixes.indexOf(prefix);\n        if (index == -1) {\n            if (parent != null) {\n                return parent.lookupNamespaceURI(prefix);\n            } else {\n                if (prefix.length() == 0) {\n                    return \"\";\n                } else {\n                    return null;\n                }\n            }\n        } else {\n            return (String) namespaceURIs.elementAt(index);\n        }\n    }\n\n    public String lookupNamespacePrefix(String URI) {\n        int index = namespaceURI.indexOf(URI);\n        if (index == -1) {\n            if (parent != null) {\n                return parent.lookupNamespacePrefix(URI);\n            } else {\n                if (URI.length() == 0) {\n                    return \"\";\n                } else {\n                    return null;\n                }\n            }\n        } else {\n            return (String) namespacePrefixes.elementAt(index);\n        }\n    }\n\n    /**\n     * Set the baseURI property of this element.\n     *\n     * @param URI  the base URI, must be absolute\n     */\n    public void setBaseURI(URL URI) {\n        baseURI = URI;\n    }\n\n    public URL getBaseURI() {\n        if (baseURI != null) {\n            return baseURI;\n        } else {\n            if (parent != null) {\n                return parent.getBaseURI();\n            } else {\n                return null;\n            }\n        }\n    }\n\n    public boolean getPreserveSpace() {\n        switch(xmlSpaceAttribute) {\n            case 'p':\n                return true;\n            case 'd':\n                return false;\n            default:\n                if (parent != null) {\n                    return parent.getPreserveSpace();\n                } else {\n                    return false;\n                }\n        }\n    }\n\n    public String getInheritedAttribute(String namespaceURI, String localName) {\n        String val = getAttrValueOrNull(namespaceURI, localName);\n        if (val != null)\n            return val;\n        else if (parent == null)\n            return null;\n        else\n            return parent.getInheritedAttribute(namespaceURI, localName);\n    }\n\n    /**\n     * Fire the startElement event to the given SAX2 ContentHandler.\n     * Will also fire startPrefixMapping events.\n     */\n    public void outputStartElement(ContentHandler sax) throws SAXException {\n        for (int i = 0; i < namespacePrefixes.size(); i++) {\n            sax.startPrefixMapping((String) namespacePrefixes.elementAt(i), (String) namespaceURIs.elementAt(i));\n        }\n        AttributesImpl atts = new AttributesImpl();\n        for (int i = 0; i < attrName.size(); i++) {\n            String s = (String) attrName.elementAt(i);\n            String URI = s.substring(s.indexOf('^') + 1);\n            String local = s.substring(0, s.indexOf('^'));\n            atts.addAttribute(URI, local, \"\", (String) attrType.elementAt(i), (String) attrValue.elementAt(i));\n        }\n        sax.startElement(namespaceURI, localName, \"\", atts);\n    }\n\n    /**\n     * Fire the endElement event to the given SAX2 ContentHandler.\n     * Will also fire endPrefixMapping events.\n     */\n    public void outputEndElement(ContentHandler sax) throws SAXException {\n        sax.endElement(namespaceURI, localName, \"\");\n        for (int i = 0; i < namespacePrefixes.size(); i++) {\n            sax.endPrefixMapping((String) namespacePrefixes.elementAt(i));\n        }\n    }\n\n    public void toSAX(ContentHandler sax) throws SAXException {\n        outputStartElement(sax);\n        for (int i = 0; i < numberOfChildren(); i++) {\n            getChild(i).toSAX(sax);\n        }\n        outputEndElement(sax);\n    }\n\n    /**\n     * Shortcut method for getting the value of an attribute without\n     * namespace.\n     *\n     * @return the attrubute value, or <code>null</code>\n     * \t\tif the attribute doesn't exist\n     */\n    public String getAttrValueOrNull(String localName) {\n        return getAttributeValue(lookupAttribute(\"\", localName));\n    }\n\n    /**\n     * Shortcut method for getting the value of an attribute without\n     * namespace.\n     *\n     * @return the attrubute value, never <code>null</code>\n     * @throws SAXParseException if the attribute doesn't exist\n     */\n    public String getAttrValue(String localName) throws SAXParseException {\n        String v = getAttrValueOrNull(localName);\n        if (v == null)\n            throw new SAXParseException(\"Attribute \" + localName + \" expected\", this);\n        else\n            return v;\n    }\n\n    /**\n     * Shortcut method for getting the value of an attribute with\n     * namespace.\n     *\n     * @return the attrubute value, or <code>null</code>\n     * \t\tif the attribute doesn't exist\n     */\n    public String getAttrValueOrNull(String namespaceURI, String localName) {\n        return getAttributeValue(lookupAttribute(namespaceURI, localName));\n    }\n\n    /**\n     * Shortcut method for getting the value of an attribute with\n     * namespace.\n     *\n     * @return the attrubute value, never <code>null</code>\n     * @throws SAXParseException if the attribute doesn't exist\n     */\n    public String getAttrValue(String namespaceURI, String localName) throws SAXParseException {\n        String v = getAttrValueOrNull(namespaceURI, localName);\n        if (v == null)\n            throw new SAXParseException(\"Attribute {\" + namespaceURI + \"}\" + localName + \" expected\", this);\n        else\n            return v;\n    }\n\n    /**\n     * Shortcut method for getting the text content of an Element.\n     *\n     * @return if there is a single Text child, return its value,\n     *         if there is no children, return \"\",\n     *         or <code>null</code>\n     *         if there are more than one children or one non-Text child\n     */\n    public String getTextContentOrNull() {\n        if (numberOfChildren() == 0) {\n            return \"\";\n        } else if (numberOfChildren() > 1) {\n            return null;\n        } else {\n            Node node = getChild(0);\n            if (!(node instanceof Text))\n                return null;\n            return ((Text) node).getValue();\n        }\n    }\n\n    /**\n     * Shortcut method for getting the text content of an Element.\n     *\n     * @return if there is a single Text child, return its value,\n     *         if there is no children, return \"\",\n     *         never <code>null</code>.\n     * @throws SAXParseException\n     *         if there are more than one children or one non-Text child\n     */\n    public String getTextContent() throws SAXParseException {\n        String s = getTextContentOrNull();\n        if (s == null)\n            throw new SAXParseException(\"No text content\", this);\n        else\n            return s;\n    }\n\n    /**\n     * Shortcut method for getting the first Element child with a\n     * specified name.\n     *\n     * @return  the first child Element with the specified name,\n     *          or <code>null</code> if there is no such child.\n     */\n    public Element getFirstChildElementOrNull(String namespaceURI, String localName) {\n        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {\n            Element e = (Element) getChild(i);\n            if (e.getNamespaceURI().equals(namespaceURI) && e.getLocalName().equals(localName)) {\n                return e;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Shortcut method for getting the first Element child with a\n     * specified name.\n     *\n     * @return  the first child Element with the specified name,\n     *          never <code>null</code>.\n     * @throws SAXParseException\n     *         if there is no such child.\n     */\n    public Element getFirstChildElement(String namespaceURI, String localName) throws SAXParseException {\n        Element e = getFirstChildElementOrNull(namespaceURI, localName);\n        if (e == null)\n            throw new SAXParseException(\"Element {\" + namespaceURI + \"}\" + localName + \" expected\", this);\n        else\n            return e;\n    }\n\n    /**\n     * Shortcut method for getting the first Element children with any name.\n     *\n     * @return  the first child Element\n     *          or <code>null</code> if there are no Element children.\n     */\n    public Element getFirstChildElementOrNull() {\n        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {\n            return (Element) getChild(i);\n        }\n        return null;\n    }\n\n    /**\n     * Shortcut method for getting the first Element children with any name.\n     *\n     * @return  the first child Element\n     *          never <code>null</code>.\n     * @throws SAXParseException\n     *         if there are no Element children.\n     */\n    public Element getFirstChildElement() throws SAXParseException {\n        Element e = getFirstChildElementOrNull();\n        if (e == null)\n            throw new SAXParseException(\"Element expected\", this);\n        else\n            return e;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/xtree/ElementTest2.java",
		"test_prompt": "// ElementTest2.java\npackage nu.staldal.xtree;\n\nimport java.util.Vector;\nimport java.net.URL;\nimport org.xml.sax.*;\nimport org.xml.sax.helpers.AttributesImpl;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Element}.\n* It contains ten unit test cases for the {@link Element#numberOfNamespaceMappings()} method.\n*/\nclass ElementTest2 {"
	},
	{
		"original_code": "// Element.java\n/*\n * Copyright (c) 2001, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.xtree;\n\nimport java.util.Vector;\nimport java.net.URL;\nimport org.xml.sax.*;\nimport org.xml.sax.helpers.AttributesImpl;\n\n/**\n * An XML Element.\n */\npublic class Element extends NodeWithChildren {\n\n    static final long serialVersionUID = -1804355746259349573L;\n\n    final String namespaceURI;\n\n    final String localName;\n\n    URL baseURI = null;\n\n    Vector attrName;\n\n    Vector attrValue;\n\n    Vector attrType;\n\n    Vector namespacePrefixes;\n\n    Vector namespaceURIs;\n\n    char xmlSpaceAttribute = ' ';\n\n    /**\n     * Construct an element.\n     *\n     * @param namespaceURI  the namespace URI for this element,\n     *                      may be the empty string\n     * @param localName\tthe element name\n     */\n    public Element(String namespaceURI, String localName) {\n        this(namespaceURI, localName, -1, -1);\n    }\n\n    /**\n     * Construct an element.\n     *\n     * @param namespaceURI  the namespace URI for this element,\n     *                      may be the empty string\n     * @param localName\tthe element name\n     * @param numberOfAttributes  the number of attributes this element should have\n     */\n    public Element(String namespaceURI, String localName, int numberOfAttributes) {\n        this(namespaceURI, localName, numberOfAttributes, -1);\n    }\n\n    /**\n     * Construct an element.\n     *\n     * @param namespaceURI  the namespace URI for this element,\n     *                      may be the empty string\n     * @param localName\tthe name of this element (no namespace)\n     * @param numberOfAttributes  the number of attributes this element should have\n     * @param numberOfChildren  the number of children this element should have\n     */\n    public Element(String namespaceURI, String localName, int numberOfAttributes, int numberOfChildren) {\n        super(numberOfChildren);\n        if (namespaceURI == null)\n            namespaceURI = \"\";\n        if (localName == null)\n            throw new NullPointerException(\"LocalName may not be null\");\n        if (numberOfAttributes >= 0) {\n            attrName = new Vector(numberOfAttributes);\n            attrValue = new Vector(numberOfAttributes);\n            attrType = new Vector(numberOfAttributes);\n        } else {\n            attrName = new Vector();\n            attrValue = new Vector();\n            attrType = new Vector();\n        }\n        namespaceURIs = new Vector();\n        namespacePrefixes = new Vector();\n        this.namespaceURI = namespaceURI;\n        this.localName = localName;\n    }\n\n    /**\n     * Get the namespace URI for this element. May be the empty string.\n     */\n    public String getNamespaceURI() {\n        return namespaceURI;\n    }\n\n    /**\n     * Get the name of this element.\n     * The name does not include namespace URI or prefix.\n     */\n    public String getLocalName() {\n        return localName;\n    }\n\n    /**\n     * Lookup the index of an attribute to this element. The returned index\n     * may be used as argument to other methods in this class.\n     *\n     * @param namespaceURI  the namespace URI, may be the empty string\n     * @param localName  the name\n     * @return the index of the attribute, or -1 if no such attribute exists\n     *\n     * @see #getAttributeValue\n     * @see #getAttributeType\n     * @see #removeAttribute\n     */\n    public int lookupAttribute(String namespaceURI, String localName) {\n        return attrName.indexOf(localName + '^' + namespaceURI);\n    }\n\n    /**\n     * Add an attribute to this element.\n     *\n     * The attribute type is one of the strings\n     * \"CDATA\", \"ID\", \"IDREF\", \"IDREFS\", \"NMTOKEN\", \"NMTOKENS\",\n     * \"ENTITY\", \"ENTITIES\", or \"NOTATION\" (always in upper case).\n     *\n     * @param namespaceURI  the namespace URI, may be the empty string\n     * @param localName  the name\n     * @param type  the type (use \"CDATA\" if the type is irrelevant)\n     * @param value  the value\n     */\n    public void addAttribute(String namespaceURI, String localName, String type, String value) {\n        attrName.addElement(localName + '^' + namespaceURI);\n        attrType.addElement(type);\n        attrValue.addElement(value);\n        if (namespaceURI.equals(XML_NS) && localName.equals(\"space\")) {\n            if (value.equals(\"preserve\"))\n                xmlSpaceAttribute = 'p';\n            else if (value.equals(\"default\"))\n                xmlSpaceAttribute = 'd';\n        }\n    }\n\n    /**\n     * Remove an attribute at the specified index.\n     * This method is a bit inefficient.\n     *\n     * @param index  the index as returned from {@link #lookupAttribute}\n     * @throws IndexOutOfBoundException  if no such attribute exist.\n     */\n    public void removeAttribute(int index) throws IndexOutOfBoundsException {\n        attrName.removeElementAt(index);\n        attrType.removeElementAt(index);\n        attrValue.removeElementAt(index);\n    }\n\n    /**\n     * Return the number of attributes this element have.\n     */\n    public int numberOfAttributes() {\n        return attrName.size();\n    }\n\n    /**\n     * Get the namespace URI for the attribute at the specified index.\n     *\n     * @param index  the index as returned from {@link #lookupAttribute}\n     *\n     * @return the namespace URI, may be (and is usually) the empty string,\n     *         or <code>null</code> if index is -1\n     * @throws IndexOutOfBoundsException  if no such attribute exist.\n     */\n    public String getAttributeNamespaceURI(int index) throws IndexOutOfBoundsException {\n        if (index == -1)\n            return null;\n        String s = (String) attrName.elementAt(index);\n        return s.substring(s.indexOf('^') + 1);\n    }\n\n    /**\n     * Get the name of the attribute at the specified index.\n     *\n     * @param index  the index as returned from {@link #lookupAttribute}\n     *\n     * @return the localName,\n     *         or <code>null</code> if index is -1\n     * @throws IndexOutOfBoundsException  if no such attribute exist.\n     */\n    public String getAttributeLocalName(int index) throws IndexOutOfBoundsException {\n        if (index == -1)\n            return null;\n        String s = (String) attrName.elementAt(index);\n        return s.substring(0, s.indexOf('^'));\n    }\n\n    /**\n     * Get the type of the attribute at the specified index.\n     *\n     * The attribute type is one of the strings\n     * \"CDATA\", \"ID\", \"IDREF\", \"IDREFS\", \"NMTOKEN\", \"NMTOKENS\",\n     * \"ENTITY\", \"ENTITIES\", or \"NOTATION\" (always in upper case).\n     *\n     * @return the attribute type,\n     *         or <code>null</code> if index is -1\n     * @param index  the index as returned from {@link #lookupAttribute}\n     * @throws IndexOutOfBoundsException  if no such attribute exist.\n     */\n    public String getAttributeType(int index) throws IndexOutOfBoundsException {\n        if (index == -1)\n            return null;\n        return (String) attrType.elementAt(index);\n    }\n\n    /**\n     * Get the value of the attribute at the specified index.\n     *\n     * @return the attribute value,\n     *         or <code>null</code> if index is -1\n     * @param index  the index as returned from {@link #lookupAttribute}\n     * @throws IndexOutOfBoundsException  if no such attribute exist.\n     */\n    public String getAttributeValue(int index) throws IndexOutOfBoundsException {\n        if (index == -1)\n            return null;\n        return (String) attrValue.elementAt(index);\n    }\n\n    void setNamespaceMappings(Vector prefixes, Vector URIs) {\n        namespacePrefixes = prefixes;\n        namespaceURIs = URIs;\n    }\n\n    /**\n     * Add a namespace mapping to this element.\n     *\n     * @param prefix  the prefix\n     * @param URI  the namespace URI\n     */\n    public void addNamespaceMapping(String prefix, String URI) {\n        namespacePrefixes.addElement(prefix);\n        namespaceURIs.addElement(URI);\n    }\n\n    /**\n     * Return the number of namespace mapping for this element.\n     */\n    public int numberOfNamespaceMappings() {\n        return namespacePrefixes.size();\n    }\n\n    /**\n     * Return a namespace mapping at the specified index.\n     *\n     * @return a String[] with [0] = prefix, [1] = namespace URI\n     * @throws IndexOutOfBoundsException  if no such mapping exist.\n     */\n    public String[] getNamespaceMapping(int index) throws IndexOutOfBoundsException {\n        return new String[] { (String) namespacePrefixes.elementAt(index), (String) namespaceURIs.elementAt(index) };\n    }\n\n    public String lookupNamespaceURI(String prefix) {\n        int index = namespacePrefixes.indexOf(prefix);\n        if (index == -1) {\n            if (parent != null) {\n                return parent.lookupNamespaceURI(prefix);\n            } else {\n                if (prefix.length() == 0) {\n                    return \"\";\n                } else {\n                    return null;\n                }\n            }\n        } else {\n            return (String) namespaceURIs.elementAt(index);\n        }\n    }\n\n    public String lookupNamespacePrefix(String URI) {\n        int index = namespaceURI.indexOf(URI);\n        if (index == -1) {\n            if (parent != null) {\n                return parent.lookupNamespacePrefix(URI);\n            } else {\n                if (URI.length() == 0) {\n                    return \"\";\n                } else {\n                    return null;\n                }\n            }\n        } else {\n            return (String) namespacePrefixes.elementAt(index);\n        }\n    }\n\n    /**\n     * Set the baseURI property of this element.\n     *\n     * @param URI  the base URI, must be absolute\n     */\n    public void setBaseURI(URL URI) {\n        baseURI = URI;\n    }\n\n    public URL getBaseURI() {\n        if (baseURI != null) {\n            return baseURI;\n        } else {\n            if (parent != null) {\n                return parent.getBaseURI();\n            } else {\n                return null;\n            }\n        }\n    }\n\n    public boolean getPreserveSpace() {\n        switch(xmlSpaceAttribute) {\n            case 'p':\n                return true;\n            case 'd':\n                return false;\n            default:\n                if (parent != null) {\n                    return parent.getPreserveSpace();\n                } else {\n                    return false;\n                }\n        }\n    }\n\n    public String getInheritedAttribute(String namespaceURI, String localName) {\n        String val = getAttrValueOrNull(namespaceURI, localName);\n        if (val != null)\n            return val;\n        else if (parent == null)\n            return null;\n        else\n            return parent.getInheritedAttribute(namespaceURI, localName);\n    }\n\n    /**\n     * Fire the startElement event to the given SAX2 ContentHandler.\n     * Will also fire startPrefixMapping events.\n     */\n    public void outputStartElement(ContentHandler sax) throws SAXException {\n        for (int i = 0; i < namespacePrefixes.size(); i++) {\n            sax.startPrefixMapping((String) namespacePrefixes.elementAt(i), (String) namespaceURIs.elementAt(i));\n        }\n        AttributesImpl atts = new AttributesImpl();\n        for (int i = 0; i < attrName.size(); i++) {\n            String s = (String) attrName.elementAt(i);\n            String URI = s.substring(s.indexOf('^') + 1);\n            String local = s.substring(0, s.indexOf('^'));\n            atts.addAttribute(URI, local, \"\", (String) attrType.elementAt(i), (String) attrValue.elementAt(i));\n        }\n        sax.startElement(namespaceURI, localName, \"\", atts);\n    }\n\n    /**\n     * Fire the endElement event to the given SAX2 ContentHandler.\n     * Will also fire endPrefixMapping events.\n     */\n    public void outputEndElement(ContentHandler sax) throws SAXException {\n        sax.endElement(namespaceURI, localName, \"\");\n        for (int i = 0; i < namespacePrefixes.size(); i++) {\n            sax.endPrefixMapping((String) namespacePrefixes.elementAt(i));\n        }\n    }\n\n    public void toSAX(ContentHandler sax) throws SAXException {\n        outputStartElement(sax);\n        for (int i = 0; i < numberOfChildren(); i++) {\n            getChild(i).toSAX(sax);\n        }\n        outputEndElement(sax);\n    }\n\n    /**\n     * Shortcut method for getting the value of an attribute without\n     * namespace.\n     *\n     * @return the attrubute value, or <code>null</code>\n     * \t\tif the attribute doesn't exist\n     */\n    public String getAttrValueOrNull(String localName) {\n        return getAttributeValue(lookupAttribute(\"\", localName));\n    }\n\n    /**\n     * Shortcut method for getting the value of an attribute without\n     * namespace.\n     *\n     * @return the attrubute value, never <code>null</code>\n     * @throws SAXParseException if the attribute doesn't exist\n     */\n    public String getAttrValue(String localName) throws SAXParseException {\n        String v = getAttrValueOrNull(localName);\n        if (v == null)\n            throw new SAXParseException(\"Attribute \" + localName + \" expected\", this);\n        else\n            return v;\n    }\n\n    /**\n     * Shortcut method for getting the value of an attribute with\n     * namespace.\n     *\n     * @return the attrubute value, or <code>null</code>\n     * \t\tif the attribute doesn't exist\n     */\n    public String getAttrValueOrNull(String namespaceURI, String localName) {\n        return getAttributeValue(lookupAttribute(namespaceURI, localName));\n    }\n\n    /**\n     * Shortcut method for getting the value of an attribute with\n     * namespace.\n     *\n     * @return the attrubute value, never <code>null</code>\n     * @throws SAXParseException if the attribute doesn't exist\n     */\n    public String getAttrValue(String namespaceURI, String localName) throws SAXParseException {\n        String v = getAttrValueOrNull(namespaceURI, localName);\n        if (v == null)\n            throw new SAXParseException(\"Attribute {\" + namespaceURI + \"}\" + localName + \" expected\", this);\n        else\n            return v;\n    }\n\n    /**\n     * Shortcut method for getting the text content of an Element.\n     *\n     * @return if there is a single Text child, return its value,\n     *         if there is no children, return \"\",\n     *         or <code>null</code>\n     *         if there are more than one children or one non-Text child\n     */\n    public String getTextContentOrNull() {\n        if (numberOfChildren() == 0) {\n            return \"\";\n        } else if (numberOfChildren() > 1) {\n            return null;\n        } else {\n            Node node = getChild(0);\n            if (!(node instanceof Text))\n                return null;\n            return ((Text) node).getValue();\n        }\n    }\n\n    /**\n     * Shortcut method for getting the text content of an Element.\n     *\n     * @return if there is a single Text child, return its value,\n     *         if there is no children, return \"\",\n     *         never <code>null</code>.\n     * @throws SAXParseException\n     *         if there are more than one children or one non-Text child\n     */\n    public String getTextContent() throws SAXParseException {\n        String s = getTextContentOrNull();\n        if (s == null)\n            throw new SAXParseException(\"No text content\", this);\n        else\n            return s;\n    }\n\n    /**\n     * Shortcut method for getting the first Element child with a\n     * specified name.\n     *\n     * @return  the first child Element with the specified name,\n     *          or <code>null</code> if there is no such child.\n     */\n    public Element getFirstChildElementOrNull(String namespaceURI, String localName) {\n        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {\n            Element e = (Element) getChild(i);\n            if (e.getNamespaceURI().equals(namespaceURI) && e.getLocalName().equals(localName)) {\n                return e;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Shortcut method for getting the first Element child with a\n     * specified name.\n     *\n     * @return  the first child Element with the specified name,\n     *          never <code>null</code>.\n     * @throws SAXParseException\n     *         if there is no such child.\n     */\n    public Element getFirstChildElement(String namespaceURI, String localName) throws SAXParseException {\n        Element e = getFirstChildElementOrNull(namespaceURI, localName);\n        if (e == null)\n            throw new SAXParseException(\"Element {\" + namespaceURI + \"}\" + localName + \" expected\", this);\n        else\n            return e;\n    }\n\n    /**\n     * Shortcut method for getting the first Element children with any name.\n     *\n     * @return  the first child Element\n     *          or <code>null</code> if there are no Element children.\n     */\n    public Element getFirstChildElementOrNull() {\n        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {\n            return (Element) getChild(i);\n        }\n        return null;\n    }\n\n    /**\n     * Shortcut method for getting the first Element children with any name.\n     *\n     * @return  the first child Element\n     *          never <code>null</code>.\n     * @throws SAXParseException\n     *         if there are no Element children.\n     */\n    public Element getFirstChildElement() throws SAXParseException {\n        Element e = getFirstChildElementOrNull();\n        if (e == null)\n            throw new SAXParseException(\"Element expected\", this);\n        else\n            return e;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/xtree/ElementTest3.java",
		"test_prompt": "// ElementTest3.java\npackage nu.staldal.xtree;\n\nimport java.util.Vector;\nimport java.net.URL;\nimport org.xml.sax.*;\nimport org.xml.sax.helpers.AttributesImpl;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Element}.\n* It contains ten unit test cases for the {@link Element#lookupNamespaceURI(String)} method.\n*/\nclass ElementTest3 {"
	},
	{
		"original_code": "// Element.java\n/*\n * Copyright (c) 2001, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.xtree;\n\nimport java.util.Vector;\nimport java.net.URL;\nimport org.xml.sax.*;\nimport org.xml.sax.helpers.AttributesImpl;\n\n/**\n * An XML Element.\n */\npublic class Element extends NodeWithChildren {\n\n    static final long serialVersionUID = -1804355746259349573L;\n\n    final String namespaceURI;\n\n    final String localName;\n\n    URL baseURI = null;\n\n    Vector attrName;\n\n    Vector attrValue;\n\n    Vector attrType;\n\n    Vector namespacePrefixes;\n\n    Vector namespaceURIs;\n\n    char xmlSpaceAttribute = ' ';\n\n    /**\n     * Construct an element.\n     *\n     * @param namespaceURI  the namespace URI for this element,\n     *                      may be the empty string\n     * @param localName\tthe element name\n     */\n    public Element(String namespaceURI, String localName) {\n        this(namespaceURI, localName, -1, -1);\n    }\n\n    /**\n     * Construct an element.\n     *\n     * @param namespaceURI  the namespace URI for this element,\n     *                      may be the empty string\n     * @param localName\tthe element name\n     * @param numberOfAttributes  the number of attributes this element should have\n     */\n    public Element(String namespaceURI, String localName, int numberOfAttributes) {\n        this(namespaceURI, localName, numberOfAttributes, -1);\n    }\n\n    /**\n     * Construct an element.\n     *\n     * @param namespaceURI  the namespace URI for this element,\n     *                      may be the empty string\n     * @param localName\tthe name of this element (no namespace)\n     * @param numberOfAttributes  the number of attributes this element should have\n     * @param numberOfChildren  the number of children this element should have\n     */\n    public Element(String namespaceURI, String localName, int numberOfAttributes, int numberOfChildren) {\n        super(numberOfChildren);\n        if (namespaceURI == null)\n            namespaceURI = \"\";\n        if (localName == null)\n            throw new NullPointerException(\"LocalName may not be null\");\n        if (numberOfAttributes >= 0) {\n            attrName = new Vector(numberOfAttributes);\n            attrValue = new Vector(numberOfAttributes);\n            attrType = new Vector(numberOfAttributes);\n        } else {\n            attrName = new Vector();\n            attrValue = new Vector();\n            attrType = new Vector();\n        }\n        namespaceURIs = new Vector();\n        namespacePrefixes = new Vector();\n        this.namespaceURI = namespaceURI;\n        this.localName = localName;\n    }\n\n    /**\n     * Get the namespace URI for this element. May be the empty string.\n     */\n    public String getNamespaceURI() {\n        return namespaceURI;\n    }\n\n    /**\n     * Get the name of this element.\n     * The name does not include namespace URI or prefix.\n     */\n    public String getLocalName() {\n        return localName;\n    }\n\n    /**\n     * Lookup the index of an attribute to this element. The returned index\n     * may be used as argument to other methods in this class.\n     *\n     * @param namespaceURI  the namespace URI, may be the empty string\n     * @param localName  the name\n     * @return the index of the attribute, or -1 if no such attribute exists\n     *\n     * @see #getAttributeValue\n     * @see #getAttributeType\n     * @see #removeAttribute\n     */\n    public int lookupAttribute(String namespaceURI, String localName) {\n        return attrName.indexOf(localName + '^' + namespaceURI);\n    }\n\n    /**\n     * Add an attribute to this element.\n     *\n     * The attribute type is one of the strings\n     * \"CDATA\", \"ID\", \"IDREF\", \"IDREFS\", \"NMTOKEN\", \"NMTOKENS\",\n     * \"ENTITY\", \"ENTITIES\", or \"NOTATION\" (always in upper case).\n     *\n     * @param namespaceURI  the namespace URI, may be the empty string\n     * @param localName  the name\n     * @param type  the type (use \"CDATA\" if the type is irrelevant)\n     * @param value  the value\n     */\n    public void addAttribute(String namespaceURI, String localName, String type, String value) {\n        attrName.addElement(localName + '^' + namespaceURI);\n        attrType.addElement(type);\n        attrValue.addElement(value);\n        if (namespaceURI.equals(XML_NS) && localName.equals(\"space\")) {\n            if (value.equals(\"preserve\"))\n                xmlSpaceAttribute = 'p';\n            else if (value.equals(\"default\"))\n                xmlSpaceAttribute = 'd';\n        }\n    }\n\n    /**\n     * Remove an attribute at the specified index.\n     * This method is a bit inefficient.\n     *\n     * @param index  the index as returned from {@link #lookupAttribute}\n     * @throws IndexOutOfBoundException  if no such attribute exist.\n     */\n    public void removeAttribute(int index) throws IndexOutOfBoundsException {\n        attrName.removeElementAt(index);\n        attrType.removeElementAt(index);\n        attrValue.removeElementAt(index);\n    }\n\n    /**\n     * Return the number of attributes this element have.\n     */\n    public int numberOfAttributes() {\n        return attrName.size();\n    }\n\n    /**\n     * Get the namespace URI for the attribute at the specified index.\n     *\n     * @param index  the index as returned from {@link #lookupAttribute}\n     *\n     * @return the namespace URI, may be (and is usually) the empty string,\n     *         or <code>null</code> if index is -1\n     * @throws IndexOutOfBoundsException  if no such attribute exist.\n     */\n    public String getAttributeNamespaceURI(int index) throws IndexOutOfBoundsException {\n        if (index == -1)\n            return null;\n        String s = (String) attrName.elementAt(index);\n        return s.substring(s.indexOf('^') + 1);\n    }\n\n    /**\n     * Get the name of the attribute at the specified index.\n     *\n     * @param index  the index as returned from {@link #lookupAttribute}\n     *\n     * @return the localName,\n     *         or <code>null</code> if index is -1\n     * @throws IndexOutOfBoundsException  if no such attribute exist.\n     */\n    public String getAttributeLocalName(int index) throws IndexOutOfBoundsException {\n        if (index == -1)\n            return null;\n        String s = (String) attrName.elementAt(index);\n        return s.substring(0, s.indexOf('^'));\n    }\n\n    /**\n     * Get the type of the attribute at the specified index.\n     *\n     * The attribute type is one of the strings\n     * \"CDATA\", \"ID\", \"IDREF\", \"IDREFS\", \"NMTOKEN\", \"NMTOKENS\",\n     * \"ENTITY\", \"ENTITIES\", or \"NOTATION\" (always in upper case).\n     *\n     * @return the attribute type,\n     *         or <code>null</code> if index is -1\n     * @param index  the index as returned from {@link #lookupAttribute}\n     * @throws IndexOutOfBoundsException  if no such attribute exist.\n     */\n    public String getAttributeType(int index) throws IndexOutOfBoundsException {\n        if (index == -1)\n            return null;\n        return (String) attrType.elementAt(index);\n    }\n\n    /**\n     * Get the value of the attribute at the specified index.\n     *\n     * @return the attribute value,\n     *         or <code>null</code> if index is -1\n     * @param index  the index as returned from {@link #lookupAttribute}\n     * @throws IndexOutOfBoundsException  if no such attribute exist.\n     */\n    public String getAttributeValue(int index) throws IndexOutOfBoundsException {\n        if (index == -1)\n            return null;\n        return (String) attrValue.elementAt(index);\n    }\n\n    void setNamespaceMappings(Vector prefixes, Vector URIs) {\n        namespacePrefixes = prefixes;\n        namespaceURIs = URIs;\n    }\n\n    /**\n     * Add a namespace mapping to this element.\n     *\n     * @param prefix  the prefix\n     * @param URI  the namespace URI\n     */\n    public void addNamespaceMapping(String prefix, String URI) {\n        namespacePrefixes.addElement(prefix);\n        namespaceURIs.addElement(URI);\n    }\n\n    /**\n     * Return the number of namespace mapping for this element.\n     */\n    public int numberOfNamespaceMappings() {\n        return namespacePrefixes.size();\n    }\n\n    /**\n     * Return a namespace mapping at the specified index.\n     *\n     * @return a String[] with [0] = prefix, [1] = namespace URI\n     * @throws IndexOutOfBoundsException  if no such mapping exist.\n     */\n    public String[] getNamespaceMapping(int index) throws IndexOutOfBoundsException {\n        return new String[] { (String) namespacePrefixes.elementAt(index), (String) namespaceURIs.elementAt(index) };\n    }\n\n    public String lookupNamespaceURI(String prefix) {\n        int index = namespacePrefixes.indexOf(prefix);\n        if (index == -1) {\n            if (parent != null) {\n                return parent.lookupNamespaceURI(prefix);\n            } else {\n                if (prefix.length() == 0) {\n                    return \"\";\n                } else {\n                    return null;\n                }\n            }\n        } else {\n            return (String) namespaceURIs.elementAt(index);\n        }\n    }\n\n    public String lookupNamespacePrefix(String URI) {\n        int index = namespaceURI.indexOf(URI);\n        if (index == -1) {\n            if (parent != null) {\n                return parent.lookupNamespacePrefix(URI);\n            } else {\n                if (URI.length() == 0) {\n                    return \"\";\n                } else {\n                    return null;\n                }\n            }\n        } else {\n            return (String) namespacePrefixes.elementAt(index);\n        }\n    }\n\n    /**\n     * Set the baseURI property of this element.\n     *\n     * @param URI  the base URI, must be absolute\n     */\n    public void setBaseURI(URL URI) {\n        baseURI = URI;\n    }\n\n    public URL getBaseURI() {\n        if (baseURI != null) {\n            return baseURI;\n        } else {\n            if (parent != null) {\n                return parent.getBaseURI();\n            } else {\n                return null;\n            }\n        }\n    }\n\n    public boolean getPreserveSpace() {\n        switch(xmlSpaceAttribute) {\n            case 'p':\n                return true;\n            case 'd':\n                return false;\n            default:\n                if (parent != null) {\n                    return parent.getPreserveSpace();\n                } else {\n                    return false;\n                }\n        }\n    }\n\n    public String getInheritedAttribute(String namespaceURI, String localName) {\n        String val = getAttrValueOrNull(namespaceURI, localName);\n        if (val != null)\n            return val;\n        else if (parent == null)\n            return null;\n        else\n            return parent.getInheritedAttribute(namespaceURI, localName);\n    }\n\n    /**\n     * Fire the startElement event to the given SAX2 ContentHandler.\n     * Will also fire startPrefixMapping events.\n     */\n    public void outputStartElement(ContentHandler sax) throws SAXException {\n        for (int i = 0; i < namespacePrefixes.size(); i++) {\n            sax.startPrefixMapping((String) namespacePrefixes.elementAt(i), (String) namespaceURIs.elementAt(i));\n        }\n        AttributesImpl atts = new AttributesImpl();\n        for (int i = 0; i < attrName.size(); i++) {\n            String s = (String) attrName.elementAt(i);\n            String URI = s.substring(s.indexOf('^') + 1);\n            String local = s.substring(0, s.indexOf('^'));\n            atts.addAttribute(URI, local, \"\", (String) attrType.elementAt(i), (String) attrValue.elementAt(i));\n        }\n        sax.startElement(namespaceURI, localName, \"\", atts);\n    }\n\n    /**\n     * Fire the endElement event to the given SAX2 ContentHandler.\n     * Will also fire endPrefixMapping events.\n     */\n    public void outputEndElement(ContentHandler sax) throws SAXException {\n        sax.endElement(namespaceURI, localName, \"\");\n        for (int i = 0; i < namespacePrefixes.size(); i++) {\n            sax.endPrefixMapping((String) namespacePrefixes.elementAt(i));\n        }\n    }\n\n    public void toSAX(ContentHandler sax) throws SAXException {\n        outputStartElement(sax);\n        for (int i = 0; i < numberOfChildren(); i++) {\n            getChild(i).toSAX(sax);\n        }\n        outputEndElement(sax);\n    }\n\n    /**\n     * Shortcut method for getting the value of an attribute without\n     * namespace.\n     *\n     * @return the attrubute value, or <code>null</code>\n     * \t\tif the attribute doesn't exist\n     */\n    public String getAttrValueOrNull(String localName) {\n        return getAttributeValue(lookupAttribute(\"\", localName));\n    }\n\n    /**\n     * Shortcut method for getting the value of an attribute without\n     * namespace.\n     *\n     * @return the attrubute value, never <code>null</code>\n     * @throws SAXParseException if the attribute doesn't exist\n     */\n    public String getAttrValue(String localName) throws SAXParseException {\n        String v = getAttrValueOrNull(localName);\n        if (v == null)\n            throw new SAXParseException(\"Attribute \" + localName + \" expected\", this);\n        else\n            return v;\n    }\n\n    /**\n     * Shortcut method for getting the value of an attribute with\n     * namespace.\n     *\n     * @return the attrubute value, or <code>null</code>\n     * \t\tif the attribute doesn't exist\n     */\n    public String getAttrValueOrNull(String namespaceURI, String localName) {\n        return getAttributeValue(lookupAttribute(namespaceURI, localName));\n    }\n\n    /**\n     * Shortcut method for getting the value of an attribute with\n     * namespace.\n     *\n     * @return the attrubute value, never <code>null</code>\n     * @throws SAXParseException if the attribute doesn't exist\n     */\n    public String getAttrValue(String namespaceURI, String localName) throws SAXParseException {\n        String v = getAttrValueOrNull(namespaceURI, localName);\n        if (v == null)\n            throw new SAXParseException(\"Attribute {\" + namespaceURI + \"}\" + localName + \" expected\", this);\n        else\n            return v;\n    }\n\n    /**\n     * Shortcut method for getting the text content of an Element.\n     *\n     * @return if there is a single Text child, return its value,\n     *         if there is no children, return \"\",\n     *         or <code>null</code>\n     *         if there are more than one children or one non-Text child\n     */\n    public String getTextContentOrNull() {\n        if (numberOfChildren() == 0) {\n            return \"\";\n        } else if (numberOfChildren() > 1) {\n            return null;\n        } else {\n            Node node = getChild(0);\n            if (!(node instanceof Text))\n                return null;\n            return ((Text) node).getValue();\n        }\n    }\n\n    /**\n     * Shortcut method for getting the text content of an Element.\n     *\n     * @return if there is a single Text child, return its value,\n     *         if there is no children, return \"\",\n     *         never <code>null</code>.\n     * @throws SAXParseException\n     *         if there are more than one children or one non-Text child\n     */\n    public String getTextContent() throws SAXParseException {\n        String s = getTextContentOrNull();\n        if (s == null)\n            throw new SAXParseException(\"No text content\", this);\n        else\n            return s;\n    }\n\n    /**\n     * Shortcut method for getting the first Element child with a\n     * specified name.\n     *\n     * @return  the first child Element with the specified name,\n     *          or <code>null</code> if there is no such child.\n     */\n    public Element getFirstChildElementOrNull(String namespaceURI, String localName) {\n        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {\n            Element e = (Element) getChild(i);\n            if (e.getNamespaceURI().equals(namespaceURI) && e.getLocalName().equals(localName)) {\n                return e;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Shortcut method for getting the first Element child with a\n     * specified name.\n     *\n     * @return  the first child Element with the specified name,\n     *          never <code>null</code>.\n     * @throws SAXParseException\n     *         if there is no such child.\n     */\n    public Element getFirstChildElement(String namespaceURI, String localName) throws SAXParseException {\n        Element e = getFirstChildElementOrNull(namespaceURI, localName);\n        if (e == null)\n            throw new SAXParseException(\"Element {\" + namespaceURI + \"}\" + localName + \" expected\", this);\n        else\n            return e;\n    }\n\n    /**\n     * Shortcut method for getting the first Element children with any name.\n     *\n     * @return  the first child Element\n     *          or <code>null</code> if there are no Element children.\n     */\n    public Element getFirstChildElementOrNull() {\n        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {\n            return (Element) getChild(i);\n        }\n        return null;\n    }\n\n    /**\n     * Shortcut method for getting the first Element children with any name.\n     *\n     * @return  the first child Element\n     *          never <code>null</code>.\n     * @throws SAXParseException\n     *         if there are no Element children.\n     */\n    public Element getFirstChildElement() throws SAXParseException {\n        Element e = getFirstChildElementOrNull();\n        if (e == null)\n            throw new SAXParseException(\"Element expected\", this);\n        else\n            return e;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/xtree/ElementTest4.java",
		"test_prompt": "// ElementTest4.java\npackage nu.staldal.xtree;\n\nimport java.util.Vector;\nimport java.net.URL;\nimport org.xml.sax.*;\nimport org.xml.sax.helpers.AttributesImpl;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Element}.\n* It contains ten unit test cases for the {@link Element#lookupNamespacePrefix(String)} method.\n*/\nclass ElementTest4 {"
	},
	{
		"original_code": "// Text.java\n/*\n * Copyright (c) 2001-2003, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.xtree;\n\nimport org.xml.sax.*;\n\n/**\n * Character content in an XML document. This class is immutible.\n */\npublic class Text extends Node {\n\n    static final long serialVersionUID = -128692223369356277L;\n\n    final String value;\n\n    transient char[] charArrayCache;\n\n    /**\n     * Constructs a text node from a char[] buffer.\n     *\n     * @param data  a char[] buffer\n     * @param start  the offset to read from in the buffer\n     * @param length  the number of characters to read from the buffer\n     * @param forceCopy  force copying of the data, if false a reference\n     *                   to the buffer may be keept.\n     */\n    public Text(char[] data, int start, int length, boolean forceCopy) {\n        value = new String(data, start, length);\n        if (start == 0 && length == data.length && !forceCopy)\n            charArrayCache = data;\n    }\n\n    /**\n     * Constructs a text node from a String.\n     *\n     * @param value  the string\n     */\n    public Text(String value) {\n        this.value = value;\n    }\n\n    /**\n     * Get the charater content as a string\n     */\n    public String getValue() {\n        return value;\n    }\n\n    private void obtainCharArray() {\n        if (charArrayCache == null)\n            charArrayCache = value.toCharArray();\n    }\n\n    /**\n     * Get the charater content as a char[].\n     */\n    public char[] asCharArray() {\n        obtainCharArray();\n        return charArrayCache;\n    }\n\n    public void toSAX(ContentHandler sax) throws SAXException {\n        obtainCharArray();\n        sax.characters(charArrayCache, 0, charArrayCache.length);\n    }\n\n    public boolean isWhitespaceNode() {\n        for (int i = 0; i < value.length(); i++) {\n            if (value.charAt(i) > ' ')\n                return false;\n        }\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/xtree/TextTest0.java",
		"test_prompt": "// TextTest0.java\npackage nu.staldal.xtree;\n\nimport org.xml.sax.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Text}.\n* It contains ten unit test cases for the {@link Text#asCharArray()} method.\n*/\nclass TextTest0 {"
	},
	{
		"original_code": "// Text.java\n/*\n * Copyright (c) 2001-2003, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.xtree;\n\nimport org.xml.sax.*;\n\n/**\n * Character content in an XML document. This class is immutible.\n */\npublic class Text extends Node {\n\n    static final long serialVersionUID = -128692223369356277L;\n\n    final String value;\n\n    transient char[] charArrayCache;\n\n    /**\n     * Constructs a text node from a char[] buffer.\n     *\n     * @param data  a char[] buffer\n     * @param start  the offset to read from in the buffer\n     * @param length  the number of characters to read from the buffer\n     * @param forceCopy  force copying of the data, if false a reference\n     *                   to the buffer may be keept.\n     */\n    public Text(char[] data, int start, int length, boolean forceCopy) {\n        value = new String(data, start, length);\n        if (start == 0 && length == data.length && !forceCopy)\n            charArrayCache = data;\n    }\n\n    /**\n     * Constructs a text node from a String.\n     *\n     * @param value  the string\n     */\n    public Text(String value) {\n        this.value = value;\n    }\n\n    /**\n     * Get the charater content as a string\n     */\n    public String getValue() {\n        return value;\n    }\n\n    private void obtainCharArray() {\n        if (charArrayCache == null)\n            charArrayCache = value.toCharArray();\n    }\n\n    /**\n     * Get the charater content as a char[].\n     */\n    public char[] asCharArray() {\n        obtainCharArray();\n        return charArrayCache;\n    }\n\n    public void toSAX(ContentHandler sax) throws SAXException {\n        obtainCharArray();\n        sax.characters(charArrayCache, 0, charArrayCache.length);\n    }\n\n    public boolean isWhitespaceNode() {\n        for (int i = 0; i < value.length(); i++) {\n            if (value.charAt(i) > ' ')\n                return false;\n        }\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/xtree/TextTest1.java",
		"test_prompt": "// TextTest1.java\npackage nu.staldal.xtree;\n\nimport org.xml.sax.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Text}.\n* It contains ten unit test cases for the {@link Text#isWhitespaceNode()} method.\n*/\nclass TextTest1 {"
	},
	{
		"original_code": "// Node.java\n/*\n * Copyright (c) 2001-2002, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.xtree;\n\nimport java.net.URL;\nimport org.xml.sax.*;\n\n/**\n * Base class for a node in an XTree.\n */\npublic abstract class Node implements java.io.Serializable, Locator {\n\n    /**\n     * Namespace URI for the implicitly defined \"xml\" namespace.\n     */\n    public static final String XML_NS = \"http://www.w3.org/XML/1998/namespace\";\n\n    private String publicId = null;\n\n    private String systemId = null;\n\n    private int line = -1;\n\n    private int column = -1;\n\n    protected NodeWithChildren parent = null;\n\n    void setParent(NodeWithChildren n) {\n        parent = n;\n    }\n\n    public void setPublicId(String publicId) {\n        this.publicId = publicId;\n    }\n\n    public void setSystemId(String systemId) {\n        this.systemId = systemId;\n    }\n\n    public void setLine(int line) {\n        this.line = line;\n    }\n\n    public void setColumn(int column) {\n        this.column = column;\n    }\n\n    /**\n     * Get the parent of this node.\n     *\n     * @return  the parent of this node,\n     * or <code>null</code> if this node has no parent.\n     */\n    public NodeWithChildren getParent() {\n        return parent;\n    }\n\n    /**\n     * Serialize this node, and recursively the (sub)tree beneath,\n     * into SAX2 events.\n     *\n     * @param sax  the SAX2 ContentHander to fire events on.\n     */\n    public abstract void toSAX(ContentHandler sax) throws SAXException;\n\n    /**\n     * Return the public identifier for this node. Useful for error reporting.\n     *\n     * The return value is the public identifier of the document\n     * entity or of the external parsed entity.\n     *\n     * @return A string containing the public identifier, or null\n     *         if none is available.\n     */\n    public String getPublicId() {\n        return publicId;\n    }\n\n    /**\n     * Return the system identifier for this node. Useful for error reporting.\n     *\n     * The return value is the system identifier of the document\n     * entity or of the external parsed entity.\n     *\n     * @return A string containing the system identifier, or null\n     *         if none is available.\n     */\n    public String getSystemId() {\n        return systemId;\n    }\n\n    /**\n     * Return the line number where this node ends. Useful for error reporting.\n     *\n     * The return value is an approximation of the line number\n     * in the document entity or external parsed entity.\n     *\n     * The first line in the document is line 1.\n     *\n     * @return The line number, or -1 if none is available.\n     * @see #getColumnNumber()\n     */\n    public int getLineNumber() {\n        return line;\n    }\n\n    /**\n     * Return the column number where this node ends. Useful for error reporting.\n     *\n     * The return value is an approximation of the column number\n     * in the document entity or external parsed entity.\n     *\n     * The first column in each line is column 1.\n     *\n     * @return The column number, or -1 if none is available.\n     * @see #getLineNumber()\n     */\n    public int getColumnNumber() {\n        return column;\n    }\n\n    /**\n     * Lookup the namespace URI which has been mapped to a prefix.\n     *\n     * @param prefix  the prefix, may be the empty string which denotes\n     *  the default namespace.\n     *\n     * @return the namespace URI, or <code>null</code>\n     *  if the prefix is not mapped to any namespace URI,\n     *  or the empty string of prefix is the empty string and there is no\n     *  default namespace mapping.\n     */\n    public String lookupNamespaceURI(String prefix) {\n        if (parent == null)\n            return null;\n        else\n            return parent.lookupNamespaceURI(prefix);\n    }\n\n    /**\n     * Lookup a prefix which has been mapped to a namespace URI.\n     *\n     * @param URI  the namespace URI\n     *\n     * @return any of the prefixes which has been mapped to the namespace URI,\n     *  or <code>null</code> if no prefix is mapped to the namespace URI.\n     */\n    public String lookupNamespacePrefix(String URI) {\n        if (parent == null)\n            return null;\n        else\n            return parent.lookupNamespacePrefix(URI);\n    }\n\n    /**\n     * Returns the absolute base URI of this node.\n     *\n     * @return  the absolute base URI of this node,\n     * or <code>null</code> if unknown.\n     */\n    public URL getBaseURI() {\n        if (parent == null)\n            return null;\n        else\n            return parent.getBaseURI();\n    }\n\n    /**\n     * Return the value of any xml:space attribute in force for this node.\n     *\n     * @return  <code>true</code> if an xml:space=\"preserve\" is in effect\n     */\n    public boolean getPreserveSpace() {\n        if (parent == null)\n            return false;\n        else\n            return parent.getPreserveSpace();\n    }\n\n    /**\n     * Return the value of an inherited attribute. If the given attribute\n     * occurs on this node, return its value, otherwise recursivley search\n     * the parent of this node (return <code>null</code> if the root is\n     * reached without finding the attribute). Useful for e.g. xml:lang.\n     *\n     * @param namespaceURI  the namespace URI, may be the empty string\n     * @param localName  the attribute name\n     *\n     * @return  <code>null</code> if no such attribute is found\n     */\n    public String getInheritedAttribute(String namespaceURI, String localName) {\n        if (parent == null)\n            return null;\n        else\n            return parent.getInheritedAttribute(namespaceURI, localName);\n    }\n\n    /**\n     * Check if this node consist of whitespace only.\n     *\n     * @return <code>true</code> if and only if this is a Text node which\n     *                           contains no other characters than whitespace.\n     */\n    public boolean isWhitespaceNode() {\n        return false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/xtree/NodeTest0.java",
		"test_prompt": "// NodeTest0.java\npackage nu.staldal.xtree;\n\nimport java.net.URL;\nimport org.xml.sax.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Node}.\n* It contains ten unit test cases for the {@link Node#lookupNamespaceURI(String)} method.\n*/\nclass NodeTest0 {"
	},
	{
		"original_code": "// Node.java\n/*\n * Copyright (c) 2001-2002, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.xtree;\n\nimport java.net.URL;\nimport org.xml.sax.*;\n\n/**\n * Base class for a node in an XTree.\n */\npublic abstract class Node implements java.io.Serializable, Locator {\n\n    /**\n     * Namespace URI for the implicitly defined \"xml\" namespace.\n     */\n    public static final String XML_NS = \"http://www.w3.org/XML/1998/namespace\";\n\n    private String publicId = null;\n\n    private String systemId = null;\n\n    private int line = -1;\n\n    private int column = -1;\n\n    protected NodeWithChildren parent = null;\n\n    void setParent(NodeWithChildren n) {\n        parent = n;\n    }\n\n    public void setPublicId(String publicId) {\n        this.publicId = publicId;\n    }\n\n    public void setSystemId(String systemId) {\n        this.systemId = systemId;\n    }\n\n    public void setLine(int line) {\n        this.line = line;\n    }\n\n    public void setColumn(int column) {\n        this.column = column;\n    }\n\n    /**\n     * Get the parent of this node.\n     *\n     * @return  the parent of this node,\n     * or <code>null</code> if this node has no parent.\n     */\n    public NodeWithChildren getParent() {\n        return parent;\n    }\n\n    /**\n     * Serialize this node, and recursively the (sub)tree beneath,\n     * into SAX2 events.\n     *\n     * @param sax  the SAX2 ContentHander to fire events on.\n     */\n    public abstract void toSAX(ContentHandler sax) throws SAXException;\n\n    /**\n     * Return the public identifier for this node. Useful for error reporting.\n     *\n     * The return value is the public identifier of the document\n     * entity or of the external parsed entity.\n     *\n     * @return A string containing the public identifier, or null\n     *         if none is available.\n     */\n    public String getPublicId() {\n        return publicId;\n    }\n\n    /**\n     * Return the system identifier for this node. Useful for error reporting.\n     *\n     * The return value is the system identifier of the document\n     * entity or of the external parsed entity.\n     *\n     * @return A string containing the system identifier, or null\n     *         if none is available.\n     */\n    public String getSystemId() {\n        return systemId;\n    }\n\n    /**\n     * Return the line number where this node ends. Useful for error reporting.\n     *\n     * The return value is an approximation of the line number\n     * in the document entity or external parsed entity.\n     *\n     * The first line in the document is line 1.\n     *\n     * @return The line number, or -1 if none is available.\n     * @see #getColumnNumber()\n     */\n    public int getLineNumber() {\n        return line;\n    }\n\n    /**\n     * Return the column number where this node ends. Useful for error reporting.\n     *\n     * The return value is an approximation of the column number\n     * in the document entity or external parsed entity.\n     *\n     * The first column in each line is column 1.\n     *\n     * @return The column number, or -1 if none is available.\n     * @see #getLineNumber()\n     */\n    public int getColumnNumber() {\n        return column;\n    }\n\n    /**\n     * Lookup the namespace URI which has been mapped to a prefix.\n     *\n     * @param prefix  the prefix, may be the empty string which denotes\n     *  the default namespace.\n     *\n     * @return the namespace URI, or <code>null</code>\n     *  if the prefix is not mapped to any namespace URI,\n     *  or the empty string of prefix is the empty string and there is no\n     *  default namespace mapping.\n     */\n    public String lookupNamespaceURI(String prefix) {\n        if (parent == null)\n            return null;\n        else\n            return parent.lookupNamespaceURI(prefix);\n    }\n\n    /**\n     * Lookup a prefix which has been mapped to a namespace URI.\n     *\n     * @param URI  the namespace URI\n     *\n     * @return any of the prefixes which has been mapped to the namespace URI,\n     *  or <code>null</code> if no prefix is mapped to the namespace URI.\n     */\n    public String lookupNamespacePrefix(String URI) {\n        if (parent == null)\n            return null;\n        else\n            return parent.lookupNamespacePrefix(URI);\n    }\n\n    /**\n     * Returns the absolute base URI of this node.\n     *\n     * @return  the absolute base URI of this node,\n     * or <code>null</code> if unknown.\n     */\n    public URL getBaseURI() {\n        if (parent == null)\n            return null;\n        else\n            return parent.getBaseURI();\n    }\n\n    /**\n     * Return the value of any xml:space attribute in force for this node.\n     *\n     * @return  <code>true</code> if an xml:space=\"preserve\" is in effect\n     */\n    public boolean getPreserveSpace() {\n        if (parent == null)\n            return false;\n        else\n            return parent.getPreserveSpace();\n    }\n\n    /**\n     * Return the value of an inherited attribute. If the given attribute\n     * occurs on this node, return its value, otherwise recursivley search\n     * the parent of this node (return <code>null</code> if the root is\n     * reached without finding the attribute). Useful for e.g. xml:lang.\n     *\n     * @param namespaceURI  the namespace URI, may be the empty string\n     * @param localName  the attribute name\n     *\n     * @return  <code>null</code> if no such attribute is found\n     */\n    public String getInheritedAttribute(String namespaceURI, String localName) {\n        if (parent == null)\n            return null;\n        else\n            return parent.getInheritedAttribute(namespaceURI, localName);\n    }\n\n    /**\n     * Check if this node consist of whitespace only.\n     *\n     * @return <code>true</code> if and only if this is a Text node which\n     *                           contains no other characters than whitespace.\n     */\n    public boolean isWhitespaceNode() {\n        return false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/xtree/NodeTest1.java",
		"test_prompt": "// NodeTest1.java\npackage nu.staldal.xtree;\n\nimport java.net.URL;\nimport org.xml.sax.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Node}.\n* It contains ten unit test cases for the {@link Node#lookupNamespacePrefix(String)} method.\n*/\nclass NodeTest1 {"
	},
	{
		"original_code": "// Node.java\n/*\n * Copyright (c) 2001-2002, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.xtree;\n\nimport java.net.URL;\nimport org.xml.sax.*;\n\n/**\n * Base class for a node in an XTree.\n */\npublic abstract class Node implements java.io.Serializable, Locator {\n\n    /**\n     * Namespace URI for the implicitly defined \"xml\" namespace.\n     */\n    public static final String XML_NS = \"http://www.w3.org/XML/1998/namespace\";\n\n    private String publicId = null;\n\n    private String systemId = null;\n\n    private int line = -1;\n\n    private int column = -1;\n\n    protected NodeWithChildren parent = null;\n\n    void setParent(NodeWithChildren n) {\n        parent = n;\n    }\n\n    public void setPublicId(String publicId) {\n        this.publicId = publicId;\n    }\n\n    public void setSystemId(String systemId) {\n        this.systemId = systemId;\n    }\n\n    public void setLine(int line) {\n        this.line = line;\n    }\n\n    public void setColumn(int column) {\n        this.column = column;\n    }\n\n    /**\n     * Get the parent of this node.\n     *\n     * @return  the parent of this node,\n     * or <code>null</code> if this node has no parent.\n     */\n    public NodeWithChildren getParent() {\n        return parent;\n    }\n\n    /**\n     * Serialize this node, and recursively the (sub)tree beneath,\n     * into SAX2 events.\n     *\n     * @param sax  the SAX2 ContentHander to fire events on.\n     */\n    public abstract void toSAX(ContentHandler sax) throws SAXException;\n\n    /**\n     * Return the public identifier for this node. Useful for error reporting.\n     *\n     * The return value is the public identifier of the document\n     * entity or of the external parsed entity.\n     *\n     * @return A string containing the public identifier, or null\n     *         if none is available.\n     */\n    public String getPublicId() {\n        return publicId;\n    }\n\n    /**\n     * Return the system identifier for this node. Useful for error reporting.\n     *\n     * The return value is the system identifier of the document\n     * entity or of the external parsed entity.\n     *\n     * @return A string containing the system identifier, or null\n     *         if none is available.\n     */\n    public String getSystemId() {\n        return systemId;\n    }\n\n    /**\n     * Return the line number where this node ends. Useful for error reporting.\n     *\n     * The return value is an approximation of the line number\n     * in the document entity or external parsed entity.\n     *\n     * The first line in the document is line 1.\n     *\n     * @return The line number, or -1 if none is available.\n     * @see #getColumnNumber()\n     */\n    public int getLineNumber() {\n        return line;\n    }\n\n    /**\n     * Return the column number where this node ends. Useful for error reporting.\n     *\n     * The return value is an approximation of the column number\n     * in the document entity or external parsed entity.\n     *\n     * The first column in each line is column 1.\n     *\n     * @return The column number, or -1 if none is available.\n     * @see #getLineNumber()\n     */\n    public int getColumnNumber() {\n        return column;\n    }\n\n    /**\n     * Lookup the namespace URI which has been mapped to a prefix.\n     *\n     * @param prefix  the prefix, may be the empty string which denotes\n     *  the default namespace.\n     *\n     * @return the namespace URI, or <code>null</code>\n     *  if the prefix is not mapped to any namespace URI,\n     *  or the empty string of prefix is the empty string and there is no\n     *  default namespace mapping.\n     */\n    public String lookupNamespaceURI(String prefix) {\n        if (parent == null)\n            return null;\n        else\n            return parent.lookupNamespaceURI(prefix);\n    }\n\n    /**\n     * Lookup a prefix which has been mapped to a namespace URI.\n     *\n     * @param URI  the namespace URI\n     *\n     * @return any of the prefixes which has been mapped to the namespace URI,\n     *  or <code>null</code> if no prefix is mapped to the namespace URI.\n     */\n    public String lookupNamespacePrefix(String URI) {\n        if (parent == null)\n            return null;\n        else\n            return parent.lookupNamespacePrefix(URI);\n    }\n\n    /**\n     * Returns the absolute base URI of this node.\n     *\n     * @return  the absolute base URI of this node,\n     * or <code>null</code> if unknown.\n     */\n    public URL getBaseURI() {\n        if (parent == null)\n            return null;\n        else\n            return parent.getBaseURI();\n    }\n\n    /**\n     * Return the value of any xml:space attribute in force for this node.\n     *\n     * @return  <code>true</code> if an xml:space=\"preserve\" is in effect\n     */\n    public boolean getPreserveSpace() {\n        if (parent == null)\n            return false;\n        else\n            return parent.getPreserveSpace();\n    }\n\n    /**\n     * Return the value of an inherited attribute. If the given attribute\n     * occurs on this node, return its value, otherwise recursivley search\n     * the parent of this node (return <code>null</code> if the root is\n     * reached without finding the attribute). Useful for e.g. xml:lang.\n     *\n     * @param namespaceURI  the namespace URI, may be the empty string\n     * @param localName  the attribute name\n     *\n     * @return  <code>null</code> if no such attribute is found\n     */\n    public String getInheritedAttribute(String namespaceURI, String localName) {\n        if (parent == null)\n            return null;\n        else\n            return parent.getInheritedAttribute(namespaceURI, localName);\n    }\n\n    /**\n     * Check if this node consist of whitespace only.\n     *\n     * @return <code>true</code> if and only if this is a Text node which\n     *                           contains no other characters than whitespace.\n     */\n    public boolean isWhitespaceNode() {\n        return false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/xtree/NodeTest2.java",
		"test_prompt": "// NodeTest2.java\npackage nu.staldal.xtree;\n\nimport java.net.URL;\nimport org.xml.sax.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Node}.\n* It contains ten unit test cases for the {@link Node#isWhitespaceNode()} method.\n*/\nclass NodeTest2 {"
	},
	{
		"original_code": "// NodeWithChildren.java\n/*\n * Copyright (c) 2001, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.xtree;\n\nimport java.util.Vector;\n\n/**\n * Base class for a node with children. The children are ordered.\n */\npublic abstract class NodeWithChildren extends Node {\n\n    private Vector children;\n\n    /**\n     * Construct a node which children.\n     *\n     * @param capacity  the number of children this node should have,\n     *                  use -1 if unknown\n     */\n    public NodeWithChildren(int capacity) {\n        if (capacity >= 0)\n            children = new Vector(capacity);\n        else\n            children = new Vector();\n    }\n\n    /**\n     * Get the current number of children this node have.\n     */\n    public int numberOfChildren() {\n        return children.size();\n    }\n\n    /**\n     * Get a specific child of this node.\n     *\n     * @param index  index of the node to get, the first child is 0.\n     *\n     * @throws IndexOutOfBoundsException  if no such child exist.\n     */\n    public Node getChild(int index) throws IndexOutOfBoundsException {\n        return (Node) children.elementAt(index);\n    }\n\n    /**\n     * Add a new child to this node, last in sequence.\n     */\n    public void addChild(Node newChild) {\n        newChild.setParent(this);\n        children.addElement(newChild);\n    }\n\n    /**\n     * Replace a child with another.\n     *\n     * @param newChild  the new child\n     * @param index  index of the child to replace\n     *\n     * @return  the replaced child\n     * @throws IndexOutOfBoundsException  if no such child exist\n     */\n    public Node replaceChild(Node newChild, int index) throws IndexOutOfBoundsException {\n        Node oldChild = (Node) children.elementAt(index);\n        oldChild.setParent(null);\n        newChild.setParent(this);\n        children.setElementAt(newChild, index);\n        return oldChild;\n    }\n\n    /**\n     * Remove a child from this node. This method is a bit inefficient.\n     *\n     * @param index  index of the child to replace\n     *\n     * @return  the removed child\n     * @throws IndexOutOfBoundsException  if no such child exist\n     */\n    public Node removeChild(int index) throws IndexOutOfBoundsException {\n        Node child = (Node) children.elementAt(index);\n        children.removeElementAt(index);\n        child.setParent(null);\n        return child;\n    }\n\n    /**\n     * Insert a new child at a specific point in sequence.\n     * This method is a bit inefficient.\n     *\n     * Inserts the new child at the specified index.\n     * Each child with an index greater or equal to the specified index\n     * is shifted upward to have an index one greater than the value it\n     * had previously.\n     *\n     * @param newChild  the new child\n     * @param index  index of the new child\n     *\n     * @throws IndexOutOfBoundsException  if the index is invalid.\n     */\n    public void insertChild(Node newChild, int index) throws IndexOutOfBoundsException {\n        newChild.setParent(this);\n        children.insertElementAt(newChild, index);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/xtree/NodeWithChildrenTest0.java",
		"test_prompt": "// NodeWithChildrenTest0.java\npackage nu.staldal.xtree;\n\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NodeWithChildren}.\n* It contains ten unit test cases for the {@link NodeWithChildren#numberOfChildren()} method.\n*/\nclass NodeWithChildrenTest0 {"
	},
	{
		"original_code": "// NodeWithChildren.java\n/*\n * Copyright (c) 2001, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.xtree;\n\nimport java.util.Vector;\n\n/**\n * Base class for a node with children. The children are ordered.\n */\npublic abstract class NodeWithChildren extends Node {\n\n    private Vector children;\n\n    /**\n     * Construct a node which children.\n     *\n     * @param capacity  the number of children this node should have,\n     *                  use -1 if unknown\n     */\n    public NodeWithChildren(int capacity) {\n        if (capacity >= 0)\n            children = new Vector(capacity);\n        else\n            children = new Vector();\n    }\n\n    /**\n     * Get the current number of children this node have.\n     */\n    public int numberOfChildren() {\n        return children.size();\n    }\n\n    /**\n     * Get a specific child of this node.\n     *\n     * @param index  index of the node to get, the first child is 0.\n     *\n     * @throws IndexOutOfBoundsException  if no such child exist.\n     */\n    public Node getChild(int index) throws IndexOutOfBoundsException {\n        return (Node) children.elementAt(index);\n    }\n\n    /**\n     * Add a new child to this node, last in sequence.\n     */\n    public void addChild(Node newChild) {\n        newChild.setParent(this);\n        children.addElement(newChild);\n    }\n\n    /**\n     * Replace a child with another.\n     *\n     * @param newChild  the new child\n     * @param index  index of the child to replace\n     *\n     * @return  the replaced child\n     * @throws IndexOutOfBoundsException  if no such child exist\n     */\n    public Node replaceChild(Node newChild, int index) throws IndexOutOfBoundsException {\n        Node oldChild = (Node) children.elementAt(index);\n        oldChild.setParent(null);\n        newChild.setParent(this);\n        children.setElementAt(newChild, index);\n        return oldChild;\n    }\n\n    /**\n     * Remove a child from this node. This method is a bit inefficient.\n     *\n     * @param index  index of the child to replace\n     *\n     * @return  the removed child\n     * @throws IndexOutOfBoundsException  if no such child exist\n     */\n    public Node removeChild(int index) throws IndexOutOfBoundsException {\n        Node child = (Node) children.elementAt(index);\n        children.removeElementAt(index);\n        child.setParent(null);\n        return child;\n    }\n\n    /**\n     * Insert a new child at a specific point in sequence.\n     * This method is a bit inefficient.\n     *\n     * Inserts the new child at the specified index.\n     * Each child with an index greater or equal to the specified index\n     * is shifted upward to have an index one greater than the value it\n     * had previously.\n     *\n     * @param newChild  the new child\n     * @param index  index of the new child\n     *\n     * @throws IndexOutOfBoundsException  if the index is invalid.\n     */\n    public void insertChild(Node newChild, int index) throws IndexOutOfBoundsException {\n        newChild.setParent(this);\n        children.insertElementAt(newChild, index);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/xtree/NodeWithChildrenTest1.java",
		"test_prompt": "// NodeWithChildrenTest1.java\npackage nu.staldal.xtree;\n\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NodeWithChildren}.\n* It contains ten unit test cases for the {@link NodeWithChildren#replaceChild(Node, int)} method.\n*/\nclass NodeWithChildrenTest1 {"
	},
	{
		"original_code": "// NodeWithChildren.java\n/*\n * Copyright (c) 2001, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.xtree;\n\nimport java.util.Vector;\n\n/**\n * Base class for a node with children. The children are ordered.\n */\npublic abstract class NodeWithChildren extends Node {\n\n    private Vector children;\n\n    /**\n     * Construct a node which children.\n     *\n     * @param capacity  the number of children this node should have,\n     *                  use -1 if unknown\n     */\n    public NodeWithChildren(int capacity) {\n        if (capacity >= 0)\n            children = new Vector(capacity);\n        else\n            children = new Vector();\n    }\n\n    /**\n     * Get the current number of children this node have.\n     */\n    public int numberOfChildren() {\n        return children.size();\n    }\n\n    /**\n     * Get a specific child of this node.\n     *\n     * @param index  index of the node to get, the first child is 0.\n     *\n     * @throws IndexOutOfBoundsException  if no such child exist.\n     */\n    public Node getChild(int index) throws IndexOutOfBoundsException {\n        return (Node) children.elementAt(index);\n    }\n\n    /**\n     * Add a new child to this node, last in sequence.\n     */\n    public void addChild(Node newChild) {\n        newChild.setParent(this);\n        children.addElement(newChild);\n    }\n\n    /**\n     * Replace a child with another.\n     *\n     * @param newChild  the new child\n     * @param index  index of the child to replace\n     *\n     * @return  the replaced child\n     * @throws IndexOutOfBoundsException  if no such child exist\n     */\n    public Node replaceChild(Node newChild, int index) throws IndexOutOfBoundsException {\n        Node oldChild = (Node) children.elementAt(index);\n        oldChild.setParent(null);\n        newChild.setParent(this);\n        children.setElementAt(newChild, index);\n        return oldChild;\n    }\n\n    /**\n     * Remove a child from this node. This method is a bit inefficient.\n     *\n     * @param index  index of the child to replace\n     *\n     * @return  the removed child\n     * @throws IndexOutOfBoundsException  if no such child exist\n     */\n    public Node removeChild(int index) throws IndexOutOfBoundsException {\n        Node child = (Node) children.elementAt(index);\n        children.removeElementAt(index);\n        child.setParent(null);\n        return child;\n    }\n\n    /**\n     * Insert a new child at a specific point in sequence.\n     * This method is a bit inefficient.\n     *\n     * Inserts the new child at the specified index.\n     * Each child with an index greater or equal to the specified index\n     * is shifted upward to have an index one greater than the value it\n     * had previously.\n     *\n     * @param newChild  the new child\n     * @param index  index of the new child\n     *\n     * @throws IndexOutOfBoundsException  if the index is invalid.\n     */\n    public void insertChild(Node newChild, int index) throws IndexOutOfBoundsException {\n        newChild.setParent(this);\n        children.insertElementAt(newChild, index);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/xtree/NodeWithChildrenTest2.java",
		"test_prompt": "// NodeWithChildrenTest2.java\npackage nu.staldal.xtree;\n\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NodeWithChildren}.\n* It contains ten unit test cases for the {@link NodeWithChildren#removeChild(int)} method.\n*/\nclass NodeWithChildrenTest2 {"
	},
	{
		"original_code": "// SequentialTreeBuilder.java\n/*\n * Copyright (c) 2002-2003, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.xtree;\n\nimport java.util.*;\nimport java.io.*;\nimport java.net.URL;\nimport javax.xml.parsers.*;\nimport org.xml.sax.*;\n\n/**\n * Build a list of XTree:s from a SAX2 event stream, or by parsing an XML document.\n * <p>\n * Useful to process a large document sequentially, without need to store the whole\n * document in memory at the same time.\n * <p>\n * The SequentialTreeBuilder ensures that the tree will not have two adjacent Text nodes.\n */\npublic class SequentialTreeBuilder implements ContentHandler, ErrorHandler {\n\n    public static final boolean DEBUG = false;\n\n    private static final String XML_NS = \"http://www.w3.org/XML/1998/namespace\";\n\n    private URL baseURI;\n\n    private Locator locator = null;\n\n    private ElementHandler handler;\n\n    private Element rootElement;\n\n    private TreeBuilder subTreeBuilder;\n\n    private Vector nsPrefix = null;\n\n    private Vector nsURI = null;\n\n    private int inSubTree = 0;\n\n    /**\n     * Parse an XML document into a list of XTree:s, one for each element under the root.\n     * Uses JAXP to find a parser.\n     * Will not support xml:base.\n     *\n     * @param xmlInput    the input to parse\n     * @param validateDTD validate using DTD\n     * @param handler     handler to invoke for each element\n     *\n     * @return the root element (without any children)\n     *\n     * @throws SAXParseException if the XML data is not valid\n     * @throws SAXException if any other error occurs while parsing the XML data\n     * @throws IOException  if there was some I/O error while reading the input.\n     */\n    public static Element parseXMLSequential(InputSource xmlInput, boolean validateDTD, ElementHandler handler) throws SAXParseException, SAXException, IOException {\n        try {\n            SAXParserFactory parserFactory = SAXParserFactory.newInstance();\n            parserFactory.setNamespaceAware(true);\n            parserFactory.setValidating(validateDTD);\n            parserFactory.setFeature(\"http://xml.org/sax/features/namespaces\", true);\n            parserFactory.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", false);\n            parserFactory.setFeature(\"http://xml.org/sax/features/validation\", validateDTD);\n            XMLReader xmlReader = parserFactory.newSAXParser().getXMLReader();\n            SequentialTreeBuilder tb = new SequentialTreeBuilder(handler);\n            xmlReader.setContentHandler(tb);\n            xmlReader.setErrorHandler(tb);\n            xmlReader.parse(xmlInput);\n            return tb.getRootElement();\n        } catch (javax.xml.parsers.ParserConfigurationException e) {\n            throw new Error(\"XML parser configuration error: \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Constructs a SequentialTreeBuilder, ready to receive SAX events.\n     * Will not support xml:base.\n     *\n     * @param handler   handler to invoke for each element\n     */\n    public SequentialTreeBuilder(ElementHandler handler) {\n        this(handler, null);\n    }\n\n    /**\n     * Constructs a SequentialTreeBuilder, ready to receive SAX events.\n     *\n     * @param handler   handler to invoke for each element\n     * @param base      base URL for the document, to support xml:base.\n     */\n    public SequentialTreeBuilder(ElementHandler handler, URL base) {\n        this.handler = handler;\n        baseURI = base;\n        subTreeBuilder = new TreeBuilder();\n    }\n\n    /**\n     * Obtain the root Element\n     *\n     * @throws IllegalStateException  if the SAX events received so far\n     * doesn't constitues a well-formed XML document.\n     */\n    public Element getRootElement() throws IllegalStateException {\n        if (rootElement == null)\n            throw new IllegalStateException(\"No root element\");\n        return rootElement;\n    }\n\n    // ContentHandler implementation\n    public void setDocumentLocator(Locator locator) {\n        this.locator = locator;\n        subTreeBuilder.setDocumentLocator(locator);\n    }\n\n    public void startDocument() throws SAXException {\n        // nothing to do\n    }\n\n    public void endDocument() throws SAXException {\n        // nothing to do\n    }\n\n    public void startElement(String namespaceURI, String localName, String qName, Attributes atts) throws SAXException {\n        if (DEBUG)\n            System.out.println(\"startElement(\" + namespaceURI + ',' + localName + ',' + qName + ')');\n        if (rootElement == null) {\n            rootElement = new Element(namespaceURI, localName, atts.getLength());\n            if (locator != null) {\n                rootElement.setSystemId(locator.getSystemId());\n                rootElement.setLine(locator.getLineNumber());\n                rootElement.setColumn(locator.getColumnNumber());\n            }\n            if (baseURI != null)\n                rootElement.setBaseURI(baseURI);\n            for (int i = 0; i < atts.getLength(); i++) {\n                rootElement.addAttribute(atts.getURI(i), atts.getLocalName(i), atts.getType(i), atts.getValue(i));\n                if (atts.getURI(i).equals(XML_NS) && atts.getLocalName(i).equals(\"base\")) {\n                    try {\n                        URL url = new URL(rootElement.getBaseURI(), atts.getValue(i));\n                        rootElement.setBaseURI(url);\n                    } catch (java.net.MalformedURLException e) {\n                        throw new SAXException(e);\n                    }\n                }\n            }\n            if (nsPrefix != null) {\n                rootElement.setNamespaceMappings(nsPrefix, nsURI);\n            }\n        } else {\n            inSubTree++;\n            subTreeBuilder.startElement(namespaceURI, localName, qName, atts);\n        }\n    }\n\n    public void endElement(String namespaceURI, String localName, String qName) throws SAXException {\n        if (DEBUG)\n            System.out.println(\"endElement(\" + namespaceURI + ',' + localName + ',' + qName + ')');\n        if (inSubTree > 0) {\n            subTreeBuilder.endElement(namespaceURI, localName, qName);\n            if (inSubTree == 1) {\n                Element el = subTreeBuilder.getTree();\n                el.setParent(rootElement);\n                handler.processElement(el);\n                subTreeBuilder.reset();\n            }\n            inSubTree--;\n        } else {\n            // nothing to do\n        }\n    }\n\n    public void startPrefixMapping(String prefix, String uri) throws SAXException {\n        if (DEBUG)\n            System.out.println(\"startPrefixMapping(\" + ((prefix.length() == 0) ? \"<default>\" : prefix) + ',' + uri + ')');\n        if (rootElement == null) {\n            if (nsPrefix == null) {\n                nsPrefix = new Vector();\n                nsURI = new Vector();\n            }\n            nsPrefix.addElement(prefix);\n            nsURI.addElement(uri);\n        } else {\n            subTreeBuilder.startPrefixMapping(prefix, uri);\n        }\n    }\n\n    public void endPrefixMapping(String prefix) throws SAXException {\n        if (DEBUG)\n            System.out.println(\"endPrefixMapping(\" + ((prefix.length() == 0) ? \"<default>\" : prefix) + ')');\n        // nothing to do\n    }\n\n    public void characters(char[] ch, int start, int length) throws SAXException {\n        if (inSubTree > 0)\n            subTreeBuilder.characters(ch, start, length);\n    }\n\n    public void ignorableWhitespace(char[] ch, int start, int length) throws SAXException {\n        if (inSubTree > 0)\n            subTreeBuilder.ignorableWhitespace(ch, start, length);\n    }\n\n    public void processingInstruction(String target, String data) throws SAXException {\n        if (inSubTree > 0)\n            subTreeBuilder.processingInstruction(target, data);\n    }\n\n    public void skippedEntity(String name) throws SAXException {\n        if (inSubTree > 0)\n            subTreeBuilder.skippedEntity(name);\n    }\n\n    // ErrorHandler implementation\n    public void fatalError(SAXParseException e) throws SAXParseException {\n        throw e;\n    }\n\n    public void error(SAXParseException e) throws SAXParseException {\n        throw e;\n    }\n\n    public void warning(SAXParseException e) {\n        // do nothing\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/xtree/SequentialTreeBuilderTest.java",
		"test_prompt": "// SequentialTreeBuilderTest.java\npackage nu.staldal.xtree;\n\nimport java.util.*;\nimport java.io.*;\nimport java.net.URL;\nimport javax.xml.parsers.*;\nimport org.xml.sax.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SequentialTreeBuilder}.\n* It contains ten unit test cases for the {@link SequentialTreeBuilder#parseXMLSequential(InputSource, boolean, ElementHandler)} method.\n*/\nclass SequentialTreeBuilderTest {"
	},
	{
		"original_code": "// XTreeUtil.java\n/*\n * Copyright (c) 2002-2004, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.xtree;\n\nimport java.util.*;\nimport java.io.*;\nimport java.net.URL;\nimport javax.xml.parsers.*;\nimport javax.xml.transform.*;\nimport javax.xml.transform.sax.*;\nimport javax.xml.transform.stream.StreamResult;\nimport org.xml.sax.*;\nimport org.iso_relax.verifier.*;\nimport nu.staldal.xmlutil.ContentHandlerFixer;\n\n/**\n * Some utility methods for XTree. All methods in this class are static.\n */\npublic final class XTreeUtil {\n\n    /**\n     * Private default constructor to prevent instantiation.\n     */\n    private XTreeUtil() {\n    }\n\n    /**\n     * Parse an XML document into an XTree.\n     * Uses JAXP to find a parser and JARV to find a validator.\n     * Will not support xml:base.\n     *\n     * @param xmlInput    the input to parse\n     * @param validateDTD validate using DTD\n     * @param schemaType  the type of schema to use, or <code>null</code>\n     *                    for no schema validation\n     * @param schema      the schema to use, or <code>null</code>\n     *                    for no schema validation\n     *\n     * @return an XTree representation of the XML data\n     *\n     * @throws SAXParseException if the XML data is not valid\n     * @throws SAXException if any other error occurs while parsing the XML data\n     * @throws IOException  if there was some I/O error while reading the input.\n     */\n    public static Element parseXML(InputSource xmlInput, boolean validateDTD, String schemaType, InputSource schema) throws SAXParseException, SAXException, IOException {\n        try {\n            SAXParserFactory parserFactory = SAXParserFactory.newInstance();\n            parserFactory.setNamespaceAware(true);\n            parserFactory.setValidating(validateDTD);\n            parserFactory.setFeature(\"http://xml.org/sax/features/namespaces\", true);\n            parserFactory.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", false);\n            parserFactory.setFeature(\"http://xml.org/sax/features/validation\", validateDTD);\n            XMLReader xmlReader = parserFactory.newSAXParser().getXMLReader();\n            TreeBuilder tb = new TreeBuilder();\n            if (schema != null) {\n                VerifierFactory vf = VerifierFactory.newInstance(schemaType);\n                Verifier verifier = vf.newVerifier(schema);\n                VerifierFilter filter = verifier.getVerifierFilter();\n                filter.setParent(xmlReader);\n                xmlReader = filter;\n            }\n            xmlReader.setContentHandler(tb);\n            xmlReader.setErrorHandler(tb);\n            xmlReader.parse(xmlInput);\n            if ((schema != null) && !((VerifierFilter) xmlReader).isValid()) {\n                throw new SAXParseException(\"Invalid XML data\", null, null, -1, -1);\n            }\n            return tb.getTree();\n        } catch (javax.xml.parsers.ParserConfigurationException e) {\n            throw new Error(\"XML parser configuration error: \" + e.getMessage());\n        } catch (VerifierConfigurationException e) {\n            throw new Error(\"XML verifier configuration error: \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Parse an XML document into a list of XTree:s, one for each element under the root.\n     * Uses JAXP to find a parser and JARV to find a validator.\n     * Will not support xml:base.\n     *\n     * @param xmlInput    the input to parse\n     * @param validateDTD validate using DTD\n     * @param schemaType  the type of schema to use, or <code>null</code>\n     *                    for no schema validation\n     * @param schema      the schema to use, or <code>null</code>\n     *                    for no schema validation\n     * @param handler     handler to invoke for each element\n     *\n     * @return the root element (without any children)\n     *\n     * @throws SAXParseException if the XML data is not valid\n     * @throws SAXException if any other error occurs while parsing the XML data\n     * @throws IOException  if there was some I/O error while reading the input.\n     */\n    public static Element parseXMLSequential(InputSource xmlInput, boolean validateDTD, String schemaType, InputSource schema, ElementHandler handler) throws SAXParseException, SAXException, IOException {\n        try {\n            SAXParserFactory parserFactory = SAXParserFactory.newInstance();\n            parserFactory.setNamespaceAware(true);\n            parserFactory.setValidating(validateDTD);\n            XMLReader xmlReader = parserFactory.newSAXParser().getXMLReader();\n            SequentialTreeBuilder tb = new SequentialTreeBuilder(handler);\n            if (schema != null) {\n                VerifierFactory vf = VerifierFactory.newInstance(schemaType);\n                Verifier verifier = vf.newVerifier(schema);\n                VerifierFilter filter = verifier.getVerifierFilter();\n                filter.setParent(xmlReader);\n                xmlReader = filter;\n            }\n            xmlReader.setContentHandler(tb);\n            xmlReader.setErrorHandler(tb);\n            xmlReader.parse(xmlInput);\n            if ((schema != null) && !((VerifierFilter) xmlReader).isValid()) {\n                throw new SAXParseException(\"Invalid XML data\", null, null, -1, -1);\n            }\n            return tb.getRootElement();\n        } catch (javax.xml.parsers.ParserConfigurationException e) {\n            throw new Error(\"XML parser configuration error: \" + e.getMessage());\n        } catch (VerifierConfigurationException e) {\n            throw new Error(\"XML verifier configuration error: \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Serialize an XTree into an OutputStream.\n     *\n     * @param tree      the XTree to serialize\n     * @param os        the OutputStream to write to\n     *\n     * @throws IOException if any error occurs\n     */\n    public static void serialize(Node tree, OutputStream os) throws IOException {\n        Properties prop = new Properties();\n        prop.setProperty(OutputKeys.METHOD, \"xml\");\n        prop.setProperty(OutputKeys.ENCODING, \"utf-8\");\n        prop.setProperty(OutputKeys.INDENT, \"no\");\n        serialize(tree, os, prop);\n    }\n\n    /**\n     * Serialize an XTree into an OutputStream.\n     *\n     * @param tree      the XTree to serialize\n     * @param os        the OutputStream to write to\n     * @param prop  \toutput properties\n     *\n     * @throws IOException if any error occurs\n     */\n    public static void serialize(Node tree, OutputStream os, Properties prop) throws IOException {\n        try {\n            TransformerFactory tf = TransformerFactory.newInstance();\n            if (!(tf.getFeature(SAXTransformerFactory.FEATURE) && tf.getFeature(StreamResult.FEATURE))) {\n                throw new Error(\"The transformer factory \" + tf.getClass().getName() + \" doesn't support SAX\");\n            }\n            SAXTransformerFactory tfactory = (SAXTransformerFactory) tf;\n            TransformerHandler th = tfactory.newTransformerHandler();\n            th.setResult(new StreamResult(os));\n            Transformer trans = th.getTransformer();\n            trans.setOutputProperties(prop);\n            ContentHandler ch = new ContentHandlerFixer(th, true);\n            try {\n                ch.startDocument();\n                tree.toSAX(ch);\n                ch.endDocument();\n            } catch (SAXException e) {\n                throw new IOException(e.toString());\n            }\n        } catch (TransformerConfigurationException e) {\n            throw new Error(e.toString());\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/xtree/XTreeUtilTest0.java",
		"test_prompt": "// XTreeUtilTest0.java\npackage nu.staldal.xtree;\n\nimport java.util.*;\nimport java.io.*;\nimport java.net.URL;\nimport javax.xml.parsers.*;\nimport javax.xml.transform.*;\nimport javax.xml.transform.sax.*;\nimport javax.xml.transform.stream.StreamResult;\nimport org.xml.sax.*;\nimport org.iso_relax.verifier.*;\nimport nu.staldal.xmlutil.ContentHandlerFixer;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XTreeUtil}.\n* It contains ten unit test cases for the {@link XTreeUtil#parseXML(InputSource, boolean, String, InputSource)} method.\n*/\nclass XTreeUtilTest0 {"
	},
	{
		"original_code": "// XTreeUtil.java\n/*\n * Copyright (c) 2002-2004, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.xtree;\n\nimport java.util.*;\nimport java.io.*;\nimport java.net.URL;\nimport javax.xml.parsers.*;\nimport javax.xml.transform.*;\nimport javax.xml.transform.sax.*;\nimport javax.xml.transform.stream.StreamResult;\nimport org.xml.sax.*;\nimport org.iso_relax.verifier.*;\nimport nu.staldal.xmlutil.ContentHandlerFixer;\n\n/**\n * Some utility methods for XTree. All methods in this class are static.\n */\npublic final class XTreeUtil {\n\n    /**\n     * Private default constructor to prevent instantiation.\n     */\n    private XTreeUtil() {\n    }\n\n    /**\n     * Parse an XML document into an XTree.\n     * Uses JAXP to find a parser and JARV to find a validator.\n     * Will not support xml:base.\n     *\n     * @param xmlInput    the input to parse\n     * @param validateDTD validate using DTD\n     * @param schemaType  the type of schema to use, or <code>null</code>\n     *                    for no schema validation\n     * @param schema      the schema to use, or <code>null</code>\n     *                    for no schema validation\n     *\n     * @return an XTree representation of the XML data\n     *\n     * @throws SAXParseException if the XML data is not valid\n     * @throws SAXException if any other error occurs while parsing the XML data\n     * @throws IOException  if there was some I/O error while reading the input.\n     */\n    public static Element parseXML(InputSource xmlInput, boolean validateDTD, String schemaType, InputSource schema) throws SAXParseException, SAXException, IOException {\n        try {\n            SAXParserFactory parserFactory = SAXParserFactory.newInstance();\n            parserFactory.setNamespaceAware(true);\n            parserFactory.setValidating(validateDTD);\n            parserFactory.setFeature(\"http://xml.org/sax/features/namespaces\", true);\n            parserFactory.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", false);\n            parserFactory.setFeature(\"http://xml.org/sax/features/validation\", validateDTD);\n            XMLReader xmlReader = parserFactory.newSAXParser().getXMLReader();\n            TreeBuilder tb = new TreeBuilder();\n            if (schema != null) {\n                VerifierFactory vf = VerifierFactory.newInstance(schemaType);\n                Verifier verifier = vf.newVerifier(schema);\n                VerifierFilter filter = verifier.getVerifierFilter();\n                filter.setParent(xmlReader);\n                xmlReader = filter;\n            }\n            xmlReader.setContentHandler(tb);\n            xmlReader.setErrorHandler(tb);\n            xmlReader.parse(xmlInput);\n            if ((schema != null) && !((VerifierFilter) xmlReader).isValid()) {\n                throw new SAXParseException(\"Invalid XML data\", null, null, -1, -1);\n            }\n            return tb.getTree();\n        } catch (javax.xml.parsers.ParserConfigurationException e) {\n            throw new Error(\"XML parser configuration error: \" + e.getMessage());\n        } catch (VerifierConfigurationException e) {\n            throw new Error(\"XML verifier configuration error: \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Parse an XML document into a list of XTree:s, one for each element under the root.\n     * Uses JAXP to find a parser and JARV to find a validator.\n     * Will not support xml:base.\n     *\n     * @param xmlInput    the input to parse\n     * @param validateDTD validate using DTD\n     * @param schemaType  the type of schema to use, or <code>null</code>\n     *                    for no schema validation\n     * @param schema      the schema to use, or <code>null</code>\n     *                    for no schema validation\n     * @param handler     handler to invoke for each element\n     *\n     * @return the root element (without any children)\n     *\n     * @throws SAXParseException if the XML data is not valid\n     * @throws SAXException if any other error occurs while parsing the XML data\n     * @throws IOException  if there was some I/O error while reading the input.\n     */\n    public static Element parseXMLSequential(InputSource xmlInput, boolean validateDTD, String schemaType, InputSource schema, ElementHandler handler) throws SAXParseException, SAXException, IOException {\n        try {\n            SAXParserFactory parserFactory = SAXParserFactory.newInstance();\n            parserFactory.setNamespaceAware(true);\n            parserFactory.setValidating(validateDTD);\n            XMLReader xmlReader = parserFactory.newSAXParser().getXMLReader();\n            SequentialTreeBuilder tb = new SequentialTreeBuilder(handler);\n            if (schema != null) {\n                VerifierFactory vf = VerifierFactory.newInstance(schemaType);\n                Verifier verifier = vf.newVerifier(schema);\n                VerifierFilter filter = verifier.getVerifierFilter();\n                filter.setParent(xmlReader);\n                xmlReader = filter;\n            }\n            xmlReader.setContentHandler(tb);\n            xmlReader.setErrorHandler(tb);\n            xmlReader.parse(xmlInput);\n            if ((schema != null) && !((VerifierFilter) xmlReader).isValid()) {\n                throw new SAXParseException(\"Invalid XML data\", null, null, -1, -1);\n            }\n            return tb.getRootElement();\n        } catch (javax.xml.parsers.ParserConfigurationException e) {\n            throw new Error(\"XML parser configuration error: \" + e.getMessage());\n        } catch (VerifierConfigurationException e) {\n            throw new Error(\"XML verifier configuration error: \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Serialize an XTree into an OutputStream.\n     *\n     * @param tree      the XTree to serialize\n     * @param os        the OutputStream to write to\n     *\n     * @throws IOException if any error occurs\n     */\n    public static void serialize(Node tree, OutputStream os) throws IOException {\n        Properties prop = new Properties();\n        prop.setProperty(OutputKeys.METHOD, \"xml\");\n        prop.setProperty(OutputKeys.ENCODING, \"utf-8\");\n        prop.setProperty(OutputKeys.INDENT, \"no\");\n        serialize(tree, os, prop);\n    }\n\n    /**\n     * Serialize an XTree into an OutputStream.\n     *\n     * @param tree      the XTree to serialize\n     * @param os        the OutputStream to write to\n     * @param prop  \toutput properties\n     *\n     * @throws IOException if any error occurs\n     */\n    public static void serialize(Node tree, OutputStream os, Properties prop) throws IOException {\n        try {\n            TransformerFactory tf = TransformerFactory.newInstance();\n            if (!(tf.getFeature(SAXTransformerFactory.FEATURE) && tf.getFeature(StreamResult.FEATURE))) {\n                throw new Error(\"The transformer factory \" + tf.getClass().getName() + \" doesn't support SAX\");\n            }\n            SAXTransformerFactory tfactory = (SAXTransformerFactory) tf;\n            TransformerHandler th = tfactory.newTransformerHandler();\n            th.setResult(new StreamResult(os));\n            Transformer trans = th.getTransformer();\n            trans.setOutputProperties(prop);\n            ContentHandler ch = new ContentHandlerFixer(th, true);\n            try {\n                ch.startDocument();\n                tree.toSAX(ch);\n                ch.endDocument();\n            } catch (SAXException e) {\n                throw new IOException(e.toString());\n            }\n        } catch (TransformerConfigurationException e) {\n            throw new Error(e.toString());\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/xtree/XTreeUtilTest1.java",
		"test_prompt": "// XTreeUtilTest1.java\npackage nu.staldal.xtree;\n\nimport java.util.*;\nimport java.io.*;\nimport java.net.URL;\nimport javax.xml.parsers.*;\nimport javax.xml.transform.*;\nimport javax.xml.transform.sax.*;\nimport javax.xml.transform.stream.StreamResult;\nimport org.xml.sax.*;\nimport org.iso_relax.verifier.*;\nimport nu.staldal.xmlutil.ContentHandlerFixer;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XTreeUtil}.\n* It contains ten unit test cases for the {@link XTreeUtil#parseXMLSequential(InputSource, boolean, String, InputSource, ElementHandler)} method.\n*/\nclass XTreeUtilTest1 {"
	},
	{
		"original_code": "// TreeBuilder.java\n/*\n * Copyright (c) 2001-2003, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.xtree;\n\nimport java.util.*;\nimport java.io.*;\nimport java.net.URL;\nimport javax.xml.parsers.*;\nimport org.xml.sax.*;\n\n/**\n * Build an XTree from a SAX2 event stream, or by parsing an XML document.\n *\n * The TreeBuilder ensures that the tree will not have two adjacent Text nodes.\n */\npublic class TreeBuilder implements ContentHandler, ErrorHandler {\n\n    public static final boolean DEBUG = false;\n\n    private Element rootElement = null;\n\n    private Stack elementStack;\n\n    private Vector nsPrefix = null;\n\n    private Vector nsURI = null;\n\n    private StringBuffer textBuffer = null;\n\n    private String textSystemId = null;\n\n    private int textLine = -1;\n\n    private int textColumn = -1;\n\n    private Locator locator = null;\n\n    private URL baseURI;\n\n    /**\n     * Create an SAX InputSource from a File object.\n     *\n     * @param file  the file\n     *\n     * @return an InputSource\n     * @throws FileNotFoundException  if the file doesn't exist\n     * @throws FileNotFoundException  if some I/O error occurs\n     */\n    public static InputSource fileToInputSource(File file) throws FileNotFoundException, IOException {\n        // we should use File.toURL() here, but it's Java2\n        String absPath = file.getCanonicalPath().replace(File.separatorChar, '/');\n        String systemId = \"file:\" + ((absPath.charAt(0) == '/') ? \"//\" : \"///\") + absPath;\n        if (!file.isFile())\n            throw new FileNotFoundException(systemId);\n        return new InputSource(systemId);\n    }\n\n    /**\n     * Parse an XML document into an XTree.\n     * Uses JAXP to find a parser.\n     * Will not support xml:base.\n     *\n     * @param xmlInput    the input to parse\n     * @param validateDTD validate using DTD\n     *\n     * @return an XTree representation of the XML data\n     *\n     * @throws SAXParseException if the XML data is not valid\n     * @throws SAXException if any other error occurs while parsing the XML data\n     * @throws IOException  if there was some I/O error while reading the input.\n     */\n    public static Element parseXML(InputSource xmlInput, boolean validateDTD) throws SAXParseException, SAXException, IOException {\n        try {\n            SAXParserFactory parserFactory = SAXParserFactory.newInstance();\n            parserFactory.setNamespaceAware(true);\n            parserFactory.setValidating(validateDTD);\n            parserFactory.setFeature(\"http://xml.org/sax/features/namespaces\", true);\n            parserFactory.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", false);\n            parserFactory.setFeature(\"http://xml.org/sax/features/validation\", validateDTD);\n            XMLReader xmlReader = parserFactory.newSAXParser().getXMLReader();\n            TreeBuilder tb = new TreeBuilder();\n            xmlReader.setContentHandler(tb);\n            xmlReader.setErrorHandler(tb);\n            xmlReader.parse(xmlInput);\n            return tb.getTree();\n        } catch (javax.xml.parsers.ParserConfigurationException e) {\n            throw new Error(\"XML parser configuration error: \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Constructs a TreeBuilder, ready to receive SAX events.\n     * Will not support xml:base.\n     */\n    public TreeBuilder() {\n        this(null);\n    }\n\n    /**\n     * Constructs a TreeBuilder, ready to receive SAX events.\n     *\n     * @param base  base URL for the document, to support xml:base.\n     */\n    public TreeBuilder(URL base) {\n        elementStack = new Stack();\n        baseURI = base;\n    }\n\n    /**\n     * Obtain the XTree built from SAX events.\n     *\n     * @throws IllegalStateException  if the SAX events received so far\n     * doesn't constitues a well-formed XML document.\n     */\n    public Element getTree() throws IllegalStateException {\n        if (!elementStack.isEmpty())\n            throw new IllegalStateException(\"All elements are not yet ended\");\n        if (rootElement == null)\n            throw new IllegalStateException(\"No root element\");\n        return rootElement;\n    }\n\n    void reset() {\n        rootElement = null;\n        elementStack = new Stack();\n        nsPrefix = null;\n        nsURI = null;\n        textBuffer = null;\n        textSystemId = null;\n        textLine = -1;\n        textColumn = -1;\n    }\n\n    private void addCharacters() {\n        if ((textBuffer != null) && (textBuffer.length() > 0)) {\n            Element parent = (Element) elementStack.peek();\n            Node node = new Text(textBuffer.toString());\n            node.setSystemId(textSystemId);\n            node.setLine(textLine);\n            node.setColumn(textColumn);\n            parent.addChild(node);\n        }\n        textBuffer = null;\n    }\n\n    // ContentHandler implementation\n    public void setDocumentLocator(Locator locator) {\n        this.locator = locator;\n    }\n\n    public void startDocument() throws SAXException {\n        // nothing to do\n    }\n\n    public void endDocument() throws SAXException {\n        // nothing to do\n    }\n\n    public void startElement(String namespaceURI, String localName, String qname, Attributes atts) throws SAXException {\n        addCharacters();\n        if (DEBUG)\n            System.out.println(\"startElement(\" + namespaceURI + ',' + localName + ',' + qname + ')');\n        Element el = new Element(namespaceURI, localName, atts.getLength());\n        if (locator != null) {\n            el.setSystemId(locator.getSystemId());\n            el.setLine(locator.getLineNumber());\n            el.setColumn(locator.getColumnNumber());\n        }\n        if (rootElement == null) {\n            rootElement = el;\n            if (baseURI != null)\n                rootElement.setBaseURI(baseURI);\n        } else {\n            Element parent = (Element) elementStack.peek();\n            parent.addChild(el);\n        }\n        for (int i = 0; i < atts.getLength(); i++) {\n            el.addAttribute(atts.getURI(i), atts.getLocalName(i), atts.getType(i), atts.getValue(i));\n            if (atts.getURI(i).equals(Node.XML_NS) && atts.getLocalName(i).equals(\"base\")) {\n                try {\n                    URL url = new URL(el.getBaseURI(), atts.getValue(i));\n                    el.setBaseURI(url);\n                } catch (java.net.MalformedURLException e) {\n                    throw new SAXException(e);\n                }\n            }\n        }\n        if (nsPrefix != null) {\n            el.setNamespaceMappings(nsPrefix, nsURI);\n        }\n        elementStack.push(el);\n        nsPrefix = null;\n        nsURI = null;\n    }\n\n    public void endElement(String namespaceURI, String localName, String qname) throws SAXException {\n        addCharacters();\n        if (DEBUG)\n            System.out.println(\"endElement(\" + namespaceURI + ',' + localName + ',' + qname + ')');\n        elementStack.pop();\n    }\n\n    public void startPrefixMapping(String prefix, String uri) throws SAXException {\n        if (DEBUG)\n            System.out.println(\"startPrefixMapping(\" + ((prefix.length() == 0) ? \"<default>\" : prefix) + ',' + uri + ')');\n        if (nsPrefix == null) {\n            nsPrefix = new Vector();\n            nsURI = new Vector();\n        }\n        nsPrefix.addElement(prefix);\n        nsURI.addElement(uri);\n    }\n\n    public void endPrefixMapping(String prefix) throws SAXException {\n        if (DEBUG)\n            System.out.println(\"endPrefixMapping(\" + ((prefix.length() == 0) ? \"<default>\" : prefix) + ')');\n        // nothing to do\n    }\n\n    public void characters(char[] ch, int start, int length) throws SAXException {\n        if (textBuffer == null) {\n            textBuffer = new StringBuffer(length);\n        }\n        textBuffer.append(ch, start, length);\n        if (locator != null) {\n            textSystemId = locator.getSystemId();\n            textLine = locator.getLineNumber();\n            textColumn = locator.getColumnNumber();\n        }\n    }\n\n    public void ignorableWhitespace(char[] ch, int start, int length) throws SAXException {\n        // nothing to do\n    }\n\n    public void processingInstruction(String target, String data) throws SAXException {\n        addCharacters();\n        if (DEBUG)\n            System.out.println(\"processingInstruction(\" + target + ',' + data + ')');\n        Element parent = (Element) elementStack.peek();\n        Node node = new ProcessingInstruction(target, data);\n        if (locator != null) {\n            node.setSystemId(locator.getSystemId());\n            node.setLine(locator.getLineNumber());\n            node.setColumn(locator.getColumnNumber());\n        }\n        parent.addChild(node);\n    }\n\n    public void skippedEntity(String name) throws SAXException {\n        // nothing to do\n    }\n\n    // ErrorHandler implementation\n    public void fatalError(SAXParseException e) throws SAXParseException {\n        throw e;\n    }\n\n    public void error(SAXParseException e) throws SAXParseException {\n        throw e;\n    }\n\n    public void warning(SAXParseException e) {\n        // do nothing\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/xtree/TreeBuilderTest0.java",
		"test_prompt": "// TreeBuilderTest0.java\npackage nu.staldal.xtree;\n\nimport java.util.*;\nimport java.io.*;\nimport java.net.URL;\nimport javax.xml.parsers.*;\nimport org.xml.sax.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TreeBuilder}.\n* It contains ten unit test cases for the {@link TreeBuilder#fileToInputSource(File)} method.\n*/\nclass TreeBuilderTest0 {"
	},
	{
		"original_code": "// TreeBuilder.java\n/*\n * Copyright (c) 2001-2003, Mikael Stï¿½ldal\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the author nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * Note: This is known as \"the modified BSD license\". It's an approved\n * Open Source and Free Software license, see\n * http://www.opensource.org/licenses/\n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.xtree;\n\nimport java.util.*;\nimport java.io.*;\nimport java.net.URL;\nimport javax.xml.parsers.*;\nimport org.xml.sax.*;\n\n/**\n * Build an XTree from a SAX2 event stream, or by parsing an XML document.\n *\n * The TreeBuilder ensures that the tree will not have two adjacent Text nodes.\n */\npublic class TreeBuilder implements ContentHandler, ErrorHandler {\n\n    public static final boolean DEBUG = false;\n\n    private Element rootElement = null;\n\n    private Stack elementStack;\n\n    private Vector nsPrefix = null;\n\n    private Vector nsURI = null;\n\n    private StringBuffer textBuffer = null;\n\n    private String textSystemId = null;\n\n    private int textLine = -1;\n\n    private int textColumn = -1;\n\n    private Locator locator = null;\n\n    private URL baseURI;\n\n    /**\n     * Create an SAX InputSource from a File object.\n     *\n     * @param file  the file\n     *\n     * @return an InputSource\n     * @throws FileNotFoundException  if the file doesn't exist\n     * @throws FileNotFoundException  if some I/O error occurs\n     */\n    public static InputSource fileToInputSource(File file) throws FileNotFoundException, IOException {\n        // we should use File.toURL() here, but it's Java2\n        String absPath = file.getCanonicalPath().replace(File.separatorChar, '/');\n        String systemId = \"file:\" + ((absPath.charAt(0) == '/') ? \"//\" : \"///\") + absPath;\n        if (!file.isFile())\n            throw new FileNotFoundException(systemId);\n        return new InputSource(systemId);\n    }\n\n    /**\n     * Parse an XML document into an XTree.\n     * Uses JAXP to find a parser.\n     * Will not support xml:base.\n     *\n     * @param xmlInput    the input to parse\n     * @param validateDTD validate using DTD\n     *\n     * @return an XTree representation of the XML data\n     *\n     * @throws SAXParseException if the XML data is not valid\n     * @throws SAXException if any other error occurs while parsing the XML data\n     * @throws IOException  if there was some I/O error while reading the input.\n     */\n    public static Element parseXML(InputSource xmlInput, boolean validateDTD) throws SAXParseException, SAXException, IOException {\n        try {\n            SAXParserFactory parserFactory = SAXParserFactory.newInstance();\n            parserFactory.setNamespaceAware(true);\n            parserFactory.setValidating(validateDTD);\n            parserFactory.setFeature(\"http://xml.org/sax/features/namespaces\", true);\n            parserFactory.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", false);\n            parserFactory.setFeature(\"http://xml.org/sax/features/validation\", validateDTD);\n            XMLReader xmlReader = parserFactory.newSAXParser().getXMLReader();\n            TreeBuilder tb = new TreeBuilder();\n            xmlReader.setContentHandler(tb);\n            xmlReader.setErrorHandler(tb);\n            xmlReader.parse(xmlInput);\n            return tb.getTree();\n        } catch (javax.xml.parsers.ParserConfigurationException e) {\n            throw new Error(\"XML parser configuration error: \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Constructs a TreeBuilder, ready to receive SAX events.\n     * Will not support xml:base.\n     */\n    public TreeBuilder() {\n        this(null);\n    }\n\n    /**\n     * Constructs a TreeBuilder, ready to receive SAX events.\n     *\n     * @param base  base URL for the document, to support xml:base.\n     */\n    public TreeBuilder(URL base) {\n        elementStack = new Stack();\n        baseURI = base;\n    }\n\n    /**\n     * Obtain the XTree built from SAX events.\n     *\n     * @throws IllegalStateException  if the SAX events received so far\n     * doesn't constitues a well-formed XML document.\n     */\n    public Element getTree() throws IllegalStateException {\n        if (!elementStack.isEmpty())\n            throw new IllegalStateException(\"All elements are not yet ended\");\n        if (rootElement == null)\n            throw new IllegalStateException(\"No root element\");\n        return rootElement;\n    }\n\n    void reset() {\n        rootElement = null;\n        elementStack = new Stack();\n        nsPrefix = null;\n        nsURI = null;\n        textBuffer = null;\n        textSystemId = null;\n        textLine = -1;\n        textColumn = -1;\n    }\n\n    private void addCharacters() {\n        if ((textBuffer != null) && (textBuffer.length() > 0)) {\n            Element parent = (Element) elementStack.peek();\n            Node node = new Text(textBuffer.toString());\n            node.setSystemId(textSystemId);\n            node.setLine(textLine);\n            node.setColumn(textColumn);\n            parent.addChild(node);\n        }\n        textBuffer = null;\n    }\n\n    // ContentHandler implementation\n    public void setDocumentLocator(Locator locator) {\n        this.locator = locator;\n    }\n\n    public void startDocument() throws SAXException {\n        // nothing to do\n    }\n\n    public void endDocument() throws SAXException {\n        // nothing to do\n    }\n\n    public void startElement(String namespaceURI, String localName, String qname, Attributes atts) throws SAXException {\n        addCharacters();\n        if (DEBUG)\n            System.out.println(\"startElement(\" + namespaceURI + ',' + localName + ',' + qname + ')');\n        Element el = new Element(namespaceURI, localName, atts.getLength());\n        if (locator != null) {\n            el.setSystemId(locator.getSystemId());\n            el.setLine(locator.getLineNumber());\n            el.setColumn(locator.getColumnNumber());\n        }\n        if (rootElement == null) {\n            rootElement = el;\n            if (baseURI != null)\n                rootElement.setBaseURI(baseURI);\n        } else {\n            Element parent = (Element) elementStack.peek();\n            parent.addChild(el);\n        }\n        for (int i = 0; i < atts.getLength(); i++) {\n            el.addAttribute(atts.getURI(i), atts.getLocalName(i), atts.getType(i), atts.getValue(i));\n            if (atts.getURI(i).equals(Node.XML_NS) && atts.getLocalName(i).equals(\"base\")) {\n                try {\n                    URL url = new URL(el.getBaseURI(), atts.getValue(i));\n                    el.setBaseURI(url);\n                } catch (java.net.MalformedURLException e) {\n                    throw new SAXException(e);\n                }\n            }\n        }\n        if (nsPrefix != null) {\n            el.setNamespaceMappings(nsPrefix, nsURI);\n        }\n        elementStack.push(el);\n        nsPrefix = null;\n        nsURI = null;\n    }\n\n    public void endElement(String namespaceURI, String localName, String qname) throws SAXException {\n        addCharacters();\n        if (DEBUG)\n            System.out.println(\"endElement(\" + namespaceURI + ',' + localName + ',' + qname + ')');\n        elementStack.pop();\n    }\n\n    public void startPrefixMapping(String prefix, String uri) throws SAXException {\n        if (DEBUG)\n            System.out.println(\"startPrefixMapping(\" + ((prefix.length() == 0) ? \"<default>\" : prefix) + ',' + uri + ')');\n        if (nsPrefix == null) {\n            nsPrefix = new Vector();\n            nsURI = new Vector();\n        }\n        nsPrefix.addElement(prefix);\n        nsURI.addElement(uri);\n    }\n\n    public void endPrefixMapping(String prefix) throws SAXException {\n        if (DEBUG)\n            System.out.println(\"endPrefixMapping(\" + ((prefix.length() == 0) ? \"<default>\" : prefix) + ')');\n        // nothing to do\n    }\n\n    public void characters(char[] ch, int start, int length) throws SAXException {\n        if (textBuffer == null) {\n            textBuffer = new StringBuffer(length);\n        }\n        textBuffer.append(ch, start, length);\n        if (locator != null) {\n            textSystemId = locator.getSystemId();\n            textLine = locator.getLineNumber();\n            textColumn = locator.getColumnNumber();\n        }\n    }\n\n    public void ignorableWhitespace(char[] ch, int start, int length) throws SAXException {\n        // nothing to do\n    }\n\n    public void processingInstruction(String target, String data) throws SAXException {\n        addCharacters();\n        if (DEBUG)\n            System.out.println(\"processingInstruction(\" + target + ',' + data + ')');\n        Element parent = (Element) elementStack.peek();\n        Node node = new ProcessingInstruction(target, data);\n        if (locator != null) {\n            node.setSystemId(locator.getSystemId());\n            node.setLine(locator.getLineNumber());\n            node.setColumn(locator.getColumnNumber());\n        }\n        parent.addChild(node);\n    }\n\n    public void skippedEntity(String name) throws SAXException {\n        // nothing to do\n    }\n\n    // ErrorHandler implementation\n    public void fatalError(SAXParseException e) throws SAXParseException {\n        throw e;\n    }\n\n    public void error(SAXParseException e) throws SAXParseException {\n        throw e;\n    }\n\n    public void warning(SAXParseException e) {\n        // do nothing\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/xtree/TreeBuilderTest1.java",
		"test_prompt": "// TreeBuilderTest1.java\npackage nu.staldal.xtree;\n\nimport java.util.*;\nimport java.io.*;\nimport java.net.URL;\nimport javax.xml.parsers.*;\nimport org.xml.sax.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TreeBuilder}.\n* It contains ten unit test cases for the {@link TreeBuilder#parseXML(InputSource, boolean)} method.\n*/\nclass TreeBuilderTest1 {"
	},
	{
		"original_code": "// OutputConfig.java\n/*\n * Copyright (c) 2005, Mikael Stï¿½ldal\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without \n * modification, are permitted provided that the following conditions \n * are met:\n * \n * 1. Redistributions of source code must retain the above copyright \n * notice, this list of conditions and the following disclaimer.\n * \n * 2. Redistributions in binary form must reproduce the above copyright \n * notice, this list of conditions and the following disclaimer in the \n * documentation and/or other materials provided with the distribution.\n * \n * 3. Neither the name of the author nor the names of its contributors \n * may be used to endorse or promote products derived from this software \n * without specific prior written permission. \n * \n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR \n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR \n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, \n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, \n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR \n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY \n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n * \n * \n * Note: This is known as \"the modified BSD license\". It's an approved \n * Open Source and Free Software license, see \n * http://www.opensource.org/licenses/ \n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.xodus;\n\nimport java.util.*;\nimport javax.xml.transform.OutputKeys;\n\n/**\n * Output config.\n */\npublic class OutputConfig {\n\n    public String method;\n\n    public boolean isXhtml = false;\n\n    public boolean isText = false;\n\n    public boolean isHtml = false;\n\n    public String version;\n\n    public String encoding;\n\n    public int omit_xml_declaration;\n\n    public boolean standalone;\n\n    public String doctype_public;\n\n    public String doctype_system;\n\n    public Set cdata_section_elements;\n\n    public boolean indent;\n\n    public String media_type;\n\n    /**\n     * Factory method.\n     */\n    public static OutputConfig createOutputConfig(Properties outputProps) {\n        return new OutputConfig(outputProps);\n    }\n\n    private OutputConfig(Properties outputProps) throws IllegalArgumentException {\n        method = outputProps.getProperty(OutputKeys.METHOD);\n        if (method == null)\n            throw new IllegalArgumentException(\"Output method must be specified\");\n        else if (method.equals(\"xml\"))\n            ;\n        else if (method.equals(\"xhtml\"))\n            isXhtml = true;\n        else if (method.equals(\"text\"))\n            isText = true;\n        else if (method.equals(\"html\"))\n            isHtml = true;\n        else\n            throw new IllegalArgumentException(\"Unknown output method: \" + method);\n        version = outputProps.getProperty(OutputKeys.VERSION);\n        if (version == null)\n            version = isHtml ? \"4.0\" : \"1.0\";\n        encoding = outputProps.getProperty(OutputKeys.ENCODING);\n        if (encoding == null)\n            encoding = (isText || isHtml) ? \"iso-8859-1\" : \"UTF-8\";\n        String omit = outputProps.getProperty(OutputKeys.OMIT_XML_DECLARATION);\n        if (omit == null)\n            omit_xml_declaration = 0;\n        else if (omit.equals(\"yes\") || omit.equals(\"omit_xml_declaration\"))\n            omit_xml_declaration = 1;\n        else if (omit.equals(\"no\"))\n            omit_xml_declaration = -1;\n        else\n            throw new IllegalArgumentException(\"Illegal omit_xml_declaration value: \" + omit);\n        String _standalone = outputProps.getProperty(OutputKeys.STANDALONE);\n        if (_standalone == null)\n            standalone = false;\n        else if (_standalone.equals(\"yes\") || _standalone.equals(\"standalone\"))\n            standalone = true;\n        else if (_standalone.equals(\"no\"))\n            standalone = false;\n        else\n            throw new IllegalArgumentException(\"Illegal standalone value: \" + _standalone);\n        String _doctype_public = outputProps.getProperty(OutputKeys.DOCTYPE_PUBLIC);\n        if (_doctype_public != null)\n            doctype_public = _doctype_public;\n        String _doctype_system = outputProps.getProperty(OutputKeys.DOCTYPE_SYSTEM);\n        if (_doctype_system != null)\n            doctype_system = _doctype_system;\n        String cdata = outputProps.getProperty(OutputKeys.CDATA_SECTION_ELEMENTS);\n        if (cdata == null) {\n            cdata_section_elements = Collections.EMPTY_SET;\n        } else {\n            cdata_section_elements = new HashSet();\n            for (StringTokenizer st = new StringTokenizer(cdata); st.hasMoreTokens(); ) {\n                cdata_section_elements.add(st.nextToken());\n            }\n        }\n        String _indent = outputProps.getProperty(OutputKeys.INDENT);\n        if (_indent == null)\n            indent = false;\n        else if (_indent.equals(\"yes\") || _indent.equals(\"indent\"))\n            indent = true;\n        else if (_indent.equals(\"no\"))\n            indent = false;\n        else\n            throw new IllegalArgumentException(\"Illegal indent value: \" + _indent);\n        media_type = outputProps.getProperty(OutputKeys.MEDIA_TYPE);\n        if (media_type == null) {\n            if (isHtml)\n                media_type = \"text/html\";\n            else if (isXhtml)\n                media_type = \"text/html\";\n            else if (isText)\n                media_type = \"text/plain\";\n            else\n                media_type = \"text/xml\";\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/xodus/OutputConfigTest.java",
		"test_prompt": "// OutputConfigTest.java\npackage nu.staldal.xodus;\n\nimport java.util.*;\nimport javax.xml.transform.OutputKeys;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link OutputConfig}.\n* It contains ten unit test cases for the {@link OutputConfig#createOutputConfig(Properties)} method.\n*/\nclass OutputConfigTest {"
	},
	{
		"original_code": "// Serializer.java\n/*\n * Copyright (c) 2005, Mikael Stï¿½ldal\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without \n * modification, are permitted provided that the following conditions \n * are met:\n * \n * 1. Redistributions of source code must retain the above copyright \n * notice, this list of conditions and the following disclaimer.\n * \n * 2. Redistributions in binary form must reproduce the above copyright \n * notice, this list of conditions and the following disclaimer in the \n * documentation and/or other materials provided with the distribution.\n * \n * 3. Neither the name of the author nor the names of its contributors \n * may be used to endorse or promote products derived from this software \n * without specific prior written permission. \n * \n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR \n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR \n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, \n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, \n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR \n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY \n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n * \n * \n * Note: This is known as \"the modified BSD license\". It's an approved \n * Open Source and Free Software license, see \n * http://www.opensource.org/licenses/ \n * and\n * http://www.gnu.org/philosophy/license-list.html\n */\npackage nu.staldal.xodus;\n\nimport java.io.*;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.util.Properties;\nimport org.xml.sax.*;\nimport org.xml.sax.ext.LexicalHandler;\nimport org.xml.sax.ext.DeclHandler;\nimport javax.xml.transform.Result;\nimport javax.xml.transform.stream.StreamResult;\n\n/**\n *  Serialize SAX2 events to its textual XML representation.\n * <p>\n *  Support output to XML, XHTML, HTML and Text. Full support for XML namespaces.\n * <p>\n *  The {@link #startDocument} and {@link #endDocument} method must be used.\n * <p>\n *  Output properties controls the serialization process, it uses the keys in\n *  <code>javax.xml.transform.OutputKeys</code>.\n * <p>\n *  The METHOD output property must be specified. It can be\n *  \"xml\", \"xhtml\", \"text\" or \"html\".\n * <p>\n *  The CDATA_SECTION_ELEMENTS output property is not supported.\n * <p>\n *  The ENCODING output property defaults to UTF-8 for XML and XHTML,\n *  and to ISO-8859-1 for Text and HTML.\n * <p>\n *  The \"html\" output method does <em>not</em> escape non-ASCII characters\n *  in URI attribute values, as specified in the XSLT 1.0 specification.\n * <p>\n *  <code>javax.xml.transform.Result.PI_DISABLE_OUTPUT_ESCAPING</code>\n *  and\n *  <code>javax.xml.transform.Result.PI_ENABLE_OUTPUT_ESCAPING</code>\n *   can be used as processingInstruction targets to disable output escaping.\n */\npublic abstract class Serializer implements ContentHandler, LexicalHandler, DTDHandler, DeclHandler {\n\n    protected final OutputConfig outputConfig;\n\n    protected final String systemId;\n\n    protected final XMLCharacterEncoder out;\n\n    private final boolean doClose;\n\n    /**\n     * Factory method, create a new Serializer.\n     *\n     * @param result  specifies where to write the textual representation.\n     * @param outputProperties output properties, uses {@link javax.xml.transform.OutputKeys}\n     *\n     * @return a new Serializer\n     *\n     * @throws UnsupportedEncodingException if the ENCODING output property\n     *         is invalid.\n     * @throws IllegalArgumentException if any other output property is invalid.\n     * @throws IOException if the result is invalid.\n     */\n    public static Serializer createSerializer(StreamResult result, Properties outputProperties) throws IllegalArgumentException, IOException, UnsupportedEncodingException {\n        OutputConfig outputConfig = OutputConfig.createOutputConfig(outputProperties);\n        if (outputConfig.isHtml)\n            return new HTMLSerializer(result, outputConfig);\n        else if (outputConfig.isXhtml)\n            return new XMLSerializer(result, outputConfig);\n        else if (outputConfig.isText)\n            return new TextSerializer(result, outputConfig);\n        else\n            // XML\n            return new XMLSerializer(result, outputConfig);\n    }\n\n    protected Serializer(StreamResult result, OutputConfig outputConfig) throws IllegalArgumentException, IOException, UnsupportedEncodingException {\n        this.outputConfig = outputConfig;\n        if (!outputConfig.cdata_section_elements.isEmpty()) {\n            throw new IllegalArgumentException(\"cdata_section_elements is not supported\");\n        }\n        this.systemId = result.getSystemId();\n        OutputStream os = result.getOutputStream();\n        Writer w = result.getWriter();\n        if (os != null) {\n            out = new XMLCharacterEncoder(os, outputConfig.encoding);\n            doClose = false;\n        } else if (w != null) {\n            out = new XMLCharacterEncoder(w);\n            doClose = false;\n        } else if (systemId != null) {\n            OutputStream _os;\n            try {\n                URI uri = new URI(systemId);\n                if (!uri.isAbsolute()) {\n                    File file = new File(systemId);\n                    _os = new FileOutputStream(file);\n                } else if (uri.getScheme().equals(\"file\")) {\n                    File file = new File(uri);\n                    _os = new FileOutputStream(file);\n                } else // Absolute URI with other scheme than \"file:\"\n                {\n                    URL url = uri.toURL();\n                    URLConnection urlConn = url.openConnection();\n                    urlConn.setDoOutput(true);\n                    _os = urlConn.getOutputStream();\n                }\n            } catch (URISyntaxException e) {\n                throw new IllegalArgumentException(\"Invalid systemId: \" + e.getMessage());\n            }\n            os = new BufferedOutputStream(_os);\n            out = new XMLCharacterEncoder(os, outputConfig.encoding);\n            doClose = true;\n        } else {\n            throw new IllegalArgumentException(\"Empty StreamResult\");\n        }\n    }\n\n    /**\n     * Finish writing to output. Does <em>not</em> close output if\n     * an {@link java.io.OutputStream} or {@link Writer} was provided.\n     */\n    protected void finishOutput() throws IOException {\n        out.finish();\n        if (doClose)\n            out.close();\n    }\n\n    /**\n     * Write a newline.\n     */\n    protected void newline() throws IOException {\n        out.write('\\n');\n    }\n}\n",
		"id": "EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/xodus/SerializerTest.java",
		"test_prompt": "// SerializerTest.java\npackage nu.staldal.xodus;\n\nimport java.io.*;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.util.Properties;\nimport org.xml.sax.*;\nimport org.xml.sax.ext.LexicalHandler;\nimport org.xml.sax.ext.DeclHandler;\nimport javax.xml.transform.Result;\nimport javax.xml.transform.stream.StreamResult;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Serializer}.\n* It contains ten unit test cases for the {@link Serializer#createSerializer(StreamResult, Properties)} method.\n*/\nclass SerializerTest {"
	}
]