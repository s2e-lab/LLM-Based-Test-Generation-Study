[
	{
		"original_code": "// ObjectViewManager.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.util;\r\n\r\nimport java.lang.reflect.Modifier;\r\nimport java.util.Collection;\r\nimport java.util.Vector;\r\nimport de.paragon.explorer.model.AttributeModel;\r\nimport de.paragon.explorer.model.NullObject;\r\nimport de.paragon.explorer.model.ObjectModel;\r\n\r\npublic class ObjectViewManager {\r\n\r\n    private boolean allAttributesVisible;\r\n\r\n    private boolean nullAttributesVisible = PropertyManager.getInstance().getHideNullAttribut();\r\n\r\n    private boolean staticAttributesVisible = PropertyManager.getInstance().getHideStaticAttribut();\r\n\r\n    private boolean attributesToDisplay;\r\n\r\n    private boolean removeDependencies = PropertyManager.getInstance().getHideUnexploredAttribut();\r\n\r\n    private Collection<AttributeModel> attributeModels;\r\n\r\n    private ObjectModel objectModel;\r\n\r\n    private boolean unexploredAttributesVisible;\r\n\r\n    /**\r\n     * ObjectViewManager constructor comment.\r\n     */\r\n    public ObjectViewManager() {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * ObjectViewManager constructor comment.\r\n     */\r\n    public ObjectViewManager(ObjectModel newObjectModel) {\r\n        super();\r\n        this.setObjectModel(newObjectModel);\r\n    }\r\n\r\n    public boolean isAllAttributesVisible() {\r\n        return this.allAttributesVisible;\r\n    }\r\n\r\n    public Collection<AttributeModel> getAttributeModels() {\r\n        if (this.attributeModels == null) {\r\n            this.setAttributeModels(new Vector<AttributeModel>());\r\n        }\r\n        return this.attributeModels;\r\n    }\r\n\r\n    public Collection<AttributeModel> getInvisibleAttributes() {\r\n        AttributeModel attrModl;\r\n        Vector<AttributeModel> vector = new Vector<AttributeModel>();\r\n        StandardEnumeration attrModls = this.getObjectModel().getAttributeModels();\r\n        while (attrModls.hasMoreElements()) {\r\n            attrModl = (AttributeModel) attrModls.nextElement();\r\n            if (!(attrModl.isVisible())) {\r\n                vector.addElement(attrModl);\r\n            }\r\n        }\r\n        return vector;\r\n    }\r\n\r\n    public ObjectModel getObjectModel() {\r\n        return this.objectModel;\r\n    }\r\n\r\n    public boolean isStaticAttributesVisible() {\r\n        return this.staticAttributesVisible;\r\n    }\r\n\r\n    public boolean isUnexploredAttributesVisible() {\r\n        return this.unexploredAttributesVisible;\r\n    }\r\n\r\n    public Collection<AttributeModel> getVisibleAttributes() {\r\n        AttributeModel attrModl;\r\n        Vector<AttributeModel> vector = new Vector<AttributeModel>();\r\n        StandardEnumeration attrModls = this.getObjectModel().getAttributeModels();\r\n        while (attrModls.hasMoreElements()) {\r\n            attrModl = (AttributeModel) attrModls.nextElement();\r\n            if (attrModl.isVisible()) {\r\n                vector.addElement(attrModl);\r\n            }\r\n        }\r\n        return vector;\r\n    }\r\n\r\n    public boolean hasAttributesToDisplay() {\r\n        return this.attributesToDisplay;\r\n    }\r\n\r\n    /**\r\n     * @return Returns the removeDependencies.\r\n     */\r\n    public boolean isRemoveDependencies() {\r\n        return this.removeDependencies;\r\n    }\r\n\r\n    public void setAllAttributesVisible(boolean newAllAttributesVisible) {\r\n        this.allAttributesVisible = newAllAttributesVisible;\r\n    }\r\n\r\n    private void setAttributeModels(Collection<AttributeModel> newAttributeModels) {\r\n        this.attributeModels = newAttributeModels;\r\n    }\r\n\r\n    public void setAttributesToDisplay(boolean newValue) {\r\n        this.attributesToDisplay = newValue;\r\n    }\r\n\r\n    public void setNullAttributesVisible(boolean newNullAttributesVisible) {\r\n        this.nullAttributesVisible = newNullAttributesVisible;\r\n    }\r\n\r\n    private void setObjectModel(ObjectModel newObjectModel) {\r\n        this.objectModel = newObjectModel;\r\n    }\r\n\r\n    /**\r\n     * @param removeDependencies\r\n     *            The removeDependencies to set.\r\n     */\r\n    public void setRemoveDependencies(boolean newRemoveDependencies) {\r\n        this.removeDependencies = newRemoveDependencies;\r\n    }\r\n\r\n    public void setStaticAttributesVisible(boolean newStaticAttributesVisible) {\r\n        this.staticAttributesVisible = newStaticAttributesVisible;\r\n    }\r\n\r\n    public void setUnexploredAttributesVisible(boolean newUnexploredAttributesVisible) {\r\n        this.unexploredAttributesVisible = newUnexploredAttributesVisible;\r\n    }\r\n\r\n    public boolean shouldBeVisible(AttributeModel attrModl) {\r\n        if (!(this.isNullAttributesVisible()) && NullObject.isNullObject(attrModl.getValue())) {\r\n            return false;\r\n        }\r\n        if (!(this.isStaticAttributesVisible()) && (Modifier.isStatic(attrModl.getModifiers()))) {\r\n            return false;\r\n        }\r\n        if (!(this.isUnexploredAttributesVisible()) && (attrModl.getConnectionModel() == null)) {\r\n            return false;\r\n        }\r\n        if (this.isAllAttributesVisible()) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public boolean isNullAttributesVisible() {\r\n        return this.nullAttributesVisible;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/util/ObjectViewManagerTest0.java",
		"test_prompt": "// ObjectViewManagerTest0.java\npackage de.paragon.explorer.util;\n\nimport java.lang.reflect.Modifier;\nimport java.util.Collection;\nimport java.util.Vector;\nimport de.paragon.explorer.model.AttributeModel;\nimport de.paragon.explorer.model.NullObject;\nimport de.paragon.explorer.model.ObjectModel;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectViewManager}.\n* It contains ten unit test cases for the {@link ObjectViewManager#isAllAttributesVisible()} method.\n*/\nclass ObjectViewManagerTest0 {"
	},
	{
		"original_code": "// ObjectViewManager.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.util;\r\n\r\nimport java.lang.reflect.Modifier;\r\nimport java.util.Collection;\r\nimport java.util.Vector;\r\nimport de.paragon.explorer.model.AttributeModel;\r\nimport de.paragon.explorer.model.NullObject;\r\nimport de.paragon.explorer.model.ObjectModel;\r\n\r\npublic class ObjectViewManager {\r\n\r\n    private boolean allAttributesVisible;\r\n\r\n    private boolean nullAttributesVisible = PropertyManager.getInstance().getHideNullAttribut();\r\n\r\n    private boolean staticAttributesVisible = PropertyManager.getInstance().getHideStaticAttribut();\r\n\r\n    private boolean attributesToDisplay;\r\n\r\n    private boolean removeDependencies = PropertyManager.getInstance().getHideUnexploredAttribut();\r\n\r\n    private Collection<AttributeModel> attributeModels;\r\n\r\n    private ObjectModel objectModel;\r\n\r\n    private boolean unexploredAttributesVisible;\r\n\r\n    /**\r\n     * ObjectViewManager constructor comment.\r\n     */\r\n    public ObjectViewManager() {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * ObjectViewManager constructor comment.\r\n     */\r\n    public ObjectViewManager(ObjectModel newObjectModel) {\r\n        super();\r\n        this.setObjectModel(newObjectModel);\r\n    }\r\n\r\n    public boolean isAllAttributesVisible() {\r\n        return this.allAttributesVisible;\r\n    }\r\n\r\n    public Collection<AttributeModel> getAttributeModels() {\r\n        if (this.attributeModels == null) {\r\n            this.setAttributeModels(new Vector<AttributeModel>());\r\n        }\r\n        return this.attributeModels;\r\n    }\r\n\r\n    public Collection<AttributeModel> getInvisibleAttributes() {\r\n        AttributeModel attrModl;\r\n        Vector<AttributeModel> vector = new Vector<AttributeModel>();\r\n        StandardEnumeration attrModls = this.getObjectModel().getAttributeModels();\r\n        while (attrModls.hasMoreElements()) {\r\n            attrModl = (AttributeModel) attrModls.nextElement();\r\n            if (!(attrModl.isVisible())) {\r\n                vector.addElement(attrModl);\r\n            }\r\n        }\r\n        return vector;\r\n    }\r\n\r\n    public ObjectModel getObjectModel() {\r\n        return this.objectModel;\r\n    }\r\n\r\n    public boolean isStaticAttributesVisible() {\r\n        return this.staticAttributesVisible;\r\n    }\r\n\r\n    public boolean isUnexploredAttributesVisible() {\r\n        return this.unexploredAttributesVisible;\r\n    }\r\n\r\n    public Collection<AttributeModel> getVisibleAttributes() {\r\n        AttributeModel attrModl;\r\n        Vector<AttributeModel> vector = new Vector<AttributeModel>();\r\n        StandardEnumeration attrModls = this.getObjectModel().getAttributeModels();\r\n        while (attrModls.hasMoreElements()) {\r\n            attrModl = (AttributeModel) attrModls.nextElement();\r\n            if (attrModl.isVisible()) {\r\n                vector.addElement(attrModl);\r\n            }\r\n        }\r\n        return vector;\r\n    }\r\n\r\n    public boolean hasAttributesToDisplay() {\r\n        return this.attributesToDisplay;\r\n    }\r\n\r\n    /**\r\n     * @return Returns the removeDependencies.\r\n     */\r\n    public boolean isRemoveDependencies() {\r\n        return this.removeDependencies;\r\n    }\r\n\r\n    public void setAllAttributesVisible(boolean newAllAttributesVisible) {\r\n        this.allAttributesVisible = newAllAttributesVisible;\r\n    }\r\n\r\n    private void setAttributeModels(Collection<AttributeModel> newAttributeModels) {\r\n        this.attributeModels = newAttributeModels;\r\n    }\r\n\r\n    public void setAttributesToDisplay(boolean newValue) {\r\n        this.attributesToDisplay = newValue;\r\n    }\r\n\r\n    public void setNullAttributesVisible(boolean newNullAttributesVisible) {\r\n        this.nullAttributesVisible = newNullAttributesVisible;\r\n    }\r\n\r\n    private void setObjectModel(ObjectModel newObjectModel) {\r\n        this.objectModel = newObjectModel;\r\n    }\r\n\r\n    /**\r\n     * @param removeDependencies\r\n     *            The removeDependencies to set.\r\n     */\r\n    public void setRemoveDependencies(boolean newRemoveDependencies) {\r\n        this.removeDependencies = newRemoveDependencies;\r\n    }\r\n\r\n    public void setStaticAttributesVisible(boolean newStaticAttributesVisible) {\r\n        this.staticAttributesVisible = newStaticAttributesVisible;\r\n    }\r\n\r\n    public void setUnexploredAttributesVisible(boolean newUnexploredAttributesVisible) {\r\n        this.unexploredAttributesVisible = newUnexploredAttributesVisible;\r\n    }\r\n\r\n    public boolean shouldBeVisible(AttributeModel attrModl) {\r\n        if (!(this.isNullAttributesVisible()) && NullObject.isNullObject(attrModl.getValue())) {\r\n            return false;\r\n        }\r\n        if (!(this.isStaticAttributesVisible()) && (Modifier.isStatic(attrModl.getModifiers()))) {\r\n            return false;\r\n        }\r\n        if (!(this.isUnexploredAttributesVisible()) && (attrModl.getConnectionModel() == null)) {\r\n            return false;\r\n        }\r\n        if (this.isAllAttributesVisible()) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public boolean isNullAttributesVisible() {\r\n        return this.nullAttributesVisible;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/util/ObjectViewManagerTest1.java",
		"test_prompt": "// ObjectViewManagerTest1.java\npackage de.paragon.explorer.util;\n\nimport java.lang.reflect.Modifier;\nimport java.util.Collection;\nimport java.util.Vector;\nimport de.paragon.explorer.model.AttributeModel;\nimport de.paragon.explorer.model.NullObject;\nimport de.paragon.explorer.model.ObjectModel;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectViewManager}.\n* It contains ten unit test cases for the {@link ObjectViewManager#isStaticAttributesVisible()} method.\n*/\nclass ObjectViewManagerTest1 {"
	},
	{
		"original_code": "// ObjectViewManager.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.util;\r\n\r\nimport java.lang.reflect.Modifier;\r\nimport java.util.Collection;\r\nimport java.util.Vector;\r\nimport de.paragon.explorer.model.AttributeModel;\r\nimport de.paragon.explorer.model.NullObject;\r\nimport de.paragon.explorer.model.ObjectModel;\r\n\r\npublic class ObjectViewManager {\r\n\r\n    private boolean allAttributesVisible;\r\n\r\n    private boolean nullAttributesVisible = PropertyManager.getInstance().getHideNullAttribut();\r\n\r\n    private boolean staticAttributesVisible = PropertyManager.getInstance().getHideStaticAttribut();\r\n\r\n    private boolean attributesToDisplay;\r\n\r\n    private boolean removeDependencies = PropertyManager.getInstance().getHideUnexploredAttribut();\r\n\r\n    private Collection<AttributeModel> attributeModels;\r\n\r\n    private ObjectModel objectModel;\r\n\r\n    private boolean unexploredAttributesVisible;\r\n\r\n    /**\r\n     * ObjectViewManager constructor comment.\r\n     */\r\n    public ObjectViewManager() {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * ObjectViewManager constructor comment.\r\n     */\r\n    public ObjectViewManager(ObjectModel newObjectModel) {\r\n        super();\r\n        this.setObjectModel(newObjectModel);\r\n    }\r\n\r\n    public boolean isAllAttributesVisible() {\r\n        return this.allAttributesVisible;\r\n    }\r\n\r\n    public Collection<AttributeModel> getAttributeModels() {\r\n        if (this.attributeModels == null) {\r\n            this.setAttributeModels(new Vector<AttributeModel>());\r\n        }\r\n        return this.attributeModels;\r\n    }\r\n\r\n    public Collection<AttributeModel> getInvisibleAttributes() {\r\n        AttributeModel attrModl;\r\n        Vector<AttributeModel> vector = new Vector<AttributeModel>();\r\n        StandardEnumeration attrModls = this.getObjectModel().getAttributeModels();\r\n        while (attrModls.hasMoreElements()) {\r\n            attrModl = (AttributeModel) attrModls.nextElement();\r\n            if (!(attrModl.isVisible())) {\r\n                vector.addElement(attrModl);\r\n            }\r\n        }\r\n        return vector;\r\n    }\r\n\r\n    public ObjectModel getObjectModel() {\r\n        return this.objectModel;\r\n    }\r\n\r\n    public boolean isStaticAttributesVisible() {\r\n        return this.staticAttributesVisible;\r\n    }\r\n\r\n    public boolean isUnexploredAttributesVisible() {\r\n        return this.unexploredAttributesVisible;\r\n    }\r\n\r\n    public Collection<AttributeModel> getVisibleAttributes() {\r\n        AttributeModel attrModl;\r\n        Vector<AttributeModel> vector = new Vector<AttributeModel>();\r\n        StandardEnumeration attrModls = this.getObjectModel().getAttributeModels();\r\n        while (attrModls.hasMoreElements()) {\r\n            attrModl = (AttributeModel) attrModls.nextElement();\r\n            if (attrModl.isVisible()) {\r\n                vector.addElement(attrModl);\r\n            }\r\n        }\r\n        return vector;\r\n    }\r\n\r\n    public boolean hasAttributesToDisplay() {\r\n        return this.attributesToDisplay;\r\n    }\r\n\r\n    /**\r\n     * @return Returns the removeDependencies.\r\n     */\r\n    public boolean isRemoveDependencies() {\r\n        return this.removeDependencies;\r\n    }\r\n\r\n    public void setAllAttributesVisible(boolean newAllAttributesVisible) {\r\n        this.allAttributesVisible = newAllAttributesVisible;\r\n    }\r\n\r\n    private void setAttributeModels(Collection<AttributeModel> newAttributeModels) {\r\n        this.attributeModels = newAttributeModels;\r\n    }\r\n\r\n    public void setAttributesToDisplay(boolean newValue) {\r\n        this.attributesToDisplay = newValue;\r\n    }\r\n\r\n    public void setNullAttributesVisible(boolean newNullAttributesVisible) {\r\n        this.nullAttributesVisible = newNullAttributesVisible;\r\n    }\r\n\r\n    private void setObjectModel(ObjectModel newObjectModel) {\r\n        this.objectModel = newObjectModel;\r\n    }\r\n\r\n    /**\r\n     * @param removeDependencies\r\n     *            The removeDependencies to set.\r\n     */\r\n    public void setRemoveDependencies(boolean newRemoveDependencies) {\r\n        this.removeDependencies = newRemoveDependencies;\r\n    }\r\n\r\n    public void setStaticAttributesVisible(boolean newStaticAttributesVisible) {\r\n        this.staticAttributesVisible = newStaticAttributesVisible;\r\n    }\r\n\r\n    public void setUnexploredAttributesVisible(boolean newUnexploredAttributesVisible) {\r\n        this.unexploredAttributesVisible = newUnexploredAttributesVisible;\r\n    }\r\n\r\n    public boolean shouldBeVisible(AttributeModel attrModl) {\r\n        if (!(this.isNullAttributesVisible()) && NullObject.isNullObject(attrModl.getValue())) {\r\n            return false;\r\n        }\r\n        if (!(this.isStaticAttributesVisible()) && (Modifier.isStatic(attrModl.getModifiers()))) {\r\n            return false;\r\n        }\r\n        if (!(this.isUnexploredAttributesVisible()) && (attrModl.getConnectionModel() == null)) {\r\n            return false;\r\n        }\r\n        if (this.isAllAttributesVisible()) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public boolean isNullAttributesVisible() {\r\n        return this.nullAttributesVisible;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/util/ObjectViewManagerTest2.java",
		"test_prompt": "// ObjectViewManagerTest2.java\npackage de.paragon.explorer.util;\n\nimport java.lang.reflect.Modifier;\nimport java.util.Collection;\nimport java.util.Vector;\nimport de.paragon.explorer.model.AttributeModel;\nimport de.paragon.explorer.model.NullObject;\nimport de.paragon.explorer.model.ObjectModel;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectViewManager}.\n* It contains ten unit test cases for the {@link ObjectViewManager#isUnexploredAttributesVisible()} method.\n*/\nclass ObjectViewManagerTest2 {"
	},
	{
		"original_code": "// ObjectViewManager.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.util;\r\n\r\nimport java.lang.reflect.Modifier;\r\nimport java.util.Collection;\r\nimport java.util.Vector;\r\nimport de.paragon.explorer.model.AttributeModel;\r\nimport de.paragon.explorer.model.NullObject;\r\nimport de.paragon.explorer.model.ObjectModel;\r\n\r\npublic class ObjectViewManager {\r\n\r\n    private boolean allAttributesVisible;\r\n\r\n    private boolean nullAttributesVisible = PropertyManager.getInstance().getHideNullAttribut();\r\n\r\n    private boolean staticAttributesVisible = PropertyManager.getInstance().getHideStaticAttribut();\r\n\r\n    private boolean attributesToDisplay;\r\n\r\n    private boolean removeDependencies = PropertyManager.getInstance().getHideUnexploredAttribut();\r\n\r\n    private Collection<AttributeModel> attributeModels;\r\n\r\n    private ObjectModel objectModel;\r\n\r\n    private boolean unexploredAttributesVisible;\r\n\r\n    /**\r\n     * ObjectViewManager constructor comment.\r\n     */\r\n    public ObjectViewManager() {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * ObjectViewManager constructor comment.\r\n     */\r\n    public ObjectViewManager(ObjectModel newObjectModel) {\r\n        super();\r\n        this.setObjectModel(newObjectModel);\r\n    }\r\n\r\n    public boolean isAllAttributesVisible() {\r\n        return this.allAttributesVisible;\r\n    }\r\n\r\n    public Collection<AttributeModel> getAttributeModels() {\r\n        if (this.attributeModels == null) {\r\n            this.setAttributeModels(new Vector<AttributeModel>());\r\n        }\r\n        return this.attributeModels;\r\n    }\r\n\r\n    public Collection<AttributeModel> getInvisibleAttributes() {\r\n        AttributeModel attrModl;\r\n        Vector<AttributeModel> vector = new Vector<AttributeModel>();\r\n        StandardEnumeration attrModls = this.getObjectModel().getAttributeModels();\r\n        while (attrModls.hasMoreElements()) {\r\n            attrModl = (AttributeModel) attrModls.nextElement();\r\n            if (!(attrModl.isVisible())) {\r\n                vector.addElement(attrModl);\r\n            }\r\n        }\r\n        return vector;\r\n    }\r\n\r\n    public ObjectModel getObjectModel() {\r\n        return this.objectModel;\r\n    }\r\n\r\n    public boolean isStaticAttributesVisible() {\r\n        return this.staticAttributesVisible;\r\n    }\r\n\r\n    public boolean isUnexploredAttributesVisible() {\r\n        return this.unexploredAttributesVisible;\r\n    }\r\n\r\n    public Collection<AttributeModel> getVisibleAttributes() {\r\n        AttributeModel attrModl;\r\n        Vector<AttributeModel> vector = new Vector<AttributeModel>();\r\n        StandardEnumeration attrModls = this.getObjectModel().getAttributeModels();\r\n        while (attrModls.hasMoreElements()) {\r\n            attrModl = (AttributeModel) attrModls.nextElement();\r\n            if (attrModl.isVisible()) {\r\n                vector.addElement(attrModl);\r\n            }\r\n        }\r\n        return vector;\r\n    }\r\n\r\n    public boolean hasAttributesToDisplay() {\r\n        return this.attributesToDisplay;\r\n    }\r\n\r\n    /**\r\n     * @return Returns the removeDependencies.\r\n     */\r\n    public boolean isRemoveDependencies() {\r\n        return this.removeDependencies;\r\n    }\r\n\r\n    public void setAllAttributesVisible(boolean newAllAttributesVisible) {\r\n        this.allAttributesVisible = newAllAttributesVisible;\r\n    }\r\n\r\n    private void setAttributeModels(Collection<AttributeModel> newAttributeModels) {\r\n        this.attributeModels = newAttributeModels;\r\n    }\r\n\r\n    public void setAttributesToDisplay(boolean newValue) {\r\n        this.attributesToDisplay = newValue;\r\n    }\r\n\r\n    public void setNullAttributesVisible(boolean newNullAttributesVisible) {\r\n        this.nullAttributesVisible = newNullAttributesVisible;\r\n    }\r\n\r\n    private void setObjectModel(ObjectModel newObjectModel) {\r\n        this.objectModel = newObjectModel;\r\n    }\r\n\r\n    /**\r\n     * @param removeDependencies\r\n     *            The removeDependencies to set.\r\n     */\r\n    public void setRemoveDependencies(boolean newRemoveDependencies) {\r\n        this.removeDependencies = newRemoveDependencies;\r\n    }\r\n\r\n    public void setStaticAttributesVisible(boolean newStaticAttributesVisible) {\r\n        this.staticAttributesVisible = newStaticAttributesVisible;\r\n    }\r\n\r\n    public void setUnexploredAttributesVisible(boolean newUnexploredAttributesVisible) {\r\n        this.unexploredAttributesVisible = newUnexploredAttributesVisible;\r\n    }\r\n\r\n    public boolean shouldBeVisible(AttributeModel attrModl) {\r\n        if (!(this.isNullAttributesVisible()) && NullObject.isNullObject(attrModl.getValue())) {\r\n            return false;\r\n        }\r\n        if (!(this.isStaticAttributesVisible()) && (Modifier.isStatic(attrModl.getModifiers()))) {\r\n            return false;\r\n        }\r\n        if (!(this.isUnexploredAttributesVisible()) && (attrModl.getConnectionModel() == null)) {\r\n            return false;\r\n        }\r\n        if (this.isAllAttributesVisible()) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public boolean isNullAttributesVisible() {\r\n        return this.nullAttributesVisible;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/util/ObjectViewManagerTest3.java",
		"test_prompt": "// ObjectViewManagerTest3.java\npackage de.paragon.explorer.util;\n\nimport java.lang.reflect.Modifier;\nimport java.util.Collection;\nimport java.util.Vector;\nimport de.paragon.explorer.model.AttributeModel;\nimport de.paragon.explorer.model.NullObject;\nimport de.paragon.explorer.model.ObjectModel;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectViewManager}.\n* It contains ten unit test cases for the {@link ObjectViewManager#hasAttributesToDisplay()} method.\n*/\nclass ObjectViewManagerTest3 {"
	},
	{
		"original_code": "// ObjectViewManager.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.util;\r\n\r\nimport java.lang.reflect.Modifier;\r\nimport java.util.Collection;\r\nimport java.util.Vector;\r\nimport de.paragon.explorer.model.AttributeModel;\r\nimport de.paragon.explorer.model.NullObject;\r\nimport de.paragon.explorer.model.ObjectModel;\r\n\r\npublic class ObjectViewManager {\r\n\r\n    private boolean allAttributesVisible;\r\n\r\n    private boolean nullAttributesVisible = PropertyManager.getInstance().getHideNullAttribut();\r\n\r\n    private boolean staticAttributesVisible = PropertyManager.getInstance().getHideStaticAttribut();\r\n\r\n    private boolean attributesToDisplay;\r\n\r\n    private boolean removeDependencies = PropertyManager.getInstance().getHideUnexploredAttribut();\r\n\r\n    private Collection<AttributeModel> attributeModels;\r\n\r\n    private ObjectModel objectModel;\r\n\r\n    private boolean unexploredAttributesVisible;\r\n\r\n    /**\r\n     * ObjectViewManager constructor comment.\r\n     */\r\n    public ObjectViewManager() {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * ObjectViewManager constructor comment.\r\n     */\r\n    public ObjectViewManager(ObjectModel newObjectModel) {\r\n        super();\r\n        this.setObjectModel(newObjectModel);\r\n    }\r\n\r\n    public boolean isAllAttributesVisible() {\r\n        return this.allAttributesVisible;\r\n    }\r\n\r\n    public Collection<AttributeModel> getAttributeModels() {\r\n        if (this.attributeModels == null) {\r\n            this.setAttributeModels(new Vector<AttributeModel>());\r\n        }\r\n        return this.attributeModels;\r\n    }\r\n\r\n    public Collection<AttributeModel> getInvisibleAttributes() {\r\n        AttributeModel attrModl;\r\n        Vector<AttributeModel> vector = new Vector<AttributeModel>();\r\n        StandardEnumeration attrModls = this.getObjectModel().getAttributeModels();\r\n        while (attrModls.hasMoreElements()) {\r\n            attrModl = (AttributeModel) attrModls.nextElement();\r\n            if (!(attrModl.isVisible())) {\r\n                vector.addElement(attrModl);\r\n            }\r\n        }\r\n        return vector;\r\n    }\r\n\r\n    public ObjectModel getObjectModel() {\r\n        return this.objectModel;\r\n    }\r\n\r\n    public boolean isStaticAttributesVisible() {\r\n        return this.staticAttributesVisible;\r\n    }\r\n\r\n    public boolean isUnexploredAttributesVisible() {\r\n        return this.unexploredAttributesVisible;\r\n    }\r\n\r\n    public Collection<AttributeModel> getVisibleAttributes() {\r\n        AttributeModel attrModl;\r\n        Vector<AttributeModel> vector = new Vector<AttributeModel>();\r\n        StandardEnumeration attrModls = this.getObjectModel().getAttributeModels();\r\n        while (attrModls.hasMoreElements()) {\r\n            attrModl = (AttributeModel) attrModls.nextElement();\r\n            if (attrModl.isVisible()) {\r\n                vector.addElement(attrModl);\r\n            }\r\n        }\r\n        return vector;\r\n    }\r\n\r\n    public boolean hasAttributesToDisplay() {\r\n        return this.attributesToDisplay;\r\n    }\r\n\r\n    /**\r\n     * @return Returns the removeDependencies.\r\n     */\r\n    public boolean isRemoveDependencies() {\r\n        return this.removeDependencies;\r\n    }\r\n\r\n    public void setAllAttributesVisible(boolean newAllAttributesVisible) {\r\n        this.allAttributesVisible = newAllAttributesVisible;\r\n    }\r\n\r\n    private void setAttributeModels(Collection<AttributeModel> newAttributeModels) {\r\n        this.attributeModels = newAttributeModels;\r\n    }\r\n\r\n    public void setAttributesToDisplay(boolean newValue) {\r\n        this.attributesToDisplay = newValue;\r\n    }\r\n\r\n    public void setNullAttributesVisible(boolean newNullAttributesVisible) {\r\n        this.nullAttributesVisible = newNullAttributesVisible;\r\n    }\r\n\r\n    private void setObjectModel(ObjectModel newObjectModel) {\r\n        this.objectModel = newObjectModel;\r\n    }\r\n\r\n    /**\r\n     * @param removeDependencies\r\n     *            The removeDependencies to set.\r\n     */\r\n    public void setRemoveDependencies(boolean newRemoveDependencies) {\r\n        this.removeDependencies = newRemoveDependencies;\r\n    }\r\n\r\n    public void setStaticAttributesVisible(boolean newStaticAttributesVisible) {\r\n        this.staticAttributesVisible = newStaticAttributesVisible;\r\n    }\r\n\r\n    public void setUnexploredAttributesVisible(boolean newUnexploredAttributesVisible) {\r\n        this.unexploredAttributesVisible = newUnexploredAttributesVisible;\r\n    }\r\n\r\n    public boolean shouldBeVisible(AttributeModel attrModl) {\r\n        if (!(this.isNullAttributesVisible()) && NullObject.isNullObject(attrModl.getValue())) {\r\n            return false;\r\n        }\r\n        if (!(this.isStaticAttributesVisible()) && (Modifier.isStatic(attrModl.getModifiers()))) {\r\n            return false;\r\n        }\r\n        if (!(this.isUnexploredAttributesVisible()) && (attrModl.getConnectionModel() == null)) {\r\n            return false;\r\n        }\r\n        if (this.isAllAttributesVisible()) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public boolean isNullAttributesVisible() {\r\n        return this.nullAttributesVisible;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/util/ObjectViewManagerTest4.java",
		"test_prompt": "// ObjectViewManagerTest4.java\npackage de.paragon.explorer.util;\n\nimport java.lang.reflect.Modifier;\nimport java.util.Collection;\nimport java.util.Vector;\nimport de.paragon.explorer.model.AttributeModel;\nimport de.paragon.explorer.model.NullObject;\nimport de.paragon.explorer.model.ObjectModel;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectViewManager}.\n* It contains ten unit test cases for the {@link ObjectViewManager#isRemoveDependencies()} method.\n*/\nclass ObjectViewManagerTest4 {"
	},
	{
		"original_code": "// ObjectViewManager.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.util;\r\n\r\nimport java.lang.reflect.Modifier;\r\nimport java.util.Collection;\r\nimport java.util.Vector;\r\nimport de.paragon.explorer.model.AttributeModel;\r\nimport de.paragon.explorer.model.NullObject;\r\nimport de.paragon.explorer.model.ObjectModel;\r\n\r\npublic class ObjectViewManager {\r\n\r\n    private boolean allAttributesVisible;\r\n\r\n    private boolean nullAttributesVisible = PropertyManager.getInstance().getHideNullAttribut();\r\n\r\n    private boolean staticAttributesVisible = PropertyManager.getInstance().getHideStaticAttribut();\r\n\r\n    private boolean attributesToDisplay;\r\n\r\n    private boolean removeDependencies = PropertyManager.getInstance().getHideUnexploredAttribut();\r\n\r\n    private Collection<AttributeModel> attributeModels;\r\n\r\n    private ObjectModel objectModel;\r\n\r\n    private boolean unexploredAttributesVisible;\r\n\r\n    /**\r\n     * ObjectViewManager constructor comment.\r\n     */\r\n    public ObjectViewManager() {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * ObjectViewManager constructor comment.\r\n     */\r\n    public ObjectViewManager(ObjectModel newObjectModel) {\r\n        super();\r\n        this.setObjectModel(newObjectModel);\r\n    }\r\n\r\n    public boolean isAllAttributesVisible() {\r\n        return this.allAttributesVisible;\r\n    }\r\n\r\n    public Collection<AttributeModel> getAttributeModels() {\r\n        if (this.attributeModels == null) {\r\n            this.setAttributeModels(new Vector<AttributeModel>());\r\n        }\r\n        return this.attributeModels;\r\n    }\r\n\r\n    public Collection<AttributeModel> getInvisibleAttributes() {\r\n        AttributeModel attrModl;\r\n        Vector<AttributeModel> vector = new Vector<AttributeModel>();\r\n        StandardEnumeration attrModls = this.getObjectModel().getAttributeModels();\r\n        while (attrModls.hasMoreElements()) {\r\n            attrModl = (AttributeModel) attrModls.nextElement();\r\n            if (!(attrModl.isVisible())) {\r\n                vector.addElement(attrModl);\r\n            }\r\n        }\r\n        return vector;\r\n    }\r\n\r\n    public ObjectModel getObjectModel() {\r\n        return this.objectModel;\r\n    }\r\n\r\n    public boolean isStaticAttributesVisible() {\r\n        return this.staticAttributesVisible;\r\n    }\r\n\r\n    public boolean isUnexploredAttributesVisible() {\r\n        return this.unexploredAttributesVisible;\r\n    }\r\n\r\n    public Collection<AttributeModel> getVisibleAttributes() {\r\n        AttributeModel attrModl;\r\n        Vector<AttributeModel> vector = new Vector<AttributeModel>();\r\n        StandardEnumeration attrModls = this.getObjectModel().getAttributeModels();\r\n        while (attrModls.hasMoreElements()) {\r\n            attrModl = (AttributeModel) attrModls.nextElement();\r\n            if (attrModl.isVisible()) {\r\n                vector.addElement(attrModl);\r\n            }\r\n        }\r\n        return vector;\r\n    }\r\n\r\n    public boolean hasAttributesToDisplay() {\r\n        return this.attributesToDisplay;\r\n    }\r\n\r\n    /**\r\n     * @return Returns the removeDependencies.\r\n     */\r\n    public boolean isRemoveDependencies() {\r\n        return this.removeDependencies;\r\n    }\r\n\r\n    public void setAllAttributesVisible(boolean newAllAttributesVisible) {\r\n        this.allAttributesVisible = newAllAttributesVisible;\r\n    }\r\n\r\n    private void setAttributeModels(Collection<AttributeModel> newAttributeModels) {\r\n        this.attributeModels = newAttributeModels;\r\n    }\r\n\r\n    public void setAttributesToDisplay(boolean newValue) {\r\n        this.attributesToDisplay = newValue;\r\n    }\r\n\r\n    public void setNullAttributesVisible(boolean newNullAttributesVisible) {\r\n        this.nullAttributesVisible = newNullAttributesVisible;\r\n    }\r\n\r\n    private void setObjectModel(ObjectModel newObjectModel) {\r\n        this.objectModel = newObjectModel;\r\n    }\r\n\r\n    /**\r\n     * @param removeDependencies\r\n     *            The removeDependencies to set.\r\n     */\r\n    public void setRemoveDependencies(boolean newRemoveDependencies) {\r\n        this.removeDependencies = newRemoveDependencies;\r\n    }\r\n\r\n    public void setStaticAttributesVisible(boolean newStaticAttributesVisible) {\r\n        this.staticAttributesVisible = newStaticAttributesVisible;\r\n    }\r\n\r\n    public void setUnexploredAttributesVisible(boolean newUnexploredAttributesVisible) {\r\n        this.unexploredAttributesVisible = newUnexploredAttributesVisible;\r\n    }\r\n\r\n    public boolean shouldBeVisible(AttributeModel attrModl) {\r\n        if (!(this.isNullAttributesVisible()) && NullObject.isNullObject(attrModl.getValue())) {\r\n            return false;\r\n        }\r\n        if (!(this.isStaticAttributesVisible()) && (Modifier.isStatic(attrModl.getModifiers()))) {\r\n            return false;\r\n        }\r\n        if (!(this.isUnexploredAttributesVisible()) && (attrModl.getConnectionModel() == null)) {\r\n            return false;\r\n        }\r\n        if (this.isAllAttributesVisible()) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public boolean isNullAttributesVisible() {\r\n        return this.nullAttributesVisible;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/util/ObjectViewManagerTest5.java",
		"test_prompt": "// ObjectViewManagerTest5.java\npackage de.paragon.explorer.util;\n\nimport java.lang.reflect.Modifier;\nimport java.util.Collection;\nimport java.util.Vector;\nimport de.paragon.explorer.model.AttributeModel;\nimport de.paragon.explorer.model.NullObject;\nimport de.paragon.explorer.model.ObjectModel;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectViewManager}.\n* It contains ten unit test cases for the {@link ObjectViewManager#shouldBeVisible(AttributeModel)} method.\n*/\nclass ObjectViewManagerTest5 {"
	},
	{
		"original_code": "// ObjectViewManager.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.util;\r\n\r\nimport java.lang.reflect.Modifier;\r\nimport java.util.Collection;\r\nimport java.util.Vector;\r\nimport de.paragon.explorer.model.AttributeModel;\r\nimport de.paragon.explorer.model.NullObject;\r\nimport de.paragon.explorer.model.ObjectModel;\r\n\r\npublic class ObjectViewManager {\r\n\r\n    private boolean allAttributesVisible;\r\n\r\n    private boolean nullAttributesVisible = PropertyManager.getInstance().getHideNullAttribut();\r\n\r\n    private boolean staticAttributesVisible = PropertyManager.getInstance().getHideStaticAttribut();\r\n\r\n    private boolean attributesToDisplay;\r\n\r\n    private boolean removeDependencies = PropertyManager.getInstance().getHideUnexploredAttribut();\r\n\r\n    private Collection<AttributeModel> attributeModels;\r\n\r\n    private ObjectModel objectModel;\r\n\r\n    private boolean unexploredAttributesVisible;\r\n\r\n    /**\r\n     * ObjectViewManager constructor comment.\r\n     */\r\n    public ObjectViewManager() {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * ObjectViewManager constructor comment.\r\n     */\r\n    public ObjectViewManager(ObjectModel newObjectModel) {\r\n        super();\r\n        this.setObjectModel(newObjectModel);\r\n    }\r\n\r\n    public boolean isAllAttributesVisible() {\r\n        return this.allAttributesVisible;\r\n    }\r\n\r\n    public Collection<AttributeModel> getAttributeModels() {\r\n        if (this.attributeModels == null) {\r\n            this.setAttributeModels(new Vector<AttributeModel>());\r\n        }\r\n        return this.attributeModels;\r\n    }\r\n\r\n    public Collection<AttributeModel> getInvisibleAttributes() {\r\n        AttributeModel attrModl;\r\n        Vector<AttributeModel> vector = new Vector<AttributeModel>();\r\n        StandardEnumeration attrModls = this.getObjectModel().getAttributeModels();\r\n        while (attrModls.hasMoreElements()) {\r\n            attrModl = (AttributeModel) attrModls.nextElement();\r\n            if (!(attrModl.isVisible())) {\r\n                vector.addElement(attrModl);\r\n            }\r\n        }\r\n        return vector;\r\n    }\r\n\r\n    public ObjectModel getObjectModel() {\r\n        return this.objectModel;\r\n    }\r\n\r\n    public boolean isStaticAttributesVisible() {\r\n        return this.staticAttributesVisible;\r\n    }\r\n\r\n    public boolean isUnexploredAttributesVisible() {\r\n        return this.unexploredAttributesVisible;\r\n    }\r\n\r\n    public Collection<AttributeModel> getVisibleAttributes() {\r\n        AttributeModel attrModl;\r\n        Vector<AttributeModel> vector = new Vector<AttributeModel>();\r\n        StandardEnumeration attrModls = this.getObjectModel().getAttributeModels();\r\n        while (attrModls.hasMoreElements()) {\r\n            attrModl = (AttributeModel) attrModls.nextElement();\r\n            if (attrModl.isVisible()) {\r\n                vector.addElement(attrModl);\r\n            }\r\n        }\r\n        return vector;\r\n    }\r\n\r\n    public boolean hasAttributesToDisplay() {\r\n        return this.attributesToDisplay;\r\n    }\r\n\r\n    /**\r\n     * @return Returns the removeDependencies.\r\n     */\r\n    public boolean isRemoveDependencies() {\r\n        return this.removeDependencies;\r\n    }\r\n\r\n    public void setAllAttributesVisible(boolean newAllAttributesVisible) {\r\n        this.allAttributesVisible = newAllAttributesVisible;\r\n    }\r\n\r\n    private void setAttributeModels(Collection<AttributeModel> newAttributeModels) {\r\n        this.attributeModels = newAttributeModels;\r\n    }\r\n\r\n    public void setAttributesToDisplay(boolean newValue) {\r\n        this.attributesToDisplay = newValue;\r\n    }\r\n\r\n    public void setNullAttributesVisible(boolean newNullAttributesVisible) {\r\n        this.nullAttributesVisible = newNullAttributesVisible;\r\n    }\r\n\r\n    private void setObjectModel(ObjectModel newObjectModel) {\r\n        this.objectModel = newObjectModel;\r\n    }\r\n\r\n    /**\r\n     * @param removeDependencies\r\n     *            The removeDependencies to set.\r\n     */\r\n    public void setRemoveDependencies(boolean newRemoveDependencies) {\r\n        this.removeDependencies = newRemoveDependencies;\r\n    }\r\n\r\n    public void setStaticAttributesVisible(boolean newStaticAttributesVisible) {\r\n        this.staticAttributesVisible = newStaticAttributesVisible;\r\n    }\r\n\r\n    public void setUnexploredAttributesVisible(boolean newUnexploredAttributesVisible) {\r\n        this.unexploredAttributesVisible = newUnexploredAttributesVisible;\r\n    }\r\n\r\n    public boolean shouldBeVisible(AttributeModel attrModl) {\r\n        if (!(this.isNullAttributesVisible()) && NullObject.isNullObject(attrModl.getValue())) {\r\n            return false;\r\n        }\r\n        if (!(this.isStaticAttributesVisible()) && (Modifier.isStatic(attrModl.getModifiers()))) {\r\n            return false;\r\n        }\r\n        if (!(this.isUnexploredAttributesVisible()) && (attrModl.getConnectionModel() == null)) {\r\n            return false;\r\n        }\r\n        if (this.isAllAttributesVisible()) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public boolean isNullAttributesVisible() {\r\n        return this.nullAttributesVisible;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/util/ObjectViewManagerTest6.java",
		"test_prompt": "// ObjectViewManagerTest6.java\npackage de.paragon.explorer.util;\n\nimport java.lang.reflect.Modifier;\nimport java.util.Collection;\nimport java.util.Vector;\nimport de.paragon.explorer.model.AttributeModel;\nimport de.paragon.explorer.model.NullObject;\nimport de.paragon.explorer.model.ObjectModel;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectViewManager}.\n* It contains ten unit test cases for the {@link ObjectViewManager#isNullAttributesVisible()} method.\n*/\nclass ObjectViewManagerTest6 {"
	},
	{
		"original_code": "// ObjectTitleManager.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.util;\r\n\r\nimport java.lang.reflect.Modifier;\r\nimport java.util.Collection;\r\nimport java.util.Vector;\r\nimport org.apache.log4j.Logger;\r\nimport de.paragon.explorer.ProjectConstants4ObjectExplorer;\r\nimport de.paragon.explorer.model.ObjectModel;\r\n\r\n/**\r\n * In dieser Klasse sind die Reglen hinterlegt, wie der Title eines Objekts\r\n * aussieht. Bei Integer und String wird der Wert direkt angezeigt.\r\n */\r\npublic final class ObjectTitleManager {\r\n\r\n    private static final Logger logger = LoggerFactory.make();\r\n\r\n    private static ObjectTitleManager objectTitleManager;\r\n\r\n    public static ObjectTitleManager getSingleton() {\r\n        if (ObjectTitleManager.objectTitleManager == null) {\r\n            ObjectTitleManager.setSingleton(new ObjectTitleManager());\r\n        }\r\n        return ObjectTitleManager.objectTitleManager;\r\n    }\r\n\r\n    private static void setSingleton(ObjectTitleManager newObjectTitleManager) {\r\n        ObjectTitleManager.objectTitleManager = newObjectTitleManager;\r\n    }\r\n\r\n    private Collection<Class<?>> valuesToShow;\r\n\r\n    /**\r\n     * ObjectViewManager constructor comment.\r\n     */\r\n    private ObjectTitleManager() {\r\n        super();\r\n        this.getValuesToShow().add(String.class);\r\n        this.getValuesToShow().add(Integer.class);\r\n    }\r\n\r\n    public String getCompleteTitle(ObjectModel objModl) {\r\n        if (objModl.isNullObject()) {\r\n            return \"\";\r\n        } else {\r\n            return Modifier.toString(objModl.getObject().getClass().getModifiers()) + \" \" + this.getTypeName(objModl.getObject().getClass()) + \"  \" + this.getValueAsString(objModl.getObject());\r\n        }\r\n    }\r\n\r\n    private String getShortTypeName(Class<?> type) {\r\n        if (this.isArrayOfPrimitiveType(type)) {\r\n            this.getTypeName(type);\r\n        }\r\n        return this.getTypeName(type).substring(this.getTypeName(type).lastIndexOf(\".\") + 1);\r\n    }\r\n\r\n    public String getTitle(ObjectModel objModl) {\r\n        Object object = objModl.getObject();\r\n        Class<? extends Object> objectClass = object.getClass();\r\n        if (this.getValuesToShow().contains(objectClass)) {\r\n            StringBuilder sb = new StringBuilder();\r\n            sb.append(this.getShortTypeName(object.getClass()));\r\n            sb.append(\"    \");\r\n            sb.append(object.toString());\r\n            return sb.toString();\r\n        }\r\n        if (objModl.isNullObject()) {\r\n            return ProjectConstants4ObjectExplorer.getSTRING_NULL();\r\n        }\r\n        return this.getShortTypeName(object.getClass());\r\n    }\r\n\r\n    private String getTypeName(Class<?> type) {\r\n        if (type.isArray()) {\r\n            try {\r\n                Class<?> clazz = type;\r\n                int dimensions = 0;\r\n                while (clazz.isArray()) {\r\n                    dimensions++;\r\n                    clazz = clazz.getComponentType();\r\n                }\r\n                StringBuilder sb = new StringBuilder();\r\n                sb.append(clazz.getName());\r\n                for (int i = 0; i < dimensions; i++) {\r\n                    sb.append(\"[]\");\r\n                }\r\n                return sb.toString();\r\n            } catch (Throwable t) {\r\n                ObjectTitleManager.logger.error(\"-->> Fehler bei getTypeName\", t);\r\n            }\r\n        }\r\n        return type.getName();\r\n    }\r\n\r\n    private String getValueAsString(Object object) {\r\n        if (object instanceof Vector) {\r\n            Vector<Object> vector2return = new Vector<Object>();\r\n            Vector<?> vector2transfer = (Vector<?>) object;\r\n            for (Object object2 : vector2transfer) {\r\n                vector2return.add(object2);\r\n            }\r\n            return ToStringConverter.convertVectorToString(vector2return);\r\n        } else {\r\n            return object.toString();\r\n        }\r\n    }\r\n\r\n    private Collection<Class<?>> getValuesToShow() {\r\n        if (this.valuesToShow == null) {\r\n            this.setValuesToShow(new Vector<Class<?>>());\r\n        }\r\n        return this.valuesToShow;\r\n    }\r\n\r\n    private boolean isArrayOfPrimitiveType(Class<?> type) {\r\n        return type.getName().startsWith(\"[\") && !(type.getName().startsWith(\"[L\"));\r\n    }\r\n\r\n    private void setValuesToShow(Collection<Class<?>> newValuesToShow) {\r\n        this.valuesToShow = newValuesToShow;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/util/ObjectTitleManagerTest.java",
		"test_prompt": "// ObjectTitleManagerTest.java\npackage de.paragon.explorer.util;\n\nimport java.lang.reflect.Modifier;\nimport java.util.Collection;\nimport java.util.Vector;\nimport org.apache.log4j.Logger;\nimport de.paragon.explorer.ProjectConstants4ObjectExplorer;\nimport de.paragon.explorer.model.ObjectModel;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectTitleManager}.\n* It contains ten unit test cases for the {@link ObjectTitleManager#getSingleton()} method.\n*/\nclass ObjectTitleManagerTest {"
	},
	{
		"original_code": "// ExplorerColorManager.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.util;\r\n\r\nimport java.awt.Color;\r\nimport de.paragon.explorer.figure.TextBoxFigure;\r\n\r\n/**\r\n * Diese Klasse stellt die zu benutzenden Farben zur Verfuegung\r\n */\r\npublic class ExplorerColorManager {\r\n\r\n    private static final int NUMBER_255 = 255;\r\n\r\n    private static final int NUMBER_153 = 153;\r\n\r\n    private static final int NUMBER_0 = 0;\r\n\r\n    private static final int NUMBER_51 = 51;\r\n\r\n    public static java.awt.Color getDefaultExplorerObjectBackground() {\r\n        if (ExplorerColorManager.defaultExplorerObjectBackground == null) {\r\n            ExplorerColorManager.setDefaultExplorerObjectBackground(new java.awt.Color(ExplorerColorManager.NUMBER_153, ExplorerColorManager.NUMBER_153, ExplorerColorManager.NUMBER_255));\r\n        }\r\n        return ExplorerColorManager.defaultExplorerObjectBackground;\r\n    }\r\n\r\n    private static void setDefaultExplorerFocusBackground(java.awt.Color newDefaultExplorerFocusBackground) {\r\n        ExplorerColorManager.defaultExplorerFocusBackground = newDefaultExplorerFocusBackground;\r\n    }\r\n\r\n    private static void setDefaultExplorerObjectBackground(java.awt.Color newDefaultExplorerObjectBackground) {\r\n        ExplorerColorManager.defaultExplorerObjectBackground = newDefaultExplorerObjectBackground;\r\n    }\r\n\r\n    private Color objectBackground;\r\n\r\n    private Color attributeBackground;\r\n\r\n    private Color attributeForeground;\r\n\r\n    private Color objectForeground;\r\n\r\n    private Color focusForeground;\r\n\r\n    private Color focusBackground;\r\n\r\n    private Color copyBackground;\r\n\r\n    private static Color defaultExplorerObjectBackground;\r\n\r\n    private static Color defaultExplorerFocusBackground;\r\n\r\n    public static Color getDefaultExplorerFocusBackground() {\r\n        if (ExplorerColorManager.defaultExplorerFocusBackground == null) {\r\n            ExplorerColorManager.setDefaultExplorerFocusBackground(new java.awt.Color(ExplorerColorManager.NUMBER_51, ExplorerColorManager.NUMBER_0, ExplorerColorManager.NUMBER_153));\r\n        }\r\n        return ExplorerColorManager.defaultExplorerFocusBackground;\r\n    }\r\n\r\n    /**\r\n     * ExplorerColorManager constructor comment.\r\n     */\r\n    public ExplorerColorManager() {\r\n        super();\r\n    }\r\n\r\n    private Color getAttributeBackground() {\r\n        if (this.attributeBackground == null) {\r\n            this.setAttributeBackground(this.getDefaultAttributeBackground());\r\n        }\r\n        return this.attributeBackground;\r\n    }\r\n\r\n    private Color getAttributeForeground() {\r\n        if (this.attributeForeground == null) {\r\n            this.setAttributeForeground(this.getDefaultForeground());\r\n        }\r\n        return this.attributeForeground;\r\n    }\r\n\r\n    public Color getBackground(TextBoxFigure tebofi) {\r\n        if (tebofi.getModel().isAttributeModel()) {\r\n            return this.getAttributeBackground();\r\n        }\r\n        return this.getObjectBackground();\r\n    }\r\n\r\n    public Color getCopyBackground() {\r\n        if (this.copyBackground == null) {\r\n            this.setCopyBackground(this.getDefaultCopyBackground());\r\n        }\r\n        return this.copyBackground;\r\n    }\r\n\r\n    private Color getDefaultAttributeBackground() {\r\n        return Color.white;\r\n    }\r\n\r\n    public Color getDefaultCopyBackground() {\r\n        return Color.red;\r\n    }\r\n\r\n    private Color getDefaultFocusBackground() {\r\n        return ExplorerColorManager.getDefaultExplorerFocusBackground();\r\n    }\r\n\r\n    private Color getDefaultFocusForeground() {\r\n        return Color.white;\r\n    }\r\n\r\n    private Color getDefaultForeground() {\r\n        return Color.black;\r\n    }\r\n\r\n    private Color getDefaultObjectBackground() {\r\n        return ExplorerColorManager.getDefaultExplorerObjectBackground();\r\n    }\r\n\r\n    public Color getFocusBackground() {\r\n        if (this.focusBackground == null) {\r\n            this.setFocusBackground(this.getDefaultFocusBackground());\r\n        }\r\n        return this.focusBackground;\r\n    }\r\n\r\n    public Color getFocusForeground() {\r\n        if (this.focusForeground == null) {\r\n            this.setFocusForeground(this.getDefaultFocusForeground());\r\n        }\r\n        return this.focusForeground;\r\n    }\r\n\r\n    public Color getForeground(TextBoxFigure tebofi) {\r\n        if (tebofi.getModel().isAttributeModel()) {\r\n            return this.getAttributeForeground();\r\n        }\r\n        return this.getObjectForeground();\r\n    }\r\n\r\n    private Color getObjectBackground() {\r\n        if (this.objectBackground == null) {\r\n            this.setObjectBackground(this.getDefaultObjectBackground());\r\n        }\r\n        return this.objectBackground;\r\n    }\r\n\r\n    private Color getObjectForeground() {\r\n        if (this.objectForeground == null) {\r\n            this.setObjectForeground(this.getDefaultForeground());\r\n        }\r\n        return this.objectForeground;\r\n    }\r\n\r\n    public void setAttributeBackground(Color newAttributeBackground) {\r\n        this.attributeBackground = newAttributeBackground;\r\n    }\r\n\r\n    public void setAttributeForeground(Color newAttributeForeground) {\r\n        this.attributeForeground = newAttributeForeground;\r\n    }\r\n\r\n    public void setCopyBackground(Color newCopyBackground) {\r\n        this.copyBackground = newCopyBackground;\r\n    }\r\n\r\n    public void setFocusBackground(Color newFocusBackground) {\r\n        this.focusBackground = newFocusBackground;\r\n    }\r\n\r\n    public void setFocusForeground(Color newFocusForeground) {\r\n        this.focusForeground = newFocusForeground;\r\n    }\r\n\r\n    public void setObjectBackground(Color newObjectBackground) {\r\n        this.objectBackground = newObjectBackground;\r\n    }\r\n\r\n    public void setObjectForeground(Color newObjectForeground) {\r\n        this.objectForeground = newObjectForeground;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/util/ExplorerColorManagerTest0.java",
		"test_prompt": "// ExplorerColorManagerTest0.java\npackage de.paragon.explorer.util;\n\nimport java.awt.Color;\nimport de.paragon.explorer.figure.TextBoxFigure;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ExplorerColorManager}.\n* It contains ten unit test cases for the {@link ExplorerColorManager#getDefaultExplorerObjectBackground()} method.\n*/\nclass ExplorerColorManagerTest0 {"
	},
	{
		"original_code": "// ExplorerColorManager.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.util;\r\n\r\nimport java.awt.Color;\r\nimport de.paragon.explorer.figure.TextBoxFigure;\r\n\r\n/**\r\n * Diese Klasse stellt die zu benutzenden Farben zur Verfuegung\r\n */\r\npublic class ExplorerColorManager {\r\n\r\n    private static final int NUMBER_255 = 255;\r\n\r\n    private static final int NUMBER_153 = 153;\r\n\r\n    private static final int NUMBER_0 = 0;\r\n\r\n    private static final int NUMBER_51 = 51;\r\n\r\n    public static java.awt.Color getDefaultExplorerObjectBackground() {\r\n        if (ExplorerColorManager.defaultExplorerObjectBackground == null) {\r\n            ExplorerColorManager.setDefaultExplorerObjectBackground(new java.awt.Color(ExplorerColorManager.NUMBER_153, ExplorerColorManager.NUMBER_153, ExplorerColorManager.NUMBER_255));\r\n        }\r\n        return ExplorerColorManager.defaultExplorerObjectBackground;\r\n    }\r\n\r\n    private static void setDefaultExplorerFocusBackground(java.awt.Color newDefaultExplorerFocusBackground) {\r\n        ExplorerColorManager.defaultExplorerFocusBackground = newDefaultExplorerFocusBackground;\r\n    }\r\n\r\n    private static void setDefaultExplorerObjectBackground(java.awt.Color newDefaultExplorerObjectBackground) {\r\n        ExplorerColorManager.defaultExplorerObjectBackground = newDefaultExplorerObjectBackground;\r\n    }\r\n\r\n    private Color objectBackground;\r\n\r\n    private Color attributeBackground;\r\n\r\n    private Color attributeForeground;\r\n\r\n    private Color objectForeground;\r\n\r\n    private Color focusForeground;\r\n\r\n    private Color focusBackground;\r\n\r\n    private Color copyBackground;\r\n\r\n    private static Color defaultExplorerObjectBackground;\r\n\r\n    private static Color defaultExplorerFocusBackground;\r\n\r\n    public static Color getDefaultExplorerFocusBackground() {\r\n        if (ExplorerColorManager.defaultExplorerFocusBackground == null) {\r\n            ExplorerColorManager.setDefaultExplorerFocusBackground(new java.awt.Color(ExplorerColorManager.NUMBER_51, ExplorerColorManager.NUMBER_0, ExplorerColorManager.NUMBER_153));\r\n        }\r\n        return ExplorerColorManager.defaultExplorerFocusBackground;\r\n    }\r\n\r\n    /**\r\n     * ExplorerColorManager constructor comment.\r\n     */\r\n    public ExplorerColorManager() {\r\n        super();\r\n    }\r\n\r\n    private Color getAttributeBackground() {\r\n        if (this.attributeBackground == null) {\r\n            this.setAttributeBackground(this.getDefaultAttributeBackground());\r\n        }\r\n        return this.attributeBackground;\r\n    }\r\n\r\n    private Color getAttributeForeground() {\r\n        if (this.attributeForeground == null) {\r\n            this.setAttributeForeground(this.getDefaultForeground());\r\n        }\r\n        return this.attributeForeground;\r\n    }\r\n\r\n    public Color getBackground(TextBoxFigure tebofi) {\r\n        if (tebofi.getModel().isAttributeModel()) {\r\n            return this.getAttributeBackground();\r\n        }\r\n        return this.getObjectBackground();\r\n    }\r\n\r\n    public Color getCopyBackground() {\r\n        if (this.copyBackground == null) {\r\n            this.setCopyBackground(this.getDefaultCopyBackground());\r\n        }\r\n        return this.copyBackground;\r\n    }\r\n\r\n    private Color getDefaultAttributeBackground() {\r\n        return Color.white;\r\n    }\r\n\r\n    public Color getDefaultCopyBackground() {\r\n        return Color.red;\r\n    }\r\n\r\n    private Color getDefaultFocusBackground() {\r\n        return ExplorerColorManager.getDefaultExplorerFocusBackground();\r\n    }\r\n\r\n    private Color getDefaultFocusForeground() {\r\n        return Color.white;\r\n    }\r\n\r\n    private Color getDefaultForeground() {\r\n        return Color.black;\r\n    }\r\n\r\n    private Color getDefaultObjectBackground() {\r\n        return ExplorerColorManager.getDefaultExplorerObjectBackground();\r\n    }\r\n\r\n    public Color getFocusBackground() {\r\n        if (this.focusBackground == null) {\r\n            this.setFocusBackground(this.getDefaultFocusBackground());\r\n        }\r\n        return this.focusBackground;\r\n    }\r\n\r\n    public Color getFocusForeground() {\r\n        if (this.focusForeground == null) {\r\n            this.setFocusForeground(this.getDefaultFocusForeground());\r\n        }\r\n        return this.focusForeground;\r\n    }\r\n\r\n    public Color getForeground(TextBoxFigure tebofi) {\r\n        if (tebofi.getModel().isAttributeModel()) {\r\n            return this.getAttributeForeground();\r\n        }\r\n        return this.getObjectForeground();\r\n    }\r\n\r\n    private Color getObjectBackground() {\r\n        if (this.objectBackground == null) {\r\n            this.setObjectBackground(this.getDefaultObjectBackground());\r\n        }\r\n        return this.objectBackground;\r\n    }\r\n\r\n    private Color getObjectForeground() {\r\n        if (this.objectForeground == null) {\r\n            this.setObjectForeground(this.getDefaultForeground());\r\n        }\r\n        return this.objectForeground;\r\n    }\r\n\r\n    public void setAttributeBackground(Color newAttributeBackground) {\r\n        this.attributeBackground = newAttributeBackground;\r\n    }\r\n\r\n    public void setAttributeForeground(Color newAttributeForeground) {\r\n        this.attributeForeground = newAttributeForeground;\r\n    }\r\n\r\n    public void setCopyBackground(Color newCopyBackground) {\r\n        this.copyBackground = newCopyBackground;\r\n    }\r\n\r\n    public void setFocusBackground(Color newFocusBackground) {\r\n        this.focusBackground = newFocusBackground;\r\n    }\r\n\r\n    public void setFocusForeground(Color newFocusForeground) {\r\n        this.focusForeground = newFocusForeground;\r\n    }\r\n\r\n    public void setObjectBackground(Color newObjectBackground) {\r\n        this.objectBackground = newObjectBackground;\r\n    }\r\n\r\n    public void setObjectForeground(Color newObjectForeground) {\r\n        this.objectForeground = newObjectForeground;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/util/ExplorerColorManagerTest1.java",
		"test_prompt": "// ExplorerColorManagerTest1.java\npackage de.paragon.explorer.util;\n\nimport java.awt.Color;\nimport de.paragon.explorer.figure.TextBoxFigure;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ExplorerColorManager}.\n* It contains ten unit test cases for the {@link ExplorerColorManager#getDefaultExplorerFocusBackground()} method.\n*/\nclass ExplorerColorManagerTest1 {"
	},
	{
		"original_code": "// ResourceBundlePurchaser.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.util;\r\n\r\npublic class ResourceBundlePurchaser extends ResourceBundleManager {\r\n\r\n    //\r\n    public static String getMessage(String key) {\r\n        return ResourceBundleManager.getInstance().getPropertyFromFromResourceBundle(key);\r\n    }\r\n\r\n    public static String getSubstitutedMessage(String property, Object... value2Substitute) {\r\n        return ResourceBundleManager.getInstance().getSubstitutedMessageFromResourceBundle(property, value2Substitute);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/util/ResourceBundlePurchaserTest0.java",
		"test_prompt": "// ResourceBundlePurchaserTest0.java\npackage de.paragon.explorer.util;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ResourceBundlePurchaser}.\n* It contains ten unit test cases for the {@link ResourceBundlePurchaser#getMessage(String)} method.\n*/\nclass ResourceBundlePurchaserTest0 {"
	},
	{
		"original_code": "// ResourceBundlePurchaser.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.util;\r\n\r\npublic class ResourceBundlePurchaser extends ResourceBundleManager {\r\n\r\n    //\r\n    public static String getMessage(String key) {\r\n        return ResourceBundleManager.getInstance().getPropertyFromFromResourceBundle(key);\r\n    }\r\n\r\n    public static String getSubstitutedMessage(String property, Object... value2Substitute) {\r\n        return ResourceBundleManager.getInstance().getSubstitutedMessageFromResourceBundle(property, value2Substitute);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/util/ResourceBundlePurchaserTest1.java",
		"test_prompt": "// ResourceBundlePurchaserTest1.java\npackage de.paragon.explorer.util;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ResourceBundlePurchaser}.\n* It contains ten unit test cases for the {@link ResourceBundlePurchaser#getSubstitutedMessage(String, Object[])} method.\n*/\nclass ResourceBundlePurchaserTest1 {"
	},
	{
		"original_code": "// ConnectionBuilder.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.util;\r\n\r\nimport org.apache.log4j.Logger;\r\nimport de.paragon.explorer.figure.ExplorerFigure;\r\nimport de.paragon.explorer.figure.ExplorerFigureBuilder;\r\nimport de.paragon.explorer.figure.ListBoxFigure;\r\nimport de.paragon.explorer.figure.StandardConnectionFigure;\r\nimport de.paragon.explorer.figure.TextBoxFigure;\r\nimport de.paragon.explorer.gui.Warning;\r\nimport de.paragon.explorer.model.AttributeModel;\r\nimport de.paragon.explorer.model.ConnectionModel;\r\nimport de.paragon.explorer.model.ExplorerModel;\r\nimport de.paragon.explorer.model.ObjectHeaderModel;\r\nimport de.paragon.explorer.model.ObjectModel;\r\n\r\n/**\r\n * Kommentar: Aufgrund der zum Zeitpunkt zu Beginn der Implementierung der\r\n * ConnectionFigures absehbaren, eingeschraenkten Funktionalitaet der\r\n * zugehoerigen Builder und Models wurde fuer ConnectionFigure und fuer\r\n * ConnectionModel zusammen nur ein Builder installiert.\r\n */\r\npublic final class ConnectionBuilder {\r\n\r\n    private static final Logger logger = LoggerFactory.make();\r\n\r\n    private static final String ERROR_WHILE_REMOVING = \"connectionbuilder.error_while_removing\";\r\n\r\n    private static ConnectionBuilder singleton;\r\n\r\n    public static ConnectionBuilder getInstance() {\r\n        return ConnectionBuilder.getSingleton();\r\n    }\r\n\r\n    private static ConnectionBuilder getSingleton() {\r\n        if (ConnectionBuilder.singleton == null) {\r\n            ConnectionBuilder.setSingleton(new ConnectionBuilder());\r\n        }\r\n        return ConnectionBuilder.singleton;\r\n    }\r\n\r\n    private static void setSingleton(ConnectionBuilder builder) {\r\n        ConnectionBuilder.singleton = builder;\r\n    }\r\n\r\n    private ConnectionBuilder() {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Das ObjectHeaderModel ist das Zielmodell. Das AttributeModel\r\n     * ist das StartModell. Die beiden Modelle haben also, falls das Attribute\r\n     * des Objects nicht auf sich selbst refernziert, kein gemeinsames\r\n     * ObjectModel. Diese Methode erzeugt ConnectionFigure und ConnectionModel,\r\n     * baut und zeichnet die ConnectionFigure. \"add\" heisst hier: erzeugen,\r\n     * bauen und zeichnen.\r\n     */\r\n    public void addConnection(ObjectHeaderModel headerModel, AttributeModel attrModl) {\r\n        ConnectionModel conModl = this.createNewConnection(headerModel, attrModl);\r\n        StandardConnectionFigure conFig = (StandardConnectionFigure) conModl.getFigure();\r\n        TextBoxFigure headerFig = (TextBoxFigure) headerModel.getFigure();\r\n        TextBoxFigure attrFig = (TextBoxFigure) attrModl.getFigure();\r\n        this.buildConnection(conFig, headerFig, attrFig);\r\n        // this.drawConnectionFigure(conFig);\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Die StandardConnectionFigure ist so konzipiert, dass sie\r\n     * anhand der beiden verbundenen Figuren alles weiss. Das bedeutet, beim\r\n     * Zeichnen ermittelt sie selbstaendig anhand der Figuren, wo und wie sie\r\n     * sich zu zeichnen hat. Daher bedeutet \"bauen\" lediglich das Zuweisen der\r\n     * Start- und Zielfigur. Weiter baut diese Methode gleichzeitig die\r\n     * entsprechenden Models: Das ConnectionModel erhaelt Referenzen auf das\r\n     * Attribute- und das ObjectHeaderModel, die jeweiligen ObjectModels dieser\r\n     * Models erhalten Referenzen auf die ConnectionFigure.\r\n     */\r\n    private void buildConnection(StandardConnectionFigure conFig, TextBoxFigure headerFigure, TextBoxFigure attrFigure) {\r\n        AttributeModel attrModl = (AttributeModel) attrFigure.getModel();\r\n        ObjectHeaderModel headModl = (ObjectHeaderModel) headerFigure.getModel();\r\n        conFig.setStartFigure(attrFigure);\r\n        conFig.setEndFigure(headerFigure);\r\n        (conFig.getModel()).setAttributeModel(attrModl);\r\n        (conFig.getModel()).setHeaderModel(headModl);\r\n        (attrModl.getObjectModel()).addConnectionModel(conFig.getModel());\r\n        (headModl.getObjectModel()).addConnectionModel(conFig.getModel());\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode erzeugt ein neues ConnectionModel und eine neue\r\n     * StandardConnectionFigure. Danach werden alle Verknuepfungen\r\n     * gemacht:ConnectionModel mit ExplorerModel, die Zuweisung von HeaderModel\r\n     * und AttributeModel zum ConnectionModel, die Verknuepfung ConnectionModel\r\n     * mit ConnectionFigure und ConnectionFigure mit ExplorerFigure. Zu Beachten\r\n     * gilt: addConnectionFigure erledigt hier lediglich nur die Verknuepfung\r\n     * zwischen den Figuren, im Gegensatz dazu steht ja das add in der Methode\r\n     * addConnectionFigure fuer erzeugen, bauen und verknuepfen.\r\n     *\r\n     * @param headerModel\r\n     *            ObjectHeaderModel\r\n     * @param attrModl\r\n     *            AttributeModel\r\n     *\r\n     * @return ConnectionModel\r\n     */\r\n    private ConnectionModel createNewConnection(ObjectHeaderModel headerModel, AttributeModel attrModl) {\r\n        ExplorerFigure explFig = this.getExplorerFigureFor(headerModel);\r\n        ConnectionModel conModl = new ConnectionModel();\r\n        StandardConnectionFigure conFig = new StandardConnectionFigure();\r\n        attrModl.setConnectionModel(conModl);\r\n        conModl.setFigure(conFig);\r\n        conFig.setModel(conModl);\r\n        conModl.setHeaderModel(headerModel);\r\n        conModl.setAttributeModel(attrModl);\r\n        conModl.setExplorerModel((ExplorerModel) explFig.getModel());\r\n        this.getExplorerFigureBuilder().addConnectionFigure(conFig, explFig);\r\n        return conModl;\r\n    }\r\n\r\n    private void drawInForeground(StandardConnectionFigure conFig) {\r\n        this.getExplorerFigureBuilder().setInForeground(conFig);\r\n        // this.drawConnectionFigure(conFig);\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht davon aus, dass zwei zu verbindende Figuren\r\n     * mit ihren Models -sprich eine TextBoxFigure und eine ListBoxFigure-\r\n     * existieren und im Vordergrund gezeichnet sind. Sie soll herausfinden, ob\r\n     * eine derartige ConnectionFigure mit ihrem Model bereits existiert. Anhand\r\n     * der ListBoxFigure werden zunaechst alle ConnectionModels ausfindig\r\n     * gemacht, die zur List-BoxFigure zeigen oder von ihr weg zeigen. Alle\r\n     * diese werden durchsucht, ob das Attribute-Model des ConnectionModels mit\r\n     * dem Model der TextBoxFigure und das HeaderModel des Connection-Models mit\r\n     * dem HeaderModel der ListBoxFigure uebereinstimmt. Dieses wird dann der\r\n     * Rueckgabevariablen zugewiesen. Wird keines gefunden, wird also null\r\n     * zurueckgegeben.\r\n     *\r\n     * @param teBoFi\r\n     *            TextBoxFigure\r\n     * @param liBoFi\r\n     *            ListBoxFigure\r\n     *\r\n     * @return StandardConnectionFigure\r\n     */\r\n    private StandardConnectionFigure getConnectionFigureToShow(TextBoxFigure teBoFi, ListBoxFigure liBoFi) {\r\n        StandardEnumeration enumeration;\r\n        ObjectModel objModl = (ObjectModel) liBoFi.getModel();\r\n        StandardConnectionFigure conFigToShow = null;\r\n        ConnectionModel tempConModl;\r\n        enumeration = objModl.getConnectionModels();\r\n        while (enumeration.hasMoreElements()) {\r\n            tempConModl = (ConnectionModel) enumeration.nextElement();\r\n            if (tempConModl.getAttributeModel() == (AttributeModel) teBoFi.getModel()) {\r\n                if (tempConModl.getHeaderModel() == ((ObjectModel) liBoFi.getModel()).getHeaderModel()) {\r\n                    conFigToShow = (StandardConnectionFigure) tempConModl.getFigure();\r\n                }\r\n            }\r\n        }\r\n        return conFigToShow;\r\n    }\r\n\r\n    private ExplorerFigureBuilder getExplorerFigureBuilder() {\r\n        return ExplorerFigureBuilder.getInstance();\r\n    }\r\n\r\n    private ExplorerFigure getExplorerFigureFor(ObjectHeaderModel headModl) {\r\n        return (ExplorerFigure) headModl.getObjectModel().getExplorerModel().getFigure();\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht davon aus, dass das objectModel und die\r\n     * zugehoerige ListBoxFigure geloescht, das heisst, aus ihren jeweiligen\r\n     * Containern entfernt sind. Sie entfernt das ConnectionModel vom\r\n     * AttributeModel, von dem es aus eine Referenz zeigte, und aus den Listen\r\n     * der beiden Objektmodelle, von dem bzw.zu dem das ConnectionModel zeigte.\r\n     */\r\n    public void removeConnections(ObjectModel objModl) {\r\n        StandardEnumeration conModls = objModl.getConnectionModels();\r\n        while (conModls.hasMoreElements()) {\r\n            ConnectionModel tempConModl = (ConnectionModel) conModls.nextElement();\r\n            this.removeFromObjectModels(tempConModl);\r\n            this.removeFromAttributeModel(tempConModl);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Fuer den Fall, dass eine komplette ListBoxFigure geloescht\r\n     * werden soll, geht diese Methode davon aus, dass das objectModel und die\r\n     * zugehoerige ListBoxFigure geloescht, das heisst, aus ihren jeweiligen\r\n     * Containern entfernt sind. Eine Referenz von den beiden ObjectModels, auf\r\n     * die gezeigt wird und von denen gezeigt wird, exi- stiert ebenfalls nicht\r\n     * mehr. Fuer den Fall, dass eine Connection geloescht werden soll, geht\r\n     * diese Methode davon aus, dass eine Referenz von den beiden ObjectModels,\r\n     * auf die gezeigt wird und von denen gezeigt wird, nicht mehr existiert.\r\n     * Sie setzt die Referenz des Attributmodells zum Connectionmodell auf null\r\n     * und entfernt die zugehoerige ConnectionFigure aus dem figureStore der\r\n     * ExplorerFigure.\r\n     */\r\n    private void removeFromAttributeModel(ConnectionModel conModl) {\r\n        conModl.getAttributeModel().setConnectionModel(null);\r\n        try {\r\n            if (conModl.getFigure().getParent() != null) {\r\n                conModl.getFigure().getParent().remove(conModl.getFigure());\r\n            }\r\n        } catch (Exception ex) {\r\n            ConnectionBuilder.logger.error(ResourceBundlePurchaser.getMessage(ConnectionBuilder.ERROR_WHILE_REMOVING), ex);\r\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(ConnectionBuilder.ERROR_WHILE_REMOVING));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Im Falle, dass diese Methode zum Loeschen einer ListBoxFigure\r\n     * aufgerufen wird, geht diese Methode davon aus, dass das objectModel und\r\n     * die zugehoerige ListBoxFigure geloescht, das heisst, aus ihren jeweiligen\r\n     * Containern entfernt sind. Weiter besteht keine Referenz mehr vom\r\n     * ExplorerModel und von der ExplorerFigure auf die Connection. Im Falle,\r\n     * dass diese Methode zum Loeschen einer einzelnen Connection aufgerufen\r\n     * wird, geht diese Methode davon aus, dass noch alle Beziehungen\r\n     * existieren. Diese Methode entfernt die Referenzen von den ObjectModels,\r\n     * von denen die Connection ausgeht oder auf die die Connection zeigt, auf\r\n     * die Connection.\r\n     */\r\n    private void removeFromObjectModels(ConnectionModel conModl) {\r\n        StandardConnectionFigure conFig = (StandardConnectionFigure) conModl.getFigure();\r\n        ListBoxFigure liBoFi;\r\n        liBoFi = (ListBoxFigure) conFig.getStartFigure().getParent();\r\n        ((ObjectModel) liBoFi.getModel()).removeConnectionModel(conModl);\r\n        liBoFi = (ListBoxFigure) conFig.getEndFigure().getParent();\r\n        ((ObjectModel) liBoFi.getModel()).removeConnectionModel(conModl);\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht davon aus, dass noch nichts geloescht\r\n     * worden ist. Sie geht so vor, dass sie zunaechst die Referenzen aus den\r\n     * ObjectModels loescht, und dann aus dem AttributeModel, von dem die\r\n     * Connection aus die Referenz zeigte.\r\n     */\r\n    public void removeSingleConnection(AttributeModel attrModl) {\r\n        if (attrModl.getConnectionModel() != null) {\r\n            this.removeFromObjectModels(attrModl.getConnectionModel());\r\n            this.removeFromAttributeModel(attrModl.getConnectionModel());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht davon aus, dass die TextBox- Figure mit\r\n     * einem AttributModel verknuepft ist. Weiter geht sie davon aus, dass eine\r\n     * zu referenzierende ListBoxFigure existiert, und im Vordergrund gezeichnet\r\n     * worden ist. Die ConnectionFigure muss noch gezeigt werden. Diese Methode\r\n     * ueberprueft zunaechst, ob eine entsprechende ConnectionFigure ueberhaupt\r\n     * existiert. Existiert sie, braucht sie lediglich in den Vordergrund\r\n     * gezeichnet werden. Existiert sie nicht, muss sie neu hinzugefuegt (\"add\")\r\n     * werden.\r\n     */\r\n    public void showConnection(TextBoxFigure teBoFi, ListBoxFigure liBoFi) {\r\n        StandardConnectionFigure conFig = this.getConnectionFigureToShow(teBoFi, liBoFi);\r\n        if (conFig == null) {\r\n            ObjectHeaderModel objHead = ((ObjectModel) liBoFi.getModel()).getHeaderModel();\r\n            this.addConnection(objHead, (AttributeModel) teBoFi.getModel());\r\n        } else {\r\n            this.drawInForeground(conFig);\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/util/ConnectionBuilderTest.java",
		"test_prompt": "// ConnectionBuilderTest.java\npackage de.paragon.explorer.util;\n\nimport org.apache.log4j.Logger;\nimport de.paragon.explorer.figure.ExplorerFigure;\nimport de.paragon.explorer.figure.ExplorerFigureBuilder;\nimport de.paragon.explorer.figure.ListBoxFigure;\nimport de.paragon.explorer.figure.StandardConnectionFigure;\nimport de.paragon.explorer.figure.TextBoxFigure;\nimport de.paragon.explorer.gui.Warning;\nimport de.paragon.explorer.model.AttributeModel;\nimport de.paragon.explorer.model.ConnectionModel;\nimport de.paragon.explorer.model.ExplorerModel;\nimport de.paragon.explorer.model.ObjectHeaderModel;\nimport de.paragon.explorer.model.ObjectModel;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ConnectionBuilder}.\n* It contains ten unit test cases for the {@link ConnectionBuilder#getInstance()} method.\n*/\nclass ConnectionBuilderTest {"
	},
	{
		"original_code": "// AttributeTitleManager.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.util;\r\n\r\nimport java.lang.reflect.Modifier;\r\nimport java.util.Vector;\r\nimport org.apache.log4j.Logger;\r\nimport de.paragon.explorer.ProjectConstants4ObjectExplorer;\r\nimport de.paragon.explorer.model.AttributeModel;\r\nimport de.paragon.explorer.model.NullObject;\r\n\r\n/**\r\n * In dieser Klasse sind die Reglen hinterlegt, wie der Title eines Attributes\r\n * aussieht, abhaengig vom Typ.\r\n */\r\npublic final class AttributeTitleManager {\r\n\r\n    private static final Logger logger = LoggerFactory.make();\r\n\r\n    private static AttributeTitleManager singleton;\r\n\r\n    public static AttributeTitleManager getSingleton() {\r\n        if (AttributeTitleManager.singleton == null) {\r\n            AttributeTitleManager.setSingleton(new AttributeTitleManager());\r\n        }\r\n        return AttributeTitleManager.singleton;\r\n    }\r\n\r\n    private static void setSingleton(AttributeTitleManager newSingleton) {\r\n        AttributeTitleManager.singleton = newSingleton;\r\n    }\r\n\r\n    private AttributeTitleManager() {\r\n        super();\r\n    }\r\n\r\n    public String getCompleteTitle(AttributeModel attrModl) {\r\n        return Modifier.toString(attrModl.getModifiers()) + \" \" + this.getTypeName(attrModl.getType()) + \"  \" + attrModl.getName() + \"     \" + this.getValueAsString(attrModl.getValue());\r\n    }\r\n\r\n    public String getTitle(AttributeModel attrModl) {\r\n        if (attrModl.isAttributePrimitive()) {\r\n            return attrModl.getName() + \"     \" + this.getValueAsString(attrModl.getValue());\r\n        } else {\r\n            return attrModl.getName();\r\n        }\r\n    }\r\n\r\n    private String getTypeName(Class<?> type) {\r\n        if (type.isArray()) {\r\n            try {\r\n                Class<?> cl = type;\r\n                int dimensions = 0;\r\n                while (cl.isArray()) {\r\n                    dimensions++;\r\n                    cl = cl.getComponentType();\r\n                }\r\n                StringBuffer sb = new StringBuffer();\r\n                sb.append(cl.getName());\r\n                for (int i = 0; i < dimensions; i++) {\r\n                    sb.append(\"[]\");\r\n                }\r\n                return sb.toString();\r\n            } catch (Throwable t) {\r\n                AttributeTitleManager.logger.error(\"-->> Fehler bei getTypeName\", t);\r\n            }\r\n        }\r\n        return type.getName();\r\n    }\r\n\r\n    private String getValueAsString(Object object) {\r\n        if (object instanceof NullObject) {\r\n            return ProjectConstants4ObjectExplorer.getSTRING_NULL();\r\n        } else if (object instanceof Vector) {\r\n            Vector<Object> vector2return = new Vector<Object>();\r\n            Vector<?> vector2transfer = (Vector<?>) object;\r\n            for (Object object2 : vector2transfer) {\r\n                vector2return.add(object2);\r\n            }\r\n            return ToStringConverter.convertVectorToString(vector2return);\r\n        } else {\r\n            return object.toString();\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/util/AttributeTitleManagerTest.java",
		"test_prompt": "// AttributeTitleManagerTest.java\npackage de.paragon.explorer.util;\n\nimport java.lang.reflect.Modifier;\nimport java.util.Vector;\nimport org.apache.log4j.Logger;\nimport de.paragon.explorer.ProjectConstants4ObjectExplorer;\nimport de.paragon.explorer.model.AttributeModel;\nimport de.paragon.explorer.model.NullObject;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AttributeTitleManager}.\n* It contains ten unit test cases for the {@link AttributeTitleManager#getSingleton()} method.\n*/\nclass AttributeTitleManagerTest {"
	},
	{
		"original_code": "// ToStringConverter.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.util;\r\n\r\nimport java.util.Vector;\r\n\r\n/**\r\n * Diese Klasse stellt Algorithmen zur Verfuegung um den Wert von Objekten als\r\n * String darzustellen. Wurde implmentiert, da die Methode toString bei der\r\n * Klasse Vector im Falle eines Verweises auf sich selbst zu einer Exception\r\n * fuehrt.\r\n */\r\npublic final class ToStringConverter {\r\n\r\n    private static final String COMMA_BLANK = \", \";\r\n\r\n    private static final String THIS = \"this\";\r\n\r\n    private static final String CLOSE_SQUARE_BRACKET = \"]\";\r\n\r\n    private static final String OPEN_SQUARE_BRACKET = \"[\";\r\n\r\n    public static String convertVectorToString(Vector<Object> vector) {\r\n        StringBuffer buf = new StringBuffer();\r\n        buf.append(ToStringConverter.OPEN_SQUARE_BRACKET);\r\n        int maxIndex = vector.size() - 1;\r\n        for (int i = 0; i <= maxIndex; i++) {\r\n            if (vector.elementAt(i) != vector) {\r\n                buf.append(String.valueOf(vector.elementAt(i)));\r\n            } else {\r\n                buf.append(ToStringConverter.THIS);\r\n            }\r\n            if (i < maxIndex) {\r\n                buf.append(ToStringConverter.COMMA_BLANK);\r\n            }\r\n        }\r\n        buf.append(ToStringConverter.CLOSE_SQUARE_BRACKET);\r\n        return buf.toString();\r\n    }\r\n\r\n    /**\r\n     * ToStringConverter constructor comment.\r\n     */\r\n    private ToStringConverter() {\r\n        super();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/util/ToStringConverterTest.java",
		"test_prompt": "// ToStringConverterTest.java\npackage de.paragon.explorer.util;\n\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ToStringConverter}.\n* It contains ten unit test cases for the {@link ToStringConverter#convertVectorToString(Vector)} method.\n*/\nclass ToStringConverterTest {"
	},
	{
		"original_code": "// LoggerFactory.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.util;\r\n\r\nimport org.apache.log4j.Logger;\r\n\r\n/**\r\n * Factory f�r Log4J.\r\n *\r\n * @author Stefan Jockenh�vel\r\n *\r\n * @see http://www.javaspecialists.eu/archive/Issue137.html\r\n * @see http://shemnon.com/speling/2006/12/dry-logs-there-are-better-ways.html\r\n *      --> comment\r\n */\r\npublic final class LoggerFactory {\r\n\r\n    /**\r\n     * Erzeugt einen Logger in der aufrufenden Klasse.\r\n     *\r\n     * @return Logger\r\n     */\r\n    public static Logger make() {\r\n        // Throwable t = new Throwable();\r\n        // StackTraceElement directCaller = t.getStackTrace()[1];\r\n        // return Logger.getLogger(directCaller.getClassName());\r\n        final Thread t = Thread.currentThread();\r\n        final StackTraceElement directCaller = t.getStackTrace()[2];\r\n        final String className = directCaller.getClassName();\r\n        return Logger.getLogger(className);\r\n    }\r\n\r\n    /**\r\n     * privater Konstruktur --> kein Erzeugen einer Instanz sinnvoll!\r\n     */\r\n    private LoggerFactory() {\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/util/LoggerFactoryTest.java",
		"test_prompt": "// LoggerFactoryTest.java\npackage de.paragon.explorer.util;\n\nimport org.apache.log4j.Logger;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link LoggerFactory}.\n* It contains ten unit test cases for the {@link LoggerFactory#make()} method.\n*/\nclass LoggerFactoryTest {"
	},
	{
		"original_code": "// PropertyManager.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.util;\r\n\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileNotFoundException;\r\nimport java.io.FileOutputStream;\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\nimport java.util.Properties;\r\nimport org.apache.log4j.Logger;\r\n\r\n/**\r\n * @author Stefan Jockenh�vel\r\n */\r\npublic final class PropertyManager {\r\n\r\n    private static final String EXPLORER_INI = \"explorer.ini\";\r\n\r\n    private static PropertyManager instance = null;\r\n\r\n    private static final Logger logger = LoggerFactory.make();\r\n\r\n    private static Properties properties = null;\r\n\r\n    private static final String PROPERTY_HIDE_NULL_ATTRIBUTES = \"hideNullAttributes\";\r\n\r\n    private static final String PROPERTY_HIDE_STATIC_ATTRIBUTES = \"hideStaticAttributes\";\r\n\r\n    private static final String PROPERTY_HIDE_UNEXPLORED_ATTRIBUTES = \"hideUnexploredAttributes\";\r\n\r\n    private static final String PROPERTYMANAGER_ERROR_FILE_NOT_FOUND = \"propertymanager.error_file_not_found\";\r\n\r\n    private static final String PROPERTYMANAGER_ERROR_FILE_NOT_SAVED = \"propertymanager.error_file_not_saved\";\r\n\r\n    private static final String PROPERTYMANAGER_ERROR_WHILE_CLOSE = \"propertymanager.error_while_close\";\r\n\r\n    private static final String PROPERTYMANAGER_ERROR_WHILE_READING = \"propertymanager.error_while_reading\";\r\n\r\n    private static final String PROPERTYMANAGER_ERROR_WITH_MEMORY_LOCATION = \"propertymanager.error_with_memory_location\";\r\n\r\n    private static final String PROPERTYMANAGER_INFO_FILE_APPLIED = \"propertymanager.info_file_applied\";\r\n\r\n    private static final String PROPERTYMANAGER_INFO_FILE_NOT_FOUND = \"propertymanager.info_file_not_found\";\r\n\r\n    private static final String PROPERTYMANAGER_INFO_FILE_UPDATED = \"propertymanager.info_file_updated\";\r\n\r\n    private static final String PROPERTYMANAGER_INFO_FILE_WAS_UP_TO_DATE = \"propertymanager.info_file_was_up_to_date\";\r\n\r\n    private static final String PROPERTYMANAGER_INFO_SUCCESFUL_LOADING = \"propertymanager.info_succesful_loading\";\r\n\r\n    private static final String TEXT_PROPERTIES_INITIALIZE = \"/* properties initialize */\";\r\n\r\n    private static final String TEXT_PROPERTIES_UPDATET = \"/* properties updatet */\";\r\n\r\n    private static final String TRUE_AS_STRING = \"true\";\r\n\r\n    private static final String USER_HOME = \"user.home\";\r\n\r\n    private static final Integer NUMBER_OF_PROPERTIES = 3;\r\n\r\n    public static PropertyManager getInstance() {\r\n        if ((PropertyManager.instance == null)) {\r\n            PropertyManager.instance = new PropertyManager();\r\n        }\r\n        return PropertyManager.instance;\r\n    }\r\n\r\n    private PropertyManager() {\r\n        String dataDir = System.getProperty(PropertyManager.USER_HOME);\r\n        String iniFile = null;\r\n        //\r\n        iniFile = this.getCompletePath4IniFile();\r\n        if (iniFile != null) {\r\n            PropertyManager.properties = new Properties();\r\n            FileInputStream fis = null;\r\n            try {\r\n                fis = new FileInputStream(iniFile);\r\n                PropertyManager.properties.load(fis);\r\n                if (PropertyManager.logger.isDebugEnabled()) {\r\n                    PropertyManager.properties.list(System.out);\r\n                    if (PropertyManager.properties.size() != PropertyManager.NUMBER_OF_PROPERTIES) {\r\n                        if (!PropertyManager.properties.containsKey(PropertyManager.PROPERTY_HIDE_NULL_ATTRIBUTES)) {\r\n                            PropertyManager.properties.put(PropertyManager.PROPERTY_HIDE_NULL_ATTRIBUTES, PropertyManager.TRUE_AS_STRING);\r\n                        }\r\n                        if (!PropertyManager.properties.containsKey(PropertyManager.PROPERTY_HIDE_STATIC_ATTRIBUTES)) {\r\n                            PropertyManager.properties.put(PropertyManager.PROPERTY_HIDE_STATIC_ATTRIBUTES, PropertyManager.TRUE_AS_STRING);\r\n                        }\r\n                        if (!PropertyManager.properties.containsKey(PropertyManager.PROPERTY_HIDE_UNEXPLORED_ATTRIBUTES)) {\r\n                            PropertyManager.properties.put(PropertyManager.PROPERTY_HIDE_UNEXPLORED_ATTRIBUTES, PropertyManager.TRUE_AS_STRING);\r\n                        }\r\n                        this.saveIniFile(iniFile, PropertyManager.TEXT_PROPERTIES_INITIALIZE);\r\n                        if (PropertyManager.logger.isDebugEnabled()) {\r\n                            PropertyManager.logger.debug(ResourceBundlePurchaser.getSubstitutedMessage(PropertyManager.PROPERTYMANAGER_INFO_FILE_UPDATED, PropertyManager.EXPLORER_INI));\r\n                        }\r\n                    }\r\n                    PropertyManager.logger.debug(ResourceBundlePurchaser.getSubstitutedMessage(PropertyManager.PROPERTYMANAGER_INFO_SUCCESFUL_LOADING, iniFile));\r\n                }\r\n            } catch (FileNotFoundException ex) {\r\n                this.createAndSaveNewIniFile(iniFile, dataDir);\r\n            } catch (IOException ex) {\r\n                PropertyManager.logger.error(ResourceBundlePurchaser.getSubstitutedMessage(PropertyManager.PROPERTYMANAGER_ERROR_WHILE_READING, iniFile), ex);\r\n            }\r\n            try {\r\n                if (fis != null) {\r\n                    fis.close();\r\n                }\r\n            } catch (IOException ex) {\r\n                PropertyManager.logger.error(ResourceBundlePurchaser.getSubstitutedMessage(PropertyManager.PROPERTYMANAGER_ERROR_WHILE_CLOSE, iniFile), ex);\r\n            }\r\n        } else {\r\n            PropertyManager.logger.error(ResourceBundlePurchaser.getSubstitutedMessage(PropertyManager.PROPERTYMANAGER_ERROR_WITH_MEMORY_LOCATION, PropertyManager.USER_HOME));\r\n        }\r\n    }\r\n\r\n    private void createAndSaveNewIniFile(String iniFile, String dataDir) {\r\n        if (PropertyManager.logger.isDebugEnabled()) {\r\n            PropertyManager.logger.debug(ResourceBundlePurchaser.getSubstitutedMessage(PropertyManager.PROPERTYMANAGER_INFO_FILE_NOT_FOUND, PropertyManager.EXPLORER_INI, dataDir));\r\n        }\r\n        // neue Ini-Datei anlegen\r\n        FileWriter fw = null;\r\n        try {\r\n            fw = new FileWriter(iniFile);\r\n            if (PropertyManager.logger.isDebugEnabled()) {\r\n                PropertyManager.logger.debug(ResourceBundlePurchaser.getSubstitutedMessage(PropertyManager.PROPERTYMANAGER_INFO_FILE_APPLIED, PropertyManager.EXPLORER_INI, dataDir));\r\n            }\r\n            // Default-Properties anlegen\r\n            PropertyManager.properties = new Properties();\r\n            PropertyManager.properties.put(PropertyManager.PROPERTY_HIDE_NULL_ATTRIBUTES, PropertyManager.TRUE_AS_STRING);\r\n            PropertyManager.properties.put(PropertyManager.PROPERTY_HIDE_STATIC_ATTRIBUTES, PropertyManager.TRUE_AS_STRING);\r\n            PropertyManager.properties.put(PropertyManager.PROPERTY_HIDE_UNEXPLORED_ATTRIBUTES, PropertyManager.TRUE_AS_STRING);\r\n            this.saveIniFile(iniFile, PropertyManager.TEXT_PROPERTIES_INITIALIZE);\r\n            if (PropertyManager.logger.isDebugEnabled()) {\r\n                PropertyManager.logger.debug(ResourceBundlePurchaser.getSubstitutedMessage(PropertyManager.PROPERTYMANAGER_INFO_FILE_UPDATED, PropertyManager.EXPLORER_INI));\r\n            }\r\n        } catch (IOException ex) {\r\n            PropertyManager.logger.error(ResourceBundlePurchaser.getSubstitutedMessage(PropertyManager.PROPERTYMANAGER_ERROR_FILE_NOT_SAVED, PropertyManager.EXPLORER_INI), ex);\r\n        }\r\n        try {\r\n            if (fw != null) {\r\n                fw.close();\r\n            }\r\n        } catch (IOException ex) {\r\n            PropertyManager.logger.error(ResourceBundlePurchaser.getSubstitutedMessage(PropertyManager.PROPERTYMANAGER_ERROR_WHILE_CLOSE, PropertyManager.EXPLORER_INI), ex);\r\n        }\r\n    }\r\n\r\n    private String getCompletePath4IniFile() {\r\n        String dataDir = System.getProperty(PropertyManager.USER_HOME);\r\n        String iniFile = PropertyManager.EXPLORER_INI;\r\n        if (dataDir != null) {\r\n            if (!dataDir.endsWith(File.separator)) {\r\n                dataDir = dataDir + File.separator;\r\n            }\r\n            return dataDir + iniFile;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public boolean getHideNullAttribut() {\r\n        String returnValue = PropertyManager.properties.getProperty(PropertyManager.PROPERTY_HIDE_NULL_ATTRIBUTES);\r\n        if ((returnValue != null) && returnValue.equals(PropertyManager.TRUE_AS_STRING)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public boolean getHideStaticAttribut() {\r\n        String returnValue = PropertyManager.properties.getProperty(PropertyManager.PROPERTY_HIDE_STATIC_ATTRIBUTES);\r\n        if ((returnValue != null) && returnValue.equals(PropertyManager.TRUE_AS_STRING)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public boolean getHideUnexploredAttribut() {\r\n        String returnValue = PropertyManager.properties.getProperty(PropertyManager.PROPERTY_HIDE_UNEXPLORED_ATTRIBUTES);\r\n        if ((returnValue != null) && returnValue.equals(PropertyManager.TRUE_AS_STRING)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private void saveIniFile(String iniFile, String comment) {\r\n        FileOutputStream out = null;\r\n        try {\r\n            out = new FileOutputStream(iniFile);\r\n        } catch (FileNotFoundException ex) {\r\n            PropertyManager.logger.error(ResourceBundlePurchaser.getSubstitutedMessage(PropertyManager.PROPERTYMANAGER_ERROR_FILE_NOT_FOUND, PropertyManager.EXPLORER_INI, ex));\r\n        }\r\n        try {\r\n            PropertyManager.properties.store(out, comment);\r\n        } catch (IOException ex) {\r\n            PropertyManager.logger.error(ResourceBundlePurchaser.getSubstitutedMessage(PropertyManager.PROPERTYMANAGER_ERROR_FILE_NOT_SAVED, PropertyManager.EXPLORER_INI), ex);\r\n        }\r\n        try {\r\n            if (out != null) {\r\n                out.close();\r\n            }\r\n        } catch (IOException ex) {\r\n            PropertyManager.logger.error(ResourceBundlePurchaser.getSubstitutedMessage(PropertyManager.PROPERTYMANAGER_ERROR_WHILE_CLOSE, PropertyManager.EXPLORER_INI), ex);\r\n        }\r\n    }\r\n\r\n    public void setHideAttributes(boolean newValueHideNull, boolean newValueHideStatic, boolean newValueHideUnexplored) {\r\n        boolean save = false;\r\n        if (!Boolean.valueOf(this.getHideNullAttribut()).equals(newValueHideNull)) {\r\n            PropertyManager.properties.setProperty(PropertyManager.PROPERTY_HIDE_NULL_ATTRIBUTES, Boolean.valueOf(newValueHideNull).toString());\r\n            save = true;\r\n        }\r\n        if (!save && !Boolean.valueOf(this.getHideStaticAttribut()).equals(newValueHideStatic)) {\r\n            PropertyManager.properties.setProperty(PropertyManager.PROPERTY_HIDE_STATIC_ATTRIBUTES, Boolean.valueOf(newValueHideStatic).toString());\r\n            if (!save) {\r\n                save = true;\r\n            }\r\n        }\r\n        if (!save && !Boolean.valueOf(this.getHideUnexploredAttribut()).equals(newValueHideUnexplored)) {\r\n            PropertyManager.properties.setProperty(PropertyManager.PROPERTY_HIDE_UNEXPLORED_ATTRIBUTES, Boolean.valueOf(newValueHideUnexplored).toString());\r\n            if (!save) {\r\n                save = true;\r\n            }\r\n        }\r\n        if (save) {\r\n            // in die Ini-Datei schreiben\r\n            String iniFile = this.getCompletePath4IniFile();\r\n            if (iniFile != null) {\r\n                this.saveIniFile(iniFile, PropertyManager.TEXT_PROPERTIES_UPDATET);\r\n                if (PropertyManager.logger.isDebugEnabled()) {\r\n                    PropertyManager.logger.debug(ResourceBundlePurchaser.getSubstitutedMessage(PropertyManager.PROPERTYMANAGER_INFO_FILE_UPDATED, PropertyManager.EXPLORER_INI));\r\n                }\r\n            } else {\r\n                PropertyManager.logger.error(ResourceBundlePurchaser.getSubstitutedMessage(PropertyManager.PROPERTYMANAGER_ERROR_WITH_MEMORY_LOCATION, PropertyManager.USER_HOME));\r\n            }\r\n        } else {\r\n            if (PropertyManager.logger.isDebugEnabled()) {\r\n                PropertyManager.logger.debug(ResourceBundlePurchaser.getSubstitutedMessage(PropertyManager.PROPERTYMANAGER_INFO_FILE_WAS_UP_TO_DATE, PropertyManager.EXPLORER_INI));\r\n            }\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/util/PropertyManagerTest.java",
		"test_prompt": "// PropertyManagerTest.java\npackage de.paragon.explorer.util;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Properties;\nimport org.apache.log4j.Logger;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PropertyManager}.\n* It contains ten unit test cases for the {@link PropertyManager#getInstance()} method.\n*/\nclass PropertyManagerTest {"
	},
	{
		"original_code": "// StandardEnumerator.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.util;\r\n\r\nimport java.util.NoSuchElementException;\r\nimport java.util.Vector;\r\nimport de.paragon.explorer.figure.Figure;\r\n\r\npublic class StandardEnumerator implements StandardEnumeration {\r\n\r\n    private static final String NO_SUCH_ELEMENT_EXCEPTION = \"standardenumerator.no_such_element_exception\";\r\n\r\n    private Vector<Object> vector;\r\n\r\n    private int count = 0;\r\n\r\n    public StandardEnumerator() {\r\n        this(new Vector<Object>());\r\n    }\r\n\r\n    public StandardEnumerator(Vector<?> newVector) {\r\n        super();\r\n        this.setVector(newVector);\r\n    }\r\n\r\n    public void addElement(Object object) {\r\n        if (this.getCount() == 0) {\r\n            this.getVector().addElement(object);\r\n        }\r\n    }\r\n\r\n    public int getCount() {\r\n        return this.count;\r\n    }\r\n\r\n    public Vector<Object> getVector() {\r\n        return this.vector;\r\n    }\r\n\r\n    public boolean hasMoreElements() {\r\n        if (this.getCount() < this.getVector().size()) {\r\n            return true;\r\n        }\r\n        this.setCount(0);\r\n        return false;\r\n    }\r\n\r\n    public void insertElementAt(Object obj, int index) {\r\n        this.getVector().insertElementAt(obj, index);\r\n    }\r\n\r\n    public boolean isInEnumeration(Object object) {\r\n        return this.getVector().contains(object);\r\n    }\r\n\r\n    public Object nextElement() {\r\n        synchronized (this.getVector()) {\r\n            if (this.getCount() < this.getVector().size()) {\r\n                this.setCount(this.getCount() + 1);\r\n                return this.getVector().elementAt(this.getCount() - 1);\r\n            }\r\n        }\r\n        throw new NoSuchElementException(ResourceBundlePurchaser.getMessage(StandardEnumerator.NO_SUCH_ELEMENT_EXCEPTION));\r\n    }\r\n\r\n    public Figure nextFigure() {\r\n        synchronized (this.getVector()) {\r\n            if (this.getCount() < this.getVector().size()) {\r\n                this.setCount(this.getCount() + 1);\r\n                return (Figure) this.getVector().elementAt(this.getCount() - 1);\r\n            }\r\n        }\r\n        throw new NoSuchElementException(ResourceBundlePurchaser.getMessage(StandardEnumerator.NO_SUCH_ELEMENT_EXCEPTION));\r\n    }\r\n\r\n    public void removeElement(Object object) {\r\n        if (this.getCount() == 0) {\r\n            this.getVector().removeElement(object);\r\n        }\r\n    }\r\n\r\n    public void setCount(int i) {\r\n        this.count = i;\r\n    }\r\n\r\n    public void setVector(Vector<?> newVector) {\r\n        Vector<Object> vector2return = new Vector<Object>();\r\n        for (Object object : newVector) {\r\n            vector2return.add(object);\r\n        }\r\n        this.vector = vector2return;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/util/StandardEnumeratorTest0.java",
		"test_prompt": "// StandardEnumeratorTest0.java\npackage de.paragon.explorer.util;\n\nimport java.util.NoSuchElementException;\nimport java.util.Vector;\nimport de.paragon.explorer.figure.Figure;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StandardEnumerator}.\n* It contains ten unit test cases for the {@link StandardEnumerator#hasMoreElements()} method.\n*/\nclass StandardEnumeratorTest0 {"
	},
	{
		"original_code": "// StandardEnumerator.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.util;\r\n\r\nimport java.util.NoSuchElementException;\r\nimport java.util.Vector;\r\nimport de.paragon.explorer.figure.Figure;\r\n\r\npublic class StandardEnumerator implements StandardEnumeration {\r\n\r\n    private static final String NO_SUCH_ELEMENT_EXCEPTION = \"standardenumerator.no_such_element_exception\";\r\n\r\n    private Vector<Object> vector;\r\n\r\n    private int count = 0;\r\n\r\n    public StandardEnumerator() {\r\n        this(new Vector<Object>());\r\n    }\r\n\r\n    public StandardEnumerator(Vector<?> newVector) {\r\n        super();\r\n        this.setVector(newVector);\r\n    }\r\n\r\n    public void addElement(Object object) {\r\n        if (this.getCount() == 0) {\r\n            this.getVector().addElement(object);\r\n        }\r\n    }\r\n\r\n    public int getCount() {\r\n        return this.count;\r\n    }\r\n\r\n    public Vector<Object> getVector() {\r\n        return this.vector;\r\n    }\r\n\r\n    public boolean hasMoreElements() {\r\n        if (this.getCount() < this.getVector().size()) {\r\n            return true;\r\n        }\r\n        this.setCount(0);\r\n        return false;\r\n    }\r\n\r\n    public void insertElementAt(Object obj, int index) {\r\n        this.getVector().insertElementAt(obj, index);\r\n    }\r\n\r\n    public boolean isInEnumeration(Object object) {\r\n        return this.getVector().contains(object);\r\n    }\r\n\r\n    public Object nextElement() {\r\n        synchronized (this.getVector()) {\r\n            if (this.getCount() < this.getVector().size()) {\r\n                this.setCount(this.getCount() + 1);\r\n                return this.getVector().elementAt(this.getCount() - 1);\r\n            }\r\n        }\r\n        throw new NoSuchElementException(ResourceBundlePurchaser.getMessage(StandardEnumerator.NO_SUCH_ELEMENT_EXCEPTION));\r\n    }\r\n\r\n    public Figure nextFigure() {\r\n        synchronized (this.getVector()) {\r\n            if (this.getCount() < this.getVector().size()) {\r\n                this.setCount(this.getCount() + 1);\r\n                return (Figure) this.getVector().elementAt(this.getCount() - 1);\r\n            }\r\n        }\r\n        throw new NoSuchElementException(ResourceBundlePurchaser.getMessage(StandardEnumerator.NO_SUCH_ELEMENT_EXCEPTION));\r\n    }\r\n\r\n    public void removeElement(Object object) {\r\n        if (this.getCount() == 0) {\r\n            this.getVector().removeElement(object);\r\n        }\r\n    }\r\n\r\n    public void setCount(int i) {\r\n        this.count = i;\r\n    }\r\n\r\n    public void setVector(Vector<?> newVector) {\r\n        Vector<Object> vector2return = new Vector<Object>();\r\n        for (Object object : newVector) {\r\n            vector2return.add(object);\r\n        }\r\n        this.vector = vector2return;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/util/StandardEnumeratorTest1.java",
		"test_prompt": "// StandardEnumeratorTest1.java\npackage de.paragon.explorer.util;\n\nimport java.util.NoSuchElementException;\nimport java.util.Vector;\nimport de.paragon.explorer.figure.Figure;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StandardEnumerator}.\n* It contains ten unit test cases for the {@link StandardEnumerator#isInEnumeration(Object)} method.\n*/\nclass StandardEnumeratorTest1 {"
	},
	{
		"original_code": "// StandardEnumerator.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.util;\r\n\r\nimport java.util.NoSuchElementException;\r\nimport java.util.Vector;\r\nimport de.paragon.explorer.figure.Figure;\r\n\r\npublic class StandardEnumerator implements StandardEnumeration {\r\n\r\n    private static final String NO_SUCH_ELEMENT_EXCEPTION = \"standardenumerator.no_such_element_exception\";\r\n\r\n    private Vector<Object> vector;\r\n\r\n    private int count = 0;\r\n\r\n    public StandardEnumerator() {\r\n        this(new Vector<Object>());\r\n    }\r\n\r\n    public StandardEnumerator(Vector<?> newVector) {\r\n        super();\r\n        this.setVector(newVector);\r\n    }\r\n\r\n    public void addElement(Object object) {\r\n        if (this.getCount() == 0) {\r\n            this.getVector().addElement(object);\r\n        }\r\n    }\r\n\r\n    public int getCount() {\r\n        return this.count;\r\n    }\r\n\r\n    public Vector<Object> getVector() {\r\n        return this.vector;\r\n    }\r\n\r\n    public boolean hasMoreElements() {\r\n        if (this.getCount() < this.getVector().size()) {\r\n            return true;\r\n        }\r\n        this.setCount(0);\r\n        return false;\r\n    }\r\n\r\n    public void insertElementAt(Object obj, int index) {\r\n        this.getVector().insertElementAt(obj, index);\r\n    }\r\n\r\n    public boolean isInEnumeration(Object object) {\r\n        return this.getVector().contains(object);\r\n    }\r\n\r\n    public Object nextElement() {\r\n        synchronized (this.getVector()) {\r\n            if (this.getCount() < this.getVector().size()) {\r\n                this.setCount(this.getCount() + 1);\r\n                return this.getVector().elementAt(this.getCount() - 1);\r\n            }\r\n        }\r\n        throw new NoSuchElementException(ResourceBundlePurchaser.getMessage(StandardEnumerator.NO_SUCH_ELEMENT_EXCEPTION));\r\n    }\r\n\r\n    public Figure nextFigure() {\r\n        synchronized (this.getVector()) {\r\n            if (this.getCount() < this.getVector().size()) {\r\n                this.setCount(this.getCount() + 1);\r\n                return (Figure) this.getVector().elementAt(this.getCount() - 1);\r\n            }\r\n        }\r\n        throw new NoSuchElementException(ResourceBundlePurchaser.getMessage(StandardEnumerator.NO_SUCH_ELEMENT_EXCEPTION));\r\n    }\r\n\r\n    public void removeElement(Object object) {\r\n        if (this.getCount() == 0) {\r\n            this.getVector().removeElement(object);\r\n        }\r\n    }\r\n\r\n    public void setCount(int i) {\r\n        this.count = i;\r\n    }\r\n\r\n    public void setVector(Vector<?> newVector) {\r\n        Vector<Object> vector2return = new Vector<Object>();\r\n        for (Object object : newVector) {\r\n            vector2return.add(object);\r\n        }\r\n        this.vector = vector2return;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/util/StandardEnumeratorTest2.java",
		"test_prompt": "// StandardEnumeratorTest2.java\npackage de.paragon.explorer.util;\n\nimport java.util.NoSuchElementException;\nimport java.util.Vector;\nimport de.paragon.explorer.figure.Figure;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StandardEnumerator}.\n* It contains ten unit test cases for the {@link StandardEnumerator#nextElement()} method.\n*/\nclass StandardEnumeratorTest2 {"
	},
	{
		"original_code": "// StandardEnumerator.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.util;\r\n\r\nimport java.util.NoSuchElementException;\r\nimport java.util.Vector;\r\nimport de.paragon.explorer.figure.Figure;\r\n\r\npublic class StandardEnumerator implements StandardEnumeration {\r\n\r\n    private static final String NO_SUCH_ELEMENT_EXCEPTION = \"standardenumerator.no_such_element_exception\";\r\n\r\n    private Vector<Object> vector;\r\n\r\n    private int count = 0;\r\n\r\n    public StandardEnumerator() {\r\n        this(new Vector<Object>());\r\n    }\r\n\r\n    public StandardEnumerator(Vector<?> newVector) {\r\n        super();\r\n        this.setVector(newVector);\r\n    }\r\n\r\n    public void addElement(Object object) {\r\n        if (this.getCount() == 0) {\r\n            this.getVector().addElement(object);\r\n        }\r\n    }\r\n\r\n    public int getCount() {\r\n        return this.count;\r\n    }\r\n\r\n    public Vector<Object> getVector() {\r\n        return this.vector;\r\n    }\r\n\r\n    public boolean hasMoreElements() {\r\n        if (this.getCount() < this.getVector().size()) {\r\n            return true;\r\n        }\r\n        this.setCount(0);\r\n        return false;\r\n    }\r\n\r\n    public void insertElementAt(Object obj, int index) {\r\n        this.getVector().insertElementAt(obj, index);\r\n    }\r\n\r\n    public boolean isInEnumeration(Object object) {\r\n        return this.getVector().contains(object);\r\n    }\r\n\r\n    public Object nextElement() {\r\n        synchronized (this.getVector()) {\r\n            if (this.getCount() < this.getVector().size()) {\r\n                this.setCount(this.getCount() + 1);\r\n                return this.getVector().elementAt(this.getCount() - 1);\r\n            }\r\n        }\r\n        throw new NoSuchElementException(ResourceBundlePurchaser.getMessage(StandardEnumerator.NO_SUCH_ELEMENT_EXCEPTION));\r\n    }\r\n\r\n    public Figure nextFigure() {\r\n        synchronized (this.getVector()) {\r\n            if (this.getCount() < this.getVector().size()) {\r\n                this.setCount(this.getCount() + 1);\r\n                return (Figure) this.getVector().elementAt(this.getCount() - 1);\r\n            }\r\n        }\r\n        throw new NoSuchElementException(ResourceBundlePurchaser.getMessage(StandardEnumerator.NO_SUCH_ELEMENT_EXCEPTION));\r\n    }\r\n\r\n    public void removeElement(Object object) {\r\n        if (this.getCount() == 0) {\r\n            this.getVector().removeElement(object);\r\n        }\r\n    }\r\n\r\n    public void setCount(int i) {\r\n        this.count = i;\r\n    }\r\n\r\n    public void setVector(Vector<?> newVector) {\r\n        Vector<Object> vector2return = new Vector<Object>();\r\n        for (Object object : newVector) {\r\n            vector2return.add(object);\r\n        }\r\n        this.vector = vector2return;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/util/StandardEnumeratorTest3.java",
		"test_prompt": "// StandardEnumeratorTest3.java\npackage de.paragon.explorer.util;\n\nimport java.util.NoSuchElementException;\nimport java.util.Vector;\nimport de.paragon.explorer.figure.Figure;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StandardEnumerator}.\n* It contains ten unit test cases for the {@link StandardEnumerator#nextFigure()} method.\n*/\nclass StandardEnumeratorTest3 {"
	},
	{
		"original_code": "// Explorer.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer;\r\n\r\nimport javax.swing.JPanel;\r\nimport javax.swing.UIManager;\r\nimport org.apache.log4j.Logger;\r\nimport de.paragon.explorer.event.ExplorerFrameEventConverter;\r\nimport de.paragon.explorer.figure.ExplorerFigure;\r\nimport de.paragon.explorer.gui.ExplorerDrawingPanel;\r\nimport de.paragon.explorer.model.ExplorerModelBuilder;\r\nimport de.paragon.explorer.util.LoggerFactory;\r\nimport de.paragon.explorer.util.ResourceBundlePurchaser;\r\n\r\n/**\r\n * Kommentar: Die Klasse explorer ist ein reines Hilfskonstrukt zur Eroeffnung\r\n * des Explorers. Sie ruft den ExplorerModelBuilder auf, das erste Model zu\r\n * Bauen. Da im Verlauf des Bauens die TextBoxFiguren gebaut werden muessen,\r\n * wird nach den FontMetrics gefragt (TextBoxFigureBuilder::getFontMetrics()).\r\n * Diese FontMetrics werden von einem neu zu erzeugenden Frame erfragt (In der\r\n * Methode ExplorerFigure::getFrame() gibt es eine entsprechende\r\n * lazy-initialisation.). Dieses Frame wird von dieser Klasse hier in einer\r\n * Klassenmethode nach einem Frame gefragt, um die Zusammensetzung der\r\n * Komponenten an zentraler Stelle zu halten. Nach dem Bauen erzeugt die\r\n * ExplorerFigure einen neuen ExplorerEventConverter. Dieser traegt sich als\r\n * MouseEvent-Listener und als ActionEventListener ein. Weiter merkt er sich die\r\n * ExplorerFigure. Der EventConverter wird von dieser Klasse hier abgefragt. Es\r\n * wird also so sein, dass das Frame niemanden \"kennt\", der EventConverter kennt\r\n * die ExplorerFigure, und diese kennt das Frame.\r\n *\r\n * @author Christian Lange, Carsten Heins\r\n * @since JDK 1.1.6\r\n * @version 1.0\r\n */\r\npublic class Explorer {\r\n\r\n    private static final String APPLICATION_USE_SYSTEM_FONT_SETTINGS = \"Application.useSystemFontSettings\";\r\n\r\n    private static final String EXPLORER_ERROR_STARTING_OBJECT_EXPLORER = \"explorer.error_starting_object_explorer\";\r\n\r\n    private static final String EXPLORER_ERROR_NO_LOOK_AN_FEEL_FOUND = \"explorer.error_no_look_an_feel_found\";\r\n\r\n    // f�r jdk kleiner 1.6.10:\r\n    private static final String COM_SUN_JAVA_SWING_PLAF_WINDOWS_WINDOWS_LOOK_AND_FEEL = \"com.sun.java.swing.plaf.windows.WindowsLookAndFeel\";\r\n\r\n    // f�r jdk ab 1.6.10:\r\n    private static final String COM_SUN_JAVA_SWING_PLAF_NIMBUS_NIMBUS_LOOK_AND_FEEL = \"com.sun.java.swing.plaf.nimbus.NimbusLookAndFeel\";\r\n\r\n    private static final Logger logger = LoggerFactory.make();\r\n\r\n    private static boolean embedded = false;\r\n\r\n    public static boolean isEmbedded() {\r\n        return Explorer.embedded;\r\n    }\r\n\r\n    public static void setEmbedded(boolean embedded) {\r\n        Explorer.embedded = embedded;\r\n    }\r\n\r\n    public static void explore(Object object) {\r\n        ExplorerModelBuilder.getInstance().add1stModel(object);\r\n    }\r\n\r\n    public ExplorerDrawingPanel explore(Object object, boolean embedded) {\r\n        Explorer.setEmbedded(embedded);\r\n        return ExplorerModelBuilder.getInstance().add1stModel(object);\r\n    }\r\n\r\n    public static ExplorerFrameEventConverter getEventConverter(ExplorerFigure explFig) {\r\n        return new ExplorerFrameEventConverter(explFig);\r\n    }\r\n\r\n    public static ExplorerDrawingPanel getPanel() {\r\n        ExplorerDrawingPanel panel = new ExplorerDrawingPanel();\r\n        return panel;\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        try {\r\n            UIManager.put(Explorer.APPLICATION_USE_SYSTEM_FONT_SETTINGS, Boolean.valueOf(false));\r\n            UIManager.setLookAndFeel(Explorer.COM_SUN_JAVA_SWING_PLAF_NIMBUS_NIMBUS_LOOK_AND_FEEL);\r\n        } catch (Throwable ex) {\r\n            try {\r\n                UIManager.setLookAndFeel(Explorer.COM_SUN_JAVA_SWING_PLAF_WINDOWS_WINDOWS_LOOK_AND_FEEL);\r\n            } catch (Throwable ex1) {\r\n                Explorer.logger.error(ResourceBundlePurchaser.getSubstitutedMessage(Explorer.EXPLORER_ERROR_NO_LOOK_AN_FEEL_FOUND, Explorer.COM_SUN_JAVA_SWING_PLAF_WINDOWS_WINDOWS_LOOK_AND_FEEL));\r\n            }\r\n        }\r\n        new Explorer(new JPanel());\r\n    }\r\n\r\n    public Explorer(Object object) {\r\n        try {\r\n            ExplorerModelBuilder.getInstance().add1stModel(object);\r\n        } catch (Exception ex) {\r\n            Explorer.logger.error(ResourceBundlePurchaser.getMessage(Explorer.EXPLORER_ERROR_STARTING_OBJECT_EXPLORER), ex);\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/ExplorerTest0.java",
		"test_prompt": "// ExplorerTest0.java\npackage de.paragon.explorer;\n\nimport javax.swing.JPanel;\nimport javax.swing.UIManager;\nimport org.apache.log4j.Logger;\nimport de.paragon.explorer.event.ExplorerFrameEventConverter;\nimport de.paragon.explorer.figure.ExplorerFigure;\nimport de.paragon.explorer.gui.ExplorerDrawingPanel;\nimport de.paragon.explorer.model.ExplorerModelBuilder;\nimport de.paragon.explorer.util.LoggerFactory;\nimport de.paragon.explorer.util.ResourceBundlePurchaser;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Explorer}.\n* It contains ten unit test cases for the {@link Explorer#isEmbedded()} method.\n*/\nclass ExplorerTest0 {"
	},
	{
		"original_code": "// Explorer.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer;\r\n\r\nimport javax.swing.JPanel;\r\nimport javax.swing.UIManager;\r\nimport org.apache.log4j.Logger;\r\nimport de.paragon.explorer.event.ExplorerFrameEventConverter;\r\nimport de.paragon.explorer.figure.ExplorerFigure;\r\nimport de.paragon.explorer.gui.ExplorerDrawingPanel;\r\nimport de.paragon.explorer.model.ExplorerModelBuilder;\r\nimport de.paragon.explorer.util.LoggerFactory;\r\nimport de.paragon.explorer.util.ResourceBundlePurchaser;\r\n\r\n/**\r\n * Kommentar: Die Klasse explorer ist ein reines Hilfskonstrukt zur Eroeffnung\r\n * des Explorers. Sie ruft den ExplorerModelBuilder auf, das erste Model zu\r\n * Bauen. Da im Verlauf des Bauens die TextBoxFiguren gebaut werden muessen,\r\n * wird nach den FontMetrics gefragt (TextBoxFigureBuilder::getFontMetrics()).\r\n * Diese FontMetrics werden von einem neu zu erzeugenden Frame erfragt (In der\r\n * Methode ExplorerFigure::getFrame() gibt es eine entsprechende\r\n * lazy-initialisation.). Dieses Frame wird von dieser Klasse hier in einer\r\n * Klassenmethode nach einem Frame gefragt, um die Zusammensetzung der\r\n * Komponenten an zentraler Stelle zu halten. Nach dem Bauen erzeugt die\r\n * ExplorerFigure einen neuen ExplorerEventConverter. Dieser traegt sich als\r\n * MouseEvent-Listener und als ActionEventListener ein. Weiter merkt er sich die\r\n * ExplorerFigure. Der EventConverter wird von dieser Klasse hier abgefragt. Es\r\n * wird also so sein, dass das Frame niemanden \"kennt\", der EventConverter kennt\r\n * die ExplorerFigure, und diese kennt das Frame.\r\n *\r\n * @author Christian Lange, Carsten Heins\r\n * @since JDK 1.1.6\r\n * @version 1.0\r\n */\r\npublic class Explorer {\r\n\r\n    private static final String APPLICATION_USE_SYSTEM_FONT_SETTINGS = \"Application.useSystemFontSettings\";\r\n\r\n    private static final String EXPLORER_ERROR_STARTING_OBJECT_EXPLORER = \"explorer.error_starting_object_explorer\";\r\n\r\n    private static final String EXPLORER_ERROR_NO_LOOK_AN_FEEL_FOUND = \"explorer.error_no_look_an_feel_found\";\r\n\r\n    // f�r jdk kleiner 1.6.10:\r\n    private static final String COM_SUN_JAVA_SWING_PLAF_WINDOWS_WINDOWS_LOOK_AND_FEEL = \"com.sun.java.swing.plaf.windows.WindowsLookAndFeel\";\r\n\r\n    // f�r jdk ab 1.6.10:\r\n    private static final String COM_SUN_JAVA_SWING_PLAF_NIMBUS_NIMBUS_LOOK_AND_FEEL = \"com.sun.java.swing.plaf.nimbus.NimbusLookAndFeel\";\r\n\r\n    private static final Logger logger = LoggerFactory.make();\r\n\r\n    private static boolean embedded = false;\r\n\r\n    public static boolean isEmbedded() {\r\n        return Explorer.embedded;\r\n    }\r\n\r\n    public static void setEmbedded(boolean embedded) {\r\n        Explorer.embedded = embedded;\r\n    }\r\n\r\n    public static void explore(Object object) {\r\n        ExplorerModelBuilder.getInstance().add1stModel(object);\r\n    }\r\n\r\n    public ExplorerDrawingPanel explore(Object object, boolean embedded) {\r\n        Explorer.setEmbedded(embedded);\r\n        return ExplorerModelBuilder.getInstance().add1stModel(object);\r\n    }\r\n\r\n    public static ExplorerFrameEventConverter getEventConverter(ExplorerFigure explFig) {\r\n        return new ExplorerFrameEventConverter(explFig);\r\n    }\r\n\r\n    public static ExplorerDrawingPanel getPanel() {\r\n        ExplorerDrawingPanel panel = new ExplorerDrawingPanel();\r\n        return panel;\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        try {\r\n            UIManager.put(Explorer.APPLICATION_USE_SYSTEM_FONT_SETTINGS, Boolean.valueOf(false));\r\n            UIManager.setLookAndFeel(Explorer.COM_SUN_JAVA_SWING_PLAF_NIMBUS_NIMBUS_LOOK_AND_FEEL);\r\n        } catch (Throwable ex) {\r\n            try {\r\n                UIManager.setLookAndFeel(Explorer.COM_SUN_JAVA_SWING_PLAF_WINDOWS_WINDOWS_LOOK_AND_FEEL);\r\n            } catch (Throwable ex1) {\r\n                Explorer.logger.error(ResourceBundlePurchaser.getSubstitutedMessage(Explorer.EXPLORER_ERROR_NO_LOOK_AN_FEEL_FOUND, Explorer.COM_SUN_JAVA_SWING_PLAF_WINDOWS_WINDOWS_LOOK_AND_FEEL));\r\n            }\r\n        }\r\n        new Explorer(new JPanel());\r\n    }\r\n\r\n    public Explorer(Object object) {\r\n        try {\r\n            ExplorerModelBuilder.getInstance().add1stModel(object);\r\n        } catch (Exception ex) {\r\n            Explorer.logger.error(ResourceBundlePurchaser.getMessage(Explorer.EXPLORER_ERROR_STARTING_OBJECT_EXPLORER), ex);\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/ExplorerTest1.java",
		"test_prompt": "// ExplorerTest1.java\npackage de.paragon.explorer;\n\nimport javax.swing.JPanel;\nimport javax.swing.UIManager;\nimport org.apache.log4j.Logger;\nimport de.paragon.explorer.event.ExplorerFrameEventConverter;\nimport de.paragon.explorer.figure.ExplorerFigure;\nimport de.paragon.explorer.gui.ExplorerDrawingPanel;\nimport de.paragon.explorer.model.ExplorerModelBuilder;\nimport de.paragon.explorer.util.LoggerFactory;\nimport de.paragon.explorer.util.ResourceBundlePurchaser;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Explorer}.\n* It contains ten unit test cases for the {@link Explorer#explore(Object, boolean)} method.\n*/\nclass ExplorerTest1 {"
	},
	{
		"original_code": "// Explorer.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer;\r\n\r\nimport javax.swing.JPanel;\r\nimport javax.swing.UIManager;\r\nimport org.apache.log4j.Logger;\r\nimport de.paragon.explorer.event.ExplorerFrameEventConverter;\r\nimport de.paragon.explorer.figure.ExplorerFigure;\r\nimport de.paragon.explorer.gui.ExplorerDrawingPanel;\r\nimport de.paragon.explorer.model.ExplorerModelBuilder;\r\nimport de.paragon.explorer.util.LoggerFactory;\r\nimport de.paragon.explorer.util.ResourceBundlePurchaser;\r\n\r\n/**\r\n * Kommentar: Die Klasse explorer ist ein reines Hilfskonstrukt zur Eroeffnung\r\n * des Explorers. Sie ruft den ExplorerModelBuilder auf, das erste Model zu\r\n * Bauen. Da im Verlauf des Bauens die TextBoxFiguren gebaut werden muessen,\r\n * wird nach den FontMetrics gefragt (TextBoxFigureBuilder::getFontMetrics()).\r\n * Diese FontMetrics werden von einem neu zu erzeugenden Frame erfragt (In der\r\n * Methode ExplorerFigure::getFrame() gibt es eine entsprechende\r\n * lazy-initialisation.). Dieses Frame wird von dieser Klasse hier in einer\r\n * Klassenmethode nach einem Frame gefragt, um die Zusammensetzung der\r\n * Komponenten an zentraler Stelle zu halten. Nach dem Bauen erzeugt die\r\n * ExplorerFigure einen neuen ExplorerEventConverter. Dieser traegt sich als\r\n * MouseEvent-Listener und als ActionEventListener ein. Weiter merkt er sich die\r\n * ExplorerFigure. Der EventConverter wird von dieser Klasse hier abgefragt. Es\r\n * wird also so sein, dass das Frame niemanden \"kennt\", der EventConverter kennt\r\n * die ExplorerFigure, und diese kennt das Frame.\r\n *\r\n * @author Christian Lange, Carsten Heins\r\n * @since JDK 1.1.6\r\n * @version 1.0\r\n */\r\npublic class Explorer {\r\n\r\n    private static final String APPLICATION_USE_SYSTEM_FONT_SETTINGS = \"Application.useSystemFontSettings\";\r\n\r\n    private static final String EXPLORER_ERROR_STARTING_OBJECT_EXPLORER = \"explorer.error_starting_object_explorer\";\r\n\r\n    private static final String EXPLORER_ERROR_NO_LOOK_AN_FEEL_FOUND = \"explorer.error_no_look_an_feel_found\";\r\n\r\n    // f�r jdk kleiner 1.6.10:\r\n    private static final String COM_SUN_JAVA_SWING_PLAF_WINDOWS_WINDOWS_LOOK_AND_FEEL = \"com.sun.java.swing.plaf.windows.WindowsLookAndFeel\";\r\n\r\n    // f�r jdk ab 1.6.10:\r\n    private static final String COM_SUN_JAVA_SWING_PLAF_NIMBUS_NIMBUS_LOOK_AND_FEEL = \"com.sun.java.swing.plaf.nimbus.NimbusLookAndFeel\";\r\n\r\n    private static final Logger logger = LoggerFactory.make();\r\n\r\n    private static boolean embedded = false;\r\n\r\n    public static boolean isEmbedded() {\r\n        return Explorer.embedded;\r\n    }\r\n\r\n    public static void setEmbedded(boolean embedded) {\r\n        Explorer.embedded = embedded;\r\n    }\r\n\r\n    public static void explore(Object object) {\r\n        ExplorerModelBuilder.getInstance().add1stModel(object);\r\n    }\r\n\r\n    public ExplorerDrawingPanel explore(Object object, boolean embedded) {\r\n        Explorer.setEmbedded(embedded);\r\n        return ExplorerModelBuilder.getInstance().add1stModel(object);\r\n    }\r\n\r\n    public static ExplorerFrameEventConverter getEventConverter(ExplorerFigure explFig) {\r\n        return new ExplorerFrameEventConverter(explFig);\r\n    }\r\n\r\n    public static ExplorerDrawingPanel getPanel() {\r\n        ExplorerDrawingPanel panel = new ExplorerDrawingPanel();\r\n        return panel;\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        try {\r\n            UIManager.put(Explorer.APPLICATION_USE_SYSTEM_FONT_SETTINGS, Boolean.valueOf(false));\r\n            UIManager.setLookAndFeel(Explorer.COM_SUN_JAVA_SWING_PLAF_NIMBUS_NIMBUS_LOOK_AND_FEEL);\r\n        } catch (Throwable ex) {\r\n            try {\r\n                UIManager.setLookAndFeel(Explorer.COM_SUN_JAVA_SWING_PLAF_WINDOWS_WINDOWS_LOOK_AND_FEEL);\r\n            } catch (Throwable ex1) {\r\n                Explorer.logger.error(ResourceBundlePurchaser.getSubstitutedMessage(Explorer.EXPLORER_ERROR_NO_LOOK_AN_FEEL_FOUND, Explorer.COM_SUN_JAVA_SWING_PLAF_WINDOWS_WINDOWS_LOOK_AND_FEEL));\r\n            }\r\n        }\r\n        new Explorer(new JPanel());\r\n    }\r\n\r\n    public Explorer(Object object) {\r\n        try {\r\n            ExplorerModelBuilder.getInstance().add1stModel(object);\r\n        } catch (Exception ex) {\r\n            Explorer.logger.error(ResourceBundlePurchaser.getMessage(Explorer.EXPLORER_ERROR_STARTING_OBJECT_EXPLORER), ex);\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/ExplorerTest2.java",
		"test_prompt": "// ExplorerTest2.java\npackage de.paragon.explorer;\n\nimport javax.swing.JPanel;\nimport javax.swing.UIManager;\nimport org.apache.log4j.Logger;\nimport de.paragon.explorer.event.ExplorerFrameEventConverter;\nimport de.paragon.explorer.figure.ExplorerFigure;\nimport de.paragon.explorer.gui.ExplorerDrawingPanel;\nimport de.paragon.explorer.model.ExplorerModelBuilder;\nimport de.paragon.explorer.util.LoggerFactory;\nimport de.paragon.explorer.util.ResourceBundlePurchaser;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Explorer}.\n* It contains ten unit test cases for the {@link Explorer#getEventConverter(ExplorerFigure)} method.\n*/\nclass ExplorerTest2 {"
	},
	{
		"original_code": "// Explorer.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer;\r\n\r\nimport javax.swing.JPanel;\r\nimport javax.swing.UIManager;\r\nimport org.apache.log4j.Logger;\r\nimport de.paragon.explorer.event.ExplorerFrameEventConverter;\r\nimport de.paragon.explorer.figure.ExplorerFigure;\r\nimport de.paragon.explorer.gui.ExplorerDrawingPanel;\r\nimport de.paragon.explorer.model.ExplorerModelBuilder;\r\nimport de.paragon.explorer.util.LoggerFactory;\r\nimport de.paragon.explorer.util.ResourceBundlePurchaser;\r\n\r\n/**\r\n * Kommentar: Die Klasse explorer ist ein reines Hilfskonstrukt zur Eroeffnung\r\n * des Explorers. Sie ruft den ExplorerModelBuilder auf, das erste Model zu\r\n * Bauen. Da im Verlauf des Bauens die TextBoxFiguren gebaut werden muessen,\r\n * wird nach den FontMetrics gefragt (TextBoxFigureBuilder::getFontMetrics()).\r\n * Diese FontMetrics werden von einem neu zu erzeugenden Frame erfragt (In der\r\n * Methode ExplorerFigure::getFrame() gibt es eine entsprechende\r\n * lazy-initialisation.). Dieses Frame wird von dieser Klasse hier in einer\r\n * Klassenmethode nach einem Frame gefragt, um die Zusammensetzung der\r\n * Komponenten an zentraler Stelle zu halten. Nach dem Bauen erzeugt die\r\n * ExplorerFigure einen neuen ExplorerEventConverter. Dieser traegt sich als\r\n * MouseEvent-Listener und als ActionEventListener ein. Weiter merkt er sich die\r\n * ExplorerFigure. Der EventConverter wird von dieser Klasse hier abgefragt. Es\r\n * wird also so sein, dass das Frame niemanden \"kennt\", der EventConverter kennt\r\n * die ExplorerFigure, und diese kennt das Frame.\r\n *\r\n * @author Christian Lange, Carsten Heins\r\n * @since JDK 1.1.6\r\n * @version 1.0\r\n */\r\npublic class Explorer {\r\n\r\n    private static final String APPLICATION_USE_SYSTEM_FONT_SETTINGS = \"Application.useSystemFontSettings\";\r\n\r\n    private static final String EXPLORER_ERROR_STARTING_OBJECT_EXPLORER = \"explorer.error_starting_object_explorer\";\r\n\r\n    private static final String EXPLORER_ERROR_NO_LOOK_AN_FEEL_FOUND = \"explorer.error_no_look_an_feel_found\";\r\n\r\n    // f�r jdk kleiner 1.6.10:\r\n    private static final String COM_SUN_JAVA_SWING_PLAF_WINDOWS_WINDOWS_LOOK_AND_FEEL = \"com.sun.java.swing.plaf.windows.WindowsLookAndFeel\";\r\n\r\n    // f�r jdk ab 1.6.10:\r\n    private static final String COM_SUN_JAVA_SWING_PLAF_NIMBUS_NIMBUS_LOOK_AND_FEEL = \"com.sun.java.swing.plaf.nimbus.NimbusLookAndFeel\";\r\n\r\n    private static final Logger logger = LoggerFactory.make();\r\n\r\n    private static boolean embedded = false;\r\n\r\n    public static boolean isEmbedded() {\r\n        return Explorer.embedded;\r\n    }\r\n\r\n    public static void setEmbedded(boolean embedded) {\r\n        Explorer.embedded = embedded;\r\n    }\r\n\r\n    public static void explore(Object object) {\r\n        ExplorerModelBuilder.getInstance().add1stModel(object);\r\n    }\r\n\r\n    public ExplorerDrawingPanel explore(Object object, boolean embedded) {\r\n        Explorer.setEmbedded(embedded);\r\n        return ExplorerModelBuilder.getInstance().add1stModel(object);\r\n    }\r\n\r\n    public static ExplorerFrameEventConverter getEventConverter(ExplorerFigure explFig) {\r\n        return new ExplorerFrameEventConverter(explFig);\r\n    }\r\n\r\n    public static ExplorerDrawingPanel getPanel() {\r\n        ExplorerDrawingPanel panel = new ExplorerDrawingPanel();\r\n        return panel;\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        try {\r\n            UIManager.put(Explorer.APPLICATION_USE_SYSTEM_FONT_SETTINGS, Boolean.valueOf(false));\r\n            UIManager.setLookAndFeel(Explorer.COM_SUN_JAVA_SWING_PLAF_NIMBUS_NIMBUS_LOOK_AND_FEEL);\r\n        } catch (Throwable ex) {\r\n            try {\r\n                UIManager.setLookAndFeel(Explorer.COM_SUN_JAVA_SWING_PLAF_WINDOWS_WINDOWS_LOOK_AND_FEEL);\r\n            } catch (Throwable ex1) {\r\n                Explorer.logger.error(ResourceBundlePurchaser.getSubstitutedMessage(Explorer.EXPLORER_ERROR_NO_LOOK_AN_FEEL_FOUND, Explorer.COM_SUN_JAVA_SWING_PLAF_WINDOWS_WINDOWS_LOOK_AND_FEEL));\r\n            }\r\n        }\r\n        new Explorer(new JPanel());\r\n    }\r\n\r\n    public Explorer(Object object) {\r\n        try {\r\n            ExplorerModelBuilder.getInstance().add1stModel(object);\r\n        } catch (Exception ex) {\r\n            Explorer.logger.error(ResourceBundlePurchaser.getMessage(Explorer.EXPLORER_ERROR_STARTING_OBJECT_EXPLORER), ex);\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/ExplorerTest3.java",
		"test_prompt": "// ExplorerTest3.java\npackage de.paragon.explorer;\n\nimport javax.swing.JPanel;\nimport javax.swing.UIManager;\nimport org.apache.log4j.Logger;\nimport de.paragon.explorer.event.ExplorerFrameEventConverter;\nimport de.paragon.explorer.figure.ExplorerFigure;\nimport de.paragon.explorer.gui.ExplorerDrawingPanel;\nimport de.paragon.explorer.model.ExplorerModelBuilder;\nimport de.paragon.explorer.util.LoggerFactory;\nimport de.paragon.explorer.util.ResourceBundlePurchaser;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Explorer}.\n* It contains ten unit test cases for the {@link Explorer#getPanel()} method.\n*/\nclass ExplorerTest3 {"
	},
	{
		"original_code": "// ProjectConstants4ObjectExplorer.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer;\r\n\r\n/**\r\n * Projektkonstanten f�r den ObjectExplorer\r\n *\r\n * @author Stefan Jockenh�vel\r\n */\r\npublic final class ProjectConstants4ObjectExplorer {\r\n\r\n    private static final String ABOUT = \"About\";\r\n\r\n    private static final String COPY_OBJECT = \"Copy Object\";\r\n\r\n    private static final String EXPLORE_OBJECT = \"Explore Object\";\r\n\r\n    private static final String HIDE_ATTRIBUTE = \"Hide Attribute\";\r\n\r\n    private static final String HIDE_NULL_ATTRIBUTES = \"Hide \" + \"\\\"\" + \"null\" + \"\\\"\" + \" Attributes\";\r\n\r\n    private static final String HIDE_OBJECT = \"Hide Object\";\r\n\r\n    private static final String HIDE_OBJECT_WITH_DEPENDENCIES = \"Hide Object with Dependencies\";\r\n\r\n    private static final String HIDE_REFERENCE = \"Hide Reference\";\r\n\r\n    private static final String HIDE_STATIC_ATTRIBUTES = \"Hide \" + \"\\\"\" + \"static\" + \"\\\"\" + \" Attributes\";\r\n\r\n    private static final String HIDE_UNEXPLORED_ATTRIBUTES = \"Hide Unexplored Attributes\";\r\n\r\n    private static final String OBJECT_VIEW = \"Object View\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_ADD = \"Add\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_CLOSE = \"Close\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_EXPLORE = \"Explore\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_GO_TO = \"Go To\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_REMOVE = \"Remove\";\r\n\r\n    private static final String REMOVE_REFERENCES_WHEN_REMOVED = \"Remove Reference When Removed\";\r\n\r\n    private static final String SAVE = \"Save\";\r\n\r\n    private static final String SHOW_ATTRIBUTES = \"Show Attributes\";\r\n\r\n    private static final String SHOW_REFERENCE = \"Show Reference\";\r\n\r\n    private static final String STRING_NULL = \"null\";\r\n\r\n    private static final String UPDATE_ATTRIBUTES = \"Update Attributes\";\r\n\r\n    private static final String UPDATE_OBJECT = \"Update Object\";\r\n\r\n    private static final String UPDATE_OBJECTS = \"Update Objects\";\r\n\r\n    public static String getABOUT() {\r\n        return ProjectConstants4ObjectExplorer.ABOUT;\r\n    }\r\n\r\n    public static String getCOPY_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.COPY_OBJECT;\r\n    }\r\n\r\n    public static String getEXPLORE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.EXPLORE_OBJECT;\r\n    }\r\n\r\n    public static String getHIDE_ATTRIBUTE() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_ATTRIBUTE;\r\n    }\r\n\r\n    public static String getHIDE_NULL_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_NULL_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getHIDE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_OBJECT;\r\n    }\r\n\r\n    public static String getHIDE_OBJECT_WITH_DEPENDENCIES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_OBJECT_WITH_DEPENDENCIES;\r\n    }\r\n\r\n    public static String getHIDE_REFERENCE() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_REFERENCE;\r\n    }\r\n\r\n    public static String getHIDE_STATIC_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_STATIC_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getHIDE_UNEXPLORED_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_UNEXPLORED_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_ADD() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_ADD;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_CLOSE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_CLOSE;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_EXPLORE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_EXPLORE;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_GO_TO() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_GO_TO;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_REMOVE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_REMOVE;\r\n    }\r\n\r\n    public static String getREMOVE_REFERENCES_WHEN_REMOVED() {\r\n        return ProjectConstants4ObjectExplorer.REMOVE_REFERENCES_WHEN_REMOVED;\r\n    }\r\n\r\n    public static String getSAVE() {\r\n        return ProjectConstants4ObjectExplorer.SAVE;\r\n    }\r\n\r\n    public static String getSHOW_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.SHOW_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getSHOW_REFERENCE() {\r\n        return ProjectConstants4ObjectExplorer.SHOW_REFERENCE;\r\n    }\r\n\r\n    public static String getSTRING_NULL() {\r\n        return ProjectConstants4ObjectExplorer.STRING_NULL;\r\n    }\r\n\r\n    public static String getUPDATE_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getUPDATE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_OBJECT;\r\n    }\r\n\r\n    public static String getUPDATE_OBJECTS() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_OBJECTS;\r\n    }\r\n\r\n    private ProjectConstants4ObjectExplorer() {\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/ProjectConstants4ObjectExplorerTest0.java",
		"test_prompt": "// ProjectConstants4ObjectExplorerTest0.java\npackage de.paragon.explorer;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProjectConstants4ObjectExplorer}.\n* It contains ten unit test cases for the {@link ProjectConstants4ObjectExplorer#getABOUT()} method.\n*/\nclass ProjectConstants4ObjectExplorerTest0 {"
	},
	{
		"original_code": "// ProjectConstants4ObjectExplorer.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer;\r\n\r\n/**\r\n * Projektkonstanten f�r den ObjectExplorer\r\n *\r\n * @author Stefan Jockenh�vel\r\n */\r\npublic final class ProjectConstants4ObjectExplorer {\r\n\r\n    private static final String ABOUT = \"About\";\r\n\r\n    private static final String COPY_OBJECT = \"Copy Object\";\r\n\r\n    private static final String EXPLORE_OBJECT = \"Explore Object\";\r\n\r\n    private static final String HIDE_ATTRIBUTE = \"Hide Attribute\";\r\n\r\n    private static final String HIDE_NULL_ATTRIBUTES = \"Hide \" + \"\\\"\" + \"null\" + \"\\\"\" + \" Attributes\";\r\n\r\n    private static final String HIDE_OBJECT = \"Hide Object\";\r\n\r\n    private static final String HIDE_OBJECT_WITH_DEPENDENCIES = \"Hide Object with Dependencies\";\r\n\r\n    private static final String HIDE_REFERENCE = \"Hide Reference\";\r\n\r\n    private static final String HIDE_STATIC_ATTRIBUTES = \"Hide \" + \"\\\"\" + \"static\" + \"\\\"\" + \" Attributes\";\r\n\r\n    private static final String HIDE_UNEXPLORED_ATTRIBUTES = \"Hide Unexplored Attributes\";\r\n\r\n    private static final String OBJECT_VIEW = \"Object View\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_ADD = \"Add\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_CLOSE = \"Close\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_EXPLORE = \"Explore\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_GO_TO = \"Go To\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_REMOVE = \"Remove\";\r\n\r\n    private static final String REMOVE_REFERENCES_WHEN_REMOVED = \"Remove Reference When Removed\";\r\n\r\n    private static final String SAVE = \"Save\";\r\n\r\n    private static final String SHOW_ATTRIBUTES = \"Show Attributes\";\r\n\r\n    private static final String SHOW_REFERENCE = \"Show Reference\";\r\n\r\n    private static final String STRING_NULL = \"null\";\r\n\r\n    private static final String UPDATE_ATTRIBUTES = \"Update Attributes\";\r\n\r\n    private static final String UPDATE_OBJECT = \"Update Object\";\r\n\r\n    private static final String UPDATE_OBJECTS = \"Update Objects\";\r\n\r\n    public static String getABOUT() {\r\n        return ProjectConstants4ObjectExplorer.ABOUT;\r\n    }\r\n\r\n    public static String getCOPY_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.COPY_OBJECT;\r\n    }\r\n\r\n    public static String getEXPLORE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.EXPLORE_OBJECT;\r\n    }\r\n\r\n    public static String getHIDE_ATTRIBUTE() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_ATTRIBUTE;\r\n    }\r\n\r\n    public static String getHIDE_NULL_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_NULL_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getHIDE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_OBJECT;\r\n    }\r\n\r\n    public static String getHIDE_OBJECT_WITH_DEPENDENCIES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_OBJECT_WITH_DEPENDENCIES;\r\n    }\r\n\r\n    public static String getHIDE_REFERENCE() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_REFERENCE;\r\n    }\r\n\r\n    public static String getHIDE_STATIC_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_STATIC_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getHIDE_UNEXPLORED_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_UNEXPLORED_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_ADD() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_ADD;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_CLOSE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_CLOSE;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_EXPLORE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_EXPLORE;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_GO_TO() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_GO_TO;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_REMOVE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_REMOVE;\r\n    }\r\n\r\n    public static String getREMOVE_REFERENCES_WHEN_REMOVED() {\r\n        return ProjectConstants4ObjectExplorer.REMOVE_REFERENCES_WHEN_REMOVED;\r\n    }\r\n\r\n    public static String getSAVE() {\r\n        return ProjectConstants4ObjectExplorer.SAVE;\r\n    }\r\n\r\n    public static String getSHOW_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.SHOW_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getSHOW_REFERENCE() {\r\n        return ProjectConstants4ObjectExplorer.SHOW_REFERENCE;\r\n    }\r\n\r\n    public static String getSTRING_NULL() {\r\n        return ProjectConstants4ObjectExplorer.STRING_NULL;\r\n    }\r\n\r\n    public static String getUPDATE_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getUPDATE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_OBJECT;\r\n    }\r\n\r\n    public static String getUPDATE_OBJECTS() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_OBJECTS;\r\n    }\r\n\r\n    private ProjectConstants4ObjectExplorer() {\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/ProjectConstants4ObjectExplorerTest1.java",
		"test_prompt": "// ProjectConstants4ObjectExplorerTest1.java\npackage de.paragon.explorer;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProjectConstants4ObjectExplorer}.\n* It contains ten unit test cases for the {@link ProjectConstants4ObjectExplorer#getCOPY_OBJECT()} method.\n*/\nclass ProjectConstants4ObjectExplorerTest1 {"
	},
	{
		"original_code": "// ProjectConstants4ObjectExplorer.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer;\r\n\r\n/**\r\n * Projektkonstanten f�r den ObjectExplorer\r\n *\r\n * @author Stefan Jockenh�vel\r\n */\r\npublic final class ProjectConstants4ObjectExplorer {\r\n\r\n    private static final String ABOUT = \"About\";\r\n\r\n    private static final String COPY_OBJECT = \"Copy Object\";\r\n\r\n    private static final String EXPLORE_OBJECT = \"Explore Object\";\r\n\r\n    private static final String HIDE_ATTRIBUTE = \"Hide Attribute\";\r\n\r\n    private static final String HIDE_NULL_ATTRIBUTES = \"Hide \" + \"\\\"\" + \"null\" + \"\\\"\" + \" Attributes\";\r\n\r\n    private static final String HIDE_OBJECT = \"Hide Object\";\r\n\r\n    private static final String HIDE_OBJECT_WITH_DEPENDENCIES = \"Hide Object with Dependencies\";\r\n\r\n    private static final String HIDE_REFERENCE = \"Hide Reference\";\r\n\r\n    private static final String HIDE_STATIC_ATTRIBUTES = \"Hide \" + \"\\\"\" + \"static\" + \"\\\"\" + \" Attributes\";\r\n\r\n    private static final String HIDE_UNEXPLORED_ATTRIBUTES = \"Hide Unexplored Attributes\";\r\n\r\n    private static final String OBJECT_VIEW = \"Object View\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_ADD = \"Add\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_CLOSE = \"Close\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_EXPLORE = \"Explore\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_GO_TO = \"Go To\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_REMOVE = \"Remove\";\r\n\r\n    private static final String REMOVE_REFERENCES_WHEN_REMOVED = \"Remove Reference When Removed\";\r\n\r\n    private static final String SAVE = \"Save\";\r\n\r\n    private static final String SHOW_ATTRIBUTES = \"Show Attributes\";\r\n\r\n    private static final String SHOW_REFERENCE = \"Show Reference\";\r\n\r\n    private static final String STRING_NULL = \"null\";\r\n\r\n    private static final String UPDATE_ATTRIBUTES = \"Update Attributes\";\r\n\r\n    private static final String UPDATE_OBJECT = \"Update Object\";\r\n\r\n    private static final String UPDATE_OBJECTS = \"Update Objects\";\r\n\r\n    public static String getABOUT() {\r\n        return ProjectConstants4ObjectExplorer.ABOUT;\r\n    }\r\n\r\n    public static String getCOPY_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.COPY_OBJECT;\r\n    }\r\n\r\n    public static String getEXPLORE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.EXPLORE_OBJECT;\r\n    }\r\n\r\n    public static String getHIDE_ATTRIBUTE() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_ATTRIBUTE;\r\n    }\r\n\r\n    public static String getHIDE_NULL_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_NULL_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getHIDE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_OBJECT;\r\n    }\r\n\r\n    public static String getHIDE_OBJECT_WITH_DEPENDENCIES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_OBJECT_WITH_DEPENDENCIES;\r\n    }\r\n\r\n    public static String getHIDE_REFERENCE() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_REFERENCE;\r\n    }\r\n\r\n    public static String getHIDE_STATIC_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_STATIC_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getHIDE_UNEXPLORED_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_UNEXPLORED_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_ADD() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_ADD;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_CLOSE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_CLOSE;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_EXPLORE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_EXPLORE;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_GO_TO() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_GO_TO;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_REMOVE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_REMOVE;\r\n    }\r\n\r\n    public static String getREMOVE_REFERENCES_WHEN_REMOVED() {\r\n        return ProjectConstants4ObjectExplorer.REMOVE_REFERENCES_WHEN_REMOVED;\r\n    }\r\n\r\n    public static String getSAVE() {\r\n        return ProjectConstants4ObjectExplorer.SAVE;\r\n    }\r\n\r\n    public static String getSHOW_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.SHOW_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getSHOW_REFERENCE() {\r\n        return ProjectConstants4ObjectExplorer.SHOW_REFERENCE;\r\n    }\r\n\r\n    public static String getSTRING_NULL() {\r\n        return ProjectConstants4ObjectExplorer.STRING_NULL;\r\n    }\r\n\r\n    public static String getUPDATE_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getUPDATE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_OBJECT;\r\n    }\r\n\r\n    public static String getUPDATE_OBJECTS() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_OBJECTS;\r\n    }\r\n\r\n    private ProjectConstants4ObjectExplorer() {\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/ProjectConstants4ObjectExplorerTest2.java",
		"test_prompt": "// ProjectConstants4ObjectExplorerTest2.java\npackage de.paragon.explorer;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProjectConstants4ObjectExplorer}.\n* It contains ten unit test cases for the {@link ProjectConstants4ObjectExplorer#getEXPLORE_OBJECT()} method.\n*/\nclass ProjectConstants4ObjectExplorerTest2 {"
	},
	{
		"original_code": "// ProjectConstants4ObjectExplorer.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer;\r\n\r\n/**\r\n * Projektkonstanten f�r den ObjectExplorer\r\n *\r\n * @author Stefan Jockenh�vel\r\n */\r\npublic final class ProjectConstants4ObjectExplorer {\r\n\r\n    private static final String ABOUT = \"About\";\r\n\r\n    private static final String COPY_OBJECT = \"Copy Object\";\r\n\r\n    private static final String EXPLORE_OBJECT = \"Explore Object\";\r\n\r\n    private static final String HIDE_ATTRIBUTE = \"Hide Attribute\";\r\n\r\n    private static final String HIDE_NULL_ATTRIBUTES = \"Hide \" + \"\\\"\" + \"null\" + \"\\\"\" + \" Attributes\";\r\n\r\n    private static final String HIDE_OBJECT = \"Hide Object\";\r\n\r\n    private static final String HIDE_OBJECT_WITH_DEPENDENCIES = \"Hide Object with Dependencies\";\r\n\r\n    private static final String HIDE_REFERENCE = \"Hide Reference\";\r\n\r\n    private static final String HIDE_STATIC_ATTRIBUTES = \"Hide \" + \"\\\"\" + \"static\" + \"\\\"\" + \" Attributes\";\r\n\r\n    private static final String HIDE_UNEXPLORED_ATTRIBUTES = \"Hide Unexplored Attributes\";\r\n\r\n    private static final String OBJECT_VIEW = \"Object View\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_ADD = \"Add\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_CLOSE = \"Close\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_EXPLORE = \"Explore\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_GO_TO = \"Go To\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_REMOVE = \"Remove\";\r\n\r\n    private static final String REMOVE_REFERENCES_WHEN_REMOVED = \"Remove Reference When Removed\";\r\n\r\n    private static final String SAVE = \"Save\";\r\n\r\n    private static final String SHOW_ATTRIBUTES = \"Show Attributes\";\r\n\r\n    private static final String SHOW_REFERENCE = \"Show Reference\";\r\n\r\n    private static final String STRING_NULL = \"null\";\r\n\r\n    private static final String UPDATE_ATTRIBUTES = \"Update Attributes\";\r\n\r\n    private static final String UPDATE_OBJECT = \"Update Object\";\r\n\r\n    private static final String UPDATE_OBJECTS = \"Update Objects\";\r\n\r\n    public static String getABOUT() {\r\n        return ProjectConstants4ObjectExplorer.ABOUT;\r\n    }\r\n\r\n    public static String getCOPY_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.COPY_OBJECT;\r\n    }\r\n\r\n    public static String getEXPLORE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.EXPLORE_OBJECT;\r\n    }\r\n\r\n    public static String getHIDE_ATTRIBUTE() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_ATTRIBUTE;\r\n    }\r\n\r\n    public static String getHIDE_NULL_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_NULL_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getHIDE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_OBJECT;\r\n    }\r\n\r\n    public static String getHIDE_OBJECT_WITH_DEPENDENCIES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_OBJECT_WITH_DEPENDENCIES;\r\n    }\r\n\r\n    public static String getHIDE_REFERENCE() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_REFERENCE;\r\n    }\r\n\r\n    public static String getHIDE_STATIC_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_STATIC_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getHIDE_UNEXPLORED_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_UNEXPLORED_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_ADD() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_ADD;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_CLOSE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_CLOSE;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_EXPLORE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_EXPLORE;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_GO_TO() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_GO_TO;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_REMOVE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_REMOVE;\r\n    }\r\n\r\n    public static String getREMOVE_REFERENCES_WHEN_REMOVED() {\r\n        return ProjectConstants4ObjectExplorer.REMOVE_REFERENCES_WHEN_REMOVED;\r\n    }\r\n\r\n    public static String getSAVE() {\r\n        return ProjectConstants4ObjectExplorer.SAVE;\r\n    }\r\n\r\n    public static String getSHOW_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.SHOW_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getSHOW_REFERENCE() {\r\n        return ProjectConstants4ObjectExplorer.SHOW_REFERENCE;\r\n    }\r\n\r\n    public static String getSTRING_NULL() {\r\n        return ProjectConstants4ObjectExplorer.STRING_NULL;\r\n    }\r\n\r\n    public static String getUPDATE_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getUPDATE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_OBJECT;\r\n    }\r\n\r\n    public static String getUPDATE_OBJECTS() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_OBJECTS;\r\n    }\r\n\r\n    private ProjectConstants4ObjectExplorer() {\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/ProjectConstants4ObjectExplorerTest3.java",
		"test_prompt": "// ProjectConstants4ObjectExplorerTest3.java\npackage de.paragon.explorer;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProjectConstants4ObjectExplorer}.\n* It contains ten unit test cases for the {@link ProjectConstants4ObjectExplorer#getHIDE_ATTRIBUTE()} method.\n*/\nclass ProjectConstants4ObjectExplorerTest3 {"
	},
	{
		"original_code": "// ProjectConstants4ObjectExplorer.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer;\r\n\r\n/**\r\n * Projektkonstanten f�r den ObjectExplorer\r\n *\r\n * @author Stefan Jockenh�vel\r\n */\r\npublic final class ProjectConstants4ObjectExplorer {\r\n\r\n    private static final String ABOUT = \"About\";\r\n\r\n    private static final String COPY_OBJECT = \"Copy Object\";\r\n\r\n    private static final String EXPLORE_OBJECT = \"Explore Object\";\r\n\r\n    private static final String HIDE_ATTRIBUTE = \"Hide Attribute\";\r\n\r\n    private static final String HIDE_NULL_ATTRIBUTES = \"Hide \" + \"\\\"\" + \"null\" + \"\\\"\" + \" Attributes\";\r\n\r\n    private static final String HIDE_OBJECT = \"Hide Object\";\r\n\r\n    private static final String HIDE_OBJECT_WITH_DEPENDENCIES = \"Hide Object with Dependencies\";\r\n\r\n    private static final String HIDE_REFERENCE = \"Hide Reference\";\r\n\r\n    private static final String HIDE_STATIC_ATTRIBUTES = \"Hide \" + \"\\\"\" + \"static\" + \"\\\"\" + \" Attributes\";\r\n\r\n    private static final String HIDE_UNEXPLORED_ATTRIBUTES = \"Hide Unexplored Attributes\";\r\n\r\n    private static final String OBJECT_VIEW = \"Object View\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_ADD = \"Add\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_CLOSE = \"Close\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_EXPLORE = \"Explore\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_GO_TO = \"Go To\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_REMOVE = \"Remove\";\r\n\r\n    private static final String REMOVE_REFERENCES_WHEN_REMOVED = \"Remove Reference When Removed\";\r\n\r\n    private static final String SAVE = \"Save\";\r\n\r\n    private static final String SHOW_ATTRIBUTES = \"Show Attributes\";\r\n\r\n    private static final String SHOW_REFERENCE = \"Show Reference\";\r\n\r\n    private static final String STRING_NULL = \"null\";\r\n\r\n    private static final String UPDATE_ATTRIBUTES = \"Update Attributes\";\r\n\r\n    private static final String UPDATE_OBJECT = \"Update Object\";\r\n\r\n    private static final String UPDATE_OBJECTS = \"Update Objects\";\r\n\r\n    public static String getABOUT() {\r\n        return ProjectConstants4ObjectExplorer.ABOUT;\r\n    }\r\n\r\n    public static String getCOPY_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.COPY_OBJECT;\r\n    }\r\n\r\n    public static String getEXPLORE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.EXPLORE_OBJECT;\r\n    }\r\n\r\n    public static String getHIDE_ATTRIBUTE() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_ATTRIBUTE;\r\n    }\r\n\r\n    public static String getHIDE_NULL_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_NULL_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getHIDE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_OBJECT;\r\n    }\r\n\r\n    public static String getHIDE_OBJECT_WITH_DEPENDENCIES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_OBJECT_WITH_DEPENDENCIES;\r\n    }\r\n\r\n    public static String getHIDE_REFERENCE() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_REFERENCE;\r\n    }\r\n\r\n    public static String getHIDE_STATIC_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_STATIC_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getHIDE_UNEXPLORED_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_UNEXPLORED_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_ADD() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_ADD;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_CLOSE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_CLOSE;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_EXPLORE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_EXPLORE;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_GO_TO() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_GO_TO;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_REMOVE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_REMOVE;\r\n    }\r\n\r\n    public static String getREMOVE_REFERENCES_WHEN_REMOVED() {\r\n        return ProjectConstants4ObjectExplorer.REMOVE_REFERENCES_WHEN_REMOVED;\r\n    }\r\n\r\n    public static String getSAVE() {\r\n        return ProjectConstants4ObjectExplorer.SAVE;\r\n    }\r\n\r\n    public static String getSHOW_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.SHOW_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getSHOW_REFERENCE() {\r\n        return ProjectConstants4ObjectExplorer.SHOW_REFERENCE;\r\n    }\r\n\r\n    public static String getSTRING_NULL() {\r\n        return ProjectConstants4ObjectExplorer.STRING_NULL;\r\n    }\r\n\r\n    public static String getUPDATE_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getUPDATE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_OBJECT;\r\n    }\r\n\r\n    public static String getUPDATE_OBJECTS() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_OBJECTS;\r\n    }\r\n\r\n    private ProjectConstants4ObjectExplorer() {\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/ProjectConstants4ObjectExplorerTest4.java",
		"test_prompt": "// ProjectConstants4ObjectExplorerTest4.java\npackage de.paragon.explorer;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProjectConstants4ObjectExplorer}.\n* It contains ten unit test cases for the {@link ProjectConstants4ObjectExplorer#getHIDE_NULL_ATTRIBUTES()} method.\n*/\nclass ProjectConstants4ObjectExplorerTest4 {"
	},
	{
		"original_code": "// ProjectConstants4ObjectExplorer.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer;\r\n\r\n/**\r\n * Projektkonstanten f�r den ObjectExplorer\r\n *\r\n * @author Stefan Jockenh�vel\r\n */\r\npublic final class ProjectConstants4ObjectExplorer {\r\n\r\n    private static final String ABOUT = \"About\";\r\n\r\n    private static final String COPY_OBJECT = \"Copy Object\";\r\n\r\n    private static final String EXPLORE_OBJECT = \"Explore Object\";\r\n\r\n    private static final String HIDE_ATTRIBUTE = \"Hide Attribute\";\r\n\r\n    private static final String HIDE_NULL_ATTRIBUTES = \"Hide \" + \"\\\"\" + \"null\" + \"\\\"\" + \" Attributes\";\r\n\r\n    private static final String HIDE_OBJECT = \"Hide Object\";\r\n\r\n    private static final String HIDE_OBJECT_WITH_DEPENDENCIES = \"Hide Object with Dependencies\";\r\n\r\n    private static final String HIDE_REFERENCE = \"Hide Reference\";\r\n\r\n    private static final String HIDE_STATIC_ATTRIBUTES = \"Hide \" + \"\\\"\" + \"static\" + \"\\\"\" + \" Attributes\";\r\n\r\n    private static final String HIDE_UNEXPLORED_ATTRIBUTES = \"Hide Unexplored Attributes\";\r\n\r\n    private static final String OBJECT_VIEW = \"Object View\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_ADD = \"Add\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_CLOSE = \"Close\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_EXPLORE = \"Explore\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_GO_TO = \"Go To\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_REMOVE = \"Remove\";\r\n\r\n    private static final String REMOVE_REFERENCES_WHEN_REMOVED = \"Remove Reference When Removed\";\r\n\r\n    private static final String SAVE = \"Save\";\r\n\r\n    private static final String SHOW_ATTRIBUTES = \"Show Attributes\";\r\n\r\n    private static final String SHOW_REFERENCE = \"Show Reference\";\r\n\r\n    private static final String STRING_NULL = \"null\";\r\n\r\n    private static final String UPDATE_ATTRIBUTES = \"Update Attributes\";\r\n\r\n    private static final String UPDATE_OBJECT = \"Update Object\";\r\n\r\n    private static final String UPDATE_OBJECTS = \"Update Objects\";\r\n\r\n    public static String getABOUT() {\r\n        return ProjectConstants4ObjectExplorer.ABOUT;\r\n    }\r\n\r\n    public static String getCOPY_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.COPY_OBJECT;\r\n    }\r\n\r\n    public static String getEXPLORE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.EXPLORE_OBJECT;\r\n    }\r\n\r\n    public static String getHIDE_ATTRIBUTE() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_ATTRIBUTE;\r\n    }\r\n\r\n    public static String getHIDE_NULL_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_NULL_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getHIDE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_OBJECT;\r\n    }\r\n\r\n    public static String getHIDE_OBJECT_WITH_DEPENDENCIES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_OBJECT_WITH_DEPENDENCIES;\r\n    }\r\n\r\n    public static String getHIDE_REFERENCE() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_REFERENCE;\r\n    }\r\n\r\n    public static String getHIDE_STATIC_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_STATIC_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getHIDE_UNEXPLORED_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_UNEXPLORED_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_ADD() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_ADD;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_CLOSE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_CLOSE;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_EXPLORE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_EXPLORE;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_GO_TO() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_GO_TO;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_REMOVE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_REMOVE;\r\n    }\r\n\r\n    public static String getREMOVE_REFERENCES_WHEN_REMOVED() {\r\n        return ProjectConstants4ObjectExplorer.REMOVE_REFERENCES_WHEN_REMOVED;\r\n    }\r\n\r\n    public static String getSAVE() {\r\n        return ProjectConstants4ObjectExplorer.SAVE;\r\n    }\r\n\r\n    public static String getSHOW_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.SHOW_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getSHOW_REFERENCE() {\r\n        return ProjectConstants4ObjectExplorer.SHOW_REFERENCE;\r\n    }\r\n\r\n    public static String getSTRING_NULL() {\r\n        return ProjectConstants4ObjectExplorer.STRING_NULL;\r\n    }\r\n\r\n    public static String getUPDATE_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getUPDATE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_OBJECT;\r\n    }\r\n\r\n    public static String getUPDATE_OBJECTS() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_OBJECTS;\r\n    }\r\n\r\n    private ProjectConstants4ObjectExplorer() {\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/ProjectConstants4ObjectExplorerTest5.java",
		"test_prompt": "// ProjectConstants4ObjectExplorerTest5.java\npackage de.paragon.explorer;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProjectConstants4ObjectExplorer}.\n* It contains ten unit test cases for the {@link ProjectConstants4ObjectExplorer#getHIDE_OBJECT()} method.\n*/\nclass ProjectConstants4ObjectExplorerTest5 {"
	},
	{
		"original_code": "// ProjectConstants4ObjectExplorer.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer;\r\n\r\n/**\r\n * Projektkonstanten f�r den ObjectExplorer\r\n *\r\n * @author Stefan Jockenh�vel\r\n */\r\npublic final class ProjectConstants4ObjectExplorer {\r\n\r\n    private static final String ABOUT = \"About\";\r\n\r\n    private static final String COPY_OBJECT = \"Copy Object\";\r\n\r\n    private static final String EXPLORE_OBJECT = \"Explore Object\";\r\n\r\n    private static final String HIDE_ATTRIBUTE = \"Hide Attribute\";\r\n\r\n    private static final String HIDE_NULL_ATTRIBUTES = \"Hide \" + \"\\\"\" + \"null\" + \"\\\"\" + \" Attributes\";\r\n\r\n    private static final String HIDE_OBJECT = \"Hide Object\";\r\n\r\n    private static final String HIDE_OBJECT_WITH_DEPENDENCIES = \"Hide Object with Dependencies\";\r\n\r\n    private static final String HIDE_REFERENCE = \"Hide Reference\";\r\n\r\n    private static final String HIDE_STATIC_ATTRIBUTES = \"Hide \" + \"\\\"\" + \"static\" + \"\\\"\" + \" Attributes\";\r\n\r\n    private static final String HIDE_UNEXPLORED_ATTRIBUTES = \"Hide Unexplored Attributes\";\r\n\r\n    private static final String OBJECT_VIEW = \"Object View\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_ADD = \"Add\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_CLOSE = \"Close\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_EXPLORE = \"Explore\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_GO_TO = \"Go To\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_REMOVE = \"Remove\";\r\n\r\n    private static final String REMOVE_REFERENCES_WHEN_REMOVED = \"Remove Reference When Removed\";\r\n\r\n    private static final String SAVE = \"Save\";\r\n\r\n    private static final String SHOW_ATTRIBUTES = \"Show Attributes\";\r\n\r\n    private static final String SHOW_REFERENCE = \"Show Reference\";\r\n\r\n    private static final String STRING_NULL = \"null\";\r\n\r\n    private static final String UPDATE_ATTRIBUTES = \"Update Attributes\";\r\n\r\n    private static final String UPDATE_OBJECT = \"Update Object\";\r\n\r\n    private static final String UPDATE_OBJECTS = \"Update Objects\";\r\n\r\n    public static String getABOUT() {\r\n        return ProjectConstants4ObjectExplorer.ABOUT;\r\n    }\r\n\r\n    public static String getCOPY_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.COPY_OBJECT;\r\n    }\r\n\r\n    public static String getEXPLORE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.EXPLORE_OBJECT;\r\n    }\r\n\r\n    public static String getHIDE_ATTRIBUTE() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_ATTRIBUTE;\r\n    }\r\n\r\n    public static String getHIDE_NULL_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_NULL_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getHIDE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_OBJECT;\r\n    }\r\n\r\n    public static String getHIDE_OBJECT_WITH_DEPENDENCIES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_OBJECT_WITH_DEPENDENCIES;\r\n    }\r\n\r\n    public static String getHIDE_REFERENCE() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_REFERENCE;\r\n    }\r\n\r\n    public static String getHIDE_STATIC_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_STATIC_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getHIDE_UNEXPLORED_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_UNEXPLORED_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_ADD() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_ADD;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_CLOSE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_CLOSE;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_EXPLORE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_EXPLORE;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_GO_TO() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_GO_TO;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_REMOVE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_REMOVE;\r\n    }\r\n\r\n    public static String getREMOVE_REFERENCES_WHEN_REMOVED() {\r\n        return ProjectConstants4ObjectExplorer.REMOVE_REFERENCES_WHEN_REMOVED;\r\n    }\r\n\r\n    public static String getSAVE() {\r\n        return ProjectConstants4ObjectExplorer.SAVE;\r\n    }\r\n\r\n    public static String getSHOW_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.SHOW_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getSHOW_REFERENCE() {\r\n        return ProjectConstants4ObjectExplorer.SHOW_REFERENCE;\r\n    }\r\n\r\n    public static String getSTRING_NULL() {\r\n        return ProjectConstants4ObjectExplorer.STRING_NULL;\r\n    }\r\n\r\n    public static String getUPDATE_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getUPDATE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_OBJECT;\r\n    }\r\n\r\n    public static String getUPDATE_OBJECTS() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_OBJECTS;\r\n    }\r\n\r\n    private ProjectConstants4ObjectExplorer() {\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/ProjectConstants4ObjectExplorerTest6.java",
		"test_prompt": "// ProjectConstants4ObjectExplorerTest6.java\npackage de.paragon.explorer;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProjectConstants4ObjectExplorer}.\n* It contains ten unit test cases for the {@link ProjectConstants4ObjectExplorer#getHIDE_OBJECT_WITH_DEPENDENCIES()} method.\n*/\nclass ProjectConstants4ObjectExplorerTest6 {"
	},
	{
		"original_code": "// ProjectConstants4ObjectExplorer.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer;\r\n\r\n/**\r\n * Projektkonstanten f�r den ObjectExplorer\r\n *\r\n * @author Stefan Jockenh�vel\r\n */\r\npublic final class ProjectConstants4ObjectExplorer {\r\n\r\n    private static final String ABOUT = \"About\";\r\n\r\n    private static final String COPY_OBJECT = \"Copy Object\";\r\n\r\n    private static final String EXPLORE_OBJECT = \"Explore Object\";\r\n\r\n    private static final String HIDE_ATTRIBUTE = \"Hide Attribute\";\r\n\r\n    private static final String HIDE_NULL_ATTRIBUTES = \"Hide \" + \"\\\"\" + \"null\" + \"\\\"\" + \" Attributes\";\r\n\r\n    private static final String HIDE_OBJECT = \"Hide Object\";\r\n\r\n    private static final String HIDE_OBJECT_WITH_DEPENDENCIES = \"Hide Object with Dependencies\";\r\n\r\n    private static final String HIDE_REFERENCE = \"Hide Reference\";\r\n\r\n    private static final String HIDE_STATIC_ATTRIBUTES = \"Hide \" + \"\\\"\" + \"static\" + \"\\\"\" + \" Attributes\";\r\n\r\n    private static final String HIDE_UNEXPLORED_ATTRIBUTES = \"Hide Unexplored Attributes\";\r\n\r\n    private static final String OBJECT_VIEW = \"Object View\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_ADD = \"Add\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_CLOSE = \"Close\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_EXPLORE = \"Explore\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_GO_TO = \"Go To\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_REMOVE = \"Remove\";\r\n\r\n    private static final String REMOVE_REFERENCES_WHEN_REMOVED = \"Remove Reference When Removed\";\r\n\r\n    private static final String SAVE = \"Save\";\r\n\r\n    private static final String SHOW_ATTRIBUTES = \"Show Attributes\";\r\n\r\n    private static final String SHOW_REFERENCE = \"Show Reference\";\r\n\r\n    private static final String STRING_NULL = \"null\";\r\n\r\n    private static final String UPDATE_ATTRIBUTES = \"Update Attributes\";\r\n\r\n    private static final String UPDATE_OBJECT = \"Update Object\";\r\n\r\n    private static final String UPDATE_OBJECTS = \"Update Objects\";\r\n\r\n    public static String getABOUT() {\r\n        return ProjectConstants4ObjectExplorer.ABOUT;\r\n    }\r\n\r\n    public static String getCOPY_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.COPY_OBJECT;\r\n    }\r\n\r\n    public static String getEXPLORE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.EXPLORE_OBJECT;\r\n    }\r\n\r\n    public static String getHIDE_ATTRIBUTE() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_ATTRIBUTE;\r\n    }\r\n\r\n    public static String getHIDE_NULL_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_NULL_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getHIDE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_OBJECT;\r\n    }\r\n\r\n    public static String getHIDE_OBJECT_WITH_DEPENDENCIES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_OBJECT_WITH_DEPENDENCIES;\r\n    }\r\n\r\n    public static String getHIDE_REFERENCE() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_REFERENCE;\r\n    }\r\n\r\n    public static String getHIDE_STATIC_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_STATIC_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getHIDE_UNEXPLORED_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_UNEXPLORED_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_ADD() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_ADD;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_CLOSE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_CLOSE;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_EXPLORE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_EXPLORE;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_GO_TO() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_GO_TO;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_REMOVE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_REMOVE;\r\n    }\r\n\r\n    public static String getREMOVE_REFERENCES_WHEN_REMOVED() {\r\n        return ProjectConstants4ObjectExplorer.REMOVE_REFERENCES_WHEN_REMOVED;\r\n    }\r\n\r\n    public static String getSAVE() {\r\n        return ProjectConstants4ObjectExplorer.SAVE;\r\n    }\r\n\r\n    public static String getSHOW_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.SHOW_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getSHOW_REFERENCE() {\r\n        return ProjectConstants4ObjectExplorer.SHOW_REFERENCE;\r\n    }\r\n\r\n    public static String getSTRING_NULL() {\r\n        return ProjectConstants4ObjectExplorer.STRING_NULL;\r\n    }\r\n\r\n    public static String getUPDATE_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getUPDATE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_OBJECT;\r\n    }\r\n\r\n    public static String getUPDATE_OBJECTS() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_OBJECTS;\r\n    }\r\n\r\n    private ProjectConstants4ObjectExplorer() {\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/ProjectConstants4ObjectExplorerTest7.java",
		"test_prompt": "// ProjectConstants4ObjectExplorerTest7.java\npackage de.paragon.explorer;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProjectConstants4ObjectExplorer}.\n* It contains ten unit test cases for the {@link ProjectConstants4ObjectExplorer#getHIDE_REFERENCE()} method.\n*/\nclass ProjectConstants4ObjectExplorerTest7 {"
	},
	{
		"original_code": "// ProjectConstants4ObjectExplorer.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer;\r\n\r\n/**\r\n * Projektkonstanten f�r den ObjectExplorer\r\n *\r\n * @author Stefan Jockenh�vel\r\n */\r\npublic final class ProjectConstants4ObjectExplorer {\r\n\r\n    private static final String ABOUT = \"About\";\r\n\r\n    private static final String COPY_OBJECT = \"Copy Object\";\r\n\r\n    private static final String EXPLORE_OBJECT = \"Explore Object\";\r\n\r\n    private static final String HIDE_ATTRIBUTE = \"Hide Attribute\";\r\n\r\n    private static final String HIDE_NULL_ATTRIBUTES = \"Hide \" + \"\\\"\" + \"null\" + \"\\\"\" + \" Attributes\";\r\n\r\n    private static final String HIDE_OBJECT = \"Hide Object\";\r\n\r\n    private static final String HIDE_OBJECT_WITH_DEPENDENCIES = \"Hide Object with Dependencies\";\r\n\r\n    private static final String HIDE_REFERENCE = \"Hide Reference\";\r\n\r\n    private static final String HIDE_STATIC_ATTRIBUTES = \"Hide \" + \"\\\"\" + \"static\" + \"\\\"\" + \" Attributes\";\r\n\r\n    private static final String HIDE_UNEXPLORED_ATTRIBUTES = \"Hide Unexplored Attributes\";\r\n\r\n    private static final String OBJECT_VIEW = \"Object View\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_ADD = \"Add\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_CLOSE = \"Close\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_EXPLORE = \"Explore\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_GO_TO = \"Go To\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_REMOVE = \"Remove\";\r\n\r\n    private static final String REMOVE_REFERENCES_WHEN_REMOVED = \"Remove Reference When Removed\";\r\n\r\n    private static final String SAVE = \"Save\";\r\n\r\n    private static final String SHOW_ATTRIBUTES = \"Show Attributes\";\r\n\r\n    private static final String SHOW_REFERENCE = \"Show Reference\";\r\n\r\n    private static final String STRING_NULL = \"null\";\r\n\r\n    private static final String UPDATE_ATTRIBUTES = \"Update Attributes\";\r\n\r\n    private static final String UPDATE_OBJECT = \"Update Object\";\r\n\r\n    private static final String UPDATE_OBJECTS = \"Update Objects\";\r\n\r\n    public static String getABOUT() {\r\n        return ProjectConstants4ObjectExplorer.ABOUT;\r\n    }\r\n\r\n    public static String getCOPY_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.COPY_OBJECT;\r\n    }\r\n\r\n    public static String getEXPLORE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.EXPLORE_OBJECT;\r\n    }\r\n\r\n    public static String getHIDE_ATTRIBUTE() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_ATTRIBUTE;\r\n    }\r\n\r\n    public static String getHIDE_NULL_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_NULL_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getHIDE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_OBJECT;\r\n    }\r\n\r\n    public static String getHIDE_OBJECT_WITH_DEPENDENCIES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_OBJECT_WITH_DEPENDENCIES;\r\n    }\r\n\r\n    public static String getHIDE_REFERENCE() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_REFERENCE;\r\n    }\r\n\r\n    public static String getHIDE_STATIC_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_STATIC_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getHIDE_UNEXPLORED_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_UNEXPLORED_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_ADD() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_ADD;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_CLOSE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_CLOSE;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_EXPLORE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_EXPLORE;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_GO_TO() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_GO_TO;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_REMOVE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_REMOVE;\r\n    }\r\n\r\n    public static String getREMOVE_REFERENCES_WHEN_REMOVED() {\r\n        return ProjectConstants4ObjectExplorer.REMOVE_REFERENCES_WHEN_REMOVED;\r\n    }\r\n\r\n    public static String getSAVE() {\r\n        return ProjectConstants4ObjectExplorer.SAVE;\r\n    }\r\n\r\n    public static String getSHOW_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.SHOW_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getSHOW_REFERENCE() {\r\n        return ProjectConstants4ObjectExplorer.SHOW_REFERENCE;\r\n    }\r\n\r\n    public static String getSTRING_NULL() {\r\n        return ProjectConstants4ObjectExplorer.STRING_NULL;\r\n    }\r\n\r\n    public static String getUPDATE_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getUPDATE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_OBJECT;\r\n    }\r\n\r\n    public static String getUPDATE_OBJECTS() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_OBJECTS;\r\n    }\r\n\r\n    private ProjectConstants4ObjectExplorer() {\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/ProjectConstants4ObjectExplorerTest8.java",
		"test_prompt": "// ProjectConstants4ObjectExplorerTest8.java\npackage de.paragon.explorer;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProjectConstants4ObjectExplorer}.\n* It contains ten unit test cases for the {@link ProjectConstants4ObjectExplorer#getHIDE_STATIC_ATTRIBUTES()} method.\n*/\nclass ProjectConstants4ObjectExplorerTest8 {"
	},
	{
		"original_code": "// ProjectConstants4ObjectExplorer.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer;\r\n\r\n/**\r\n * Projektkonstanten f�r den ObjectExplorer\r\n *\r\n * @author Stefan Jockenh�vel\r\n */\r\npublic final class ProjectConstants4ObjectExplorer {\r\n\r\n    private static final String ABOUT = \"About\";\r\n\r\n    private static final String COPY_OBJECT = \"Copy Object\";\r\n\r\n    private static final String EXPLORE_OBJECT = \"Explore Object\";\r\n\r\n    private static final String HIDE_ATTRIBUTE = \"Hide Attribute\";\r\n\r\n    private static final String HIDE_NULL_ATTRIBUTES = \"Hide \" + \"\\\"\" + \"null\" + \"\\\"\" + \" Attributes\";\r\n\r\n    private static final String HIDE_OBJECT = \"Hide Object\";\r\n\r\n    private static final String HIDE_OBJECT_WITH_DEPENDENCIES = \"Hide Object with Dependencies\";\r\n\r\n    private static final String HIDE_REFERENCE = \"Hide Reference\";\r\n\r\n    private static final String HIDE_STATIC_ATTRIBUTES = \"Hide \" + \"\\\"\" + \"static\" + \"\\\"\" + \" Attributes\";\r\n\r\n    private static final String HIDE_UNEXPLORED_ATTRIBUTES = \"Hide Unexplored Attributes\";\r\n\r\n    private static final String OBJECT_VIEW = \"Object View\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_ADD = \"Add\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_CLOSE = \"Close\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_EXPLORE = \"Explore\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_GO_TO = \"Go To\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_REMOVE = \"Remove\";\r\n\r\n    private static final String REMOVE_REFERENCES_WHEN_REMOVED = \"Remove Reference When Removed\";\r\n\r\n    private static final String SAVE = \"Save\";\r\n\r\n    private static final String SHOW_ATTRIBUTES = \"Show Attributes\";\r\n\r\n    private static final String SHOW_REFERENCE = \"Show Reference\";\r\n\r\n    private static final String STRING_NULL = \"null\";\r\n\r\n    private static final String UPDATE_ATTRIBUTES = \"Update Attributes\";\r\n\r\n    private static final String UPDATE_OBJECT = \"Update Object\";\r\n\r\n    private static final String UPDATE_OBJECTS = \"Update Objects\";\r\n\r\n    public static String getABOUT() {\r\n        return ProjectConstants4ObjectExplorer.ABOUT;\r\n    }\r\n\r\n    public static String getCOPY_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.COPY_OBJECT;\r\n    }\r\n\r\n    public static String getEXPLORE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.EXPLORE_OBJECT;\r\n    }\r\n\r\n    public static String getHIDE_ATTRIBUTE() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_ATTRIBUTE;\r\n    }\r\n\r\n    public static String getHIDE_NULL_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_NULL_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getHIDE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_OBJECT;\r\n    }\r\n\r\n    public static String getHIDE_OBJECT_WITH_DEPENDENCIES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_OBJECT_WITH_DEPENDENCIES;\r\n    }\r\n\r\n    public static String getHIDE_REFERENCE() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_REFERENCE;\r\n    }\r\n\r\n    public static String getHIDE_STATIC_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_STATIC_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getHIDE_UNEXPLORED_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_UNEXPLORED_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_ADD() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_ADD;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_CLOSE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_CLOSE;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_EXPLORE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_EXPLORE;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_GO_TO() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_GO_TO;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_REMOVE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_REMOVE;\r\n    }\r\n\r\n    public static String getREMOVE_REFERENCES_WHEN_REMOVED() {\r\n        return ProjectConstants4ObjectExplorer.REMOVE_REFERENCES_WHEN_REMOVED;\r\n    }\r\n\r\n    public static String getSAVE() {\r\n        return ProjectConstants4ObjectExplorer.SAVE;\r\n    }\r\n\r\n    public static String getSHOW_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.SHOW_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getSHOW_REFERENCE() {\r\n        return ProjectConstants4ObjectExplorer.SHOW_REFERENCE;\r\n    }\r\n\r\n    public static String getSTRING_NULL() {\r\n        return ProjectConstants4ObjectExplorer.STRING_NULL;\r\n    }\r\n\r\n    public static String getUPDATE_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getUPDATE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_OBJECT;\r\n    }\r\n\r\n    public static String getUPDATE_OBJECTS() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_OBJECTS;\r\n    }\r\n\r\n    private ProjectConstants4ObjectExplorer() {\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/ProjectConstants4ObjectExplorerTest9.java",
		"test_prompt": "// ProjectConstants4ObjectExplorerTest9.java\npackage de.paragon.explorer;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProjectConstants4ObjectExplorer}.\n* It contains ten unit test cases for the {@link ProjectConstants4ObjectExplorer#getHIDE_UNEXPLORED_ATTRIBUTES()} method.\n*/\nclass ProjectConstants4ObjectExplorerTest9 {"
	},
	{
		"original_code": "// ProjectConstants4ObjectExplorer.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer;\r\n\r\n/**\r\n * Projektkonstanten f�r den ObjectExplorer\r\n *\r\n * @author Stefan Jockenh�vel\r\n */\r\npublic final class ProjectConstants4ObjectExplorer {\r\n\r\n    private static final String ABOUT = \"About\";\r\n\r\n    private static final String COPY_OBJECT = \"Copy Object\";\r\n\r\n    private static final String EXPLORE_OBJECT = \"Explore Object\";\r\n\r\n    private static final String HIDE_ATTRIBUTE = \"Hide Attribute\";\r\n\r\n    private static final String HIDE_NULL_ATTRIBUTES = \"Hide \" + \"\\\"\" + \"null\" + \"\\\"\" + \" Attributes\";\r\n\r\n    private static final String HIDE_OBJECT = \"Hide Object\";\r\n\r\n    private static final String HIDE_OBJECT_WITH_DEPENDENCIES = \"Hide Object with Dependencies\";\r\n\r\n    private static final String HIDE_REFERENCE = \"Hide Reference\";\r\n\r\n    private static final String HIDE_STATIC_ATTRIBUTES = \"Hide \" + \"\\\"\" + \"static\" + \"\\\"\" + \" Attributes\";\r\n\r\n    private static final String HIDE_UNEXPLORED_ATTRIBUTES = \"Hide Unexplored Attributes\";\r\n\r\n    private static final String OBJECT_VIEW = \"Object View\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_ADD = \"Add\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_CLOSE = \"Close\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_EXPLORE = \"Explore\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_GO_TO = \"Go To\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_REMOVE = \"Remove\";\r\n\r\n    private static final String REMOVE_REFERENCES_WHEN_REMOVED = \"Remove Reference When Removed\";\r\n\r\n    private static final String SAVE = \"Save\";\r\n\r\n    private static final String SHOW_ATTRIBUTES = \"Show Attributes\";\r\n\r\n    private static final String SHOW_REFERENCE = \"Show Reference\";\r\n\r\n    private static final String STRING_NULL = \"null\";\r\n\r\n    private static final String UPDATE_ATTRIBUTES = \"Update Attributes\";\r\n\r\n    private static final String UPDATE_OBJECT = \"Update Object\";\r\n\r\n    private static final String UPDATE_OBJECTS = \"Update Objects\";\r\n\r\n    public static String getABOUT() {\r\n        return ProjectConstants4ObjectExplorer.ABOUT;\r\n    }\r\n\r\n    public static String getCOPY_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.COPY_OBJECT;\r\n    }\r\n\r\n    public static String getEXPLORE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.EXPLORE_OBJECT;\r\n    }\r\n\r\n    public static String getHIDE_ATTRIBUTE() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_ATTRIBUTE;\r\n    }\r\n\r\n    public static String getHIDE_NULL_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_NULL_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getHIDE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_OBJECT;\r\n    }\r\n\r\n    public static String getHIDE_OBJECT_WITH_DEPENDENCIES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_OBJECT_WITH_DEPENDENCIES;\r\n    }\r\n\r\n    public static String getHIDE_REFERENCE() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_REFERENCE;\r\n    }\r\n\r\n    public static String getHIDE_STATIC_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_STATIC_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getHIDE_UNEXPLORED_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_UNEXPLORED_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_ADD() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_ADD;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_CLOSE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_CLOSE;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_EXPLORE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_EXPLORE;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_GO_TO() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_GO_TO;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_REMOVE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_REMOVE;\r\n    }\r\n\r\n    public static String getREMOVE_REFERENCES_WHEN_REMOVED() {\r\n        return ProjectConstants4ObjectExplorer.REMOVE_REFERENCES_WHEN_REMOVED;\r\n    }\r\n\r\n    public static String getSAVE() {\r\n        return ProjectConstants4ObjectExplorer.SAVE;\r\n    }\r\n\r\n    public static String getSHOW_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.SHOW_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getSHOW_REFERENCE() {\r\n        return ProjectConstants4ObjectExplorer.SHOW_REFERENCE;\r\n    }\r\n\r\n    public static String getSTRING_NULL() {\r\n        return ProjectConstants4ObjectExplorer.STRING_NULL;\r\n    }\r\n\r\n    public static String getUPDATE_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getUPDATE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_OBJECT;\r\n    }\r\n\r\n    public static String getUPDATE_OBJECTS() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_OBJECTS;\r\n    }\r\n\r\n    private ProjectConstants4ObjectExplorer() {\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/ProjectConstants4ObjectExplorerTest10.java",
		"test_prompt": "// ProjectConstants4ObjectExplorerTest10.java\npackage de.paragon.explorer;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProjectConstants4ObjectExplorer}.\n* It contains ten unit test cases for the {@link ProjectConstants4ObjectExplorer#getOBJECT_VIEW()} method.\n*/\nclass ProjectConstants4ObjectExplorerTest10 {"
	},
	{
		"original_code": "// ProjectConstants4ObjectExplorer.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer;\r\n\r\n/**\r\n * Projektkonstanten f�r den ObjectExplorer\r\n *\r\n * @author Stefan Jockenh�vel\r\n */\r\npublic final class ProjectConstants4ObjectExplorer {\r\n\r\n    private static final String ABOUT = \"About\";\r\n\r\n    private static final String COPY_OBJECT = \"Copy Object\";\r\n\r\n    private static final String EXPLORE_OBJECT = \"Explore Object\";\r\n\r\n    private static final String HIDE_ATTRIBUTE = \"Hide Attribute\";\r\n\r\n    private static final String HIDE_NULL_ATTRIBUTES = \"Hide \" + \"\\\"\" + \"null\" + \"\\\"\" + \" Attributes\";\r\n\r\n    private static final String HIDE_OBJECT = \"Hide Object\";\r\n\r\n    private static final String HIDE_OBJECT_WITH_DEPENDENCIES = \"Hide Object with Dependencies\";\r\n\r\n    private static final String HIDE_REFERENCE = \"Hide Reference\";\r\n\r\n    private static final String HIDE_STATIC_ATTRIBUTES = \"Hide \" + \"\\\"\" + \"static\" + \"\\\"\" + \" Attributes\";\r\n\r\n    private static final String HIDE_UNEXPLORED_ATTRIBUTES = \"Hide Unexplored Attributes\";\r\n\r\n    private static final String OBJECT_VIEW = \"Object View\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_ADD = \"Add\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_CLOSE = \"Close\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_EXPLORE = \"Explore\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_GO_TO = \"Go To\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_REMOVE = \"Remove\";\r\n\r\n    private static final String REMOVE_REFERENCES_WHEN_REMOVED = \"Remove Reference When Removed\";\r\n\r\n    private static final String SAVE = \"Save\";\r\n\r\n    private static final String SHOW_ATTRIBUTES = \"Show Attributes\";\r\n\r\n    private static final String SHOW_REFERENCE = \"Show Reference\";\r\n\r\n    private static final String STRING_NULL = \"null\";\r\n\r\n    private static final String UPDATE_ATTRIBUTES = \"Update Attributes\";\r\n\r\n    private static final String UPDATE_OBJECT = \"Update Object\";\r\n\r\n    private static final String UPDATE_OBJECTS = \"Update Objects\";\r\n\r\n    public static String getABOUT() {\r\n        return ProjectConstants4ObjectExplorer.ABOUT;\r\n    }\r\n\r\n    public static String getCOPY_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.COPY_OBJECT;\r\n    }\r\n\r\n    public static String getEXPLORE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.EXPLORE_OBJECT;\r\n    }\r\n\r\n    public static String getHIDE_ATTRIBUTE() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_ATTRIBUTE;\r\n    }\r\n\r\n    public static String getHIDE_NULL_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_NULL_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getHIDE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_OBJECT;\r\n    }\r\n\r\n    public static String getHIDE_OBJECT_WITH_DEPENDENCIES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_OBJECT_WITH_DEPENDENCIES;\r\n    }\r\n\r\n    public static String getHIDE_REFERENCE() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_REFERENCE;\r\n    }\r\n\r\n    public static String getHIDE_STATIC_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_STATIC_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getHIDE_UNEXPLORED_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_UNEXPLORED_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_ADD() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_ADD;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_CLOSE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_CLOSE;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_EXPLORE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_EXPLORE;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_GO_TO() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_GO_TO;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_REMOVE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_REMOVE;\r\n    }\r\n\r\n    public static String getREMOVE_REFERENCES_WHEN_REMOVED() {\r\n        return ProjectConstants4ObjectExplorer.REMOVE_REFERENCES_WHEN_REMOVED;\r\n    }\r\n\r\n    public static String getSAVE() {\r\n        return ProjectConstants4ObjectExplorer.SAVE;\r\n    }\r\n\r\n    public static String getSHOW_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.SHOW_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getSHOW_REFERENCE() {\r\n        return ProjectConstants4ObjectExplorer.SHOW_REFERENCE;\r\n    }\r\n\r\n    public static String getSTRING_NULL() {\r\n        return ProjectConstants4ObjectExplorer.STRING_NULL;\r\n    }\r\n\r\n    public static String getUPDATE_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getUPDATE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_OBJECT;\r\n    }\r\n\r\n    public static String getUPDATE_OBJECTS() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_OBJECTS;\r\n    }\r\n\r\n    private ProjectConstants4ObjectExplorer() {\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/ProjectConstants4ObjectExplorerTest11.java",
		"test_prompt": "// ProjectConstants4ObjectExplorerTest11.java\npackage de.paragon.explorer;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProjectConstants4ObjectExplorer}.\n* It contains ten unit test cases for the {@link ProjectConstants4ObjectExplorer#getOBJECT_VIEW_DIALOG_ADD()} method.\n*/\nclass ProjectConstants4ObjectExplorerTest11 {"
	},
	{
		"original_code": "// ProjectConstants4ObjectExplorer.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer;\r\n\r\n/**\r\n * Projektkonstanten f�r den ObjectExplorer\r\n *\r\n * @author Stefan Jockenh�vel\r\n */\r\npublic final class ProjectConstants4ObjectExplorer {\r\n\r\n    private static final String ABOUT = \"About\";\r\n\r\n    private static final String COPY_OBJECT = \"Copy Object\";\r\n\r\n    private static final String EXPLORE_OBJECT = \"Explore Object\";\r\n\r\n    private static final String HIDE_ATTRIBUTE = \"Hide Attribute\";\r\n\r\n    private static final String HIDE_NULL_ATTRIBUTES = \"Hide \" + \"\\\"\" + \"null\" + \"\\\"\" + \" Attributes\";\r\n\r\n    private static final String HIDE_OBJECT = \"Hide Object\";\r\n\r\n    private static final String HIDE_OBJECT_WITH_DEPENDENCIES = \"Hide Object with Dependencies\";\r\n\r\n    private static final String HIDE_REFERENCE = \"Hide Reference\";\r\n\r\n    private static final String HIDE_STATIC_ATTRIBUTES = \"Hide \" + \"\\\"\" + \"static\" + \"\\\"\" + \" Attributes\";\r\n\r\n    private static final String HIDE_UNEXPLORED_ATTRIBUTES = \"Hide Unexplored Attributes\";\r\n\r\n    private static final String OBJECT_VIEW = \"Object View\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_ADD = \"Add\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_CLOSE = \"Close\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_EXPLORE = \"Explore\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_GO_TO = \"Go To\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_REMOVE = \"Remove\";\r\n\r\n    private static final String REMOVE_REFERENCES_WHEN_REMOVED = \"Remove Reference When Removed\";\r\n\r\n    private static final String SAVE = \"Save\";\r\n\r\n    private static final String SHOW_ATTRIBUTES = \"Show Attributes\";\r\n\r\n    private static final String SHOW_REFERENCE = \"Show Reference\";\r\n\r\n    private static final String STRING_NULL = \"null\";\r\n\r\n    private static final String UPDATE_ATTRIBUTES = \"Update Attributes\";\r\n\r\n    private static final String UPDATE_OBJECT = \"Update Object\";\r\n\r\n    private static final String UPDATE_OBJECTS = \"Update Objects\";\r\n\r\n    public static String getABOUT() {\r\n        return ProjectConstants4ObjectExplorer.ABOUT;\r\n    }\r\n\r\n    public static String getCOPY_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.COPY_OBJECT;\r\n    }\r\n\r\n    public static String getEXPLORE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.EXPLORE_OBJECT;\r\n    }\r\n\r\n    public static String getHIDE_ATTRIBUTE() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_ATTRIBUTE;\r\n    }\r\n\r\n    public static String getHIDE_NULL_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_NULL_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getHIDE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_OBJECT;\r\n    }\r\n\r\n    public static String getHIDE_OBJECT_WITH_DEPENDENCIES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_OBJECT_WITH_DEPENDENCIES;\r\n    }\r\n\r\n    public static String getHIDE_REFERENCE() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_REFERENCE;\r\n    }\r\n\r\n    public static String getHIDE_STATIC_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_STATIC_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getHIDE_UNEXPLORED_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_UNEXPLORED_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_ADD() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_ADD;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_CLOSE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_CLOSE;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_EXPLORE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_EXPLORE;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_GO_TO() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_GO_TO;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_REMOVE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_REMOVE;\r\n    }\r\n\r\n    public static String getREMOVE_REFERENCES_WHEN_REMOVED() {\r\n        return ProjectConstants4ObjectExplorer.REMOVE_REFERENCES_WHEN_REMOVED;\r\n    }\r\n\r\n    public static String getSAVE() {\r\n        return ProjectConstants4ObjectExplorer.SAVE;\r\n    }\r\n\r\n    public static String getSHOW_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.SHOW_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getSHOW_REFERENCE() {\r\n        return ProjectConstants4ObjectExplorer.SHOW_REFERENCE;\r\n    }\r\n\r\n    public static String getSTRING_NULL() {\r\n        return ProjectConstants4ObjectExplorer.STRING_NULL;\r\n    }\r\n\r\n    public static String getUPDATE_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getUPDATE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_OBJECT;\r\n    }\r\n\r\n    public static String getUPDATE_OBJECTS() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_OBJECTS;\r\n    }\r\n\r\n    private ProjectConstants4ObjectExplorer() {\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/ProjectConstants4ObjectExplorerTest12.java",
		"test_prompt": "// ProjectConstants4ObjectExplorerTest12.java\npackage de.paragon.explorer;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProjectConstants4ObjectExplorer}.\n* It contains ten unit test cases for the {@link ProjectConstants4ObjectExplorer#getOBJECT_VIEW_DIALOG_CLOSE()} method.\n*/\nclass ProjectConstants4ObjectExplorerTest12 {"
	},
	{
		"original_code": "// ProjectConstants4ObjectExplorer.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer;\r\n\r\n/**\r\n * Projektkonstanten f�r den ObjectExplorer\r\n *\r\n * @author Stefan Jockenh�vel\r\n */\r\npublic final class ProjectConstants4ObjectExplorer {\r\n\r\n    private static final String ABOUT = \"About\";\r\n\r\n    private static final String COPY_OBJECT = \"Copy Object\";\r\n\r\n    private static final String EXPLORE_OBJECT = \"Explore Object\";\r\n\r\n    private static final String HIDE_ATTRIBUTE = \"Hide Attribute\";\r\n\r\n    private static final String HIDE_NULL_ATTRIBUTES = \"Hide \" + \"\\\"\" + \"null\" + \"\\\"\" + \" Attributes\";\r\n\r\n    private static final String HIDE_OBJECT = \"Hide Object\";\r\n\r\n    private static final String HIDE_OBJECT_WITH_DEPENDENCIES = \"Hide Object with Dependencies\";\r\n\r\n    private static final String HIDE_REFERENCE = \"Hide Reference\";\r\n\r\n    private static final String HIDE_STATIC_ATTRIBUTES = \"Hide \" + \"\\\"\" + \"static\" + \"\\\"\" + \" Attributes\";\r\n\r\n    private static final String HIDE_UNEXPLORED_ATTRIBUTES = \"Hide Unexplored Attributes\";\r\n\r\n    private static final String OBJECT_VIEW = \"Object View\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_ADD = \"Add\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_CLOSE = \"Close\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_EXPLORE = \"Explore\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_GO_TO = \"Go To\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_REMOVE = \"Remove\";\r\n\r\n    private static final String REMOVE_REFERENCES_WHEN_REMOVED = \"Remove Reference When Removed\";\r\n\r\n    private static final String SAVE = \"Save\";\r\n\r\n    private static final String SHOW_ATTRIBUTES = \"Show Attributes\";\r\n\r\n    private static final String SHOW_REFERENCE = \"Show Reference\";\r\n\r\n    private static final String STRING_NULL = \"null\";\r\n\r\n    private static final String UPDATE_ATTRIBUTES = \"Update Attributes\";\r\n\r\n    private static final String UPDATE_OBJECT = \"Update Object\";\r\n\r\n    private static final String UPDATE_OBJECTS = \"Update Objects\";\r\n\r\n    public static String getABOUT() {\r\n        return ProjectConstants4ObjectExplorer.ABOUT;\r\n    }\r\n\r\n    public static String getCOPY_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.COPY_OBJECT;\r\n    }\r\n\r\n    public static String getEXPLORE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.EXPLORE_OBJECT;\r\n    }\r\n\r\n    public static String getHIDE_ATTRIBUTE() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_ATTRIBUTE;\r\n    }\r\n\r\n    public static String getHIDE_NULL_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_NULL_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getHIDE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_OBJECT;\r\n    }\r\n\r\n    public static String getHIDE_OBJECT_WITH_DEPENDENCIES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_OBJECT_WITH_DEPENDENCIES;\r\n    }\r\n\r\n    public static String getHIDE_REFERENCE() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_REFERENCE;\r\n    }\r\n\r\n    public static String getHIDE_STATIC_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_STATIC_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getHIDE_UNEXPLORED_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_UNEXPLORED_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_ADD() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_ADD;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_CLOSE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_CLOSE;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_EXPLORE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_EXPLORE;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_GO_TO() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_GO_TO;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_REMOVE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_REMOVE;\r\n    }\r\n\r\n    public static String getREMOVE_REFERENCES_WHEN_REMOVED() {\r\n        return ProjectConstants4ObjectExplorer.REMOVE_REFERENCES_WHEN_REMOVED;\r\n    }\r\n\r\n    public static String getSAVE() {\r\n        return ProjectConstants4ObjectExplorer.SAVE;\r\n    }\r\n\r\n    public static String getSHOW_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.SHOW_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getSHOW_REFERENCE() {\r\n        return ProjectConstants4ObjectExplorer.SHOW_REFERENCE;\r\n    }\r\n\r\n    public static String getSTRING_NULL() {\r\n        return ProjectConstants4ObjectExplorer.STRING_NULL;\r\n    }\r\n\r\n    public static String getUPDATE_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getUPDATE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_OBJECT;\r\n    }\r\n\r\n    public static String getUPDATE_OBJECTS() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_OBJECTS;\r\n    }\r\n\r\n    private ProjectConstants4ObjectExplorer() {\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/ProjectConstants4ObjectExplorerTest13.java",
		"test_prompt": "// ProjectConstants4ObjectExplorerTest13.java\npackage de.paragon.explorer;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProjectConstants4ObjectExplorer}.\n* It contains ten unit test cases for the {@link ProjectConstants4ObjectExplorer#getOBJECT_VIEW_DIALOG_EXPLORE()} method.\n*/\nclass ProjectConstants4ObjectExplorerTest13 {"
	},
	{
		"original_code": "// ProjectConstants4ObjectExplorer.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer;\r\n\r\n/**\r\n * Projektkonstanten f�r den ObjectExplorer\r\n *\r\n * @author Stefan Jockenh�vel\r\n */\r\npublic final class ProjectConstants4ObjectExplorer {\r\n\r\n    private static final String ABOUT = \"About\";\r\n\r\n    private static final String COPY_OBJECT = \"Copy Object\";\r\n\r\n    private static final String EXPLORE_OBJECT = \"Explore Object\";\r\n\r\n    private static final String HIDE_ATTRIBUTE = \"Hide Attribute\";\r\n\r\n    private static final String HIDE_NULL_ATTRIBUTES = \"Hide \" + \"\\\"\" + \"null\" + \"\\\"\" + \" Attributes\";\r\n\r\n    private static final String HIDE_OBJECT = \"Hide Object\";\r\n\r\n    private static final String HIDE_OBJECT_WITH_DEPENDENCIES = \"Hide Object with Dependencies\";\r\n\r\n    private static final String HIDE_REFERENCE = \"Hide Reference\";\r\n\r\n    private static final String HIDE_STATIC_ATTRIBUTES = \"Hide \" + \"\\\"\" + \"static\" + \"\\\"\" + \" Attributes\";\r\n\r\n    private static final String HIDE_UNEXPLORED_ATTRIBUTES = \"Hide Unexplored Attributes\";\r\n\r\n    private static final String OBJECT_VIEW = \"Object View\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_ADD = \"Add\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_CLOSE = \"Close\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_EXPLORE = \"Explore\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_GO_TO = \"Go To\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_REMOVE = \"Remove\";\r\n\r\n    private static final String REMOVE_REFERENCES_WHEN_REMOVED = \"Remove Reference When Removed\";\r\n\r\n    private static final String SAVE = \"Save\";\r\n\r\n    private static final String SHOW_ATTRIBUTES = \"Show Attributes\";\r\n\r\n    private static final String SHOW_REFERENCE = \"Show Reference\";\r\n\r\n    private static final String STRING_NULL = \"null\";\r\n\r\n    private static final String UPDATE_ATTRIBUTES = \"Update Attributes\";\r\n\r\n    private static final String UPDATE_OBJECT = \"Update Object\";\r\n\r\n    private static final String UPDATE_OBJECTS = \"Update Objects\";\r\n\r\n    public static String getABOUT() {\r\n        return ProjectConstants4ObjectExplorer.ABOUT;\r\n    }\r\n\r\n    public static String getCOPY_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.COPY_OBJECT;\r\n    }\r\n\r\n    public static String getEXPLORE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.EXPLORE_OBJECT;\r\n    }\r\n\r\n    public static String getHIDE_ATTRIBUTE() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_ATTRIBUTE;\r\n    }\r\n\r\n    public static String getHIDE_NULL_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_NULL_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getHIDE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_OBJECT;\r\n    }\r\n\r\n    public static String getHIDE_OBJECT_WITH_DEPENDENCIES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_OBJECT_WITH_DEPENDENCIES;\r\n    }\r\n\r\n    public static String getHIDE_REFERENCE() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_REFERENCE;\r\n    }\r\n\r\n    public static String getHIDE_STATIC_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_STATIC_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getHIDE_UNEXPLORED_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_UNEXPLORED_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_ADD() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_ADD;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_CLOSE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_CLOSE;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_EXPLORE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_EXPLORE;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_GO_TO() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_GO_TO;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_REMOVE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_REMOVE;\r\n    }\r\n\r\n    public static String getREMOVE_REFERENCES_WHEN_REMOVED() {\r\n        return ProjectConstants4ObjectExplorer.REMOVE_REFERENCES_WHEN_REMOVED;\r\n    }\r\n\r\n    public static String getSAVE() {\r\n        return ProjectConstants4ObjectExplorer.SAVE;\r\n    }\r\n\r\n    public static String getSHOW_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.SHOW_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getSHOW_REFERENCE() {\r\n        return ProjectConstants4ObjectExplorer.SHOW_REFERENCE;\r\n    }\r\n\r\n    public static String getSTRING_NULL() {\r\n        return ProjectConstants4ObjectExplorer.STRING_NULL;\r\n    }\r\n\r\n    public static String getUPDATE_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getUPDATE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_OBJECT;\r\n    }\r\n\r\n    public static String getUPDATE_OBJECTS() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_OBJECTS;\r\n    }\r\n\r\n    private ProjectConstants4ObjectExplorer() {\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/ProjectConstants4ObjectExplorerTest14.java",
		"test_prompt": "// ProjectConstants4ObjectExplorerTest14.java\npackage de.paragon.explorer;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProjectConstants4ObjectExplorer}.\n* It contains ten unit test cases for the {@link ProjectConstants4ObjectExplorer#getOBJECT_VIEW_DIALOG_GO_TO()} method.\n*/\nclass ProjectConstants4ObjectExplorerTest14 {"
	},
	{
		"original_code": "// ProjectConstants4ObjectExplorer.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer;\r\n\r\n/**\r\n * Projektkonstanten f�r den ObjectExplorer\r\n *\r\n * @author Stefan Jockenh�vel\r\n */\r\npublic final class ProjectConstants4ObjectExplorer {\r\n\r\n    private static final String ABOUT = \"About\";\r\n\r\n    private static final String COPY_OBJECT = \"Copy Object\";\r\n\r\n    private static final String EXPLORE_OBJECT = \"Explore Object\";\r\n\r\n    private static final String HIDE_ATTRIBUTE = \"Hide Attribute\";\r\n\r\n    private static final String HIDE_NULL_ATTRIBUTES = \"Hide \" + \"\\\"\" + \"null\" + \"\\\"\" + \" Attributes\";\r\n\r\n    private static final String HIDE_OBJECT = \"Hide Object\";\r\n\r\n    private static final String HIDE_OBJECT_WITH_DEPENDENCIES = \"Hide Object with Dependencies\";\r\n\r\n    private static final String HIDE_REFERENCE = \"Hide Reference\";\r\n\r\n    private static final String HIDE_STATIC_ATTRIBUTES = \"Hide \" + \"\\\"\" + \"static\" + \"\\\"\" + \" Attributes\";\r\n\r\n    private static final String HIDE_UNEXPLORED_ATTRIBUTES = \"Hide Unexplored Attributes\";\r\n\r\n    private static final String OBJECT_VIEW = \"Object View\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_ADD = \"Add\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_CLOSE = \"Close\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_EXPLORE = \"Explore\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_GO_TO = \"Go To\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_REMOVE = \"Remove\";\r\n\r\n    private static final String REMOVE_REFERENCES_WHEN_REMOVED = \"Remove Reference When Removed\";\r\n\r\n    private static final String SAVE = \"Save\";\r\n\r\n    private static final String SHOW_ATTRIBUTES = \"Show Attributes\";\r\n\r\n    private static final String SHOW_REFERENCE = \"Show Reference\";\r\n\r\n    private static final String STRING_NULL = \"null\";\r\n\r\n    private static final String UPDATE_ATTRIBUTES = \"Update Attributes\";\r\n\r\n    private static final String UPDATE_OBJECT = \"Update Object\";\r\n\r\n    private static final String UPDATE_OBJECTS = \"Update Objects\";\r\n\r\n    public static String getABOUT() {\r\n        return ProjectConstants4ObjectExplorer.ABOUT;\r\n    }\r\n\r\n    public static String getCOPY_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.COPY_OBJECT;\r\n    }\r\n\r\n    public static String getEXPLORE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.EXPLORE_OBJECT;\r\n    }\r\n\r\n    public static String getHIDE_ATTRIBUTE() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_ATTRIBUTE;\r\n    }\r\n\r\n    public static String getHIDE_NULL_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_NULL_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getHIDE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_OBJECT;\r\n    }\r\n\r\n    public static String getHIDE_OBJECT_WITH_DEPENDENCIES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_OBJECT_WITH_DEPENDENCIES;\r\n    }\r\n\r\n    public static String getHIDE_REFERENCE() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_REFERENCE;\r\n    }\r\n\r\n    public static String getHIDE_STATIC_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_STATIC_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getHIDE_UNEXPLORED_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_UNEXPLORED_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_ADD() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_ADD;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_CLOSE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_CLOSE;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_EXPLORE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_EXPLORE;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_GO_TO() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_GO_TO;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_REMOVE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_REMOVE;\r\n    }\r\n\r\n    public static String getREMOVE_REFERENCES_WHEN_REMOVED() {\r\n        return ProjectConstants4ObjectExplorer.REMOVE_REFERENCES_WHEN_REMOVED;\r\n    }\r\n\r\n    public static String getSAVE() {\r\n        return ProjectConstants4ObjectExplorer.SAVE;\r\n    }\r\n\r\n    public static String getSHOW_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.SHOW_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getSHOW_REFERENCE() {\r\n        return ProjectConstants4ObjectExplorer.SHOW_REFERENCE;\r\n    }\r\n\r\n    public static String getSTRING_NULL() {\r\n        return ProjectConstants4ObjectExplorer.STRING_NULL;\r\n    }\r\n\r\n    public static String getUPDATE_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getUPDATE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_OBJECT;\r\n    }\r\n\r\n    public static String getUPDATE_OBJECTS() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_OBJECTS;\r\n    }\r\n\r\n    private ProjectConstants4ObjectExplorer() {\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/ProjectConstants4ObjectExplorerTest15.java",
		"test_prompt": "// ProjectConstants4ObjectExplorerTest15.java\npackage de.paragon.explorer;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProjectConstants4ObjectExplorer}.\n* It contains ten unit test cases for the {@link ProjectConstants4ObjectExplorer#getOBJECT_VIEW_DIALOG_REMOVE()} method.\n*/\nclass ProjectConstants4ObjectExplorerTest15 {"
	},
	{
		"original_code": "// ProjectConstants4ObjectExplorer.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer;\r\n\r\n/**\r\n * Projektkonstanten f�r den ObjectExplorer\r\n *\r\n * @author Stefan Jockenh�vel\r\n */\r\npublic final class ProjectConstants4ObjectExplorer {\r\n\r\n    private static final String ABOUT = \"About\";\r\n\r\n    private static final String COPY_OBJECT = \"Copy Object\";\r\n\r\n    private static final String EXPLORE_OBJECT = \"Explore Object\";\r\n\r\n    private static final String HIDE_ATTRIBUTE = \"Hide Attribute\";\r\n\r\n    private static final String HIDE_NULL_ATTRIBUTES = \"Hide \" + \"\\\"\" + \"null\" + \"\\\"\" + \" Attributes\";\r\n\r\n    private static final String HIDE_OBJECT = \"Hide Object\";\r\n\r\n    private static final String HIDE_OBJECT_WITH_DEPENDENCIES = \"Hide Object with Dependencies\";\r\n\r\n    private static final String HIDE_REFERENCE = \"Hide Reference\";\r\n\r\n    private static final String HIDE_STATIC_ATTRIBUTES = \"Hide \" + \"\\\"\" + \"static\" + \"\\\"\" + \" Attributes\";\r\n\r\n    private static final String HIDE_UNEXPLORED_ATTRIBUTES = \"Hide Unexplored Attributes\";\r\n\r\n    private static final String OBJECT_VIEW = \"Object View\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_ADD = \"Add\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_CLOSE = \"Close\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_EXPLORE = \"Explore\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_GO_TO = \"Go To\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_REMOVE = \"Remove\";\r\n\r\n    private static final String REMOVE_REFERENCES_WHEN_REMOVED = \"Remove Reference When Removed\";\r\n\r\n    private static final String SAVE = \"Save\";\r\n\r\n    private static final String SHOW_ATTRIBUTES = \"Show Attributes\";\r\n\r\n    private static final String SHOW_REFERENCE = \"Show Reference\";\r\n\r\n    private static final String STRING_NULL = \"null\";\r\n\r\n    private static final String UPDATE_ATTRIBUTES = \"Update Attributes\";\r\n\r\n    private static final String UPDATE_OBJECT = \"Update Object\";\r\n\r\n    private static final String UPDATE_OBJECTS = \"Update Objects\";\r\n\r\n    public static String getABOUT() {\r\n        return ProjectConstants4ObjectExplorer.ABOUT;\r\n    }\r\n\r\n    public static String getCOPY_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.COPY_OBJECT;\r\n    }\r\n\r\n    public static String getEXPLORE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.EXPLORE_OBJECT;\r\n    }\r\n\r\n    public static String getHIDE_ATTRIBUTE() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_ATTRIBUTE;\r\n    }\r\n\r\n    public static String getHIDE_NULL_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_NULL_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getHIDE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_OBJECT;\r\n    }\r\n\r\n    public static String getHIDE_OBJECT_WITH_DEPENDENCIES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_OBJECT_WITH_DEPENDENCIES;\r\n    }\r\n\r\n    public static String getHIDE_REFERENCE() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_REFERENCE;\r\n    }\r\n\r\n    public static String getHIDE_STATIC_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_STATIC_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getHIDE_UNEXPLORED_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_UNEXPLORED_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_ADD() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_ADD;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_CLOSE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_CLOSE;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_EXPLORE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_EXPLORE;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_GO_TO() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_GO_TO;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_REMOVE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_REMOVE;\r\n    }\r\n\r\n    public static String getREMOVE_REFERENCES_WHEN_REMOVED() {\r\n        return ProjectConstants4ObjectExplorer.REMOVE_REFERENCES_WHEN_REMOVED;\r\n    }\r\n\r\n    public static String getSAVE() {\r\n        return ProjectConstants4ObjectExplorer.SAVE;\r\n    }\r\n\r\n    public static String getSHOW_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.SHOW_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getSHOW_REFERENCE() {\r\n        return ProjectConstants4ObjectExplorer.SHOW_REFERENCE;\r\n    }\r\n\r\n    public static String getSTRING_NULL() {\r\n        return ProjectConstants4ObjectExplorer.STRING_NULL;\r\n    }\r\n\r\n    public static String getUPDATE_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getUPDATE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_OBJECT;\r\n    }\r\n\r\n    public static String getUPDATE_OBJECTS() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_OBJECTS;\r\n    }\r\n\r\n    private ProjectConstants4ObjectExplorer() {\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/ProjectConstants4ObjectExplorerTest16.java",
		"test_prompt": "// ProjectConstants4ObjectExplorerTest16.java\npackage de.paragon.explorer;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProjectConstants4ObjectExplorer}.\n* It contains ten unit test cases for the {@link ProjectConstants4ObjectExplorer#getREMOVE_REFERENCES_WHEN_REMOVED()} method.\n*/\nclass ProjectConstants4ObjectExplorerTest16 {"
	},
	{
		"original_code": "// ProjectConstants4ObjectExplorer.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer;\r\n\r\n/**\r\n * Projektkonstanten f�r den ObjectExplorer\r\n *\r\n * @author Stefan Jockenh�vel\r\n */\r\npublic final class ProjectConstants4ObjectExplorer {\r\n\r\n    private static final String ABOUT = \"About\";\r\n\r\n    private static final String COPY_OBJECT = \"Copy Object\";\r\n\r\n    private static final String EXPLORE_OBJECT = \"Explore Object\";\r\n\r\n    private static final String HIDE_ATTRIBUTE = \"Hide Attribute\";\r\n\r\n    private static final String HIDE_NULL_ATTRIBUTES = \"Hide \" + \"\\\"\" + \"null\" + \"\\\"\" + \" Attributes\";\r\n\r\n    private static final String HIDE_OBJECT = \"Hide Object\";\r\n\r\n    private static final String HIDE_OBJECT_WITH_DEPENDENCIES = \"Hide Object with Dependencies\";\r\n\r\n    private static final String HIDE_REFERENCE = \"Hide Reference\";\r\n\r\n    private static final String HIDE_STATIC_ATTRIBUTES = \"Hide \" + \"\\\"\" + \"static\" + \"\\\"\" + \" Attributes\";\r\n\r\n    private static final String HIDE_UNEXPLORED_ATTRIBUTES = \"Hide Unexplored Attributes\";\r\n\r\n    private static final String OBJECT_VIEW = \"Object View\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_ADD = \"Add\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_CLOSE = \"Close\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_EXPLORE = \"Explore\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_GO_TO = \"Go To\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_REMOVE = \"Remove\";\r\n\r\n    private static final String REMOVE_REFERENCES_WHEN_REMOVED = \"Remove Reference When Removed\";\r\n\r\n    private static final String SAVE = \"Save\";\r\n\r\n    private static final String SHOW_ATTRIBUTES = \"Show Attributes\";\r\n\r\n    private static final String SHOW_REFERENCE = \"Show Reference\";\r\n\r\n    private static final String STRING_NULL = \"null\";\r\n\r\n    private static final String UPDATE_ATTRIBUTES = \"Update Attributes\";\r\n\r\n    private static final String UPDATE_OBJECT = \"Update Object\";\r\n\r\n    private static final String UPDATE_OBJECTS = \"Update Objects\";\r\n\r\n    public static String getABOUT() {\r\n        return ProjectConstants4ObjectExplorer.ABOUT;\r\n    }\r\n\r\n    public static String getCOPY_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.COPY_OBJECT;\r\n    }\r\n\r\n    public static String getEXPLORE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.EXPLORE_OBJECT;\r\n    }\r\n\r\n    public static String getHIDE_ATTRIBUTE() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_ATTRIBUTE;\r\n    }\r\n\r\n    public static String getHIDE_NULL_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_NULL_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getHIDE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_OBJECT;\r\n    }\r\n\r\n    public static String getHIDE_OBJECT_WITH_DEPENDENCIES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_OBJECT_WITH_DEPENDENCIES;\r\n    }\r\n\r\n    public static String getHIDE_REFERENCE() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_REFERENCE;\r\n    }\r\n\r\n    public static String getHIDE_STATIC_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_STATIC_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getHIDE_UNEXPLORED_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_UNEXPLORED_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_ADD() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_ADD;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_CLOSE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_CLOSE;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_EXPLORE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_EXPLORE;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_GO_TO() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_GO_TO;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_REMOVE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_REMOVE;\r\n    }\r\n\r\n    public static String getREMOVE_REFERENCES_WHEN_REMOVED() {\r\n        return ProjectConstants4ObjectExplorer.REMOVE_REFERENCES_WHEN_REMOVED;\r\n    }\r\n\r\n    public static String getSAVE() {\r\n        return ProjectConstants4ObjectExplorer.SAVE;\r\n    }\r\n\r\n    public static String getSHOW_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.SHOW_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getSHOW_REFERENCE() {\r\n        return ProjectConstants4ObjectExplorer.SHOW_REFERENCE;\r\n    }\r\n\r\n    public static String getSTRING_NULL() {\r\n        return ProjectConstants4ObjectExplorer.STRING_NULL;\r\n    }\r\n\r\n    public static String getUPDATE_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getUPDATE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_OBJECT;\r\n    }\r\n\r\n    public static String getUPDATE_OBJECTS() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_OBJECTS;\r\n    }\r\n\r\n    private ProjectConstants4ObjectExplorer() {\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/ProjectConstants4ObjectExplorerTest17.java",
		"test_prompt": "// ProjectConstants4ObjectExplorerTest17.java\npackage de.paragon.explorer;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProjectConstants4ObjectExplorer}.\n* It contains ten unit test cases for the {@link ProjectConstants4ObjectExplorer#getSAVE()} method.\n*/\nclass ProjectConstants4ObjectExplorerTest17 {"
	},
	{
		"original_code": "// ProjectConstants4ObjectExplorer.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer;\r\n\r\n/**\r\n * Projektkonstanten f�r den ObjectExplorer\r\n *\r\n * @author Stefan Jockenh�vel\r\n */\r\npublic final class ProjectConstants4ObjectExplorer {\r\n\r\n    private static final String ABOUT = \"About\";\r\n\r\n    private static final String COPY_OBJECT = \"Copy Object\";\r\n\r\n    private static final String EXPLORE_OBJECT = \"Explore Object\";\r\n\r\n    private static final String HIDE_ATTRIBUTE = \"Hide Attribute\";\r\n\r\n    private static final String HIDE_NULL_ATTRIBUTES = \"Hide \" + \"\\\"\" + \"null\" + \"\\\"\" + \" Attributes\";\r\n\r\n    private static final String HIDE_OBJECT = \"Hide Object\";\r\n\r\n    private static final String HIDE_OBJECT_WITH_DEPENDENCIES = \"Hide Object with Dependencies\";\r\n\r\n    private static final String HIDE_REFERENCE = \"Hide Reference\";\r\n\r\n    private static final String HIDE_STATIC_ATTRIBUTES = \"Hide \" + \"\\\"\" + \"static\" + \"\\\"\" + \" Attributes\";\r\n\r\n    private static final String HIDE_UNEXPLORED_ATTRIBUTES = \"Hide Unexplored Attributes\";\r\n\r\n    private static final String OBJECT_VIEW = \"Object View\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_ADD = \"Add\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_CLOSE = \"Close\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_EXPLORE = \"Explore\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_GO_TO = \"Go To\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_REMOVE = \"Remove\";\r\n\r\n    private static final String REMOVE_REFERENCES_WHEN_REMOVED = \"Remove Reference When Removed\";\r\n\r\n    private static final String SAVE = \"Save\";\r\n\r\n    private static final String SHOW_ATTRIBUTES = \"Show Attributes\";\r\n\r\n    private static final String SHOW_REFERENCE = \"Show Reference\";\r\n\r\n    private static final String STRING_NULL = \"null\";\r\n\r\n    private static final String UPDATE_ATTRIBUTES = \"Update Attributes\";\r\n\r\n    private static final String UPDATE_OBJECT = \"Update Object\";\r\n\r\n    private static final String UPDATE_OBJECTS = \"Update Objects\";\r\n\r\n    public static String getABOUT() {\r\n        return ProjectConstants4ObjectExplorer.ABOUT;\r\n    }\r\n\r\n    public static String getCOPY_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.COPY_OBJECT;\r\n    }\r\n\r\n    public static String getEXPLORE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.EXPLORE_OBJECT;\r\n    }\r\n\r\n    public static String getHIDE_ATTRIBUTE() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_ATTRIBUTE;\r\n    }\r\n\r\n    public static String getHIDE_NULL_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_NULL_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getHIDE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_OBJECT;\r\n    }\r\n\r\n    public static String getHIDE_OBJECT_WITH_DEPENDENCIES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_OBJECT_WITH_DEPENDENCIES;\r\n    }\r\n\r\n    public static String getHIDE_REFERENCE() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_REFERENCE;\r\n    }\r\n\r\n    public static String getHIDE_STATIC_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_STATIC_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getHIDE_UNEXPLORED_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_UNEXPLORED_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_ADD() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_ADD;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_CLOSE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_CLOSE;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_EXPLORE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_EXPLORE;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_GO_TO() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_GO_TO;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_REMOVE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_REMOVE;\r\n    }\r\n\r\n    public static String getREMOVE_REFERENCES_WHEN_REMOVED() {\r\n        return ProjectConstants4ObjectExplorer.REMOVE_REFERENCES_WHEN_REMOVED;\r\n    }\r\n\r\n    public static String getSAVE() {\r\n        return ProjectConstants4ObjectExplorer.SAVE;\r\n    }\r\n\r\n    public static String getSHOW_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.SHOW_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getSHOW_REFERENCE() {\r\n        return ProjectConstants4ObjectExplorer.SHOW_REFERENCE;\r\n    }\r\n\r\n    public static String getSTRING_NULL() {\r\n        return ProjectConstants4ObjectExplorer.STRING_NULL;\r\n    }\r\n\r\n    public static String getUPDATE_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getUPDATE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_OBJECT;\r\n    }\r\n\r\n    public static String getUPDATE_OBJECTS() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_OBJECTS;\r\n    }\r\n\r\n    private ProjectConstants4ObjectExplorer() {\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/ProjectConstants4ObjectExplorerTest18.java",
		"test_prompt": "// ProjectConstants4ObjectExplorerTest18.java\npackage de.paragon.explorer;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProjectConstants4ObjectExplorer}.\n* It contains ten unit test cases for the {@link ProjectConstants4ObjectExplorer#getSHOW_ATTRIBUTES()} method.\n*/\nclass ProjectConstants4ObjectExplorerTest18 {"
	},
	{
		"original_code": "// ProjectConstants4ObjectExplorer.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer;\r\n\r\n/**\r\n * Projektkonstanten f�r den ObjectExplorer\r\n *\r\n * @author Stefan Jockenh�vel\r\n */\r\npublic final class ProjectConstants4ObjectExplorer {\r\n\r\n    private static final String ABOUT = \"About\";\r\n\r\n    private static final String COPY_OBJECT = \"Copy Object\";\r\n\r\n    private static final String EXPLORE_OBJECT = \"Explore Object\";\r\n\r\n    private static final String HIDE_ATTRIBUTE = \"Hide Attribute\";\r\n\r\n    private static final String HIDE_NULL_ATTRIBUTES = \"Hide \" + \"\\\"\" + \"null\" + \"\\\"\" + \" Attributes\";\r\n\r\n    private static final String HIDE_OBJECT = \"Hide Object\";\r\n\r\n    private static final String HIDE_OBJECT_WITH_DEPENDENCIES = \"Hide Object with Dependencies\";\r\n\r\n    private static final String HIDE_REFERENCE = \"Hide Reference\";\r\n\r\n    private static final String HIDE_STATIC_ATTRIBUTES = \"Hide \" + \"\\\"\" + \"static\" + \"\\\"\" + \" Attributes\";\r\n\r\n    private static final String HIDE_UNEXPLORED_ATTRIBUTES = \"Hide Unexplored Attributes\";\r\n\r\n    private static final String OBJECT_VIEW = \"Object View\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_ADD = \"Add\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_CLOSE = \"Close\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_EXPLORE = \"Explore\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_GO_TO = \"Go To\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_REMOVE = \"Remove\";\r\n\r\n    private static final String REMOVE_REFERENCES_WHEN_REMOVED = \"Remove Reference When Removed\";\r\n\r\n    private static final String SAVE = \"Save\";\r\n\r\n    private static final String SHOW_ATTRIBUTES = \"Show Attributes\";\r\n\r\n    private static final String SHOW_REFERENCE = \"Show Reference\";\r\n\r\n    private static final String STRING_NULL = \"null\";\r\n\r\n    private static final String UPDATE_ATTRIBUTES = \"Update Attributes\";\r\n\r\n    private static final String UPDATE_OBJECT = \"Update Object\";\r\n\r\n    private static final String UPDATE_OBJECTS = \"Update Objects\";\r\n\r\n    public static String getABOUT() {\r\n        return ProjectConstants4ObjectExplorer.ABOUT;\r\n    }\r\n\r\n    public static String getCOPY_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.COPY_OBJECT;\r\n    }\r\n\r\n    public static String getEXPLORE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.EXPLORE_OBJECT;\r\n    }\r\n\r\n    public static String getHIDE_ATTRIBUTE() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_ATTRIBUTE;\r\n    }\r\n\r\n    public static String getHIDE_NULL_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_NULL_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getHIDE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_OBJECT;\r\n    }\r\n\r\n    public static String getHIDE_OBJECT_WITH_DEPENDENCIES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_OBJECT_WITH_DEPENDENCIES;\r\n    }\r\n\r\n    public static String getHIDE_REFERENCE() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_REFERENCE;\r\n    }\r\n\r\n    public static String getHIDE_STATIC_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_STATIC_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getHIDE_UNEXPLORED_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_UNEXPLORED_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_ADD() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_ADD;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_CLOSE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_CLOSE;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_EXPLORE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_EXPLORE;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_GO_TO() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_GO_TO;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_REMOVE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_REMOVE;\r\n    }\r\n\r\n    public static String getREMOVE_REFERENCES_WHEN_REMOVED() {\r\n        return ProjectConstants4ObjectExplorer.REMOVE_REFERENCES_WHEN_REMOVED;\r\n    }\r\n\r\n    public static String getSAVE() {\r\n        return ProjectConstants4ObjectExplorer.SAVE;\r\n    }\r\n\r\n    public static String getSHOW_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.SHOW_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getSHOW_REFERENCE() {\r\n        return ProjectConstants4ObjectExplorer.SHOW_REFERENCE;\r\n    }\r\n\r\n    public static String getSTRING_NULL() {\r\n        return ProjectConstants4ObjectExplorer.STRING_NULL;\r\n    }\r\n\r\n    public static String getUPDATE_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getUPDATE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_OBJECT;\r\n    }\r\n\r\n    public static String getUPDATE_OBJECTS() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_OBJECTS;\r\n    }\r\n\r\n    private ProjectConstants4ObjectExplorer() {\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/ProjectConstants4ObjectExplorerTest19.java",
		"test_prompt": "// ProjectConstants4ObjectExplorerTest19.java\npackage de.paragon.explorer;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProjectConstants4ObjectExplorer}.\n* It contains ten unit test cases for the {@link ProjectConstants4ObjectExplorer#getSHOW_REFERENCE()} method.\n*/\nclass ProjectConstants4ObjectExplorerTest19 {"
	},
	{
		"original_code": "// ProjectConstants4ObjectExplorer.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer;\r\n\r\n/**\r\n * Projektkonstanten f�r den ObjectExplorer\r\n *\r\n * @author Stefan Jockenh�vel\r\n */\r\npublic final class ProjectConstants4ObjectExplorer {\r\n\r\n    private static final String ABOUT = \"About\";\r\n\r\n    private static final String COPY_OBJECT = \"Copy Object\";\r\n\r\n    private static final String EXPLORE_OBJECT = \"Explore Object\";\r\n\r\n    private static final String HIDE_ATTRIBUTE = \"Hide Attribute\";\r\n\r\n    private static final String HIDE_NULL_ATTRIBUTES = \"Hide \" + \"\\\"\" + \"null\" + \"\\\"\" + \" Attributes\";\r\n\r\n    private static final String HIDE_OBJECT = \"Hide Object\";\r\n\r\n    private static final String HIDE_OBJECT_WITH_DEPENDENCIES = \"Hide Object with Dependencies\";\r\n\r\n    private static final String HIDE_REFERENCE = \"Hide Reference\";\r\n\r\n    private static final String HIDE_STATIC_ATTRIBUTES = \"Hide \" + \"\\\"\" + \"static\" + \"\\\"\" + \" Attributes\";\r\n\r\n    private static final String HIDE_UNEXPLORED_ATTRIBUTES = \"Hide Unexplored Attributes\";\r\n\r\n    private static final String OBJECT_VIEW = \"Object View\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_ADD = \"Add\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_CLOSE = \"Close\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_EXPLORE = \"Explore\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_GO_TO = \"Go To\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_REMOVE = \"Remove\";\r\n\r\n    private static final String REMOVE_REFERENCES_WHEN_REMOVED = \"Remove Reference When Removed\";\r\n\r\n    private static final String SAVE = \"Save\";\r\n\r\n    private static final String SHOW_ATTRIBUTES = \"Show Attributes\";\r\n\r\n    private static final String SHOW_REFERENCE = \"Show Reference\";\r\n\r\n    private static final String STRING_NULL = \"null\";\r\n\r\n    private static final String UPDATE_ATTRIBUTES = \"Update Attributes\";\r\n\r\n    private static final String UPDATE_OBJECT = \"Update Object\";\r\n\r\n    private static final String UPDATE_OBJECTS = \"Update Objects\";\r\n\r\n    public static String getABOUT() {\r\n        return ProjectConstants4ObjectExplorer.ABOUT;\r\n    }\r\n\r\n    public static String getCOPY_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.COPY_OBJECT;\r\n    }\r\n\r\n    public static String getEXPLORE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.EXPLORE_OBJECT;\r\n    }\r\n\r\n    public static String getHIDE_ATTRIBUTE() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_ATTRIBUTE;\r\n    }\r\n\r\n    public static String getHIDE_NULL_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_NULL_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getHIDE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_OBJECT;\r\n    }\r\n\r\n    public static String getHIDE_OBJECT_WITH_DEPENDENCIES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_OBJECT_WITH_DEPENDENCIES;\r\n    }\r\n\r\n    public static String getHIDE_REFERENCE() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_REFERENCE;\r\n    }\r\n\r\n    public static String getHIDE_STATIC_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_STATIC_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getHIDE_UNEXPLORED_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_UNEXPLORED_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_ADD() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_ADD;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_CLOSE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_CLOSE;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_EXPLORE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_EXPLORE;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_GO_TO() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_GO_TO;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_REMOVE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_REMOVE;\r\n    }\r\n\r\n    public static String getREMOVE_REFERENCES_WHEN_REMOVED() {\r\n        return ProjectConstants4ObjectExplorer.REMOVE_REFERENCES_WHEN_REMOVED;\r\n    }\r\n\r\n    public static String getSAVE() {\r\n        return ProjectConstants4ObjectExplorer.SAVE;\r\n    }\r\n\r\n    public static String getSHOW_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.SHOW_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getSHOW_REFERENCE() {\r\n        return ProjectConstants4ObjectExplorer.SHOW_REFERENCE;\r\n    }\r\n\r\n    public static String getSTRING_NULL() {\r\n        return ProjectConstants4ObjectExplorer.STRING_NULL;\r\n    }\r\n\r\n    public static String getUPDATE_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getUPDATE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_OBJECT;\r\n    }\r\n\r\n    public static String getUPDATE_OBJECTS() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_OBJECTS;\r\n    }\r\n\r\n    private ProjectConstants4ObjectExplorer() {\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/ProjectConstants4ObjectExplorerTest20.java",
		"test_prompt": "// ProjectConstants4ObjectExplorerTest20.java\npackage de.paragon.explorer;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProjectConstants4ObjectExplorer}.\n* It contains ten unit test cases for the {@link ProjectConstants4ObjectExplorer#getSTRING_NULL()} method.\n*/\nclass ProjectConstants4ObjectExplorerTest20 {"
	},
	{
		"original_code": "// ProjectConstants4ObjectExplorer.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer;\r\n\r\n/**\r\n * Projektkonstanten f�r den ObjectExplorer\r\n *\r\n * @author Stefan Jockenh�vel\r\n */\r\npublic final class ProjectConstants4ObjectExplorer {\r\n\r\n    private static final String ABOUT = \"About\";\r\n\r\n    private static final String COPY_OBJECT = \"Copy Object\";\r\n\r\n    private static final String EXPLORE_OBJECT = \"Explore Object\";\r\n\r\n    private static final String HIDE_ATTRIBUTE = \"Hide Attribute\";\r\n\r\n    private static final String HIDE_NULL_ATTRIBUTES = \"Hide \" + \"\\\"\" + \"null\" + \"\\\"\" + \" Attributes\";\r\n\r\n    private static final String HIDE_OBJECT = \"Hide Object\";\r\n\r\n    private static final String HIDE_OBJECT_WITH_DEPENDENCIES = \"Hide Object with Dependencies\";\r\n\r\n    private static final String HIDE_REFERENCE = \"Hide Reference\";\r\n\r\n    private static final String HIDE_STATIC_ATTRIBUTES = \"Hide \" + \"\\\"\" + \"static\" + \"\\\"\" + \" Attributes\";\r\n\r\n    private static final String HIDE_UNEXPLORED_ATTRIBUTES = \"Hide Unexplored Attributes\";\r\n\r\n    private static final String OBJECT_VIEW = \"Object View\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_ADD = \"Add\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_CLOSE = \"Close\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_EXPLORE = \"Explore\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_GO_TO = \"Go To\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_REMOVE = \"Remove\";\r\n\r\n    private static final String REMOVE_REFERENCES_WHEN_REMOVED = \"Remove Reference When Removed\";\r\n\r\n    private static final String SAVE = \"Save\";\r\n\r\n    private static final String SHOW_ATTRIBUTES = \"Show Attributes\";\r\n\r\n    private static final String SHOW_REFERENCE = \"Show Reference\";\r\n\r\n    private static final String STRING_NULL = \"null\";\r\n\r\n    private static final String UPDATE_ATTRIBUTES = \"Update Attributes\";\r\n\r\n    private static final String UPDATE_OBJECT = \"Update Object\";\r\n\r\n    private static final String UPDATE_OBJECTS = \"Update Objects\";\r\n\r\n    public static String getABOUT() {\r\n        return ProjectConstants4ObjectExplorer.ABOUT;\r\n    }\r\n\r\n    public static String getCOPY_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.COPY_OBJECT;\r\n    }\r\n\r\n    public static String getEXPLORE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.EXPLORE_OBJECT;\r\n    }\r\n\r\n    public static String getHIDE_ATTRIBUTE() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_ATTRIBUTE;\r\n    }\r\n\r\n    public static String getHIDE_NULL_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_NULL_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getHIDE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_OBJECT;\r\n    }\r\n\r\n    public static String getHIDE_OBJECT_WITH_DEPENDENCIES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_OBJECT_WITH_DEPENDENCIES;\r\n    }\r\n\r\n    public static String getHIDE_REFERENCE() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_REFERENCE;\r\n    }\r\n\r\n    public static String getHIDE_STATIC_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_STATIC_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getHIDE_UNEXPLORED_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_UNEXPLORED_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_ADD() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_ADD;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_CLOSE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_CLOSE;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_EXPLORE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_EXPLORE;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_GO_TO() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_GO_TO;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_REMOVE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_REMOVE;\r\n    }\r\n\r\n    public static String getREMOVE_REFERENCES_WHEN_REMOVED() {\r\n        return ProjectConstants4ObjectExplorer.REMOVE_REFERENCES_WHEN_REMOVED;\r\n    }\r\n\r\n    public static String getSAVE() {\r\n        return ProjectConstants4ObjectExplorer.SAVE;\r\n    }\r\n\r\n    public static String getSHOW_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.SHOW_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getSHOW_REFERENCE() {\r\n        return ProjectConstants4ObjectExplorer.SHOW_REFERENCE;\r\n    }\r\n\r\n    public static String getSTRING_NULL() {\r\n        return ProjectConstants4ObjectExplorer.STRING_NULL;\r\n    }\r\n\r\n    public static String getUPDATE_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getUPDATE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_OBJECT;\r\n    }\r\n\r\n    public static String getUPDATE_OBJECTS() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_OBJECTS;\r\n    }\r\n\r\n    private ProjectConstants4ObjectExplorer() {\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/ProjectConstants4ObjectExplorerTest21.java",
		"test_prompt": "// ProjectConstants4ObjectExplorerTest21.java\npackage de.paragon.explorer;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProjectConstants4ObjectExplorer}.\n* It contains ten unit test cases for the {@link ProjectConstants4ObjectExplorer#getUPDATE_ATTRIBUTES()} method.\n*/\nclass ProjectConstants4ObjectExplorerTest21 {"
	},
	{
		"original_code": "// ProjectConstants4ObjectExplorer.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer;\r\n\r\n/**\r\n * Projektkonstanten f�r den ObjectExplorer\r\n *\r\n * @author Stefan Jockenh�vel\r\n */\r\npublic final class ProjectConstants4ObjectExplorer {\r\n\r\n    private static final String ABOUT = \"About\";\r\n\r\n    private static final String COPY_OBJECT = \"Copy Object\";\r\n\r\n    private static final String EXPLORE_OBJECT = \"Explore Object\";\r\n\r\n    private static final String HIDE_ATTRIBUTE = \"Hide Attribute\";\r\n\r\n    private static final String HIDE_NULL_ATTRIBUTES = \"Hide \" + \"\\\"\" + \"null\" + \"\\\"\" + \" Attributes\";\r\n\r\n    private static final String HIDE_OBJECT = \"Hide Object\";\r\n\r\n    private static final String HIDE_OBJECT_WITH_DEPENDENCIES = \"Hide Object with Dependencies\";\r\n\r\n    private static final String HIDE_REFERENCE = \"Hide Reference\";\r\n\r\n    private static final String HIDE_STATIC_ATTRIBUTES = \"Hide \" + \"\\\"\" + \"static\" + \"\\\"\" + \" Attributes\";\r\n\r\n    private static final String HIDE_UNEXPLORED_ATTRIBUTES = \"Hide Unexplored Attributes\";\r\n\r\n    private static final String OBJECT_VIEW = \"Object View\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_ADD = \"Add\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_CLOSE = \"Close\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_EXPLORE = \"Explore\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_GO_TO = \"Go To\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_REMOVE = \"Remove\";\r\n\r\n    private static final String REMOVE_REFERENCES_WHEN_REMOVED = \"Remove Reference When Removed\";\r\n\r\n    private static final String SAVE = \"Save\";\r\n\r\n    private static final String SHOW_ATTRIBUTES = \"Show Attributes\";\r\n\r\n    private static final String SHOW_REFERENCE = \"Show Reference\";\r\n\r\n    private static final String STRING_NULL = \"null\";\r\n\r\n    private static final String UPDATE_ATTRIBUTES = \"Update Attributes\";\r\n\r\n    private static final String UPDATE_OBJECT = \"Update Object\";\r\n\r\n    private static final String UPDATE_OBJECTS = \"Update Objects\";\r\n\r\n    public static String getABOUT() {\r\n        return ProjectConstants4ObjectExplorer.ABOUT;\r\n    }\r\n\r\n    public static String getCOPY_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.COPY_OBJECT;\r\n    }\r\n\r\n    public static String getEXPLORE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.EXPLORE_OBJECT;\r\n    }\r\n\r\n    public static String getHIDE_ATTRIBUTE() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_ATTRIBUTE;\r\n    }\r\n\r\n    public static String getHIDE_NULL_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_NULL_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getHIDE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_OBJECT;\r\n    }\r\n\r\n    public static String getHIDE_OBJECT_WITH_DEPENDENCIES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_OBJECT_WITH_DEPENDENCIES;\r\n    }\r\n\r\n    public static String getHIDE_REFERENCE() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_REFERENCE;\r\n    }\r\n\r\n    public static String getHIDE_STATIC_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_STATIC_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getHIDE_UNEXPLORED_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_UNEXPLORED_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_ADD() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_ADD;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_CLOSE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_CLOSE;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_EXPLORE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_EXPLORE;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_GO_TO() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_GO_TO;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_REMOVE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_REMOVE;\r\n    }\r\n\r\n    public static String getREMOVE_REFERENCES_WHEN_REMOVED() {\r\n        return ProjectConstants4ObjectExplorer.REMOVE_REFERENCES_WHEN_REMOVED;\r\n    }\r\n\r\n    public static String getSAVE() {\r\n        return ProjectConstants4ObjectExplorer.SAVE;\r\n    }\r\n\r\n    public static String getSHOW_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.SHOW_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getSHOW_REFERENCE() {\r\n        return ProjectConstants4ObjectExplorer.SHOW_REFERENCE;\r\n    }\r\n\r\n    public static String getSTRING_NULL() {\r\n        return ProjectConstants4ObjectExplorer.STRING_NULL;\r\n    }\r\n\r\n    public static String getUPDATE_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getUPDATE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_OBJECT;\r\n    }\r\n\r\n    public static String getUPDATE_OBJECTS() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_OBJECTS;\r\n    }\r\n\r\n    private ProjectConstants4ObjectExplorer() {\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/ProjectConstants4ObjectExplorerTest22.java",
		"test_prompt": "// ProjectConstants4ObjectExplorerTest22.java\npackage de.paragon.explorer;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProjectConstants4ObjectExplorer}.\n* It contains ten unit test cases for the {@link ProjectConstants4ObjectExplorer#getUPDATE_OBJECT()} method.\n*/\nclass ProjectConstants4ObjectExplorerTest22 {"
	},
	{
		"original_code": "// ProjectConstants4ObjectExplorer.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer;\r\n\r\n/**\r\n * Projektkonstanten f�r den ObjectExplorer\r\n *\r\n * @author Stefan Jockenh�vel\r\n */\r\npublic final class ProjectConstants4ObjectExplorer {\r\n\r\n    private static final String ABOUT = \"About\";\r\n\r\n    private static final String COPY_OBJECT = \"Copy Object\";\r\n\r\n    private static final String EXPLORE_OBJECT = \"Explore Object\";\r\n\r\n    private static final String HIDE_ATTRIBUTE = \"Hide Attribute\";\r\n\r\n    private static final String HIDE_NULL_ATTRIBUTES = \"Hide \" + \"\\\"\" + \"null\" + \"\\\"\" + \" Attributes\";\r\n\r\n    private static final String HIDE_OBJECT = \"Hide Object\";\r\n\r\n    private static final String HIDE_OBJECT_WITH_DEPENDENCIES = \"Hide Object with Dependencies\";\r\n\r\n    private static final String HIDE_REFERENCE = \"Hide Reference\";\r\n\r\n    private static final String HIDE_STATIC_ATTRIBUTES = \"Hide \" + \"\\\"\" + \"static\" + \"\\\"\" + \" Attributes\";\r\n\r\n    private static final String HIDE_UNEXPLORED_ATTRIBUTES = \"Hide Unexplored Attributes\";\r\n\r\n    private static final String OBJECT_VIEW = \"Object View\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_ADD = \"Add\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_CLOSE = \"Close\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_EXPLORE = \"Explore\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_GO_TO = \"Go To\";\r\n\r\n    private static final String OBJECT_VIEW_DIALOG_REMOVE = \"Remove\";\r\n\r\n    private static final String REMOVE_REFERENCES_WHEN_REMOVED = \"Remove Reference When Removed\";\r\n\r\n    private static final String SAVE = \"Save\";\r\n\r\n    private static final String SHOW_ATTRIBUTES = \"Show Attributes\";\r\n\r\n    private static final String SHOW_REFERENCE = \"Show Reference\";\r\n\r\n    private static final String STRING_NULL = \"null\";\r\n\r\n    private static final String UPDATE_ATTRIBUTES = \"Update Attributes\";\r\n\r\n    private static final String UPDATE_OBJECT = \"Update Object\";\r\n\r\n    private static final String UPDATE_OBJECTS = \"Update Objects\";\r\n\r\n    public static String getABOUT() {\r\n        return ProjectConstants4ObjectExplorer.ABOUT;\r\n    }\r\n\r\n    public static String getCOPY_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.COPY_OBJECT;\r\n    }\r\n\r\n    public static String getEXPLORE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.EXPLORE_OBJECT;\r\n    }\r\n\r\n    public static String getHIDE_ATTRIBUTE() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_ATTRIBUTE;\r\n    }\r\n\r\n    public static String getHIDE_NULL_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_NULL_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getHIDE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_OBJECT;\r\n    }\r\n\r\n    public static String getHIDE_OBJECT_WITH_DEPENDENCIES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_OBJECT_WITH_DEPENDENCIES;\r\n    }\r\n\r\n    public static String getHIDE_REFERENCE() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_REFERENCE;\r\n    }\r\n\r\n    public static String getHIDE_STATIC_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_STATIC_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getHIDE_UNEXPLORED_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.HIDE_UNEXPLORED_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_ADD() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_ADD;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_CLOSE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_CLOSE;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_EXPLORE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_EXPLORE;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_GO_TO() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_GO_TO;\r\n    }\r\n\r\n    public static String getOBJECT_VIEW_DIALOG_REMOVE() {\r\n        return ProjectConstants4ObjectExplorer.OBJECT_VIEW_DIALOG_REMOVE;\r\n    }\r\n\r\n    public static String getREMOVE_REFERENCES_WHEN_REMOVED() {\r\n        return ProjectConstants4ObjectExplorer.REMOVE_REFERENCES_WHEN_REMOVED;\r\n    }\r\n\r\n    public static String getSAVE() {\r\n        return ProjectConstants4ObjectExplorer.SAVE;\r\n    }\r\n\r\n    public static String getSHOW_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.SHOW_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getSHOW_REFERENCE() {\r\n        return ProjectConstants4ObjectExplorer.SHOW_REFERENCE;\r\n    }\r\n\r\n    public static String getSTRING_NULL() {\r\n        return ProjectConstants4ObjectExplorer.STRING_NULL;\r\n    }\r\n\r\n    public static String getUPDATE_ATTRIBUTES() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_ATTRIBUTES;\r\n    }\r\n\r\n    public static String getUPDATE_OBJECT() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_OBJECT;\r\n    }\r\n\r\n    public static String getUPDATE_OBJECTS() {\r\n        return ProjectConstants4ObjectExplorer.UPDATE_OBJECTS;\r\n    }\r\n\r\n    private ProjectConstants4ObjectExplorer() {\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/ProjectConstants4ObjectExplorerTest23.java",
		"test_prompt": "// ProjectConstants4ObjectExplorerTest23.java\npackage de.paragon.explorer;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProjectConstants4ObjectExplorer}.\n* It contains ten unit test cases for the {@link ProjectConstants4ObjectExplorer#getUPDATE_OBJECTS()} method.\n*/\nclass ProjectConstants4ObjectExplorerTest23 {"
	},
	{
		"original_code": "// FigureStore.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.figure;\r\n\r\n// C.L.\r\n/**\r\n * dient dem Speichern von Figure-Objekten, liefert Inhalt als Instanz einer\r\n * StandardEnumeration zurueck, die verwendete spezielle Implementation heisst\r\n * VectorBasedFigureEnumeration,\r\n *\r\n * FigureStore wird als Default-Speichermedium von CompositeFigure benutzt.\r\n * Gespeichert werden Variablen vom Typ Figure (Interface).\r\n */\r\nimport java.util.Vector;\r\nimport de.paragon.explorer.excp.NoSuchFigureException;\r\nimport de.paragon.explorer.excp.NotAFigureException;\r\nimport de.paragon.explorer.util.ResourceBundlePurchaser;\r\nimport de.paragon.explorer.util.StandardEnumeration;\r\nimport de.paragon.explorer.util.StandardEnumerator;\r\n\r\npublic class FigureStore {\r\n\r\n    private static final String NO_SUCH_FIGURE_EXC = \"figurestore.no_such_figure_exc\";\r\n\r\n    private Vector<Figure> figures;\r\n\r\n    public FigureStore() {\r\n        this.figures = new Vector<Figure>();\r\n    }\r\n\r\n    public void add(Figure f) {\r\n        this.figures.addElement(f);\r\n    }\r\n\r\n    public StandardEnumeration getFigures() throws NotAFigureException {\r\n        return new StandardEnumerator(this.figures);\r\n    }\r\n\r\n    public boolean isInStore(Figure f) {\r\n        for (int i = 0; i < this.figures.size(); i++) {\r\n            if (f == this.figures.elementAt(i)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Entfernt alle Eintraege eines Objektes\r\n     */\r\n    public void remove(Figure f) throws NoSuchFigureException {\r\n        if (!this.isInStore(f)) {\r\n            throw new NoSuchFigureException(ResourceBundlePurchaser.getMessage(FigureStore.NO_SUCH_FIGURE_EXC));\r\n        }\r\n        while (this.isInStore(f)) {\r\n            this.figures.removeElement(f);\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/figure/FigureStoreTest.java",
		"test_prompt": "// FigureStoreTest.java\npackage de.paragon.explorer.figure;\n\n// C.L.\n/**\n * dient dem Speichern von Figure-Objekten, liefert Inhalt als Instanz einer\n * StandardEnumeration zurueck, die verwendete spezielle Implementation heisst\n * VectorBasedFigureEnumeration,\n *\n * FigureStore wird als Default-Speichermedium von CompositeFigure benutzt.\n * Gespeichert werden Variablen vom Typ Figure (Interface).\n */\nimport java.util.Vector;\nimport de.paragon.explorer.excp.NoSuchFigureException;\nimport de.paragon.explorer.excp.NotAFigureException;\nimport de.paragon.explorer.util.ResourceBundlePurchaser;\nimport de.paragon.explorer.util.StandardEnumeration;\nimport de.paragon.explorer.util.StandardEnumerator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FigureStore}.\n* It contains ten unit test cases for the {@link FigureStore#isInStore(Figure)} method.\n*/\nclass FigureStoreTest {"
	},
	{
		"original_code": "// ExplorerFigureBuilder.java\n/**\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\n * Referenzen]\n *\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\n *\n * This program is free software; you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation; either version 3 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program; if not, see <http://www.gnu.org/licenses/>.\n */\npackage de.paragon.explorer.figure;\n\nimport java.util.Vector;\nimport org.apache.log4j.Logger;\nimport de.paragon.explorer.gui.Warning;\nimport de.paragon.explorer.model.AttributeModel;\nimport de.paragon.explorer.model.ObjectModel;\nimport de.paragon.explorer.util.LoggerFactory;\nimport de.paragon.explorer.util.ResourceBundlePurchaser;\nimport de.paragon.explorer.util.StandardEnumeration;\nimport de.paragon.explorer.util.StandardEnumerator;\n\npublic class ExplorerFigureBuilder {\n\n    private static final int NUMBER_15 = 15;\n\n    private static final int NUMBER_25 = 25;\n\n    private static final int NUMBER_24 = 24;\n\n    private static final int NUMBER_5 = 5;\n\n    private static final int NUMBER_50 = 50;\n\n    private static final int NUMBER_20 = 20;\n\n    private static final String EXPLORERFIGUREBUILDER_ERROR_WHILE_BUILDING_EXPLORERMODEL = \"explorerfigurebuilder.error_while_building_explorermodel\";\n\n    private static final String EXPLORERFIGUREBUILDER_ERROR_WHILE_BUILDING_MODEL = \"explorerfigurebuilder.error_while_building_model\";\n\n    private static final String EXPLORERFIGUREBUILDER_ERROR_WHILE_COPYING_FIGURES = \"explorerfigurebuilder.error_while_copying_figures\";\n\n    private static final String EXPLORERFIGUREBUILDER_ERROR_WHILE_DRAWING = \"explorerfigurebuilder.error_while_drawing\";\n\n    private static final String EXPLORERFIGUREBUILDER_ERROR_WHILE_INITIALIZING_1ST_LIST = \"explorerfigurebuilder.error_while_initializing_1st_list\";\n\n    private static final String EXPLORERFIGUREBUILDER_ERROR_WHILE_REMOVING = \"explorerfigurebuilder.error_while_removing\";\n\n    private static final String EXPLORERFIGUREBUILDER_ERROR_WHILE_SETTING_FIGURE_IN_FOREGROUND = \"explorerfigurebuilder.error_while_setting_figure_in_foreground\";\n\n    private static final String EXPLORERFIGUREBUILDER_ERROR_WHILE_SETTING_LBF_BEHIND = \"explorerfigurebuilder.error_while_setting_lbf_behind\";\n\n    private static final Logger logger = LoggerFactory.make();\n\n    private static ExplorerFigureBuilder singleton;\n\n    public static ExplorerFigureBuilder getInstance() {\n        return ExplorerFigureBuilder.getSingleton();\n    }\n\n    private static ExplorerFigureBuilder getSingleton() {\n        if (ExplorerFigureBuilder.singleton == null) {\n            ExplorerFigureBuilder.setSingleton(new ExplorerFigureBuilder());\n        }\n        return ExplorerFigureBuilder.singleton;\n    }\n\n    private static void setSingleton(ExplorerFigureBuilder builder) {\n        ExplorerFigureBuilder.singleton = builder;\n    }\n\n    /**\n     * Kommentar: Diese Methode verknuepft die ListBoxFigure mit der\n     * ExplorerFigure. Im Gegensatz zur Methode addListBoxFigure benoetigt diese\n     * Methode hier die ExplorerFigure, da die StandardConnectionFigure nicht\n     * mit einem Model verknuepft ist, ueber das auf die ExplorerFigure\n     * zurueckgeschlossen werden koennte. Ansonsten macht diese Methode das\n     * gleiche. Das Verknuepfen von ListBox- bzw. StandardConnectionFigure mit\n     * der Explorer- Figure geschieht in zwei verschiedenen Methoden in Hinblick\n     * auf eventuelle, spaetere Unterscheidung zwischen beiden.\n     */\n    public void addConnectionFigure(StandardConnectionFigure conFig, ExplorerFigure explFig) {\n        try {\n            explFig.add(conFig);\n        } catch (Exception ex) {\n            ExplorerFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_BUILDING_EXPLORERMODEL), ex);\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_BUILDING_EXPLORERMODEL));\n        }\n    }\n\n    /**\n     * Kommentar: Diese Methode geht davon aus, dass die Verknuepfungen zwischen\n     * ListBoxFigure, ObjectModel und ExplorerModel bereits existieren. Sie\n     * verknuepft die ListBoxFigure mit der ExplorerFigure.\n     */\n    public void addListBoxFigure(ListBoxFigure liBoFi) {\n        ObjectModel objModl = (ObjectModel) liBoFi.getModel();\n        try {\n            objModl.getExplorerModel().getFigure().add(liBoFi);\n        } catch (Exception ex) {\n            ExplorerFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_BUILDING_EXPLORERMODEL), ex);\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_BUILDING_EXPLORERMODEL));\n        }\n    }\n\n    public ExplorerFigure createNewExplorerFigure() {\n        return new ExplorerFigure();\n    }\n\n    /**\n     * Kommentar: Diese Methode geht davon aus, dass die uebergebene\n     * ListBoxFigure nicht die erste ist. Soll heissen, dass anhand der\n     * ListBoxFigure die Graphics ermittelt werden koennen.\n     */\n    public void draw(ListBoxFigure liBoFi) {\n        ((ExplorerFigure) liBoFi.getParent()).repaint();\n    }\n\n    /**\n     * Kommentar: Der Methodenname dieser Methode drueckt es schon aus:\n     * drawInForeground bedeutet, eine Figure zuerst in den Verdergrund zu\n     * setzen und dann zu zeichnen. Ein vorheriges Loeschen ist nicht noetig, da\n     * es nichts gibt, das vorher verdeckt war und nachher zu sehen sein wird.\n     */\n    public void drawInForeground(ListBoxFigure liBoFi) {\n        this.setInForeground(liBoFi);\n        this.draw(liBoFi);\n    }\n\n    private int getFigureHeight(Figure figure) {\n        int tempHeight = 0;\n        try {\n            tempHeight = figure.getDisplayBox().getRectangle().height;\n        } catch (Exception ex) {\n            ExplorerFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_BUILDING_MODEL), ex);\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_BUILDING_MODEL));\n        }\n        return tempHeight;\n    }\n\n    /**\n     * Kommentar: Eine Kopie der Aufzaehlung muss aus folgenden Grund extra\n     * erstellt werden: Der Operator new StandardEnumerator(Vector v) erzeugt\n     * einen neuen StandardEnumerator, der auf den selben, uebergebenen Vector v\n     * zeigt. Ist dies der Vector aus dem FigureStore, so werden neue und alte\n     * StandardEnumeration nicht unabhaengig voneinander bearbeitet.\n     *\n     * @return StandardEnumeration\n     */\n    private StandardEnumeration getFiguresOf(ExplorerFigure explFig) {\n        StandardEnumeration returnEnum = new StandardEnumerator();\n        StandardEnumeration tempEnum = null;\n        try {\n            tempEnum = explFig.getFigures();\n        } catch (Exception ex) {\n            ExplorerFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_COPYING_FIGURES), ex);\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_COPYING_FIGURES));\n        }\n        if (tempEnum != null) {\n            while (tempEnum.hasMoreElements()) {\n                returnEnum.addElement(tempEnum.nextElement());\n            }\n        }\n        return returnEnum;\n    }\n\n    private int getFigureWidth(Figure figure) {\n        int tempWidth = 0;\n        try {\n            tempWidth = figure.getDisplayBox().getRectangle().width;\n        } catch (Exception ex) {\n            ExplorerFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_BUILDING_MODEL), ex);\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_BUILDING_MODEL));\n        }\n        return tempWidth;\n    }\n\n    /**\n     * Kommentar: Diese Methode geht davon aus, dass die ListBoxFigure schon in\n     * allen Variablen definiert ist und nur noch in Position und Groesse in die\n     * ExplorerFigure einge- baut werden muss.\n     */\n    public void initialize1stList(ListBoxFigure liBoFi) {\n        ExplorerFigure explFig = (ExplorerFigure) liBoFi.getParent();\n        try {\n            liBoFi.moveBy(ExplorerFigureBuilder.NUMBER_20, ExplorerFigureBuilder.NUMBER_50);\n        } catch (Exception ex) {\n            ExplorerFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_INITIALIZING_1ST_LIST), ex);\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_INITIALIZING_1ST_LIST));\n        }\n        this.setFigureWidth(explFig, ExplorerFigureBuilder.NUMBER_20 + this.getFigureWidth(liBoFi));\n        this.setFigureHeight(explFig, ExplorerFigureBuilder.NUMBER_50 + this.getFigureHeight(liBoFi));\n    }\n\n    /**\n     * Kommentar: Diese Methode geht davon aus, dass die ListBoxFigure schon in\n     * allen Variablen definiert ist und nur noch in Position und Groesse in die\n     * ExplorerFigure einge- baut werden muss.\n     */\n    public void initializeCopyList(ListBoxFigure liBoFi) {\n        ExplorerFigure explFig;\n        java.awt.Point p;\n        int x;\n        int y;\n        explFig = (ExplorerFigure) liBoFi.getParent();\n        p = javax.swing.SwingUtilities.convertPoint(explFig.getFrame(), ExplorerFigureBuilder.NUMBER_5, ExplorerFigureBuilder.NUMBER_24, explFig.getPanel());\n        x = (int) p.getX() + ExplorerFigureBuilder.NUMBER_20;\n        y = (int) p.getY() + ExplorerFigureBuilder.NUMBER_20;\n        try {\n            liBoFi.moveBy(x, y);\n        } catch (Exception ex) {\n            ExplorerFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_INITIALIZING_1ST_LIST), ex);\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_INITIALIZING_1ST_LIST));\n        }\n        this.setFigureWidth(explFig, x + this.getFigureWidth(liBoFi));\n        this.setFigureHeight(explFig, y + this.getFigureHeight(liBoFi));\n    }\n\n    public void initializeListFor(ObjectModel objModl, AttributeModel attrModl) {\n        ListBoxFigure liBoFi = (ListBoxFigure) objModl.getFigure();\n        TextBoxFigure teBoFi = (TextBoxFigure) attrModl.getFigure();\n        try {\n            int x = teBoFi.getBounds().x + teBoFi.getBounds().width + ExplorerFigureBuilder.NUMBER_15;\n            int y = teBoFi.getBounds().y;\n            if (!teBoFi.isVisible()) {\n                ObjectModel myObjModl = (ObjectModel) ((ListBoxFigure) teBoFi.getParent()).getModel();\n                Vector<?> attrModls = myObjModl.getAttributeModels().getVector();\n                for (int i = 0; i < attrModls.size(); i++) {\n                    AttributeModel myAttrModl = (AttributeModel) attrModls.elementAt(i);\n                    if (myAttrModl.getConnectionModel() != null) {\n                        y = y + ExplorerFigureBuilder.NUMBER_25;\n                    }\n                }\n            }\n            liBoFi.moveBy(x, y);\n        } catch (Exception ex) {\n            ExplorerFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_INITIALIZING_1ST_LIST), ex);\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_INITIALIZING_1ST_LIST));\n        }\n    }\n\n    /**\n     * Kommentar: Das Verschieben funktioniert so: Anhand der ListBoxFigure\n     * bestimmt diese Methode die zugehoerige ExplorerFigure. Diese wird\n     * geloescht. Dann werden die zugehoerigen Daten der ListBoxFigure\n     * verschoben. Danach wird die gesamte ExplorerFigure wieder gezeichnet.\n     */\n    public void moveFigureBy(ListBoxFigure liBoFi, int x, int y) {\n        // ExplorerFigure explFig = (ExplorerFigure) liBoFi.getParent();\n        // explFig.clear();\n        try {\n            liBoFi.moveBy(x, y);\n            // explFig.draw();\n        } catch (Exception ex) {\n            ExplorerFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_DRAWING), ex);\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_DRAWING));\n        }\n    }\n\n    /**\n     * Kommentar: Zunaechst wird die betreffende Figur aus der Liste aller\n     * Figuren entfernt. Dann wird eine Kopie der Liste der uebrigen Figuren\n     * erstellt. Die betreffende Figur wird der Liste aller Figuren wieder\n     * hinzugefuegt, danach die uebri- gen. Auf diese Weise wird die betreffende\n     * Figur zuerst gezeichnet und dann von allen anderen uebermalt. Eine Kopie\n     * der Aufzaehlung muss aus folgenden Grund extra erstellt werden: Der\n     * Operator new StandardEnumerator(Vector v) erzeugt einen neuen\n     * StandardEnumerator, der auf den selben, uebergebenen Vector v zeigt. Ist\n     * dies der Vector aus dem FigureStore, so werden neue und alte\n     * StandardEnumeration nicht unabhaengig voneinander bearbeitet.\n     */\n    public void placeBehind(ListBoxFigure liBoFi) {\n        ExplorerFigure explFig = (ExplorerFigure) liBoFi.getParent();\n        StandardEnumeration enumeration;\n        try {\n            explFig.remove(liBoFi);\n            enumeration = this.getFiguresOf(explFig);\n            explFig.removeAll();\n            explFig.add(liBoFi);\n            explFig.addAll(enumeration);\n        } catch (Exception ex) {\n            ExplorerFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_SETTING_LBF_BEHIND), ex);\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_SETTING_LBF_BEHIND));\n        }\n    }\n\n    /**\n     * Kommentar: Diese Methode geht davon aus, dass das zugehoerige ObjectModel\n     * bereits geloescht worden ist. Das Loeschen einer ListBoxFigure besteht\n     * darin, sie aus der Liste figureStore der ExplorerFigure zu entfernen.\n     */\n    public void removeFromExplorer(ListBoxFigure liBoFi) {\n        try {\n            if (liBoFi.getParent() != null) {\n                liBoFi.getParent().remove(liBoFi);\n            }\n        } catch (Exception ex) {\n            ExplorerFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_REMOVING), ex);\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_REMOVING));\n        }\n    }\n\n    private void setFigureHeight(Figure figure, int y) {\n        try {\n            figure.getDisplayBox().getRectangle().height = y;\n        } catch (Exception ex) {\n            ExplorerFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_BUILDING_MODEL), ex);\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_BUILDING_MODEL));\n        }\n    }\n\n    private void setFigureWidth(Figure figure, int x) {\n        try {\n            figure.getDisplayBox().getRectangle().width = x;\n        } catch (Exception ex) {\n            ExplorerFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_BUILDING_MODEL), ex);\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_BUILDING_MODEL));\n        }\n    }\n\n    /**\n     * Kommentar: Diese Methode geht davon aus, dass die uebergebene Figure\n     * entweder eine ListBoxFigure oder eine ConnectionFigure ist. Diese Methode\n     * entfernt die entsprechende List- BoxFigure aus der Menge aller\n     * ListBoxFigures und setzt sie ans Ende dieser Liste. Es wird nicht\n     * gezeichnet!\n     */\n    public void setInForeground(Figure figure) {\n        ExplorerFigure explFig = (ExplorerFigure) figure.getParent();\n        try {\n            explFig.getFigures().removeElement(figure);\n            explFig.add(figure);\n        } catch (Exception ex) {\n            ExplorerFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_SETTING_FIGURE_IN_FOREGROUND), ex);\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_SETTING_FIGURE_IN_FOREGROUND));\n        }\n    }\n\n    public void update(ExplorerFigure explFig) {\n        explFig.repaint();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/figure/ExplorerFigureBuilderTest0.java",
		"test_prompt": "// ExplorerFigureBuilderTest0.java\npackage de.paragon.explorer.figure;\n\nimport java.util.Vector;\nimport org.apache.log4j.Logger;\nimport de.paragon.explorer.gui.Warning;\nimport de.paragon.explorer.model.AttributeModel;\nimport de.paragon.explorer.model.ObjectModel;\nimport de.paragon.explorer.util.LoggerFactory;\nimport de.paragon.explorer.util.ResourceBundlePurchaser;\nimport de.paragon.explorer.util.StandardEnumeration;\nimport de.paragon.explorer.util.StandardEnumerator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ExplorerFigureBuilder}.\n* It contains ten unit test cases for the {@link ExplorerFigureBuilder#getInstance()} method.\n*/\nclass ExplorerFigureBuilderTest0 {"
	},
	{
		"original_code": "// ExplorerFigureBuilder.java\n/**\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\n * Referenzen]\n *\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\n *\n * This program is free software; you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation; either version 3 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program; if not, see <http://www.gnu.org/licenses/>.\n */\npackage de.paragon.explorer.figure;\n\nimport java.util.Vector;\nimport org.apache.log4j.Logger;\nimport de.paragon.explorer.gui.Warning;\nimport de.paragon.explorer.model.AttributeModel;\nimport de.paragon.explorer.model.ObjectModel;\nimport de.paragon.explorer.util.LoggerFactory;\nimport de.paragon.explorer.util.ResourceBundlePurchaser;\nimport de.paragon.explorer.util.StandardEnumeration;\nimport de.paragon.explorer.util.StandardEnumerator;\n\npublic class ExplorerFigureBuilder {\n\n    private static final int NUMBER_15 = 15;\n\n    private static final int NUMBER_25 = 25;\n\n    private static final int NUMBER_24 = 24;\n\n    private static final int NUMBER_5 = 5;\n\n    private static final int NUMBER_50 = 50;\n\n    private static final int NUMBER_20 = 20;\n\n    private static final String EXPLORERFIGUREBUILDER_ERROR_WHILE_BUILDING_EXPLORERMODEL = \"explorerfigurebuilder.error_while_building_explorermodel\";\n\n    private static final String EXPLORERFIGUREBUILDER_ERROR_WHILE_BUILDING_MODEL = \"explorerfigurebuilder.error_while_building_model\";\n\n    private static final String EXPLORERFIGUREBUILDER_ERROR_WHILE_COPYING_FIGURES = \"explorerfigurebuilder.error_while_copying_figures\";\n\n    private static final String EXPLORERFIGUREBUILDER_ERROR_WHILE_DRAWING = \"explorerfigurebuilder.error_while_drawing\";\n\n    private static final String EXPLORERFIGUREBUILDER_ERROR_WHILE_INITIALIZING_1ST_LIST = \"explorerfigurebuilder.error_while_initializing_1st_list\";\n\n    private static final String EXPLORERFIGUREBUILDER_ERROR_WHILE_REMOVING = \"explorerfigurebuilder.error_while_removing\";\n\n    private static final String EXPLORERFIGUREBUILDER_ERROR_WHILE_SETTING_FIGURE_IN_FOREGROUND = \"explorerfigurebuilder.error_while_setting_figure_in_foreground\";\n\n    private static final String EXPLORERFIGUREBUILDER_ERROR_WHILE_SETTING_LBF_BEHIND = \"explorerfigurebuilder.error_while_setting_lbf_behind\";\n\n    private static final Logger logger = LoggerFactory.make();\n\n    private static ExplorerFigureBuilder singleton;\n\n    public static ExplorerFigureBuilder getInstance() {\n        return ExplorerFigureBuilder.getSingleton();\n    }\n\n    private static ExplorerFigureBuilder getSingleton() {\n        if (ExplorerFigureBuilder.singleton == null) {\n            ExplorerFigureBuilder.setSingleton(new ExplorerFigureBuilder());\n        }\n        return ExplorerFigureBuilder.singleton;\n    }\n\n    private static void setSingleton(ExplorerFigureBuilder builder) {\n        ExplorerFigureBuilder.singleton = builder;\n    }\n\n    /**\n     * Kommentar: Diese Methode verknuepft die ListBoxFigure mit der\n     * ExplorerFigure. Im Gegensatz zur Methode addListBoxFigure benoetigt diese\n     * Methode hier die ExplorerFigure, da die StandardConnectionFigure nicht\n     * mit einem Model verknuepft ist, ueber das auf die ExplorerFigure\n     * zurueckgeschlossen werden koennte. Ansonsten macht diese Methode das\n     * gleiche. Das Verknuepfen von ListBox- bzw. StandardConnectionFigure mit\n     * der Explorer- Figure geschieht in zwei verschiedenen Methoden in Hinblick\n     * auf eventuelle, spaetere Unterscheidung zwischen beiden.\n     */\n    public void addConnectionFigure(StandardConnectionFigure conFig, ExplorerFigure explFig) {\n        try {\n            explFig.add(conFig);\n        } catch (Exception ex) {\n            ExplorerFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_BUILDING_EXPLORERMODEL), ex);\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_BUILDING_EXPLORERMODEL));\n        }\n    }\n\n    /**\n     * Kommentar: Diese Methode geht davon aus, dass die Verknuepfungen zwischen\n     * ListBoxFigure, ObjectModel und ExplorerModel bereits existieren. Sie\n     * verknuepft die ListBoxFigure mit der ExplorerFigure.\n     */\n    public void addListBoxFigure(ListBoxFigure liBoFi) {\n        ObjectModel objModl = (ObjectModel) liBoFi.getModel();\n        try {\n            objModl.getExplorerModel().getFigure().add(liBoFi);\n        } catch (Exception ex) {\n            ExplorerFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_BUILDING_EXPLORERMODEL), ex);\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_BUILDING_EXPLORERMODEL));\n        }\n    }\n\n    public ExplorerFigure createNewExplorerFigure() {\n        return new ExplorerFigure();\n    }\n\n    /**\n     * Kommentar: Diese Methode geht davon aus, dass die uebergebene\n     * ListBoxFigure nicht die erste ist. Soll heissen, dass anhand der\n     * ListBoxFigure die Graphics ermittelt werden koennen.\n     */\n    public void draw(ListBoxFigure liBoFi) {\n        ((ExplorerFigure) liBoFi.getParent()).repaint();\n    }\n\n    /**\n     * Kommentar: Der Methodenname dieser Methode drueckt es schon aus:\n     * drawInForeground bedeutet, eine Figure zuerst in den Verdergrund zu\n     * setzen und dann zu zeichnen. Ein vorheriges Loeschen ist nicht noetig, da\n     * es nichts gibt, das vorher verdeckt war und nachher zu sehen sein wird.\n     */\n    public void drawInForeground(ListBoxFigure liBoFi) {\n        this.setInForeground(liBoFi);\n        this.draw(liBoFi);\n    }\n\n    private int getFigureHeight(Figure figure) {\n        int tempHeight = 0;\n        try {\n            tempHeight = figure.getDisplayBox().getRectangle().height;\n        } catch (Exception ex) {\n            ExplorerFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_BUILDING_MODEL), ex);\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_BUILDING_MODEL));\n        }\n        return tempHeight;\n    }\n\n    /**\n     * Kommentar: Eine Kopie der Aufzaehlung muss aus folgenden Grund extra\n     * erstellt werden: Der Operator new StandardEnumerator(Vector v) erzeugt\n     * einen neuen StandardEnumerator, der auf den selben, uebergebenen Vector v\n     * zeigt. Ist dies der Vector aus dem FigureStore, so werden neue und alte\n     * StandardEnumeration nicht unabhaengig voneinander bearbeitet.\n     *\n     * @return StandardEnumeration\n     */\n    private StandardEnumeration getFiguresOf(ExplorerFigure explFig) {\n        StandardEnumeration returnEnum = new StandardEnumerator();\n        StandardEnumeration tempEnum = null;\n        try {\n            tempEnum = explFig.getFigures();\n        } catch (Exception ex) {\n            ExplorerFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_COPYING_FIGURES), ex);\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_COPYING_FIGURES));\n        }\n        if (tempEnum != null) {\n            while (tempEnum.hasMoreElements()) {\n                returnEnum.addElement(tempEnum.nextElement());\n            }\n        }\n        return returnEnum;\n    }\n\n    private int getFigureWidth(Figure figure) {\n        int tempWidth = 0;\n        try {\n            tempWidth = figure.getDisplayBox().getRectangle().width;\n        } catch (Exception ex) {\n            ExplorerFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_BUILDING_MODEL), ex);\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_BUILDING_MODEL));\n        }\n        return tempWidth;\n    }\n\n    /**\n     * Kommentar: Diese Methode geht davon aus, dass die ListBoxFigure schon in\n     * allen Variablen definiert ist und nur noch in Position und Groesse in die\n     * ExplorerFigure einge- baut werden muss.\n     */\n    public void initialize1stList(ListBoxFigure liBoFi) {\n        ExplorerFigure explFig = (ExplorerFigure) liBoFi.getParent();\n        try {\n            liBoFi.moveBy(ExplorerFigureBuilder.NUMBER_20, ExplorerFigureBuilder.NUMBER_50);\n        } catch (Exception ex) {\n            ExplorerFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_INITIALIZING_1ST_LIST), ex);\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_INITIALIZING_1ST_LIST));\n        }\n        this.setFigureWidth(explFig, ExplorerFigureBuilder.NUMBER_20 + this.getFigureWidth(liBoFi));\n        this.setFigureHeight(explFig, ExplorerFigureBuilder.NUMBER_50 + this.getFigureHeight(liBoFi));\n    }\n\n    /**\n     * Kommentar: Diese Methode geht davon aus, dass die ListBoxFigure schon in\n     * allen Variablen definiert ist und nur noch in Position und Groesse in die\n     * ExplorerFigure einge- baut werden muss.\n     */\n    public void initializeCopyList(ListBoxFigure liBoFi) {\n        ExplorerFigure explFig;\n        java.awt.Point p;\n        int x;\n        int y;\n        explFig = (ExplorerFigure) liBoFi.getParent();\n        p = javax.swing.SwingUtilities.convertPoint(explFig.getFrame(), ExplorerFigureBuilder.NUMBER_5, ExplorerFigureBuilder.NUMBER_24, explFig.getPanel());\n        x = (int) p.getX() + ExplorerFigureBuilder.NUMBER_20;\n        y = (int) p.getY() + ExplorerFigureBuilder.NUMBER_20;\n        try {\n            liBoFi.moveBy(x, y);\n        } catch (Exception ex) {\n            ExplorerFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_INITIALIZING_1ST_LIST), ex);\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_INITIALIZING_1ST_LIST));\n        }\n        this.setFigureWidth(explFig, x + this.getFigureWidth(liBoFi));\n        this.setFigureHeight(explFig, y + this.getFigureHeight(liBoFi));\n    }\n\n    public void initializeListFor(ObjectModel objModl, AttributeModel attrModl) {\n        ListBoxFigure liBoFi = (ListBoxFigure) objModl.getFigure();\n        TextBoxFigure teBoFi = (TextBoxFigure) attrModl.getFigure();\n        try {\n            int x = teBoFi.getBounds().x + teBoFi.getBounds().width + ExplorerFigureBuilder.NUMBER_15;\n            int y = teBoFi.getBounds().y;\n            if (!teBoFi.isVisible()) {\n                ObjectModel myObjModl = (ObjectModel) ((ListBoxFigure) teBoFi.getParent()).getModel();\n                Vector<?> attrModls = myObjModl.getAttributeModels().getVector();\n                for (int i = 0; i < attrModls.size(); i++) {\n                    AttributeModel myAttrModl = (AttributeModel) attrModls.elementAt(i);\n                    if (myAttrModl.getConnectionModel() != null) {\n                        y = y + ExplorerFigureBuilder.NUMBER_25;\n                    }\n                }\n            }\n            liBoFi.moveBy(x, y);\n        } catch (Exception ex) {\n            ExplorerFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_INITIALIZING_1ST_LIST), ex);\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_INITIALIZING_1ST_LIST));\n        }\n    }\n\n    /**\n     * Kommentar: Das Verschieben funktioniert so: Anhand der ListBoxFigure\n     * bestimmt diese Methode die zugehoerige ExplorerFigure. Diese wird\n     * geloescht. Dann werden die zugehoerigen Daten der ListBoxFigure\n     * verschoben. Danach wird die gesamte ExplorerFigure wieder gezeichnet.\n     */\n    public void moveFigureBy(ListBoxFigure liBoFi, int x, int y) {\n        // ExplorerFigure explFig = (ExplorerFigure) liBoFi.getParent();\n        // explFig.clear();\n        try {\n            liBoFi.moveBy(x, y);\n            // explFig.draw();\n        } catch (Exception ex) {\n            ExplorerFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_DRAWING), ex);\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_DRAWING));\n        }\n    }\n\n    /**\n     * Kommentar: Zunaechst wird die betreffende Figur aus der Liste aller\n     * Figuren entfernt. Dann wird eine Kopie der Liste der uebrigen Figuren\n     * erstellt. Die betreffende Figur wird der Liste aller Figuren wieder\n     * hinzugefuegt, danach die uebri- gen. Auf diese Weise wird die betreffende\n     * Figur zuerst gezeichnet und dann von allen anderen uebermalt. Eine Kopie\n     * der Aufzaehlung muss aus folgenden Grund extra erstellt werden: Der\n     * Operator new StandardEnumerator(Vector v) erzeugt einen neuen\n     * StandardEnumerator, der auf den selben, uebergebenen Vector v zeigt. Ist\n     * dies der Vector aus dem FigureStore, so werden neue und alte\n     * StandardEnumeration nicht unabhaengig voneinander bearbeitet.\n     */\n    public void placeBehind(ListBoxFigure liBoFi) {\n        ExplorerFigure explFig = (ExplorerFigure) liBoFi.getParent();\n        StandardEnumeration enumeration;\n        try {\n            explFig.remove(liBoFi);\n            enumeration = this.getFiguresOf(explFig);\n            explFig.removeAll();\n            explFig.add(liBoFi);\n            explFig.addAll(enumeration);\n        } catch (Exception ex) {\n            ExplorerFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_SETTING_LBF_BEHIND), ex);\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_SETTING_LBF_BEHIND));\n        }\n    }\n\n    /**\n     * Kommentar: Diese Methode geht davon aus, dass das zugehoerige ObjectModel\n     * bereits geloescht worden ist. Das Loeschen einer ListBoxFigure besteht\n     * darin, sie aus der Liste figureStore der ExplorerFigure zu entfernen.\n     */\n    public void removeFromExplorer(ListBoxFigure liBoFi) {\n        try {\n            if (liBoFi.getParent() != null) {\n                liBoFi.getParent().remove(liBoFi);\n            }\n        } catch (Exception ex) {\n            ExplorerFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_REMOVING), ex);\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_REMOVING));\n        }\n    }\n\n    private void setFigureHeight(Figure figure, int y) {\n        try {\n            figure.getDisplayBox().getRectangle().height = y;\n        } catch (Exception ex) {\n            ExplorerFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_BUILDING_MODEL), ex);\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_BUILDING_MODEL));\n        }\n    }\n\n    private void setFigureWidth(Figure figure, int x) {\n        try {\n            figure.getDisplayBox().getRectangle().width = x;\n        } catch (Exception ex) {\n            ExplorerFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_BUILDING_MODEL), ex);\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_BUILDING_MODEL));\n        }\n    }\n\n    /**\n     * Kommentar: Diese Methode geht davon aus, dass die uebergebene Figure\n     * entweder eine ListBoxFigure oder eine ConnectionFigure ist. Diese Methode\n     * entfernt die entsprechende List- BoxFigure aus der Menge aller\n     * ListBoxFigures und setzt sie ans Ende dieser Liste. Es wird nicht\n     * gezeichnet!\n     */\n    public void setInForeground(Figure figure) {\n        ExplorerFigure explFig = (ExplorerFigure) figure.getParent();\n        try {\n            explFig.getFigures().removeElement(figure);\n            explFig.add(figure);\n        } catch (Exception ex) {\n            ExplorerFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_SETTING_FIGURE_IN_FOREGROUND), ex);\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_SETTING_FIGURE_IN_FOREGROUND));\n        }\n    }\n\n    public void update(ExplorerFigure explFig) {\n        explFig.repaint();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/figure/ExplorerFigureBuilderTest1.java",
		"test_prompt": "// ExplorerFigureBuilderTest1.java\npackage de.paragon.explorer.figure;\n\nimport java.util.Vector;\nimport org.apache.log4j.Logger;\nimport de.paragon.explorer.gui.Warning;\nimport de.paragon.explorer.model.AttributeModel;\nimport de.paragon.explorer.model.ObjectModel;\nimport de.paragon.explorer.util.LoggerFactory;\nimport de.paragon.explorer.util.ResourceBundlePurchaser;\nimport de.paragon.explorer.util.StandardEnumeration;\nimport de.paragon.explorer.util.StandardEnumerator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ExplorerFigureBuilder}.\n* It contains ten unit test cases for the {@link ExplorerFigureBuilder#createNewExplorerFigure()} method.\n*/\nclass ExplorerFigureBuilderTest1 {"
	},
	{
		"original_code": "// FilledRectangleFigure.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.figure;\r\n\r\n/**\r\n * Klassenbeschreibung:\r\n *\r\n * Ein Objekt dieser Klasse wird referenziert von: ListBoxFigure, zusammen mit\r\n * den TextBoxFigures.\r\n */\r\nimport java.awt.Graphics;\r\n\r\npublic class FilledRectangleFigure extends RectangleFigure {\r\n\r\n    public FilledRectangleFigure() {\r\n        super();\r\n    }\r\n\r\n    public FilledRectangleFigure(int x, int y, int width, int height) {\r\n        super(x, y, width, height);\r\n    }\r\n\r\n    @Override\r\n    public void draw(Graphics g) {\r\n        int x = this.getDisplayBox().getRectangle().x;\r\n        int y = this.getDisplayBox().getRectangle().y;\r\n        int width = this.getDisplayBox().getRectangle().width;\r\n        int height = this.getDisplayBox().getRectangle().height;\r\n        g.fillRect(x, y, width, height);\r\n    }\r\n\r\n    @Override\r\n    public boolean isVisible() {\r\n        return true;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/figure/FilledRectangleFigureTest.java",
		"test_prompt": "// FilledRectangleFigureTest.java\npackage de.paragon.explorer.figure;\n\n/**\n * Klassenbeschreibung:\n *\n * Ein Objekt dieser Klasse wird referenziert von: ListBoxFigure, zusammen mit\n * den TextBoxFigures.\n */\nimport java.awt.Graphics;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FilledRectangleFigure}.\n* It contains ten unit test cases for the {@link FilledRectangleFigure#isVisible()} method.\n*/\nclass FilledRectangleFigureTest {"
	},
	{
		"original_code": "// TextBoxFigure.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.figure;\r\n\r\nimport java.awt.Color;\r\nimport java.awt.Font;\r\nimport java.awt.Graphics;\r\nimport java.awt.Rectangle;\r\nimport de.paragon.explorer.model.Model;\r\n\r\n/**\r\n * Klassenbeschreibung:\r\n *\r\n * Instanzvariablen: text: Der String, der innerhalb der TextBoxFigure darge-\r\n * stellt werden soll, model: Das Model, das inhaltliche Aspekte der Figure\r\n * haelt. Im Falle des Explorers z.Bsp. sind dies: a) ObjectHeaderModel, falls\r\n * die TextBoxFigure den Namen des Objektes darstellt, b) AttributeModel, falls\r\n * die TextBoxFigure den Namen ei- nes Feldes des Objektes darstellt. visible:\r\n * Eine Variable des Typs boolean, die angibt, ob die Figur bei Zeichnung\r\n * sichtbar oder unsichtbar ist.\r\n *\r\n * Ein Objekt dieser Klasse wird referenziert von: StandardConnectionFigure (als\r\n * startFigure): Die Connection- figur, die auf eine andere Figur zeigt. In\r\n * diesem Falle ist das Model dieser Figur ein AttributeModel,\r\n * StandardConnectionFigure (als endFigure): Die Connection- figure, die von\r\n * einer anderen Figur auf diese zeigt. In diesem Falle ist das Model ein\r\n * ObjectHeaderModel.\r\n */\r\npublic class TextBoxFigure extends ColorRectangleFigure {\r\n\r\n    private static final int NUMBER_3 = 3;\r\n\r\n    private String text = \"\";\r\n\r\n    private Model model;\r\n\r\n    private boolean visible = false;\r\n\r\n    private java.awt.Font font;\r\n\r\n    private java.awt.Color foreground;\r\n\r\n    public TextBoxFigure() {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * provisorische Einbettung des Textes in das umgebende Rechteck Kommentar:\r\n     * Das Zeichnen einer Figur wird abhaengig gemacht von \"visible\". Falls\r\n     * \"visible\", wird zunaechst der Rahmen und dann der Text gezeichnet.\r\n     */\r\n    @Override\r\n    public void draw(Graphics g) {\r\n        if (this.isVisible()) {\r\n            super.draw(g);\r\n            int leftMargin = TextBoxFigure.NUMBER_3;\r\n            int bottomHeight = 1;\r\n            String localtext = this.getText();\r\n            int descent = g.getFontMetrics(this.getFont()).getMaxDescent();\r\n            Rectangle rect = this.getDisplayBox().getRectangle();\r\n            int x = rect.x + leftMargin;\r\n            int y = rect.y + rect.height - descent - bottomHeight;\r\n            Font localFont = g.getFont();\r\n            g.setFont(this.getFont());\r\n            Color color = g.getColor();\r\n            g.setColor(this.getForeground());\r\n            g.drawString(localtext, x, y);\r\n            g.setFont(localFont);\r\n            g.setColor(color);\r\n        }\r\n    }\r\n\r\n    public Font getFont() {\r\n        return this.font;\r\n    }\r\n\r\n    public Color getForeground() {\r\n        return this.foreground;\r\n    }\r\n\r\n    public Model getModel() {\r\n        return this.model;\r\n    }\r\n\r\n    public String getText() {\r\n        return this.text;\r\n    }\r\n\r\n    @Override\r\n    public boolean isVisible() {\r\n        return this.visible;\r\n    }\r\n\r\n    public void setFont(Font newFont) {\r\n        this.font = newFont;\r\n    }\r\n\r\n    public void setForeground(Color newForeground) {\r\n        this.foreground = newForeground;\r\n    }\r\n\r\n    public void setModel(Model newModel) {\r\n        this.model = newModel;\r\n    }\r\n\r\n    public void setText(String newText) {\r\n        this.text = newText;\r\n    }\r\n\r\n    public void setUnvisible() {\r\n        this.visible = false;\r\n    }\r\n\r\n    public void setVisible() {\r\n        this.visible = true;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/figure/TextBoxFigureTest.java",
		"test_prompt": "// TextBoxFigureTest.java\npackage de.paragon.explorer.figure;\n\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\nimport de.paragon.explorer.model.Model;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TextBoxFigure}.\n* It contains ten unit test cases for the {@link TextBoxFigure#isVisible()} method.\n*/\nclass TextBoxFigureTest {"
	},
	{
		"original_code": "// AbstractFigure.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.figure;\r\n\r\nimport java.awt.Dimension;\r\nimport java.awt.Graphics;\r\nimport java.awt.Rectangle;\r\nimport de.paragon.explorer.excp.FigureEventException;\r\nimport de.paragon.explorer.excp.FigureException;\r\nimport de.paragon.explorer.gui.DisplayBox;\r\nimport de.paragon.explorer.util.ResourceBundlePurchaser;\r\nimport de.paragon.explorer.util.StandardEnumeration;\r\n\r\n/**\r\n * Kommentar: Diese Klasse implementiert Figure und gibt Default-Implementation\r\n * fuer die grafischen Basisklassen vor Beschreibung der Kasse:\r\n *\r\n * Die Instanzvariablen: parent: normale Hierarchieverknuepfung, die Figur, von\r\n * der diese Figur Teilfigur ist.\r\n */\r\npublic abstract class AbstractFigure implements Figure {\r\n\r\n    private static final String ERROR_WHILE_DISPATCHING_APPEARED = \"abstractfigure.error_while_dispatching_appeared\";\r\n\r\n    private static final String ERROR_WHILE_DISPATCHING_INVALIDATED = \"abstractfigure.error_while_dispatching_invalidated\";\r\n\r\n    private static final String LISTENER_DOESNT_KNOW2HANDLE_FIGURE_CHANGE_EVENT = \"abstractfigure.listener_doesnt_know2handle_figure_change_event\";\r\n\r\n    private static final String TRYING2ADD_A_FIGURE2A_BASICFIGURE = \"abstractfigure.trying2add_a_figure2a_basicfigure\";\r\n\r\n    private static final String TRYING2ADD_PARTS2A_NON_COMPOSITE_FIGURE = \"abstractfigure.trying2add_parts2a_non_composite_figure\";\r\n\r\n    private static final String TRYING2CHECK_WHETER_A_FIGURE_IS_PART_OF_A_NON_COMPOSITE_FIGURE = \"abstractfigure.trying2check_wheter_a_figure_is_part_of_a_non_composite_figure\";\r\n\r\n    private static final String TRYING2GET_PARTS_OF_A_BASIC_FIGURE = \"abstractfigure.trying2get_parts_of_a_basic_figure\";\r\n\r\n    private static final String TRYING2REMOVE_ALL_FROM_A_BASIC_FIGURE = \"abstractfigure.trying2remove_all_from_a_basic_figure\";\r\n\r\n    private static final String TRYING2REMOVE_FROM_A_BASIC_FIGURE = \"abstractfigure.trying2remove_from_a_basic_figure\";\r\n\r\n    private static final String TRYING2SET_PARTS_OF_A_NON_COMPOSITE_FIGURE = \"abstractfigure.trying2set_parts_of_a_non_composite_figure\";\r\n\r\n    private FigureChangeManager changeManager;\r\n\r\n    private Figure parent;\r\n\r\n    // gemeinsames Eventhandling von E.Gamma implizit angesprochen\r\n    // durch Implementationsbeispiel in Figure\r\n    //\r\n    // changeManager zur Kapselung der Listenerverwaltung ist\r\n    // hier Idee von C.L., im Observer Pattern aber auch angesprochen\r\n    //\r\n    // fuer Defaultverhalten des Eventhandlings\r\n    protected AbstractFigure() {\r\n        this.changeManager = new FigureChangeManager();\r\n    }\r\n\r\n    // Methode folgt aus dem DesignPattern Composite (Verwendung ist Vorschlag\r\n    // von E.Gamma). Exception werfen ist Implementationsempfehlung des\r\n    // DesignPatterns.\r\n    public void add(Figure f) throws FigureException {\r\n        throw new FigureException(ResourceBundlePurchaser.getMessage(AbstractFigure.TRYING2ADD_A_FIGURE2A_BASICFIGURE));\r\n    }\r\n\r\n    // Methode folgt aus dem DesignPattern Composite (Verwendung ist Vorschlag\r\n    // von E.Gamma). Exception werfen ist Implementationsempfehlung des\r\n    // DesignPatterns.\r\n    public void addAll(StandardEnumeration figures) throws FigureException {\r\n        throw new FigureException(ResourceBundlePurchaser.getMessage(AbstractFigure.TRYING2ADD_PARTS2A_NON_COMPOSITE_FIGURE));\r\n    }\r\n\r\n    // MethodenIdee: E.Gamma, Delegation: C.L.\r\n    public void addChangeListener(FigureChangeListener l) {\r\n        this.getChangeManager().addChangeListener(l);\r\n    }\r\n\r\n    // Vorschlag von E.Gamma\r\n    protected abstract void basicMoveBy(int x, int y) throws FigureException;\r\n\r\n    // Methode folgt aus dem DesignPattern Composite (Verwendung ist Vorschlag\r\n    // von E.Gamma). Exception werfen ist Implementationsempfehlung des\r\n    // DesignPatterns.\r\n    public boolean containsFigure(Figure f) throws FigureException {\r\n        throw new FigureException(ResourceBundlePurchaser.getMessage(AbstractFigure.TRYING2CHECK_WHETER_A_FIGURE_IS_PART_OF_A_NON_COMPOSITE_FIGURE));\r\n    }\r\n\r\n    // identisch zum Beispielcode von E.Gamma\r\n    // (bis auf displayBox->getDisplayBox() und Exceptions)\r\n    //\r\n    // Die Frage, ob eine Figur einen Punkt enthaelt oder nicht,\r\n    // ist durch die dieser bekannten DisplayBox zu beantworten\r\n    // und kann folglich an sie delegiert werden.\r\n    public boolean containsPoint(int x, int y) {\r\n        return this.getDisplayBox().isInside(x, y);\r\n    }\r\n\r\n    // Wiederholung der Nennung: 80% C.L. (in Analogie zu getDisplayBox())\r\n    public abstract void draw(Graphics g) throws FigureException;\r\n\r\n    // Ausdifferenzierung nach erscheinenden und verschwindenden Figuren: C.L.\r\n    public void figureAppeared(FigureChangeEvent e) throws FigureException {\r\n        throw new FigureEventException(ResourceBundlePurchaser.getMessage(AbstractFigure.LISTENER_DOESNT_KNOW2HANDLE_FIGURE_CHANGE_EVENT));\r\n    }\r\n\r\n    // Vorschlag von E.Gamma\r\n    public void figureInvalidated(FigureChangeEvent e) throws FigureException {\r\n        throw new FigureEventException(ResourceBundlePurchaser.getMessage(AbstractFigure.LISTENER_DOESNT_KNOW2HANDLE_FIGURE_CHANGE_EVENT));\r\n    }\r\n\r\n    public Rectangle getBounds() throws FigureException {\r\n        return this.getDisplayBox().getRectangle();\r\n    }\r\n\r\n    // C.L:\r\n    protected FigureChangeManager getChangeManager() {\r\n        return this.changeManager;\r\n    }\r\n\r\n    // von Figure, E.Gamma nennt in Figure (Folie 11) und AbstractFigure (Folie\r\n    // 13) jeweils die abstrakte Methode displayBox();\r\n    // Folie 11 deutet allerdings auf eine Defaultimplementation von\r\n    // displayBox() hin, die basicDisplayBox() aufruft (vermutlich abstrakt).\r\n    // Dies macht eigentlich nur fuer einen echten Zeichenprozess Sinn (im\r\n    // Widerspruch zum Beispielcode von containsPoint()).\r\n    // C.L. realisiert die Version von Folie 13.\r\n    //\r\n    // Implementation durch konkrete Subklassen\r\n    public abstract DisplayBox getDisplayBox();\r\n\r\n    // Methode folgt aus dem DesignPattern Composite (Verwendung ist Vorschlag\r\n    // von E.Gamma). Exception werfen ist Implementationsempfehlung des\r\n    // DesignPatterns.\r\n    public StandardEnumeration getFigures() throws FigureException {\r\n        throw new FigureException(ResourceBundlePurchaser.getMessage(AbstractFigure.TRYING2GET_PARTS_OF_A_BASIC_FIGURE));\r\n    }\r\n\r\n    public Figure getParent() {\r\n        return this.parent;\r\n    }\r\n\r\n    public Dimension getSize() throws FigureException {\r\n        Dimension d = new Dimension();\r\n        Rectangle r = this.getBounds();\r\n        d.width = r.width;\r\n        d.height = r.height;\r\n        return d;\r\n    }\r\n\r\n    public void hasChanged() throws FigureEventException {\r\n        try {\r\n            this.getChangeManager().processEvent(new FigureChangeEvent(this, this.getDisplayBox(), PackageConstants.FIGURE_APPEARED));\r\n        } catch (Exception ex) {\r\n            throw new FigureEventException(ResourceBundlePurchaser.getMessage(AbstractFigure.ERROR_WHILE_DISPATCHING_APPEARED));\r\n        }\r\n    }\r\n\r\n    // identisch zum Beispielcode von E.Gamma\r\n    // (bis auf changed()->hasChanged(), dx -> x, dy -> y und Exceptions)\r\n    //\r\n    // erlaubt es einen gemeinsamen Notification-Mechanismus vorzuimplementieren\r\n    // (durch willChange() und changed()), delegiert eigentliche Bewegung\r\n    // an Unterklasse\r\n    public void moveBy(int x, int y) throws FigureException {\r\n        this.willChange();\r\n        this.basicMoveBy(x, y);\r\n        this.hasChanged();\r\n    }\r\n\r\n    // Methode folgt aus dem DesignPattern Composite (Verwendung ist Vorschlag\r\n    // von E.Gamma). Exception werfen ist Implementationsempfehlung des\r\n    // DesignPatterns.\r\n    public void remove(Figure f) throws FigureException {\r\n        throw new FigureException(ResourceBundlePurchaser.getMessage(AbstractFigure.TRYING2REMOVE_FROM_A_BASIC_FIGURE));\r\n    }\r\n\r\n    // Methode folgt aus dem DesignPattern Composite (Verwendung ist Vorschlag\r\n    // von E.Gamma). Exception werfen ist Implementationsempfehlung des\r\n    // DesignPatterns.\r\n    public void removeAll() throws FigureException {\r\n        throw new FigureException(ResourceBundlePurchaser.getMessage(AbstractFigure.TRYING2REMOVE_ALL_FROM_A_BASIC_FIGURE));\r\n    }\r\n\r\n    // MethodenIdee E.Gamma, Delegation: C.L.\r\n    public void removeChangeListener(FigureChangeListener l) {\r\n        this.getChangeManager().removeChangeListener(l);\r\n    }\r\n\r\n    public void setBounds(int x, int y, int width, int height) throws FigureException {\r\n        Rectangle r = new Rectangle(x, y, width, height);\r\n        this.setBounds(r);\r\n    }\r\n\r\n    public void setBounds(Rectangle r) throws FigureException {\r\n        this.willChange();\r\n        Rectangle db = this.getDisplayBox().getRectangle();\r\n        db.x = r.x;\r\n        db.y = r.y;\r\n        db.width = r.width;\r\n        db.height = r.height;\r\n        this.hasChanged();\r\n    }\r\n\r\n    // Methode folgt aus dem DesignPattern Composite (Verwendung ist Vorschlag\r\n    // von E.Gamma). Exception werfen ist Implementationsempfehlung des\r\n    // DesignPatterns.\r\n    public void setFigures(StandardEnumeration figures) throws FigureException {\r\n        throw new FigureException(ResourceBundlePurchaser.getMessage(AbstractFigure.TRYING2SET_PARTS_OF_A_NON_COMPOSITE_FIGURE));\r\n    }\r\n\r\n    public void setParent(Figure newParent) {\r\n        this.parent = newParent;\r\n    }\r\n\r\n    public void setSize(Dimension d) throws FigureException {\r\n        this.willChange();\r\n        Rectangle db = this.getDisplayBox().getRectangle();\r\n        db.width = d.width;\r\n        db.height = d.height;\r\n        this.hasChanged();\r\n    }\r\n\r\n    // Vorschlag von E.Gamma\r\n    //\r\n    //\r\n    public void setSize(int width, int height) throws FigureException {\r\n        Dimension d = new Dimension(width, height);\r\n        this.setSize(d);\r\n    }\r\n\r\n    public void willChange() throws FigureEventException {\r\n        try {\r\n            this.getChangeManager().processEvent(new FigureChangeEvent(this, (DisplayBox) this.getDisplayBox().clone(), PackageConstants.FIGURE_INVALIDATED));\r\n        } catch (Exception ex) {\r\n            throw new FigureEventException(ResourceBundlePurchaser.getMessage(AbstractFigure.ERROR_WHILE_DISPATCHING_INVALIDATED));\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/figure/AbstractFigureTest0.java",
		"test_prompt": "// AbstractFigureTest0.java\npackage de.paragon.explorer.figure;\n\nimport java.awt.Dimension;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\nimport de.paragon.explorer.excp.FigureEventException;\nimport de.paragon.explorer.excp.FigureException;\nimport de.paragon.explorer.gui.DisplayBox;\nimport de.paragon.explorer.util.ResourceBundlePurchaser;\nimport de.paragon.explorer.util.StandardEnumeration;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AbstractFigure}.\n* It contains ten unit test cases for the {@link AbstractFigure#containsFigure(Figure)} method.\n*/\nclass AbstractFigureTest0 {"
	},
	{
		"original_code": "// AbstractFigure.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.figure;\r\n\r\nimport java.awt.Dimension;\r\nimport java.awt.Graphics;\r\nimport java.awt.Rectangle;\r\nimport de.paragon.explorer.excp.FigureEventException;\r\nimport de.paragon.explorer.excp.FigureException;\r\nimport de.paragon.explorer.gui.DisplayBox;\r\nimport de.paragon.explorer.util.ResourceBundlePurchaser;\r\nimport de.paragon.explorer.util.StandardEnumeration;\r\n\r\n/**\r\n * Kommentar: Diese Klasse implementiert Figure und gibt Default-Implementation\r\n * fuer die grafischen Basisklassen vor Beschreibung der Kasse:\r\n *\r\n * Die Instanzvariablen: parent: normale Hierarchieverknuepfung, die Figur, von\r\n * der diese Figur Teilfigur ist.\r\n */\r\npublic abstract class AbstractFigure implements Figure {\r\n\r\n    private static final String ERROR_WHILE_DISPATCHING_APPEARED = \"abstractfigure.error_while_dispatching_appeared\";\r\n\r\n    private static final String ERROR_WHILE_DISPATCHING_INVALIDATED = \"abstractfigure.error_while_dispatching_invalidated\";\r\n\r\n    private static final String LISTENER_DOESNT_KNOW2HANDLE_FIGURE_CHANGE_EVENT = \"abstractfigure.listener_doesnt_know2handle_figure_change_event\";\r\n\r\n    private static final String TRYING2ADD_A_FIGURE2A_BASICFIGURE = \"abstractfigure.trying2add_a_figure2a_basicfigure\";\r\n\r\n    private static final String TRYING2ADD_PARTS2A_NON_COMPOSITE_FIGURE = \"abstractfigure.trying2add_parts2a_non_composite_figure\";\r\n\r\n    private static final String TRYING2CHECK_WHETER_A_FIGURE_IS_PART_OF_A_NON_COMPOSITE_FIGURE = \"abstractfigure.trying2check_wheter_a_figure_is_part_of_a_non_composite_figure\";\r\n\r\n    private static final String TRYING2GET_PARTS_OF_A_BASIC_FIGURE = \"abstractfigure.trying2get_parts_of_a_basic_figure\";\r\n\r\n    private static final String TRYING2REMOVE_ALL_FROM_A_BASIC_FIGURE = \"abstractfigure.trying2remove_all_from_a_basic_figure\";\r\n\r\n    private static final String TRYING2REMOVE_FROM_A_BASIC_FIGURE = \"abstractfigure.trying2remove_from_a_basic_figure\";\r\n\r\n    private static final String TRYING2SET_PARTS_OF_A_NON_COMPOSITE_FIGURE = \"abstractfigure.trying2set_parts_of_a_non_composite_figure\";\r\n\r\n    private FigureChangeManager changeManager;\r\n\r\n    private Figure parent;\r\n\r\n    // gemeinsames Eventhandling von E.Gamma implizit angesprochen\r\n    // durch Implementationsbeispiel in Figure\r\n    //\r\n    // changeManager zur Kapselung der Listenerverwaltung ist\r\n    // hier Idee von C.L., im Observer Pattern aber auch angesprochen\r\n    //\r\n    // fuer Defaultverhalten des Eventhandlings\r\n    protected AbstractFigure() {\r\n        this.changeManager = new FigureChangeManager();\r\n    }\r\n\r\n    // Methode folgt aus dem DesignPattern Composite (Verwendung ist Vorschlag\r\n    // von E.Gamma). Exception werfen ist Implementationsempfehlung des\r\n    // DesignPatterns.\r\n    public void add(Figure f) throws FigureException {\r\n        throw new FigureException(ResourceBundlePurchaser.getMessage(AbstractFigure.TRYING2ADD_A_FIGURE2A_BASICFIGURE));\r\n    }\r\n\r\n    // Methode folgt aus dem DesignPattern Composite (Verwendung ist Vorschlag\r\n    // von E.Gamma). Exception werfen ist Implementationsempfehlung des\r\n    // DesignPatterns.\r\n    public void addAll(StandardEnumeration figures) throws FigureException {\r\n        throw new FigureException(ResourceBundlePurchaser.getMessage(AbstractFigure.TRYING2ADD_PARTS2A_NON_COMPOSITE_FIGURE));\r\n    }\r\n\r\n    // MethodenIdee: E.Gamma, Delegation: C.L.\r\n    public void addChangeListener(FigureChangeListener l) {\r\n        this.getChangeManager().addChangeListener(l);\r\n    }\r\n\r\n    // Vorschlag von E.Gamma\r\n    protected abstract void basicMoveBy(int x, int y) throws FigureException;\r\n\r\n    // Methode folgt aus dem DesignPattern Composite (Verwendung ist Vorschlag\r\n    // von E.Gamma). Exception werfen ist Implementationsempfehlung des\r\n    // DesignPatterns.\r\n    public boolean containsFigure(Figure f) throws FigureException {\r\n        throw new FigureException(ResourceBundlePurchaser.getMessage(AbstractFigure.TRYING2CHECK_WHETER_A_FIGURE_IS_PART_OF_A_NON_COMPOSITE_FIGURE));\r\n    }\r\n\r\n    // identisch zum Beispielcode von E.Gamma\r\n    // (bis auf displayBox->getDisplayBox() und Exceptions)\r\n    //\r\n    // Die Frage, ob eine Figur einen Punkt enthaelt oder nicht,\r\n    // ist durch die dieser bekannten DisplayBox zu beantworten\r\n    // und kann folglich an sie delegiert werden.\r\n    public boolean containsPoint(int x, int y) {\r\n        return this.getDisplayBox().isInside(x, y);\r\n    }\r\n\r\n    // Wiederholung der Nennung: 80% C.L. (in Analogie zu getDisplayBox())\r\n    public abstract void draw(Graphics g) throws FigureException;\r\n\r\n    // Ausdifferenzierung nach erscheinenden und verschwindenden Figuren: C.L.\r\n    public void figureAppeared(FigureChangeEvent e) throws FigureException {\r\n        throw new FigureEventException(ResourceBundlePurchaser.getMessage(AbstractFigure.LISTENER_DOESNT_KNOW2HANDLE_FIGURE_CHANGE_EVENT));\r\n    }\r\n\r\n    // Vorschlag von E.Gamma\r\n    public void figureInvalidated(FigureChangeEvent e) throws FigureException {\r\n        throw new FigureEventException(ResourceBundlePurchaser.getMessage(AbstractFigure.LISTENER_DOESNT_KNOW2HANDLE_FIGURE_CHANGE_EVENT));\r\n    }\r\n\r\n    public Rectangle getBounds() throws FigureException {\r\n        return this.getDisplayBox().getRectangle();\r\n    }\r\n\r\n    // C.L:\r\n    protected FigureChangeManager getChangeManager() {\r\n        return this.changeManager;\r\n    }\r\n\r\n    // von Figure, E.Gamma nennt in Figure (Folie 11) und AbstractFigure (Folie\r\n    // 13) jeweils die abstrakte Methode displayBox();\r\n    // Folie 11 deutet allerdings auf eine Defaultimplementation von\r\n    // displayBox() hin, die basicDisplayBox() aufruft (vermutlich abstrakt).\r\n    // Dies macht eigentlich nur fuer einen echten Zeichenprozess Sinn (im\r\n    // Widerspruch zum Beispielcode von containsPoint()).\r\n    // C.L. realisiert die Version von Folie 13.\r\n    //\r\n    // Implementation durch konkrete Subklassen\r\n    public abstract DisplayBox getDisplayBox();\r\n\r\n    // Methode folgt aus dem DesignPattern Composite (Verwendung ist Vorschlag\r\n    // von E.Gamma). Exception werfen ist Implementationsempfehlung des\r\n    // DesignPatterns.\r\n    public StandardEnumeration getFigures() throws FigureException {\r\n        throw new FigureException(ResourceBundlePurchaser.getMessage(AbstractFigure.TRYING2GET_PARTS_OF_A_BASIC_FIGURE));\r\n    }\r\n\r\n    public Figure getParent() {\r\n        return this.parent;\r\n    }\r\n\r\n    public Dimension getSize() throws FigureException {\r\n        Dimension d = new Dimension();\r\n        Rectangle r = this.getBounds();\r\n        d.width = r.width;\r\n        d.height = r.height;\r\n        return d;\r\n    }\r\n\r\n    public void hasChanged() throws FigureEventException {\r\n        try {\r\n            this.getChangeManager().processEvent(new FigureChangeEvent(this, this.getDisplayBox(), PackageConstants.FIGURE_APPEARED));\r\n        } catch (Exception ex) {\r\n            throw new FigureEventException(ResourceBundlePurchaser.getMessage(AbstractFigure.ERROR_WHILE_DISPATCHING_APPEARED));\r\n        }\r\n    }\r\n\r\n    // identisch zum Beispielcode von E.Gamma\r\n    // (bis auf changed()->hasChanged(), dx -> x, dy -> y und Exceptions)\r\n    //\r\n    // erlaubt es einen gemeinsamen Notification-Mechanismus vorzuimplementieren\r\n    // (durch willChange() und changed()), delegiert eigentliche Bewegung\r\n    // an Unterklasse\r\n    public void moveBy(int x, int y) throws FigureException {\r\n        this.willChange();\r\n        this.basicMoveBy(x, y);\r\n        this.hasChanged();\r\n    }\r\n\r\n    // Methode folgt aus dem DesignPattern Composite (Verwendung ist Vorschlag\r\n    // von E.Gamma). Exception werfen ist Implementationsempfehlung des\r\n    // DesignPatterns.\r\n    public void remove(Figure f) throws FigureException {\r\n        throw new FigureException(ResourceBundlePurchaser.getMessage(AbstractFigure.TRYING2REMOVE_FROM_A_BASIC_FIGURE));\r\n    }\r\n\r\n    // Methode folgt aus dem DesignPattern Composite (Verwendung ist Vorschlag\r\n    // von E.Gamma). Exception werfen ist Implementationsempfehlung des\r\n    // DesignPatterns.\r\n    public void removeAll() throws FigureException {\r\n        throw new FigureException(ResourceBundlePurchaser.getMessage(AbstractFigure.TRYING2REMOVE_ALL_FROM_A_BASIC_FIGURE));\r\n    }\r\n\r\n    // MethodenIdee E.Gamma, Delegation: C.L.\r\n    public void removeChangeListener(FigureChangeListener l) {\r\n        this.getChangeManager().removeChangeListener(l);\r\n    }\r\n\r\n    public void setBounds(int x, int y, int width, int height) throws FigureException {\r\n        Rectangle r = new Rectangle(x, y, width, height);\r\n        this.setBounds(r);\r\n    }\r\n\r\n    public void setBounds(Rectangle r) throws FigureException {\r\n        this.willChange();\r\n        Rectangle db = this.getDisplayBox().getRectangle();\r\n        db.x = r.x;\r\n        db.y = r.y;\r\n        db.width = r.width;\r\n        db.height = r.height;\r\n        this.hasChanged();\r\n    }\r\n\r\n    // Methode folgt aus dem DesignPattern Composite (Verwendung ist Vorschlag\r\n    // von E.Gamma). Exception werfen ist Implementationsempfehlung des\r\n    // DesignPatterns.\r\n    public void setFigures(StandardEnumeration figures) throws FigureException {\r\n        throw new FigureException(ResourceBundlePurchaser.getMessage(AbstractFigure.TRYING2SET_PARTS_OF_A_NON_COMPOSITE_FIGURE));\r\n    }\r\n\r\n    public void setParent(Figure newParent) {\r\n        this.parent = newParent;\r\n    }\r\n\r\n    public void setSize(Dimension d) throws FigureException {\r\n        this.willChange();\r\n        Rectangle db = this.getDisplayBox().getRectangle();\r\n        db.width = d.width;\r\n        db.height = d.height;\r\n        this.hasChanged();\r\n    }\r\n\r\n    // Vorschlag von E.Gamma\r\n    //\r\n    //\r\n    public void setSize(int width, int height) throws FigureException {\r\n        Dimension d = new Dimension(width, height);\r\n        this.setSize(d);\r\n    }\r\n\r\n    public void willChange() throws FigureEventException {\r\n        try {\r\n            this.getChangeManager().processEvent(new FigureChangeEvent(this, (DisplayBox) this.getDisplayBox().clone(), PackageConstants.FIGURE_INVALIDATED));\r\n        } catch (Exception ex) {\r\n            throw new FigureEventException(ResourceBundlePurchaser.getMessage(AbstractFigure.ERROR_WHILE_DISPATCHING_INVALIDATED));\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/figure/AbstractFigureTest1.java",
		"test_prompt": "// AbstractFigureTest1.java\npackage de.paragon.explorer.figure;\n\nimport java.awt.Dimension;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\nimport de.paragon.explorer.excp.FigureEventException;\nimport de.paragon.explorer.excp.FigureException;\nimport de.paragon.explorer.gui.DisplayBox;\nimport de.paragon.explorer.util.ResourceBundlePurchaser;\nimport de.paragon.explorer.util.StandardEnumeration;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AbstractFigure}.\n* It contains ten unit test cases for the {@link AbstractFigure#containsPoint(int, int)} method.\n*/\nclass AbstractFigureTest1 {"
	},
	{
		"original_code": "// RectangleFigure.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.figure;\r\n\r\nimport java.awt.Graphics;\r\nimport de.paragon.explorer.gui.DisplayBox;\r\nimport de.paragon.explorer.gui.StandardRectangularDisplayBox;\r\n\r\npublic class RectangleFigure extends AbstractFigure {\r\n\r\n    private DisplayBox displayBox;\r\n\r\n    // C.L.\r\n    public RectangleFigure() {\r\n        super();\r\n        this.displayBox = new StandardRectangularDisplayBox(0, 0, 0, 0);\r\n    }\r\n\r\n    // C.L.\r\n    public RectangleFigure(int x, int y, int width, int height) {\r\n        super();\r\n        this.displayBox = new StandardRectangularDisplayBox(x, y, width, height);\r\n    }\r\n\r\n    @Override\r\n    protected void basicMoveBy(int x, int y) {\r\n        this.getDisplayBox().translate(x, y);\r\n    }\r\n\r\n    // E.Gamma schlaegt dies Methode (ohne naehere Angaben zum Code) vor.\r\n    //\r\n    // drawRect(int x, int y, int width, int height) von java.awt.Graphics wird\r\n    // nicht benutzt,\r\n    // da fuer negatives width oder height nichts gezeichnet wird. Eine\r\n    // Koordinatentransformation ist moeglich,\r\n    // aber da drawLine(int x1, int y1, int x2, int y2) das stabilere Konzept zu\r\n    // sein scheint,\r\n    // werden hier vier Linien gezeichnet.\r\n    //\r\n    // Die -1 kommt vom Pixelzaehlen, java.awt.Rectangle verfuegt ueber keine\r\n    // get- und set-Methoden\r\n    // um auf die Variablen einzeln zugreifen zu koennen, dafuer sind diese\r\n    // oeffentlich.\r\n    //\r\n    @Override\r\n    public void draw(Graphics g) {\r\n        // int x = this.getDisplayBox().getRectangle().x;\r\n        // int y = this.getDisplayBox().getRectangle().y;\r\n        // int width = this.getDisplayBox().getRectangle().width;\r\n        // int height = this.getDisplayBox().getRectangle().height;\r\n        // g.drawLine(x,y, x+width-1,y);\r\n        // g.drawLine(x+width-1,y, x+width-1,y+height-1);\r\n        // g.drawLine(x+width-1,y+height-1, x,y+height-1);\r\n        // g.drawLine(x,y+height-1, x,y);\r\n    }\r\n\r\n    @Override\r\n    public DisplayBox getDisplayBox() {\r\n        return this.displayBox;\r\n    }\r\n\r\n    public boolean isVisible() {\r\n        return true;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/figure/RectangleFigureTest.java",
		"test_prompt": "// RectangleFigureTest.java\npackage de.paragon.explorer.figure;\n\nimport java.awt.Graphics;\nimport de.paragon.explorer.gui.DisplayBox;\nimport de.paragon.explorer.gui.StandardRectangularDisplayBox;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RectangleFigure}.\n* It contains ten unit test cases for the {@link RectangleFigure#isVisible()} method.\n*/\nclass RectangleFigureTest {"
	},
	{
		"original_code": "// CompositeFigure.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.figure;\r\n\r\nimport java.awt.Graphics;\r\nimport de.paragon.explorer.excp.FigureEventException;\r\nimport de.paragon.explorer.excp.FigureException;\r\nimport de.paragon.explorer.gui.DisplayBox;\r\nimport de.paragon.explorer.util.ResourceBundlePurchaser;\r\nimport de.paragon.explorer.util.StandardEnumeration;\r\n\r\n/**\r\n * Kommentar: CompositeFigure ist die abstrakte Basisklasse aller\r\n * zusammengesetzten Figuren. Sie enthaelt Default-Implementationen von\r\n * Figurenmanagement-Funktionen, sowie von draw() und moveBy().\r\n *\r\n * Die Verwaltung der Figuren erfolgt in einem Figurestore, das Ein- und\r\n * Austragen als FigureChangeListener bei den Figuren erfolgt in dieser Klasse.\r\n * Im figureStore werden die Teilfiguren als Typ Figure (Interface) gehalten.\r\n */\r\npublic abstract class CompositeFigure extends AbstractFigure {\r\n\r\n    private static final String SETTING_BOUNDS = \"compositefigure.setting_bounds\";\r\n\r\n    private FigureStore figureStore;\r\n\r\n    // C.L.\r\n    protected CompositeFigure() {\r\n        this.figureStore = new FigureStore();\r\n    }\r\n\r\n    // E.Gamma: konkrete Implementation soll erfolgen\r\n    // C.L.: und zwar durch Delegation an FigureStore\r\n    // ausserdem traegt sich die CompositeFigure bei Figure als\r\n    // FigureChangeListener ein, damit durch die Figure ausgeloeste\r\n    // Events (evtl. ueber eine Kette ineinandergeschachtelter\r\n    // CompositeFigure-Objekte) beiDrawingView landen.\r\n    @Override\r\n    public void add(Figure figure) throws FigureEventException {\r\n        this.figureStore.add(figure);\r\n        // figure.addChangeListener(this);\r\n        figure.setParent(this);\r\n        // this.hasChanged();\r\n        /*\r\n\t\t * Kommentar von CHE: Soweit ich das ermittelt habe, fuehrt hasChanged\r\n\t\t * zu keiner Aktion\r\n\t\t */\r\n    }\r\n\r\n    // E.Gamma: konkrete Implementation soll erfolgen\r\n    // C.L.: benutzt this.add()\r\n    @Override\r\n    public void addAll(StandardEnumeration f) throws FigureException {\r\n        while (f.hasMoreElements()) {\r\n            this.add((Figure) f.nextElement());\r\n        }\r\n    }\r\n\r\n    // 80% C.L.; analoge Implementation zu draw()\r\n    @Override\r\n    public void basicMoveBy(int x, int y) throws FigureException {\r\n        de.paragon.explorer.util.StandardEnumeration f = this.getFigures();\r\n        while (f.hasMoreElements()) {\r\n            ((Figure) f.nextElement()).moveBy(x, y);\r\n        }\r\n    }\r\n\r\n    // 90% C.L.\r\n    // E.Gamma fordert findFigure fuer das Interface Drawing\r\n    @Override\r\n    public boolean containsFigure(Figure figure) {\r\n        return this.figureStore.isInStore(figure);\r\n    }\r\n\r\n    // identisch zum Beispielcode von E.Gamma\r\n    // (bis auf figure->getFigures() und Exceptions)\r\n    @Override\r\n    public void draw(Graphics g) throws FigureException {\r\n        de.paragon.explorer.util.StandardEnumeration f = this.getFigures();\r\n        while (f.hasMoreElements()) {\r\n            ((Figure) (f.nextElement())).draw(g);\r\n        }\r\n    }\r\n\r\n    // Differenzierung: C.L.\r\n    // Idee des Mechnismus: E.Gamma (vgl. figureInvalidated)\r\n    //\r\n    // gibt Event an die eigenen Listener weiter\r\n    // belaesst Source beim Child\r\n    @Override\r\n    public void figureAppeared(FigureChangeEvent e) throws FigureEventException {\r\n        this.getChangeManager().processEvent(e);\r\n    }\r\n\r\n    // E.Gamma: die Teilfiguren (Child-Objekte) reichen Events an die\r\n    // entsprechende CompositeFigure weiter\r\n    // bis die CompositeFigure, die die Drawing ist, die DrawingView haelt,\r\n    // diese benachrichtigt.\r\n    //\r\n    // leaf->CompositeFigure->CompositeFigure->...->CompositeFigure(=StandardDrawingView.drawing)->DrawingView\r\n    //\r\n    // diese Methode benachrichtigt die Listener einer CompositeFigure duch\r\n    // Weiterreichen des\r\n    // von einem Child empfangenen Events.\r\n    //\r\n    @Override\r\n    public void figureInvalidated(FigureChangeEvent e) throws FigureEventException {\r\n        this.getChangeManager().processEvent(e);\r\n    }\r\n\r\n    // E.Gamma schlaegt vor, dass CompositeFigure kein Layout definiert,\r\n    // getDisplayBox() (E.Gamma DisplayBox()) also nicht implementiert wird.\r\n    @Override\r\n    public abstract DisplayBox getDisplayBox();\r\n\r\n    // E.Gamma: konkrete Implementation soll erfolgen (von figures())\r\n    // C.L.: und zwar durch Delegation an FigureStore\r\n    @Override\r\n    public StandardEnumeration getFigures() throws FigureException {\r\n        return this.figureStore.getFigures();\r\n    }\r\n\r\n    // E.Gamma: konkrete Implementation soll erfolgen\r\n    // C.L.: und zwar durch Delegation an FigureStore\r\n    @Override\r\n    public void remove(Figure figure) throws FigureException {\r\n        this.willChange();\r\n        figure.removeChangeListener(this);\r\n        figure.setParent(null);\r\n        this.figureStore.remove(figure);\r\n    }\r\n\r\n    // C.L.\r\n    //\r\n    // holt sich zunaechst die Figuren, um sich als Listener austragen zu\r\n    // koennen\r\n    @Override\r\n    public void removeAll() throws FigureException {\r\n        de.paragon.explorer.util.StandardEnumeration f = this.figureStore.getFigures();\r\n        Figure current = null;\r\n        while (f.hasMoreElements()) {\r\n            current = (Figure) f.nextElement();\r\n            this.remove(current);\r\n        }\r\n        this.figureStore = new FigureStore();\r\n    }\r\n\r\n    @Override\r\n    public void setBounds(java.awt.Rectangle r) throws FigureException {\r\n        throw new FigureException(ResourceBundlePurchaser.getMessage(CompositeFigure.SETTING_BOUNDS));\r\n    }\r\n\r\n    // C.L.\r\n    @Override\r\n    public void setFigures(StandardEnumeration figures) throws FigureException {\r\n        this.removeAll();\r\n        this.addAll(figures);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/figure/CompositeFigureTest.java",
		"test_prompt": "// CompositeFigureTest.java\npackage de.paragon.explorer.figure;\n\nimport java.awt.Graphics;\nimport de.paragon.explorer.excp.FigureEventException;\nimport de.paragon.explorer.excp.FigureException;\nimport de.paragon.explorer.gui.DisplayBox;\nimport de.paragon.explorer.util.ResourceBundlePurchaser;\nimport de.paragon.explorer.util.StandardEnumeration;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CompositeFigure}.\n* It contains ten unit test cases for the {@link CompositeFigure#containsFigure(Figure)} method.\n*/\nclass CompositeFigureTest {"
	},
	{
		"original_code": "// ListBoxFigureBuilder.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.figure;\r\n\r\nimport java.lang.reflect.Modifier;\r\nimport java.util.Enumeration;\r\nimport org.apache.log4j.Logger;\r\nimport de.paragon.explorer.gui.Warning;\r\nimport de.paragon.explorer.model.AttributeModel;\r\nimport de.paragon.explorer.model.NullObject;\r\nimport de.paragon.explorer.model.ObjectHeaderModel;\r\nimport de.paragon.explorer.model.ObjectModel;\r\nimport de.paragon.explorer.model.ObjectModelPart;\r\nimport de.paragon.explorer.util.LoggerFactory;\r\nimport de.paragon.explorer.util.ResourceBundlePurchaser;\r\nimport de.paragon.explorer.util.StandardEnumeration;\r\n\r\npublic final class ListBoxFigureBuilder {\r\n\r\n    private static final String ERROR_WHILE_UPDATING_FIGURES = \"listboxfigurebuilder.error_while_updating_figures\";\r\n\r\n    private static final String ERROR_WHILE_GETTING_FIGURES = \"listboxfigurebuilder.error_while_getting_figures\";\r\n\r\n    private static final String ERROR_WHILE_SETTING_ALL_ATTRIBUTES_VISIBLE = \"listboxfigurebuilder.error_while_setting_all_attributes_visible\";\r\n\r\n    private static final String ERROR_WHILE_SETTING_ALL_ATTRIBUTES_UNVISIBLE = \"listboxfigurebuilder.error_while_setting_all_attributes_unvisible\";\r\n\r\n    private static final String ERROR_WHILE_INIT_MODELL = \"listboxfigurebuilder.error_while_init_modell\";\r\n\r\n    private static final String ERROR_WHILE_BUILDING_MODELL = \"listboxfigurebuilder.error_while_building_modell\";\r\n\r\n    private static final String ERROR_WHILE_BUILDING_LISTBOXFIGURE = \"listboxfigurebuilder.error_while_building_listboxfigure\";\r\n\r\n    private static final Logger logger = LoggerFactory.make();\r\n\r\n    private static ListBoxFigureBuilder singleton;\r\n\r\n    public static ListBoxFigureBuilder getInstance() {\r\n        return ListBoxFigureBuilder.getSingleton();\r\n    }\r\n\r\n    private static ListBoxFigureBuilder getSingleton() {\r\n        if (ListBoxFigureBuilder.singleton == null) {\r\n            ListBoxFigureBuilder.setSingleton(new ListBoxFigureBuilder());\r\n        }\r\n        return ListBoxFigureBuilder.singleton;\r\n    }\r\n\r\n    private static void setSingleton(ListBoxFigureBuilder builder) {\r\n        ListBoxFigureBuilder.singleton = builder;\r\n    }\r\n\r\n    private ListBoxFigureBuilder() {\r\n        super();\r\n    }\r\n\r\n    protected void addTextBoxFigure(TextBoxFigure teBoFi) {\r\n        try {\r\n            ((ObjectModelPart) teBoFi.getModel()).getObjectModel().getFigure().add(teBoFi);\r\n        } catch (Exception ex) {\r\n            ListBoxFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_BUILDING_LISTBOXFIGURE), ex);\r\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_BUILDING_LISTBOXFIGURE));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht davon aus, dass die TextBoxFigure, die mit\r\n     * dem HeaderModel verknuepft ist, fertig ist. Anhand dessen bestimmt sie\r\n     * die Groesse der FilledRectangleFigure, die als Unterstrich fuer die\r\n     * Header-TextBoxFigure dient, und fuegt sie der ListBoxFigure hinzu.\r\n     */\r\n    protected void buildHeaderUnderline(ObjectModel objModl) {\r\n        TextBoxFigure teBoFig = (TextBoxFigure) objModl.getHeaderModel().getFigure();\r\n        int width = this.getFigureWidth(teBoFig);\r\n        // int height = this.getFigureHeight(teBoFig) / 5;\r\n        int height = 1;\r\n        int y = 0, x = 0;\r\n        try {\r\n            objModl.getFigure().add(new FilledRectangleFigure(x, y, width, height));\r\n        } catch (Exception ex) {\r\n            ListBoxFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_BUILDING_MODELL), ex);\r\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_BUILDING_MODELL));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Zunaechst wird fuer jedes TeilModel eine TextBoxFigure erzeugt\r\n     * und mit ihrem jeweiligen Model (Header- bzw. AttributeModel) verknuepft.\r\n     * Diese Methode geht davon aus, dass fuer das ObjectModel bereits\r\n     * HeaderModels und AttributeModels in dem Object angepasster Anzahl\r\n     * existieren. Dann wird jeder TextBoxFigure ein entsprechender String\r\n     * zugewiesen. Anschliessend wird zunaechst die soeben erzeugte\r\n     * TextBoxFigure fuer das HeaderModel gebaut, was die Bestimmung der Groesse\r\n     * bedeutet, und mit der ListBoxFigure, die auch die ExplorerFigure kennt,\r\n     * die die Graphics kennt, verknuepft. Danach wird eine neue\r\n     * FilledRectangleFigure erzeugt und mit der ListBoxFigure verknuepft.\r\n     * Danach wird jede der mit einem AttributModel verknuepften TextBoxFiguren\r\n     * gebaut und mit der ListBoxFigure verknuepft. Danach wird die\r\n     * ListBoxFigure fertiggebaut.\r\n     */\r\n    public void buildListBoxFigure(ObjectModel objModl) {\r\n        ListBoxFigure liBoFi = (ListBoxFigure) objModl.getFigure();\r\n        this.getTextBoxFigureBuilder().createTextBoxFigures(objModl);\r\n        this.initializeListBoxFigure(liBoFi);\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht davon aus, dass alle Verknuepfungen bereits\r\n     * existieren und die Teilfiguren -jede fuer sich- gebaut sind. Sie\r\n     * ermittelt die Weite der ListBoxFigure. Dabei geht sie so vor: Falls die\r\n     * Figur \"visible\" ist, geht sie in die Berechnung mit ein. Am Ende ist die\r\n     * Weite der ListBoxFigure das Maximum aller Weiten der sichtbaren\r\n     * TextBoxFiguren.\r\n     *\r\n     * @return int\r\n     */\r\n    private int computeListBoxFigureWidth(ListBoxFigure list) {\r\n        /* damn the class Rectangle for having no get method for the width! */\r\n        ObjectHeaderModel headModl = ((ObjectModel) list.getModel()).getHeaderModel();\r\n        StandardEnumeration attrModls = ((ObjectModel) list.getModel()).getAttributeModels();\r\n        AttributeModel tempModel;\r\n        int x = this.getFigureWidth(headModl.getFigure());\r\n        while (attrModls.hasMoreElements()) {\r\n            tempModel = (AttributeModel) attrModls.nextElement();\r\n            if (((TextBoxFigure) tempModel.getFigure()).isVisible()) {\r\n                x = Math.max(this.getFigureWidth(tempModel.getFigure()), x);\r\n            }\r\n        }\r\n        return x;\r\n    }\r\n\r\n    public void createNewListBoxFigure(ObjectModel objModl) {\r\n        ExplorerFieldListBoxFigure exFiLiBoFi = new ExplorerFieldListBoxFigure();\r\n        objModl.setFigure(exFiLiBoFi);\r\n        exFiLiBoFi.setModel(objModl);\r\n        this.getExplorerFigureBuilder().addListBoxFigure(exFiLiBoFi);\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht davon aus, dass das ObjectModel bereits mit\r\n     * einem ExplorerModel verknuepft ist. Das ExplorerModel seinerseits ist\r\n     * bereits mit einer ExplorerFigure verknuepft. Diese Methode erzeugt eine\r\n     * neue ListBoxFigure und verknuepft sie mit dem ObjectModel. Anschliessend\r\n     * laesst sie die neue ListBoxFigure mit der ExplorerFigure verknuepfen, um\r\n     * den Kreis zu schliessen.\r\n     */\r\n    public void createNewListBoxFigure(ObjectModel objModl, TextBoxFigure tbf) {\r\n        ExplorerFieldListBoxFigure exFiLiBoFi = new ExplorerFieldListBoxFigure();\r\n        if (tbf.getParent() instanceof ExplorerFieldListBoxFigure) {\r\n            ((ExplorerFieldListBoxFigure) tbf.getParent()).addChild(exFiLiBoFi);\r\n        }\r\n        objModl.setFigure(exFiLiBoFi);\r\n        exFiLiBoFi.setModel(objModl);\r\n        this.getExplorerFigureBuilder().addListBoxFigure(exFiLiBoFi);\r\n    }\r\n\r\n    private ExplorerFigureBuilder getExplorerFigureBuilder() {\r\n        return ExplorerFigureBuilder.getInstance();\r\n    }\r\n\r\n    private int getFigureHeight(Figure figure) {\r\n        int tempHeight = 0;\r\n        try {\r\n            tempHeight = figure.getDisplayBox().getRectangle().height;\r\n        } catch (Exception ex) {\r\n            ListBoxFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_BUILDING_MODELL), ex);\r\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_BUILDING_MODELL));\r\n        }\r\n        return tempHeight;\r\n    }\r\n\r\n    private int getFigureWidth(Figure figure) {\r\n        int tempWidth = 0;\r\n        try {\r\n            tempWidth = figure.getDisplayBox().getRectangle().width;\r\n        } catch (Exception ex) {\r\n            ListBoxFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_BUILDING_MODELL), ex);\r\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_BUILDING_MODELL));\r\n        }\r\n        return tempWidth;\r\n    }\r\n\r\n    private TextBoxFigureBuilder getTextBoxFigureBuilder() {\r\n        return TextBoxFigureBuilder.getInstance();\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht davon aus, dass saemtliche Verknuepfungen\r\n     * zwischen Models und Figures existieren, und dass die Text- BoxFigures\r\n     * jede fuer sich selbst gebaut sind. Diese Methode bestimmt die\r\n     * DisplayBoxen der Teilfiguren neu. Das heisst, sie ermittelt und setzt die\r\n     * Position der Teilfigur innerhalb der ListBoxFigure, und sie ermittelt die\r\n     * Weite der ListBoxFigure und setzt diese in allen Teilfiguren und der\r\n     * ListBoxFigure selbst. Bei der Emitt- lung der Weite wird die Angabe\r\n     * \"visible\" beruecksichtigt. Anschliessend positioniert sie die\r\n     * ListBoxFigure in der ExplorerFigure, wieder abhaengig von \"visible\".\r\n     */\r\n    public void initializeListBoxFigure(ListBoxFigure liBoFi) {\r\n        this.setListBoxFigureWidths(liBoFi, this.computeListBoxFigureWidth(liBoFi));\r\n        StandardEnumeration figParts;\r\n        try {\r\n            figParts = liBoFi.getFigures();\r\n        } catch (Exception ex) {\r\n            ListBoxFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_INIT_MODELL), ex);\r\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_INIT_MODELL));\r\n            figParts = null;\r\n        }\r\n        this.setFigureHeight(liBoFi, 0);\r\n        if (figParts != null) {\r\n            while (figParts.hasMoreElements()) {\r\n                RectangleFigure tempFig = (RectangleFigure) figParts.nextElement();\r\n                if (tempFig.isVisible()) {\r\n                    try {\r\n                        tempFig.moveBy(0, this.getFigureHeight(liBoFi));\r\n                    } catch (Exception ex) {\r\n                        ListBoxFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_INIT_MODELL), ex);\r\n                        Warning.showWarning(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_INIT_MODELL));\r\n                    }\r\n                    this.setFigureHeight(liBoFi, this.getFigureHeight(liBoFi) + this.getFigureHeight(tempFig));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht so vor: Zunaechst werden alle\r\n     * AttributeModels, die in der ListBoxFigure enthalten sind, auf unvisible\r\n     * gesetzt. Dann wird die Weite von allen Teilen der ListBoxFigure auf 0\r\n     * (null) gesetzt, und die Orte werden gleich dem Ort der ListBoxFigure\r\n     * gesetzt. Mit allen TeilFiguren, die TextBoxFigure sind, geschieht dann\r\n     * folgendes: Die DisplayBox wird erneut berechnet. Die Be- rechnung der\r\n     * DisplayBox hat zur Folge, dass der Ort der Figure wieder auf 0,0 gesetzt\r\n     * wird. Also wird die TextBoxFigure wieder um die Position der\r\n     * ListBoxFigure verschoben.\r\n     */\r\n    public void setAllAttributesUnvisible(ListBoxFigure liBoFi) {\r\n        ObjectModel objModl;\r\n        StandardEnumeration parts;\r\n        TextBoxFigure teBoFi;\r\n        AttributeModel attrModl;\r\n        RectangleFigure liBoFiPart;\r\n        objModl = (ObjectModel) liBoFi.getModel();\r\n        objModl.getObjectViewManager().setAllAttributesVisible(false);\r\n        // objModl.getObjectViewManager().setNullAttributesVisible(false);\r\n        // objModl.getObjectViewManager().setStaticAttributesVisible(false);\r\n        // objModl.getObjectViewManager().setUnexploredAttributesVisible(false);\r\n        parts = objModl.getAttributeModels();\r\n        try {\r\n            // Hier werden alle Attribute unsichtbar gesetzt.\r\n            while (parts.hasMoreElements()) {\r\n                attrModl = (AttributeModel) parts.nextElement();\r\n                ((TextBoxFigure) attrModl.getFigure()).setUnvisible();\r\n            }\r\n            // Hier werden die Weiten aller Teilfiguren auf 0 gesetzt und die\r\n            // Positionen gleich der Position der ListBoxFigure.\r\n            // Hierzu bekommt parts eine neue Zuweisung.\r\n            parts = liBoFi.getFigures();\r\n            while (parts.hasMoreElements()) {\r\n                liBoFiPart = (RectangleFigure) parts.nextElement();\r\n                liBoFiPart.getBounds().width = 0;\r\n                liBoFiPart.getBounds().x = liBoFi.getBounds().x;\r\n                liBoFiPart.getBounds().y = liBoFi.getBounds().y;\r\n            }\r\n            // Hier werden die DisplayBoxen aller TextBoxFigures neu berechnet.\r\n            // Beachte, dass die Berechnung bewirkt, dass die Position auf 0,0\r\n            // gesetzt wird. Daher werden die Figuren anschliessend um die Posi-\r\n            // tion der ListBoxFigure verschoben.\r\n            // Da in der folgenden NeuBerechnung die FilledRectangularBox nicht\r\n            // mitberuecksichtigt wird, war es oben noetig, die Position aller\r\n            // TeilFiguren auf die der ListBoxFigure zu setzten.\r\n            // Es wird mit der TextBoxFigure des HeaderModels begonnen.\r\n            teBoFi = (TextBoxFigure) ((ObjectModel) liBoFi.getModel()).getHeaderModel().getFigure();\r\n            teBoFi.setBounds(this.getTextBoxFigureBuilder().computeDisplayBox(teBoFi));\r\n            teBoFi.moveBy(liBoFi.getBounds().x, liBoFi.getBounds().y);\r\n            // Jetzt kommen die TextBoxFigures der AttributeModels dran.\r\n            parts = ((ObjectModel) liBoFi.getModel()).getAttributeModels();\r\n            while (parts.hasMoreElements()) {\r\n                teBoFi = (TextBoxFigure) ((AttributeModel) parts.nextElement()).getFigure();\r\n                teBoFi.setBounds(this.getTextBoxFigureBuilder().computeDisplayBox(teBoFi));\r\n                teBoFi.moveBy(liBoFi.getBounds().x, liBoFi.getBounds().y);\r\n            }\r\n        } catch (Exception ex) {\r\n            ListBoxFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_SETTING_ALL_ATTRIBUTES_UNVISIBLE), ex);\r\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_SETTING_ALL_ATTRIBUTES_UNVISIBLE));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht so vor: Zunaechst werden alle\r\n     * AttributeModels, die in der ListBoxFigure enthalten sind, auf visible\r\n     * gesetzt. Dann wird die Weite von allen Teilen der ListBoxFigure auf 0\r\n     * (null) gesetzt, und die Orte werden gleich dem Ort der ListBoxFigure\r\n     * gesetzt. Mit allen TeilFiguren, die TextBoxFigure sind, geschieht dann\r\n     * folgendes: Die DisplayBox wird erneut berechnet. Die Berechnung der\r\n     * DisplayBox hat zur Folge, dass der Ort der Figure wieder auf 0,0 gesetzt\r\n     * wird. Also wird die TextBoxFigure wieder um die Position der\r\n     * ListBoxFigure verschoben.\r\n     */\r\n    public void setAllAttributesVisible(ListBoxFigure liBoFi) {\r\n        ObjectModel objModl;\r\n        StandardEnumeration parts;\r\n        TextBoxFigure teBoFi;\r\n        AttributeModel attrModl;\r\n        RectangleFigure liBoFiPart;\r\n        objModl = (ObjectModel) liBoFi.getModel();\r\n        objModl.getObjectViewManager().setAllAttributesVisible(true);\r\n        // objModl.getObjectViewManager().setNullAttributesVisible(true);\r\n        // objModl.getObjectViewManager().setStaticAttributesVisible(true);\r\n        // objModl.getObjectViewManager().setUnexploredAttributesVisible(true);\r\n        parts = objModl.getAttributeModels();\r\n        try {\r\n            // Hier werden alle Attribute sichtbar gesetzt.\r\n            while (parts.hasMoreElements()) {\r\n                attrModl = (AttributeModel) parts.nextElement();\r\n                if (objModl.getObjectViewManager().shouldBeVisible(attrModl)) {\r\n                    ((TextBoxFigure) attrModl.getFigure()).setVisible();\r\n                }\r\n            }\r\n            // Hier werden die Weiten aller Teilfiguren auf 0 gesetzt und die\r\n            // Positionen gleich der Position der ListBoxFigure.\r\n            // Hierzu bekommt parts eine neue Zuweisung.\r\n            parts = liBoFi.getFigures();\r\n            while (parts.hasMoreElements()) {\r\n                liBoFiPart = (RectangleFigure) parts.nextElement();\r\n                liBoFiPart.getBounds().width = 0;\r\n                liBoFiPart.getBounds().x = liBoFi.getBounds().x;\r\n                liBoFiPart.getBounds().y = liBoFi.getBounds().y;\r\n            }\r\n            // Hier werden die DisplayBoxen aller TextBoxFigures neu berechnet.\r\n            // Beachte, dass die Berechnung bewirkt, dass die Position auf 0,0\r\n            // gesetzt wird. Daher werden die Figuren anschliessend um die Posi-\r\n            // tion der ListBoxFigure verschoben.\r\n            // Da in der folgenden NeuBerechnung die FilledRectangularBox nicht\r\n            // mitberuecksichtigt wird, war es oben noetig, die Position aller\r\n            // TeilFiguren auf die der ListBoxFigure zu setzten.\r\n            // Es wird mit der TextBoxFigure des HeaderModels begonnen.\r\n            teBoFi = (TextBoxFigure) ((ObjectModel) liBoFi.getModel()).getHeaderModel().getFigure();\r\n            teBoFi.setBounds(this.getTextBoxFigureBuilder().computeDisplayBox(teBoFi));\r\n            teBoFi.moveBy(liBoFi.getBounds().x, liBoFi.getBounds().y);\r\n            // Jetzt kommen die TextBoxFigures der AttributeModels dran.\r\n            parts = ((ObjectModel) liBoFi.getModel()).getAttributeModels();\r\n            while (parts.hasMoreElements()) {\r\n                teBoFi = (TextBoxFigure) ((AttributeModel) parts.nextElement()).getFigure();\r\n                teBoFi.setBounds(this.getTextBoxFigureBuilder().computeDisplayBox(teBoFi));\r\n                teBoFi.moveBy(liBoFi.getBounds().x, liBoFi.getBounds().y);\r\n            }\r\n        } catch (Exception ex) {\r\n            ListBoxFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_SETTING_ALL_ATTRIBUTES_VISIBLE), ex);\r\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_SETTING_ALL_ATTRIBUTES_VISIBLE));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht so vor: Zunaechst werden alle\r\n     * AttributeModels, die in der ListBoxFigure enthalten sind und die kein\r\n     * ConnectionModel haben, auf unvisible gesetzt. Dann wird die Weite von\r\n     * allen Teilen der ListBoxFigure auf 0 (null) gesetzt, und die Orte werden\r\n     * gleich dem Ort der ListBoxFigure gesetzt. Mit allen TeilFiguren, die\r\n     * TextBoxFigure sind, geschieht dann folgendes: Die DisplayBox wird erneut\r\n     * berechnet. Die Be- rechnung der DisplayBox hat zur Folge, dass der Ort\r\n     * der Figure wieder auf 0,0 gesetzt wird. Also wird die TextBoxFigure\r\n     * wieder um die Position der ListBoxFigure verschoben.\r\n     */\r\n    public void setAllUnexploredAttributesUnvisible(ListBoxFigure liBoFi) {\r\n        ObjectModel objModl;\r\n        StandardEnumeration parts;\r\n        TextBoxFigure teBoFi;\r\n        AttributeModel attrModl;\r\n        RectangleFigure liBoFiPart;\r\n        objModl = (ObjectModel) liBoFi.getModel();\r\n        objModl.getObjectViewManager().setUnexploredAttributesVisible(false);\r\n        parts = objModl.getAttributeModels();\r\n        try {\r\n            // Hier werden alle Attribute, die nicht explored sind, unsichtbar\r\n            // gesetzt.\r\n            while (parts.hasMoreElements()) {\r\n                attrModl = (AttributeModel) parts.nextElement();\r\n                if (attrModl.getConnectionModel() == null) {\r\n                    ((TextBoxFigure) attrModl.getFigure()).setUnvisible();\r\n                }\r\n            }\r\n            // Hier werden die Weiten aller Teilfiguren auf 0 gesetzt und die\r\n            // Positionen gleich der Position der ListBoxFigure.\r\n            // Hierzu bekommt parts eine neue Zuweisung.\r\n            parts = liBoFi.getFigures();\r\n            while (parts.hasMoreElements()) {\r\n                liBoFiPart = (RectangleFigure) parts.nextElement();\r\n                liBoFiPart.getBounds().width = 0;\r\n                liBoFiPart.getBounds().x = liBoFi.getBounds().x;\r\n                liBoFiPart.getBounds().y = liBoFi.getBounds().y;\r\n            }\r\n            // Hier werden die DisplayBoxen aller TextBoxFigures neu berechnet.\r\n            // Beachte, dass die Berechnung bewirkt, dass die Position auf 0,0\r\n            // gesetzt wird. Daher werden die Figuren anschliessend um die Posi-\r\n            // tion der ListBoxFigure verschoben.\r\n            // Da in der folgenden NeuBerechnung die FilledRectangularBox nicht\r\n            // mitberuecksichtigt wird, war es oben noetig, die Position aller\r\n            // TeilFiguren auf die der ListBoxFigure zu setzten.\r\n            // Es wird mit der TextBoxFigure des HeaderModels begonnen.\r\n            teBoFi = (TextBoxFigure) ((ObjectModel) liBoFi.getModel()).getHeaderModel().getFigure();\r\n            teBoFi.setBounds(this.getTextBoxFigureBuilder().computeDisplayBox(teBoFi));\r\n            teBoFi.moveBy(liBoFi.getBounds().x, liBoFi.getBounds().y);\r\n            // Jetzt kommen die TextBoxFigures der AttributeModels dran.\r\n            parts = ((ObjectModel) liBoFi.getModel()).getAttributeModels();\r\n            while (parts.hasMoreElements()) {\r\n                teBoFi = (TextBoxFigure) ((AttributeModel) parts.nextElement()).getFigure();\r\n                teBoFi.setBounds(this.getTextBoxFigureBuilder().computeDisplayBox(teBoFi));\r\n                teBoFi.moveBy(liBoFi.getBounds().x, liBoFi.getBounds().y);\r\n            }\r\n        } catch (Exception ex) {\r\n            ListBoxFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_SETTING_ALL_ATTRIBUTES_UNVISIBLE), ex);\r\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_SETTING_ALL_ATTRIBUTES_UNVISIBLE));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht so vor: Zunaechst werden alle\r\n     * AttributeModels, die in der ListBoxFigure enthalten sind und die kein\r\n     * ConnectionModel haben, auf unvisible gesetzt. Dann wird die Weite von\r\n     * allen Teilen der ListBoxFigure auf 0 (null) gesetzt, und die Orte werden\r\n     * gleich dem Ort der ListBoxFigure gesetzt. Mit allen TeilFiguren, die\r\n     * TextBoxFigure sind, geschieht dann folgendes: Die DisplayBox wird erneut\r\n     * berechnet. Die Be- rechnung der DisplayBox hat zur Folge, dass der Ort\r\n     * der Figure wieder auf 0,0 gesetzt wird. Also wird die TextBoxFigure\r\n     * wieder um die Position der ListBoxFigure verschoben.\r\n     */\r\n    public void setAllUnexploredAttributesVisible(ListBoxFigure liBoFi) {\r\n        ObjectModel objModl;\r\n        de.paragon.explorer.util.StandardEnumeration parts;\r\n        TextBoxFigure teBoFi;\r\n        AttributeModel attrModl;\r\n        RectangleFigure liBoFiPart;\r\n        objModl = (ObjectModel) liBoFi.getModel();\r\n        objModl.getObjectViewManager().setUnexploredAttributesVisible(true);\r\n        parts = objModl.getAttributeModels();\r\n        try {\r\n            // Hier werden alle Attribute, die nicht explored sind, unsichtbar\r\n            // gesetzt.\r\n            while (parts.hasMoreElements()) {\r\n                attrModl = (AttributeModel) parts.nextElement();\r\n                if (objModl.getObjectViewManager().shouldBeVisible(attrModl)) {\r\n                    ((TextBoxFigure) attrModl.getFigure()).setVisible();\r\n                }\r\n            }\r\n            // Hier werden die Weiten aller Teilfiguren auf 0 gesetzt und die\r\n            // Positionen gleich der Position der ListBoxFigure.\r\n            // Hierzu bekommt parts eine neue Zuweisung.\r\n            parts = liBoFi.getFigures();\r\n            while (parts.hasMoreElements()) {\r\n                liBoFiPart = (RectangleFigure) parts.nextElement();\r\n                liBoFiPart.getBounds().width = 0;\r\n                liBoFiPart.getBounds().x = liBoFi.getBounds().x;\r\n                liBoFiPart.getBounds().y = liBoFi.getBounds().y;\r\n            }\r\n            // Hier werden die DisplayBoxen aller TextBoxFigures neu berechnet.\r\n            // Beachte, dass die Berechnung bewirkt, dass die Position auf 0,0\r\n            // gesetzt wird. Daher werden die Figuren anschliessend um die Posi-\r\n            // tion der ListBoxFigure verschoben.\r\n            // Da in der folgenden NeuBerechnung die FilledRectangularBox nicht\r\n            // mitberuecksichtigt wird, war es oben noetig, die Position aller\r\n            // TeilFiguren auf die der ListBoxFigure zu setzten.\r\n            // Es wird mit der TextBoxFigure des HeaderModels begonnen.\r\n            teBoFi = (TextBoxFigure) ((ObjectModel) liBoFi.getModel()).getHeaderModel().getFigure();\r\n            teBoFi.setBounds(this.getTextBoxFigureBuilder().computeDisplayBox(teBoFi));\r\n            teBoFi.moveBy(liBoFi.getBounds().x, liBoFi.getBounds().y);\r\n            // Jetzt kommen die TextBoxFigures der AttributeModels dran.\r\n            parts = ((ObjectModel) liBoFi.getModel()).getAttributeModels();\r\n            while (parts.hasMoreElements()) {\r\n                teBoFi = (TextBoxFigure) ((AttributeModel) parts.nextElement()).getFigure();\r\n                teBoFi.setBounds(this.getTextBoxFigureBuilder().computeDisplayBox(teBoFi));\r\n                teBoFi.moveBy(liBoFi.getBounds().x, liBoFi.getBounds().y);\r\n            }\r\n        } catch (Exception ex) {\r\n            ListBoxFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_SETTING_ALL_ATTRIBUTES_VISIBLE), ex);\r\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_SETTING_ALL_ATTRIBUTES_VISIBLE));\r\n        }\r\n    }\r\n\r\n    private void setFigureHeight(Figure figure, int y) {\r\n        try {\r\n            figure.getDisplayBox().getRectangle().height = y;\r\n        } catch (Exception ex) {\r\n            ListBoxFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_BUILDING_MODELL), ex);\r\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_BUILDING_MODELL));\r\n        }\r\n    }\r\n\r\n    private void setFigureWidth(Figure figure, int x) {\r\n        try {\r\n            figure.getDisplayBox().getRectangle().width = x;\r\n        } catch (Exception ex) {\r\n            ListBoxFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_BUILDING_MODELL), ex);\r\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_BUILDING_MODELL));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht davon aus, dass alle Verknuepfungen bereits\r\n     * existieren und die Teilfiguren -jede fuer sich- gebaut sind. Sie weist\r\n     * jeder Teilfigur und der ListBoxFigure die Breite zu. Zu Beachten gilt\r\n     * dabei, dass dies auch fuer die \"unvisible\" TextBoxFigures geschieht,\r\n     * damit die Connections richtig posi- tioniert sind.\r\n     */\r\n    private void setListBoxFigureWidths(ListBoxFigure list, int width) {\r\n        /* damn the class Rectangle for having no get method for the width! */\r\n        StandardEnumeration figParts;\r\n        try {\r\n            figParts = list.getFigures();\r\n        } catch (Exception ex) {\r\n            ListBoxFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_GETTING_FIGURES), ex);\r\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_GETTING_FIGURES));\r\n            figParts = null;\r\n        }\r\n        this.setFigureWidth(list, width);\r\n        if (figParts != null) {\r\n            while (figParts.hasMoreElements()) {\r\n                this.setFigureWidth((Figure) figParts.nextElement(), width);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht so vor: Zunaechst werden alle\r\n     * AttributeModels, die in der ListBoxFigure enthalten sind, auf unvisible\r\n     * gesetzt. Dann wird die Weite von allen Teilen der ListBoxFigure auf 0\r\n     * (null) gesetzt, und die Orte werden gleich dem Ort der ListBoxFigure\r\n     * gesetzt. Mit allen TeilFiguren, die TextBoxFigure sind, geschieht dann\r\n     * folgendes: Die DisplayBox wird erneut berechnet. Die Be- rechnung der\r\n     * DisplayBox hat zur Folge, dass der Ort der Figure wieder auf 0,0 gesetzt\r\n     * wird. Also wird die TextBoxFigure wieder um die Position der\r\n     * ListBoxFigure verschoben.\r\n     */\r\n    public void setNullAttributesUnvisible(ListBoxFigure liBoFi) {\r\n        ObjectModel objModl;\r\n        StandardEnumeration parts;\r\n        TextBoxFigure teBoFi;\r\n        AttributeModel attrModl;\r\n        RectangleFigure liBoFiPart;\r\n        objModl = (ObjectModel) liBoFi.getModel();\r\n        objModl.getObjectViewManager().setNullAttributesVisible(false);\r\n        parts = objModl.getAttributeModels();\r\n        try {\r\n            // Hier werden die Attribute unsichtbar gesetzt, deren Wert gleich\r\n            // null ist.\r\n            while (parts.hasMoreElements()) {\r\n                attrModl = (AttributeModel) parts.nextElement();\r\n                // if (attrModl.getValue() == null) {\r\n                if (NullObject.isNullObject(attrModl.getValue())) {\r\n                    ((TextBoxFigure) attrModl.getFigure()).setUnvisible();\r\n                    // this.getConnectionBuilder().removeSingleConnection(attrModl);\r\n                }\r\n            }\r\n            // Hier werden die Weiten aller Teilfiguren auf 0 gesetzt und die\r\n            // Positionen gleich der Position der ListBoxFigure.\r\n            // Hierzu bekommt parts eine neue Zuweisung.\r\n            parts = liBoFi.getFigures();\r\n            while (parts.hasMoreElements()) {\r\n                liBoFiPart = (RectangleFigure) parts.nextElement();\r\n                liBoFiPart.getBounds().width = 0;\r\n                liBoFiPart.getBounds().x = liBoFi.getBounds().x;\r\n                liBoFiPart.getBounds().y = liBoFi.getBounds().y;\r\n            }\r\n            // Hier werden die DisplayBoxen aller TextBoxFigures neu berechnet.\r\n            // Beachte, dass die Berechnung bewirkt, dass die Position auf 0,0\r\n            // gesetzt wird. Daher werden die Figuren anschliessend um die Posi-\r\n            // tion der ListBoxFigure verschoben.\r\n            // Da in der folgenden NeuBerechnung die FilledRectangularBox nicht\r\n            // mitberuecksichtigt wird, war es oben noetig, die Position aller\r\n            // TeilFiguren auf die der ListBoxFigure zu setzten.\r\n            // Es wird mit der TextBoxFigure des HeaderModels begonnen.\r\n            teBoFi = (TextBoxFigure) ((ObjectModel) liBoFi.getModel()).getHeaderModel().getFigure();\r\n            teBoFi.setBounds(this.getTextBoxFigureBuilder().computeDisplayBox(teBoFi));\r\n            teBoFi.moveBy(liBoFi.getBounds().x, liBoFi.getBounds().y);\r\n            // Jetzt kommen die TextBoxFigures der AttributeModels dran.\r\n            parts = ((ObjectModel) liBoFi.getModel()).getAttributeModels();\r\n            while (parts.hasMoreElements()) {\r\n                teBoFi = (TextBoxFigure) ((AttributeModel) parts.nextElement()).getFigure();\r\n                teBoFi.setBounds(this.getTextBoxFigureBuilder().computeDisplayBox(teBoFi));\r\n                teBoFi.moveBy(liBoFi.getBounds().x, liBoFi.getBounds().y);\r\n            }\r\n        } catch (Exception ex) {\r\n            ListBoxFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_SETTING_ALL_ATTRIBUTES_UNVISIBLE), ex);\r\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_SETTING_ALL_ATTRIBUTES_UNVISIBLE));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht so vor: Zunaechst werden alle\r\n     * AttributeModels, die in der ListBoxFigure enthalten sind, auf unvisible\r\n     * gesetzt. Dann wird die Weite von allen Teilen der ListBoxFigure auf 0\r\n     * (null) gesetzt, und die Orte werden gleich dem Ort der ListBoxFigure\r\n     * gesetzt. Mit allen TeilFiguren, die TextBoxFigure sind, geschieht dann\r\n     * folgendes: Die DisplayBox wird erneut berechnet. Die Be- rechnung der\r\n     * DisplayBox hat zur Folge, dass der Ort der Figure wieder auf 0,0 gesetzt\r\n     * wird. Also wird die TextBoxFigure wieder um die Position der\r\n     * ListBoxFigure verschoben.\r\n     */\r\n    public void setNullAttributesVisible(ListBoxFigure liBoFi) {\r\n        ObjectModel objModl;\r\n        Enumeration<?> parts;\r\n        TextBoxFigure teBoFi;\r\n        AttributeModel attrModl;\r\n        RectangleFigure liBoFiPart;\r\n        objModl = (ObjectModel) liBoFi.getModel();\r\n        objModl.getObjectViewManager().setNullAttributesVisible(true);\r\n        parts = objModl.getAttributeModels().getVector().elements();\r\n        try {\r\n            // Hier werden die Attribute unsichtbar gesetzt, deren Wert gleich\r\n            // null ist.\r\n            while (parts.hasMoreElements()) {\r\n                attrModl = (AttributeModel) parts.nextElement();\r\n                // if (attrModl.getValue() == null) {\r\n                if (objModl.getObjectViewManager().shouldBeVisible(attrModl)) {\r\n                    ((TextBoxFigure) attrModl.getFigure()).setVisible();\r\n                }\r\n            }\r\n            // Hier werden die Weiten aller Teilfiguren auf 0 gesetzt und die\r\n            // Positionen gleich der Position der ListBoxFigure.\r\n            // Hierzu bekommt parts eine neue Zuweisung.\r\n            parts = liBoFi.getFigures();\r\n            while (parts.hasMoreElements()) {\r\n                liBoFiPart = (RectangleFigure) parts.nextElement();\r\n                liBoFiPart.getBounds().width = 0;\r\n                liBoFiPart.getBounds().x = liBoFi.getBounds().x;\r\n                liBoFiPart.getBounds().y = liBoFi.getBounds().y;\r\n            }\r\n            // Hier werden die DisplayBoxen aller TextBoxFigures neu berechnet.\r\n            // Beachte, dass die Berechnung bewirkt, dass die Position auf 0,0\r\n            // gesetzt wird. Daher werden die Figuren anschliessend um die Posi-\r\n            // tion der ListBoxFigure verschoben.\r\n            // Da in der folgenden NeuBerechnung die FilledRectangularBox nicht\r\n            // mitberuecksichtigt wird, war es oben noetig, die Position aller\r\n            // TeilFiguren auf die der ListBoxFigure zu setzten.\r\n            // Es wird mit der TextBoxFigure des HeaderModels begonnen.\r\n            teBoFi = (TextBoxFigure) ((ObjectModel) liBoFi.getModel()).getHeaderModel().getFigure();\r\n            teBoFi.setBounds(this.getTextBoxFigureBuilder().computeDisplayBox(teBoFi));\r\n            teBoFi.moveBy(liBoFi.getBounds().x, liBoFi.getBounds().y);\r\n            // Jetzt kommen die TextBoxFigures der AttributeModels dran.\r\n            parts = ((ObjectModel) liBoFi.getModel()).getAttributeModels();\r\n            while (parts.hasMoreElements()) {\r\n                teBoFi = (TextBoxFigure) ((AttributeModel) parts.nextElement()).getFigure();\r\n                teBoFi.setBounds(this.getTextBoxFigureBuilder().computeDisplayBox(teBoFi));\r\n                teBoFi.moveBy(liBoFi.getBounds().x, liBoFi.getBounds().y);\r\n            }\r\n        } catch (Exception ex) {\r\n            ListBoxFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_SETTING_ALL_ATTRIBUTES_VISIBLE), ex);\r\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_SETTING_ALL_ATTRIBUTES_VISIBLE));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht so vor: Zunaechst wird die TextBoxFigure,\r\n     * auf unvisible gesetzt. Dann wird die Weite von allen Teilen der\r\n     * ListBoxFigure auf 0 (null) gesetzt, und die Orte werden gleich dem Ort\r\n     * der ListBoxFigure gesetzt. Mit allen TeilFiguren, die TextBoxFigure sind,\r\n     * geschieht dann folgendes: Die DisplayBox wird erneut berechnet. Die Be-\r\n     * rechnung der DisplayBox hat zur Folge, dass der Ort der Figure wieder auf\r\n     * 0,0 gesetzt wird. Also wird die TextBoxFigure wieder um die Position der\r\n     * ListBoxFigure verschoben.\r\n     */\r\n    public void setSingleAttributeUnvisible(TextBoxFigure texBoFi) {\r\n        ListBoxFigure liBoFi = (ListBoxFigure) texBoFi.getParent();\r\n        de.paragon.explorer.util.StandardEnumeration parts;\r\n        TextBoxFigure teBoFi;\r\n        // AttributeModel attrModl;\r\n        RectangleFigure liBoFiPart;\r\n        try {\r\n            // Hier wird das Attribut unsichtbar gesetzt.\r\n            texBoFi.setUnvisible();\r\n            // this.getConnectionBuilder().removeSingleConnection((AttributeModel)\r\n            // texBoFi.getModel());\r\n            // Hier werden die Weiten aller Teilfiguren auf 0 gesetzt und die\r\n            // Positionen gleich der Position der ListBoxFigure.\r\n            // Hierzu bekommt parts eine neue Zuweisung.\r\n            parts = liBoFi.getFigures();\r\n            while (parts.hasMoreElements()) {\r\n                liBoFiPart = (RectangleFigure) parts.nextElement();\r\n                liBoFiPart.getBounds().width = 0;\r\n                liBoFiPart.getBounds().x = liBoFi.getBounds().x;\r\n                liBoFiPart.getBounds().y = liBoFi.getBounds().y;\r\n            }\r\n            // Hier werden die DisplayBoxen aller TextBoxFigures neu berechnet.\r\n            // Beachte, dass die Berechnung bewirkt, dass die Position auf 0,0\r\n            // gesetzt wird. Daher werden die Figuren anschliessend um die Posi-\r\n            // tion der ListBoxFigure verschoben.\r\n            // Da in der folgenden NeuBerechnung die FilledRectangularBox nicht\r\n            // mitberuecksichtigt wird, war es oben noetig, die Position aller\r\n            // TeilFiguren auf die der ListBoxFigure zu setzten.\r\n            // Es wird mit der TextBoxFigure des HeaderModels begonnen.\r\n            teBoFi = (TextBoxFigure) ((ObjectModel) liBoFi.getModel()).getHeaderModel().getFigure();\r\n            teBoFi.setBounds(this.getTextBoxFigureBuilder().computeDisplayBox(teBoFi));\r\n            teBoFi.moveBy(liBoFi.getBounds().x, liBoFi.getBounds().y);\r\n            // Jetzt kommen die TextBoxFigures der AttributeModels dran.\r\n            parts = ((ObjectModel) liBoFi.getModel()).getAttributeModels();\r\n            while (parts.hasMoreElements()) {\r\n                teBoFi = (TextBoxFigure) ((AttributeModel) parts.nextElement()).getFigure();\r\n                teBoFi.setBounds(this.getTextBoxFigureBuilder().computeDisplayBox(teBoFi));\r\n                teBoFi.moveBy(liBoFi.getBounds().x, liBoFi.getBounds().y);\r\n            }\r\n        } catch (Exception ex) {\r\n            ListBoxFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_SETTING_ALL_ATTRIBUTES_UNVISIBLE), ex);\r\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_SETTING_ALL_ATTRIBUTES_UNVISIBLE));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht so vor: Zunaechst werden alle\r\n     * AttributeModels, die in der ListBoxFigure enthalten sind, auf visible\r\n     * gesetzt. Dann wird die Weite von allen Teilen der ListBoxFigure auf 0\r\n     * (null) gesetzt, und die Orte werden gleich dem Ort der ListBoxFigure\r\n     * gesetzt. Mit allen TeilFiguren, die TextBoxFigure sind, geschieht dann\r\n     * folgendes: Die DisplayBox wird erneut berechnet. Die Be- rechnung der\r\n     * DisplayBox hat zur Folge, dass der Ort der Figure wieder auf 0,0 gesetzt\r\n     * wird. Also wird die TextBoxFigure wieder um die Position der\r\n     * ListBoxFigure verschoben.\r\n     */\r\n    public void setSingleAttributeVisible(TextBoxFigure texBoFi) {\r\n        ListBoxFigure liBoFi = (ListBoxFigure) texBoFi.getParent();\r\n        StandardEnumeration parts;\r\n        TextBoxFigure teBoFi;\r\n        // AttributeModel attrModl;\r\n        RectangleFigure liBoFiPart;\r\n        try {\r\n            texBoFi.setVisible();\r\n            // Hier werden die Weiten aller Teilfiguren auf 0 gesetzt und die\r\n            // Positionen gleich der Position der ListBoxFigure.\r\n            // Hierzu bekommt parts eine neue Zuweisung.\r\n            parts = liBoFi.getFigures();\r\n            while (parts.hasMoreElements()) {\r\n                liBoFiPart = (RectangleFigure) parts.nextElement();\r\n                liBoFiPart.getBounds().width = 0;\r\n                liBoFiPart.getBounds().x = liBoFi.getBounds().x;\r\n                liBoFiPart.getBounds().y = liBoFi.getBounds().y;\r\n            }\r\n            // Hier werden die DisplayBoxen aller TextBoxFigures neu berechnet.\r\n            // Beachte, dass die Berechnung bewirkt, dass die Position auf 0,0\r\n            // gesetzt wird. Daher werden die Figuren anschliessend um die Posi-\r\n            // tion der ListBoxFigure verschoben.\r\n            // Da in der folgenden NeuBerechnung die FilledRectangularBox nicht\r\n            // mitberuecksichtigt wird, war es oben noetig, die Position aller\r\n            // TeilFiguren auf die der ListBoxFigure zu setzten.\r\n            // Es wird mit der TextBoxFigure des HeaderModels begonnen.\r\n            teBoFi = (TextBoxFigure) ((ObjectModel) liBoFi.getModel()).getHeaderModel().getFigure();\r\n            teBoFi.setBounds(this.getTextBoxFigureBuilder().computeDisplayBox(teBoFi));\r\n            teBoFi.moveBy(liBoFi.getBounds().x, liBoFi.getBounds().y);\r\n            // Jetzt kommen die TextBoxFigures der AttributeModels dran.\r\n            parts = ((ObjectModel) liBoFi.getModel()).getAttributeModels();\r\n            while (parts.hasMoreElements()) {\r\n                teBoFi = (TextBoxFigure) ((AttributeModel) parts.nextElement()).getFigure();\r\n                teBoFi.setBounds(this.getTextBoxFigureBuilder().computeDisplayBox(teBoFi));\r\n                teBoFi.moveBy(liBoFi.getBounds().x, liBoFi.getBounds().y);\r\n            }\r\n        } catch (Exception ex) {\r\n            ListBoxFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_SETTING_ALL_ATTRIBUTES_VISIBLE), ex);\r\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_SETTING_ALL_ATTRIBUTES_VISIBLE));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht so vor: Zunaechst werden alle\r\n     * AttributeModels, die in der ListBoxFigure enthalten sind, auf unvisible\r\n     * gesetzt. Dann wird die Weite von allen Teilen der ListBoxFigure auf 0\r\n     * (null) gesetzt, und die Orte werden gleich dem Ort der ListBoxFigure\r\n     * gesetzt. Mit allen TeilFiguren, die TextBoxFigure sind, geschieht dann\r\n     * folgendes: Die DisplayBox wird erneut berechnet. Die Be- rechnung der\r\n     * DisplayBox hat zur Folge, dass der Ort der Figure wieder auf 0,0 gesetzt\r\n     * wird. Also wird die TextBoxFigure wieder um die Position der\r\n     * ListBoxFigure verschoben.\r\n     */\r\n    public void setStaticAttributesUnvisible(ListBoxFigure liBoFi) {\r\n        ObjectModel objModl;\r\n        de.paragon.explorer.util.StandardEnumeration parts;\r\n        TextBoxFigure teBoFi;\r\n        AttributeModel attrModl;\r\n        RectangleFigure liBoFiPart;\r\n        objModl = (ObjectModel) liBoFi.getModel();\r\n        objModl.getObjectViewManager().setStaticAttributesVisible(false);\r\n        parts = objModl.getAttributeModels();\r\n        try {\r\n            // Hier werden die Attribute unsichtbar gesetzt, deren Wert gleich\r\n            // null ist.\r\n            while (parts.hasMoreElements()) {\r\n                attrModl = (AttributeModel) parts.nextElement();\r\n                if (Modifier.isStatic(attrModl.getModifiers())) {\r\n                    ((TextBoxFigure) attrModl.getFigure()).setUnvisible();\r\n                    // this.getConnectionBuilder().removeSingleConnection(attrModl);\r\n                }\r\n            }\r\n            // Hier werden die Weiten aller Teilfiguren auf 0 gesetzt und die\r\n            // Positionen gleich der Position der ListBoxFigure.\r\n            // Hierzu bekommt parts eine neue Zuweisung.\r\n            parts = liBoFi.getFigures();\r\n            while (parts.hasMoreElements()) {\r\n                liBoFiPart = (RectangleFigure) parts.nextElement();\r\n                liBoFiPart.getBounds().width = 0;\r\n                liBoFiPart.getBounds().x = liBoFi.getBounds().x;\r\n                liBoFiPart.getBounds().y = liBoFi.getBounds().y;\r\n            }\r\n            // Hier werden die DisplayBoxen aller TextBoxFigures neu berechnet.\r\n            // Beachte, dass die Berechnung bewirkt, dass die Position auf 0,0\r\n            // gesetzt wird. Daher werden die Figuren anschliessend um die Posi-\r\n            // tion der ListBoxFigure verschoben.\r\n            // Da in der folgenden NeuBerechnung die FilledRectangularBox nicht\r\n            // mitberuecksichtigt wird, war es oben noetig, die Position aller\r\n            // TeilFiguren auf die der ListBoxFigure zu setzten.\r\n            // Es wird mit der TextBoxFigure des HeaderModels begonnen.\r\n            teBoFi = (TextBoxFigure) ((ObjectModel) liBoFi.getModel()).getHeaderModel().getFigure();\r\n            teBoFi.setBounds(this.getTextBoxFigureBuilder().computeDisplayBox(teBoFi));\r\n            teBoFi.moveBy(liBoFi.getBounds().x, liBoFi.getBounds().y);\r\n            // Jetzt kommen die TextBoxFigures der AttributeModels dran.\r\n            parts = ((ObjectModel) liBoFi.getModel()).getAttributeModels();\r\n            while (parts.hasMoreElements()) {\r\n                teBoFi = (TextBoxFigure) ((AttributeModel) parts.nextElement()).getFigure();\r\n                teBoFi.setBounds(this.getTextBoxFigureBuilder().computeDisplayBox(teBoFi));\r\n                teBoFi.moveBy(liBoFi.getBounds().x, liBoFi.getBounds().y);\r\n            }\r\n        } catch (Exception ex) {\r\n            ListBoxFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_SETTING_ALL_ATTRIBUTES_UNVISIBLE), ex);\r\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_SETTING_ALL_ATTRIBUTES_UNVISIBLE));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht so vor: Zunaechst werden alle\r\n     * AttributeModels, die in der ListBoxFigure enthalten sind, auf unvisible\r\n     * gesetzt. Dann wird die Weite von allen Teilen der ListBoxFigure auf 0\r\n     * (null) gesetzt, und die Orte werden gleich dem Ort der ListBoxFigure\r\n     * gesetzt. Mit allen TeilFiguren, die TextBoxFigure sind, geschieht dann\r\n     * folgendes: Die DisplayBox wird erneut berechnet. Die Be- rechnung der\r\n     * DisplayBox hat zur Folge, dass der Ort der Figure wieder auf 0,0 gesetzt\r\n     * wird. Also wird die TextBoxFigure wieder um die Position der\r\n     * ListBoxFigure verschoben.\r\n     */\r\n    public void setStaticAttributesVisible(ListBoxFigure liBoFi) {\r\n        ObjectModel objModl;\r\n        de.paragon.explorer.util.StandardEnumeration parts;\r\n        TextBoxFigure teBoFi;\r\n        AttributeModel attrModl;\r\n        RectangleFigure liBoFiPart;\r\n        objModl = (ObjectModel) liBoFi.getModel();\r\n        objModl.getObjectViewManager().setStaticAttributesVisible(true);\r\n        parts = objModl.getAttributeModels();\r\n        try {\r\n            // Hier werden die Attribute unsichtbar gesetzt, deren Wert gleich\r\n            // null ist.\r\n            while (parts.hasMoreElements()) {\r\n                attrModl = (AttributeModel) parts.nextElement();\r\n                if (objModl.getObjectViewManager().shouldBeVisible(attrModl)) {\r\n                    ((TextBoxFigure) attrModl.getFigure()).setVisible();\r\n                }\r\n            }\r\n            // Hier werden die Weiten aller Teilfiguren auf 0 gesetzt und die\r\n            // Positionen gleich der Position der ListBoxFigure.\r\n            // Hierzu bekommt parts eine neue Zuweisung.\r\n            parts = liBoFi.getFigures();\r\n            while (parts.hasMoreElements()) {\r\n                liBoFiPart = (RectangleFigure) parts.nextElement();\r\n                liBoFiPart.getBounds().width = 0;\r\n                liBoFiPart.getBounds().x = liBoFi.getBounds().x;\r\n                liBoFiPart.getBounds().y = liBoFi.getBounds().y;\r\n            }\r\n            // Hier werden die DisplayBoxen aller TextBoxFigures neu berechnet.\r\n            // Beachte, dass die Berechnung bewirkt, dass die Position auf 0,0\r\n            // gesetzt wird. Daher werden die Figuren anschliessend um die Posi-\r\n            // tion der ListBoxFigure verschoben.\r\n            // Da in der folgenden NeuBerechnung die FilledRectangularBox nicht\r\n            // mitberuecksichtigt wird, war es oben noetig, die Position aller\r\n            // TeilFiguren auf die der ListBoxFigure zu setzten.\r\n            // Es wird mit der TextBoxFigure des HeaderModels begonnen.\r\n            teBoFi = (TextBoxFigure) ((ObjectModel) liBoFi.getModel()).getHeaderModel().getFigure();\r\n            teBoFi.setBounds(this.getTextBoxFigureBuilder().computeDisplayBox(teBoFi));\r\n            teBoFi.moveBy(liBoFi.getBounds().x, liBoFi.getBounds().y);\r\n            // Jetzt kommen die TextBoxFigures der AttributeModels dran.\r\n            parts = ((ObjectModel) liBoFi.getModel()).getAttributeModels();\r\n            while (parts.hasMoreElements()) {\r\n                teBoFi = (TextBoxFigure) ((AttributeModel) parts.nextElement()).getFigure();\r\n                teBoFi.setBounds(this.getTextBoxFigureBuilder().computeDisplayBox(teBoFi));\r\n                teBoFi.moveBy(liBoFi.getBounds().x, liBoFi.getBounds().y);\r\n            }\r\n        } catch (Exception ex) {\r\n            ListBoxFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_SETTING_ALL_ATTRIBUTES_VISIBLE), ex);\r\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_SETTING_ALL_ATTRIBUTES_VISIBLE));\r\n        }\r\n    }\r\n\r\n    public void updateObject(ListBoxFigure liBoFi) {\r\n        StandardEnumeration parts;\r\n        TextBoxFigure teBoFi;\r\n        RectangleFigure liBoFiPart;\r\n        try {\r\n            // Hier werden die Weiten aller Teilfiguren auf 0 gesetzt und die\r\n            // Positionen gleich der Position der ListBoxFigure.\r\n            // Hierzu bekommt parts eine neue Zuweisung.\r\n            this.getTextBoxFigureBuilder().updateHeader((ObjectModel) liBoFi.getModel());\r\n            this.getTextBoxFigureBuilder().updateAttributes((ObjectModel) liBoFi.getModel());\r\n            parts = liBoFi.getFigures();\r\n            while (parts.hasMoreElements()) {\r\n                liBoFiPart = (RectangleFigure) parts.nextElement();\r\n                liBoFiPart.getBounds().width = 0;\r\n                liBoFiPart.getBounds().x = liBoFi.getBounds().x;\r\n                liBoFiPart.getBounds().y = liBoFi.getBounds().y;\r\n            }\r\n            // Hier werden die DisplayBoxen aller TextBoxFigures neu berechnet.\r\n            // Beachte, dass die Berechnung bewirkt, dass die Position auf 0,0\r\n            // gesetzt wird. Daher werden die Figuren anschliessend um die Posi-\r\n            // tion der ListBoxFigure verschoben.\r\n            // Da in der folgenden NeuBerechnung die FilledRectangularBox nicht\r\n            // mitberuecksichtigt wird, war es oben noetig, die Position aller\r\n            // TeilFiguren auf die der ListBoxFigure zu setzten.\r\n            // Es wird mit der TextBoxFigure des HeaderModels begonnen.\r\n            teBoFi = (TextBoxFigure) ((ObjectModel) liBoFi.getModel()).getHeaderModel().getFigure();\r\n            teBoFi.setBounds(this.getTextBoxFigureBuilder().computeDisplayBox(teBoFi));\r\n            teBoFi.moveBy(liBoFi.getBounds().x, liBoFi.getBounds().y);\r\n            // Jetzt kommen die TextBoxFigures der AttributeModels dran.\r\n            parts = ((ObjectModel) liBoFi.getModel()).getAttributeModels();\r\n            while (parts.hasMoreElements()) {\r\n                teBoFi = (TextBoxFigure) ((AttributeModel) parts.nextElement()).getFigure();\r\n                teBoFi.setBounds(this.getTextBoxFigureBuilder().computeDisplayBox(teBoFi));\r\n                teBoFi.moveBy(liBoFi.getBounds().x, liBoFi.getBounds().y);\r\n            }\r\n        } catch (Exception ex) {\r\n            ListBoxFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_UPDATING_FIGURES), ex);\r\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_UPDATING_FIGURES));\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/figure/ListBoxFigureBuilderTest.java",
		"test_prompt": "// ListBoxFigureBuilderTest.java\npackage de.paragon.explorer.figure;\n\nimport java.lang.reflect.Modifier;\nimport java.util.Enumeration;\nimport org.apache.log4j.Logger;\nimport de.paragon.explorer.gui.Warning;\nimport de.paragon.explorer.model.AttributeModel;\nimport de.paragon.explorer.model.NullObject;\nimport de.paragon.explorer.model.ObjectHeaderModel;\nimport de.paragon.explorer.model.ObjectModel;\nimport de.paragon.explorer.model.ObjectModelPart;\nimport de.paragon.explorer.util.LoggerFactory;\nimport de.paragon.explorer.util.ResourceBundlePurchaser;\nimport de.paragon.explorer.util.StandardEnumeration;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ListBoxFigureBuilder}.\n* It contains ten unit test cases for the {@link ListBoxFigureBuilder#getInstance()} method.\n*/\nclass ListBoxFigureBuilderTest {"
	},
	{
		"original_code": "// TextBoxFigureBuilder.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.figure;\r\n\r\nimport java.awt.Font;\r\nimport java.awt.FontMetrics;\r\nimport java.awt.Rectangle;\r\nimport org.apache.log4j.Logger;\r\nimport de.paragon.explorer.gui.Warning;\r\nimport de.paragon.explorer.model.AttributeModel;\r\nimport de.paragon.explorer.model.ObjectHeaderModel;\r\nimport de.paragon.explorer.model.ObjectModel;\r\nimport de.paragon.explorer.model.ObjectModelPart;\r\nimport de.paragon.explorer.util.LoggerFactory;\r\nimport de.paragon.explorer.util.ResourceBundlePurchaser;\r\nimport de.paragon.explorer.util.StandardEnumeration;\r\n\r\npublic class TextBoxFigureBuilder {\r\n\r\n    private static final Logger logger = LoggerFactory.make();\r\n\r\n    private static final String ERROR_WHILE_BUILDING_TEXTBOXFIGURE = \"textboxfigurebuilder.error_while_building_textboxfigure\";\r\n\r\n    private static final int NUMBER_6 = 6;\r\n\r\n    private static final int NUMBER_3 = 3;\r\n\r\n    private static TextBoxFigureBuilder singleton;\r\n\r\n    public static TextBoxFigureBuilder getInstance() {\r\n        return TextBoxFigureBuilder.getSingleton();\r\n    }\r\n\r\n    private static TextBoxFigureBuilder getSingleton() {\r\n        if (TextBoxFigureBuilder.singleton == null) {\r\n            TextBoxFigureBuilder.setSingleton(new TextBoxFigureBuilder());\r\n        }\r\n        return TextBoxFigureBuilder.singleton;\r\n    }\r\n\r\n    private static void setSingleton(TextBoxFigureBuilder builder) {\r\n        TextBoxFigureBuilder.singleton = builder;\r\n    }\r\n\r\n    public TextBoxFigureBuilder() {\r\n        super();\r\n    }\r\n\r\n    // StandardEnumeration asEnumeration(Vector<?> aVector) {\r\n    // return new StandardEnumerator(aVector);\r\n    // }\r\n    /**\r\n     * Kommentar: Diese Methode geht davon aus, dass die Verknuepfungen zwischen\r\n     * ListBoxFigure, ObjectModel, ObjectHeaderModel und der dazugehoerigen\r\n     * TextBoxFigure bereits existieren. Sie setzt den entsprechenden Text und\r\n     * bestimmt die Groesse der TextBoxFigure. Anschliessend verknuepft sie\r\n     * ListBoxFigure mit der TextBoxFigure.\r\n     */\r\n    private void buildFigureForHeader(ObjectModel objModl) {\r\n        ObjectHeaderModel headModl = objModl.getHeaderModel();\r\n        TextBoxFigure figure = (TextBoxFigure) headModl.getFigure();\r\n        figure.setText(headModl.getTitle());\r\n        figure.setFont(this.getFont(figure));\r\n        figure.setVisible();\r\n        figure.setBackground(objModl.getColorManager().getBackground(figure));\r\n        figure.setForeground(objModl.getColorManager().getForeground(figure));\r\n        java.awt.Rectangle box = this.computeDisplayBox(figure);\r\n        figure.getDisplayBox().getRectangle().setBounds(box);\r\n        try {\r\n            objModl.getFigure().add(headModl.getFigure());\r\n        } catch (Exception ex) {\r\n            TextBoxFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(TextBoxFigureBuilder.ERROR_WHILE_BUILDING_TEXTBOXFIGURE), ex);\r\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(TextBoxFigureBuilder.ERROR_WHILE_BUILDING_TEXTBOXFIGURE));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht davon aus, dass die Verknuepfungen zwischen\r\n     * ListBoxFigure, ObjectModel, den AttributeModels und den dazugehoerigen\r\n     * TextBoxFigures bereits existieren. Sie setzt den entsprechenden Text und\r\n     * bestimmt die Groesse der TextBoxFigure. Anschliessend verknuepft sie\r\n     * ListBoxFigure mit der TextBoxFigure.\r\n     */\r\n    private void buildFiguresForAttributes(ObjectModel objModl) {\r\n        StandardEnumeration attrModls = objModl.getAttributeModels();\r\n        while (attrModls.hasMoreElements()) {\r\n            AttributeModel attrModl = (AttributeModel) attrModls.nextElement();\r\n            TextBoxFigure figure = (TextBoxFigure) attrModl.getFigure();\r\n            figure.setText(attrModl.getTitle());\r\n            figure.setBackground(objModl.getColorManager().getBackground(figure));\r\n            figure.setForeground(objModl.getColorManager().getForeground(figure));\r\n            figure.setFont(this.getFont(figure));\r\n            try {\r\n                objModl.getFigure().add(attrModl.getFigure());\r\n            } catch (Exception ex) {\r\n                TextBoxFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(TextBoxFigureBuilder.ERROR_WHILE_BUILDING_TEXTBOXFIGURE), ex);\r\n                Warning.showWarning(ResourceBundlePurchaser.getMessage(TextBoxFigureBuilder.ERROR_WHILE_BUILDING_TEXTBOXFIGURE));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht davon aus, dass die TextBoxFigures mit den\r\n     * jeweiligen Models verknuepft sind. Sie weist jeder TextBoxFigure einen\r\n     * String zu, bestimmt mit Hilfe der Graphics, die aus der ExplorerFigure\r\n     * abgefragt werden, die Groesse der TextBoxFigure und verknuepft sie\r\n     * anschliessend mit der ListBoxFigure. So ist sichergestellt, dass fuer\r\n     * Bauen und Zeichnen dieselben Graphics verwendet werden. Zwischen der\r\n     * Verknuepfung von HeaderFigure und den Attribute- Figures wird noch ein\r\n     * FilledRectangleFigure verknuepft.\r\n     */\r\n    private void buildTextBoxFigures(ObjectModel objModl) {\r\n        this.buildFigureForHeader(objModl);\r\n        this.getListBoxFigureBuilder().buildHeaderUnderline(objModl);\r\n        this.buildFiguresForAttributes(objModl);\r\n    }\r\n\r\n    public Rectangle computeDisplayBox(TextBoxFigure figure) {\r\n        int x, y, width, height;\r\n        java.awt.FontMetrics fm = this.getFontMetrics(figure);\r\n        String text = figure.getText();\r\n        x = 0;\r\n        y = 0;\r\n        height = fm.getLeading() + fm.getMaxAscent() + fm.getMaxDescent() + TextBoxFigureBuilder.NUMBER_3;\r\n        width = fm.stringWidth(text) + TextBoxFigureBuilder.NUMBER_6;\r\n        return new java.awt.Rectangle(x, y, width, height);\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht davon aus, dass bereits fuer das\r\n     * ObjectModel eine passende Anzahl entsprechender Teilmodelle erzeugt\r\n     * wurde. Sie erzeugt fuer jede dieser Models eine TextBoxFigure und\r\n     * verknuepft sie mit den Teilmodellen. Danach wird jeder TextBoxFigure ein\r\n     * String zugewiesen. Anschliessend wird von jeder TextBoxFigur die Groesse\r\n     * bestimmt und in der gleichen Routine mit der ListBoxFigure verknuepft,\r\n     * von der die Graphics abgefragt wurden. Beim Hinzufuegen einer neuen Figur\r\n     * wird ja automatisch die Groesse der ListBoxFigure neu berechnet.\r\n     */\r\n    protected void createTextBoxFigures(ObjectModel objModl) {\r\n        TextBoxFigure teBoFi = new TextBoxFigure();\r\n        StandardEnumeration attrModls = objModl.getAttributeModels();\r\n        objModl.getHeaderModel().setFigure(teBoFi);\r\n        teBoFi.setModel(objModl.getHeaderModel());\r\n        while (attrModls.hasMoreElements()) {\r\n            AttributeModel tempModl = (AttributeModel) attrModls.nextElement();\r\n            teBoFi = new TextBoxFigure();\r\n            teBoFi.setModel(tempModl);\r\n            tempModl.setFigure(teBoFi);\r\n        }\r\n        this.buildTextBoxFigures(objModl);\r\n    }\r\n\r\n    private java.awt.Graphics getGraphics(TextBoxFigure teBoFi) {\r\n        ObjectModel objModl = ((ObjectModelPart) teBoFi.getModel()).getObjectModel();\r\n        ExplorerFigure explFig = (ExplorerFigure) objModl.getExplorerModel().getFigure();\r\n        return explFig.getFrame().getGraphics();\r\n    }\r\n\r\n    private Font getFont(TextBoxFigure teBoFi) {\r\n        Font f = null;\r\n        ObjectModel objModl = ((ObjectModelPart) teBoFi.getModel()).getObjectModel();\r\n        ExplorerFigure explFig = (ExplorerFigure) objModl.getExplorerModel().getFigure();\r\n        if (explFig.getFrame() != null) {\r\n            f = explFig.getFrame().getGraphics().getFont();\r\n        } else {\r\n            f = explFig.getPanel().getFont();\r\n        }\r\n        return f;\r\n    }\r\n\r\n    private FontMetrics getFontMetrics(TextBoxFigure teBoFi) {\r\n        FontMetrics fm = null;\r\n        ObjectModel objModl = ((ObjectModelPart) teBoFi.getModel()).getObjectModel();\r\n        ExplorerFigure explFig = (ExplorerFigure) objModl.getExplorerModel().getFigure();\r\n        if (explFig.getFrame() != null) {\r\n            fm = explFig.getFrame().getGraphics().getFontMetrics();\r\n        } else {\r\n            fm = explFig.getPanel().getFontMetrics(explFig.getPanel().getFont());\r\n        }\r\n        return fm;\r\n    }\r\n\r\n    private ListBoxFigureBuilder getListBoxFigureBuilder() {\r\n        return ListBoxFigureBuilder.getInstance();\r\n    }\r\n\r\n    public void updateAttributes(ObjectModel objModl) {\r\n        StandardEnumeration attrModls = objModl.getAttributeModels();\r\n        while (attrModls.hasMoreElements()) {\r\n            AttributeModel attrModl = (AttributeModel) attrModls.nextElement();\r\n            TextBoxFigure figure = (TextBoxFigure) attrModl.getFigure();\r\n            if (objModl.getObjectViewManager().shouldBeVisible(attrModl)) {\r\n                figure.setVisible();\r\n            }\r\n            figure.setText(attrModl.getTitle());\r\n            figure.setBackground(objModl.getColorManager().getBackground(figure));\r\n            figure.setForeground(objModl.getColorManager().getForeground(figure));\r\n            figure.setFont(this.getGraphics(figure).getFont());\r\n        }\r\n    }\r\n\r\n    public void updateHeader(ObjectModel objModl) {\r\n        de.paragon.explorer.model.ObjectHeaderModel headModl = objModl.getHeaderModel();\r\n        TextBoxFigure figure = (TextBoxFigure) headModl.getFigure();\r\n        figure.setText(headModl.getTitle());\r\n        figure.setFont(this.getGraphics(figure).getFont());\r\n        figure.setVisible();\r\n        figure.setBackground(objModl.getColorManager().getBackground(figure));\r\n        figure.setForeground(objModl.getColorManager().getForeground(figure));\r\n        java.awt.Rectangle box = this.computeDisplayBox(figure);\r\n        figure.getDisplayBox().getRectangle().setBounds(box);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/figure/TextBoxFigureBuilderTest0.java",
		"test_prompt": "// TextBoxFigureBuilderTest0.java\npackage de.paragon.explorer.figure;\n\nimport java.awt.Font;\nimport java.awt.FontMetrics;\nimport java.awt.Rectangle;\nimport org.apache.log4j.Logger;\nimport de.paragon.explorer.gui.Warning;\nimport de.paragon.explorer.model.AttributeModel;\nimport de.paragon.explorer.model.ObjectHeaderModel;\nimport de.paragon.explorer.model.ObjectModel;\nimport de.paragon.explorer.model.ObjectModelPart;\nimport de.paragon.explorer.util.LoggerFactory;\nimport de.paragon.explorer.util.ResourceBundlePurchaser;\nimport de.paragon.explorer.util.StandardEnumeration;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TextBoxFigureBuilder}.\n* It contains ten unit test cases for the {@link TextBoxFigureBuilder#getInstance()} method.\n*/\nclass TextBoxFigureBuilderTest0 {"
	},
	{
		"original_code": "// TextBoxFigureBuilder.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.figure;\r\n\r\nimport java.awt.Font;\r\nimport java.awt.FontMetrics;\r\nimport java.awt.Rectangle;\r\nimport org.apache.log4j.Logger;\r\nimport de.paragon.explorer.gui.Warning;\r\nimport de.paragon.explorer.model.AttributeModel;\r\nimport de.paragon.explorer.model.ObjectHeaderModel;\r\nimport de.paragon.explorer.model.ObjectModel;\r\nimport de.paragon.explorer.model.ObjectModelPart;\r\nimport de.paragon.explorer.util.LoggerFactory;\r\nimport de.paragon.explorer.util.ResourceBundlePurchaser;\r\nimport de.paragon.explorer.util.StandardEnumeration;\r\n\r\npublic class TextBoxFigureBuilder {\r\n\r\n    private static final Logger logger = LoggerFactory.make();\r\n\r\n    private static final String ERROR_WHILE_BUILDING_TEXTBOXFIGURE = \"textboxfigurebuilder.error_while_building_textboxfigure\";\r\n\r\n    private static final int NUMBER_6 = 6;\r\n\r\n    private static final int NUMBER_3 = 3;\r\n\r\n    private static TextBoxFigureBuilder singleton;\r\n\r\n    public static TextBoxFigureBuilder getInstance() {\r\n        return TextBoxFigureBuilder.getSingleton();\r\n    }\r\n\r\n    private static TextBoxFigureBuilder getSingleton() {\r\n        if (TextBoxFigureBuilder.singleton == null) {\r\n            TextBoxFigureBuilder.setSingleton(new TextBoxFigureBuilder());\r\n        }\r\n        return TextBoxFigureBuilder.singleton;\r\n    }\r\n\r\n    private static void setSingleton(TextBoxFigureBuilder builder) {\r\n        TextBoxFigureBuilder.singleton = builder;\r\n    }\r\n\r\n    public TextBoxFigureBuilder() {\r\n        super();\r\n    }\r\n\r\n    // StandardEnumeration asEnumeration(Vector<?> aVector) {\r\n    // return new StandardEnumerator(aVector);\r\n    // }\r\n    /**\r\n     * Kommentar: Diese Methode geht davon aus, dass die Verknuepfungen zwischen\r\n     * ListBoxFigure, ObjectModel, ObjectHeaderModel und der dazugehoerigen\r\n     * TextBoxFigure bereits existieren. Sie setzt den entsprechenden Text und\r\n     * bestimmt die Groesse der TextBoxFigure. Anschliessend verknuepft sie\r\n     * ListBoxFigure mit der TextBoxFigure.\r\n     */\r\n    private void buildFigureForHeader(ObjectModel objModl) {\r\n        ObjectHeaderModel headModl = objModl.getHeaderModel();\r\n        TextBoxFigure figure = (TextBoxFigure) headModl.getFigure();\r\n        figure.setText(headModl.getTitle());\r\n        figure.setFont(this.getFont(figure));\r\n        figure.setVisible();\r\n        figure.setBackground(objModl.getColorManager().getBackground(figure));\r\n        figure.setForeground(objModl.getColorManager().getForeground(figure));\r\n        java.awt.Rectangle box = this.computeDisplayBox(figure);\r\n        figure.getDisplayBox().getRectangle().setBounds(box);\r\n        try {\r\n            objModl.getFigure().add(headModl.getFigure());\r\n        } catch (Exception ex) {\r\n            TextBoxFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(TextBoxFigureBuilder.ERROR_WHILE_BUILDING_TEXTBOXFIGURE), ex);\r\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(TextBoxFigureBuilder.ERROR_WHILE_BUILDING_TEXTBOXFIGURE));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht davon aus, dass die Verknuepfungen zwischen\r\n     * ListBoxFigure, ObjectModel, den AttributeModels und den dazugehoerigen\r\n     * TextBoxFigures bereits existieren. Sie setzt den entsprechenden Text und\r\n     * bestimmt die Groesse der TextBoxFigure. Anschliessend verknuepft sie\r\n     * ListBoxFigure mit der TextBoxFigure.\r\n     */\r\n    private void buildFiguresForAttributes(ObjectModel objModl) {\r\n        StandardEnumeration attrModls = objModl.getAttributeModels();\r\n        while (attrModls.hasMoreElements()) {\r\n            AttributeModel attrModl = (AttributeModel) attrModls.nextElement();\r\n            TextBoxFigure figure = (TextBoxFigure) attrModl.getFigure();\r\n            figure.setText(attrModl.getTitle());\r\n            figure.setBackground(objModl.getColorManager().getBackground(figure));\r\n            figure.setForeground(objModl.getColorManager().getForeground(figure));\r\n            figure.setFont(this.getFont(figure));\r\n            try {\r\n                objModl.getFigure().add(attrModl.getFigure());\r\n            } catch (Exception ex) {\r\n                TextBoxFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(TextBoxFigureBuilder.ERROR_WHILE_BUILDING_TEXTBOXFIGURE), ex);\r\n                Warning.showWarning(ResourceBundlePurchaser.getMessage(TextBoxFigureBuilder.ERROR_WHILE_BUILDING_TEXTBOXFIGURE));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht davon aus, dass die TextBoxFigures mit den\r\n     * jeweiligen Models verknuepft sind. Sie weist jeder TextBoxFigure einen\r\n     * String zu, bestimmt mit Hilfe der Graphics, die aus der ExplorerFigure\r\n     * abgefragt werden, die Groesse der TextBoxFigure und verknuepft sie\r\n     * anschliessend mit der ListBoxFigure. So ist sichergestellt, dass fuer\r\n     * Bauen und Zeichnen dieselben Graphics verwendet werden. Zwischen der\r\n     * Verknuepfung von HeaderFigure und den Attribute- Figures wird noch ein\r\n     * FilledRectangleFigure verknuepft.\r\n     */\r\n    private void buildTextBoxFigures(ObjectModel objModl) {\r\n        this.buildFigureForHeader(objModl);\r\n        this.getListBoxFigureBuilder().buildHeaderUnderline(objModl);\r\n        this.buildFiguresForAttributes(objModl);\r\n    }\r\n\r\n    public Rectangle computeDisplayBox(TextBoxFigure figure) {\r\n        int x, y, width, height;\r\n        java.awt.FontMetrics fm = this.getFontMetrics(figure);\r\n        String text = figure.getText();\r\n        x = 0;\r\n        y = 0;\r\n        height = fm.getLeading() + fm.getMaxAscent() + fm.getMaxDescent() + TextBoxFigureBuilder.NUMBER_3;\r\n        width = fm.stringWidth(text) + TextBoxFigureBuilder.NUMBER_6;\r\n        return new java.awt.Rectangle(x, y, width, height);\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht davon aus, dass bereits fuer das\r\n     * ObjectModel eine passende Anzahl entsprechender Teilmodelle erzeugt\r\n     * wurde. Sie erzeugt fuer jede dieser Models eine TextBoxFigure und\r\n     * verknuepft sie mit den Teilmodellen. Danach wird jeder TextBoxFigure ein\r\n     * String zugewiesen. Anschliessend wird von jeder TextBoxFigur die Groesse\r\n     * bestimmt und in der gleichen Routine mit der ListBoxFigure verknuepft,\r\n     * von der die Graphics abgefragt wurden. Beim Hinzufuegen einer neuen Figur\r\n     * wird ja automatisch die Groesse der ListBoxFigure neu berechnet.\r\n     */\r\n    protected void createTextBoxFigures(ObjectModel objModl) {\r\n        TextBoxFigure teBoFi = new TextBoxFigure();\r\n        StandardEnumeration attrModls = objModl.getAttributeModels();\r\n        objModl.getHeaderModel().setFigure(teBoFi);\r\n        teBoFi.setModel(objModl.getHeaderModel());\r\n        while (attrModls.hasMoreElements()) {\r\n            AttributeModel tempModl = (AttributeModel) attrModls.nextElement();\r\n            teBoFi = new TextBoxFigure();\r\n            teBoFi.setModel(tempModl);\r\n            tempModl.setFigure(teBoFi);\r\n        }\r\n        this.buildTextBoxFigures(objModl);\r\n    }\r\n\r\n    private java.awt.Graphics getGraphics(TextBoxFigure teBoFi) {\r\n        ObjectModel objModl = ((ObjectModelPart) teBoFi.getModel()).getObjectModel();\r\n        ExplorerFigure explFig = (ExplorerFigure) objModl.getExplorerModel().getFigure();\r\n        return explFig.getFrame().getGraphics();\r\n    }\r\n\r\n    private Font getFont(TextBoxFigure teBoFi) {\r\n        Font f = null;\r\n        ObjectModel objModl = ((ObjectModelPart) teBoFi.getModel()).getObjectModel();\r\n        ExplorerFigure explFig = (ExplorerFigure) objModl.getExplorerModel().getFigure();\r\n        if (explFig.getFrame() != null) {\r\n            f = explFig.getFrame().getGraphics().getFont();\r\n        } else {\r\n            f = explFig.getPanel().getFont();\r\n        }\r\n        return f;\r\n    }\r\n\r\n    private FontMetrics getFontMetrics(TextBoxFigure teBoFi) {\r\n        FontMetrics fm = null;\r\n        ObjectModel objModl = ((ObjectModelPart) teBoFi.getModel()).getObjectModel();\r\n        ExplorerFigure explFig = (ExplorerFigure) objModl.getExplorerModel().getFigure();\r\n        if (explFig.getFrame() != null) {\r\n            fm = explFig.getFrame().getGraphics().getFontMetrics();\r\n        } else {\r\n            fm = explFig.getPanel().getFontMetrics(explFig.getPanel().getFont());\r\n        }\r\n        return fm;\r\n    }\r\n\r\n    private ListBoxFigureBuilder getListBoxFigureBuilder() {\r\n        return ListBoxFigureBuilder.getInstance();\r\n    }\r\n\r\n    public void updateAttributes(ObjectModel objModl) {\r\n        StandardEnumeration attrModls = objModl.getAttributeModels();\r\n        while (attrModls.hasMoreElements()) {\r\n            AttributeModel attrModl = (AttributeModel) attrModls.nextElement();\r\n            TextBoxFigure figure = (TextBoxFigure) attrModl.getFigure();\r\n            if (objModl.getObjectViewManager().shouldBeVisible(attrModl)) {\r\n                figure.setVisible();\r\n            }\r\n            figure.setText(attrModl.getTitle());\r\n            figure.setBackground(objModl.getColorManager().getBackground(figure));\r\n            figure.setForeground(objModl.getColorManager().getForeground(figure));\r\n            figure.setFont(this.getGraphics(figure).getFont());\r\n        }\r\n    }\r\n\r\n    public void updateHeader(ObjectModel objModl) {\r\n        de.paragon.explorer.model.ObjectHeaderModel headModl = objModl.getHeaderModel();\r\n        TextBoxFigure figure = (TextBoxFigure) headModl.getFigure();\r\n        figure.setText(headModl.getTitle());\r\n        figure.setFont(this.getGraphics(figure).getFont());\r\n        figure.setVisible();\r\n        figure.setBackground(objModl.getColorManager().getBackground(figure));\r\n        figure.setForeground(objModl.getColorManager().getForeground(figure));\r\n        java.awt.Rectangle box = this.computeDisplayBox(figure);\r\n        figure.getDisplayBox().getRectangle().setBounds(box);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/figure/TextBoxFigureBuilderTest1.java",
		"test_prompt": "// TextBoxFigureBuilderTest1.java\npackage de.paragon.explorer.figure;\n\nimport java.awt.Font;\nimport java.awt.FontMetrics;\nimport java.awt.Rectangle;\nimport org.apache.log4j.Logger;\nimport de.paragon.explorer.gui.Warning;\nimport de.paragon.explorer.model.AttributeModel;\nimport de.paragon.explorer.model.ObjectHeaderModel;\nimport de.paragon.explorer.model.ObjectModel;\nimport de.paragon.explorer.model.ObjectModelPart;\nimport de.paragon.explorer.util.LoggerFactory;\nimport de.paragon.explorer.util.ResourceBundlePurchaser;\nimport de.paragon.explorer.util.StandardEnumeration;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TextBoxFigureBuilder}.\n* It contains ten unit test cases for the {@link TextBoxFigureBuilder#computeDisplayBox(TextBoxFigure)} method.\n*/\nclass TextBoxFigureBuilderTest1 {"
	},
	{
		"original_code": "// StandardRectangularDisplayBox.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.gui;\r\n\r\n// C.L.\r\nimport java.awt.Rectangle;\r\n\r\n/**\r\n * Kommentar: implementiert RectangularDisplayBox\r\n */\r\npublic class StandardRectangularDisplayBox implements RectangularDisplayBox {\r\n\r\n    private Rectangle box;\r\n\r\n    public StandardRectangularDisplayBox() {\r\n        super();\r\n        this.box = new Rectangle(0, 0, 0, 0);\r\n    }\r\n\r\n    public StandardRectangularDisplayBox(int x, int y, int width, int height) {\r\n        super();\r\n        this.box = new Rectangle(x, y, width, height);\r\n    }\r\n\r\n    @Override\r\n    public Object clone() {\r\n        try {\r\n            super.clone();\r\n            int x = this.getRectangle().x;\r\n            int y = this.getRectangle().y;\r\n            int width = this.getRectangle().width;\r\n            int height = this.getRectangle().height;\r\n            return new StandardRectangularDisplayBox(x, y, width, height);\r\n        } catch (CloneNotSupportedException ex) {\r\n            throw new InternalError();\r\n        }\r\n    }\r\n\r\n    public Rectangle getRectangle() {\r\n        return this.box;\r\n    }\r\n\r\n    public boolean isInside(int x, int y) {\r\n        return this.getRectangle().contains(x, y);\r\n    }\r\n\r\n    public void translate(int dx, int dy) {\r\n        this.getRectangle().translate(dx, dy);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/gui/StandardRectangularDisplayBoxTest0.java",
		"test_prompt": "// StandardRectangularDisplayBoxTest0.java\npackage de.paragon.explorer.gui;\n\n// C.L.\nimport java.awt.Rectangle;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StandardRectangularDisplayBox}.\n* It contains ten unit test cases for the {@link StandardRectangularDisplayBox#clone()} method.\n*/\nclass StandardRectangularDisplayBoxTest0 {"
	},
	{
		"original_code": "// StandardRectangularDisplayBox.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.gui;\r\n\r\n// C.L.\r\nimport java.awt.Rectangle;\r\n\r\n/**\r\n * Kommentar: implementiert RectangularDisplayBox\r\n */\r\npublic class StandardRectangularDisplayBox implements RectangularDisplayBox {\r\n\r\n    private Rectangle box;\r\n\r\n    public StandardRectangularDisplayBox() {\r\n        super();\r\n        this.box = new Rectangle(0, 0, 0, 0);\r\n    }\r\n\r\n    public StandardRectangularDisplayBox(int x, int y, int width, int height) {\r\n        super();\r\n        this.box = new Rectangle(x, y, width, height);\r\n    }\r\n\r\n    @Override\r\n    public Object clone() {\r\n        try {\r\n            super.clone();\r\n            int x = this.getRectangle().x;\r\n            int y = this.getRectangle().y;\r\n            int width = this.getRectangle().width;\r\n            int height = this.getRectangle().height;\r\n            return new StandardRectangularDisplayBox(x, y, width, height);\r\n        } catch (CloneNotSupportedException ex) {\r\n            throw new InternalError();\r\n        }\r\n    }\r\n\r\n    public Rectangle getRectangle() {\r\n        return this.box;\r\n    }\r\n\r\n    public boolean isInside(int x, int y) {\r\n        return this.getRectangle().contains(x, y);\r\n    }\r\n\r\n    public void translate(int dx, int dy) {\r\n        this.getRectangle().translate(dx, dy);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/gui/StandardRectangularDisplayBoxTest1.java",
		"test_prompt": "// StandardRectangularDisplayBoxTest1.java\npackage de.paragon.explorer.gui;\n\n// C.L.\r\nimport java.awt.Rectangle;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StandardRectangularDisplayBox}.\n* It contains ten unit test cases for the {@link StandardRectangularDisplayBox#isInside(int, int)} method.\n*/\nclass StandardRectangularDisplayBoxTest1 {"
	},
	{
		"original_code": "// NullDisplayBox.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.gui;\r\n\r\n// C.L. (was Einsatz an dieser Stelle angeht,\r\n// Null Object ist DesignPattern, als Patlet von E.Gamma im Vortrag\r\n// genannt)\r\n//\r\nimport java.awt.Rectangle;\r\n\r\npublic class NullDisplayBox implements DisplayBox {\r\n\r\n    public NullDisplayBox() {\r\n        super();\r\n    }\r\n\r\n    @Override\r\n    public Object clone() {\r\n        try {\r\n            super.clone();\r\n            return new NullDisplayBox();\r\n        } catch (CloneNotSupportedException ex) {\r\n            throw new InternalError();\r\n        }\r\n    }\r\n\r\n    public Rectangle getRectangle() {\r\n        return new Rectangle(0, 0, 0, 0);\r\n    }\r\n\r\n    public boolean isInside(int x, int y) {\r\n        return false;\r\n    }\r\n\r\n    public void translate(int x, int y) {\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/gui/NullDisplayBoxTest0.java",
		"test_prompt": "// NullDisplayBoxTest0.java\npackage de.paragon.explorer.gui;\n\n// C.L. (was Einsatz an dieser Stelle angeht,\n// Null Object ist DesignPattern, als Patlet von E.Gamma im Vortrag\n// genannt)\n//\nimport java.awt.Rectangle;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NullDisplayBox}.\n* It contains ten unit test cases for the {@link NullDisplayBox#clone()} method.\n*/\nclass NullDisplayBoxTest0 {"
	},
	{
		"original_code": "// NullDisplayBox.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.gui;\r\n\r\n// C.L. (was Einsatz an dieser Stelle angeht,\r\n// Null Object ist DesignPattern, als Patlet von E.Gamma im Vortrag\r\n// genannt)\r\n//\r\nimport java.awt.Rectangle;\r\n\r\npublic class NullDisplayBox implements DisplayBox {\r\n\r\n    public NullDisplayBox() {\r\n        super();\r\n    }\r\n\r\n    @Override\r\n    public Object clone() {\r\n        try {\r\n            super.clone();\r\n            return new NullDisplayBox();\r\n        } catch (CloneNotSupportedException ex) {\r\n            throw new InternalError();\r\n        }\r\n    }\r\n\r\n    public Rectangle getRectangle() {\r\n        return new Rectangle(0, 0, 0, 0);\r\n    }\r\n\r\n    public boolean isInside(int x, int y) {\r\n        return false;\r\n    }\r\n\r\n    public void translate(int x, int y) {\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/gui/NullDisplayBoxTest1.java",
		"test_prompt": "// NullDisplayBoxTest1.java\npackage de.paragon.explorer.gui;\n\n// C.L. (was Einsatz an dieser Stelle angeht,\r\n// Null Object ist DesignPattern, als Patlet von E.Gamma im Vortrag\r\n// genannt)\r\n//\r\nimport java.awt.Rectangle;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NullDisplayBox}.\n* It contains ten unit test cases for the {@link NullDisplayBox#isInside(int, int)} method.\n*/\nclass NullDisplayBoxTest1 {"
	},
	{
		"original_code": "// DisplayBoxComposer.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.gui;\r\n\r\nimport org.apache.log4j.Logger;\r\nimport de.paragon.explorer.excp.FigureException;\r\nimport de.paragon.explorer.figure.CompositeFigure;\r\nimport de.paragon.explorer.figure.Figure;\r\nimport de.paragon.explorer.util.LoggerFactory;\r\nimport de.paragon.explorer.util.ResourceBundlePurchaser;\r\nimport de.paragon.explorer.util.StandardEnumeration;\r\n\r\n// C.L.\r\n/**\r\n * Goal: calculate DisplayBox of a Composed Figure Important Methods: compose:\r\n * returns enclosing Rectangle of Figure-Parts as DisplayBox Possible Extension:\r\n * flexible Composition Strategy\r\n */\r\npublic class DisplayBoxComposer {\r\n\r\n    private static final Logger logger = LoggerFactory.make();\r\n\r\n    private static final String ERROR_IN_THIS_OBJECT = \"displayboxcomposer.error_in_this_object\";\r\n\r\n    public DisplayBoxComposer() {\r\n        super();\r\n    }\r\n\r\n    protected int calcHigh(Figure figure) throws FigureException {\r\n        int y1 = figure.getDisplayBox().getRectangle().y;\r\n        int y2 = y1 + figure.getDisplayBox().getRectangle().height;\r\n        return Math.max(y1, y2);\r\n    }\r\n\r\n    protected int calcLeft(Figure figure) throws FigureException {\r\n        int x1 = figure.getDisplayBox().getRectangle().x;\r\n        int x2 = x1 + figure.getDisplayBox().getRectangle().width;\r\n        return Math.min(x1, x2);\r\n    }\r\n\r\n    protected int calcLow(Figure figure) throws FigureException {\r\n        int y1 = figure.getDisplayBox().getRectangle().y;\r\n        int y2 = y1 + figure.getDisplayBox().getRectangle().height;\r\n        return Math.min(y1, y2);\r\n    }\r\n\r\n    protected int calcRight(Figure figure) throws FigureException {\r\n        int x1 = figure.getDisplayBox().getRectangle().x;\r\n        int x2 = x1 + figure.getDisplayBox().getRectangle().width;\r\n        return Math.max(x1, x2);\r\n    }\r\n\r\n    /**\r\n     * Comment: new DisplayBox = enclosing Rectangle of Parts no parts =>\r\n     * NullDisplayBox\r\n     *\r\n     * @return DisplayBox\r\n     */\r\n    public DisplayBox compose(CompositeFigure client) {\r\n        StandardEnumeration figures = null;\r\n        Figure currentFigure;\r\n        try {\r\n            figures = client.getFigures();\r\n        } catch (FigureException e) {\r\n            return this.getNewNullDisplayBox();\r\n        }\r\n        if (figures == null) {\r\n            return this.getNewNullDisplayBox();\r\n        }\r\n        int leftBorder = 0;\r\n        int rightBorder = 0;\r\n        int lowBorder = 0;\r\n        int highBorder = 0;\r\n        if (!figures.hasMoreElements()) {\r\n            return this.getNewNullDisplayBox();\r\n        }\r\n        try {\r\n            currentFigure = (Figure) figures.nextElement();\r\n            leftBorder = this.calcLeft(currentFigure);\r\n            rightBorder = this.calcRight(currentFigure);\r\n            lowBorder = this.calcLow(currentFigure);\r\n            highBorder = this.calcHigh(currentFigure);\r\n            while (figures.hasMoreElements()) {\r\n                currentFigure = (Figure) figures.nextElement();\r\n                leftBorder = Math.min(leftBorder, this.calcLeft(currentFigure));\r\n                rightBorder = Math.max(rightBorder, this.calcRight(currentFigure));\r\n                lowBorder = Math.min(lowBorder, this.calcLow(currentFigure));\r\n                highBorder = Math.max(highBorder, this.calcHigh(currentFigure));\r\n            }\r\n        } catch (FigureException ex) {\r\n            DisplayBoxComposer.logger.error(ResourceBundlePurchaser.getMessage(DisplayBoxComposer.ERROR_IN_THIS_OBJECT), ex);\r\n            Warning.showWarning(ResourceBundlePurchaser.getMessage(DisplayBoxComposer.ERROR_IN_THIS_OBJECT));\r\n        }\r\n        int x = leftBorder;\r\n        int y = lowBorder;\r\n        int width = rightBorder - x;\r\n        int height = highBorder - y;\r\n        return new StandardRectangularDisplayBox(x, y, width, height);\r\n    }\r\n\r\n    private DisplayBox getNewNullDisplayBox() {\r\n        return new NullDisplayBox();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/gui/DisplayBoxComposerTest.java",
		"test_prompt": "// DisplayBoxComposerTest.java\npackage de.paragon.explorer.gui;\n\nimport org.apache.log4j.Logger;\nimport de.paragon.explorer.excp.FigureException;\nimport de.paragon.explorer.figure.CompositeFigure;\nimport de.paragon.explorer.figure.Figure;\nimport de.paragon.explorer.util.LoggerFactory;\nimport de.paragon.explorer.util.ResourceBundlePurchaser;\nimport de.paragon.explorer.util.StandardEnumeration;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DisplayBoxComposer}.\n* It contains ten unit test cases for the {@link DisplayBoxComposer#compose(CompositeFigure)} method.\n*/\nclass DisplayBoxComposerTest {"
	},
	{
		"original_code": "// ObjectHeaderModel.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.model;\r\n\r\nimport de.paragon.explorer.figure.Figure;\r\nimport de.paragon.explorer.util.ObjectTitleManager;\r\n\r\n/**\r\n * Klassenbeschreibung:\r\n *\r\n * Instanzvariablen: objectModel: Das Modell fuer das entsprechende Object.\r\n *\r\n * Das ObjectHeaderModel wird referenziert von: Dem ConnectionModel, das eine\r\n * Referenz zu dem Object, das das ObjectModel dieses Ob- jectHeaderModels\r\n * referenziert, darstellt. Dem ObjectModel in der normalen Hierarchie-\r\n * beziehung,\r\n */\r\npublic class ObjectHeaderModel extends ObjectModelPart {\r\n\r\n    private ObjectModel objectModel;\r\n\r\n    public ObjectHeaderModel() {\r\n        super();\r\n    }\r\n\r\n    @Override\r\n    public String getCompleteTitle() {\r\n        return this.getObjectTitleManager().getCompleteTitle(this.getObjectModel());\r\n    }\r\n\r\n    @Override\r\n    public Figure getFigure() {\r\n        return this.getFigureInModel();\r\n    }\r\n\r\n    @Override\r\n    public ObjectModel getObjectModel() {\r\n        return this.objectModel;\r\n    }\r\n\r\n    private ObjectTitleManager getObjectTitleManager() {\r\n        return ObjectTitleManager.getSingleton();\r\n    }\r\n\r\n    public String getTitle() {\r\n        return this.getObjectTitleManager().getTitle(this.getObjectModel());\r\n    }\r\n\r\n    @Override\r\n    public boolean isObjectHeaderModel() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public void setFigure(Figure newFigure) {\r\n        this.setFigureInModel(newFigure);\r\n    }\r\n\r\n    protected void setObjectModel(ObjectModel model) {\r\n        this.objectModel = model;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/model/ObjectHeaderModelTest.java",
		"test_prompt": "// ObjectHeaderModelTest.java\npackage de.paragon.explorer.model;\n\nimport de.paragon.explorer.figure.Figure;\nimport de.paragon.explorer.util.ObjectTitleManager;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectHeaderModel}.\n* It contains ten unit test cases for the {@link ObjectHeaderModel#isObjectHeaderModel()} method.\n*/\nclass ObjectHeaderModelTest {"
	},
	{
		"original_code": "// ExplorerModel.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.model;\r\n\r\nimport de.paragon.explorer.event.ExplorerFrameEventConverter;\r\nimport de.paragon.explorer.figure.Figure;\r\nimport de.paragon.explorer.util.ExplorerColorManager;\r\nimport de.paragon.explorer.util.ExplorerManager;\r\nimport de.paragon.explorer.util.StandardEnumeration;\r\nimport de.paragon.explorer.util.StandardEnumerator;\r\n\r\n/**\r\n * Klassenbeschreibung: Das ExplorerModel repraesentiert das gesamte\r\n * Zusammenspiel der Models. Beschreibung der Instanzvariablen:\r\n * listOfAllExplorerd - Eine Liste aller ObjectModels, die ein Object\r\n * darstellen.\r\n *\r\n * Das ExplorerModel wird referenziert von: ConnectionModel in der normalen\r\n * Hierarchieverknuepfung, ObjectModel in der normalen Hierarchieverknuepfung\r\n */\r\npublic class ExplorerModel extends Model {\r\n\r\n    private StandardEnumeration listOfAllExplored;\r\n\r\n    // \"noetig damit Explorermanager nicht aufgeraeumt wird, da er sonst nicht referenziert wuerde\")\r\n    @SuppressWarnings(value = { \"unused\" })\r\n    private ExplorerManager explorerManager;\r\n\r\n    private String name;\r\n\r\n    private ExplorerColorManager colorManager;\r\n\r\n    private ExplorerFrameEventConverter drawingFrameEventConverter;\r\n\r\n    public ExplorerModel() {\r\n        super();\r\n    }\r\n\r\n    public void addObjectModel(ObjectModel objModl) {\r\n        this.getObjectModels().addElement(objModl);\r\n    }\r\n\r\n    public ExplorerColorManager getColorManager() {\r\n        if (this.colorManager == null) {\r\n            this.setColorManager(new ExplorerColorManager());\r\n        }\r\n        return this.colorManager;\r\n    }\r\n\r\n    public ExplorerFrameEventConverter getDrawingFrameEventConverter() {\r\n        return this.drawingFrameEventConverter;\r\n    }\r\n\r\n    @Override\r\n    public Figure getFigure() {\r\n        return this.getFigureInModel();\r\n    }\r\n\r\n    public String getName() {\r\n        return this.name;\r\n    }\r\n\r\n    public StandardEnumeration getObjectModels() {\r\n        if (this.listOfAllExplored == null) {\r\n            this.listOfAllExplored = new StandardEnumerator();\r\n        }\r\n        return this.listOfAllExplored;\r\n    }\r\n\r\n    @Override\r\n    public boolean isExplorerModel() {\r\n        return true;\r\n    }\r\n\r\n    public void removeObjectModel(ObjectModel objModl) {\r\n        this.getObjectModels().removeElement(objModl);\r\n    }\r\n\r\n    public void setColorManager(ExplorerColorManager newColorManager) {\r\n        this.colorManager = newColorManager;\r\n    }\r\n\r\n    public void setDrawingFrameEventConverter(ExplorerFrameEventConverter newDrawingFrameEventConverter) {\r\n        this.drawingFrameEventConverter = newDrawingFrameEventConverter;\r\n    }\r\n\r\n    @edu.umd.cs.findbugs.annotations.SuppressWarnings(value = \"URF_UNREAD_FIELD\", justification = \"noetig damit Explorermanager nicht aufgeraeumt wird, da er sonst nicht referenziert wuerde\")\r\n    public void setExplorerManager(ExplorerManager newExplorerManager) {\r\n        this.explorerManager = newExplorerManager;\r\n    }\r\n\r\n    @Override\r\n    public void setFigure(Figure newFigure) {\r\n        this.setFigureInModel(newFigure);\r\n    }\r\n\r\n    public void setName(String newName) {\r\n        this.name = newName;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/model/ExplorerModelTest.java",
		"test_prompt": "// ExplorerModelTest.java\npackage de.paragon.explorer.model;\n\nimport de.paragon.explorer.event.ExplorerFrameEventConverter;\nimport de.paragon.explorer.figure.Figure;\nimport de.paragon.explorer.util.ExplorerColorManager;\nimport de.paragon.explorer.util.ExplorerManager;\nimport de.paragon.explorer.util.StandardEnumeration;\nimport de.paragon.explorer.util.StandardEnumerator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ExplorerModel}.\n* It contains ten unit test cases for the {@link ExplorerModel#isExplorerModel()} method.\n*/\nclass ExplorerModelTest {"
	},
	{
		"original_code": "// ExplorerModelBuilder.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.model;\r\n\r\nimport de.paragon.explorer.figure.ExplorerFigure;\r\nimport de.paragon.explorer.figure.ExplorerFigureBuilder;\r\nimport de.paragon.explorer.figure.ListBoxFigure;\r\nimport de.paragon.explorer.figure.TextBoxFigure;\r\nimport de.paragon.explorer.gui.ExplorerDrawingPanel;\r\nimport de.paragon.explorer.util.ExplorerManager;\r\n\r\npublic final class ExplorerModelBuilder {\r\n\r\n    private static ExplorerModelBuilder singleton;\r\n\r\n    public static ExplorerModelBuilder getInstance() {\r\n        return ExplorerModelBuilder.getSingleton();\r\n    }\r\n\r\n    private static ExplorerModelBuilder getSingleton() {\r\n        if (ExplorerModelBuilder.singleton == null) {\r\n            ExplorerModelBuilder.setSingleton(new ExplorerModelBuilder());\r\n        }\r\n        return ExplorerModelBuilder.singleton;\r\n    }\r\n\r\n    private static void setSingleton(ExplorerModelBuilder builder) {\r\n        ExplorerModelBuilder.singleton = builder;\r\n    }\r\n\r\n    private ExplorerModelBuilder() {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Als erstes wird ein neues ExplorerModel erzeugt. Danach wird\r\n     * eine ExplorerFigure erzeugt. Diese wird dann mit dem ExplorerModel\r\n     * verknuepft. Generell gilt: Der Builder, der eine Figur oder ein Model\r\n     * frisch erzeugt hat, ist fuer die Verknuepfung der unmittelbar zuvor\r\n     * erzeugten Figur bzw. dem unmittelbar zuvor erzeugten Model zustaendig.\r\n     * Nach der Verknuepfung von ExplorerModel und ExplorerFigure wird ein neues\r\n     * ObjectModel erzeugt. Anschliessend werden ObjectModel und ExplorerModel\r\n     * verknuepft. Dann wird eine neue ListBoxFigure erzeugt. Diese wird dann\r\n     * mit dem ObjectModel verknuepft. Schliesslich schliesst sich der Kreis mit\r\n     * der Verknuepfung von ListBoxFigure und Explorer-Figure. Diese wird\r\n     * vorgenommen von dem ExplorerFigureBuilder. Anschliessend wird das\r\n     * ObjectModel weiter ausgebaut. Eine Beschreibung hierzu siehe im\r\n     * ObjectModelBuilder in der Methode buildObjectModel(ObjectModel objModl,\r\n     * Object object)! Ganz zum Schluss wird die fertige ListBoxFigure in der\r\n     * ExplorerFigure plaziert, das heisst, ihre Position innerhalb der\r\n     * ExplorerFigure wird festgelegt. Danach wird sie gezeichnet und ein neuer\r\n     * EventConverter wird erzeugt, bei dem die ExplorerFigure eingetragen wird.\r\n     */\r\n    public ExplorerDrawingPanel add1stModel(Object object) {\r\n        ExplorerModel explModl = this.createNewExplorerModelWithFigure();\r\n        if (object != null) {\r\n            ObjectModel objModl = this.createNewObjectModel(explModl);\r\n            this.getObjectModelBuilder().buildObjectModel(objModl, object);\r\n            this.getExplorerFigureBuilder().initialize1stList((ListBoxFigure) objModl.getFigure());\r\n            explModl.setDrawingFrameEventConverter(this.createNewEventConverter((ExplorerFigure) explModl.getFigure()));\r\n            ((ExplorerFigure) explModl.getFigure()).repaint();\r\n            this.getExplorerManager().addExplorerModel(explModl);\r\n        }\r\n        return ((ExplorerFigure) explModl.getFigure()).getPanel();\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Als erstes wird ein neues ExplorerModel erzeugt. Danach wird\r\n     * eine ExplorerFigure erzeugt. Diese wird dann mit dem ExplorerModel\r\n     * verknuepft. Generell gilt: Der Builder, der eine Figur oder ein Model\r\n     * frisch erzeugt hat, ist fuer die Verknuepfung der unmittelbar zuvor\r\n     * erzeugten Figur bzw. dem unmittelbar zuvor erzeugten Model zustaendig.\r\n     * Nach der Verknuepfung von ExplorerModel und ExplorerFigure wird ein neues\r\n     * ObjectModel erzeugt. Anschliessend werden ObjectModel und ExplorerModel\r\n     * verknuepft. Dann wird eine neue ListBoxFigure erzeugt. Diese wird dann\r\n     * mit dem ObjectModel verknuepft. Schliesslich schliesst sich der Kreis mit\r\n     * der Verknuepfung von ListBoxFigure und Explorer-Figure. Diese wird\r\n     * vorgenommen von dem ExplorerFigureBuilder. Anschliessend wird das\r\n     * ObjectModel weiter ausgebaut. Eine Be- schreibung hierzu siehe im\r\n     * ObjectModelBuilder in der Methode buildObjectModel(ObjectModel objModl,\r\n     * Object object)! Ganz zum Schluss wird die fertige ListBoxFigure in der\r\n     * ExplorerFigure plaziert, das heisst, ihre Position innerhalb der\r\n     * ExplorerFigure wird festgelegt. Danach wird sie gezeichnet und ein neuer\r\n     * EventConverter wird erzeugt, bei dem die ExplorerFigure eingetragen wird.\r\n     */\r\n    public void addModel(ExplorerModel explModl, Object object) {\r\n        ObjectModel objModl = this.createNewObjectModel(explModl);\r\n        this.getObjectModelBuilder().buildObjectModel(objModl, object);\r\n        this.getExplorerFigureBuilder().initializeCopyList((ListBoxFigure) objModl.getFigure());\r\n        this.getExplorerFigureBuilder().draw((ListBoxFigure) objModl.getFigure());\r\n    }\r\n\r\n    private void addNewConnectedObjectModelFor(TextBoxFigure tbf) {\r\n        AttributeModel attrModl = (AttributeModel) tbf.getModel();\r\n        // ObjectModel objModl =\r\n        // this.createNewObjectModel(attrModl.getObjectModel().getExplorerModel()\r\n        // );\r\n        ObjectModel objModl = this.createNewObjectModel(tbf);\r\n        this.getObjectModelBuilder().buildObjectModel(objModl, attrModl.getValue());\r\n        this.getExplorerFigureBuilder().initializeListFor(objModl, attrModl);\r\n        this.getExplorerFigureBuilder().draw((ListBoxFigure) objModl.getFigure());\r\n        this.getConnectionBuilder().addConnection(objModl.getHeaderModel(), attrModl);\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht davon aus, dass lediglich die fertig\r\n     * erstellte ListBoxFigure noch innerhalb der Explorer- Figure positioniert\r\n     * werden muss.\r\n     */\r\n    private void connect(ExplorerModel explModl, ExplorerFigure explFig) {\r\n        explModl.setFigure(explFig);\r\n        explFig.setModel(explModl);\r\n    }\r\n\r\n    private de.paragon.explorer.event.ExplorerFrameEventConverter createNewEventConverter(ExplorerFigure explFig) {\r\n        return de.paragon.explorer.Explorer.getEventConverter(explFig);\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode erzeugt ein neues ExplorerModel, eine neue\r\n     * ExplorerFigure und verknuepft diese beiden.\r\n     */\r\n    public ExplorerModel createNewExplorerModelWithFigure() {\r\n        ExplorerModel explModl;\r\n        ExplorerFigure explFig;\r\n        explModl = new ExplorerModel();\r\n        explFig = this.getExplorerFigureBuilder().createNewExplorerFigure();\r\n        this.connect(explModl, explFig);\r\n        return explModl;\r\n    }\r\n\r\n    private ObjectModel createNewObjectModel(ExplorerModel explModl) {\r\n        return this.getObjectModelBuilder().createNewObjectModel(explModl);\r\n    }\r\n\r\n    private ObjectModel createNewObjectModel(TextBoxFigure tbf) {\r\n        return this.getObjectModelBuilder().createNewObjectModel(tbf);\r\n    }\r\n\r\n    private de.paragon.explorer.util.ConnectionBuilder getConnectionBuilder() {\r\n        return de.paragon.explorer.util.ConnectionBuilder.getInstance();\r\n    }\r\n\r\n    private ExplorerFigureBuilder getExplorerFigureBuilder() {\r\n        return ExplorerFigureBuilder.getInstance();\r\n    }\r\n\r\n    public ExplorerManager getExplorerManager() {\r\n        return ExplorerManager.INSTANCE;\r\n    }\r\n\r\n    private ObjectModelBuilder getObjectModelBuilder() {\r\n        return ObjectModelBuilder.getInstance();\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht davon aus, dass existieren: 1.\r\n     * ExplorerFigure verknuepft mit einem ExplorerModel; 2. Mindestens eine\r\n     * fertige ListBoxFigure. Diese Methode macht: Sie ist dann aufzurufen, wenn\r\n     * weder eine zu referenzierende ListBoxFigure noch die dazugehoerige\r\n     * ConnectionFigure da ist. Sie erzeugt ein neues ObjectModel incl.\r\n     * ListBoxFigure; baut dieses ObjectModel aus und fuegt sie abhaengig von\r\n     * dem AttributeModel, das es referenziert, in die ExplorerFigure ein.\r\n     * Anschliessend fuegt sie die verbindende ConnectionFigure ein. \"add\" steht\r\n     * hierbei fuer create, build und draw.\r\n     */\r\n    public void handleAttributeModel(TextBoxFigure tbf) {\r\n        if (!(((AttributeModel) tbf.getModel()).isAttributePrimitive())) {\r\n            this.addNewConnectedObjectModelFor(tbf);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht davon aus, dass noch alle Verknuepfungen\r\n     * existieren, also noch nicht geloescht worden ist. Zunaechst wird das\r\n     * Objektmodell mit der zugehoerigen ListBoxFigure von der ExplorerFigure\r\n     * entfernt. Ein Objektmodell zu loeschen bedeutet, es aus der Liste\r\n     * objectModels des ExplorerModels zu entfernen. Dann geschieht Analoges mit\r\n     * den Connections, die auf das Modell zeigen oder vom Modell wegzeigen.\r\n     */\r\n    public void removeFromExplorer(ObjectModel objModl) {\r\n        objModl.getExplorerModel().removeObjectModel(objModl);\r\n        this.getExplorerFigureBuilder().removeFromExplorer((ListBoxFigure) objModl.getFigure());\r\n        this.getConnectionBuilder().removeConnections(objModl);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/model/ExplorerModelBuilderTest0.java",
		"test_prompt": "// ExplorerModelBuilderTest0.java\npackage de.paragon.explorer.model;\n\nimport de.paragon.explorer.figure.ExplorerFigure;\nimport de.paragon.explorer.figure.ExplorerFigureBuilder;\nimport de.paragon.explorer.figure.ListBoxFigure;\nimport de.paragon.explorer.figure.TextBoxFigure;\nimport de.paragon.explorer.gui.ExplorerDrawingPanel;\nimport de.paragon.explorer.util.ExplorerManager;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ExplorerModelBuilder}.\n* It contains ten unit test cases for the {@link ExplorerModelBuilder#getInstance()} method.\n*/\nclass ExplorerModelBuilderTest0 {"
	},
	{
		"original_code": "// ExplorerModelBuilder.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.model;\r\n\r\nimport de.paragon.explorer.figure.ExplorerFigure;\r\nimport de.paragon.explorer.figure.ExplorerFigureBuilder;\r\nimport de.paragon.explorer.figure.ListBoxFigure;\r\nimport de.paragon.explorer.figure.TextBoxFigure;\r\nimport de.paragon.explorer.gui.ExplorerDrawingPanel;\r\nimport de.paragon.explorer.util.ExplorerManager;\r\n\r\npublic final class ExplorerModelBuilder {\r\n\r\n    private static ExplorerModelBuilder singleton;\r\n\r\n    public static ExplorerModelBuilder getInstance() {\r\n        return ExplorerModelBuilder.getSingleton();\r\n    }\r\n\r\n    private static ExplorerModelBuilder getSingleton() {\r\n        if (ExplorerModelBuilder.singleton == null) {\r\n            ExplorerModelBuilder.setSingleton(new ExplorerModelBuilder());\r\n        }\r\n        return ExplorerModelBuilder.singleton;\r\n    }\r\n\r\n    private static void setSingleton(ExplorerModelBuilder builder) {\r\n        ExplorerModelBuilder.singleton = builder;\r\n    }\r\n\r\n    private ExplorerModelBuilder() {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Als erstes wird ein neues ExplorerModel erzeugt. Danach wird\r\n     * eine ExplorerFigure erzeugt. Diese wird dann mit dem ExplorerModel\r\n     * verknuepft. Generell gilt: Der Builder, der eine Figur oder ein Model\r\n     * frisch erzeugt hat, ist fuer die Verknuepfung der unmittelbar zuvor\r\n     * erzeugten Figur bzw. dem unmittelbar zuvor erzeugten Model zustaendig.\r\n     * Nach der Verknuepfung von ExplorerModel und ExplorerFigure wird ein neues\r\n     * ObjectModel erzeugt. Anschliessend werden ObjectModel und ExplorerModel\r\n     * verknuepft. Dann wird eine neue ListBoxFigure erzeugt. Diese wird dann\r\n     * mit dem ObjectModel verknuepft. Schliesslich schliesst sich der Kreis mit\r\n     * der Verknuepfung von ListBoxFigure und Explorer-Figure. Diese wird\r\n     * vorgenommen von dem ExplorerFigureBuilder. Anschliessend wird das\r\n     * ObjectModel weiter ausgebaut. Eine Beschreibung hierzu siehe im\r\n     * ObjectModelBuilder in der Methode buildObjectModel(ObjectModel objModl,\r\n     * Object object)! Ganz zum Schluss wird die fertige ListBoxFigure in der\r\n     * ExplorerFigure plaziert, das heisst, ihre Position innerhalb der\r\n     * ExplorerFigure wird festgelegt. Danach wird sie gezeichnet und ein neuer\r\n     * EventConverter wird erzeugt, bei dem die ExplorerFigure eingetragen wird.\r\n     */\r\n    public ExplorerDrawingPanel add1stModel(Object object) {\r\n        ExplorerModel explModl = this.createNewExplorerModelWithFigure();\r\n        if (object != null) {\r\n            ObjectModel objModl = this.createNewObjectModel(explModl);\r\n            this.getObjectModelBuilder().buildObjectModel(objModl, object);\r\n            this.getExplorerFigureBuilder().initialize1stList((ListBoxFigure) objModl.getFigure());\r\n            explModl.setDrawingFrameEventConverter(this.createNewEventConverter((ExplorerFigure) explModl.getFigure()));\r\n            ((ExplorerFigure) explModl.getFigure()).repaint();\r\n            this.getExplorerManager().addExplorerModel(explModl);\r\n        }\r\n        return ((ExplorerFigure) explModl.getFigure()).getPanel();\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Als erstes wird ein neues ExplorerModel erzeugt. Danach wird\r\n     * eine ExplorerFigure erzeugt. Diese wird dann mit dem ExplorerModel\r\n     * verknuepft. Generell gilt: Der Builder, der eine Figur oder ein Model\r\n     * frisch erzeugt hat, ist fuer die Verknuepfung der unmittelbar zuvor\r\n     * erzeugten Figur bzw. dem unmittelbar zuvor erzeugten Model zustaendig.\r\n     * Nach der Verknuepfung von ExplorerModel und ExplorerFigure wird ein neues\r\n     * ObjectModel erzeugt. Anschliessend werden ObjectModel und ExplorerModel\r\n     * verknuepft. Dann wird eine neue ListBoxFigure erzeugt. Diese wird dann\r\n     * mit dem ObjectModel verknuepft. Schliesslich schliesst sich der Kreis mit\r\n     * der Verknuepfung von ListBoxFigure und Explorer-Figure. Diese wird\r\n     * vorgenommen von dem ExplorerFigureBuilder. Anschliessend wird das\r\n     * ObjectModel weiter ausgebaut. Eine Be- schreibung hierzu siehe im\r\n     * ObjectModelBuilder in der Methode buildObjectModel(ObjectModel objModl,\r\n     * Object object)! Ganz zum Schluss wird die fertige ListBoxFigure in der\r\n     * ExplorerFigure plaziert, das heisst, ihre Position innerhalb der\r\n     * ExplorerFigure wird festgelegt. Danach wird sie gezeichnet und ein neuer\r\n     * EventConverter wird erzeugt, bei dem die ExplorerFigure eingetragen wird.\r\n     */\r\n    public void addModel(ExplorerModel explModl, Object object) {\r\n        ObjectModel objModl = this.createNewObjectModel(explModl);\r\n        this.getObjectModelBuilder().buildObjectModel(objModl, object);\r\n        this.getExplorerFigureBuilder().initializeCopyList((ListBoxFigure) objModl.getFigure());\r\n        this.getExplorerFigureBuilder().draw((ListBoxFigure) objModl.getFigure());\r\n    }\r\n\r\n    private void addNewConnectedObjectModelFor(TextBoxFigure tbf) {\r\n        AttributeModel attrModl = (AttributeModel) tbf.getModel();\r\n        // ObjectModel objModl =\r\n        // this.createNewObjectModel(attrModl.getObjectModel().getExplorerModel()\r\n        // );\r\n        ObjectModel objModl = this.createNewObjectModel(tbf);\r\n        this.getObjectModelBuilder().buildObjectModel(objModl, attrModl.getValue());\r\n        this.getExplorerFigureBuilder().initializeListFor(objModl, attrModl);\r\n        this.getExplorerFigureBuilder().draw((ListBoxFigure) objModl.getFigure());\r\n        this.getConnectionBuilder().addConnection(objModl.getHeaderModel(), attrModl);\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht davon aus, dass lediglich die fertig\r\n     * erstellte ListBoxFigure noch innerhalb der Explorer- Figure positioniert\r\n     * werden muss.\r\n     */\r\n    private void connect(ExplorerModel explModl, ExplorerFigure explFig) {\r\n        explModl.setFigure(explFig);\r\n        explFig.setModel(explModl);\r\n    }\r\n\r\n    private de.paragon.explorer.event.ExplorerFrameEventConverter createNewEventConverter(ExplorerFigure explFig) {\r\n        return de.paragon.explorer.Explorer.getEventConverter(explFig);\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode erzeugt ein neues ExplorerModel, eine neue\r\n     * ExplorerFigure und verknuepft diese beiden.\r\n     */\r\n    public ExplorerModel createNewExplorerModelWithFigure() {\r\n        ExplorerModel explModl;\r\n        ExplorerFigure explFig;\r\n        explModl = new ExplorerModel();\r\n        explFig = this.getExplorerFigureBuilder().createNewExplorerFigure();\r\n        this.connect(explModl, explFig);\r\n        return explModl;\r\n    }\r\n\r\n    private ObjectModel createNewObjectModel(ExplorerModel explModl) {\r\n        return this.getObjectModelBuilder().createNewObjectModel(explModl);\r\n    }\r\n\r\n    private ObjectModel createNewObjectModel(TextBoxFigure tbf) {\r\n        return this.getObjectModelBuilder().createNewObjectModel(tbf);\r\n    }\r\n\r\n    private de.paragon.explorer.util.ConnectionBuilder getConnectionBuilder() {\r\n        return de.paragon.explorer.util.ConnectionBuilder.getInstance();\r\n    }\r\n\r\n    private ExplorerFigureBuilder getExplorerFigureBuilder() {\r\n        return ExplorerFigureBuilder.getInstance();\r\n    }\r\n\r\n    public ExplorerManager getExplorerManager() {\r\n        return ExplorerManager.INSTANCE;\r\n    }\r\n\r\n    private ObjectModelBuilder getObjectModelBuilder() {\r\n        return ObjectModelBuilder.getInstance();\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht davon aus, dass existieren: 1.\r\n     * ExplorerFigure verknuepft mit einem ExplorerModel; 2. Mindestens eine\r\n     * fertige ListBoxFigure. Diese Methode macht: Sie ist dann aufzurufen, wenn\r\n     * weder eine zu referenzierende ListBoxFigure noch die dazugehoerige\r\n     * ConnectionFigure da ist. Sie erzeugt ein neues ObjectModel incl.\r\n     * ListBoxFigure; baut dieses ObjectModel aus und fuegt sie abhaengig von\r\n     * dem AttributeModel, das es referenziert, in die ExplorerFigure ein.\r\n     * Anschliessend fuegt sie die verbindende ConnectionFigure ein. \"add\" steht\r\n     * hierbei fuer create, build und draw.\r\n     */\r\n    public void handleAttributeModel(TextBoxFigure tbf) {\r\n        if (!(((AttributeModel) tbf.getModel()).isAttributePrimitive())) {\r\n            this.addNewConnectedObjectModelFor(tbf);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht davon aus, dass noch alle Verknuepfungen\r\n     * existieren, also noch nicht geloescht worden ist. Zunaechst wird das\r\n     * Objektmodell mit der zugehoerigen ListBoxFigure von der ExplorerFigure\r\n     * entfernt. Ein Objektmodell zu loeschen bedeutet, es aus der Liste\r\n     * objectModels des ExplorerModels zu entfernen. Dann geschieht Analoges mit\r\n     * den Connections, die auf das Modell zeigen oder vom Modell wegzeigen.\r\n     */\r\n    public void removeFromExplorer(ObjectModel objModl) {\r\n        objModl.getExplorerModel().removeObjectModel(objModl);\r\n        this.getExplorerFigureBuilder().removeFromExplorer((ListBoxFigure) objModl.getFigure());\r\n        this.getConnectionBuilder().removeConnections(objModl);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/model/ExplorerModelBuilderTest1.java",
		"test_prompt": "// ExplorerModelBuilderTest1.java\npackage de.paragon.explorer.model;\n\nimport de.paragon.explorer.figure.ExplorerFigure;\nimport de.paragon.explorer.figure.ExplorerFigureBuilder;\nimport de.paragon.explorer.figure.ListBoxFigure;\nimport de.paragon.explorer.figure.TextBoxFigure;\nimport de.paragon.explorer.gui.ExplorerDrawingPanel;\nimport de.paragon.explorer.util.ExplorerManager;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ExplorerModelBuilder}.\n* It contains ten unit test cases for the {@link ExplorerModelBuilder#add1stModel(Object)} method.\n*/\nclass ExplorerModelBuilderTest1 {"
	},
	{
		"original_code": "// ExplorerModelBuilder.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.model;\r\n\r\nimport de.paragon.explorer.figure.ExplorerFigure;\r\nimport de.paragon.explorer.figure.ExplorerFigureBuilder;\r\nimport de.paragon.explorer.figure.ListBoxFigure;\r\nimport de.paragon.explorer.figure.TextBoxFigure;\r\nimport de.paragon.explorer.gui.ExplorerDrawingPanel;\r\nimport de.paragon.explorer.util.ExplorerManager;\r\n\r\npublic final class ExplorerModelBuilder {\r\n\r\n    private static ExplorerModelBuilder singleton;\r\n\r\n    public static ExplorerModelBuilder getInstance() {\r\n        return ExplorerModelBuilder.getSingleton();\r\n    }\r\n\r\n    private static ExplorerModelBuilder getSingleton() {\r\n        if (ExplorerModelBuilder.singleton == null) {\r\n            ExplorerModelBuilder.setSingleton(new ExplorerModelBuilder());\r\n        }\r\n        return ExplorerModelBuilder.singleton;\r\n    }\r\n\r\n    private static void setSingleton(ExplorerModelBuilder builder) {\r\n        ExplorerModelBuilder.singleton = builder;\r\n    }\r\n\r\n    private ExplorerModelBuilder() {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Als erstes wird ein neues ExplorerModel erzeugt. Danach wird\r\n     * eine ExplorerFigure erzeugt. Diese wird dann mit dem ExplorerModel\r\n     * verknuepft. Generell gilt: Der Builder, der eine Figur oder ein Model\r\n     * frisch erzeugt hat, ist fuer die Verknuepfung der unmittelbar zuvor\r\n     * erzeugten Figur bzw. dem unmittelbar zuvor erzeugten Model zustaendig.\r\n     * Nach der Verknuepfung von ExplorerModel und ExplorerFigure wird ein neues\r\n     * ObjectModel erzeugt. Anschliessend werden ObjectModel und ExplorerModel\r\n     * verknuepft. Dann wird eine neue ListBoxFigure erzeugt. Diese wird dann\r\n     * mit dem ObjectModel verknuepft. Schliesslich schliesst sich der Kreis mit\r\n     * der Verknuepfung von ListBoxFigure und Explorer-Figure. Diese wird\r\n     * vorgenommen von dem ExplorerFigureBuilder. Anschliessend wird das\r\n     * ObjectModel weiter ausgebaut. Eine Beschreibung hierzu siehe im\r\n     * ObjectModelBuilder in der Methode buildObjectModel(ObjectModel objModl,\r\n     * Object object)! Ganz zum Schluss wird die fertige ListBoxFigure in der\r\n     * ExplorerFigure plaziert, das heisst, ihre Position innerhalb der\r\n     * ExplorerFigure wird festgelegt. Danach wird sie gezeichnet und ein neuer\r\n     * EventConverter wird erzeugt, bei dem die ExplorerFigure eingetragen wird.\r\n     */\r\n    public ExplorerDrawingPanel add1stModel(Object object) {\r\n        ExplorerModel explModl = this.createNewExplorerModelWithFigure();\r\n        if (object != null) {\r\n            ObjectModel objModl = this.createNewObjectModel(explModl);\r\n            this.getObjectModelBuilder().buildObjectModel(objModl, object);\r\n            this.getExplorerFigureBuilder().initialize1stList((ListBoxFigure) objModl.getFigure());\r\n            explModl.setDrawingFrameEventConverter(this.createNewEventConverter((ExplorerFigure) explModl.getFigure()));\r\n            ((ExplorerFigure) explModl.getFigure()).repaint();\r\n            this.getExplorerManager().addExplorerModel(explModl);\r\n        }\r\n        return ((ExplorerFigure) explModl.getFigure()).getPanel();\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Als erstes wird ein neues ExplorerModel erzeugt. Danach wird\r\n     * eine ExplorerFigure erzeugt. Diese wird dann mit dem ExplorerModel\r\n     * verknuepft. Generell gilt: Der Builder, der eine Figur oder ein Model\r\n     * frisch erzeugt hat, ist fuer die Verknuepfung der unmittelbar zuvor\r\n     * erzeugten Figur bzw. dem unmittelbar zuvor erzeugten Model zustaendig.\r\n     * Nach der Verknuepfung von ExplorerModel und ExplorerFigure wird ein neues\r\n     * ObjectModel erzeugt. Anschliessend werden ObjectModel und ExplorerModel\r\n     * verknuepft. Dann wird eine neue ListBoxFigure erzeugt. Diese wird dann\r\n     * mit dem ObjectModel verknuepft. Schliesslich schliesst sich der Kreis mit\r\n     * der Verknuepfung von ListBoxFigure und Explorer-Figure. Diese wird\r\n     * vorgenommen von dem ExplorerFigureBuilder. Anschliessend wird das\r\n     * ObjectModel weiter ausgebaut. Eine Be- schreibung hierzu siehe im\r\n     * ObjectModelBuilder in der Methode buildObjectModel(ObjectModel objModl,\r\n     * Object object)! Ganz zum Schluss wird die fertige ListBoxFigure in der\r\n     * ExplorerFigure plaziert, das heisst, ihre Position innerhalb der\r\n     * ExplorerFigure wird festgelegt. Danach wird sie gezeichnet und ein neuer\r\n     * EventConverter wird erzeugt, bei dem die ExplorerFigure eingetragen wird.\r\n     */\r\n    public void addModel(ExplorerModel explModl, Object object) {\r\n        ObjectModel objModl = this.createNewObjectModel(explModl);\r\n        this.getObjectModelBuilder().buildObjectModel(objModl, object);\r\n        this.getExplorerFigureBuilder().initializeCopyList((ListBoxFigure) objModl.getFigure());\r\n        this.getExplorerFigureBuilder().draw((ListBoxFigure) objModl.getFigure());\r\n    }\r\n\r\n    private void addNewConnectedObjectModelFor(TextBoxFigure tbf) {\r\n        AttributeModel attrModl = (AttributeModel) tbf.getModel();\r\n        // ObjectModel objModl =\r\n        // this.createNewObjectModel(attrModl.getObjectModel().getExplorerModel()\r\n        // );\r\n        ObjectModel objModl = this.createNewObjectModel(tbf);\r\n        this.getObjectModelBuilder().buildObjectModel(objModl, attrModl.getValue());\r\n        this.getExplorerFigureBuilder().initializeListFor(objModl, attrModl);\r\n        this.getExplorerFigureBuilder().draw((ListBoxFigure) objModl.getFigure());\r\n        this.getConnectionBuilder().addConnection(objModl.getHeaderModel(), attrModl);\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht davon aus, dass lediglich die fertig\r\n     * erstellte ListBoxFigure noch innerhalb der Explorer- Figure positioniert\r\n     * werden muss.\r\n     */\r\n    private void connect(ExplorerModel explModl, ExplorerFigure explFig) {\r\n        explModl.setFigure(explFig);\r\n        explFig.setModel(explModl);\r\n    }\r\n\r\n    private de.paragon.explorer.event.ExplorerFrameEventConverter createNewEventConverter(ExplorerFigure explFig) {\r\n        return de.paragon.explorer.Explorer.getEventConverter(explFig);\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode erzeugt ein neues ExplorerModel, eine neue\r\n     * ExplorerFigure und verknuepft diese beiden.\r\n     */\r\n    public ExplorerModel createNewExplorerModelWithFigure() {\r\n        ExplorerModel explModl;\r\n        ExplorerFigure explFig;\r\n        explModl = new ExplorerModel();\r\n        explFig = this.getExplorerFigureBuilder().createNewExplorerFigure();\r\n        this.connect(explModl, explFig);\r\n        return explModl;\r\n    }\r\n\r\n    private ObjectModel createNewObjectModel(ExplorerModel explModl) {\r\n        return this.getObjectModelBuilder().createNewObjectModel(explModl);\r\n    }\r\n\r\n    private ObjectModel createNewObjectModel(TextBoxFigure tbf) {\r\n        return this.getObjectModelBuilder().createNewObjectModel(tbf);\r\n    }\r\n\r\n    private de.paragon.explorer.util.ConnectionBuilder getConnectionBuilder() {\r\n        return de.paragon.explorer.util.ConnectionBuilder.getInstance();\r\n    }\r\n\r\n    private ExplorerFigureBuilder getExplorerFigureBuilder() {\r\n        return ExplorerFigureBuilder.getInstance();\r\n    }\r\n\r\n    public ExplorerManager getExplorerManager() {\r\n        return ExplorerManager.INSTANCE;\r\n    }\r\n\r\n    private ObjectModelBuilder getObjectModelBuilder() {\r\n        return ObjectModelBuilder.getInstance();\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht davon aus, dass existieren: 1.\r\n     * ExplorerFigure verknuepft mit einem ExplorerModel; 2. Mindestens eine\r\n     * fertige ListBoxFigure. Diese Methode macht: Sie ist dann aufzurufen, wenn\r\n     * weder eine zu referenzierende ListBoxFigure noch die dazugehoerige\r\n     * ConnectionFigure da ist. Sie erzeugt ein neues ObjectModel incl.\r\n     * ListBoxFigure; baut dieses ObjectModel aus und fuegt sie abhaengig von\r\n     * dem AttributeModel, das es referenziert, in die ExplorerFigure ein.\r\n     * Anschliessend fuegt sie die verbindende ConnectionFigure ein. \"add\" steht\r\n     * hierbei fuer create, build und draw.\r\n     */\r\n    public void handleAttributeModel(TextBoxFigure tbf) {\r\n        if (!(((AttributeModel) tbf.getModel()).isAttributePrimitive())) {\r\n            this.addNewConnectedObjectModelFor(tbf);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht davon aus, dass noch alle Verknuepfungen\r\n     * existieren, also noch nicht geloescht worden ist. Zunaechst wird das\r\n     * Objektmodell mit der zugehoerigen ListBoxFigure von der ExplorerFigure\r\n     * entfernt. Ein Objektmodell zu loeschen bedeutet, es aus der Liste\r\n     * objectModels des ExplorerModels zu entfernen. Dann geschieht Analoges mit\r\n     * den Connections, die auf das Modell zeigen oder vom Modell wegzeigen.\r\n     */\r\n    public void removeFromExplorer(ObjectModel objModl) {\r\n        objModl.getExplorerModel().removeObjectModel(objModl);\r\n        this.getExplorerFigureBuilder().removeFromExplorer((ListBoxFigure) objModl.getFigure());\r\n        this.getConnectionBuilder().removeConnections(objModl);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/model/ExplorerModelBuilderTest2.java",
		"test_prompt": "// ExplorerModelBuilderTest2.java\npackage de.paragon.explorer.model;\n\nimport de.paragon.explorer.figure.ExplorerFigure;\nimport de.paragon.explorer.figure.ExplorerFigureBuilder;\nimport de.paragon.explorer.figure.ListBoxFigure;\nimport de.paragon.explorer.figure.TextBoxFigure;\nimport de.paragon.explorer.gui.ExplorerDrawingPanel;\nimport de.paragon.explorer.util.ExplorerManager;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ExplorerModelBuilder}.\n* It contains ten unit test cases for the {@link ExplorerModelBuilder#createNewExplorerModelWithFigure()} method.\n*/\nclass ExplorerModelBuilderTest2 {"
	},
	{
		"original_code": "// ObjectModel.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.model;\r\n\r\nimport java.lang.reflect.Array;\r\nimport java.lang.reflect.Field;\r\nimport java.util.Vector;\r\nimport de.paragon.explorer.figure.Figure;\r\nimport de.paragon.explorer.util.ExplorerColorManager;\r\nimport de.paragon.explorer.util.ObjectViewManager;\r\nimport de.paragon.explorer.util.StandardEnumeration;\r\nimport de.paragon.explorer.util.StandardEnumerator;\r\n\r\n/**\r\n * Klassenbeschreibung: Ein ObjectModel repraesentiert ein Object. Es besteht\r\n * aus: 1. Einem ObjectHeaderModel - fuer den Klassennamen 2. Einer Liste von\r\n * AttributeModels, die die Attribute des eigenen Objects repraesentieren. 3.\r\n * Einer Liste von ConnectionModels, die entweder von anderen AttributeModels\r\n * kommen oder von einer der eigenen AttributeModels zu an- deren ObjectModels\r\n * gehen.\r\n *\r\n * Instanzvariablen: headerModel: Referenz auf das Model, das fuer die\r\n * Beinhaltung des Objektnamens steht. attributeModels: Liste aller Modelle, die\r\n * den Inhalt der Attribute (Instanzvariablen etc.) halten. explorerModel:\r\n * Referenz auf das Gesamtmodel. connectionModels: Liste aller Modell, die die\r\n * Darstellung einer Referenz repraesentieren.\r\n *\r\n * Das ObjectModel wird referenziert von: AttributeModel in der \"normalen\"\r\n * Hierarchieverknuepfung, dem ExplorerModel, zusammen mit allen anderen\r\n * ObjectModels in einer Liste. dem ObjectHeaderModel, das fuer den Inhalt des\r\n * Namens des Objectes zustaendig ist.\r\n */\r\npublic class ObjectModel extends Model {\r\n\r\n    private ObjectHeaderModel headerModel;\r\n\r\n    private StandardEnumeration attributeModels;\r\n\r\n    private ExplorerModel explorerModel;\r\n\r\n    private StandardEnumeration connectionModels;\r\n\r\n    private ObjectViewManager objectViewManager;\r\n\r\n    public ObjectModel() {\r\n        super();\r\n    }\r\n\r\n    public void addAttributeModel(AttributeModel attrModl) {\r\n        this.getAttributeModels().addElement(attrModl);\r\n    }\r\n\r\n    public void addConnectionModel(ConnectionModel conModl) {\r\n        this.getConnectionModels().addElement(conModl);\r\n    }\r\n\r\n    public StandardEnumeration getAttributeModels() {\r\n        if (this.attributeModels == null) {\r\n            this.setAttributeModels(new StandardEnumerator());\r\n        }\r\n        return this.attributeModels;\r\n    }\r\n\r\n    public ExplorerColorManager getColorManager() {\r\n        return this.getExplorerModel().getColorManager();\r\n    }\r\n\r\n    public StandardEnumeration getConnectionModels() {\r\n        if (this.connectionModels == null) {\r\n            this.setConnectionModels(new StandardEnumerator());\r\n        }\r\n        return this.connectionModels;\r\n    }\r\n\r\n    public Vector<Field> getDeclaredFields() {\r\n        return this.getDeclaredFields(this.getObject().getClass());\r\n    }\r\n\r\n    public Vector<Field> getDeclaredFields(Class<?> aClass) {\r\n        Field[] field;\r\n        Vector<Field> vector;\r\n        if (aClass.getSuperclass() != null) {\r\n            vector = this.getDeclaredFields(aClass.getSuperclass());\r\n        } else {\r\n            vector = new Vector<Field>();\r\n        }\r\n        field = aClass.getDeclaredFields();\r\n        for (int i = 0; i < field.length; i++) {\r\n            vector.add(field[i]);\r\n        }\r\n        return vector;\r\n    }\r\n\r\n    public ExplorerModel getExplorerModel() {\r\n        return this.explorerModel;\r\n    }\r\n\r\n    @Override\r\n    public Figure getFigure() {\r\n        return this.getFigureInModel();\r\n    }\r\n\r\n    public ObjectHeaderModel getHeaderModel() {\r\n        return this.headerModel;\r\n    }\r\n\r\n    public int getNumberOfAttributes() {\r\n        if (this.isArrayObject()) {\r\n            return Array.getLength(this.getObject());\r\n        }\r\n        if (this.isStringObject() || this.isNullObject()) {\r\n            return 0;\r\n        }\r\n        return this.getDeclaredFields().size();\r\n    }\r\n\r\n    public ObjectViewManager getObjectViewManager() {\r\n        if (this.objectViewManager == null) {\r\n            this.setObjectViewManager(new ObjectViewManager(this));\r\n        }\r\n        return this.objectViewManager;\r\n    }\r\n\r\n    public boolean isArrayObject() {\r\n        return this.getObject().getClass().isArray();\r\n    }\r\n\r\n    public boolean isNullObject() {\r\n        return NullObject.isNullObject(this.getObject());\r\n    }\r\n\r\n    @Override\r\n    public boolean isObjectModel() {\r\n        return true;\r\n    }\r\n\r\n    public boolean isStringObject() {\r\n        return this.getObject().getClass() == String.class;\r\n    }\r\n\r\n    public void removeConnectionModel(ConnectionModel conModl) {\r\n        this.getConnectionModels().removeElement(conModl);\r\n    }\r\n\r\n    public void setAttributeModels(StandardEnumeration models) {\r\n        this.attributeModels = models;\r\n    }\r\n\r\n    private void setConnectionModels(StandardEnumeration conModls) {\r\n        this.connectionModels = conModls;\r\n    }\r\n\r\n    public void setExplorerModel(ExplorerModel explModl) {\r\n        this.explorerModel = explModl;\r\n    }\r\n\r\n    @Override\r\n    public void setFigure(Figure newFigure) {\r\n        this.setFigureInModel(newFigure);\r\n    }\r\n\r\n    public void setHeaderModel(ObjectHeaderModel model) {\r\n        this.headerModel = model;\r\n    }\r\n\r\n    public void setObjectViewManager(ObjectViewManager newObjectViewManager) {\r\n        this.objectViewManager = newObjectViewManager;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/model/ObjectModelTest0.java",
		"test_prompt": "// ObjectModelTest0.java\npackage de.paragon.explorer.model;\n\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Field;\nimport java.util.Vector;\nimport de.paragon.explorer.figure.Figure;\nimport de.paragon.explorer.util.ExplorerColorManager;\nimport de.paragon.explorer.util.ObjectViewManager;\nimport de.paragon.explorer.util.StandardEnumeration;\nimport de.paragon.explorer.util.StandardEnumerator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectModel}.\n* It contains ten unit test cases for the {@link ObjectModel#isArrayObject()} method.\n*/\nclass ObjectModelTest0 {"
	},
	{
		"original_code": "// ObjectModel.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.model;\r\n\r\nimport java.lang.reflect.Array;\r\nimport java.lang.reflect.Field;\r\nimport java.util.Vector;\r\nimport de.paragon.explorer.figure.Figure;\r\nimport de.paragon.explorer.util.ExplorerColorManager;\r\nimport de.paragon.explorer.util.ObjectViewManager;\r\nimport de.paragon.explorer.util.StandardEnumeration;\r\nimport de.paragon.explorer.util.StandardEnumerator;\r\n\r\n/**\r\n * Klassenbeschreibung: Ein ObjectModel repraesentiert ein Object. Es besteht\r\n * aus: 1. Einem ObjectHeaderModel - fuer den Klassennamen 2. Einer Liste von\r\n * AttributeModels, die die Attribute des eigenen Objects repraesentieren. 3.\r\n * Einer Liste von ConnectionModels, die entweder von anderen AttributeModels\r\n * kommen oder von einer der eigenen AttributeModels zu an- deren ObjectModels\r\n * gehen.\r\n *\r\n * Instanzvariablen: headerModel: Referenz auf das Model, das fuer die\r\n * Beinhaltung des Objektnamens steht. attributeModels: Liste aller Modelle, die\r\n * den Inhalt der Attribute (Instanzvariablen etc.) halten. explorerModel:\r\n * Referenz auf das Gesamtmodel. connectionModels: Liste aller Modell, die die\r\n * Darstellung einer Referenz repraesentieren.\r\n *\r\n * Das ObjectModel wird referenziert von: AttributeModel in der \"normalen\"\r\n * Hierarchieverknuepfung, dem ExplorerModel, zusammen mit allen anderen\r\n * ObjectModels in einer Liste. dem ObjectHeaderModel, das fuer den Inhalt des\r\n * Namens des Objectes zustaendig ist.\r\n */\r\npublic class ObjectModel extends Model {\r\n\r\n    private ObjectHeaderModel headerModel;\r\n\r\n    private StandardEnumeration attributeModels;\r\n\r\n    private ExplorerModel explorerModel;\r\n\r\n    private StandardEnumeration connectionModels;\r\n\r\n    private ObjectViewManager objectViewManager;\r\n\r\n    public ObjectModel() {\r\n        super();\r\n    }\r\n\r\n    public void addAttributeModel(AttributeModel attrModl) {\r\n        this.getAttributeModels().addElement(attrModl);\r\n    }\r\n\r\n    public void addConnectionModel(ConnectionModel conModl) {\r\n        this.getConnectionModels().addElement(conModl);\r\n    }\r\n\r\n    public StandardEnumeration getAttributeModels() {\r\n        if (this.attributeModels == null) {\r\n            this.setAttributeModels(new StandardEnumerator());\r\n        }\r\n        return this.attributeModels;\r\n    }\r\n\r\n    public ExplorerColorManager getColorManager() {\r\n        return this.getExplorerModel().getColorManager();\r\n    }\r\n\r\n    public StandardEnumeration getConnectionModels() {\r\n        if (this.connectionModels == null) {\r\n            this.setConnectionModels(new StandardEnumerator());\r\n        }\r\n        return this.connectionModels;\r\n    }\r\n\r\n    public Vector<Field> getDeclaredFields() {\r\n        return this.getDeclaredFields(this.getObject().getClass());\r\n    }\r\n\r\n    public Vector<Field> getDeclaredFields(Class<?> aClass) {\r\n        Field[] field;\r\n        Vector<Field> vector;\r\n        if (aClass.getSuperclass() != null) {\r\n            vector = this.getDeclaredFields(aClass.getSuperclass());\r\n        } else {\r\n            vector = new Vector<Field>();\r\n        }\r\n        field = aClass.getDeclaredFields();\r\n        for (int i = 0; i < field.length; i++) {\r\n            vector.add(field[i]);\r\n        }\r\n        return vector;\r\n    }\r\n\r\n    public ExplorerModel getExplorerModel() {\r\n        return this.explorerModel;\r\n    }\r\n\r\n    @Override\r\n    public Figure getFigure() {\r\n        return this.getFigureInModel();\r\n    }\r\n\r\n    public ObjectHeaderModel getHeaderModel() {\r\n        return this.headerModel;\r\n    }\r\n\r\n    public int getNumberOfAttributes() {\r\n        if (this.isArrayObject()) {\r\n            return Array.getLength(this.getObject());\r\n        }\r\n        if (this.isStringObject() || this.isNullObject()) {\r\n            return 0;\r\n        }\r\n        return this.getDeclaredFields().size();\r\n    }\r\n\r\n    public ObjectViewManager getObjectViewManager() {\r\n        if (this.objectViewManager == null) {\r\n            this.setObjectViewManager(new ObjectViewManager(this));\r\n        }\r\n        return this.objectViewManager;\r\n    }\r\n\r\n    public boolean isArrayObject() {\r\n        return this.getObject().getClass().isArray();\r\n    }\r\n\r\n    public boolean isNullObject() {\r\n        return NullObject.isNullObject(this.getObject());\r\n    }\r\n\r\n    @Override\r\n    public boolean isObjectModel() {\r\n        return true;\r\n    }\r\n\r\n    public boolean isStringObject() {\r\n        return this.getObject().getClass() == String.class;\r\n    }\r\n\r\n    public void removeConnectionModel(ConnectionModel conModl) {\r\n        this.getConnectionModels().removeElement(conModl);\r\n    }\r\n\r\n    public void setAttributeModels(StandardEnumeration models) {\r\n        this.attributeModels = models;\r\n    }\r\n\r\n    private void setConnectionModels(StandardEnumeration conModls) {\r\n        this.connectionModels = conModls;\r\n    }\r\n\r\n    public void setExplorerModel(ExplorerModel explModl) {\r\n        this.explorerModel = explModl;\r\n    }\r\n\r\n    @Override\r\n    public void setFigure(Figure newFigure) {\r\n        this.setFigureInModel(newFigure);\r\n    }\r\n\r\n    public void setHeaderModel(ObjectHeaderModel model) {\r\n        this.headerModel = model;\r\n    }\r\n\r\n    public void setObjectViewManager(ObjectViewManager newObjectViewManager) {\r\n        this.objectViewManager = newObjectViewManager;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/model/ObjectModelTest1.java",
		"test_prompt": "// ObjectModelTest1.java\npackage de.paragon.explorer.model;\n\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Field;\nimport java.util.Vector;\nimport de.paragon.explorer.figure.Figure;\nimport de.paragon.explorer.util.ExplorerColorManager;\nimport de.paragon.explorer.util.ObjectViewManager;\nimport de.paragon.explorer.util.StandardEnumeration;\nimport de.paragon.explorer.util.StandardEnumerator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectModel}.\n* It contains ten unit test cases for the {@link ObjectModel#isNullObject()} method.\n*/\nclass ObjectModelTest1 {"
	},
	{
		"original_code": "// ObjectModel.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.model;\r\n\r\nimport java.lang.reflect.Array;\r\nimport java.lang.reflect.Field;\r\nimport java.util.Vector;\r\nimport de.paragon.explorer.figure.Figure;\r\nimport de.paragon.explorer.util.ExplorerColorManager;\r\nimport de.paragon.explorer.util.ObjectViewManager;\r\nimport de.paragon.explorer.util.StandardEnumeration;\r\nimport de.paragon.explorer.util.StandardEnumerator;\r\n\r\n/**\r\n * Klassenbeschreibung: Ein ObjectModel repraesentiert ein Object. Es besteht\r\n * aus: 1. Einem ObjectHeaderModel - fuer den Klassennamen 2. Einer Liste von\r\n * AttributeModels, die die Attribute des eigenen Objects repraesentieren. 3.\r\n * Einer Liste von ConnectionModels, die entweder von anderen AttributeModels\r\n * kommen oder von einer der eigenen AttributeModels zu an- deren ObjectModels\r\n * gehen.\r\n *\r\n * Instanzvariablen: headerModel: Referenz auf das Model, das fuer die\r\n * Beinhaltung des Objektnamens steht. attributeModels: Liste aller Modelle, die\r\n * den Inhalt der Attribute (Instanzvariablen etc.) halten. explorerModel:\r\n * Referenz auf das Gesamtmodel. connectionModels: Liste aller Modell, die die\r\n * Darstellung einer Referenz repraesentieren.\r\n *\r\n * Das ObjectModel wird referenziert von: AttributeModel in der \"normalen\"\r\n * Hierarchieverknuepfung, dem ExplorerModel, zusammen mit allen anderen\r\n * ObjectModels in einer Liste. dem ObjectHeaderModel, das fuer den Inhalt des\r\n * Namens des Objectes zustaendig ist.\r\n */\r\npublic class ObjectModel extends Model {\r\n\r\n    private ObjectHeaderModel headerModel;\r\n\r\n    private StandardEnumeration attributeModels;\r\n\r\n    private ExplorerModel explorerModel;\r\n\r\n    private StandardEnumeration connectionModels;\r\n\r\n    private ObjectViewManager objectViewManager;\r\n\r\n    public ObjectModel() {\r\n        super();\r\n    }\r\n\r\n    public void addAttributeModel(AttributeModel attrModl) {\r\n        this.getAttributeModels().addElement(attrModl);\r\n    }\r\n\r\n    public void addConnectionModel(ConnectionModel conModl) {\r\n        this.getConnectionModels().addElement(conModl);\r\n    }\r\n\r\n    public StandardEnumeration getAttributeModels() {\r\n        if (this.attributeModels == null) {\r\n            this.setAttributeModels(new StandardEnumerator());\r\n        }\r\n        return this.attributeModels;\r\n    }\r\n\r\n    public ExplorerColorManager getColorManager() {\r\n        return this.getExplorerModel().getColorManager();\r\n    }\r\n\r\n    public StandardEnumeration getConnectionModels() {\r\n        if (this.connectionModels == null) {\r\n            this.setConnectionModels(new StandardEnumerator());\r\n        }\r\n        return this.connectionModels;\r\n    }\r\n\r\n    public Vector<Field> getDeclaredFields() {\r\n        return this.getDeclaredFields(this.getObject().getClass());\r\n    }\r\n\r\n    public Vector<Field> getDeclaredFields(Class<?> aClass) {\r\n        Field[] field;\r\n        Vector<Field> vector;\r\n        if (aClass.getSuperclass() != null) {\r\n            vector = this.getDeclaredFields(aClass.getSuperclass());\r\n        } else {\r\n            vector = new Vector<Field>();\r\n        }\r\n        field = aClass.getDeclaredFields();\r\n        for (int i = 0; i < field.length; i++) {\r\n            vector.add(field[i]);\r\n        }\r\n        return vector;\r\n    }\r\n\r\n    public ExplorerModel getExplorerModel() {\r\n        return this.explorerModel;\r\n    }\r\n\r\n    @Override\r\n    public Figure getFigure() {\r\n        return this.getFigureInModel();\r\n    }\r\n\r\n    public ObjectHeaderModel getHeaderModel() {\r\n        return this.headerModel;\r\n    }\r\n\r\n    public int getNumberOfAttributes() {\r\n        if (this.isArrayObject()) {\r\n            return Array.getLength(this.getObject());\r\n        }\r\n        if (this.isStringObject() || this.isNullObject()) {\r\n            return 0;\r\n        }\r\n        return this.getDeclaredFields().size();\r\n    }\r\n\r\n    public ObjectViewManager getObjectViewManager() {\r\n        if (this.objectViewManager == null) {\r\n            this.setObjectViewManager(new ObjectViewManager(this));\r\n        }\r\n        return this.objectViewManager;\r\n    }\r\n\r\n    public boolean isArrayObject() {\r\n        return this.getObject().getClass().isArray();\r\n    }\r\n\r\n    public boolean isNullObject() {\r\n        return NullObject.isNullObject(this.getObject());\r\n    }\r\n\r\n    @Override\r\n    public boolean isObjectModel() {\r\n        return true;\r\n    }\r\n\r\n    public boolean isStringObject() {\r\n        return this.getObject().getClass() == String.class;\r\n    }\r\n\r\n    public void removeConnectionModel(ConnectionModel conModl) {\r\n        this.getConnectionModels().removeElement(conModl);\r\n    }\r\n\r\n    public void setAttributeModels(StandardEnumeration models) {\r\n        this.attributeModels = models;\r\n    }\r\n\r\n    private void setConnectionModels(StandardEnumeration conModls) {\r\n        this.connectionModels = conModls;\r\n    }\r\n\r\n    public void setExplorerModel(ExplorerModel explModl) {\r\n        this.explorerModel = explModl;\r\n    }\r\n\r\n    @Override\r\n    public void setFigure(Figure newFigure) {\r\n        this.setFigureInModel(newFigure);\r\n    }\r\n\r\n    public void setHeaderModel(ObjectHeaderModel model) {\r\n        this.headerModel = model;\r\n    }\r\n\r\n    public void setObjectViewManager(ObjectViewManager newObjectViewManager) {\r\n        this.objectViewManager = newObjectViewManager;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/model/ObjectModelTest2.java",
		"test_prompt": "// ObjectModelTest2.java\npackage de.paragon.explorer.model;\n\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Field;\nimport java.util.Vector;\nimport de.paragon.explorer.figure.Figure;\nimport de.paragon.explorer.util.ExplorerColorManager;\nimport de.paragon.explorer.util.ObjectViewManager;\nimport de.paragon.explorer.util.StandardEnumeration;\nimport de.paragon.explorer.util.StandardEnumerator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectModel}.\n* It contains ten unit test cases for the {@link ObjectModel#isObjectModel()} method.\n*/\nclass ObjectModelTest2 {"
	},
	{
		"original_code": "// ObjectModel.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.model;\r\n\r\nimport java.lang.reflect.Array;\r\nimport java.lang.reflect.Field;\r\nimport java.util.Vector;\r\nimport de.paragon.explorer.figure.Figure;\r\nimport de.paragon.explorer.util.ExplorerColorManager;\r\nimport de.paragon.explorer.util.ObjectViewManager;\r\nimport de.paragon.explorer.util.StandardEnumeration;\r\nimport de.paragon.explorer.util.StandardEnumerator;\r\n\r\n/**\r\n * Klassenbeschreibung: Ein ObjectModel repraesentiert ein Object. Es besteht\r\n * aus: 1. Einem ObjectHeaderModel - fuer den Klassennamen 2. Einer Liste von\r\n * AttributeModels, die die Attribute des eigenen Objects repraesentieren. 3.\r\n * Einer Liste von ConnectionModels, die entweder von anderen AttributeModels\r\n * kommen oder von einer der eigenen AttributeModels zu an- deren ObjectModels\r\n * gehen.\r\n *\r\n * Instanzvariablen: headerModel: Referenz auf das Model, das fuer die\r\n * Beinhaltung des Objektnamens steht. attributeModels: Liste aller Modelle, die\r\n * den Inhalt der Attribute (Instanzvariablen etc.) halten. explorerModel:\r\n * Referenz auf das Gesamtmodel. connectionModels: Liste aller Modell, die die\r\n * Darstellung einer Referenz repraesentieren.\r\n *\r\n * Das ObjectModel wird referenziert von: AttributeModel in der \"normalen\"\r\n * Hierarchieverknuepfung, dem ExplorerModel, zusammen mit allen anderen\r\n * ObjectModels in einer Liste. dem ObjectHeaderModel, das fuer den Inhalt des\r\n * Namens des Objectes zustaendig ist.\r\n */\r\npublic class ObjectModel extends Model {\r\n\r\n    private ObjectHeaderModel headerModel;\r\n\r\n    private StandardEnumeration attributeModels;\r\n\r\n    private ExplorerModel explorerModel;\r\n\r\n    private StandardEnumeration connectionModels;\r\n\r\n    private ObjectViewManager objectViewManager;\r\n\r\n    public ObjectModel() {\r\n        super();\r\n    }\r\n\r\n    public void addAttributeModel(AttributeModel attrModl) {\r\n        this.getAttributeModels().addElement(attrModl);\r\n    }\r\n\r\n    public void addConnectionModel(ConnectionModel conModl) {\r\n        this.getConnectionModels().addElement(conModl);\r\n    }\r\n\r\n    public StandardEnumeration getAttributeModels() {\r\n        if (this.attributeModels == null) {\r\n            this.setAttributeModels(new StandardEnumerator());\r\n        }\r\n        return this.attributeModels;\r\n    }\r\n\r\n    public ExplorerColorManager getColorManager() {\r\n        return this.getExplorerModel().getColorManager();\r\n    }\r\n\r\n    public StandardEnumeration getConnectionModels() {\r\n        if (this.connectionModels == null) {\r\n            this.setConnectionModels(new StandardEnumerator());\r\n        }\r\n        return this.connectionModels;\r\n    }\r\n\r\n    public Vector<Field> getDeclaredFields() {\r\n        return this.getDeclaredFields(this.getObject().getClass());\r\n    }\r\n\r\n    public Vector<Field> getDeclaredFields(Class<?> aClass) {\r\n        Field[] field;\r\n        Vector<Field> vector;\r\n        if (aClass.getSuperclass() != null) {\r\n            vector = this.getDeclaredFields(aClass.getSuperclass());\r\n        } else {\r\n            vector = new Vector<Field>();\r\n        }\r\n        field = aClass.getDeclaredFields();\r\n        for (int i = 0; i < field.length; i++) {\r\n            vector.add(field[i]);\r\n        }\r\n        return vector;\r\n    }\r\n\r\n    public ExplorerModel getExplorerModel() {\r\n        return this.explorerModel;\r\n    }\r\n\r\n    @Override\r\n    public Figure getFigure() {\r\n        return this.getFigureInModel();\r\n    }\r\n\r\n    public ObjectHeaderModel getHeaderModel() {\r\n        return this.headerModel;\r\n    }\r\n\r\n    public int getNumberOfAttributes() {\r\n        if (this.isArrayObject()) {\r\n            return Array.getLength(this.getObject());\r\n        }\r\n        if (this.isStringObject() || this.isNullObject()) {\r\n            return 0;\r\n        }\r\n        return this.getDeclaredFields().size();\r\n    }\r\n\r\n    public ObjectViewManager getObjectViewManager() {\r\n        if (this.objectViewManager == null) {\r\n            this.setObjectViewManager(new ObjectViewManager(this));\r\n        }\r\n        return this.objectViewManager;\r\n    }\r\n\r\n    public boolean isArrayObject() {\r\n        return this.getObject().getClass().isArray();\r\n    }\r\n\r\n    public boolean isNullObject() {\r\n        return NullObject.isNullObject(this.getObject());\r\n    }\r\n\r\n    @Override\r\n    public boolean isObjectModel() {\r\n        return true;\r\n    }\r\n\r\n    public boolean isStringObject() {\r\n        return this.getObject().getClass() == String.class;\r\n    }\r\n\r\n    public void removeConnectionModel(ConnectionModel conModl) {\r\n        this.getConnectionModels().removeElement(conModl);\r\n    }\r\n\r\n    public void setAttributeModels(StandardEnumeration models) {\r\n        this.attributeModels = models;\r\n    }\r\n\r\n    private void setConnectionModels(StandardEnumeration conModls) {\r\n        this.connectionModels = conModls;\r\n    }\r\n\r\n    public void setExplorerModel(ExplorerModel explModl) {\r\n        this.explorerModel = explModl;\r\n    }\r\n\r\n    @Override\r\n    public void setFigure(Figure newFigure) {\r\n        this.setFigureInModel(newFigure);\r\n    }\r\n\r\n    public void setHeaderModel(ObjectHeaderModel model) {\r\n        this.headerModel = model;\r\n    }\r\n\r\n    public void setObjectViewManager(ObjectViewManager newObjectViewManager) {\r\n        this.objectViewManager = newObjectViewManager;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/model/ObjectModelTest3.java",
		"test_prompt": "// ObjectModelTest3.java\npackage de.paragon.explorer.model;\n\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Field;\nimport java.util.Vector;\nimport de.paragon.explorer.figure.Figure;\nimport de.paragon.explorer.util.ExplorerColorManager;\nimport de.paragon.explorer.util.ObjectViewManager;\nimport de.paragon.explorer.util.StandardEnumeration;\nimport de.paragon.explorer.util.StandardEnumerator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectModel}.\n* It contains ten unit test cases for the {@link ObjectModel#isStringObject()} method.\n*/\nclass ObjectModelTest3 {"
	},
	{
		"original_code": "// AttributeModelBuilder.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.model;\r\n\r\nimport java.lang.reflect.Field;\r\nimport java.util.Collections;\r\nimport java.util.Vector;\r\nimport de.paragon.explorer.util.StandardEnumeration;\r\n\r\npublic final class AttributeModelBuilder {\r\n\r\n    private static AttributeModelBuilder singleton;\r\n\r\n    public static AttributeModelBuilder getInstance() {\r\n        return AttributeModelBuilder.getSingleton();\r\n    }\r\n\r\n    private static AttributeModelBuilder getSingleton() {\r\n        if (AttributeModelBuilder.singleton == null) {\r\n            AttributeModelBuilder.setSingleton(new AttributeModelBuilder());\r\n        }\r\n        return AttributeModelBuilder.singleton;\r\n    }\r\n\r\n    private static void setSingleton(AttributeModelBuilder builder) {\r\n        AttributeModelBuilder.singleton = builder;\r\n    }\r\n\r\n    private AttributeModelBuilder() {\r\n        super();\r\n    }\r\n\r\n    protected void createArrayAttributeModel(ObjectModel objModl) {\r\n        AttributeModel attrModl = new ArrayAttributeModel();\r\n        objModl.addAttributeModel(attrModl);\r\n        attrModl.setObjectModel(objModl);\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht davon aus, dass das ObjectModel bereits mit\r\n     * einem Object versehen ist. Fuer jedes Feld dieses Objects erzeugt sie ein\r\n     * neues AttributeModel und verknuepft es mit dem ObjectModel.\r\n     */\r\n    protected void createAttributeModel(ObjectModel objModl) {\r\n        AttributeModel attrModl = new AttributeModel();\r\n        objModl.addAttributeModel(attrModl);\r\n        attrModl.setObjectModel(objModl);\r\n    }\r\n\r\n    protected void createStandardAttributeModel(ObjectModel objModl) {\r\n        AttributeModel attrModl = new StandardAttributeModel();\r\n        objModl.addAttributeModel(attrModl);\r\n        attrModl.setObjectModel(objModl);\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht davon aus, das bereits fuer jedes Feld des\r\n     * Objects in objectModel ein AttributeModel er- zeugt wurde. Jedem dieser\r\n     * AttributeModels wird der jeweilige Wert des Feldes zugewiesen.\r\n     */\r\n    public void setArrayAttributeData(ObjectModel objModl) {\r\n        int i = 0;\r\n        // Object aObject;\r\n        StandardEnumeration attrModls = objModl.getAttributeModels();\r\n        while (attrModls.hasMoreElements()) {\r\n            ArrayAttributeModel attrModl = (ArrayAttributeModel) attrModls.nextElement();\r\n            // aObject = Array.get(objModl.getObject(), i);\r\n            attrModl.setPos(i);\r\n            attrModl.setName(\"[\" + (Integer.valueOf(i)).toString() + \"]\");\r\n            attrModl.setType(objModl.getObject().getClass().getComponentType());\r\n            // if (aObject != null) {\r\n            // attrModl.setValue(aObject);\r\n            // } else {\r\n            // attrModl.setValue(NullObject.getNullObject());\r\n            // }\r\n            i = i + 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht davon aus, das bereits fuer jedes Feld des\r\n     * Objects in objectModel ein AttributeModel erzeugt wurde. Jedem dieser\r\n     * AttributeModels wird der jeweilige Wert des Feldes zugewiesen.\r\n     */\r\n    public void setStandardAttributeData(ObjectModel objModl) {\r\n        int i = 0;\r\n        // Object aObject;\r\n        Field field;\r\n        StandardEnumeration attrModls = objModl.getAttributeModels();\r\n        Vector<Field> fields = objModl.getDeclaredFields();\r\n        while (attrModls.hasMoreElements()) {\r\n            StandardAttributeModel attrModl = (StandardAttributeModel) attrModls.nextElement();\r\n            field = fields.elementAt(i);\r\n            attrModl.setField(field);\r\n            attrModl.setModifiers(field.getModifiers());\r\n            attrModl.setType(field.getType());\r\n            attrModl.setName(field.getName());\r\n            i = i + 1;\r\n        }\r\n        Vector<AttributeModel> vector2set = new Vector<AttributeModel>();\r\n        Vector<?> vector2transfer = attrModls.getVector();\r\n        for (Object object2 : vector2transfer) {\r\n            vector2set.add((AttributeModel) object2);\r\n        }\r\n        Vector<AttributeModel> vector = vector2set;\r\n        Collections.sort(vector, new AttributeModelComparator());\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/model/AttributeModelBuilderTest.java",
		"test_prompt": "// AttributeModelBuilderTest.java\npackage de.paragon.explorer.model;\n\nimport java.lang.reflect.Field;\nimport java.util.Collections;\nimport java.util.Vector;\nimport de.paragon.explorer.util.StandardEnumeration;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AttributeModelBuilder}.\n* It contains ten unit test cases for the {@link AttributeModelBuilder#getInstance()} method.\n*/\nclass AttributeModelBuilderTest {"
	},
	{
		"original_code": "// AttributeModelComparator.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.model;\r\n\r\nimport java.io.Serializable;\r\nimport java.util.Comparator;\r\n\r\n/**\r\n * Diese Klasse stellt einen Vergleichsalgorihmus zur Sortierung der Attribute\r\n * zur Verfuegung\r\n */\r\npublic class AttributeModelComparator implements Comparator<AttributeModel>, Serializable {\r\n\r\n    private static final String A_AS_STRING = \"a\";\r\n\r\n    private static final long serialVersionUID = -8846334934584145381L;\r\n\r\n    /**\r\n     * Comparator constructor comment.\r\n     */\r\n    public AttributeModelComparator() {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * Compares its two arguments for order. Returns a negative integer, zero,\r\n     * or a positive integer as the first argument is less than, equal to, or\r\n     * greater than the second.\r\n     * <p>\r\n     *\r\n     * The implementor must ensure that <tt>sgn(compare(x, y)) ==\r\n     * -sgn(compare(y, x))</tt> for all <tt>x</tt> and <tt>y</tt>. (This implies\r\n     * that <tt>compare(x, y)</tt> must throw an exception if and only if\r\n     * <tt>compare(y, x)</tt> throws an exception.)\r\n     * <p>\r\n     *\r\n     * The implementor must also ensure that the relation is transitive:\r\n     * <tt>((compare(x, y)&gt;0) &amp;&amp; (compare(y, z)&gt;0))</tt> implies\r\n     * <tt>compare(x, z)&gt;0</tt>.\r\n     * <p>\r\n     *\r\n     * Finally, the implementer must ensure that <tt>compare(x, y)==0</tt>\r\n     * implies that <tt>sgn(compare(x, z))==sgn(compare(y, z))</tt> for all\r\n     * <tt>z</tt>.\r\n     * <p>\r\n     *\r\n     * It is generally the case, but <i>not </i> strictly required that\r\n     * <tt>(compare(x, y)==0) == (x.equals(y))</tt>. Generally speaking, any\r\n     * comparator that violates this condition should clearly indicate this\r\n     * fact. The recommended language is \"Note: this comparator imposes\r\n     * orderings that are inconsistent with equals.\"\r\n     *\r\n     * @return a negative integer, zero, or a positive integer as the first\r\n     *         argument is less than, equal to, or greater than the second.\r\n     * @throws ClassCastException\r\n     *             if the arguments' types prevent them from being compared by\r\n     *             this Comparator.\r\n     */\r\n    public int compare(AttributeModel o1, AttributeModel o2) {\r\n        int value = -1;\r\n        if ((o1 != null) && (o2 != null)) {\r\n            value = (o1).getName().compareToIgnoreCase((o2).getName());\r\n            if (value < 0) {\r\n                if (((o1).getName().compareToIgnoreCase(AttributeModelComparator.A_AS_STRING) < 0) && ((o2).getName().compareToIgnoreCase(AttributeModelComparator.A_AS_STRING) >= 0)) {\r\n                    return 1;\r\n                }\r\n            }\r\n            if (value > 0) {\r\n                if (((o2).getName().compareToIgnoreCase(AttributeModelComparator.A_AS_STRING) < 0) && ((o1).getName().compareToIgnoreCase(AttributeModelComparator.A_AS_STRING) >= 0)) {\r\n                    return -1;\r\n                }\r\n            }\r\n        }\r\n        return value;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/model/AttributeModelComparatorTest.java",
		"test_prompt": "// AttributeModelComparatorTest.java\npackage de.paragon.explorer.model;\n\nimport java.io.Serializable;\nimport java.util.Comparator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AttributeModelComparator}.\n* It contains ten unit test cases for the {@link AttributeModelComparator#compare(AttributeModel, AttributeModel)} method.\n*/\nclass AttributeModelComparatorTest {"
	},
	{
		"original_code": "// NullObject.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.model;\r\n\r\npublic final class NullObject {\r\n\r\n    private static NullObject nullObject;\r\n\r\n    public static NullObject getNullObject() {\r\n        if (NullObject.nullObject == null) {\r\n            NullObject.nullObject = new NullObject();\r\n        }\r\n        return NullObject.nullObject;\r\n    }\r\n\r\n    public static boolean isNullObject() {\r\n        return false;\r\n    }\r\n\r\n    public static boolean isNullObject(Object object) {\r\n        if (NullObject.getNullObject() == object) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * NullObject constructor comment.\r\n     */\r\n    private NullObject() {\r\n        super();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/model/NullObjectTest0.java",
		"test_prompt": "// NullObjectTest0.java\npackage de.paragon.explorer.model;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NullObject}.\n* It contains ten unit test cases for the {@link NullObject#getNullObject()} method.\n*/\nclass NullObjectTest0 {"
	},
	{
		"original_code": "// NullObject.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.model;\r\n\r\npublic final class NullObject {\r\n\r\n    private static NullObject nullObject;\r\n\r\n    public static NullObject getNullObject() {\r\n        if (NullObject.nullObject == null) {\r\n            NullObject.nullObject = new NullObject();\r\n        }\r\n        return NullObject.nullObject;\r\n    }\r\n\r\n    public static boolean isNullObject() {\r\n        return false;\r\n    }\r\n\r\n    public static boolean isNullObject(Object object) {\r\n        if (NullObject.getNullObject() == object) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * NullObject constructor comment.\r\n     */\r\n    private NullObject() {\r\n        super();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/model/NullObjectTest1.java",
		"test_prompt": "// NullObjectTest1.java\npackage de.paragon.explorer.model;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NullObject}.\n* It contains ten unit test cases for the {@link NullObject#isNullObject()} method.\n*/\nclass NullObjectTest1 {"
	},
	{
		"original_code": "// NullObject.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.model;\r\n\r\npublic final class NullObject {\r\n\r\n    private static NullObject nullObject;\r\n\r\n    public static NullObject getNullObject() {\r\n        if (NullObject.nullObject == null) {\r\n            NullObject.nullObject = new NullObject();\r\n        }\r\n        return NullObject.nullObject;\r\n    }\r\n\r\n    public static boolean isNullObject() {\r\n        return false;\r\n    }\r\n\r\n    public static boolean isNullObject(Object object) {\r\n        if (NullObject.getNullObject() == object) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * NullObject constructor comment.\r\n     */\r\n    private NullObject() {\r\n        super();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/model/NullObjectTest2.java",
		"test_prompt": "// NullObjectTest2.java\npackage de.paragon.explorer.model;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NullObject}.\n* It contains ten unit test cases for the {@link NullObject#isNullObject(Object)} method.\n*/\nclass NullObjectTest2 {"
	},
	{
		"original_code": "// AttributeModel.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.model;\r\n\r\nimport de.paragon.explorer.figure.Figure;\r\nimport de.paragon.explorer.figure.TextBoxFigure;\r\nimport de.paragon.explorer.util.AttributeTitleManager;\r\n\r\n/**\r\n * Klassenbeschreibung: Ein AttributeModel stellt ein Attribute -sprich eine\r\n * Instanzvariable- dar. Es referenziert auf ein Field und auf ein ObjectModel.\r\n * Anhand dieser Instanzvariablen kann es das entsprechende Objekt, das die\r\n * entsprechende Instanzvariable referenziert, ermitteln. Die visuelle\r\n * Darstellung eines AttributeModels besteht aus zwei Figuren, nicht nur aus\r\n * einer. Deshalb hat das AttributeModel neben der vererbten Instanzvariable\r\n * figure eine weitere: ConnectionFigure. Daraus gehen die beiden Bestandteile\r\n * der Figur hervor: Eine TextBoxFigure und eine ConnectionFigure. Beschreibung\r\n * der Instanzvariablen: In objectModel wird das ObjectModel gesetzt, zu dem das\r\n * AttributeModel gehoert. field ist eigentlich selbsterklaerend. In\r\n * connectionModel wird ein ConnectionModel gespeichert, falls eine Verbindung\r\n * zum entsprechenden Object gezeigt wird.\r\n *\r\n * Das AttributeModel wird referenziert von: Dem ConnectionModel, das eine\r\n * Referenz zeigt (falls eines existiert), dem ObjectModel zusammen mit allen\r\n * anderen Attributmodellen des entsprechenden ObjectModels in der normalen\r\n * Hierarchieverknuepfung\r\n */\r\npublic class AttributeModel extends ObjectModelPart {\r\n\r\n    private ObjectModel objectModel;\r\n\r\n    private ConnectionModel connectionModel;\r\n\r\n    private int modifiers;\r\n\r\n    private Object value;\r\n\r\n    private Class<?> type;\r\n\r\n    private String name;\r\n\r\n    public AttributeModel() {\r\n        super();\r\n    }\r\n\r\n    private AttributeTitleManager getAttributeTitleManager() {\r\n        return AttributeTitleManager.getSingleton();\r\n    }\r\n\r\n    @Override\r\n    public String getCompleteTitle() {\r\n        return this.getAttributeTitleManager().getCompleteTitle(this);\r\n    }\r\n\r\n    public ConnectionModel getConnectionModel() {\r\n        return this.connectionModel;\r\n    }\r\n\r\n    @Override\r\n    public Figure getFigure() {\r\n        return this.getFigureInModel();\r\n    }\r\n\r\n    public int getModifiers() {\r\n        return this.modifiers;\r\n    }\r\n\r\n    public String getName() {\r\n        return this.name;\r\n    }\r\n\r\n    @Override\r\n    public ObjectModel getObjectModel() {\r\n        return this.objectModel;\r\n    }\r\n\r\n    public String getTitle() {\r\n        return this.getAttributeTitleManager().getTitle(this);\r\n    }\r\n\r\n    public Class<?> getType() {\r\n        return this.type;\r\n    }\r\n\r\n    public Object getValue() {\r\n        return this.value;\r\n    }\r\n\r\n    @Override\r\n    public boolean isAttributeModel() {\r\n        return true;\r\n    }\r\n\r\n    public boolean isAttributePrimitive() {\r\n        if (this.getType().isArray()) {\r\n            return false;\r\n        }\r\n        return this.getType().isPrimitive();\r\n    }\r\n\r\n    public boolean isVisible() {\r\n        return ((TextBoxFigure) this.getFigure()).isVisible();\r\n    }\r\n\r\n    public void setConnectionModel(ConnectionModel modl) {\r\n        this.connectionModel = modl;\r\n    }\r\n\r\n    @Override\r\n    public void setFigure(Figure newFigure) {\r\n        this.setFigureInModel(newFigure);\r\n    }\r\n\r\n    public void setModifiers(int newModifiers) {\r\n        this.modifiers = newModifiers;\r\n    }\r\n\r\n    public void setName(String newName) {\r\n        this.name = newName;\r\n    }\r\n\r\n    public void setObjectModel(ObjectModel model) {\r\n        this.objectModel = model;\r\n    }\r\n\r\n    public void setType(Class<?> newType) {\r\n        this.type = newType;\r\n    }\r\n\r\n    public void setValue(Object newValue) {\r\n        this.value = newValue;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/model/AttributeModelTest0.java",
		"test_prompt": "// AttributeModelTest0.java\npackage de.paragon.explorer.model;\n\nimport de.paragon.explorer.figure.Figure;\nimport de.paragon.explorer.figure.TextBoxFigure;\nimport de.paragon.explorer.util.AttributeTitleManager;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AttributeModel}.\n* It contains ten unit test cases for the {@link AttributeModel#isAttributeModel()} method.\n*/\nclass AttributeModelTest0 {"
	},
	{
		"original_code": "// AttributeModel.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.model;\r\n\r\nimport de.paragon.explorer.figure.Figure;\r\nimport de.paragon.explorer.figure.TextBoxFigure;\r\nimport de.paragon.explorer.util.AttributeTitleManager;\r\n\r\n/**\r\n * Klassenbeschreibung: Ein AttributeModel stellt ein Attribute -sprich eine\r\n * Instanzvariable- dar. Es referenziert auf ein Field und auf ein ObjectModel.\r\n * Anhand dieser Instanzvariablen kann es das entsprechende Objekt, das die\r\n * entsprechende Instanzvariable referenziert, ermitteln. Die visuelle\r\n * Darstellung eines AttributeModels besteht aus zwei Figuren, nicht nur aus\r\n * einer. Deshalb hat das AttributeModel neben der vererbten Instanzvariable\r\n * figure eine weitere: ConnectionFigure. Daraus gehen die beiden Bestandteile\r\n * der Figur hervor: Eine TextBoxFigure und eine ConnectionFigure. Beschreibung\r\n * der Instanzvariablen: In objectModel wird das ObjectModel gesetzt, zu dem das\r\n * AttributeModel gehoert. field ist eigentlich selbsterklaerend. In\r\n * connectionModel wird ein ConnectionModel gespeichert, falls eine Verbindung\r\n * zum entsprechenden Object gezeigt wird.\r\n *\r\n * Das AttributeModel wird referenziert von: Dem ConnectionModel, das eine\r\n * Referenz zeigt (falls eines existiert), dem ObjectModel zusammen mit allen\r\n * anderen Attributmodellen des entsprechenden ObjectModels in der normalen\r\n * Hierarchieverknuepfung\r\n */\r\npublic class AttributeModel extends ObjectModelPart {\r\n\r\n    private ObjectModel objectModel;\r\n\r\n    private ConnectionModel connectionModel;\r\n\r\n    private int modifiers;\r\n\r\n    private Object value;\r\n\r\n    private Class<?> type;\r\n\r\n    private String name;\r\n\r\n    public AttributeModel() {\r\n        super();\r\n    }\r\n\r\n    private AttributeTitleManager getAttributeTitleManager() {\r\n        return AttributeTitleManager.getSingleton();\r\n    }\r\n\r\n    @Override\r\n    public String getCompleteTitle() {\r\n        return this.getAttributeTitleManager().getCompleteTitle(this);\r\n    }\r\n\r\n    public ConnectionModel getConnectionModel() {\r\n        return this.connectionModel;\r\n    }\r\n\r\n    @Override\r\n    public Figure getFigure() {\r\n        return this.getFigureInModel();\r\n    }\r\n\r\n    public int getModifiers() {\r\n        return this.modifiers;\r\n    }\r\n\r\n    public String getName() {\r\n        return this.name;\r\n    }\r\n\r\n    @Override\r\n    public ObjectModel getObjectModel() {\r\n        return this.objectModel;\r\n    }\r\n\r\n    public String getTitle() {\r\n        return this.getAttributeTitleManager().getTitle(this);\r\n    }\r\n\r\n    public Class<?> getType() {\r\n        return this.type;\r\n    }\r\n\r\n    public Object getValue() {\r\n        return this.value;\r\n    }\r\n\r\n    @Override\r\n    public boolean isAttributeModel() {\r\n        return true;\r\n    }\r\n\r\n    public boolean isAttributePrimitive() {\r\n        if (this.getType().isArray()) {\r\n            return false;\r\n        }\r\n        return this.getType().isPrimitive();\r\n    }\r\n\r\n    public boolean isVisible() {\r\n        return ((TextBoxFigure) this.getFigure()).isVisible();\r\n    }\r\n\r\n    public void setConnectionModel(ConnectionModel modl) {\r\n        this.connectionModel = modl;\r\n    }\r\n\r\n    @Override\r\n    public void setFigure(Figure newFigure) {\r\n        this.setFigureInModel(newFigure);\r\n    }\r\n\r\n    public void setModifiers(int newModifiers) {\r\n        this.modifiers = newModifiers;\r\n    }\r\n\r\n    public void setName(String newName) {\r\n        this.name = newName;\r\n    }\r\n\r\n    public void setObjectModel(ObjectModel model) {\r\n        this.objectModel = model;\r\n    }\r\n\r\n    public void setType(Class<?> newType) {\r\n        this.type = newType;\r\n    }\r\n\r\n    public void setValue(Object newValue) {\r\n        this.value = newValue;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/model/AttributeModelTest1.java",
		"test_prompt": "// AttributeModelTest1.java\npackage de.paragon.explorer.model;\n\nimport de.paragon.explorer.figure.Figure;\nimport de.paragon.explorer.figure.TextBoxFigure;\nimport de.paragon.explorer.util.AttributeTitleManager;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AttributeModel}.\n* It contains ten unit test cases for the {@link AttributeModel#isAttributePrimitive()} method.\n*/\nclass AttributeModelTest1 {"
	},
	{
		"original_code": "// AttributeModel.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.model;\r\n\r\nimport de.paragon.explorer.figure.Figure;\r\nimport de.paragon.explorer.figure.TextBoxFigure;\r\nimport de.paragon.explorer.util.AttributeTitleManager;\r\n\r\n/**\r\n * Klassenbeschreibung: Ein AttributeModel stellt ein Attribute -sprich eine\r\n * Instanzvariable- dar. Es referenziert auf ein Field und auf ein ObjectModel.\r\n * Anhand dieser Instanzvariablen kann es das entsprechende Objekt, das die\r\n * entsprechende Instanzvariable referenziert, ermitteln. Die visuelle\r\n * Darstellung eines AttributeModels besteht aus zwei Figuren, nicht nur aus\r\n * einer. Deshalb hat das AttributeModel neben der vererbten Instanzvariable\r\n * figure eine weitere: ConnectionFigure. Daraus gehen die beiden Bestandteile\r\n * der Figur hervor: Eine TextBoxFigure und eine ConnectionFigure. Beschreibung\r\n * der Instanzvariablen: In objectModel wird das ObjectModel gesetzt, zu dem das\r\n * AttributeModel gehoert. field ist eigentlich selbsterklaerend. In\r\n * connectionModel wird ein ConnectionModel gespeichert, falls eine Verbindung\r\n * zum entsprechenden Object gezeigt wird.\r\n *\r\n * Das AttributeModel wird referenziert von: Dem ConnectionModel, das eine\r\n * Referenz zeigt (falls eines existiert), dem ObjectModel zusammen mit allen\r\n * anderen Attributmodellen des entsprechenden ObjectModels in der normalen\r\n * Hierarchieverknuepfung\r\n */\r\npublic class AttributeModel extends ObjectModelPart {\r\n\r\n    private ObjectModel objectModel;\r\n\r\n    private ConnectionModel connectionModel;\r\n\r\n    private int modifiers;\r\n\r\n    private Object value;\r\n\r\n    private Class<?> type;\r\n\r\n    private String name;\r\n\r\n    public AttributeModel() {\r\n        super();\r\n    }\r\n\r\n    private AttributeTitleManager getAttributeTitleManager() {\r\n        return AttributeTitleManager.getSingleton();\r\n    }\r\n\r\n    @Override\r\n    public String getCompleteTitle() {\r\n        return this.getAttributeTitleManager().getCompleteTitle(this);\r\n    }\r\n\r\n    public ConnectionModel getConnectionModel() {\r\n        return this.connectionModel;\r\n    }\r\n\r\n    @Override\r\n    public Figure getFigure() {\r\n        return this.getFigureInModel();\r\n    }\r\n\r\n    public int getModifiers() {\r\n        return this.modifiers;\r\n    }\r\n\r\n    public String getName() {\r\n        return this.name;\r\n    }\r\n\r\n    @Override\r\n    public ObjectModel getObjectModel() {\r\n        return this.objectModel;\r\n    }\r\n\r\n    public String getTitle() {\r\n        return this.getAttributeTitleManager().getTitle(this);\r\n    }\r\n\r\n    public Class<?> getType() {\r\n        return this.type;\r\n    }\r\n\r\n    public Object getValue() {\r\n        return this.value;\r\n    }\r\n\r\n    @Override\r\n    public boolean isAttributeModel() {\r\n        return true;\r\n    }\r\n\r\n    public boolean isAttributePrimitive() {\r\n        if (this.getType().isArray()) {\r\n            return false;\r\n        }\r\n        return this.getType().isPrimitive();\r\n    }\r\n\r\n    public boolean isVisible() {\r\n        return ((TextBoxFigure) this.getFigure()).isVisible();\r\n    }\r\n\r\n    public void setConnectionModel(ConnectionModel modl) {\r\n        this.connectionModel = modl;\r\n    }\r\n\r\n    @Override\r\n    public void setFigure(Figure newFigure) {\r\n        this.setFigureInModel(newFigure);\r\n    }\r\n\r\n    public void setModifiers(int newModifiers) {\r\n        this.modifiers = newModifiers;\r\n    }\r\n\r\n    public void setName(String newName) {\r\n        this.name = newName;\r\n    }\r\n\r\n    public void setObjectModel(ObjectModel model) {\r\n        this.objectModel = model;\r\n    }\r\n\r\n    public void setType(Class<?> newType) {\r\n        this.type = newType;\r\n    }\r\n\r\n    public void setValue(Object newValue) {\r\n        this.value = newValue;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/model/AttributeModelTest2.java",
		"test_prompt": "// AttributeModelTest2.java\npackage de.paragon.explorer.model;\n\nimport de.paragon.explorer.figure.Figure;\nimport de.paragon.explorer.figure.TextBoxFigure;\nimport de.paragon.explorer.util.AttributeTitleManager;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AttributeModel}.\n* It contains ten unit test cases for the {@link AttributeModel#isVisible()} method.\n*/\nclass AttributeModelTest2 {"
	},
	{
		"original_code": "// Model.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.model;\r\n\r\nimport de.paragon.explorer.figure.Figure;\r\n\r\n/**\r\n * Klassenbeschreibung: Die abstrakte Klasse Model ermoeglicht fuer alle\r\n * Subklassen:\r\n *\r\n * Instanzvariablen: figure: Die Verknuepfung mit einer Figure, die den Inhaltes\r\n * eines Models visuell darstellen soll. Konkret bedeutet dies fuer die\r\n * Explorer-Subklassen: ExplorerModel-ExplorerFigure; die ExplorerFigure stellt\r\n * den gesamten Inhalt - geschachtelt aehn- lich wie die Hierarchie der Models -\r\n * dar. ObjectModels-ListBoxFigure; Eine ListBoxFigure stellt ein Object dar,\r\n * das durch ein Object Model repraesentiert wird. ObjectHeaderModel und\r\n * AttributeModel-TextBox- Figure; eine TextBoxFigure stellt den Klassen- bzw.\r\n * Feldnamen in Stringform graphisch dar.\r\n * ConnectionModel-StandardConnectionFigure; Die StandardConnectionFigure stellt\r\n * eine Referenz von einem Feld auf ein Object graphisch dar, falls diese\r\n * Darstellung erwuenscht ist.\r\n *\r\n * object: Das Object, das das jeweilige SubModel repraesentiert.\r\n *\r\n * Ein Objekt dieser Klasse wird referenziert von: ExplorerFigure,\r\n * ListBoxFigure, TextBoxFigure zur inhaltlichen Darstellung dieser Figuren.\r\n */\r\npublic abstract class Model {\r\n\r\n    private Object object;\r\n\r\n    private Figure figureInModel;\r\n\r\n    protected Figure getFigureInModel() {\r\n        return this.figureInModel;\r\n    }\r\n\r\n    protected void setFigureInModel(Figure newFigureInModel) {\r\n        this.figureInModel = newFigureInModel;\r\n    }\r\n\r\n    public Model() {\r\n        super();\r\n    }\r\n\r\n    public abstract Figure getFigure();\r\n\r\n    public Object getObject() {\r\n        return this.object;\r\n    }\r\n\r\n    public boolean isAttributeModel() {\r\n        return false;\r\n    }\r\n\r\n    public boolean isExplorerModel() {\r\n        return false;\r\n    }\r\n\r\n    public boolean isObjectHeaderModel() {\r\n        return false;\r\n    }\r\n\r\n    public boolean isObjectModel() {\r\n        return false;\r\n    }\r\n\r\n    public abstract void setFigure(Figure newFigure);\r\n\r\n    public void setObject(Object newObject) {\r\n        this.object = newObject;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/model/ModelTest0.java",
		"test_prompt": "// ModelTest0.java\npackage de.paragon.explorer.model;\n\nimport de.paragon.explorer.figure.Figure;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Model}.\n* It contains ten unit test cases for the {@link Model#isAttributeModel()} method.\n*/\nclass ModelTest0 {"
	},
	{
		"original_code": "// Model.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.model;\r\n\r\nimport de.paragon.explorer.figure.Figure;\r\n\r\n/**\r\n * Klassenbeschreibung: Die abstrakte Klasse Model ermoeglicht fuer alle\r\n * Subklassen:\r\n *\r\n * Instanzvariablen: figure: Die Verknuepfung mit einer Figure, die den Inhaltes\r\n * eines Models visuell darstellen soll. Konkret bedeutet dies fuer die\r\n * Explorer-Subklassen: ExplorerModel-ExplorerFigure; die ExplorerFigure stellt\r\n * den gesamten Inhalt - geschachtelt aehn- lich wie die Hierarchie der Models -\r\n * dar. ObjectModels-ListBoxFigure; Eine ListBoxFigure stellt ein Object dar,\r\n * das durch ein Object Model repraesentiert wird. ObjectHeaderModel und\r\n * AttributeModel-TextBox- Figure; eine TextBoxFigure stellt den Klassen- bzw.\r\n * Feldnamen in Stringform graphisch dar.\r\n * ConnectionModel-StandardConnectionFigure; Die StandardConnectionFigure stellt\r\n * eine Referenz von einem Feld auf ein Object graphisch dar, falls diese\r\n * Darstellung erwuenscht ist.\r\n *\r\n * object: Das Object, das das jeweilige SubModel repraesentiert.\r\n *\r\n * Ein Objekt dieser Klasse wird referenziert von: ExplorerFigure,\r\n * ListBoxFigure, TextBoxFigure zur inhaltlichen Darstellung dieser Figuren.\r\n */\r\npublic abstract class Model {\r\n\r\n    private Object object;\r\n\r\n    private Figure figureInModel;\r\n\r\n    protected Figure getFigureInModel() {\r\n        return this.figureInModel;\r\n    }\r\n\r\n    protected void setFigureInModel(Figure newFigureInModel) {\r\n        this.figureInModel = newFigureInModel;\r\n    }\r\n\r\n    public Model() {\r\n        super();\r\n    }\r\n\r\n    public abstract Figure getFigure();\r\n\r\n    public Object getObject() {\r\n        return this.object;\r\n    }\r\n\r\n    public boolean isAttributeModel() {\r\n        return false;\r\n    }\r\n\r\n    public boolean isExplorerModel() {\r\n        return false;\r\n    }\r\n\r\n    public boolean isObjectHeaderModel() {\r\n        return false;\r\n    }\r\n\r\n    public boolean isObjectModel() {\r\n        return false;\r\n    }\r\n\r\n    public abstract void setFigure(Figure newFigure);\r\n\r\n    public void setObject(Object newObject) {\r\n        this.object = newObject;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/model/ModelTest1.java",
		"test_prompt": "// ModelTest1.java\npackage de.paragon.explorer.model;\n\nimport de.paragon.explorer.figure.Figure;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Model}.\n* It contains ten unit test cases for the {@link Model#isExplorerModel()} method.\n*/\nclass ModelTest1 {"
	},
	{
		"original_code": "// Model.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.model;\r\n\r\nimport de.paragon.explorer.figure.Figure;\r\n\r\n/**\r\n * Klassenbeschreibung: Die abstrakte Klasse Model ermoeglicht fuer alle\r\n * Subklassen:\r\n *\r\n * Instanzvariablen: figure: Die Verknuepfung mit einer Figure, die den Inhaltes\r\n * eines Models visuell darstellen soll. Konkret bedeutet dies fuer die\r\n * Explorer-Subklassen: ExplorerModel-ExplorerFigure; die ExplorerFigure stellt\r\n * den gesamten Inhalt - geschachtelt aehn- lich wie die Hierarchie der Models -\r\n * dar. ObjectModels-ListBoxFigure; Eine ListBoxFigure stellt ein Object dar,\r\n * das durch ein Object Model repraesentiert wird. ObjectHeaderModel und\r\n * AttributeModel-TextBox- Figure; eine TextBoxFigure stellt den Klassen- bzw.\r\n * Feldnamen in Stringform graphisch dar.\r\n * ConnectionModel-StandardConnectionFigure; Die StandardConnectionFigure stellt\r\n * eine Referenz von einem Feld auf ein Object graphisch dar, falls diese\r\n * Darstellung erwuenscht ist.\r\n *\r\n * object: Das Object, das das jeweilige SubModel repraesentiert.\r\n *\r\n * Ein Objekt dieser Klasse wird referenziert von: ExplorerFigure,\r\n * ListBoxFigure, TextBoxFigure zur inhaltlichen Darstellung dieser Figuren.\r\n */\r\npublic abstract class Model {\r\n\r\n    private Object object;\r\n\r\n    private Figure figureInModel;\r\n\r\n    protected Figure getFigureInModel() {\r\n        return this.figureInModel;\r\n    }\r\n\r\n    protected void setFigureInModel(Figure newFigureInModel) {\r\n        this.figureInModel = newFigureInModel;\r\n    }\r\n\r\n    public Model() {\r\n        super();\r\n    }\r\n\r\n    public abstract Figure getFigure();\r\n\r\n    public Object getObject() {\r\n        return this.object;\r\n    }\r\n\r\n    public boolean isAttributeModel() {\r\n        return false;\r\n    }\r\n\r\n    public boolean isExplorerModel() {\r\n        return false;\r\n    }\r\n\r\n    public boolean isObjectHeaderModel() {\r\n        return false;\r\n    }\r\n\r\n    public boolean isObjectModel() {\r\n        return false;\r\n    }\r\n\r\n    public abstract void setFigure(Figure newFigure);\r\n\r\n    public void setObject(Object newObject) {\r\n        this.object = newObject;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/model/ModelTest2.java",
		"test_prompt": "// ModelTest2.java\npackage de.paragon.explorer.model;\n\nimport de.paragon.explorer.figure.Figure;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Model}.\n* It contains ten unit test cases for the {@link Model#isObjectHeaderModel()} method.\n*/\nclass ModelTest2 {"
	},
	{
		"original_code": "// Model.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.model;\r\n\r\nimport de.paragon.explorer.figure.Figure;\r\n\r\n/**\r\n * Klassenbeschreibung: Die abstrakte Klasse Model ermoeglicht fuer alle\r\n * Subklassen:\r\n *\r\n * Instanzvariablen: figure: Die Verknuepfung mit einer Figure, die den Inhaltes\r\n * eines Models visuell darstellen soll. Konkret bedeutet dies fuer die\r\n * Explorer-Subklassen: ExplorerModel-ExplorerFigure; die ExplorerFigure stellt\r\n * den gesamten Inhalt - geschachtelt aehn- lich wie die Hierarchie der Models -\r\n * dar. ObjectModels-ListBoxFigure; Eine ListBoxFigure stellt ein Object dar,\r\n * das durch ein Object Model repraesentiert wird. ObjectHeaderModel und\r\n * AttributeModel-TextBox- Figure; eine TextBoxFigure stellt den Klassen- bzw.\r\n * Feldnamen in Stringform graphisch dar.\r\n * ConnectionModel-StandardConnectionFigure; Die StandardConnectionFigure stellt\r\n * eine Referenz von einem Feld auf ein Object graphisch dar, falls diese\r\n * Darstellung erwuenscht ist.\r\n *\r\n * object: Das Object, das das jeweilige SubModel repraesentiert.\r\n *\r\n * Ein Objekt dieser Klasse wird referenziert von: ExplorerFigure,\r\n * ListBoxFigure, TextBoxFigure zur inhaltlichen Darstellung dieser Figuren.\r\n */\r\npublic abstract class Model {\r\n\r\n    private Object object;\r\n\r\n    private Figure figureInModel;\r\n\r\n    protected Figure getFigureInModel() {\r\n        return this.figureInModel;\r\n    }\r\n\r\n    protected void setFigureInModel(Figure newFigureInModel) {\r\n        this.figureInModel = newFigureInModel;\r\n    }\r\n\r\n    public Model() {\r\n        super();\r\n    }\r\n\r\n    public abstract Figure getFigure();\r\n\r\n    public Object getObject() {\r\n        return this.object;\r\n    }\r\n\r\n    public boolean isAttributeModel() {\r\n        return false;\r\n    }\r\n\r\n    public boolean isExplorerModel() {\r\n        return false;\r\n    }\r\n\r\n    public boolean isObjectHeaderModel() {\r\n        return false;\r\n    }\r\n\r\n    public boolean isObjectModel() {\r\n        return false;\r\n    }\r\n\r\n    public abstract void setFigure(Figure newFigure);\r\n\r\n    public void setObject(Object newObject) {\r\n        this.object = newObject;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/model/ModelTest3.java",
		"test_prompt": "// ModelTest3.java\npackage de.paragon.explorer.model;\n\nimport de.paragon.explorer.figure.Figure;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Model}.\n* It contains ten unit test cases for the {@link Model#isObjectModel()} method.\n*/\nclass ModelTest3 {"
	},
	{
		"original_code": "// ObjectModelBuilder.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.model;\r\n\r\nimport java.util.Vector;\r\nimport de.paragon.explorer.figure.ListBoxFigureBuilder;\r\nimport de.paragon.explorer.figure.TextBoxFigure;\r\nimport de.paragon.explorer.util.ObjectViewManager;\r\nimport de.paragon.explorer.util.PropertyManager;\r\nimport de.paragon.explorer.util.StandardEnumeration;\r\nimport de.paragon.explorer.util.StandardEnumerator;\r\n\r\npublic final class ObjectModelBuilder {\r\n\r\n    private static ObjectModelBuilder singleton;\r\n\r\n    public static ObjectModelBuilder getInstance() {\r\n        return ObjectModelBuilder.getSingleton();\r\n    }\r\n\r\n    private static ObjectModelBuilder getSingleton() {\r\n        if (ObjectModelBuilder.singleton == null) {\r\n            ObjectModelBuilder.setSingleton(new ObjectModelBuilder());\r\n        }\r\n        return ObjectModelBuilder.singleton;\r\n    }\r\n\r\n    private static void setSingleton(ObjectModelBuilder builder) {\r\n        ObjectModelBuilder.singleton = builder;\r\n    }\r\n\r\n    private ObjectModelBuilder() {\r\n        super();\r\n    }\r\n\r\n    protected StandardEnumeration asEnumeration(Object[] anArray) {\r\n        Vector<Object> aVector = new Vector<Object>();\r\n        for (int i = 0; i < anArray.length; i++) {\r\n            aVector.addElement(anArray[i]);\r\n        }\r\n        return new StandardEnumerator(aVector);\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht davon aus, dass das ExplorerModel, das\r\n     * ObjectModel, die ExplorerFigure und die ListBoxFigure schon miteinander\r\n     * verknuepft sind. Zunaechst wird das HeaderModel erzeugt und mit dem\r\n     * ObjectModel verknuepft. Analog wird fuer jedes Feld des Objekts ein\r\n     * AttributeModel erzeugt und mit dem ObjectModel verknuepft. Dann wird\r\n     * allen AttributeModels ihr jeweiliger Wert, also das Objekt, auf das das\r\n     * jeweilige Feld zeigt, zugewiesen. Fuer alle Teile des ObjectModels (also\r\n     * die Vereinigung von ObjectHeaderModel und AttributeModels) wird je eine\r\n     * TextBox- Figure erzeugt und mit dem jeweiligen Model verknuepft. Jede der\r\n     * soeben erzeugten TextBoxFigures erhaelt den ent- sprechenden\r\n     * darzustellenden Text. Danach wird der mit dem HeaderModel verknuepften\r\n     * TextBox- Figure der darzustellende Text zugewiesen, anhand dessen die\r\n     * Groesse bestimmt wird, und anschliessend wird sie mit derselben\r\n     * ListBoxFigure verknuepft, die mit der Explorer-Figure verknuepft ist, die\r\n     * die Graphics kennt, anhand derer die Groesse bestimmt wurde. Dann wird\r\n     * eine FilledRectangleFigure mit der ListBoxFigure verknuepft. Schliesslich\r\n     * wird mit allen mit einem AttributeModel verknuepften TextBoxFigures\r\n     * analog zum HeaderModel verfahren. Zum Schluss wird noch die Groesse der\r\n     * ListBoxFigure korrigiert.\r\n     */\r\n    public void buildObjectModel(ObjectModel objModl, Object object) {\r\n        this.setObject(objModl, object);\r\n        this.createModelParts(objModl);\r\n        this.setAttributes(objModl);\r\n        this.getListBoxFigureBuilder().buildListBoxFigure(objModl);\r\n        this.initializeObjectViewManager(objModl);\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht davon aus, dass ExplorerModel,\r\n     * ExplorerFigure, ObjectModel und ListBoxFigure miteinander verknuepft\r\n     * sind. Diese Methode erzeugt ein HeaderModel und verknuepft dies mit dem\r\n     * objectModel. Dasselbe geschieht anschliessend fuer alle Felder des\r\n     * Objects. Fuer jedes Feld wird ein AttributeModel erzeugt und verknuepft.\r\n     */\r\n    private void createModelParts(ObjectModel objModl) {\r\n        this.createNewHeaderModel(objModl);\r\n        for (int i = 0; i < objModl.getNumberOfAttributes(); i++) {\r\n            if (objModl.isArrayObject()) {\r\n                this.getAttributeModelBuilder().createArrayAttributeModel(objModl);\r\n            } else {\r\n                this.getAttributeModelBuilder().createStandardAttributeModel(objModl);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht davon aus, dass das ObjectModel bereits mit\r\n     * einem Object versehen ist. Erzeugt ein neues HeaderModel und verknuepft\r\n     * es mit dem ObjectModel.\r\n     */\r\n    private void createNewHeaderModel(ObjectModel objModl) {\r\n        objModl.setHeaderModel(new ObjectHeaderModel());\r\n        objModl.getHeaderModel().setObjectModel(objModl);\r\n    }\r\n\r\n    private void createNewListBoxFigure(ObjectModel objModl) {\r\n        this.getListBoxFigureBuilder().createNewListBoxFigure(objModl);\r\n    }\r\n\r\n    private void createNewListBoxFigure(ObjectModel objModl, TextBoxFigure tbf) {\r\n        this.getListBoxFigureBuilder().createNewListBoxFigure(objModl, tbf);\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht davon aus, dass bereits das ExplorerModel\r\n     * mit einer ExplorerFigur verknuepft wurde. Sie erzeugt ein neues\r\n     * ObjectModel und laesst es mit dem ExplorerModel verknuepfen.\r\n     * Anschliessend veranlasst sie, dies auch mit einer neu zu erzeugenden\r\n     * ListBoxFigure zu tun.\r\n     *\r\n     * @param explModl\r\n     *            ExplorerModel\r\n     *\r\n     * @return ObjectModel\r\n     */\r\n    protected ObjectModel createNewObjectModel(ExplorerModel explModl) {\r\n        ObjectModel objModl = new ObjectModel();\r\n        explModl.addObjectModel(objModl);\r\n        objModl.setExplorerModel(explModl);\r\n        this.createNewListBoxFigure(objModl);\r\n        return objModl;\r\n    }\r\n\r\n    /**\r\n     * @param tbf\r\n     *            TextBoxFigure\r\n     *\r\n     * @return ObjectModel\r\n     */\r\n    protected ObjectModel createNewObjectModel(TextBoxFigure tbf) {\r\n        ExplorerModel explModel = ((AttributeModel) tbf.getModel()).getObjectModel().getExplorerModel();\r\n        ObjectModel objModl = new ObjectModel();\r\n        explModel.addObjectModel(objModl);\r\n        objModl.setExplorerModel(explModel);\r\n        this.createNewListBoxFigure(objModl, tbf);\r\n        return objModl;\r\n    }\r\n\r\n    private AttributeModelBuilder getAttributeModelBuilder() {\r\n        return AttributeModelBuilder.getInstance();\r\n    }\r\n\r\n    private ListBoxFigureBuilder getListBoxFigureBuilder() {\r\n        return ListBoxFigureBuilder.getInstance();\r\n    }\r\n\r\n    private void initializeObjectViewManager(ObjectModel objModl) {\r\n        ObjectViewManager objView = objModl.getObjectViewManager();\r\n        objView.setAllAttributesVisible(false);\r\n        objView.setNullAttributesVisible(PropertyManager.getInstance().getHideNullAttribut());\r\n        objView.setStaticAttributesVisible(PropertyManager.getInstance().getHideStaticAttribut());\r\n        objView.setUnexploredAttributesVisible(PropertyManager.getInstance().getHideUnexploredAttribut());\r\n        objView.setAttributesToDisplay(!(objModl.isNullObject()));\r\n    }\r\n\r\n    public void setAttributes(ObjectModel objModl) {\r\n        if (objModl.isArrayObject()) {\r\n            this.getAttributeModelBuilder().setArrayAttributeData(objModl);\r\n        } else {\r\n            this.getAttributeModelBuilder().setStandardAttributeData(objModl);\r\n        }\r\n    }\r\n\r\n    public void setObject(ObjectModel objModl, Object object) {\r\n        objModl.setObject(object);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/model/ObjectModelBuilderTest.java",
		"test_prompt": "// ObjectModelBuilderTest.java\npackage de.paragon.explorer.model;\n\nimport java.util.Vector;\nimport de.paragon.explorer.figure.ListBoxFigureBuilder;\nimport de.paragon.explorer.figure.TextBoxFigure;\nimport de.paragon.explorer.util.ObjectViewManager;\nimport de.paragon.explorer.util.PropertyManager;\nimport de.paragon.explorer.util.StandardEnumeration;\nimport de.paragon.explorer.util.StandardEnumerator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectModelBuilder}.\n* It contains ten unit test cases for the {@link ObjectModelBuilder#getInstance()} method.\n*/\nclass ObjectModelBuilderTest {"
	},
	{
		"original_code": "// ExplorerActionConverter.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.event;\r\n\r\nimport de.paragon.explorer.figure.ExplorerFigure;\r\nimport de.paragon.explorer.figure.ExplorerFigureBuilder;\r\nimport de.paragon.explorer.figure.ListBoxFigure;\r\nimport de.paragon.explorer.figure.ListBoxFigureBuilder;\r\nimport de.paragon.explorer.figure.TextBoxFigure;\r\nimport de.paragon.explorer.model.AttributeModel;\r\nimport de.paragon.explorer.model.ExplorerModelBuilder;\r\nimport de.paragon.explorer.model.ObjectHeaderModel;\r\nimport de.paragon.explorer.model.ObjectModel;\r\nimport de.paragon.explorer.util.ConnectionBuilder;\r\nimport de.paragon.explorer.util.ObjectViewManager;\r\nimport de.paragon.explorer.util.PropertyManager;\r\nimport de.paragon.explorer.util.StandardEnumeration;\r\n\r\n/**\r\n * Kommentar: Diese Klasse empfaengt Explorer-Spezifische Aktionen,die sie vom\r\n * EventConverter erhalten hat. Aufgabe ist es, diese Aktionen an die Builder\r\n * weiterzuleiten.\r\n */\r\npublic class ExplorerActionConverter {\r\n\r\n    private static ExplorerActionConverter singleton;\r\n\r\n    public static ExplorerActionConverter getInstance() {\r\n        return ExplorerActionConverter.getSingleton();\r\n    }\r\n\r\n    private static ExplorerActionConverter getSingleton() {\r\n        if (ExplorerActionConverter.singleton == null) {\r\n            ExplorerActionConverter.setSingleton(new ExplorerActionConverter());\r\n        }\r\n        return ExplorerActionConverter.singleton;\r\n    }\r\n\r\n    private static void setSingleton(ExplorerActionConverter builder) {\r\n        ExplorerActionConverter.singleton = builder;\r\n    }\r\n\r\n    public ExplorerActionConverter() {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * draw bedeutet, dass nur die im Argument angebene Figur gezeichnet wird.\r\n     * draw wird immer dann aufgerufen, wenn sich die Stelle der zu zeich-\r\n     * nenden Figure nicht geaendert hat.\r\n     */\r\n    public void draw(ListBoxFigure liBoFi) {\r\n        this.getExplorerFigureBuilder().draw(liBoFi);\r\n    }\r\n\r\n    private ConnectionBuilder getConnectionBuilder() {\r\n        return ConnectionBuilder.getInstance();\r\n    }\r\n\r\n    private ExplorerFigureBuilder getExplorerFigureBuilder() {\r\n        return ExplorerFigureBuilder.getInstance();\r\n    }\r\n\r\n    private ExplorerModelBuilder getExplorerModelBuilder() {\r\n        return ExplorerModelBuilder.getInstance();\r\n    }\r\n\r\n    private ListBoxFigureBuilder getListBoxFigureBuilder() {\r\n        return ListBoxFigureBuilder.getInstance();\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht davon aus, dass die ueberge- bene\r\n     * TextBoxFigure mit einem AttributeModel verknuepft ist. Anhand der\r\n     * TextBoxFigure werden zunaechst alle existierenden ListBoxFigures\r\n     * ausfindig gemacht. Alle diese werden durchsucht nach dem Object. Dieses\r\n     * wird dann der Rueckgabevariablen zugewiesen. Wird keines gefunden, wird\r\n     * also null zurueck- gegeben.\r\n     */\r\n    private ListBoxFigure getListBoxFigureToShow(TextBoxFigure teBoFi) {\r\n        StandardEnumeration enumeration;\r\n        AttributeModel attrModl = (AttributeModel) teBoFi.getModel();\r\n        ListBoxFigure liBoFiToShow = null;\r\n        ObjectModel tempObjModl;\r\n        enumeration = attrModl.getObjectModel().getExplorerModel().getObjectModels();\r\n        while (enumeration.hasMoreElements()) {\r\n            tempObjModl = (ObjectModel) enumeration.nextElement();\r\n            if (tempObjModl.getObject() == attrModl.getValue()) {\r\n                liBoFiToShow = (ListBoxFigure) tempObjModl.getFigure();\r\n            }\r\n        }\r\n        return liBoFiToShow;\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Eine Figure wird bewegt, wenn -wie bei normalen Fenstern- die\r\n     * linke Maustaste gedrueckt gehalten wird und gleichzeitig verschoben wird.\r\n     * Ist dies geschehen, so gibt der DrawingFrameEventConverter an den\r\n     * ExplorerActionConverter dies weiter. Das weitere Bewegen erfolgt durch\r\n     * den Explorer- FigureBuilder.\r\n     */\r\n    public void moveFigureBy(ListBoxFigure liBoFi, int x, int y) {\r\n        this.getExplorerFigureBuilder().moveFigureBy(liBoFi, x, y);\r\n    }\r\n\r\n    /**\r\n     * Diese Methode loescht eine einzelne Connection. Zunaechst werden die\r\n     * Referenzen auf die Connection von dem AttributeModell und von der Ex-\r\n     * plorerFigure entfernt. Dann werden die Referenzen von den beiden Object-\r\n     * modellen, auf die bzw. von denen eine Referenz dargestellt wird,\r\n     * geloescht.\r\n     */\r\n    private void removeConnection(TextBoxFigure teBoFi) {\r\n        this.getConnectionBuilder().removeSingleConnection((AttributeModel) teBoFi.getModel());\r\n        ListBoxFigure liBoFi = (ListBoxFigure) teBoFi.getParent();\r\n        this.getExplorerFigureBuilder().update((ExplorerFigure) liBoFi.getParent());\r\n    }\r\n\r\n    public void setInForeground(ListBoxFigure liBoFi) {\r\n        this.getExplorerFigureBuilder().setInForeground(liBoFi);\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht so vor: Die Methode setAllAttributesVisible\r\n     * macht folgendes: Zunaechst werden alle AttributeModels auf visible\r\n     * gesetzt. Dann wird die Weite von allen Teilen der ListBoxFigure auf 0\r\n     * (null) gesetzt, und die Orte werden gleich dem Ort der ListBoxFigure\r\n     * gesetzt. Mit allen TeilFiguren, die TextBoxFigure sind, geschieht dann\r\n     * folgendes: Die DisplayBox wird erneut berechnet. Die Be- rechnung der\r\n     * DisplayBox hat zur Folge, dass der Ort der Figure wieder auf 0,0 gesetzt\r\n     * wird. Also wird die TextBoxFigure wieder um die Position der\r\n     * ListBoxFigure verschoben.\r\n     *\r\n     * Nach der Methode setAllAttributesUnvisible sind alle Voraussetzungen\r\n     * geschaffen, um initializeListBoxFigure anzuwenden. Diese Methode setzt\r\n     * alle Weiten auf ein einheit- liches Mass, naemlich das Maximum aller\r\n     * sicht- baren Figuren. Anschliessend werden alle Figuren je nach ihrer\r\n     * Erscheinung (Stelle in der Liste und (Sichtbarkeit) richtig po-\r\n     * sitioniert.\r\n     *\r\n     * Schliesslich wird noch upgedated (oh Gott!), d.h. geloescht und neu\r\n     * gezeichnet.\r\n     */\r\n    // private void setSingleAttributeVisibleOf(TextBoxFigure teBoFi) {\r\n    // ListBoxFigure liBoFi = (ListBoxFigure) teBoFi.getParent();\r\n    // this.getListBoxFigureBuilder().setSingleAttributeVisible(teBoFi);\r\n    // this.getListBoxFigureBuilder().initializeListBoxFigure(liBoFi);\r\n    // this.getExplorerFigureBuilder().update((ExplorerFigure)\r\n    // liBoFi.getParent());\r\n    // }\r\n    // private void showAllReferences(ListBoxFigure liBoFi) {\r\n    // AttributeModel attrModl = null;\r\n    // this.draw(liBoFi);\r\n    // StandardEnumeration attrModls = ((ObjectModel)\r\n    // liBoFi.getModel()).getAttributeModels();\r\n    // while (attrModls.hasMoreElements()) {\r\n    // attrModl = ((de.paragon.explorer.model.AttributeModel)\r\n    // attrModls.nextElement());\r\n    // if (!(attrModl.isAttributePrimitive())) {\r\n    // this.showReferenceFor((TextBoxFigure) attrModl.getFigure());\r\n    // this.setSingleAttributeVisibleOf((TextBoxFigure) attrModl.getFigure());\r\n    // }\r\n    // }\r\n    // }\r\n    // private void showAllReferencesRec(ListBoxFigure liBoFi) {\r\n    // AttributeModel attrModl = null;\r\n    // this.draw(liBoFi);\r\n    // de.paragon.explorer.util.StandardEnumeration attrModls = ((ObjectModel)\r\n    // liBoFi.getModel()).getAttributeModels();\r\n    // while (attrModls.hasMoreElements()) {\r\n    // attrModl = ((de.paragon.explorer.model.AttributeModel)\r\n    // attrModls.nextElement());\r\n    // if (attrModl.getConnectionModel() == null) {\r\n    // this.showReferenceFor((TextBoxFigure) attrModl.getFigure());\r\n    // }\r\n    // }\r\n    // attrModls = ((ObjectModel) liBoFi.getModel()).getAttributeModels();\r\n    // while (attrModls.hasMoreElements()) {\r\n    // attrModl = ((de.paragon.explorer.model.AttributeModel)\r\n    // attrModls.nextElement());\r\n    // if (!attrModl.isAttributePrimitive()) {\r\n    // this.showAllReferencesRec((ListBoxFigure)\r\n    // attrModl.getConnectionModel().getHeaderModel().getObjectModel().getFigure());\r\n    // }\r\n    // }\r\n    // }\r\n    /**\r\n     * Kommentar: Zunaechst wird die zur TextBoxFigure gehoerige ListBoxFigure\r\n     * neu gezeichnet, sodass sie (zunaechst) im Vordergrund erscheint. Darueber\r\n     * kommen nur noch die beiden unten beschriebenen Figuren. Anschliessend\r\n     * wird die zu zeigende ListBoxFigure gesucht, nach vorn gesetzt und\r\n     * gezeichnet. Analog dazu wird der verbindende Pfeil gesucht, nach vorn\r\n     * gesetzt und gezeichnet.\r\n     */\r\n    public void showInForeground(TextBoxFigure teBoFi) {\r\n        this.draw((ListBoxFigure) teBoFi.getParent());\r\n        this.showReferenceFor(teBoFi);\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht davon aus, dass die uebergebene\r\n     * TextBoxFigure eine mit AttributeModel ist. Beim Zeigen einer Referenz ist\r\n     * die Aktion abhaengig von den bereits existierenden Figuren: 1. Die\r\n     * ListBoxFigure fuer das entsprechende Objekt existiert schon; 2. Die\r\n     * entsprechende ListBoxFigure existiert noch nicht. Im ersten Fall wird die\r\n     * Figur nach vorn gesetzt. Danach muessen zwei weitere Moeglichkeiten\r\n     * unterschieden werden: 1.a. Der Referenzpfeil existiert auch schon; 1.b.\r\n     * Der Pfeil existiert nicht. Im Fall a. wird der Pfeil nach vorn gesetzt\r\n     * und gezeichnet. Im Fall b. wird der Pfeil hinzugefuegt und anschliessend\r\n     * nur die Figur und der Pfeil gezeichnet. Im zweiten Fall, falls die Figur\r\n     * nicht da ist, wird die Figur, anschliessend der Pfeil gesetzt. Dann\r\n     * werden nur die Figur und der Pfeil gezeichnet. \"show\" soll bedeuten, dass\r\n     * immer zuerst geguckt wird, ob die entsprechende Figure bereits existiert.\r\n     * Davon ist abhaengig, ob sie gezeichnet wird.\r\n     */\r\n    private void showReferenceFor(TextBoxFigure teBoFi) {\r\n        ListBoxFigure liBoFiToShow = this.getListBoxFigureToShow(teBoFi);\r\n        // Liefert mir die darzustellende ListBoxFigure zurueck\r\n        if (liBoFiToShow == null) {\r\n            // this.getExplorerModelBuilder().handleAttributeModel((de.paragon.explorer.model.AttributeModel)teBoFi.getModel());\r\n            this.getExplorerModelBuilder().handleAttributeModel(teBoFi);\r\n        } else {\r\n            this.getExplorerFigureBuilder().drawInForeground(liBoFiToShow);\r\n            this.getConnectionBuilder().showConnection(teBoFi, liBoFiToShow);\r\n        }\r\n    }\r\n\r\n    public void updateAllAttributesOf(ListBoxFigure liBoFi) {\r\n        // de.paragon.explorer.model.AttributeModel attrModl = null;\r\n        StandardEnumeration attrModls = ((ObjectModel) liBoFi.getModel()).getAttributeModels();\r\n        while (attrModls.hasMoreElements()) {\r\n            this.updateAttribute((AttributeModel) attrModls.nextElement());\r\n        }\r\n        this.updateObject(liBoFi);\r\n    }\r\n\r\n    public void updateAttribute(AttributeModel attrModl) {\r\n        if (!attrModl.isAttributePrimitive()) {\r\n            if (attrModl.getConnectionModel() != null) {\r\n                this.removeConnection((TextBoxFigure) attrModl.getFigure());\r\n                this.showReferenceFor((TextBoxFigure) attrModl.getFigure());\r\n            }\r\n        }\r\n    }\r\n\r\n    public void updateObject(ListBoxFigure liBoFi) {\r\n        this.getListBoxFigureBuilder().updateObject(liBoFi);\r\n        this.getListBoxFigureBuilder().initializeListBoxFigure(liBoFi);\r\n        this.getExplorerFigureBuilder().update((ExplorerFigure) liBoFi.getParent());\r\n    }\r\n\r\n    public void saveAttribute(ObjectHeaderModel newModel) {\r\n        //\r\n        if (newModel != null) {\r\n            ObjectModel objectModel = newModel.getObjectModel();\r\n            if (objectModel != null) {\r\n                ObjectViewManager objectViewManager = objectModel.getObjectViewManager();\r\n                if (objectViewManager != null) {\r\n                    boolean newValueHideNull = objectViewManager.isNullAttributesVisible();\r\n                    boolean newValueHideStatic = objectViewManager.isStaticAttributesVisible();\r\n                    boolean newValueHideUnexplored = objectViewManager.isUnexploredAttributesVisible();\r\n                    PropertyManager.getInstance().setHideAttributes(newValueHideNull, newValueHideStatic, newValueHideUnexplored);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/event/ExplorerActionConverterTest.java",
		"test_prompt": "// ExplorerActionConverterTest.java\npackage de.paragon.explorer.event;\n\nimport de.paragon.explorer.figure.ExplorerFigure;\nimport de.paragon.explorer.figure.ExplorerFigureBuilder;\nimport de.paragon.explorer.figure.ListBoxFigure;\nimport de.paragon.explorer.figure.ListBoxFigureBuilder;\nimport de.paragon.explorer.figure.TextBoxFigure;\nimport de.paragon.explorer.model.AttributeModel;\nimport de.paragon.explorer.model.ExplorerModelBuilder;\nimport de.paragon.explorer.model.ObjectHeaderModel;\nimport de.paragon.explorer.model.ObjectModel;\nimport de.paragon.explorer.util.ConnectionBuilder;\nimport de.paragon.explorer.util.ObjectViewManager;\nimport de.paragon.explorer.util.PropertyManager;\nimport de.paragon.explorer.util.StandardEnumeration;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ExplorerActionConverter}.\n* It contains ten unit test cases for the {@link ExplorerActionConverter#getInstance()} method.\n*/\nclass ExplorerActionConverterTest {"
	},
	{
		"original_code": "// ExplorerPopupActionConverter.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.event;\r\n\r\nimport de.paragon.explorer.Explorer;\r\nimport de.paragon.explorer.figure.ExplorerFigure;\r\nimport de.paragon.explorer.figure.ExplorerFigureBuilder;\r\nimport de.paragon.explorer.figure.ListBoxFigure;\r\nimport de.paragon.explorer.figure.ListBoxFigureBuilder;\r\nimport de.paragon.explorer.figure.TextBoxFigure;\r\nimport de.paragon.explorer.model.AttributeModel;\r\nimport de.paragon.explorer.model.ExplorerModelBuilder;\r\nimport de.paragon.explorer.model.ObjectModel;\r\nimport de.paragon.explorer.util.ConnectionBuilder;\r\nimport de.paragon.explorer.util.StandardEnumeration;\r\n\r\n/**\r\n * Kommentar: Diese Klasse ist speziell dafuer da, Popupmenu-Events zu empfangen\r\n * und an die entsprechenden Builder weiterzuleiten.\r\n */\r\npublic class ExplorerPopupActionConverter {\r\n\r\n    private static ExplorerPopupActionConverter singleton;\r\n\r\n    public static ExplorerPopupActionConverter getInstance() {\r\n        return ExplorerPopupActionConverter.getSingleton();\r\n    }\r\n\r\n    private static ExplorerPopupActionConverter getSingleton() {\r\n        if (ExplorerPopupActionConverter.singleton == null) {\r\n            ExplorerPopupActionConverter.setSingleton(new ExplorerPopupActionConverter());\r\n        }\r\n        return ExplorerPopupActionConverter.singleton;\r\n    }\r\n\r\n    private static void setSingleton(ExplorerPopupActionConverter builder) {\r\n        ExplorerPopupActionConverter.singleton = builder;\r\n    }\r\n\r\n    public ExplorerPopupActionConverter() {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode oeffnet einfach einen neuen PARAGON-Explorer\r\n     * fuer das Objekt, das mit dem ObjectModel der ListBoxFigure verbunden ist.\r\n     */\r\n    public void exploreObjectOf(ListBoxFigure liBoFi) {\r\n        Explorer.explore(liBoFi);\r\n    }\r\n\r\n    private ConnectionBuilder getConnectionBuilder() {\r\n        return ConnectionBuilder.getInstance();\r\n    }\r\n\r\n    private ExplorerFigureBuilder getExplorerFigureBuilder() {\r\n        return ExplorerFigureBuilder.getInstance();\r\n    }\r\n\r\n    private ExplorerModelBuilder getExplorerModelBuilder() {\r\n        return ExplorerModelBuilder.getInstance();\r\n    }\r\n\r\n    private ListBoxFigureBuilder getListBoxFigureBuilder() {\r\n        return ListBoxFigureBuilder.getInstance();\r\n    }\r\n\r\n    /**\r\n     * Diese Methode loescht eine einzelne Connection. Zunaechst werden die\r\n     * Referenzen auf die Connection von dem AttributeModell und von der\r\n     * ExplorerFigure entfernt. Dann werden die Referenzen von den beiden\r\n     * Objectmodellen, auf die bzw. von denen eine Referenz dargestellt wird,\r\n     * geloescht.\r\n     */\r\n    public void hideAllReferences(ListBoxFigure liBoFi) {\r\n        AttributeModel attrModl = null;\r\n        StandardEnumeration attrModls = ((ObjectModel) liBoFi.getModel()).getAttributeModels();\r\n        while (attrModls.hasMoreElements()) {\r\n            attrModl = ((AttributeModel) attrModls.nextElement());\r\n            this.removeConnection((TextBoxFigure) attrModl.getFigure());\r\n        }\r\n    }\r\n\r\n    private void initializeListBoxFigureAndUpdateExplorerFigure(ListBoxFigure liBoFi) {\r\n        this.getListBoxFigureBuilder().initializeListBoxFigure(liBoFi);\r\n        this.getExplorerFigureBuilder().update((ExplorerFigure) liBoFi.getParent());\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode setzt die uebergebene ListBoxFigure nach ganz\r\n     * hinten und zeichnet dann alles neu.\r\n     */\r\n    public void placeBehind(ListBoxFigure liBoFi) {\r\n        this.getExplorerFigureBuilder().placeBehind(liBoFi);\r\n        this.getExplorerFigureBuilder().update((ExplorerFigure) liBoFi.getParent());\r\n    }\r\n\r\n    public void removeChildListBoxFigure(ListBoxFigure liBoFi) {\r\n        ObjectModel objModl = (ObjectModel) liBoFi.getModel();\r\n        objModl.getExplorerModel().removeObjectModel(objModl);\r\n        this.getExplorerFigureBuilder().removeFromExplorer((ListBoxFigure) liBoFi.getModel().getFigure());\r\n        this.getConnectionBuilder().removeConnections(objModl);\r\n    }\r\n\r\n    /**\r\n     * Diese Methode loescht eine einzelne Connection. Zunaechst werden die\r\n     * Referenzen auf die Connection von dem AttributeModell und von der\r\n     * ExplorerFigure entfernt. Dann werden die Referenzen von den beiden\r\n     * Objectmodellen, auf die bzw. von denen eine Referenz dargestellt wird,\r\n     * geloescht.\r\n     */\r\n    public void removeConnection(TextBoxFigure teBoFi) {\r\n        this.getConnectionBuilder().removeSingleConnection((AttributeModel) teBoFi.getModel());\r\n        ListBoxFigure liBoFi = (ListBoxFigure) teBoFi.getParent();\r\n        this.getExplorerFigureBuilder().update((ExplorerFigure) liBoFi.getParent());\r\n    }\r\n\r\n    /**\r\n     * Ein ObjectModel wird so geloescht: Zunaechst werden die Referenzen der\r\n     * entsprechenden Containerobjekten auf die ListBoxFigure bzw. das\r\n     * Object-Model geloescht. Dann werden die Referenzen von den obigen\r\n     * Containerobjekten auf die Connections geloescht, ebenso die des\r\n     * AttributeModels und die der Object- Models. Schliesslich wird die\r\n     * Zeichnung geloescht, und es wird neu gezeichnet.\r\n     */\r\n    public void removeListBoxFigure(ListBoxFigure liBoFi) {\r\n        ExplorerFigure tempExplFig = (ExplorerFigure) liBoFi.getParent();\r\n        this.getExplorerModelBuilder().removeFromExplorer((ObjectModel) liBoFi.getModel());\r\n        if (tempExplFig != null) {\r\n            this.getExplorerFigureBuilder().update(tempExplFig);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht so vor: Die Methode\r\n     * setAllAttributesUnvisible macht folgendes: Zunaechst werden alle\r\n     * AttributeModels, die in der ListBoxFigure enthalten sind, auf unvisible\r\n     * gesetzt. Dann wird die Weite von allen Teilen der ListBoxFigure auf 0\r\n     * (null) gesetzt, und die Orte werden gleich dem Ort der ListBoxFigure\r\n     * gesetzt. Mit allen TeilFiguren, die TextBoxFigure sind, geschieht dann\r\n     * folgendes: Die DisplayBox wird erneut berechnet. Die Berechnung der\r\n     * DisplayBox hat zur Folge, dass der Ort der Figure wieder auf 0,0 gesetzt\r\n     * wird. Also wird die TextBoxFigure wieder um die Position der\r\n     * ListBoxFigure verschoben.\r\n     *\r\n     * Nach der Methode setAllAttributesUnvisible sind alle Voraussetzungen\r\n     * geschaffen, um initializeListBoxFigure anzuwenden. Diese Methode setzt\r\n     * alle Weiten auf ein einheit- liches Mass, naemlich das Maximum aller\r\n     * sicht- baren Figuren. Anschliessend werden alle Figuren je nach ihrer\r\n     * Erscheinung (Stelle in der Liste und (Sichtbarkeit) richtig po-\r\n     * sitioniert.\r\n     *\r\n     * Schliesslich wird noch upgedated (oh Gott!), d.h. geloescht und neu\r\n     * gezeichnet.\r\n     */\r\n    public void setAllAttributesUnvisibleOf(ListBoxFigure liBoFi) {\r\n        this.getListBoxFigureBuilder().setAllAttributesUnvisible(liBoFi);\r\n        this.initializeListBoxFigureAndUpdateExplorerFigure(liBoFi);\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht so vor: Die Methode setAllAttributesVisible\r\n     * macht folgendes: Zunaechst werden alle AttributeModels auf visible\r\n     * gesetzt. Dann wird die Weite von allen Teilen der ListBoxFigure auf 0\r\n     * (null) gesetzt, und die Orte werden gleich dem Ort der ListBoxFigure\r\n     * gesetzt. Mit allen TeilFiguren, die TextBoxFigure sind, geschieht dann\r\n     * folgendes: Die DisplayBox wird erneut berechnet. Die Be- rechnung der\r\n     * DisplayBox hat zur Folge, dass der Ort der Figure wieder auf 0,0 gesetzt\r\n     * wird. Also wird die TextBoxFigure wieder um die Position der\r\n     * ListBoxFigure verschoben.\r\n     *\r\n     * Nach der Methode setAllAttributesUnvisible sind alle Voraussetzungen\r\n     * geschaffen, um initializeListBoxFigure anzuwenden. Diese Methode setzt\r\n     * alle Weiten auf ein einheit- liches Mass, naemlich das Maximum aller\r\n     * sicht- baren Figuren. Anschliessend werden alle Figuren je nach ihrer\r\n     * Erscheinung (Stelle in der Liste und (Sichtbarkeit) richtig po-\r\n     * sitioniert.\r\n     *\r\n     * Schliesslich wird noch upgedated (oh Gott!), d.h. geloescht und neu\r\n     * gezeichnet.\r\n     */\r\n    public void setAllAttributesVisibleOf(ListBoxFigure liBoFi) {\r\n        this.getListBoxFigureBuilder().setAllAttributesVisible(liBoFi);\r\n        this.initializeListBoxFigureAndUpdateExplorerFigure(liBoFi);\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht so vor: Die Methode\r\n     * setAllExploredAttributesVisible macht folgendes: Zunaechst werden alle\r\n     * AttributeModels, die in der ListBoxFigure enthalten sind und nicht\r\n     * explored sind,auf unvisible gesetzt. Dann wird die Weite von allen Teilen\r\n     * der ListBoxFigure auf 0 (null) gesetzt, und die Orte werden gleich dem\r\n     * Ort der ListBoxFigure gesetzt. Mit allen TeilFiguren, die TextBoxFigure\r\n     * sind, geschieht dann folgendes: Die DisplayBox wird erneut berechnet. Die\r\n     * Be- rechnung der DisplayBox hat zur Folge, dass der Ort der Figure wieder\r\n     * auf 0,0 gesetzt wird. Also wird die TextBoxFigure wieder um die Position\r\n     * der ListBoxFigure verschoben.\r\n     *\r\n     * Nach der Methode setAllAttributesUnvisible sind alle Voraussetzungen\r\n     * geschaffen, um initializeListBoxFigure anzuwenden. Diese Methode setzt\r\n     * alle Weiten auf ein einheit- liches Mass, naemlich das Maximum aller\r\n     * sicht- baren Figuren. Anschliessend werden alle Figuren je nach ihrer\r\n     * Erscheinung (Stelle in der Liste und (Sichtbarkeit) richtig po-\r\n     * sitioniert.\r\n     *\r\n     * Schliesslich wird noch upgedated (oh Gott!), d.h. geloescht und neu\r\n     * gezeichnet.\r\n     */\r\n    public void setAllUnexploredAttributesUnvisibleOf(ListBoxFigure liBoFi) {\r\n        this.getListBoxFigureBuilder().setAllUnexploredAttributesUnvisible(liBoFi);\r\n        this.initializeListBoxFigureAndUpdateExplorerFigure(liBoFi);\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht so vor: Die Methode\r\n     * setAllExploredAttributesVisible macht folgendes: Zunaechst werden alle\r\n     * AttributeModels, die in der ListBoxFigure enthalten sind und nicht\r\n     * explored sind,auf unvisible gesetzt. Dann wird die Weite von allen Teilen\r\n     * der ListBoxFigure auf 0 (null) gesetzt, und die Orte werden gleich dem\r\n     * Ort der ListBoxFigure gesetzt. Mit allen TeilFiguren, die TextBoxFigure\r\n     * sind, geschieht dann folgendes: Die DisplayBox wird erneut berechnet. Die\r\n     * Be- rechnung der DisplayBox hat zur Folge, dass der Ort der Figure wieder\r\n     * auf 0,0 gesetzt wird. Also wird die TextBoxFigure wieder um die Position\r\n     * der ListBoxFigure verschoben.\r\n     *\r\n     * Nach der Methode setAllAttributesUnvisible sind alle Voraussetzungen\r\n     * geschaffen, um initializeListBoxFigure anzuwenden. Diese Methode setzt\r\n     * alle Weiten auf ein einheit- liches Mass, naemlich das Maximum aller\r\n     * sicht- baren Figuren. Anschliessend werden alle Figuren je nach ihrer\r\n     * Erscheinung (Stelle in der Liste und (Sichtbarkeit) richtig po-\r\n     * sitioniert.\r\n     *\r\n     * Schliesslich wird noch upgedated (oh Gott!), d.h. geloescht und neu\r\n     * gezeichnet.\r\n     */\r\n    public void setAllUnexploredAttributesVisibleOf(ListBoxFigure liBoFi) {\r\n        this.getListBoxFigureBuilder().setAllUnexploredAttributesVisible(liBoFi);\r\n        this.initializeListBoxFigureAndUpdateExplorerFigure(liBoFi);\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht so vor: Die Methode\r\n     * setAllAttributesUnvisible macht folgendes: Zunaechst werden alle\r\n     * AttributeModels, die in der ListBoxFigure enthalten sind und keinen Wert\r\n     * null haben, auf unvisible gesetzt. Dann wird die Weite von allen Teilen\r\n     * der ListBoxFigure auf 0 (null) gesetzt, und die Orte werden gleich dem\r\n     * Ort der ListBoxFigure gesetzt. Mit allen TeilFiguren, die TextBoxFigure\r\n     * sind, geschieht dann folgendes: Die DisplayBox wird erneut berechnet. Die\r\n     * Be- rechnung der DisplayBox hat zur Folge, dass der Ort der Figure wieder\r\n     * auf 0,0 gesetzt wird. Also wird die TextBoxFigure wieder um die Position\r\n     * der ListBoxFigure verschoben.\r\n     *\r\n     * Nach der Methode setAllAttributesUnvisible sind alle Voraussetzungen\r\n     * geschaffen, um initializeListBoxFigure anzuwenden. Diese Methode setzt\r\n     * alle Weiten auf ein einheit- liches Mass, naemlich das Maximum aller\r\n     * sicht- baren Figuren. Anschliessend werden alle Figuren je nach ihrer\r\n     * Erscheinung (Stelle in der Liste und (Sichtbarkeit) richtig po-\r\n     * sitioniert.\r\n     *\r\n     * Schliesslich wird noch upgedated (oh Gott!), d.h. geloescht und neu\r\n     * gezeichnet.\r\n     */\r\n    public void setNullAttributesUnvisibleOf(ListBoxFigure liBoFi) {\r\n        this.getListBoxFigureBuilder().setNullAttributesUnvisible(liBoFi);\r\n        this.initializeListBoxFigureAndUpdateExplorerFigure(liBoFi);\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht so vor: Die Methode\r\n     * setAllAttributesUnvisible macht folgendes: Zunaechst werden alle\r\n     * AttributeModels, die in der ListBoxFigure enthalten sind und keinen Wert\r\n     * null haben, auf unvisible gesetzt. Dann wird die Weite von allen Teilen\r\n     * der ListBoxFigure auf 0 (null) gesetzt, und die Orte werden gleich dem\r\n     * Ort der ListBoxFigure gesetzt. Mit allen TeilFiguren, die TextBoxFigure\r\n     * sind, geschieht dann folgendes: Die DisplayBox wird erneut berechnet. Die\r\n     * Be- rechnung der DisplayBox hat zur Folge, dass der Ort der Figure wieder\r\n     * auf 0,0 gesetzt wird. Also wird die TextBoxFigure wieder um die Position\r\n     * der ListBoxFigure verschoben.\r\n     *\r\n     * Nach der Methode setAllAttributesUnvisible sind alle Voraussetzungen\r\n     * geschaffen, um initializeListBoxFigure anzuwenden. Diese Methode setzt\r\n     * alle Weiten auf ein einheit- liches Mass, naemlich das Maximum aller\r\n     * sicht- baren Figuren. Anschliessend werden alle Figuren je nach ihrer\r\n     * Erscheinung (Stelle in der Liste und (Sichtbarkeit) richtig po-\r\n     * sitioniert.\r\n     *\r\n     * Schliesslich wird noch upgedated (oh Gott!), d.h. geloescht und neu\r\n     * gezeichnet.\r\n     */\r\n    public void setNullAttributesVisibleOf(ListBoxFigure liBoFi) {\r\n        this.getListBoxFigureBuilder().setNullAttributesVisible(liBoFi);\r\n        this.initializeListBoxFigureAndUpdateExplorerFigure(liBoFi);\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht so vor: Die Methode\r\n     * setSingleAttributesUnvisible macht folgendes: Zunaechst wird das\r\n     * AttributeModel, das mit der TextBoxFigure verknuepft ist, auf unvisible\r\n     * gesetzt. Dann wird die Weite von allen Teilen der ListBoxFigure auf 0\r\n     * (null) gesetzt, und die Orte werden gleich dem Ort der ListBoxFigure\r\n     * gesetzt. Mit allen TeilFiguren, die TextBoxFigure sind, geschieht dann\r\n     * folgendes: Die DisplayBox wird erneut berechnet. Die Be- rechnung der\r\n     * DisplayBox hat zur Folge, dass der Ort der Figure wieder auf 0,0 gesetzt\r\n     * wird. Also wird die TextBoxFigure wieder um die Position der\r\n     * ListBoxFigure verschoben.\r\n     *\r\n     * Nach der Methode setAllAttributesUnvisible sind alle Voraussetzungen\r\n     * geschaffen, um initializeListBoxFigure anzuwenden. Diese Methode setzt\r\n     * alle Weiten auf ein einheit- liches Mass, naemlich das Maximum aller\r\n     * sicht- baren Figuren. Anschliessend werden alle Figuren je nach ihrer\r\n     * Erscheinung (Stelle in der Liste und (Sichtbarkeit) richtig po-\r\n     * sitioniert.\r\n     *\r\n     * Schliesslich wird noch upgedated (oh Gott!), d.h. geloescht und neu\r\n     * gezeichnet.\r\n     */\r\n    public void setSingleAttributeUnvisibleOf(TextBoxFigure teBoFi) {\r\n        ListBoxFigure liBoFi = (ListBoxFigure) teBoFi.getParent();\r\n        this.getListBoxFigureBuilder().setSingleAttributeUnvisible(teBoFi);\r\n        this.initializeListBoxFigureAndUpdateExplorerFigure(liBoFi);\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht so vor: Die Methode\r\n     * setAllAttributesUnvisible macht folgendes: Zunaechst werden alle\r\n     * AttributeModels, die in der ListBoxFigure enthalten sind und keinen Wert\r\n     * null haben, auf unvisible gesetzt. Dann wird die Weite von allen Teilen\r\n     * der ListBoxFigure auf 0 (null) gesetzt, und die Orte werden gleich dem\r\n     * Ort der ListBoxFigure gesetzt. Mit allen TeilFiguren, die TextBoxFigure\r\n     * sind, geschieht dann folgendes: Die DisplayBox wird erneut berechnet. Die\r\n     * Be- rechnung der DisplayBox hat zur Folge, dass der Ort der Figure wieder\r\n     * auf 0,0 gesetzt wird. Also wird die TextBoxFigure wieder um die Position\r\n     * der ListBoxFigure verschoben.\r\n     *\r\n     * Nach der Methode setAllAttributesUnvisible sind alle Voraussetzungen\r\n     * geschaffen, um initializeListBoxFigure anzuwenden. Diese Methode setzt\r\n     * alle Weiten auf ein einheit- liches Mass, naemlich das Maximum aller\r\n     * sicht- baren Figuren. Anschliessend werden alle Figuren je nach ihrer\r\n     * Erscheinung (Stelle in der Liste und (Sichtbarkeit) richtig po-\r\n     * sitioniert.\r\n     *\r\n     * Schliesslich wird noch upgedated (oh Gott!), d.h. geloescht und neu\r\n     * gezeichnet.\r\n     */\r\n    public void setStaticAttributesUnvisibleOf(ListBoxFigure liBoFi) {\r\n        this.getListBoxFigureBuilder().setStaticAttributesUnvisible(liBoFi);\r\n        this.initializeListBoxFigureAndUpdateExplorerFigure(liBoFi);\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht so vor: Die Methode\r\n     * setAllAttributesUnvisible macht folgendes: Zunaechst werden alle\r\n     * AttributeModels, die in der ListBoxFigure enthalten sind und keinen Wert\r\n     * null haben, auf unvisible gesetzt. Dann wird die Weite von allen Teilen\r\n     * der ListBoxFigure auf 0 (null) gesetzt, und die Orte werden gleich dem\r\n     * Ort der ListBoxFigure gesetzt. Mit allen TeilFiguren, die TextBoxFigure\r\n     * sind, geschieht dann folgendes: Die DisplayBox wird erneut berechnet. Die\r\n     * Be- rechnung der DisplayBox hat zur Folge, dass der Ort der Figure wieder\r\n     * auf 0,0 gesetzt wird. Also wird die TextBoxFigure wieder um die Position\r\n     * der ListBoxFigure verschoben.\r\n     *\r\n     * Nach der Methode setAllAttributesUnvisible sind alle Voraussetzungen\r\n     * geschaffen, um initializeListBoxFigure anzuwenden. Diese Methode setzt\r\n     * alle Weiten auf ein einheit- liches Mass, naemlich das Maximum aller\r\n     * sicht- baren Figuren. Anschliessend werden alle Figuren je nach ihrer\r\n     * Erscheinung (Stelle in der Liste und (Sichtbarkeit) richtig po-\r\n     * sitioniert.\r\n     *\r\n     * Schliesslich wird noch upgedated (oh Gott!), d.h. geloescht und neu\r\n     * gezeichnet.\r\n     */\r\n    public void setStaticAttributesVisibleOf(ListBoxFigure liBoFi) {\r\n        this.getListBoxFigureBuilder().setStaticAttributesVisible(liBoFi);\r\n        this.initializeListBoxFigureAndUpdateExplorerFigure(liBoFi);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/event/ExplorerPopupActionConverterTest.java",
		"test_prompt": "// ExplorerPopupActionConverterTest.java\npackage de.paragon.explorer.event;\n\nimport de.paragon.explorer.Explorer;\nimport de.paragon.explorer.figure.ExplorerFigure;\nimport de.paragon.explorer.figure.ExplorerFigureBuilder;\nimport de.paragon.explorer.figure.ListBoxFigure;\nimport de.paragon.explorer.figure.ListBoxFigureBuilder;\nimport de.paragon.explorer.figure.TextBoxFigure;\nimport de.paragon.explorer.model.AttributeModel;\nimport de.paragon.explorer.model.ExplorerModelBuilder;\nimport de.paragon.explorer.model.ObjectModel;\nimport de.paragon.explorer.util.ConnectionBuilder;\nimport de.paragon.explorer.util.StandardEnumeration;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ExplorerPopupActionConverter}.\n* It contains ten unit test cases for the {@link ExplorerPopupActionConverter#getInstance()} method.\n*/\nclass ExplorerPopupActionConverterTest {"
	}
]