[
	{
		"original_code": "// Axis.java\n/*\r\n * $Header: /cvsroot/saxpath/saxpath/src/java/main/org/saxpath/Axis.java,v 1.11 2002/04/26 17:05:34 jstrachan Exp $\r\n * $Revision: 1.11 $\r\n * $Date: 2002/04/26 17:05:34 $\r\n *\r\n * ====================================================================\r\n *\r\n * Copyright (C) 2000-2002 werken digital.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions\r\n * are met:\r\n * \r\n * 1. Redistributions of source code must retain the above copyright\r\n *    notice, this list of conditions, and the following disclaimer.\r\n *\r\n * 2. Redistributions in binary form must reproduce the above copyright\r\n *    notice, this list of conditions, and the disclaimer that follows \r\n *    these conditions in the documentation and/or other materials \r\n *    provided with the distribution.\r\n *\r\n * 3. The name \"SAXPath\" must not be used to endorse or promote products\r\n *    derived from this software without prior written permission.  For\r\n *    written permission, please contact license@saxpath.org.\r\n * \r\n * 4. Products derived from this software may not be called \"SAXPath\", nor\r\n *    may \"SAXPath\" appear in their name, without prior written permission\r\n *    from the SAXPath Project Management (pm@saxpath.org).\r\n * \r\n * In addition, we request (but do not require) that you include in the \r\n * end-user documentation provided with the redistribution and/or in the \r\n * software itself an acknowledgement equivalent to the following:\r\n *     \"This product includes software developed by the\r\n *      SAXPath Project (http://www.saxpath.org/).\"\r\n * Alternatively, the acknowledgment may be graphical using the logos \r\n * available at http://www.saxpath.org/\r\n *\r\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\r\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\r\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED.  IN NO EVENT SHALL THE SAXPath AUTHORS OR THE PROJECT\r\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\r\n * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\r\n * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\r\n * SUCH DAMAGE.\r\n *\r\n * ====================================================================\r\n * This software consists of voluntary contributions made by many \r\n * individuals on behalf of the SAXPath Project and was originally \r\n * created by bob mcwhirter <bob@werken.com> and \r\n * James Strachan <jstrachan@apache.org>.  For more information on the \r\n * SAXPath Project, please see <http://www.saxpath.org/>.\r\n * \r\n * $Id: Axis.java,v 1.11 2002/04/26 17:05:34 jstrachan Exp $\r\n */\r\npackage org.saxpath;\r\n\r\nimport java.util.Map;\r\nimport java.util.HashMap;\r\n\r\npublic class Axis {\r\n\r\n    /**\r\n     * Marker for an invalid axis\r\n     */\r\n    public final static int INVALID_AXIS = 0;\r\n\r\n    /**\r\n     * The <code>child</code> axis\r\n     */\r\n    public final static int CHILD = 1;\r\n\r\n    /**\r\n     * The <code>descendant</code> axis\r\n     */\r\n    public final static int DESCENDANT = 2;\r\n\r\n    /**\r\n     * The <code>parent</code> axis\r\n     */\r\n    public final static int PARENT = 3;\r\n\r\n    /**\r\n     * The <code>ancestor</code> axis\r\n     */\r\n    public final static int ANCESTOR = 4;\r\n\r\n    /**\r\n     * The <code>following-sibling</code> axis\r\n     */\r\n    public final static int FOLLOWING_SIBLING = 5;\r\n\r\n    /**\r\n     * The <code>preceding-sibling</code> axis\r\n     */\r\n    public final static int PRECEDING_SIBLING = 6;\r\n\r\n    /**\r\n     * The <code>following</code> axis\r\n     */\r\n    public final static int FOLLOWING = 7;\r\n\r\n    /**\r\n     * The <code>preceding</code> axis\r\n     */\r\n    public final static int PRECEDING = 8;\r\n\r\n    /**\r\n     * The <code>attribute</code> axis\r\n     */\r\n    public final static int ATTRIBUTE = 9;\r\n\r\n    /**\r\n     * The <code>namespace</code> axis\r\n     */\r\n    public final static int NAMESPACE = 10;\r\n\r\n    /**\r\n     * The <code>self</code> axis\r\n     */\r\n    public final static int SELF = 11;\r\n\r\n    /**\r\n     * The <code>descendant-or-self</code> axis\r\n     */\r\n    public final static int DESCENDANT_OR_SELF = 12;\r\n\r\n    /**\r\n     * The <code>ancestor-or-self</code> axis\r\n     */\r\n    public final static int ANCESTOR_OR_SELF = 13;\r\n\r\n    public static String lookup(int axisNum) {\r\n        switch(axisNum) {\r\n            case CHILD:\r\n                return \"child\";\r\n            case DESCENDANT:\r\n                return \"descendant\";\r\n            case PARENT:\r\n                return \"parent\";\r\n            case ANCESTOR:\r\n                return \"ancestor\";\r\n            case FOLLOWING_SIBLING:\r\n                return \"following-sibling\";\r\n            case PRECEDING_SIBLING:\r\n                return \"preceding-sibling\";\r\n            case FOLLOWING:\r\n                return \"following\";\r\n            case PRECEDING:\r\n                return \"preceding\";\r\n            case ATTRIBUTE:\r\n                return \"attribute\";\r\n            case NAMESPACE:\r\n                return \"namespace\";\r\n            case SELF:\r\n                return \"self\";\r\n            case DESCENDANT_OR_SELF:\r\n                return \"descendant-or-self\";\r\n            case ANCESTOR_OR_SELF:\r\n                return \"ancestor-or-self\";\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public static int lookup(String axisName) {\r\n        if (\"child\".equals(axisName)) {\r\n            return CHILD;\r\n        }\r\n        if (\"descendant\".equals(axisName)) {\r\n            return DESCENDANT;\r\n        }\r\n        if (\"parent\".equals(axisName)) {\r\n            return PARENT;\r\n        }\r\n        if (\"ancestor\".equals(axisName)) {\r\n            return ANCESTOR;\r\n        }\r\n        if (\"following-sibling\".equals(axisName)) {\r\n            return FOLLOWING_SIBLING;\r\n        }\r\n        if (\"preceding-sibling\".equals(axisName)) {\r\n            return PRECEDING_SIBLING;\r\n        }\r\n        if (\"following\".equals(axisName)) {\r\n            return FOLLOWING;\r\n        }\r\n        if (\"preceding\".equals(axisName)) {\r\n            return PRECEDING;\r\n        }\r\n        if (\"attribute\".equals(axisName)) {\r\n            return ATTRIBUTE;\r\n        }\r\n        if (\"namespace\".equals(axisName)) {\r\n            return NAMESPACE;\r\n        }\r\n        if (\"self\".equals(axisName)) {\r\n            return SELF;\r\n        }\r\n        if (\"descendant-or-self\".equals(axisName)) {\r\n            return DESCENDANT_OR_SELF;\r\n        }\r\n        if (\"ancestor-or-self\".equals(axisName)) {\r\n            return ANCESTOR_OR_SELF;\r\n        }\r\n        return INVALID_AXIS;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/24_saxpath/src/main/java/saxpath/AxisTest0.java",
		"test_prompt": "// AxisTest0.java\npackage org.saxpath;\n\nimport java.util.Map;\nimport java.util.HashMap;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Axis}.\n* It contains ten unit test cases for the {@link Axis#lookup(int)} method.\n*/\nclass AxisTest0 {"
	},
	{
		"original_code": "// Axis.java\n/*\r\n * $Header: /cvsroot/saxpath/saxpath/src/java/main/org/saxpath/Axis.java,v 1.11 2002/04/26 17:05:34 jstrachan Exp $\r\n * $Revision: 1.11 $\r\n * $Date: 2002/04/26 17:05:34 $\r\n *\r\n * ====================================================================\r\n *\r\n * Copyright (C) 2000-2002 werken digital.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions\r\n * are met:\r\n * \r\n * 1. Redistributions of source code must retain the above copyright\r\n *    notice, this list of conditions, and the following disclaimer.\r\n *\r\n * 2. Redistributions in binary form must reproduce the above copyright\r\n *    notice, this list of conditions, and the disclaimer that follows \r\n *    these conditions in the documentation and/or other materials \r\n *    provided with the distribution.\r\n *\r\n * 3. The name \"SAXPath\" must not be used to endorse or promote products\r\n *    derived from this software without prior written permission.  For\r\n *    written permission, please contact license@saxpath.org.\r\n * \r\n * 4. Products derived from this software may not be called \"SAXPath\", nor\r\n *    may \"SAXPath\" appear in their name, without prior written permission\r\n *    from the SAXPath Project Management (pm@saxpath.org).\r\n * \r\n * In addition, we request (but do not require) that you include in the \r\n * end-user documentation provided with the redistribution and/or in the \r\n * software itself an acknowledgement equivalent to the following:\r\n *     \"This product includes software developed by the\r\n *      SAXPath Project (http://www.saxpath.org/).\"\r\n * Alternatively, the acknowledgment may be graphical using the logos \r\n * available at http://www.saxpath.org/\r\n *\r\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\r\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\r\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED.  IN NO EVENT SHALL THE SAXPath AUTHORS OR THE PROJECT\r\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\r\n * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\r\n * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\r\n * SUCH DAMAGE.\r\n *\r\n * ====================================================================\r\n * This software consists of voluntary contributions made by many \r\n * individuals on behalf of the SAXPath Project and was originally \r\n * created by bob mcwhirter <bob@werken.com> and \r\n * James Strachan <jstrachan@apache.org>.  For more information on the \r\n * SAXPath Project, please see <http://www.saxpath.org/>.\r\n * \r\n * $Id: Axis.java,v 1.11 2002/04/26 17:05:34 jstrachan Exp $\r\n */\r\npackage org.saxpath;\r\n\r\nimport java.util.Map;\r\nimport java.util.HashMap;\r\n\r\npublic class Axis {\r\n\r\n    /**\r\n     * Marker for an invalid axis\r\n     */\r\n    public final static int INVALID_AXIS = 0;\r\n\r\n    /**\r\n     * The <code>child</code> axis\r\n     */\r\n    public final static int CHILD = 1;\r\n\r\n    /**\r\n     * The <code>descendant</code> axis\r\n     */\r\n    public final static int DESCENDANT = 2;\r\n\r\n    /**\r\n     * The <code>parent</code> axis\r\n     */\r\n    public final static int PARENT = 3;\r\n\r\n    /**\r\n     * The <code>ancestor</code> axis\r\n     */\r\n    public final static int ANCESTOR = 4;\r\n\r\n    /**\r\n     * The <code>following-sibling</code> axis\r\n     */\r\n    public final static int FOLLOWING_SIBLING = 5;\r\n\r\n    /**\r\n     * The <code>preceding-sibling</code> axis\r\n     */\r\n    public final static int PRECEDING_SIBLING = 6;\r\n\r\n    /**\r\n     * The <code>following</code> axis\r\n     */\r\n    public final static int FOLLOWING = 7;\r\n\r\n    /**\r\n     * The <code>preceding</code> axis\r\n     */\r\n    public final static int PRECEDING = 8;\r\n\r\n    /**\r\n     * The <code>attribute</code> axis\r\n     */\r\n    public final static int ATTRIBUTE = 9;\r\n\r\n    /**\r\n     * The <code>namespace</code> axis\r\n     */\r\n    public final static int NAMESPACE = 10;\r\n\r\n    /**\r\n     * The <code>self</code> axis\r\n     */\r\n    public final static int SELF = 11;\r\n\r\n    /**\r\n     * The <code>descendant-or-self</code> axis\r\n     */\r\n    public final static int DESCENDANT_OR_SELF = 12;\r\n\r\n    /**\r\n     * The <code>ancestor-or-self</code> axis\r\n     */\r\n    public final static int ANCESTOR_OR_SELF = 13;\r\n\r\n    public static String lookup(int axisNum) {\r\n        switch(axisNum) {\r\n            case CHILD:\r\n                return \"child\";\r\n            case DESCENDANT:\r\n                return \"descendant\";\r\n            case PARENT:\r\n                return \"parent\";\r\n            case ANCESTOR:\r\n                return \"ancestor\";\r\n            case FOLLOWING_SIBLING:\r\n                return \"following-sibling\";\r\n            case PRECEDING_SIBLING:\r\n                return \"preceding-sibling\";\r\n            case FOLLOWING:\r\n                return \"following\";\r\n            case PRECEDING:\r\n                return \"preceding\";\r\n            case ATTRIBUTE:\r\n                return \"attribute\";\r\n            case NAMESPACE:\r\n                return \"namespace\";\r\n            case SELF:\r\n                return \"self\";\r\n            case DESCENDANT_OR_SELF:\r\n                return \"descendant-or-self\";\r\n            case ANCESTOR_OR_SELF:\r\n                return \"ancestor-or-self\";\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public static int lookup(String axisName) {\r\n        if (\"child\".equals(axisName)) {\r\n            return CHILD;\r\n        }\r\n        if (\"descendant\".equals(axisName)) {\r\n            return DESCENDANT;\r\n        }\r\n        if (\"parent\".equals(axisName)) {\r\n            return PARENT;\r\n        }\r\n        if (\"ancestor\".equals(axisName)) {\r\n            return ANCESTOR;\r\n        }\r\n        if (\"following-sibling\".equals(axisName)) {\r\n            return FOLLOWING_SIBLING;\r\n        }\r\n        if (\"preceding-sibling\".equals(axisName)) {\r\n            return PRECEDING_SIBLING;\r\n        }\r\n        if (\"following\".equals(axisName)) {\r\n            return FOLLOWING;\r\n        }\r\n        if (\"preceding\".equals(axisName)) {\r\n            return PRECEDING;\r\n        }\r\n        if (\"attribute\".equals(axisName)) {\r\n            return ATTRIBUTE;\r\n        }\r\n        if (\"namespace\".equals(axisName)) {\r\n            return NAMESPACE;\r\n        }\r\n        if (\"self\".equals(axisName)) {\r\n            return SELF;\r\n        }\r\n        if (\"descendant-or-self\".equals(axisName)) {\r\n            return DESCENDANT_OR_SELF;\r\n        }\r\n        if (\"ancestor-or-self\".equals(axisName)) {\r\n            return ANCESTOR_OR_SELF;\r\n        }\r\n        return INVALID_AXIS;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/24_saxpath/src/main/java/saxpath/AxisTest1.java",
		"test_prompt": "// AxisTest1.java\npackage org.saxpath;\n\nimport java.util.Map;\nimport java.util.HashMap;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Axis}.\n* It contains ten unit test cases for the {@link Axis#lookup(String)} method.\n*/\nclass AxisTest1 {"
	},
	{
		"original_code": "// XPathReaderFactory.java\n/*\r\n * $Header: /cvsroot/saxpath/saxpath/src/java/main/org/saxpath/helpers/XPathReaderFactory.java,v 1.7 2002/04/26 17:05:34 jstrachan Exp $\r\n * $Revision: 1.7 $\r\n * $Date: 2002/04/26 17:05:34 $\r\n *\r\n * ====================================================================\r\n *\r\n * Copyright (C) 2000-2002 werken digital.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions\r\n * are met:\r\n * \r\n * 1. Redistributions of source code must retain the above copyright\r\n *    notice, this list of conditions, and the following disclaimer.\r\n *\r\n * 2. Redistributions in binary form must reproduce the above copyright\r\n *    notice, this list of conditions, and the disclaimer that follows \r\n *    these conditions in the documentation and/or other materials \r\n *    provided with the distribution.\r\n *\r\n * 3. The name \"SAXPath\" must not be used to endorse or promote products\r\n *    derived from this software without prior written permission.  For\r\n *    written permission, please contact license@saxpath.org.\r\n * \r\n * 4. Products derived from this software may not be called \"SAXPath\", nor\r\n *    may \"SAXPath\" appear in their name, without prior written permission\r\n *    from the SAXPath Project Management (pm@saxpath.org).\r\n * \r\n * In addition, we request (but do not require) that you include in the \r\n * end-user documentation provided with the redistribution and/or in the \r\n * software itself an acknowledgement equivalent to the following:\r\n *     \"This product includes software developed by the\r\n *      SAXPath Project (http://www.saxpath.org/).\"\r\n * Alternatively, the acknowledgment may be graphical using the logos \r\n * available at http://www.saxpath.org/\r\n *\r\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\r\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\r\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED.  IN NO EVENT SHALL THE SAXPath AUTHORS OR THE PROJECT\r\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\r\n * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\r\n * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\r\n * SUCH DAMAGE.\r\n *\r\n * ====================================================================\r\n * This software consists of voluntary contributions made by many \r\n * individuals on behalf of the SAXPath Project and was originally \r\n * created by bob mcwhirter <bob@werken.com> and \r\n * James Strachan <jstrachan@apache.org>.  For more information on the \r\n * SAXPath Project, please see <http://www.saxpath.org/>.\r\n * \r\n * $Id: XPathReaderFactory.java,v 1.7 2002/04/26 17:05:34 jstrachan Exp $\r\n */\r\npackage org.saxpath.helpers;\r\n\r\nimport org.saxpath.XPathReader;\r\nimport org.saxpath.SAXPathException;\r\n\r\n/**\r\n * Create an {@link org.saxpath.XPathReader} from\r\n *  either a system property, or a named class.\r\n *\r\n *  <p>\r\n *  Similar to the SAX API, the <code>XPathReaderFactory</code>\r\n *  can create an <code>XPathReader</code> from a name of a\r\n *  class passed in directly, or by inspecting the system\r\n *  property <code>org.saxpath.driver</code>.\r\n *\r\n *  @author bob mcwhirter (bob@werken.com)\r\n */\r\npublic class XPathReaderFactory {\r\n\r\n    /**\r\n     * The <code>org.saxpath.driver</code> property name.\r\n     */\r\n    public static final String DRIVER_PROPERTY = \"org.saxpath.driver\";\r\n\r\n    /**\r\n     * The default driver to use if none is configured.\r\n     */\r\n    protected static final String DEFAULT_DRIVER = \"com.werken.saxpath.XPathReader\";\r\n\r\n    /**\r\n     * Should the default driver be used\r\n     */\r\n    private static boolean USE_DEFAULT = true;\r\n\r\n    /**\r\n     * Create an <code>XPathReader</code> using the value of\r\n     *  the <code>org.saxpath.driver</code> system property.\r\n     *\r\n     *  @return An instance of the <code>XPathReader</code> specified\r\n     *          by the <code>org.saxpath.driver</code> property.\r\n     *\r\n     *  @throws SAXPathException if the property is unset, or if\r\n     *          the class can not be instantiated for some reason.,\r\n     *          or if the class doesn't implement the <code>XPathReader</code>\r\n     *          interface.\r\n     */\r\n    public static XPathReader createReader() throws SAXPathException {\r\n        String className = null;\r\n        boolean securityException = false;\r\n        try {\r\n            className = System.getProperty(DRIVER_PROPERTY);\r\n        } catch (SecurityException e) {\r\n            securityException = true;\r\n        }\r\n        if (className == null || \"\".equals(className)) {\r\n            if (USE_DEFAULT) {\r\n                className = DEFAULT_DRIVER;\r\n            } else {\r\n                if (securityException) {\r\n                    throw new SAXPathException(\"Reading of property \" + DRIVER_PROPERTY + \" disallowed.\");\r\n                } else {\r\n                    throw new SAXPathException(\"Property \" + DRIVER_PROPERTY + \" not set\");\r\n                }\r\n            }\r\n        }\r\n        return createReader(className);\r\n    }\r\n\r\n    /**\r\n     * Create an <code>XPathReader</code> using the passed\r\n     *  in class name.\r\n     *\r\n     *  @param className The name of the class which implements\r\n     *         the <code>XPathReader</code> interface.\r\n     *\r\n     *  @throws SAXPathException if the class can not be\r\n     *          instantiated for some reason, or if the\r\n     *          class doesn't implement the <code>XPathReader</code>\r\n     *          interface.\r\n     */\r\n    public static XPathReader createReader(String className) throws SAXPathException {\r\n        Class readerClass = null;\r\n        XPathReader reader = null;\r\n        try {\r\n            // Use the full version of Class.forName(), so as to\r\n            // work better in sandboxed environments, such as\r\n            // Servlet contains, and Applets.\r\n            readerClass = Class.forName(className, true, XPathReaderFactory.class.getClassLoader());\r\n            // Double-check that it's actually the right kind of class\r\n            // before attempting instantiation.\r\n            if (!XPathReader.class.isAssignableFrom(readerClass)) {\r\n                throw new SAXPathException(\"Class [\" + className + \"] does not implement the org.saxpath.XPathReader interface.\");\r\n            }\r\n        } catch (ClassNotFoundException e) {\r\n            throw new SAXPathException(e.getMessage());\r\n        }\r\n        try {\r\n            reader = (XPathReader) readerClass.newInstance();\r\n        } catch (IllegalAccessException e) {\r\n            throw new SAXPathException(e.getMessage());\r\n        } catch (InstantiationException e) {\r\n            throw new SAXPathException(e.getMessage());\r\n        }\r\n        if (reader == null) {\r\n            throw new SAXPathException(\"Unable to create XPathReader\");\r\n        }\r\n        return reader;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/24_saxpath/src/main/java/saxpath/helpers/XPathReaderFactoryTest0.java",
		"test_prompt": "// XPathReaderFactoryTest0.java\npackage org.saxpath.helpers;\n\nimport org.saxpath.XPathReader;\nimport org.saxpath.SAXPathException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XPathReaderFactory}.\n* It contains ten unit test cases for the {@link XPathReaderFactory#createReader()} method.\n*/\nclass XPathReaderFactoryTest0 {"
	},
	{
		"original_code": "// XPathReaderFactory.java\n/*\r\n * $Header: /cvsroot/saxpath/saxpath/src/java/main/org/saxpath/helpers/XPathReaderFactory.java,v 1.7 2002/04/26 17:05:34 jstrachan Exp $\r\n * $Revision: 1.7 $\r\n * $Date: 2002/04/26 17:05:34 $\r\n *\r\n * ====================================================================\r\n *\r\n * Copyright (C) 2000-2002 werken digital.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions\r\n * are met:\r\n * \r\n * 1. Redistributions of source code must retain the above copyright\r\n *    notice, this list of conditions, and the following disclaimer.\r\n *\r\n * 2. Redistributions in binary form must reproduce the above copyright\r\n *    notice, this list of conditions, and the disclaimer that follows \r\n *    these conditions in the documentation and/or other materials \r\n *    provided with the distribution.\r\n *\r\n * 3. The name \"SAXPath\" must not be used to endorse or promote products\r\n *    derived from this software without prior written permission.  For\r\n *    written permission, please contact license@saxpath.org.\r\n * \r\n * 4. Products derived from this software may not be called \"SAXPath\", nor\r\n *    may \"SAXPath\" appear in their name, without prior written permission\r\n *    from the SAXPath Project Management (pm@saxpath.org).\r\n * \r\n * In addition, we request (but do not require) that you include in the \r\n * end-user documentation provided with the redistribution and/or in the \r\n * software itself an acknowledgement equivalent to the following:\r\n *     \"This product includes software developed by the\r\n *      SAXPath Project (http://www.saxpath.org/).\"\r\n * Alternatively, the acknowledgment may be graphical using the logos \r\n * available at http://www.saxpath.org/\r\n *\r\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\r\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\r\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED.  IN NO EVENT SHALL THE SAXPath AUTHORS OR THE PROJECT\r\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\r\n * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\r\n * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\r\n * SUCH DAMAGE.\r\n *\r\n * ====================================================================\r\n * This software consists of voluntary contributions made by many \r\n * individuals on behalf of the SAXPath Project and was originally \r\n * created by bob mcwhirter <bob@werken.com> and \r\n * James Strachan <jstrachan@apache.org>.  For more information on the \r\n * SAXPath Project, please see <http://www.saxpath.org/>.\r\n * \r\n * $Id: XPathReaderFactory.java,v 1.7 2002/04/26 17:05:34 jstrachan Exp $\r\n */\r\npackage org.saxpath.helpers;\r\n\r\nimport org.saxpath.XPathReader;\r\nimport org.saxpath.SAXPathException;\r\n\r\n/**\r\n * Create an {@link org.saxpath.XPathReader} from\r\n *  either a system property, or a named class.\r\n *\r\n *  <p>\r\n *  Similar to the SAX API, the <code>XPathReaderFactory</code>\r\n *  can create an <code>XPathReader</code> from a name of a\r\n *  class passed in directly, or by inspecting the system\r\n *  property <code>org.saxpath.driver</code>.\r\n *\r\n *  @author bob mcwhirter (bob@werken.com)\r\n */\r\npublic class XPathReaderFactory {\r\n\r\n    /**\r\n     * The <code>org.saxpath.driver</code> property name.\r\n     */\r\n    public static final String DRIVER_PROPERTY = \"org.saxpath.driver\";\r\n\r\n    /**\r\n     * The default driver to use if none is configured.\r\n     */\r\n    protected static final String DEFAULT_DRIVER = \"com.werken.saxpath.XPathReader\";\r\n\r\n    /**\r\n     * Should the default driver be used\r\n     */\r\n    private static boolean USE_DEFAULT = true;\r\n\r\n    /**\r\n     * Create an <code>XPathReader</code> using the value of\r\n     *  the <code>org.saxpath.driver</code> system property.\r\n     *\r\n     *  @return An instance of the <code>XPathReader</code> specified\r\n     *          by the <code>org.saxpath.driver</code> property.\r\n     *\r\n     *  @throws SAXPathException if the property is unset, or if\r\n     *          the class can not be instantiated for some reason.,\r\n     *          or if the class doesn't implement the <code>XPathReader</code>\r\n     *          interface.\r\n     */\r\n    public static XPathReader createReader() throws SAXPathException {\r\n        String className = null;\r\n        boolean securityException = false;\r\n        try {\r\n            className = System.getProperty(DRIVER_PROPERTY);\r\n        } catch (SecurityException e) {\r\n            securityException = true;\r\n        }\r\n        if (className == null || \"\".equals(className)) {\r\n            if (USE_DEFAULT) {\r\n                className = DEFAULT_DRIVER;\r\n            } else {\r\n                if (securityException) {\r\n                    throw new SAXPathException(\"Reading of property \" + DRIVER_PROPERTY + \" disallowed.\");\r\n                } else {\r\n                    throw new SAXPathException(\"Property \" + DRIVER_PROPERTY + \" not set\");\r\n                }\r\n            }\r\n        }\r\n        return createReader(className);\r\n    }\r\n\r\n    /**\r\n     * Create an <code>XPathReader</code> using the passed\r\n     *  in class name.\r\n     *\r\n     *  @param className The name of the class which implements\r\n     *         the <code>XPathReader</code> interface.\r\n     *\r\n     *  @throws SAXPathException if the class can not be\r\n     *          instantiated for some reason, or if the\r\n     *          class doesn't implement the <code>XPathReader</code>\r\n     *          interface.\r\n     */\r\n    public static XPathReader createReader(String className) throws SAXPathException {\r\n        Class readerClass = null;\r\n        XPathReader reader = null;\r\n        try {\r\n            // Use the full version of Class.forName(), so as to\r\n            // work better in sandboxed environments, such as\r\n            // Servlet contains, and Applets.\r\n            readerClass = Class.forName(className, true, XPathReaderFactory.class.getClassLoader());\r\n            // Double-check that it's actually the right kind of class\r\n            // before attempting instantiation.\r\n            if (!XPathReader.class.isAssignableFrom(readerClass)) {\r\n                throw new SAXPathException(\"Class [\" + className + \"] does not implement the org.saxpath.XPathReader interface.\");\r\n            }\r\n        } catch (ClassNotFoundException e) {\r\n            throw new SAXPathException(e.getMessage());\r\n        }\r\n        try {\r\n            reader = (XPathReader) readerClass.newInstance();\r\n        } catch (IllegalAccessException e) {\r\n            throw new SAXPathException(e.getMessage());\r\n        } catch (InstantiationException e) {\r\n            throw new SAXPathException(e.getMessage());\r\n        }\r\n        if (reader == null) {\r\n            throw new SAXPathException(\"Unable to create XPathReader\");\r\n        }\r\n        return reader;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/24_saxpath/src/main/java/saxpath/helpers/XPathReaderFactoryTest1.java",
		"test_prompt": "// XPathReaderFactoryTest1.java\npackage org.saxpath.helpers;\n\nimport org.saxpath.XPathReader;\nimport org.saxpath.SAXPathException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XPathReaderFactory}.\n* It contains ten unit test cases for the {@link XPathReaderFactory#createReader(String)} method.\n*/\nclass XPathReaderFactoryTest1 {"
	},
	{
		"original_code": "// ConformanceXPathHandler.java\n/*\r\n * $Header: /cvsroot/saxpath/saxpath/src/java/main/org/saxpath/conformance/ConformanceXPathHandler.java,v 1.8 2002/04/26 17:05:34 jstrachan Exp $\r\n * $Revision: 1.8 $\r\n * $Date: 2002/04/26 17:05:34 $\r\n *\r\n * ====================================================================\r\n *\r\n * Copyright (C) 2000-2002 werken digital.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions\r\n * are met:\r\n * \r\n * 1. Redistributions of source code must retain the above copyright\r\n *    notice, this list of conditions, and the following disclaimer.\r\n *\r\n * 2. Redistributions in binary form must reproduce the above copyright\r\n *    notice, this list of conditions, and the disclaimer that follows \r\n *    these conditions in the documentation and/or other materials \r\n *    provided with the distribution.\r\n *\r\n * 3. The name \"SAXPath\" must not be used to endorse or promote products\r\n *    derived from this software without prior written permission.  For\r\n *    written permission, please contact license@saxpath.org.\r\n * \r\n * 4. Products derived from this software may not be called \"SAXPath\", nor\r\n *    may \"SAXPath\" appear in their name, without prior written permission\r\n *    from the SAXPath Project Management (pm@saxpath.org).\r\n * \r\n * In addition, we request (but do not require) that you include in the \r\n * end-user documentation provided with the redistribution and/or in the \r\n * software itself an acknowledgement equivalent to the following:\r\n *     \"This product includes software developed by the\r\n *      SAXPath Project (http://www.saxpath.org/).\"\r\n * Alternatively, the acknowledgment may be graphical using the logos \r\n * available at http://www.saxpath.org/\r\n *\r\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\r\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\r\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED.  IN NO EVENT SHALL THE SAXPath AUTHORS OR THE PROJECT\r\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\r\n * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\r\n * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\r\n * SUCH DAMAGE.\r\n *\r\n * ====================================================================\r\n * This software consists of voluntary contributions made by many \r\n * individuals on behalf of the SAXPath Project and was originally \r\n * created by bob mcwhirter <bob@werken.com> and \r\n * James Strachan <jstrachan@apache.org>.  For more information on the \r\n * SAXPath Project, please see <http://www.saxpath.org/>.\r\n * \r\n * $Id: ConformanceXPathHandler.java,v 1.8 2002/04/26 17:05:34 jstrachan Exp $\r\n */\r\npackage org.saxpath.conformance;\r\n\r\nimport org.saxpath.XPathHandler;\r\nimport java.util.List;\r\nimport java.util.LinkedList;\r\nimport java.util.Iterator;\r\n\r\npublic class ConformanceXPathHandler implements XPathHandler {\r\n\r\n    private List events;\r\n\r\n    public ConformanceXPathHandler() {\r\n        this.events = new LinkedList();\r\n    }\r\n\r\n    public void startXPath() {\r\n        addEvent(\"startXPath()\");\r\n    }\r\n\r\n    public void endXPath() {\r\n        addEvent(\"endXPath()\");\r\n    }\r\n\r\n    public void startPathExpr() {\r\n        addEvent(\"startPathExpr()\");\r\n    }\r\n\r\n    public void endPathExpr() {\r\n        addEvent(\"endPathExpr()\");\r\n    }\r\n\r\n    public void startAbsoluteLocationPath() {\r\n        addEvent(\"startAbsoluteLocationPath()\");\r\n    }\r\n\r\n    public void endAbsoluteLocationPath() {\r\n        addEvent(\"endAbsoluteLocationPath()\");\r\n    }\r\n\r\n    public void startRelativeLocationPath() {\r\n        addEvent(\"startRelativeLocationPath()\");\r\n    }\r\n\r\n    public void endRelativeLocationPath() {\r\n        addEvent(\"endRelativeLocationPath()\");\r\n    }\r\n\r\n    public void startNameStep(int axis, String prefix, String localName) {\r\n        addEvent(\"startNameStep(\" + axis + \", \\\"\" + prefix + \"\\\", \\\"\" + localName + \"\\\")\");\r\n    }\r\n\r\n    public void endNameStep() {\r\n        addEvent(\"endNameStep()\");\r\n    }\r\n\r\n    public void startTextNodeStep(int axis) {\r\n        addEvent(\"startTextNodeStep(\" + axis + \")\");\r\n    }\r\n\r\n    public void endTextNodeStep() {\r\n        addEvent(\"endTextNodeStep()\");\r\n    }\r\n\r\n    public void startCommentNodeStep(int axis) {\r\n        addEvent(\"startCommentNodeStep(\" + axis + \")\");\r\n    }\r\n\r\n    public void endCommentNodeStep() {\r\n        addEvent(\"endCommentNodeStep()\");\r\n    }\r\n\r\n    public void startAllNodeStep(int axis) {\r\n        addEvent(\"startAllNodeStep(\" + axis + \")\");\r\n    }\r\n\r\n    public void endAllNodeStep() {\r\n        addEvent(\"endAllNodeStep()\");\r\n    }\r\n\r\n    public void startProcessingInstructionNodeStep(int axis, String name) {\r\n        addEvent(\"startProcessingInstructionNodeStep(\" + axis + \", \\\"\" + name + \"\\\")\");\r\n    }\r\n\r\n    public void endProcessingInstructionNodeStep() {\r\n        addEvent(\"endProcessingInstructionNodeStep()\");\r\n    }\r\n\r\n    public void startPredicate() {\r\n        addEvent(\"startPredicate()\");\r\n    }\r\n\r\n    public void endPredicate() {\r\n        addEvent(\"endPredicate()\");\r\n    }\r\n\r\n    public void startFilterExpr() {\r\n        addEvent(\"startFilterExpr()\");\r\n    }\r\n\r\n    public void endFilterExpr() {\r\n        addEvent(\"endFilterExpr()\");\r\n    }\r\n\r\n    public void startOrExpr() {\r\n        addEvent(\"startOrExpr()\");\r\n    }\r\n\r\n    public void endOrExpr(boolean create) {\r\n        addEvent(\"endOrExpr(\" + create + \")\");\r\n    }\r\n\r\n    public void startAndExpr() {\r\n        addEvent(\"startAndExpr()\");\r\n    }\r\n\r\n    public void endAndExpr(boolean create) {\r\n        addEvent(\"endAndExpr(\" + create + \")\");\r\n    }\r\n\r\n    public void startEqualityExpr() {\r\n        addEvent(\"startEqualityExpr()\");\r\n    }\r\n\r\n    public void endEqualityExpr(int operator) {\r\n        addEvent(\"endEqualityExpr(\" + operator + \")\");\r\n    }\r\n\r\n    public void startRelationalExpr() {\r\n        addEvent(\"startRelationalExpr()\");\r\n    }\r\n\r\n    public void endRelationalExpr(int operator) {\r\n        addEvent(\"endRelationalExpr(\" + operator + \")\");\r\n    }\r\n\r\n    public void startAdditiveExpr() {\r\n        addEvent(\"startAdditiveExpr()\");\r\n    }\r\n\r\n    public void endAdditiveExpr(int operator) {\r\n        addEvent(\"endAdditiveExpr(\" + operator + \")\");\r\n    }\r\n\r\n    public void startMultiplicativeExpr() {\r\n        addEvent(\"startMultiplicativeExpr()\");\r\n    }\r\n\r\n    public void endMultiplicativeExpr(int operator) {\r\n        addEvent(\"endMultiplicativeExpr(\" + operator + \")\");\r\n    }\r\n\r\n    public void startUnaryExpr() {\r\n        addEvent(\"startUnaryExpr()\");\r\n    }\r\n\r\n    public void endUnaryExpr(int operator) {\r\n        addEvent(\"endUnaryExpr(\" + operator + \")\");\r\n    }\r\n\r\n    public void startUnionExpr() {\r\n        addEvent(\"startUnionExpr()\");\r\n    }\r\n\r\n    public void endUnionExpr(boolean create) {\r\n        addEvent(\"endUnionExpr(\" + create + \")\");\r\n    }\r\n\r\n    public void number(int number) {\r\n        addEvent(\"number(\" + number + \")\");\r\n    }\r\n\r\n    public void number(double number) {\r\n        addEvent(\"number(\" + number + \")\");\r\n    }\r\n\r\n    public void literal(String literal) {\r\n        addEvent(\"literal(\\\"\" + literal + \"\\\")\");\r\n    }\r\n\r\n    public void variableReference(String prefix, String variableName) {\r\n        addEvent(\"variableReference(\\\"\" + prefix + \":\" + variableName + \"\\\")\");\r\n    }\r\n\r\n    public void startFunction(String prefix, String functionName) {\r\n        addEvent(\"startFunction(\\\"\" + prefix + \":\" + functionName + \"\\\")\");\r\n    }\r\n\r\n    public void endFunction() {\r\n        addEvent(\"endFunction()\");\r\n    }\r\n\r\n    private void addEvent(String eventStr) {\r\n        this.events.add(eventStr);\r\n    }\r\n\r\n    public boolean equals(Object thatObj) {\r\n        if (thatObj instanceof ConformanceXPathHandler) {\r\n            ConformanceXPathHandler that = (ConformanceXPathHandler) thatObj;\r\n            return (this.events.equals(that.events));\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public String toString() {\r\n        Iterator eventIter = this.events.iterator();\r\n        int i = 0;\r\n        StringBuffer buf = new StringBuffer();\r\n        while (eventIter.hasNext()) {\r\n            buf.append(\"(\").append(i).append(\") \").append(eventIter.next().toString()).append(\"\\n\");\r\n            ++i;\r\n        }\r\n        return buf.toString();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/24_saxpath/src/main/java/saxpath/conformance/ConformanceXPathHandlerTest.java",
		"test_prompt": "// ConformanceXPathHandlerTest.java\npackage org.saxpath.conformance;\n\nimport org.saxpath.XPathHandler;\nimport java.util.List;\nimport java.util.LinkedList;\nimport java.util.Iterator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ConformanceXPathHandler}.\n* It contains ten unit test cases for the {@link ConformanceXPathHandler#equals(Object)} method.\n*/\nclass ConformanceXPathHandlerTest {"
	},
	{
		"original_code": "// DefaultXPathHandler.java\n/*\n * $Header: /cvsroot/saxpath/saxpath/src/java/main/com/werken/saxpath/DefaultXPathHandler.java,v 1.8 2002/04/26 17:05:34 jstrachan Exp $\n * $Revision: 1.8 $\n * $Date: 2002/04/26 17:05:34 $\n *\n * ====================================================================\n *\n * Copyright (C) 2000-2002 werken digital.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * \n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions, and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions, and the disclaimer that follows \n *    these conditions in the documentation and/or other materials \n *    provided with the distribution.\n *\n * 3. The name \"SAXPath\" must not be used to endorse or promote products\n *    derived from this software without prior written permission.  For\n *    written permission, please contact license@saxpath.org.\n * \n * 4. Products derived from this software may not be called \"SAXPath\", nor\n *    may \"SAXPath\" appear in their name, without prior written permission\n *    from the SAXPath Project Management (pm@saxpath.org).\n * \n * In addition, we request (but do not require) that you include in the \n * end-user documentation provided with the redistribution and/or in the \n * software itself an acknowledgement equivalent to the following:\n *     \"This product includes software developed by the\n *      SAXPath Project (http://www.saxpath.org/).\"\n * Alternatively, the acknowledgment may be graphical using the logos \n * available at http://www.saxpath.org/\n *\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED.  IN NO EVENT SHALL THE SAXPath AUTHORS OR THE PROJECT\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n * ====================================================================\n * This software consists of voluntary contributions made by many \n * individuals on behalf of the SAXPath Project and was originally \n * created by bob mcwhirter <bob@werken.com> and \n * James Strachan <jstrachan@apache.org>.  For more information on the \n * SAXPath Project, please see <http://www.saxpath.org/>.\n * \n * $Id: DefaultXPathHandler.java,v 1.8 2002/04/26 17:05:34 jstrachan Exp $\n */\npackage com.werken.saxpath;\n\nimport org.saxpath.XPathHandler;\n\nclass DefaultXPathHandler implements XPathHandler {\n\n    static class Singleton {\n\n        static final DefaultXPathHandler instance = new DefaultXPathHandler();\n    }\n\n    public static XPathHandler getInstance() {\n        return Singleton.instance;\n    }\n\n    public void startXPath() {\n    }\n\n    public void endXPath() {\n    }\n\n    public void startPathExpr() {\n    }\n\n    public void endPathExpr() {\n    }\n\n    public void startAbsoluteLocationPath() {\n    }\n\n    public void endAbsoluteLocationPath() {\n    }\n\n    public void startRelativeLocationPath() {\n    }\n\n    public void endRelativeLocationPath() {\n    }\n\n    public void startNameStep(int axis, String prefix, String localName) {\n    }\n\n    public void startTextNodeStep(int axis) {\n    }\n\n    public void endTextNodeStep() {\n    }\n\n    public void startCommentNodeStep(int axis) {\n    }\n\n    public void endCommentNodeStep() {\n    }\n\n    public void startAllNodeStep(int axis) {\n    }\n\n    public void endAllNodeStep() {\n    }\n\n    public void startProcessingInstructionNodeStep(int axis, String name) {\n    }\n\n    public void endProcessingInstructionNodeStep() {\n    }\n\n    public void endNameStep() {\n    }\n\n    public void startPredicate() {\n    }\n\n    public void endPredicate() {\n    }\n\n    public void startFilterExpr() {\n    }\n\n    public void endFilterExpr() {\n    }\n\n    public void startOrExpr() {\n    }\n\n    public void endOrExpr(boolean create) {\n    }\n\n    public void startAndExpr() {\n    }\n\n    public void endAndExpr(boolean create) {\n    }\n\n    public void startEqualityExpr() {\n    }\n\n    public void endEqualityExpr(int operator) {\n    }\n\n    public void startRelationalExpr() {\n    }\n\n    public void endRelationalExpr(int operator) {\n    }\n\n    public void startAdditiveExpr() {\n    }\n\n    public void endAdditiveExpr(int operator) {\n    }\n\n    public void startMultiplicativeExpr() {\n    }\n\n    public void endMultiplicativeExpr(int operator) {\n    }\n\n    public void startUnaryExpr() {\n    }\n\n    public void endUnaryExpr(int operator) {\n    }\n\n    public void startUnionExpr() {\n    }\n\n    public void endUnionExpr(boolean create) {\n    }\n\n    public void number(int number) {\n    }\n\n    public void number(double number) {\n    }\n\n    public void literal(String literal) {\n    }\n\n    public void variableReference(String prefix, String variableName) {\n    }\n\n    public void startFunction(String prefix, String functionName) {\n    }\n\n    public void endFunction() {\n    }\n}\n",
		"id": "EvoSuiteBenchmark/24_saxpath/src/main/java/com/werken/saxpath/DefaultXPathHandlerTest.java",
		"test_prompt": "// DefaultXPathHandlerTest.java\npackage com.werken.saxpath;\n\nimport org.saxpath.XPathHandler;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DefaultXPathHandler}.\n* It contains ten unit test cases for the {@link DefaultXPathHandler#getInstance()} method.\n*/\nclass DefaultXPathHandlerTest {"
	},
	{
		"original_code": "// XPathLexer.java\n/*\n * $Header: /cvsroot/saxpath/saxpath/src/java/main/com/werken/saxpath/XPathLexer.java,v 1.10 2002/04/26 17:05:34 jstrachan Exp $\n * $Revision: 1.10 $\n * $Date: 2002/04/26 17:05:34 $\n *\n * ====================================================================\n *\n * Copyright (C) 2000-2002 werken digital.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * \n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions, and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions, and the disclaimer that follows \n *    these conditions in the documentation and/or other materials \n *    provided with the distribution.\n *\n * 3. The name \"SAXPath\" must not be used to endorse or promote products\n *    derived from this software without prior written permission.  For\n *    written permission, please contact license@saxpath.org.\n * \n * 4. Products derived from this software may not be called \"SAXPath\", nor\n *    may \"SAXPath\" appear in their name, without prior written permission\n *    from the SAXPath Project Management (pm@saxpath.org).\n * \n * In addition, we request (but do not require) that you include in the \n * end-user documentation provided with the redistribution and/or in the \n * software itself an acknowledgement equivalent to the following:\n *     \"This product includes software developed by the\n *      SAXPath Project (http://www.saxpath.org/).\"\n * Alternatively, the acknowledgment may be graphical using the logos \n * available at http://www.saxpath.org/\n *\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED.  IN NO EVENT SHALL THE SAXPath AUTHORS OR THE PROJECT\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n * ====================================================================\n * This software consists of voluntary contributions made by many \n * individuals on behalf of the SAXPath Project and was originally \n * created by bob mcwhirter <bob@werken.com> and \n * James Strachan <jstrachan@apache.org>.  For more information on the \n * SAXPath Project, please see <http://www.saxpath.org/>.\n * \n * $Id: XPathLexer.java,v 1.10 2002/04/26 17:05:34 jstrachan Exp $\n */\npackage com.werken.saxpath;\n\nclass XPathLexer {\n\n    private String xpath;\n\n    private int currentPosition;\n\n    private int endPosition;\n\n    private Token previousToken;\n\n    public XPathLexer(String xpath) {\n        setXPath(xpath);\n    }\n\n    XPathLexer() {\n    }\n\n    void setXPath(String xpath) {\n        this.xpath = xpath;\n        this.currentPosition = 0;\n        this.endPosition = xpath.length();\n    }\n\n    public String getXPath() {\n        return this.xpath;\n    }\n\n    public Token nextToken() {\n        Token token = null;\n        do {\n            token = null;\n            switch(LA(1)) {\n                case '$':\n                    {\n                        token = dollar();\n                        break;\n                    }\n                case '\"':\n                case '\\'':\n                    {\n                        token = literal();\n                        break;\n                    }\n                case '/':\n                    {\n                        token = slashes();\n                        break;\n                    }\n                case ',':\n                    {\n                        token = comma();\n                        break;\n                    }\n                case '(':\n                    {\n                        token = leftParen();\n                        break;\n                    }\n                case ')':\n                    {\n                        token = rightParen();\n                        break;\n                    }\n                case '[':\n                    {\n                        token = leftBracket();\n                        break;\n                    }\n                case ']':\n                    {\n                        token = rightBracket();\n                        break;\n                    }\n                case '+':\n                    {\n                        token = plus();\n                        break;\n                    }\n                case '-':\n                    {\n                        token = minus();\n                        break;\n                    }\n                case '<':\n                case '>':\n                    {\n                        token = relationalOperator();\n                        break;\n                    }\n                case '=':\n                    {\n                        token = equals();\n                        break;\n                    }\n                case '!':\n                    {\n                        if (LA(2) == '=') {\n                            token = notEquals();\n                        } else {\n                            token = not();\n                        }\n                        break;\n                    }\n                case '|':\n                    {\n                        token = pipe();\n                        break;\n                    }\n                case '@':\n                    {\n                        token = at();\n                        break;\n                    }\n                case ':':\n                    {\n                        if (LA(2) == ':') {\n                            token = doubleColon();\n                        } else {\n                            token = colon();\n                        }\n                        break;\n                    }\n                case '*':\n                    {\n                        token = star();\n                        break;\n                    }\n                case '.':\n                    {\n                        switch(LA(2)) {\n                            case '0':\n                            case '1':\n                            case '2':\n                            case '3':\n                            case '4':\n                            case '5':\n                            case '6':\n                            case '7':\n                            case '8':\n                            case '9':\n                                {\n                                    token = number();\n                                    break;\n                                }\n                            default:\n                                {\n                                    token = dots();\n                                    break;\n                                }\n                        }\n                        break;\n                    }\n                case '0':\n                case '1':\n                case '2':\n                case '3':\n                case '4':\n                case '5':\n                case '6':\n                case '7':\n                case '8':\n                case '9':\n                    {\n                        token = number();\n                        break;\n                    }\n                case ' ':\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                    {\n                        token = whitespace();\n                        break;\n                    }\n                default:\n                    {\n                        if (isIdentifierStartChar(LA(1))) {\n                            token = identifierOrOperatorName();\n                        }\n                    }\n            }\n            if (token == null) {\n                token = new Token(TokenTypes.EOF, getXPath(), currentPosition(), endPosition());\n            }\n        } while (token.getTokenType() == TokenTypes.SKIP);\n        setPreviousToken(token);\n        return token;\n    }\n\n    Token identifierOrOperatorName() {\n        Token token = null;\n        Token previousToken = getPreviousToken();\n        if (previousToken != null) {\n            // For some reason, section 3.7, Lexical structure,\n            // doesn't seem to feel like it needs to mention the\n            // SLASH, DOUBLE_SLASH, and COLON tokens for the test\n            // if an NCName is an operator or not.\n            //\n            // Accoring to section 3.7, \"/foo\" should be considered\n            // as a SLASH following by an OperatorName being 'foo'.\n            // Which is just simply, clearly, wrong, in my mind.\n            //\n            //     -bob\n            switch(previousToken.getTokenType()) {\n                case TokenTypes.AT:\n                case TokenTypes.DOUBLE_COLON:\n                case TokenTypes.LEFT_PAREN:\n                case TokenTypes.LEFT_BRACKET:\n                case TokenTypes.AND:\n                case TokenTypes.OR:\n                case TokenTypes.MOD:\n                case TokenTypes.DIV:\n                case TokenTypes.COLON:\n                case TokenTypes.SLASH:\n                case TokenTypes.DOUBLE_SLASH:\n                case TokenTypes.PIPE:\n                case TokenTypes.DOLLAR:\n                case TokenTypes.PLUS:\n                case TokenTypes.MINUS:\n                case TokenTypes.STAR:\n                case TokenTypes.COMMA:\n                case TokenTypes.LESS_THAN:\n                case TokenTypes.GREATER_THAN:\n                case TokenTypes.LESS_THAN_EQUALS:\n                case TokenTypes.GREATER_THAN_EQUALS:\n                case TokenTypes.EQUALS:\n                case TokenTypes.NOT_EQUALS:\n                    {\n                        token = identifier();\n                        break;\n                    }\n                default:\n                    {\n                        token = operatorName();\n                        break;\n                    }\n            }\n        } else {\n            token = identifier();\n        }\n        return token;\n    }\n\n    Token identifier() {\n        Token token = null;\n        int start = currentPosition();\n        while (hasMoreChars()) {\n            if (isIdentifierChar(LA(1))) {\n                consume();\n            } else {\n                break;\n            }\n        }\n        token = new Token(TokenTypes.IDENTIFIER, getXPath(), start, currentPosition());\n        return token;\n    }\n\n    Token operatorName() {\n        Token token = null;\n        switch(LA(1)) {\n            case 'a':\n                {\n                    token = and();\n                    break;\n                }\n            case 'o':\n                {\n                    token = or();\n                    break;\n                }\n            case 'm':\n                {\n                    token = mod();\n                    break;\n                }\n            case 'd':\n                {\n                    token = div();\n                    break;\n                }\n        }\n        return token;\n    }\n\n    Token mod() {\n        Token token = null;\n        if ((LA(1) == 'm') && (LA(2) == 'o') && (LA(3) == 'd') && (!isIdentifierChar(LA(4)))) {\n            token = new Token(TokenTypes.MOD, getXPath(), currentPosition(), currentPosition() + 3);\n            consume();\n            consume();\n            consume();\n        }\n        return token;\n    }\n\n    Token div() {\n        Token token = null;\n        if ((LA(1) == 'd') && (LA(2) == 'i') && (LA(3) == 'v') && (!isIdentifierChar(LA(4)))) {\n            token = new Token(TokenTypes.DIV, getXPath(), currentPosition(), currentPosition() + 3);\n            consume();\n            consume();\n            consume();\n        }\n        return token;\n    }\n\n    Token and() {\n        Token token = null;\n        if ((LA(1) == 'a') && (LA(2) == 'n') && (LA(3) == 'd') && (!isIdentifierChar(LA(4)))) {\n            token = new Token(TokenTypes.AND, getXPath(), currentPosition(), currentPosition() + 3);\n            consume();\n            consume();\n            consume();\n        }\n        return token;\n    }\n\n    Token or() {\n        Token token = null;\n        if ((LA(1) == 'o') && (LA(2) == 'r') && (!isIdentifierChar(LA(3)))) {\n            token = new Token(TokenTypes.OR, getXPath(), currentPosition(), currentPosition() + 2);\n            consume();\n            consume();\n        }\n        return token;\n    }\n\n    Token number() {\n        int start = currentPosition();\n        boolean periodAllowed = true;\n        loop: while (true) {\n            switch(LA(1)) {\n                case '.':\n                    {\n                        if (periodAllowed) {\n                            periodAllowed = false;\n                            consume();\n                        } else {\n                            break loop;\n                        }\n                        break;\n                    }\n                case '0':\n                case '1':\n                case '2':\n                case '3':\n                case '4':\n                case '5':\n                case '6':\n                case '7':\n                case '8':\n                case '9':\n                    {\n                        consume();\n                        break;\n                    }\n                default:\n                    {\n                        break loop;\n                    }\n            }\n        }\n        Token token = null;\n        if (periodAllowed) {\n            token = new Token(TokenTypes.INTEGER, getXPath(), start, currentPosition());\n        } else {\n            token = new Token(TokenTypes.DOUBLE, getXPath(), start, currentPosition());\n        }\n        return token;\n    }\n\n    Token whitespace() {\n        consume();\n        loop: while (hasMoreChars()) {\n            switch(LA(1)) {\n                case ' ':\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                    {\n                        consume();\n                        break;\n                    }\n                default:\n                    {\n                        break loop;\n                    }\n            }\n        }\n        return new Token(TokenTypes.SKIP, getXPath(), 0, 0);\n    }\n\n    Token comma() {\n        Token token = new Token(TokenTypes.COMMA, getXPath(), currentPosition(), currentPosition() + 1);\n        consume();\n        return token;\n    }\n\n    Token equals() {\n        Token token = new Token(TokenTypes.EQUALS, getXPath(), currentPosition(), currentPosition() + 1);\n        consume();\n        return token;\n    }\n\n    Token minus() {\n        Token token = new Token(TokenTypes.MINUS, getXPath(), currentPosition(), currentPosition() + 1);\n        consume();\n        return token;\n    }\n\n    Token plus() {\n        Token token = new Token(TokenTypes.PLUS, getXPath(), currentPosition(), currentPosition() + 1);\n        consume();\n        return token;\n    }\n\n    Token dollar() {\n        Token token = new Token(TokenTypes.DOLLAR, getXPath(), currentPosition(), currentPosition() + 1);\n        consume();\n        return token;\n    }\n\n    Token pipe() {\n        Token token = new Token(TokenTypes.PIPE, getXPath(), currentPosition(), currentPosition() + 1);\n        consume();\n        return token;\n    }\n\n    Token at() {\n        Token token = new Token(TokenTypes.AT, getXPath(), currentPosition(), currentPosition() + 1);\n        consume();\n        return token;\n    }\n\n    Token colon() {\n        Token token = new Token(TokenTypes.COLON, getXPath(), currentPosition(), currentPosition() + 1);\n        consume();\n        return token;\n    }\n\n    Token doubleColon() {\n        Token token = new Token(TokenTypes.DOUBLE_COLON, getXPath(), currentPosition(), currentPosition() + 2);\n        consume();\n        consume();\n        return token;\n    }\n\n    Token not() {\n        Token token = new Token(TokenTypes.NOT, getXPath(), currentPosition(), currentPosition() + 1);\n        consume();\n        return token;\n    }\n\n    Token notEquals() {\n        Token token = new Token(TokenTypes.NOT_EQUALS, getXPath(), currentPosition(), currentPosition() + 2);\n        consume();\n        consume();\n        return token;\n    }\n\n    Token relationalOperator() {\n        Token token = null;\n        switch(LA(1)) {\n            case '<':\n                {\n                    if (LA(2) == '=') {\n                        token = new Token(TokenTypes.LESS_THAN_EQUALS, getXPath(), currentPosition(), currentPosition() + 2);\n                        consume();\n                    } else {\n                        token = new Token(TokenTypes.LESS_THAN, getXPath(), currentPosition(), currentPosition() + 1);\n                    }\n                    consume();\n                    break;\n                }\n            case '>':\n                {\n                    if (LA(2) == '=') {\n                        token = new Token(TokenTypes.GREATER_THAN_EQUALS, getXPath(), currentPosition(), currentPosition() + 2);\n                        consume();\n                    } else {\n                        token = new Token(TokenTypes.GREATER_THAN, getXPath(), currentPosition(), currentPosition() + 1);\n                    }\n                    consume();\n                    break;\n                }\n        }\n        return token;\n    }\n\n    Token star() {\n        Token token = new Token(TokenTypes.STAR, getXPath(), currentPosition(), currentPosition() + 1);\n        consume();\n        return token;\n    }\n\n    Token literal() {\n        Token token = null;\n        char match = LA(1);\n        consume();\n        int start = currentPosition();\n        while ((token == null) && hasMoreChars()) {\n            if (LA(1) == match) {\n                token = new Token(TokenTypes.LITERAL, getXPath(), start, currentPosition());\n            }\n            consume();\n        }\n        return token;\n    }\n\n    Token dots() {\n        Token token = null;\n        switch(LA(2)) {\n            case '.':\n                {\n                    token = new Token(TokenTypes.DOT_DOT, getXPath(), currentPosition(), currentPosition() + 2);\n                    consume();\n                    consume();\n                    break;\n                }\n            default:\n                {\n                    token = new Token(TokenTypes.DOT, getXPath(), currentPosition(), currentPosition() + 1);\n                    consume();\n                    break;\n                }\n        }\n        return token;\n    }\n\n    Token leftBracket() {\n        Token token = new Token(TokenTypes.LEFT_BRACKET, getXPath(), currentPosition(), currentPosition() + 1);\n        consume();\n        return token;\n    }\n\n    Token rightBracket() {\n        Token token = new Token(TokenTypes.RIGHT_BRACKET, getXPath(), currentPosition(), currentPosition() + 1);\n        consume();\n        return token;\n    }\n\n    Token leftParen() {\n        Token token = new Token(TokenTypes.LEFT_PAREN, getXPath(), currentPosition(), currentPosition() + 1);\n        consume();\n        return token;\n    }\n\n    Token rightParen() {\n        Token token = new Token(TokenTypes.RIGHT_PAREN, getXPath(), currentPosition(), currentPosition() + 1);\n        consume();\n        return token;\n    }\n\n    Token slashes() {\n        Token token = null;\n        switch(LA(2)) {\n            case '/':\n                {\n                    token = new Token(TokenTypes.DOUBLE_SLASH, getXPath(), currentPosition(), currentPosition() + 2);\n                    consume();\n                    consume();\n                    break;\n                }\n            default:\n                {\n                    token = new Token(TokenTypes.SLASH, getXPath(), currentPosition(), currentPosition() + 1);\n                    consume();\n                }\n        }\n        return token;\n    }\n\n    char LA(int i) {\n        if (currentPosition + (i - 1) >= endPosition()) {\n            return (char) -1;\n        }\n        return getXPath().charAt(currentPosition() + (i - 1));\n    }\n\n    void consume() {\n        ++this.currentPosition;\n    }\n\n    void consume(int i) {\n        this.currentPosition += i;\n    }\n\n    int currentPosition() {\n        return this.currentPosition;\n    }\n\n    int endPosition() {\n        return this.endPosition;\n    }\n\n    Token getPreviousToken() {\n        return this.previousToken;\n    }\n\n    void setPreviousToken(Token previousToken) {\n        this.previousToken = previousToken;\n    }\n\n    boolean hasMoreChars() {\n        return currentPosition() < endPosition();\n    }\n\n    boolean isIdentifierChar(char c) {\n        switch(c) {\n            case '-':\n            case '.':\n                return true;\n        }\n        return Character.isUnicodeIdentifierPart(c);\n    }\n\n    boolean isIdentifierStartChar(char c) {\n        return c == '_' || Character.isUnicodeIdentifierStart(c);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/24_saxpath/src/main/java/com/werken/saxpath/XPathLexerTest.java",
		"test_prompt": "// XPathLexerTest.java\npackage com.werken.saxpath;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XPathLexer}.\n* It contains ten unit test cases for the {@link XPathLexer#nextToken()} method.\n*/\nclass XPathLexerTest {"
	}
]