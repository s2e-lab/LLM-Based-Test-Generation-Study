[
	{
		"original_code": "// Info.java\n/*\nCopyright (c) 2007, Andrew Wilcox\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions are met:\n\n+ Redistributions of source code must retain the above copyright notice, \n  this list of conditions and the following disclaimer.\n+ Redistributions in binary form must reproduce the above copyright notice, \n  this list of conditions and the following disclaimer in the documentation \n  and/or other materials provided with the distribution.\n+ Neither the name Andrew Wilcox nor the names of its contributors may be \n  used to endorse or promote products derived from this software without \n  specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \n  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE \n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \n  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \n  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \n  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n  POSSIBILITY OF SUCH DAMAGE.\n */\npackage net.sourceforge.jiprof.instrument.clfilter;\n\nimport java.util.Properties;\nimport com.mentorgen.tools.profile.instrument.clfilter.ClassLoaderFilter;\n\npublic class Info implements ClassLoaderFilter {\n\n    public boolean accept(ClassLoader loader) {\n        return false;\n    }\n\n    public boolean canFilter() {\n        System.err.print(\"--> classloader: \");\n        System.err.println(Thread.currentThread().getContextClassLoader().getClass().getName());\n        Properties p = System.getProperties();\n        for (Object key : p.keySet()) {\n            Object value = p.get(key);\n            System.err.print(\"[InfoClassLoaderFilter] \");\n            System.err.print(key);\n            System.err.print(\": \");\n            System.err.println(value);\n        }\n        return false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/net/sourceforge/jiprof/instrument/clfilter/InfoTest0.java",
		"test_prompt": "// InfoTest0.java\npackage net.sourceforge.jiprof.instrument.clfilter;\n\nimport java.util.Properties;\nimport com.mentorgen.tools.profile.instrument.clfilter.ClassLoaderFilter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Info}.\n* It contains ten unit test cases for the {@link Info#accept(ClassLoader)} method.\n*/\nclass InfoTest0 {"
	},
	{
		"original_code": "// Info.java\n/*\nCopyright (c) 2007, Andrew Wilcox\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions are met:\n\n+ Redistributions of source code must retain the above copyright notice, \n  this list of conditions and the following disclaimer.\n+ Redistributions in binary form must reproduce the above copyright notice, \n  this list of conditions and the following disclaimer in the documentation \n  and/or other materials provided with the distribution.\n+ Neither the name Andrew Wilcox nor the names of its contributors may be \n  used to endorse or promote products derived from this software without \n  specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \n  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE \n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \n  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \n  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \n  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n  POSSIBILITY OF SUCH DAMAGE.\n */\npackage net.sourceforge.jiprof.instrument.clfilter;\n\nimport java.util.Properties;\nimport com.mentorgen.tools.profile.instrument.clfilter.ClassLoaderFilter;\n\npublic class Info implements ClassLoaderFilter {\n\n    public boolean accept(ClassLoader loader) {\n        return false;\n    }\n\n    public boolean canFilter() {\n        System.err.print(\"--> classloader: \");\n        System.err.println(Thread.currentThread().getContextClassLoader().getClass().getName());\n        Properties p = System.getProperties();\n        for (Object key : p.keySet()) {\n            Object value = p.get(key);\n            System.err.print(\"[InfoClassLoaderFilter] \");\n            System.err.print(key);\n            System.err.print(\": \");\n            System.err.println(value);\n        }\n        return false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/net/sourceforge/jiprof/instrument/clfilter/InfoTest1.java",
		"test_prompt": "// InfoTest1.java\npackage net.sourceforge.jiprof.instrument.clfilter;\n\nimport java.util.Properties;\nimport com.mentorgen.tools.profile.instrument.clfilter.ClassLoaderFilter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Info}.\n* It contains ten unit test cases for the {@link Info#canFilter()} method.\n*/\nclass InfoTest1 {"
	},
	{
		"original_code": "// JBossUniversalClassLoaderFilter.java\n/*\nCopyright (c) 2007, Andrew Wilcox\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions are met:\n\n+ Redistributions of source code must retain the above copyright notice, \n  this list of conditions and the following disclaimer.\n+ Redistributions in binary form must reproduce the above copyright notice, \n  this list of conditions and the following disclaimer in the documentation \n  and/or other materials provided with the distribution.\n+ Neither the name Andrew Wilcox nor the names of its contributors may be \n  used to endorse or promote products derived from this software without \n  specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \n  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE \n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \n  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \n  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \n  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n  POSSIBILITY OF SUCH DAMAGE.\n */\npackage net.sourceforge.jiprof.instrument.clfilter;\n\nimport com.mentorgen.tools.profile.instrument.clfilter.ClassLoaderFilter;\n\n/**\n * This class has only been tested with JBoss 4.0.4 GA\n * @author andrew\n */\npublic class JBossUniversalClassLoaderFilter implements ClassLoaderFilter {\n\n    private static final String[] CLASSLOADERS = new String[] { \"org.jboss.mx.loading.UnifiedClassLoader3\", \"org.jboss.web.tomcat.tc5.WebAppClassLoader\" };\n\n    public boolean accept(ClassLoader loader) {\n        for (String classloader : CLASSLOADERS) {\n            if (loader.getClass().getName().equals(classloader)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public boolean canFilter() {\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/net/sourceforge/jiprof/instrument/clfilter/JBossUniversalClassLoaderFilterTest0.java",
		"test_prompt": "// JBossUniversalClassLoaderFilterTest0.java\npackage net.sourceforge.jiprof.instrument.clfilter;\n\nimport com.mentorgen.tools.profile.instrument.clfilter.ClassLoaderFilter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JBossUniversalClassLoaderFilter}.\n* It contains ten unit test cases for the {@link JBossUniversalClassLoaderFilter#accept(ClassLoader)} method.\n*/\nclass JBossUniversalClassLoaderFilterTest0 {"
	},
	{
		"original_code": "// JBossUniversalClassLoaderFilter.java\n/*\nCopyright (c) 2007, Andrew Wilcox\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions are met:\n\n+ Redistributions of source code must retain the above copyright notice, \n  this list of conditions and the following disclaimer.\n+ Redistributions in binary form must reproduce the above copyright notice, \n  this list of conditions and the following disclaimer in the documentation \n  and/or other materials provided with the distribution.\n+ Neither the name Andrew Wilcox nor the names of its contributors may be \n  used to endorse or promote products derived from this software without \n  specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \n  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE \n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \n  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \n  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \n  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n  POSSIBILITY OF SUCH DAMAGE.\n */\npackage net.sourceforge.jiprof.instrument.clfilter;\n\nimport com.mentorgen.tools.profile.instrument.clfilter.ClassLoaderFilter;\n\n/**\n * This class has only been tested with JBoss 4.0.4 GA\n * @author andrew\n */\npublic class JBossUniversalClassLoaderFilter implements ClassLoaderFilter {\n\n    private static final String[] CLASSLOADERS = new String[] { \"org.jboss.mx.loading.UnifiedClassLoader3\", \"org.jboss.web.tomcat.tc5.WebAppClassLoader\" };\n\n    public boolean accept(ClassLoader loader) {\n        for (String classloader : CLASSLOADERS) {\n            if (loader.getClass().getName().equals(classloader)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public boolean canFilter() {\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/net/sourceforge/jiprof/instrument/clfilter/JBossUniversalClassLoaderFilterTest1.java",
		"test_prompt": "// JBossUniversalClassLoaderFilterTest1.java\npackage net.sourceforge.jiprof.instrument.clfilter;\n\nimport com.mentorgen.tools.profile.instrument.clfilter.ClassLoaderFilter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JBossUniversalClassLoaderFilter}.\n* It contains ten unit test cases for the {@link JBossUniversalClassLoaderFilter#canFilter()} method.\n*/\nclass JBossUniversalClassLoaderFilterTest1 {"
	},
	{
		"original_code": "// EclipseOSGIClassLoaderFilter.java\npackage net.sourceforge.jiprof.instrument.clfilter;\n\nimport com.mentorgen.tools.profile.instrument.clfilter.ClassLoaderFilter;\n\npublic class EclipseOSGIClassLoaderFilter implements ClassLoaderFilter {\n\n    private static final String CLASSLOADER = \"org.eclipse.osgi.internal.baseadaptor.DefaultClassLoader\";\n\n    public boolean accept(ClassLoader loader) {\n        return loader.getClass().getName().equals(CLASSLOADER);\n    }\n\n    public boolean canFilter() {\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/net/sourceforge/jiprof/instrument/clfilter/EclipseOSGIClassLoaderFilterTest0.java",
		"test_prompt": "// EclipseOSGIClassLoaderFilterTest0.java\npackage net.sourceforge.jiprof.instrument.clfilter;\n\nimport com.mentorgen.tools.profile.instrument.clfilter.ClassLoaderFilter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EclipseOSGIClassLoaderFilter}.\n* It contains ten unit test cases for the {@link EclipseOSGIClassLoaderFilter#accept(ClassLoader)} method.\n*/\nclass EclipseOSGIClassLoaderFilterTest0 {"
	},
	{
		"original_code": "// EclipseOSGIClassLoaderFilter.java\npackage net.sourceforge.jiprof.instrument.clfilter;\n\nimport com.mentorgen.tools.profile.instrument.clfilter.ClassLoaderFilter;\n\npublic class EclipseOSGIClassLoaderFilter implements ClassLoaderFilter {\n\n    private static final String CLASSLOADER = \"org.eclipse.osgi.internal.baseadaptor.DefaultClassLoader\";\n\n    public boolean accept(ClassLoader loader) {\n        return loader.getClass().getName().equals(CLASSLOADER);\n    }\n\n    public boolean canFilter() {\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/net/sourceforge/jiprof/instrument/clfilter/EclipseOSGIClassLoaderFilterTest1.java",
		"test_prompt": "// EclipseOSGIClassLoaderFilterTest1.java\npackage net.sourceforge.jiprof.instrument.clfilter;\n\nimport com.mentorgen.tools.profile.instrument.clfilter.ClassLoaderFilter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EclipseOSGIClassLoaderFilter}.\n* It contains ten unit test cases for the {@link EclipseOSGIClassLoaderFilter#canFilter()} method.\n*/\nclass EclipseOSGIClassLoaderFilterTest1 {"
	},
	{
		"original_code": "// GenericClassLoaderFilter.java\n/*\nCopyright (c) 2007, Andrew Wilcox\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions are met:\n\n+ Redistributions of source code must retain the above copyright notice, \n  this list of conditions and the following disclaimer.\n+ Redistributions in binary form must reproduce the above copyright notice, \n  this list of conditions and the following disclaimer in the documentation \n  and/or other materials provided with the distribution.\n+ Neither the name Andrew Wilcox nor the names of its contributors may be \n  used to endorse or promote products derived from this software without \n  specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \n  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE \n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \n  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \n  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \n  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n  POSSIBILITY OF SUCH DAMAGE.\n */\npackage net.sourceforge.jiprof.instrument.clfilter;\n\nimport com.mentorgen.tools.profile.Controller;\nimport com.mentorgen.tools.profile.instrument.clfilter.ClassLoaderFilter;\n\npublic class GenericClassLoaderFilter implements ClassLoaderFilter {\n\n    public boolean accept(ClassLoader loader) {\n        for (Class cl : Controller._acceptClassLoaders) {\n            if (cl.isInstance(loader)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public boolean canFilter() {\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/net/sourceforge/jiprof/instrument/clfilter/GenericClassLoaderFilterTest0.java",
		"test_prompt": "// GenericClassLoaderFilterTest0.java\npackage net.sourceforge.jiprof.instrument.clfilter;\n\nimport com.mentorgen.tools.profile.Controller;\nimport com.mentorgen.tools.profile.instrument.clfilter.ClassLoaderFilter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GenericClassLoaderFilter}.\n* It contains ten unit test cases for the {@link GenericClassLoaderFilter#accept(ClassLoader)} method.\n*/\nclass GenericClassLoaderFilterTest0 {"
	},
	{
		"original_code": "// GenericClassLoaderFilter.java\n/*\nCopyright (c) 2007, Andrew Wilcox\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions are met:\n\n+ Redistributions of source code must retain the above copyright notice, \n  this list of conditions and the following disclaimer.\n+ Redistributions in binary form must reproduce the above copyright notice, \n  this list of conditions and the following disclaimer in the documentation \n  and/or other materials provided with the distribution.\n+ Neither the name Andrew Wilcox nor the names of its contributors may be \n  used to endorse or promote products derived from this software without \n  specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \n  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE \n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \n  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \n  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \n  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n  POSSIBILITY OF SUCH DAMAGE.\n */\npackage net.sourceforge.jiprof.instrument.clfilter;\n\nimport com.mentorgen.tools.profile.Controller;\nimport com.mentorgen.tools.profile.instrument.clfilter.ClassLoaderFilter;\n\npublic class GenericClassLoaderFilter implements ClassLoaderFilter {\n\n    public boolean accept(ClassLoader loader) {\n        for (Class cl : Controller._acceptClassLoaders) {\n            if (cl.isInstance(loader)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public boolean canFilter() {\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/net/sourceforge/jiprof/instrument/clfilter/GenericClassLoaderFilterTest1.java",
		"test_prompt": "// GenericClassLoaderFilterTest1.java\npackage net.sourceforge.jiprof.instrument.clfilter;\n\nimport com.mentorgen.tools.profile.Controller;\nimport com.mentorgen.tools.profile.instrument.clfilter.ClassLoaderFilter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GenericClassLoaderFilter}.\n* It contains ten unit test cases for the {@link GenericClassLoaderFilter#canFilter()} method.\n*/\nclass GenericClassLoaderFilterTest1 {"
	},
	{
		"original_code": "// JBossServletClassLoaderFilter.java\n/*\nCopyright (c) 2007, Andrew Wilcox\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions are met:\n\n+ Redistributions of source code must retain the above copyright notice, \n  this list of conditions and the following disclaimer.\n+ Redistributions in binary form must reproduce the above copyright notice, \n  this list of conditions and the following disclaimer in the documentation \n  and/or other materials provided with the distribution.\n+ Neither the name Andrew Wilcox nor the names of its contributors may be \n  used to endorse or promote products derived from this software without \n  specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \n  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE \n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \n  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \n  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \n  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n  POSSIBILITY OF SUCH DAMAGE.\n */\npackage net.sourceforge.jiprof.instrument.clfilter;\n\nimport com.mentorgen.tools.profile.instrument.clfilter.ClassLoaderFilter;\n\n/**\n * This class has only been tested with JBoss 4.0.4 GA\n * @author andrew\n */\npublic class JBossServletClassLoaderFilter implements ClassLoaderFilter {\n\n    private static final String CLASSLOADER = \"org.jboss.web.tomcat.tc5.WebAppClassLoader\";\n\n    public boolean accept(ClassLoader loader) {\n        return loader.getClass().getName().equals(CLASSLOADER);\n    }\n\n    public boolean canFilter() {\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/net/sourceforge/jiprof/instrument/clfilter/JBossServletClassLoaderFilterTest0.java",
		"test_prompt": "// JBossServletClassLoaderFilterTest0.java\npackage net.sourceforge.jiprof.instrument.clfilter;\n\nimport com.mentorgen.tools.profile.instrument.clfilter.ClassLoaderFilter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JBossServletClassLoaderFilter}.\n* It contains ten unit test cases for the {@link JBossServletClassLoaderFilter#accept(ClassLoader)} method.\n*/\nclass JBossServletClassLoaderFilterTest0 {"
	},
	{
		"original_code": "// JBossServletClassLoaderFilter.java\n/*\nCopyright (c) 2007, Andrew Wilcox\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions are met:\n\n+ Redistributions of source code must retain the above copyright notice, \n  this list of conditions and the following disclaimer.\n+ Redistributions in binary form must reproduce the above copyright notice, \n  this list of conditions and the following disclaimer in the documentation \n  and/or other materials provided with the distribution.\n+ Neither the name Andrew Wilcox nor the names of its contributors may be \n  used to endorse or promote products derived from this software without \n  specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \n  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE \n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \n  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \n  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \n  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n  POSSIBILITY OF SUCH DAMAGE.\n */\npackage net.sourceforge.jiprof.instrument.clfilter;\n\nimport com.mentorgen.tools.profile.instrument.clfilter.ClassLoaderFilter;\n\n/**\n * This class has only been tested with JBoss 4.0.4 GA\n * @author andrew\n */\npublic class JBossServletClassLoaderFilter implements ClassLoaderFilter {\n\n    private static final String CLASSLOADER = \"org.jboss.web.tomcat.tc5.WebAppClassLoader\";\n\n    public boolean accept(ClassLoader loader) {\n        return loader.getClass().getName().equals(CLASSLOADER);\n    }\n\n    public boolean canFilter() {\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/net/sourceforge/jiprof/instrument/clfilter/JBossServletClassLoaderFilterTest1.java",
		"test_prompt": "// JBossServletClassLoaderFilterTest1.java\npackage net.sourceforge.jiprof.instrument.clfilter;\n\nimport com.mentorgen.tools.profile.instrument.clfilter.ClassLoaderFilter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JBossServletClassLoaderFilter}.\n* It contains ten unit test cases for the {@link JBossServletClassLoaderFilter#canFilter()} method.\n*/\nclass JBossServletClassLoaderFilterTest1 {"
	},
	{
		"original_code": "// JBossEJBClassLoaderFilter.java\n/*\nCopyright (c) 2007, Andrew Wilcox\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions are met:\n\n+ Redistributions of source code must retain the above copyright notice, \n  this list of conditions and the following disclaimer.\n+ Redistributions in binary form must reproduce the above copyright notice, \n  this list of conditions and the following disclaimer in the documentation \n  and/or other materials provided with the distribution.\n+ Neither the name Andrew Wilcox nor the names of its contributors may be \n  used to endorse or promote products derived from this software without \n  specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \n  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE \n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \n  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \n  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \n  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n  POSSIBILITY OF SUCH DAMAGE.\n */\npackage net.sourceforge.jiprof.instrument.clfilter;\n\nimport com.mentorgen.tools.profile.instrument.clfilter.ClassLoaderFilter;\n\n/**\n * This class has only been tested with JBoss 4.0.4 GA\n * @author andrew\n */\npublic class JBossEJBClassLoaderFilter implements ClassLoaderFilter {\n\n    private static final String CLASSLOADER = \"org.jboss.mx.loading.UnifiedClassLoader3\";\n\n    public boolean accept(ClassLoader loader) {\n        return loader.getClass().getName().equals(CLASSLOADER);\n    }\n\n    public boolean canFilter() {\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/net/sourceforge/jiprof/instrument/clfilter/JBossEJBClassLoaderFilterTest0.java",
		"test_prompt": "// JBossEJBClassLoaderFilterTest0.java\npackage net.sourceforge.jiprof.instrument.clfilter;\n\nimport com.mentorgen.tools.profile.instrument.clfilter.ClassLoaderFilter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JBossEJBClassLoaderFilter}.\n* It contains ten unit test cases for the {@link JBossEJBClassLoaderFilter#accept(ClassLoader)} method.\n*/\nclass JBossEJBClassLoaderFilterTest0 {"
	},
	{
		"original_code": "// JBossEJBClassLoaderFilter.java\n/*\nCopyright (c) 2007, Andrew Wilcox\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions are met:\n\n+ Redistributions of source code must retain the above copyright notice, \n  this list of conditions and the following disclaimer.\n+ Redistributions in binary form must reproduce the above copyright notice, \n  this list of conditions and the following disclaimer in the documentation \n  and/or other materials provided with the distribution.\n+ Neither the name Andrew Wilcox nor the names of its contributors may be \n  used to endorse or promote products derived from this software without \n  specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \n  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE \n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \n  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \n  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \n  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n  POSSIBILITY OF SUCH DAMAGE.\n */\npackage net.sourceforge.jiprof.instrument.clfilter;\n\nimport com.mentorgen.tools.profile.instrument.clfilter.ClassLoaderFilter;\n\n/**\n * This class has only been tested with JBoss 4.0.4 GA\n * @author andrew\n */\npublic class JBossEJBClassLoaderFilter implements ClassLoaderFilter {\n\n    private static final String CLASSLOADER = \"org.jboss.mx.loading.UnifiedClassLoader3\";\n\n    public boolean accept(ClassLoader loader) {\n        return loader.getClass().getName().equals(CLASSLOADER);\n    }\n\n    public boolean canFilter() {\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/net/sourceforge/jiprof/instrument/clfilter/JBossEJBClassLoaderFilterTest1.java",
		"test_prompt": "// JBossEJBClassLoaderFilterTest1.java\npackage net.sourceforge.jiprof.instrument.clfilter;\n\nimport com.mentorgen.tools.profile.instrument.clfilter.ClassLoaderFilter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JBossEJBClassLoaderFilter}.\n* It contains ten unit test cases for the {@link JBossEJBClassLoaderFilter#canFilter()} method.\n*/\nclass JBossEJBClassLoaderFilterTest1 {"
	},
	{
		"original_code": "// MethodWriter.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\n/**\n * A {@link MethodVisitor} that generates methods in bytecode form. Each visit\n * method of this class appends the bytecode corresponding to the visited\n * instruction to a byte vector, in the order these methods are called.\n *\n * @author Eric Bruneton\n * @author Eugene Kuleshov\n */\nclass MethodWriter implements MethodVisitor {\n\n    /**\n     * Pseudo access flag used to denote constructors.\n     */\n    static final int ACC_CONSTRUCTOR = 262144;\n\n    /**\n     * Frame has exactly the same locals as the previous stack map frame and\n     * number of stack items is zero.\n     */\n    // to 63 (0-3f)\n    static final int SAME_FRAME = 0;\n\n    /**\n     * Frame has exactly the same locals as the previous stack map frame and\n     * number of stack items is 1\n     */\n    // to 127 (40-7f)\n    static final int SAME_LOCALS_1_STACK_ITEM_FRAME = 64;\n\n    /**\n     * Reserved for future use\n     */\n    static final int RESERVED = 128;\n\n    /**\n     * Frame has exactly the same locals as the previous stack map frame and\n     * number of stack items is 1. Offset is bigger then 63;\n     */\n    // f7\n    static final int SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED = 247;\n\n    /**\n     * Frame where current locals are the same as the locals in the previous\n     * frame, except that the k last locals are absent. The value of k is given\n     * by the formula 251-frame_type.\n     */\n    // to 250 (f8-fA)\n    static final int CHOP_FRAME = 248;\n\n    /**\n     * Frame has exactly the same locals as the previous stack map frame and\n     * number of stack items is zero. Offset is bigger then 63;\n     */\n    // fb\n    static final int SAME_FRAME_EXTENDED = 251;\n\n    /**\n     * Frame where current locals are the same as the locals in the previous\n     * frame, except that k additional locals are defined. The value of k is\n     * given by the formula frame_type-251.\n     */\n    // to 254 // fc-fe\n    static final int APPEND_FRAME = 252;\n\n    /**\n     * Full frame\n     */\n    // ff\n    static final int FULL_FRAME = 255;\n\n    /**\n     * Indicates that the stack map frames must be recomputed from scratch. In\n     * this case the maximum stack size and number of local variables is also\n     * recomputed from scratch.\n     *\n     * @see #compute\n     */\n    private static final int FRAMES = 0;\n\n    /**\n     * Indicates that the maximum stack size and number of local variables must\n     * be automatically computed.\n     *\n     * @see #compute\n     */\n    private static final int MAXS = 1;\n\n    /**\n     * Indicates that nothing must be automatically computed.\n     *\n     * @see #compute\n     */\n    private static final int NOTHING = 2;\n\n    /**\n     * Next method writer (see {@link ClassWriter#firstMethod firstMethod}).\n     */\n    MethodWriter next;\n\n    /**\n     * The class writer to which this method must be added.\n     */\n    final ClassWriter cw;\n\n    /**\n     * Access flags of this method.\n     */\n    private int access;\n\n    /**\n     * The index of the constant pool item that contains the name of this\n     * method.\n     */\n    private final int name;\n\n    /**\n     * The index of the constant pool item that contains the descriptor of this\n     * method.\n     */\n    private final int desc;\n\n    /**\n     * The descriptor of this method.\n     */\n    private final String descriptor;\n\n    /**\n     * The signature of this method.\n     */\n    String signature;\n\n    /**\n     * If not zero, indicates that the code of this method must be copied from\n     * the ClassReader associated to this writer in <code>cw.cr</code>. More\n     * precisely, this field gives the index of the first byte to copied from\n     * <code>cw.cr.b</code>.\n     */\n    int classReaderOffset;\n\n    /**\n     * If not zero, indicates that the code of this method must be copied from\n     * the ClassReader associated to this writer in <code>cw.cr</code>. More\n     * precisely, this field gives the number of bytes to copied from\n     * <code>cw.cr.b</code>.\n     */\n    int classReaderLength;\n\n    /**\n     * Number of exceptions that can be thrown by this method.\n     */\n    int exceptionCount;\n\n    /**\n     * The exceptions that can be thrown by this method. More precisely, this\n     * array contains the indexes of the constant pool items that contain the\n     * internal names of these exception classes.\n     */\n    int[] exceptions;\n\n    /**\n     * The annotation default attribute of this method. May be <tt>null</tt>.\n     */\n    private ByteVector annd;\n\n    /**\n     * The runtime visible annotations of this method. May be <tt>null</tt>.\n     */\n    private AnnotationWriter anns;\n\n    /**\n     * The runtime invisible annotations of this method. May be <tt>null</tt>.\n     */\n    private AnnotationWriter ianns;\n\n    /**\n     * The runtime visible parameter annotations of this method. May be\n     * <tt>null</tt>.\n     */\n    private AnnotationWriter[] panns;\n\n    /**\n     * The runtime invisible parameter annotations of this method. May be\n     * <tt>null</tt>.\n     */\n    private AnnotationWriter[] ipanns;\n\n    /**\n     * The number of synthetic parameters of this method.\n     */\n    private int synthetics;\n\n    /**\n     * The non standard attributes of the method.\n     */\n    private Attribute attrs;\n\n    /**\n     * The bytecode of this method.\n     */\n    private ByteVector code = new ByteVector();\n\n    /**\n     * Maximum stack size of this method.\n     */\n    private int maxStack;\n\n    /**\n     * Maximum number of local variables for this method.\n     */\n    private int maxLocals;\n\n    /**\n     * Number of stack map frames in the StackMapTable attribute.\n     */\n    private int frameCount;\n\n    /**\n     * The StackMapTable attribute.\n     */\n    private ByteVector stackMap;\n\n    /**\n     * The offset of the last frame that was written in the StackMapTable\n     * attribute.\n     */\n    private int previousFrameOffset;\n\n    /**\n     * The last frame that was written in the StackMapTable attribute.\n     *\n     * @see #frame\n     */\n    private int[] previousFrame;\n\n    /**\n     * Index of the next element to be added in {@link #frame}.\n     */\n    private int frameIndex;\n\n    /**\n     * The current stack map frame. The first element contains the offset of the\n     * instruction to which the frame corresponds, the second element is the\n     * number of locals and the third one is the number of stack elements. The\n     * local variables start at index 3 and are followed by the operand stack\n     * values. In summary frame[0] = offset, frame[1] = nLocal, frame[2] =\n     * nStack, frame[3] = nLocal. All types are encoded as integers, with the\n     * same format as the one used in {@link Label}, but limited to BASE types.\n     */\n    private int[] frame;\n\n    /**\n     * Number of elements in the exception handler list.\n     */\n    private int handlerCount;\n\n    /**\n     * The first element in the exception handler list.\n     */\n    private Handler firstHandler;\n\n    /**\n     * The last element in the exception handler list.\n     */\n    private Handler lastHandler;\n\n    /**\n     * Number of entries in the LocalVariableTable attribute.\n     */\n    private int localVarCount;\n\n    /**\n     * The LocalVariableTable attribute.\n     */\n    private ByteVector localVar;\n\n    /**\n     * Number of entries in the LocalVariableTypeTable attribute.\n     */\n    private int localVarTypeCount;\n\n    /**\n     * The LocalVariableTypeTable attribute.\n     */\n    private ByteVector localVarType;\n\n    /**\n     * Number of entries in the LineNumberTable attribute.\n     */\n    private int lineNumberCount;\n\n    /**\n     * The LineNumberTable attribute.\n     */\n    private ByteVector lineNumber;\n\n    /**\n     * The non standard attributes of the method's code.\n     */\n    private Attribute cattrs;\n\n    /**\n     * Indicates if some jump instructions are too small and need to be resized.\n     */\n    private boolean resize;\n\n    /**\n     * The number of subroutines in this method.\n     */\n    private int subroutines;\n\n    // ------------------------------------------------------------------------\n    /*\n     * Fields for the control flow graph analysis algorithm (used to compute the\n     * maximum stack size). A control flow graph contains one node per \"basic\n     * block\", and one edge per \"jump\" from one basic block to another. Each\n     * node (i.e., each basic block) is represented by the Label object that\n     * corresponds to the first instruction of this basic block. Each node also\n     * stores the list of its successors in the graph, as a linked list of Edge\n     * objects.\n     */\n    /**\n     * Indicates what must be automatically computed.\n     *\n     * @see #FRAMES\n     * @see #MAXS\n     * @see #NOTHING\n     */\n    private final int compute;\n\n    /**\n     * A list of labels. This list is the list of basic blocks in the method,\n     * i.e. a list of Label objects linked to each other by their\n     * {@link Label#successor} field, in the order they are visited by\n     * {@link MethodVisitor#visitLabel}, and starting with the first basic block.\n     */\n    private Label labels;\n\n    /**\n     * The previous basic block.\n     */\n    private Label previousBlock;\n\n    /**\n     * The current basic block.\n     */\n    private Label currentBlock;\n\n    /**\n     * The (relative) stack size after the last visited instruction. This size\n     * is relative to the beginning of the current basic block, i.e., the true\n     * stack size after the last visited instruction is equal to the\n     * {@link Label#inputStackTop beginStackSize} of the current basic block\n     * plus <tt>stackSize</tt>.\n     */\n    private int stackSize;\n\n    /**\n     * The (relative) maximum stack size after the last visited instruction.\n     * This size is relative to the beginning of the current basic block, i.e.,\n     * the true maximum stack size after the last visited instruction is equal\n     * to the {@link Label#inputStackTop beginStackSize} of the current basic\n     * block plus <tt>stackSize</tt>.\n     */\n    private int maxStackSize;\n\n    // ------------------------------------------------------------------------\n    // Constructor\n    // ------------------------------------------------------------------------\n    /**\n     * Constructs a new {@link MethodWriter}.\n     *\n     * @param cw the class writer in which the method must be added.\n     * @param access the method's access flags (see {@link Opcodes}).\n     * @param name the method's name.\n     * @param desc the method's descriptor (see {@link Type}).\n     * @param signature the method's signature. May be <tt>null</tt>.\n     * @param exceptions the internal names of the method's exceptions. May be\n     *        <tt>null</tt>.\n     * @param computeMaxs <tt>true</tt> if the maximum stack size and number\n     *        of local variables must be automatically computed.\n     * @param computeFrames <tt>true</tt> if the stack map tables must be\n     *        recomputed from scratch.\n     */\n    MethodWriter(final ClassWriter cw, final int access, final String name, final String desc, final String signature, final String[] exceptions, final boolean computeMaxs, final boolean computeFrames) {\n        if (cw.firstMethod == null) {\n            cw.firstMethod = this;\n        } else {\n            cw.lastMethod.next = this;\n        }\n        cw.lastMethod = this;\n        this.cw = cw;\n        this.access = access;\n        this.name = cw.newUTF8(name);\n        this.desc = cw.newUTF8(desc);\n        this.descriptor = desc;\n        if (ClassReader.SIGNATURES) {\n            this.signature = signature;\n        }\n        if (exceptions != null && exceptions.length > 0) {\n            exceptionCount = exceptions.length;\n            this.exceptions = new int[exceptionCount];\n            for (int i = 0; i < exceptionCount; ++i) {\n                this.exceptions[i] = cw.newClass(exceptions[i]);\n            }\n        }\n        this.compute = computeFrames ? FRAMES : (computeMaxs ? MAXS : NOTHING);\n        if (computeMaxs || computeFrames) {\n            if (computeFrames && \"<init>\".equals(name)) {\n                this.access |= ACC_CONSTRUCTOR;\n            }\n            // updates maxLocals\n            int size = Type.getArgumentsAndReturnSizes(descriptor) >> 2;\n            if ((access & Opcodes.ACC_STATIC) != 0) {\n                --size;\n            }\n            maxLocals = size;\n            // creates and visits the label for the first basic block\n            labels = new Label();\n            labels.status |= Label.PUSHED;\n            visitLabel(labels);\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Implementation of the MethodVisitor interface\n    // ------------------------------------------------------------------------\n    public AnnotationVisitor visitAnnotationDefault() {\n        if (!ClassReader.ANNOTATIONS) {\n            return null;\n        }\n        annd = new ByteVector();\n        return new AnnotationWriter(cw, false, annd, null, 0);\n    }\n\n    public AnnotationVisitor visitAnnotation(final String desc, final boolean visible) {\n        if (!ClassReader.ANNOTATIONS) {\n            return null;\n        }\n        ByteVector bv = new ByteVector();\n        // write type, and reserve space for values count\n        bv.putShort(cw.newUTF8(desc)).putShort(0);\n        AnnotationWriter aw = new AnnotationWriter(cw, true, bv, bv, 2);\n        if (visible) {\n            aw.next = anns;\n            anns = aw;\n        } else {\n            aw.next = ianns;\n            ianns = aw;\n        }\n        return aw;\n    }\n\n    public AnnotationVisitor visitParameterAnnotation(final int parameter, final String desc, final boolean visible) {\n        if (!ClassReader.ANNOTATIONS) {\n            return null;\n        }\n        ByteVector bv = new ByteVector();\n        if (\"Ljava/lang/Synthetic;\".equals(desc)) {\n            // workaround for a bug in javac with synthetic parameters\n            // see ClassReader.readParameterAnnotations\n            synthetics = Math.max(synthetics, parameter + 1);\n            return new AnnotationWriter(cw, false, bv, null, 0);\n        }\n        // write type, and reserve space for values count\n        bv.putShort(cw.newUTF8(desc)).putShort(0);\n        AnnotationWriter aw = new AnnotationWriter(cw, true, bv, bv, 2);\n        if (visible) {\n            if (panns == null) {\n                panns = new AnnotationWriter[Type.getArgumentTypes(descriptor).length];\n            }\n            aw.next = panns[parameter];\n            panns[parameter] = aw;\n        } else {\n            if (ipanns == null) {\n                ipanns = new AnnotationWriter[Type.getArgumentTypes(descriptor).length];\n            }\n            aw.next = ipanns[parameter];\n            ipanns[parameter] = aw;\n        }\n        return aw;\n    }\n\n    public void visitAttribute(final Attribute attr) {\n        if (attr.isCodeAttribute()) {\n            attr.next = cattrs;\n            cattrs = attr;\n        } else {\n            attr.next = attrs;\n            attrs = attr;\n        }\n    }\n\n    public void visitCode() {\n    }\n\n    public void visitFrame(final int type, final int nLocal, final Object[] local, final int nStack, final Object[] stack) {\n        if (!ClassReader.FRAMES || compute == FRAMES) {\n            return;\n        }\n        if (type == Opcodes.F_NEW) {\n            startFrame(code.length, nLocal, nStack);\n            for (int i = 0; i < nLocal; ++i) {\n                if (local[i] instanceof String) {\n                    frame[frameIndex++] = Frame.OBJECT | cw.addType((String) local[i]);\n                } else if (local[i] instanceof Integer) {\n                    frame[frameIndex++] = ((Integer) local[i]).intValue();\n                } else {\n                    frame[frameIndex++] = Frame.UNINITIALIZED | cw.addUninitializedType(\"\", ((Label) local[i]).position);\n                }\n            }\n            for (int i = 0; i < nStack; ++i) {\n                if (stack[i] instanceof String) {\n                    frame[frameIndex++] = Frame.OBJECT | cw.addType((String) stack[i]);\n                } else if (stack[i] instanceof Integer) {\n                    frame[frameIndex++] = ((Integer) stack[i]).intValue();\n                } else {\n                    frame[frameIndex++] = Frame.UNINITIALIZED | cw.addUninitializedType(\"\", ((Label) stack[i]).position);\n                }\n            }\n            endFrame();\n        } else {\n            int delta;\n            if (stackMap == null) {\n                stackMap = new ByteVector();\n                delta = code.length;\n            } else {\n                delta = code.length - previousFrameOffset - 1;\n                if (delta < 0) {\n                    if (type == Opcodes.F_SAME) {\n                        return;\n                    } else {\n                        throw new IllegalStateException();\n                    }\n                }\n            }\n            switch(type) {\n                case Opcodes.F_FULL:\n                    stackMap.putByte(FULL_FRAME).putShort(delta).putShort(nLocal);\n                    for (int i = 0; i < nLocal; ++i) {\n                        writeFrameType(local[i]);\n                    }\n                    stackMap.putShort(nStack);\n                    for (int i = 0; i < nStack; ++i) {\n                        writeFrameType(stack[i]);\n                    }\n                    break;\n                case Opcodes.F_APPEND:\n                    stackMap.putByte(SAME_FRAME_EXTENDED + nLocal).putShort(delta);\n                    for (int i = 0; i < nLocal; ++i) {\n                        writeFrameType(local[i]);\n                    }\n                    break;\n                case Opcodes.F_CHOP:\n                    stackMap.putByte(SAME_FRAME_EXTENDED - nLocal).putShort(delta);\n                    break;\n                case Opcodes.F_SAME:\n                    if (delta < 64) {\n                        stackMap.putByte(delta);\n                    } else {\n                        stackMap.putByte(SAME_FRAME_EXTENDED).putShort(delta);\n                    }\n                    break;\n                case Opcodes.F_SAME1:\n                    if (delta < 64) {\n                        stackMap.putByte(SAME_LOCALS_1_STACK_ITEM_FRAME + delta);\n                    } else {\n                        stackMap.putByte(SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED).putShort(delta);\n                    }\n                    writeFrameType(stack[0]);\n                    break;\n            }\n            previousFrameOffset = code.length;\n            ++frameCount;\n        }\n    }\n\n    public void visitInsn(final int opcode) {\n        // adds the instruction to the bytecode of the method\n        code.putByte(opcode);\n        // update currentBlock\n        // Label currentBlock = this.currentBlock;\n        if (currentBlock != null) {\n            if (compute == FRAMES) {\n                currentBlock.frame.execute(opcode, 0, null, null);\n            } else {\n                // updates current and max stack sizes\n                int size = stackSize + Frame.SIZE[opcode];\n                if (size > maxStackSize) {\n                    maxStackSize = size;\n                }\n                stackSize = size;\n            }\n            // if opcode == ATHROW or xRETURN, ends current block (no successor)\n            if ((opcode >= Opcodes.IRETURN && opcode <= Opcodes.RETURN) || opcode == Opcodes.ATHROW) {\n                noSuccessor();\n            }\n        }\n    }\n\n    public void visitIntInsn(final int opcode, final int operand) {\n        // Label currentBlock = this.currentBlock;\n        if (currentBlock != null) {\n            if (compute == FRAMES) {\n                currentBlock.frame.execute(opcode, operand, null, null);\n            } else if (opcode != Opcodes.NEWARRAY) {\n                // updates current and max stack sizes only for NEWARRAY\n                // (stack size variation = 0 for BIPUSH or SIPUSH)\n                int size = stackSize + 1;\n                if (size > maxStackSize) {\n                    maxStackSize = size;\n                }\n                stackSize = size;\n            }\n        }\n        // adds the instruction to the bytecode of the method\n        if (opcode == Opcodes.SIPUSH) {\n            code.put12(opcode, operand);\n        } else {\n            // BIPUSH or NEWARRAY\n            code.put11(opcode, operand);\n        }\n    }\n\n    public void visitVarInsn(final int opcode, final int var) {\n        // Label currentBlock = this.currentBlock;\n        if (currentBlock != null) {\n            if (compute == FRAMES) {\n                currentBlock.frame.execute(opcode, var, null, null);\n            } else {\n                // updates current and max stack sizes\n                if (opcode == Opcodes.RET) {\n                    // no stack change, but end of current block (no successor)\n                    currentBlock.status |= Label.RET;\n                    // save 'stackSize' here for future use\n                    // (see {@link #findSubroutineSuccessors})\n                    currentBlock.inputStackTop = stackSize;\n                    noSuccessor();\n                } else {\n                    // xLOAD or xSTORE\n                    int size = stackSize + Frame.SIZE[opcode];\n                    if (size > maxStackSize) {\n                        maxStackSize = size;\n                    }\n                    stackSize = size;\n                }\n            }\n        }\n        if (compute != NOTHING) {\n            // updates max locals\n            int n;\n            if (opcode == Opcodes.LLOAD || opcode == Opcodes.DLOAD || opcode == Opcodes.LSTORE || opcode == Opcodes.DSTORE) {\n                n = var + 2;\n            } else {\n                n = var + 1;\n            }\n            if (n > maxLocals) {\n                maxLocals = n;\n            }\n        }\n        // adds the instruction to the bytecode of the method\n        if (var < 4 && opcode != Opcodes.RET) {\n            int opt;\n            if (opcode < Opcodes.ISTORE) {\n                /* ILOAD_0 */\n                opt = 26 + ((opcode - Opcodes.ILOAD) << 2) + var;\n            } else {\n                /* ISTORE_0 */\n                opt = 59 + ((opcode - Opcodes.ISTORE) << 2) + var;\n            }\n            code.putByte(opt);\n        } else if (var >= 256) {\n            code.putByte(196).put12(opcode, var);\n        } else {\n            code.put11(opcode, var);\n        }\n        if (opcode >= Opcodes.ISTORE && compute == FRAMES && handlerCount > 0) {\n            visitLabel(new Label());\n        }\n    }\n\n    public void visitTypeInsn(final int opcode, final String type) {\n        Item i = cw.newClassItem(type);\n        // Label currentBlock = this.currentBlock;\n        if (currentBlock != null) {\n            if (compute == FRAMES) {\n                currentBlock.frame.execute(opcode, code.length, cw, i);\n            } else if (opcode == Opcodes.NEW) {\n                // updates current and max stack sizes only if opcode == NEW\n                // (no stack change for ANEWARRAY, CHECKCAST, INSTANCEOF)\n                int size = stackSize + 1;\n                if (size > maxStackSize) {\n                    maxStackSize = size;\n                }\n                stackSize = size;\n            }\n        }\n        // adds the instruction to the bytecode of the method\n        code.put12(opcode, i.index);\n    }\n\n    public void visitFieldInsn(final int opcode, final String owner, final String name, final String desc) {\n        Item i = cw.newFieldItem(owner, name, desc);\n        // Label currentBlock = this.currentBlock;\n        if (currentBlock != null) {\n            if (compute == FRAMES) {\n                currentBlock.frame.execute(opcode, 0, cw, i);\n            } else {\n                int size;\n                // computes the stack size variation\n                char c = desc.charAt(0);\n                switch(opcode) {\n                    case Opcodes.GETSTATIC:\n                        size = stackSize + (c == 'D' || c == 'J' ? 2 : 1);\n                        break;\n                    case Opcodes.PUTSTATIC:\n                        size = stackSize + (c == 'D' || c == 'J' ? -2 : -1);\n                        break;\n                    case Opcodes.GETFIELD:\n                        size = stackSize + (c == 'D' || c == 'J' ? 1 : 0);\n                        break;\n                    // case Constants.PUTFIELD:\n                    default:\n                        size = stackSize + (c == 'D' || c == 'J' ? -3 : -2);\n                        break;\n                }\n                // updates current and max stack sizes\n                if (size > maxStackSize) {\n                    maxStackSize = size;\n                }\n                stackSize = size;\n            }\n        }\n        // adds the instruction to the bytecode of the method\n        code.put12(opcode, i.index);\n    }\n\n    public void visitMethodInsn(final int opcode, final String owner, final String name, final String desc) {\n        boolean itf = opcode == Opcodes.INVOKEINTERFACE;\n        Item i = (opcode == Opcodes.INVOKEDYNAMIC) ? cw.newNameTypeItem(name, desc) : cw.newMethodItem(owner, name, desc, itf);\n        int argSize = i.intVal;\n        // Label currentBlock = this.currentBlock;\n        if (currentBlock != null) {\n            if (compute == FRAMES) {\n                currentBlock.frame.execute(opcode, 0, cw, i);\n            } else {\n                /*\n                 * computes the stack size variation. In order not to recompute\n                 * several times this variation for the same Item, we use the\n                 * intVal field of this item to store this variation, once it\n                 * has been computed. More precisely this intVal field stores\n                 * the sizes of the arguments and of the return value\n                 * corresponding to desc.\n                 */\n                if (argSize == 0) {\n                    // the above sizes have not been computed yet,\n                    // so we compute them...\n                    argSize = Type.getArgumentsAndReturnSizes(desc);\n                    // ... and we save them in order\n                    // not to recompute them in the future\n                    i.intVal = argSize;\n                }\n                int size;\n                if (opcode == Opcodes.INVOKESTATIC || opcode == Opcodes.INVOKEDYNAMIC) {\n                    size = stackSize - (argSize >> 2) + (argSize & 0x03) + 1;\n                } else {\n                    size = stackSize - (argSize >> 2) + (argSize & 0x03);\n                }\n                // updates current and max stack sizes\n                if (size > maxStackSize) {\n                    maxStackSize = size;\n                }\n                stackSize = size;\n            }\n        }\n        // adds the instruction to the bytecode of the method\n        if (itf) {\n            if (argSize == 0) {\n                argSize = Type.getArgumentsAndReturnSizes(desc);\n                i.intVal = argSize;\n            }\n            code.put12(Opcodes.INVOKEINTERFACE, i.index).put11(argSize >> 2, 0);\n        } else {\n            code.put12(opcode, i.index);\n            if (opcode == Opcodes.INVOKEDYNAMIC) {\n                code.putShort(0);\n            }\n        }\n    }\n\n    public void visitJumpInsn(final int opcode, final Label label) {\n        Label nextInsn = null;\n        // Label currentBlock = this.currentBlock;\n        if (currentBlock != null) {\n            if (compute == FRAMES) {\n                currentBlock.frame.execute(opcode, 0, null, null);\n                // 'label' is the target of a jump instruction\n                label.getFirst().status |= Label.TARGET;\n                // adds 'label' as a successor of this basic block\n                addSuccessor(Edge.NORMAL, label);\n                if (opcode != Opcodes.GOTO) {\n                    // creates a Label for the next basic block\n                    nextInsn = new Label();\n                }\n            } else {\n                if (opcode == Opcodes.JSR) {\n                    if ((label.status & Label.SUBROUTINE) == 0) {\n                        label.status |= Label.SUBROUTINE;\n                        ++subroutines;\n                    }\n                    currentBlock.status |= Label.JSR;\n                    addSuccessor(stackSize + 1, label);\n                    // creates a Label for the next basic block\n                    nextInsn = new Label();\n                    /*\n                     * note that, by construction in this method, a JSR block\n                     * has at least two successors in the control flow graph:\n                     * the first one leads the next instruction after the JSR,\n                     * while the second one leads to the JSR target.\n                     */\n                } else {\n                    // updates current stack size (max stack size unchanged\n                    // because stack size variation always negative in this\n                    // case)\n                    stackSize += Frame.SIZE[opcode];\n                    addSuccessor(stackSize, label);\n                }\n            }\n        }\n        // adds the instruction to the bytecode of the method\n        if ((label.status & Label.RESOLVED) != 0 && label.position - code.length < Short.MIN_VALUE) {\n            /*\n             * case of a backward jump with an offset < -32768. In this case we\n             * automatically replace GOTO with GOTO_W, JSR with JSR_W and IFxxx\n             * <l> with IFNOTxxx <l'> GOTO_W <l>, where IFNOTxxx is the\n             * \"opposite\" opcode of IFxxx (i.e., IFNE for IFEQ) and where <l'>\n             * designates the instruction just after the GOTO_W.\n             */\n            if (opcode == Opcodes.GOTO) {\n                // GOTO_W\n                code.putByte(200);\n            } else if (opcode == Opcodes.JSR) {\n                // JSR_W\n                code.putByte(201);\n            } else {\n                // if the IF instruction is transformed into IFNOT GOTO_W the\n                // next instruction becomes the target of the IFNOT instruction\n                if (nextInsn != null) {\n                    nextInsn.status |= Label.TARGET;\n                }\n                code.putByte(opcode <= 166 ? ((opcode + 1) ^ 1) - 1 : opcode ^ 1);\n                // jump offset\n                code.putShort(8);\n                // GOTO_W\n                code.putByte(200);\n            }\n            label.put(this, code, code.length - 1, true);\n        } else {\n            /*\n             * case of a backward jump with an offset >= -32768, or of a forward\n             * jump with, of course, an unknown offset. In these cases we store\n             * the offset in 2 bytes (which will be increased in\n             * resizeInstructions, if needed).\n             */\n            code.putByte(opcode);\n            label.put(this, code, code.length - 1, false);\n        }\n        if (currentBlock != null) {\n            if (nextInsn != null) {\n                // if the jump instruction is not a GOTO, the next instruction\n                // is also a successor of this instruction. Calling visitLabel\n                // adds the label of this next instruction as a successor of the\n                // current block, and starts a new basic block\n                visitLabel(nextInsn);\n            }\n            if (opcode == Opcodes.GOTO) {\n                noSuccessor();\n            }\n        }\n    }\n\n    public void visitLabel(final Label label) {\n        // resolves previous forward references to label, if any\n        resize |= label.resolve(this, code.length, code.data);\n        // updates currentBlock\n        if ((label.status & Label.DEBUG) != 0) {\n            return;\n        }\n        if (compute == FRAMES) {\n            if (currentBlock != null) {\n                if (label.position == currentBlock.position) {\n                    // successive labels, do not start a new basic block\n                    currentBlock.status |= (label.status & Label.TARGET);\n                    label.frame = currentBlock.frame;\n                    return;\n                }\n                // ends current block (with one new successor)\n                addSuccessor(Edge.NORMAL, label);\n            }\n            // begins a new current block\n            currentBlock = label;\n            if (label.frame == null) {\n                label.frame = new Frame();\n                label.frame.owner = label;\n            }\n            // updates the basic block list\n            if (previousBlock != null) {\n                if (label.position == previousBlock.position) {\n                    previousBlock.status |= (label.status & Label.TARGET);\n                    label.frame = previousBlock.frame;\n                    currentBlock = previousBlock;\n                    return;\n                }\n                previousBlock.successor = label;\n            }\n            previousBlock = label;\n        } else if (compute == MAXS) {\n            if (currentBlock != null) {\n                // ends current block (with one new successor)\n                currentBlock.outputStackMax = maxStackSize;\n                addSuccessor(stackSize, label);\n            }\n            // begins a new current block\n            currentBlock = label;\n            // resets the relative current and max stack sizes\n            stackSize = 0;\n            maxStackSize = 0;\n            // updates the basic block list\n            if (previousBlock != null) {\n                previousBlock.successor = label;\n            }\n            previousBlock = label;\n        }\n    }\n\n    public void visitLdcInsn(final Object cst) {\n        Item i = cw.newConstItem(cst);\n        // Label currentBlock = this.currentBlock;\n        if (currentBlock != null) {\n            if (compute == FRAMES) {\n                currentBlock.frame.execute(Opcodes.LDC, 0, cw, i);\n            } else {\n                int size;\n                // computes the stack size variation\n                if (i.type == ClassWriter.LONG || i.type == ClassWriter.DOUBLE) {\n                    size = stackSize + 2;\n                } else {\n                    size = stackSize + 1;\n                }\n                // updates current and max stack sizes\n                if (size > maxStackSize) {\n                    maxStackSize = size;\n                }\n                stackSize = size;\n            }\n        }\n        // adds the instruction to the bytecode of the method\n        int index = i.index;\n        if (i.type == ClassWriter.LONG || i.type == ClassWriter.DOUBLE) {\n            code.put12(20, /* LDC2_W */\n            index);\n        } else if (index >= 256) {\n            code.put12(19, /* LDC_W */\n            index);\n        } else {\n            code.put11(Opcodes.LDC, index);\n        }\n    }\n\n    public void visitIincInsn(final int var, final int increment) {\n        if (currentBlock != null) {\n            if (compute == FRAMES) {\n                currentBlock.frame.execute(Opcodes.IINC, var, null, null);\n            }\n        }\n        if (compute != NOTHING) {\n            // updates max locals\n            int n = var + 1;\n            if (n > maxLocals) {\n                maxLocals = n;\n            }\n        }\n        // adds the instruction to the bytecode of the method\n        if ((var > 255) || (increment > 127) || (increment < -128)) {\n            code.putByte(196).put12(Opcodes.IINC, var).putShort(increment);\n        } else {\n            code.putByte(Opcodes.IINC).put11(var, increment);\n        }\n    }\n\n    public void visitTableSwitchInsn(final int min, final int max, final Label dflt, final Label[] labels) {\n        // adds the instruction to the bytecode of the method\n        int source = code.length;\n        code.putByte(Opcodes.TABLESWITCH);\n        code.putByteArray(null, 0, (4 - code.length % 4) % 4);\n        dflt.put(this, code, source, true);\n        code.putInt(min).putInt(max);\n        for (int i = 0; i < labels.length; ++i) {\n            labels[i].put(this, code, source, true);\n        }\n        // updates currentBlock\n        visitSwitchInsn(dflt, labels);\n    }\n\n    public void visitLookupSwitchInsn(final Label dflt, final int[] keys, final Label[] labels) {\n        // adds the instruction to the bytecode of the method\n        int source = code.length;\n        code.putByte(Opcodes.LOOKUPSWITCH);\n        code.putByteArray(null, 0, (4 - code.length % 4) % 4);\n        dflt.put(this, code, source, true);\n        code.putInt(labels.length);\n        for (int i = 0; i < labels.length; ++i) {\n            code.putInt(keys[i]);\n            labels[i].put(this, code, source, true);\n        }\n        // updates currentBlock\n        visitSwitchInsn(dflt, labels);\n    }\n\n    private void visitSwitchInsn(final Label dflt, final Label[] labels) {\n        // Label currentBlock = this.currentBlock;\n        if (currentBlock != null) {\n            if (compute == FRAMES) {\n                currentBlock.frame.execute(Opcodes.LOOKUPSWITCH, 0, null, null);\n                // adds current block successors\n                addSuccessor(Edge.NORMAL, dflt);\n                dflt.getFirst().status |= Label.TARGET;\n                for (int i = 0; i < labels.length; ++i) {\n                    addSuccessor(Edge.NORMAL, labels[i]);\n                    labels[i].getFirst().status |= Label.TARGET;\n                }\n            } else {\n                // updates current stack size (max stack size unchanged)\n                --stackSize;\n                // adds current block successors\n                addSuccessor(stackSize, dflt);\n                for (int i = 0; i < labels.length; ++i) {\n                    addSuccessor(stackSize, labels[i]);\n                }\n            }\n            // ends current block\n            noSuccessor();\n        }\n    }\n\n    public void visitMultiANewArrayInsn(final String desc, final int dims) {\n        Item i = cw.newClassItem(desc);\n        // Label currentBlock = this.currentBlock;\n        if (currentBlock != null) {\n            if (compute == FRAMES) {\n                currentBlock.frame.execute(Opcodes.MULTIANEWARRAY, dims, cw, i);\n            } else {\n                // updates current stack size (max stack size unchanged because\n                // stack size variation always negative or null)\n                stackSize += 1 - dims;\n            }\n        }\n        // adds the instruction to the bytecode of the method\n        code.put12(Opcodes.MULTIANEWARRAY, i.index).putByte(dims);\n    }\n\n    public void visitTryCatchBlock(final Label start, final Label end, final Label handler, final String type) {\n        ++handlerCount;\n        Handler h = new Handler();\n        h.start = start;\n        h.end = end;\n        h.handler = handler;\n        h.desc = type;\n        h.type = type != null ? cw.newClass(type) : 0;\n        if (lastHandler == null) {\n            firstHandler = h;\n        } else {\n            lastHandler.next = h;\n        }\n        lastHandler = h;\n    }\n\n    public void visitLocalVariable(final String name, final String desc, final String signature, final Label start, final Label end, final int index) {\n        if (signature != null) {\n            if (localVarType == null) {\n                localVarType = new ByteVector();\n            }\n            ++localVarTypeCount;\n            localVarType.putShort(start.position).putShort(end.position - start.position).putShort(cw.newUTF8(name)).putShort(cw.newUTF8(signature)).putShort(index);\n        }\n        if (localVar == null) {\n            localVar = new ByteVector();\n        }\n        ++localVarCount;\n        localVar.putShort(start.position).putShort(end.position - start.position).putShort(cw.newUTF8(name)).putShort(cw.newUTF8(desc)).putShort(index);\n        if (compute != NOTHING) {\n            // updates max locals\n            char c = desc.charAt(0);\n            int n = index + (c == 'J' || c == 'D' ? 2 : 1);\n            if (n > maxLocals) {\n                maxLocals = n;\n            }\n        }\n    }\n\n    public void visitLineNumber(final int line, final Label start) {\n        if (lineNumber == null) {\n            lineNumber = new ByteVector();\n        }\n        ++lineNumberCount;\n        lineNumber.putShort(start.position);\n        lineNumber.putShort(line);\n    }\n\n    public void visitMaxs(final int maxStack, final int maxLocals) {\n        if (ClassReader.FRAMES && compute == FRAMES) {\n            // completes the control flow graph with exception handler blocks\n            Handler handler = firstHandler;\n            while (handler != null) {\n                Label l = handler.start.getFirst();\n                Label h = handler.handler.getFirst();\n                Label e = handler.end.getFirst();\n                // computes the kind of the edges to 'h'\n                String t = handler.desc == null ? \"java/lang/Throwable\" : handler.desc;\n                int kind = Frame.OBJECT | cw.addType(t);\n                // h is an exception handler\n                h.status |= Label.TARGET;\n                // adds 'h' as a successor of labels between 'start' and 'end'\n                while (l != e) {\n                    // creates an edge to 'h'\n                    Edge b = new Edge();\n                    b.info = kind;\n                    b.successor = h;\n                    // adds it to the successors of 'l'\n                    b.next = l.successors;\n                    l.successors = b;\n                    // goes to the next label\n                    l = l.successor;\n                }\n                handler = handler.next;\n            }\n            // creates and visits the first (implicit) frame\n            Frame f = labels.frame;\n            Type[] args = Type.getArgumentTypes(descriptor);\n            f.initInputFrame(cw, access, args, this.maxLocals);\n            visitFrame(f);\n            /*\n             * fix point algorithm: mark the first basic block as 'changed'\n             * (i.e. put it in the 'changed' list) and, while there are changed\n             * basic blocks, choose one, mark it as unchanged, and update its\n             * successors (which can be changed in the process).\n             */\n            int max = 0;\n            Label changed = labels;\n            while (changed != null) {\n                // removes a basic block from the list of changed basic blocks\n                Label l = changed;\n                changed = changed.next;\n                l.next = null;\n                f = l.frame;\n                // a reachable jump target must be stored in the stack map\n                if ((l.status & Label.TARGET) != 0) {\n                    l.status |= Label.STORE;\n                }\n                // all visited labels are reachable, by definition\n                l.status |= Label.REACHABLE;\n                // updates the (absolute) maximum stack size\n                int blockMax = f.inputStack.length + l.outputStackMax;\n                if (blockMax > max) {\n                    max = blockMax;\n                }\n                // updates the successors of the current basic block\n                Edge e = l.successors;\n                while (e != null) {\n                    Label n = e.successor.getFirst();\n                    boolean change = f.merge(cw, n.frame, e.info);\n                    if (change && n.next == null) {\n                        // if n has changed and is not already in the 'changed'\n                        // list, adds it to this list\n                        n.next = changed;\n                        changed = n;\n                    }\n                    e = e.next;\n                }\n            }\n            // visits all the frames that must be stored in the stack map\n            Label l = labels;\n            while (l != null) {\n                f = l.frame;\n                if ((l.status & Label.STORE) != 0) {\n                    visitFrame(f);\n                }\n                if ((l.status & Label.REACHABLE) == 0) {\n                    // finds start and end of dead basic block\n                    Label k = l.successor;\n                    int start = l.position;\n                    int end = (k == null ? code.length : k.position) - 1;\n                    // if non empty basic block\n                    if (end >= start) {\n                        max = Math.max(max, 1);\n                        // replaces instructions with NOP ... NOP ATHROW\n                        for (int i = start; i < end; ++i) {\n                            code.data[i] = Opcodes.NOP;\n                        }\n                        code.data[end] = (byte) Opcodes.ATHROW;\n                        // emits a frame for this unreachable block\n                        startFrame(start, 0, 1);\n                        frame[frameIndex++] = Frame.OBJECT | cw.addType(\"java/lang/Throwable\");\n                        endFrame();\n                    }\n                }\n                l = l.successor;\n            }\n            this.maxStack = max;\n        } else if (compute == MAXS) {\n            // completes the control flow graph with exception handler blocks\n            Handler handler = firstHandler;\n            while (handler != null) {\n                Label l = handler.start;\n                Label h = handler.handler;\n                Label e = handler.end;\n                // adds 'h' as a successor of labels between 'start' and 'end'\n                while (l != e) {\n                    // creates an edge to 'h'\n                    Edge b = new Edge();\n                    b.info = Edge.EXCEPTION;\n                    b.successor = h;\n                    // adds it to the successors of 'l'\n                    if ((l.status & Label.JSR) == 0) {\n                        b.next = l.successors;\n                        l.successors = b;\n                    } else {\n                        // if l is a JSR block, adds b after the first two edges\n                        // to preserve the hypothesis about JSR block successors\n                        // order (see {@link #visitJumpInsn})\n                        b.next = l.successors.next.next;\n                        l.successors.next.next = b;\n                    }\n                    // goes to the next label\n                    l = l.successor;\n                }\n                handler = handler.next;\n            }\n            if (subroutines > 0) {\n                // completes the control flow graph with the RET successors\n                /*\n                 * first step: finds the subroutines. This step determines, for\n                 * each basic block, to which subroutine(s) it belongs.\n                 */\n                // finds the basic blocks that belong to the \"main\" subroutine\n                int id = 0;\n                labels.visitSubroutine(null, 1, subroutines);\n                // finds the basic blocks that belong to the real subroutines\n                Label l = labels;\n                while (l != null) {\n                    if ((l.status & Label.JSR) != 0) {\n                        // the subroutine is defined by l's TARGET, not by l\n                        Label subroutine = l.successors.next.successor;\n                        // if this subroutine has not been visited yet...\n                        if ((subroutine.status & Label.VISITED) == 0) {\n                            // ...assigns it a new id and finds its basic blocks\n                            id += 1;\n                            subroutine.visitSubroutine(null, (id / 32L) << 32 | (1L << (id % 32)), subroutines);\n                        }\n                    }\n                    l = l.successor;\n                }\n                // second step: finds the successors of RET blocks\n                l = labels;\n                while (l != null) {\n                    if ((l.status & Label.JSR) != 0) {\n                        Label L = labels;\n                        while (L != null) {\n                            L.status &= ~Label.VISITED2;\n                            L = L.successor;\n                        }\n                        // the subroutine is defined by l's TARGET, not by l\n                        Label subroutine = l.successors.next.successor;\n                        subroutine.visitSubroutine(l, 0, subroutines);\n                    }\n                    l = l.successor;\n                }\n            }\n            /*\n             * control flow analysis algorithm: while the block stack is not\n             * empty, pop a block from this stack, update the max stack size,\n             * compute the true (non relative) begin stack size of the\n             * successors of this block, and push these successors onto the\n             * stack (unless they have already been pushed onto the stack).\n             * Note: by hypothesis, the {@link Label#inputStackTop} of the\n             * blocks in the block stack are the true (non relative) beginning\n             * stack sizes of these blocks.\n             */\n            int max = 0;\n            Label stack = labels;\n            while (stack != null) {\n                // pops a block from the stack\n                Label l = stack;\n                stack = stack.next;\n                // computes the true (non relative) max stack size of this block\n                int start = l.inputStackTop;\n                int blockMax = start + l.outputStackMax;\n                // updates the global max stack size\n                if (blockMax > max) {\n                    max = blockMax;\n                }\n                // analyzes the successors of the block\n                Edge b = l.successors;\n                if ((l.status & Label.JSR) != 0) {\n                    // ignores the first edge of JSR blocks (virtual successor)\n                    b = b.next;\n                }\n                while (b != null) {\n                    l = b.successor;\n                    // if this successor has not already been pushed...\n                    if ((l.status & Label.PUSHED) == 0) {\n                        // computes its true beginning stack size...\n                        l.inputStackTop = b.info == Edge.EXCEPTION ? 1 : start + b.info;\n                        // ...and pushes it onto the stack\n                        l.status |= Label.PUSHED;\n                        l.next = stack;\n                        stack = l;\n                    }\n                    b = b.next;\n                }\n            }\n            this.maxStack = max;\n        } else {\n            this.maxStack = maxStack;\n            this.maxLocals = maxLocals;\n        }\n    }\n\n    public void visitEnd() {\n    }\n\n    // ------------------------------------------------------------------------\n    // Utility methods: control flow analysis algorithm\n    // ------------------------------------------------------------------------\n    /**\n     * Adds a successor to the {@link #currentBlock currentBlock} block.\n     *\n     * @param info information about the control flow edge to be added.\n     * @param successor the successor block to be added to the current block.\n     */\n    private void addSuccessor(final int info, final Label successor) {\n        // creates and initializes an Edge object...\n        Edge b = new Edge();\n        b.info = info;\n        b.successor = successor;\n        // ...and adds it to the successor list of the currentBlock block\n        b.next = currentBlock.successors;\n        currentBlock.successors = b;\n    }\n\n    /**\n     * Ends the current basic block. This method must be used in the case where\n     * the current basic block does not have any successor.\n     */\n    private void noSuccessor() {\n        if (compute == FRAMES) {\n            Label l = new Label();\n            l.frame = new Frame();\n            l.frame.owner = l;\n            l.resolve(this, code.length, code.data);\n            previousBlock.successor = l;\n            previousBlock = l;\n        } else {\n            currentBlock.outputStackMax = maxStackSize;\n        }\n        currentBlock = null;\n    }\n\n    // ------------------------------------------------------------------------\n    // Utility methods: stack map frames\n    // ------------------------------------------------------------------------\n    /**\n     * Visits a frame that has been computed from scratch.\n     *\n     * @param f the frame that must be visited.\n     */\n    private void visitFrame(final Frame f) {\n        int i, t;\n        int nTop = 0;\n        int nLocal = 0;\n        int nStack = 0;\n        int[] locals = f.inputLocals;\n        int[] stacks = f.inputStack;\n        // computes the number of locals (ignores TOP types that are just after\n        // a LONG or a DOUBLE, and all trailing TOP types)\n        for (i = 0; i < locals.length; ++i) {\n            t = locals[i];\n            if (t == Frame.TOP) {\n                ++nTop;\n            } else {\n                nLocal += nTop + 1;\n                nTop = 0;\n            }\n            if (t == Frame.LONG || t == Frame.DOUBLE) {\n                ++i;\n            }\n        }\n        // computes the stack size (ignores TOP types that are just after\n        // a LONG or a DOUBLE)\n        for (i = 0; i < stacks.length; ++i) {\n            t = stacks[i];\n            ++nStack;\n            if (t == Frame.LONG || t == Frame.DOUBLE) {\n                ++i;\n            }\n        }\n        // visits the frame and its content\n        startFrame(f.owner.position, nLocal, nStack);\n        for (i = 0; nLocal > 0; ++i, --nLocal) {\n            t = locals[i];\n            frame[frameIndex++] = t;\n            if (t == Frame.LONG || t == Frame.DOUBLE) {\n                ++i;\n            }\n        }\n        for (i = 0; i < stacks.length; ++i) {\n            t = stacks[i];\n            frame[frameIndex++] = t;\n            if (t == Frame.LONG || t == Frame.DOUBLE) {\n                ++i;\n            }\n        }\n        endFrame();\n    }\n\n    /**\n     * Starts the visit of a stack map frame.\n     *\n     * @param offset the offset of the instruction to which the frame\n     *        corresponds.\n     * @param nLocal the number of local variables in the frame.\n     * @param nStack the number of stack elements in the frame.\n     */\n    private void startFrame(final int offset, final int nLocal, final int nStack) {\n        int n = 3 + nLocal + nStack;\n        if (frame == null || frame.length < n) {\n            frame = new int[n];\n        }\n        frame[0] = offset;\n        frame[1] = nLocal;\n        frame[2] = nStack;\n        frameIndex = 3;\n    }\n\n    /**\n     * Checks if the visit of the current frame {@link #frame} is finished, and\n     * if yes, write it in the StackMapTable attribute.\n     */\n    private void endFrame() {\n        if (previousFrame != null) {\n            // do not write the first frame\n            if (stackMap == null) {\n                stackMap = new ByteVector();\n            }\n            writeFrame();\n            ++frameCount;\n        }\n        previousFrame = frame;\n        frame = null;\n    }\n\n    /**\n     * Compress and writes the current frame {@link #frame} in the StackMapTable\n     * attribute.\n     */\n    private void writeFrame() {\n        int clocalsSize = frame[1];\n        int cstackSize = frame[2];\n        if ((cw.version & 0xFFFF) < Opcodes.V1_6) {\n            stackMap.putShort(frame[0]).putShort(clocalsSize);\n            writeFrameTypes(3, 3 + clocalsSize);\n            stackMap.putShort(cstackSize);\n            writeFrameTypes(3 + clocalsSize, 3 + clocalsSize + cstackSize);\n            return;\n        }\n        int localsSize = previousFrame[1];\n        int type = FULL_FRAME;\n        int k = 0;\n        int delta;\n        if (frameCount == 0) {\n            delta = frame[0];\n        } else {\n            delta = frame[0] - previousFrame[0] - 1;\n        }\n        if (cstackSize == 0) {\n            k = clocalsSize - localsSize;\n            switch(k) {\n                case -3:\n                case -2:\n                case -1:\n                    type = CHOP_FRAME;\n                    localsSize = clocalsSize;\n                    break;\n                case 0:\n                    type = delta < 64 ? SAME_FRAME : SAME_FRAME_EXTENDED;\n                    break;\n                case 1:\n                case 2:\n                case 3:\n                    type = APPEND_FRAME;\n                    break;\n            }\n        } else if (clocalsSize == localsSize && cstackSize == 1) {\n            type = delta < 63 ? SAME_LOCALS_1_STACK_ITEM_FRAME : SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED;\n        }\n        if (type != FULL_FRAME) {\n            // verify if locals are the same\n            int l = 3;\n            for (int j = 0; j < localsSize; j++) {\n                if (frame[l] != previousFrame[l]) {\n                    type = FULL_FRAME;\n                    break;\n                }\n                l++;\n            }\n        }\n        switch(type) {\n            case SAME_FRAME:\n                stackMap.putByte(delta);\n                break;\n            case SAME_LOCALS_1_STACK_ITEM_FRAME:\n                stackMap.putByte(SAME_LOCALS_1_STACK_ITEM_FRAME + delta);\n                writeFrameTypes(3 + clocalsSize, 4 + clocalsSize);\n                break;\n            case SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED:\n                stackMap.putByte(SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED).putShort(delta);\n                writeFrameTypes(3 + clocalsSize, 4 + clocalsSize);\n                break;\n            case SAME_FRAME_EXTENDED:\n                stackMap.putByte(SAME_FRAME_EXTENDED).putShort(delta);\n                break;\n            case CHOP_FRAME:\n                stackMap.putByte(SAME_FRAME_EXTENDED + k).putShort(delta);\n                break;\n            case APPEND_FRAME:\n                stackMap.putByte(SAME_FRAME_EXTENDED + k).putShort(delta);\n                writeFrameTypes(3 + localsSize, 3 + clocalsSize);\n                break;\n            // case FULL_FRAME:\n            default:\n                stackMap.putByte(FULL_FRAME).putShort(delta).putShort(clocalsSize);\n                writeFrameTypes(3, 3 + clocalsSize);\n                stackMap.putShort(cstackSize);\n                writeFrameTypes(3 + clocalsSize, 3 + clocalsSize + cstackSize);\n        }\n    }\n\n    /**\n     * Writes some types of the current frame {@link #frame} into the\n     * StackMapTableAttribute. This method converts types from the format used\n     * in {@link Label} to the format used in StackMapTable attributes. In\n     * particular, it converts type table indexes to constant pool indexes.\n     *\n     * @param start index of the first type in {@link #frame} to write.\n     * @param end index of last type in {@link #frame} to write (exclusive).\n     */\n    private void writeFrameTypes(final int start, final int end) {\n        for (int i = start; i < end; ++i) {\n            int t = frame[i];\n            int d = t & Frame.DIM;\n            if (d == 0) {\n                int v = t & Frame.BASE_VALUE;\n                switch(t & Frame.BASE_KIND) {\n                    case Frame.OBJECT:\n                        stackMap.putByte(7).putShort(cw.newClass(cw.typeTable[v].strVal1));\n                        break;\n                    case Frame.UNINITIALIZED:\n                        stackMap.putByte(8).putShort(cw.typeTable[v].intVal);\n                        break;\n                    default:\n                        stackMap.putByte(v);\n                }\n            } else {\n                StringBuffer buf = new StringBuffer();\n                d >>= 28;\n                while (d-- > 0) {\n                    buf.append('[');\n                }\n                if ((t & Frame.BASE_KIND) == Frame.OBJECT) {\n                    buf.append('L');\n                    buf.append(cw.typeTable[t & Frame.BASE_VALUE].strVal1);\n                    buf.append(';');\n                } else {\n                    switch(t & 0xF) {\n                        case 1:\n                            buf.append('I');\n                            break;\n                        case 2:\n                            buf.append('F');\n                            break;\n                        case 3:\n                            buf.append('D');\n                            break;\n                        case 9:\n                            buf.append('Z');\n                            break;\n                        case 10:\n                            buf.append('B');\n                            break;\n                        case 11:\n                            buf.append('C');\n                            break;\n                        case 12:\n                            buf.append('S');\n                            break;\n                        default:\n                            buf.append('J');\n                    }\n                }\n                stackMap.putByte(7).putShort(cw.newClass(buf.toString()));\n            }\n        }\n    }\n\n    private void writeFrameType(final Object type) {\n        if (type instanceof String) {\n            stackMap.putByte(7).putShort(cw.newClass((String) type));\n        } else if (type instanceof Integer) {\n            stackMap.putByte(((Integer) type).intValue());\n        } else {\n            stackMap.putByte(8).putShort(((Label) type).position);\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Utility methods: dump bytecode array\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the size of the bytecode of this method.\n     *\n     * @return the size of the bytecode of this method.\n     */\n    final int getSize() {\n        if (classReaderOffset != 0) {\n            return 6 + classReaderLength;\n        }\n        if (resize) {\n            // replaces the temporary jump opcodes introduced by Label.resolve.\n            if (ClassReader.RESIZE) {\n                resizeInstructions();\n            } else {\n                throw new RuntimeException(\"Method code too large!\");\n            }\n        }\n        int size = 8;\n        if (code.length > 0) {\n            cw.newUTF8(\"Code\");\n            size += 18 + code.length + 8 * handlerCount;\n            if (localVar != null) {\n                cw.newUTF8(\"LocalVariableTable\");\n                size += 8 + localVar.length;\n            }\n            if (localVarType != null) {\n                cw.newUTF8(\"LocalVariableTypeTable\");\n                size += 8 + localVarType.length;\n            }\n            if (lineNumber != null) {\n                cw.newUTF8(\"LineNumberTable\");\n                size += 8 + lineNumber.length;\n            }\n            if (stackMap != null) {\n                boolean zip = (cw.version & 0xFFFF) >= Opcodes.V1_6;\n                cw.newUTF8(zip ? \"StackMapTable\" : \"StackMap\");\n                size += 8 + stackMap.length;\n            }\n            if (cattrs != null) {\n                size += cattrs.getSize(cw, code.data, code.length, maxStack, maxLocals);\n            }\n        }\n        if (exceptionCount > 0) {\n            cw.newUTF8(\"Exceptions\");\n            size += 8 + 2 * exceptionCount;\n        }\n        if ((access & Opcodes.ACC_SYNTHETIC) != 0 && (cw.version & 0xffff) < Opcodes.V1_5) {\n            cw.newUTF8(\"Synthetic\");\n            size += 6;\n        }\n        if ((access & Opcodes.ACC_DEPRECATED) != 0) {\n            cw.newUTF8(\"Deprecated\");\n            size += 6;\n        }\n        if (ClassReader.SIGNATURES && signature != null) {\n            cw.newUTF8(\"Signature\");\n            cw.newUTF8(signature);\n            size += 8;\n        }\n        if (ClassReader.ANNOTATIONS && annd != null) {\n            cw.newUTF8(\"AnnotationDefault\");\n            size += 6 + annd.length;\n        }\n        if (ClassReader.ANNOTATIONS && anns != null) {\n            cw.newUTF8(\"RuntimeVisibleAnnotations\");\n            size += 8 + anns.getSize();\n        }\n        if (ClassReader.ANNOTATIONS && ianns != null) {\n            cw.newUTF8(\"RuntimeInvisibleAnnotations\");\n            size += 8 + ianns.getSize();\n        }\n        if (ClassReader.ANNOTATIONS && panns != null) {\n            cw.newUTF8(\"RuntimeVisibleParameterAnnotations\");\n            size += 7 + 2 * (panns.length - synthetics);\n            for (int i = panns.length - 1; i >= synthetics; --i) {\n                size += panns[i] == null ? 0 : panns[i].getSize();\n            }\n        }\n        if (ClassReader.ANNOTATIONS && ipanns != null) {\n            cw.newUTF8(\"RuntimeInvisibleParameterAnnotations\");\n            size += 7 + 2 * (ipanns.length - synthetics);\n            for (int i = ipanns.length - 1; i >= synthetics; --i) {\n                size += ipanns[i] == null ? 0 : ipanns[i].getSize();\n            }\n        }\n        if (attrs != null) {\n            size += attrs.getSize(cw, null, 0, -1, -1);\n        }\n        return size;\n    }\n\n    /**\n     * Puts the bytecode of this method in the given byte vector.\n     *\n     * @param out the byte vector into which the bytecode of this method must be\n     *        copied.\n     */\n    final void put(final ByteVector out) {\n        out.putShort(access).putShort(name).putShort(desc);\n        if (classReaderOffset != 0) {\n            out.putByteArray(cw.cr.b, classReaderOffset, classReaderLength);\n            return;\n        }\n        int attributeCount = 0;\n        if (code.length > 0) {\n            ++attributeCount;\n        }\n        if (exceptionCount > 0) {\n            ++attributeCount;\n        }\n        if ((access & Opcodes.ACC_SYNTHETIC) != 0 && (cw.version & 0xffff) < Opcodes.V1_5) {\n            ++attributeCount;\n        }\n        if ((access & Opcodes.ACC_DEPRECATED) != 0) {\n            ++attributeCount;\n        }\n        if (ClassReader.SIGNATURES && signature != null) {\n            ++attributeCount;\n        }\n        if (ClassReader.ANNOTATIONS && annd != null) {\n            ++attributeCount;\n        }\n        if (ClassReader.ANNOTATIONS && anns != null) {\n            ++attributeCount;\n        }\n        if (ClassReader.ANNOTATIONS && ianns != null) {\n            ++attributeCount;\n        }\n        if (ClassReader.ANNOTATIONS && panns != null) {\n            ++attributeCount;\n        }\n        if (ClassReader.ANNOTATIONS && ipanns != null) {\n            ++attributeCount;\n        }\n        if (attrs != null) {\n            attributeCount += attrs.getCount();\n        }\n        out.putShort(attributeCount);\n        if (code.length > 0) {\n            int size = 12 + code.length + 8 * handlerCount;\n            if (localVar != null) {\n                size += 8 + localVar.length;\n            }\n            if (localVarType != null) {\n                size += 8 + localVarType.length;\n            }\n            if (lineNumber != null) {\n                size += 8 + lineNumber.length;\n            }\n            if (stackMap != null) {\n                size += 8 + stackMap.length;\n            }\n            if (cattrs != null) {\n                size += cattrs.getSize(cw, code.data, code.length, maxStack, maxLocals);\n            }\n            out.putShort(cw.newUTF8(\"Code\")).putInt(size);\n            out.putShort(maxStack).putShort(maxLocals);\n            out.putInt(code.length).putByteArray(code.data, 0, code.length);\n            out.putShort(handlerCount);\n            if (handlerCount > 0) {\n                Handler h = firstHandler;\n                while (h != null) {\n                    out.putShort(h.start.position).putShort(h.end.position).putShort(h.handler.position).putShort(h.type);\n                    h = h.next;\n                }\n            }\n            attributeCount = 0;\n            if (localVar != null) {\n                ++attributeCount;\n            }\n            if (localVarType != null) {\n                ++attributeCount;\n            }\n            if (lineNumber != null) {\n                ++attributeCount;\n            }\n            if (stackMap != null) {\n                ++attributeCount;\n            }\n            if (cattrs != null) {\n                attributeCount += cattrs.getCount();\n            }\n            out.putShort(attributeCount);\n            if (localVar != null) {\n                out.putShort(cw.newUTF8(\"LocalVariableTable\"));\n                out.putInt(localVar.length + 2).putShort(localVarCount);\n                out.putByteArray(localVar.data, 0, localVar.length);\n            }\n            if (localVarType != null) {\n                out.putShort(cw.newUTF8(\"LocalVariableTypeTable\"));\n                out.putInt(localVarType.length + 2).putShort(localVarTypeCount);\n                out.putByteArray(localVarType.data, 0, localVarType.length);\n            }\n            if (lineNumber != null) {\n                out.putShort(cw.newUTF8(\"LineNumberTable\"));\n                out.putInt(lineNumber.length + 2).putShort(lineNumberCount);\n                out.putByteArray(lineNumber.data, 0, lineNumber.length);\n            }\n            if (stackMap != null) {\n                boolean zip = (cw.version & 0xFFFF) >= Opcodes.V1_6;\n                out.putShort(cw.newUTF8(zip ? \"StackMapTable\" : \"StackMap\"));\n                out.putInt(stackMap.length + 2).putShort(frameCount);\n                out.putByteArray(stackMap.data, 0, stackMap.length);\n            }\n            if (cattrs != null) {\n                cattrs.put(cw, code.data, code.length, maxLocals, maxStack, out);\n            }\n        }\n        if (exceptionCount > 0) {\n            out.putShort(cw.newUTF8(\"Exceptions\")).putInt(2 * exceptionCount + 2);\n            out.putShort(exceptionCount);\n            for (int i = 0; i < exceptionCount; ++i) {\n                out.putShort(exceptions[i]);\n            }\n        }\n        if ((access & Opcodes.ACC_SYNTHETIC) != 0 && (cw.version & 0xffff) < Opcodes.V1_5) {\n            out.putShort(cw.newUTF8(\"Synthetic\")).putInt(0);\n        }\n        if ((access & Opcodes.ACC_DEPRECATED) != 0) {\n            out.putShort(cw.newUTF8(\"Deprecated\")).putInt(0);\n        }\n        if (ClassReader.SIGNATURES && signature != null) {\n            out.putShort(cw.newUTF8(\"Signature\")).putInt(2).putShort(cw.newUTF8(signature));\n        }\n        if (ClassReader.ANNOTATIONS && annd != null) {\n            out.putShort(cw.newUTF8(\"AnnotationDefault\"));\n            out.putInt(annd.length);\n            out.putByteArray(annd.data, 0, annd.length);\n        }\n        if (ClassReader.ANNOTATIONS && anns != null) {\n            out.putShort(cw.newUTF8(\"RuntimeVisibleAnnotations\"));\n            anns.put(out);\n        }\n        if (ClassReader.ANNOTATIONS && ianns != null) {\n            out.putShort(cw.newUTF8(\"RuntimeInvisibleAnnotations\"));\n            ianns.put(out);\n        }\n        if (ClassReader.ANNOTATIONS && panns != null) {\n            out.putShort(cw.newUTF8(\"RuntimeVisibleParameterAnnotations\"));\n            AnnotationWriter.put(panns, synthetics, out);\n        }\n        if (ClassReader.ANNOTATIONS && ipanns != null) {\n            out.putShort(cw.newUTF8(\"RuntimeInvisibleParameterAnnotations\"));\n            AnnotationWriter.put(ipanns, synthetics, out);\n        }\n        if (attrs != null) {\n            attrs.put(cw, null, 0, -1, -1, out);\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Utility methods: instruction resizing (used to handle GOTO_W and JSR_W)\n    // ------------------------------------------------------------------------\n    /**\n     * Resizes and replaces the temporary instructions inserted by\n     * {@link Label#resolve} for wide forward jumps, while keeping jump offsets\n     * and instruction addresses consistent. This may require to resize other\n     * existing instructions, or even to introduce new instructions: for\n     * example, increasing the size of an instruction by 2 at the middle of a\n     * method can increases the offset of an IFEQ instruction from 32766 to\n     * 32768, in which case IFEQ 32766 must be replaced with IFNEQ 8 GOTO_W\n     * 32765. This, in turn, may require to increase the size of another jump\n     * instruction, and so on... All these operations are handled automatically\n     * by this method. <p> <i>This method must be called after all the method\n     * that is being built has been visited</i>. In particular, the\n     * {@link Label Label} objects used to construct the method are no longer\n     * valid after this method has been called.\n     */\n    private void resizeInstructions() {\n        // bytecode of the method\n        byte[] b = code.data;\n        // indexes in b\n        int u, v, label;\n        // loop indexes\n        int i, j;\n        /*\n         * 1st step: As explained above, resizing an instruction may require to\n         * resize another one, which may require to resize yet another one, and\n         * so on. The first step of the algorithm consists in finding all the\n         * instructions that need to be resized, without modifying the code.\n         * This is done by the following \"fix point\" algorithm:\n         * \n         * Parse the code to find the jump instructions whose offset will need\n         * more than 2 bytes to be stored (the future offset is computed from\n         * the current offset and from the number of bytes that will be inserted\n         * or removed between the source and target instructions). For each such\n         * instruction, adds an entry in (a copy of) the indexes and sizes\n         * arrays (if this has not already been done in a previous iteration!).\n         * \n         * If at least one entry has been added during the previous step, go\n         * back to the beginning, otherwise stop.\n         * \n         * In fact the real algorithm is complicated by the fact that the size\n         * of TABLESWITCH and LOOKUPSWITCH instructions depends on their\n         * position in the bytecode (because of padding). In order to ensure the\n         * convergence of the algorithm, the number of bytes to be added or\n         * removed from these instructions is over estimated during the previous\n         * loop, and computed exactly only after the loop is finished (this\n         * requires another pass to parse the bytecode of the method).\n         */\n        // copy of indexes\n        int[] allIndexes = new int[0];\n        // copy of sizes\n        int[] allSizes = new int[0];\n        // instructions to be resized\n        boolean[] resize;\n        // future offset of a jump instruction\n        int newOffset;\n        resize = new boolean[code.length];\n        // 3 = loop again, 2 = loop ended, 1 = last pass, 0 = done\n        int state = 3;\n        do {\n            if (state == 3) {\n                state = 2;\n            }\n            u = 0;\n            while (u < b.length) {\n                // opcode of current instruction\n                int opcode = b[u] & 0xFF;\n                // bytes to be added after this instruction\n                int insert = 0;\n                switch(ClassWriter.TYPE[opcode]) {\n                    case ClassWriter.NOARG_INSN:\n                    case ClassWriter.IMPLVAR_INSN:\n                        u += 1;\n                        break;\n                    case ClassWriter.LABEL_INSN:\n                        if (opcode > 201) {\n                            // converts temporary opcodes 202 to 217, 218 and\n                            // 219 to IFEQ ... JSR (inclusive), IFNULL and\n                            // IFNONNULL\n                            opcode = opcode < 218 ? opcode - 49 : opcode - 20;\n                            label = u + readUnsignedShort(b, u + 1);\n                        } else {\n                            label = u + readShort(b, u + 1);\n                        }\n                        newOffset = getNewOffset(allIndexes, allSizes, u, label);\n                        if (newOffset < Short.MIN_VALUE || newOffset > Short.MAX_VALUE) {\n                            if (!resize[u]) {\n                                if (opcode == Opcodes.GOTO || opcode == Opcodes.JSR) {\n                                    // two additional bytes will be required to\n                                    // replace this GOTO or JSR instruction with\n                                    // a GOTO_W or a JSR_W\n                                    insert = 2;\n                                } else {\n                                    // five additional bytes will be required to\n                                    // replace this IFxxx <l> instruction with\n                                    // IFNOTxxx <l'> GOTO_W <l>, where IFNOTxxx\n                                    // is the \"opposite\" opcode of IFxxx (i.e.,\n                                    // IFNE for IFEQ) and where <l'> designates\n                                    // the instruction just after the GOTO_W.\n                                    insert = 5;\n                                }\n                                resize[u] = true;\n                            }\n                        }\n                        u += 3;\n                        break;\n                    case ClassWriter.LABELW_INSN:\n                        u += 5;\n                        break;\n                    case ClassWriter.TABL_INSN:\n                        if (state == 1) {\n                            // true number of bytes to be added (or removed)\n                            // from this instruction = (future number of padding\n                            // bytes - current number of padding byte) -\n                            // previously over estimated variation =\n                            // = ((3 - newOffset%4) - (3 - u%4)) - u%4\n                            // = (-newOffset%4 + u%4) - u%4\n                            // = -(newOffset & 3)\n                            newOffset = getNewOffset(allIndexes, allSizes, 0, u);\n                            insert = -(newOffset & 3);\n                        } else if (!resize[u]) {\n                            // over estimation of the number of bytes to be\n                            // added to this instruction = 3 - current number\n                            // of padding bytes = 3 - (3 - u%4) = u%4 = u & 3\n                            insert = u & 3;\n                            resize[u] = true;\n                        }\n                        // skips instruction\n                        u = u + 4 - (u & 3);\n                        u += 4 * (readInt(b, u + 8) - readInt(b, u + 4) + 1) + 12;\n                        break;\n                    case ClassWriter.LOOK_INSN:\n                        if (state == 1) {\n                            // like TABL_INSN\n                            newOffset = getNewOffset(allIndexes, allSizes, 0, u);\n                            insert = -(newOffset & 3);\n                        } else if (!resize[u]) {\n                            // like TABL_INSN\n                            insert = u & 3;\n                            resize[u] = true;\n                        }\n                        // skips instruction\n                        u = u + 4 - (u & 3);\n                        u += 8 * readInt(b, u + 4) + 8;\n                        break;\n                    case ClassWriter.WIDE_INSN:\n                        opcode = b[u + 1] & 0xFF;\n                        if (opcode == Opcodes.IINC) {\n                            u += 6;\n                        } else {\n                            u += 4;\n                        }\n                        break;\n                    case ClassWriter.VAR_INSN:\n                    case ClassWriter.SBYTE_INSN:\n                    case ClassWriter.LDC_INSN:\n                        u += 2;\n                        break;\n                    case ClassWriter.SHORT_INSN:\n                    case ClassWriter.LDCW_INSN:\n                    case ClassWriter.FIELDORMETH_INSN:\n                    case ClassWriter.TYPE_INSN:\n                    case ClassWriter.IINC_INSN:\n                        u += 3;\n                        break;\n                    case ClassWriter.ITFDYNMETH_INSN:\n                        u += 5;\n                        break;\n                    // case ClassWriter.MANA_INSN:\n                    default:\n                        u += 4;\n                        break;\n                }\n                if (insert != 0) {\n                    // adds a new (u, insert) entry in the allIndexes and\n                    // allSizes arrays\n                    int[] newIndexes = new int[allIndexes.length + 1];\n                    int[] newSizes = new int[allSizes.length + 1];\n                    System.arraycopy(allIndexes, 0, newIndexes, 0, allIndexes.length);\n                    System.arraycopy(allSizes, 0, newSizes, 0, allSizes.length);\n                    newIndexes[allIndexes.length] = u;\n                    newSizes[allSizes.length] = insert;\n                    allIndexes = newIndexes;\n                    allSizes = newSizes;\n                    if (insert > 0) {\n                        state = 3;\n                    }\n                }\n            }\n            if (state < 3) {\n                --state;\n            }\n        } while (state != 0);\n        // 2nd step:\n        // copies the bytecode of the method into a new bytevector, updates the\n        // offsets, and inserts (or removes) bytes as requested.\n        ByteVector newCode = new ByteVector(code.length);\n        u = 0;\n        while (u < code.length) {\n            int opcode = b[u] & 0xFF;\n            switch(ClassWriter.TYPE[opcode]) {\n                case ClassWriter.NOARG_INSN:\n                case ClassWriter.IMPLVAR_INSN:\n                    newCode.putByte(opcode);\n                    u += 1;\n                    break;\n                case ClassWriter.LABEL_INSN:\n                    if (opcode > 201) {\n                        // changes temporary opcodes 202 to 217 (inclusive), 218\n                        // and 219 to IFEQ ... JSR (inclusive), IFNULL and\n                        // IFNONNULL\n                        opcode = opcode < 218 ? opcode - 49 : opcode - 20;\n                        label = u + readUnsignedShort(b, u + 1);\n                    } else {\n                        label = u + readShort(b, u + 1);\n                    }\n                    newOffset = getNewOffset(allIndexes, allSizes, u, label);\n                    if (resize[u]) {\n                        // replaces GOTO with GOTO_W, JSR with JSR_W and IFxxx\n                        // <l> with IFNOTxxx <l'> GOTO_W <l>, where IFNOTxxx is\n                        // the \"opposite\" opcode of IFxxx (i.e., IFNE for IFEQ)\n                        // and where <l'> designates the instruction just after\n                        // the GOTO_W.\n                        if (opcode == Opcodes.GOTO) {\n                            // GOTO_W\n                            newCode.putByte(200);\n                        } else if (opcode == Opcodes.JSR) {\n                            // JSR_W\n                            newCode.putByte(201);\n                        } else {\n                            newCode.putByte(opcode <= 166 ? ((opcode + 1) ^ 1) - 1 : opcode ^ 1);\n                            // jump offset\n                            newCode.putShort(8);\n                            // GOTO_W\n                            newCode.putByte(200);\n                            // newOffset now computed from start of GOTO_W\n                            newOffset -= 3;\n                        }\n                        newCode.putInt(newOffset);\n                    } else {\n                        newCode.putByte(opcode);\n                        newCode.putShort(newOffset);\n                    }\n                    u += 3;\n                    break;\n                case ClassWriter.LABELW_INSN:\n                    label = u + readInt(b, u + 1);\n                    newOffset = getNewOffset(allIndexes, allSizes, u, label);\n                    newCode.putByte(opcode);\n                    newCode.putInt(newOffset);\n                    u += 5;\n                    break;\n                case ClassWriter.TABL_INSN:\n                    // skips 0 to 3 padding bytes\n                    v = u;\n                    u = u + 4 - (v & 3);\n                    // reads and copies instruction\n                    newCode.putByte(Opcodes.TABLESWITCH);\n                    newCode.putByteArray(null, 0, (4 - newCode.length % 4) % 4);\n                    label = v + readInt(b, u);\n                    u += 4;\n                    newOffset = getNewOffset(allIndexes, allSizes, v, label);\n                    newCode.putInt(newOffset);\n                    j = readInt(b, u);\n                    u += 4;\n                    newCode.putInt(j);\n                    j = readInt(b, u) - j + 1;\n                    u += 4;\n                    newCode.putInt(readInt(b, u - 4));\n                    for (; j > 0; --j) {\n                        label = v + readInt(b, u);\n                        u += 4;\n                        newOffset = getNewOffset(allIndexes, allSizes, v, label);\n                        newCode.putInt(newOffset);\n                    }\n                    break;\n                case ClassWriter.LOOK_INSN:\n                    // skips 0 to 3 padding bytes\n                    v = u;\n                    u = u + 4 - (v & 3);\n                    // reads and copies instruction\n                    newCode.putByte(Opcodes.LOOKUPSWITCH);\n                    newCode.putByteArray(null, 0, (4 - newCode.length % 4) % 4);\n                    label = v + readInt(b, u);\n                    u += 4;\n                    newOffset = getNewOffset(allIndexes, allSizes, v, label);\n                    newCode.putInt(newOffset);\n                    j = readInt(b, u);\n                    u += 4;\n                    newCode.putInt(j);\n                    for (; j > 0; --j) {\n                        newCode.putInt(readInt(b, u));\n                        u += 4;\n                        label = v + readInt(b, u);\n                        u += 4;\n                        newOffset = getNewOffset(allIndexes, allSizes, v, label);\n                        newCode.putInt(newOffset);\n                    }\n                    break;\n                case ClassWriter.WIDE_INSN:\n                    opcode = b[u + 1] & 0xFF;\n                    if (opcode == Opcodes.IINC) {\n                        newCode.putByteArray(b, u, 6);\n                        u += 6;\n                    } else {\n                        newCode.putByteArray(b, u, 4);\n                        u += 4;\n                    }\n                    break;\n                case ClassWriter.VAR_INSN:\n                case ClassWriter.SBYTE_INSN:\n                case ClassWriter.LDC_INSN:\n                    newCode.putByteArray(b, u, 2);\n                    u += 2;\n                    break;\n                case ClassWriter.SHORT_INSN:\n                case ClassWriter.LDCW_INSN:\n                case ClassWriter.FIELDORMETH_INSN:\n                case ClassWriter.TYPE_INSN:\n                case ClassWriter.IINC_INSN:\n                    newCode.putByteArray(b, u, 3);\n                    u += 3;\n                    break;\n                case ClassWriter.ITFDYNMETH_INSN:\n                    newCode.putByteArray(b, u, 5);\n                    u += 5;\n                    break;\n                // case MANA_INSN:\n                default:\n                    newCode.putByteArray(b, u, 4);\n                    u += 4;\n                    break;\n            }\n        }\n        // recomputes the stack map frames\n        if (frameCount > 0) {\n            if (compute == FRAMES) {\n                frameCount = 0;\n                stackMap = null;\n                previousFrame = null;\n                frame = null;\n                Frame f = new Frame();\n                f.owner = labels;\n                Type[] args = Type.getArgumentTypes(descriptor);\n                f.initInputFrame(cw, access, args, maxLocals);\n                visitFrame(f);\n                Label l = labels;\n                while (l != null) {\n                    /*\n                     * here we need the original label position. getNewOffset\n                     * must therefore never have been called for this label.\n                     */\n                    u = l.position - 3;\n                    if ((l.status & Label.STORE) != 0 || (u >= 0 && resize[u])) {\n                        getNewOffset(allIndexes, allSizes, l);\n                        // TODO update offsets in UNINITIALIZED values\n                        visitFrame(l.frame);\n                    }\n                    l = l.successor;\n                }\n            } else {\n                /*\n                 * Resizing an existing stack map frame table is really hard.\n                 * Not only the table must be parsed to update the offets, but\n                 * new frames may be needed for jump instructions that were\n                 * inserted by this method. And updating the offsets or\n                 * inserting frames can change the format of the following\n                 * frames, in case of packed frames. In practice the whole table\n                 * must be recomputed. For this the frames are marked as\n                 * potentially invalid. This will cause the whole class to be\n                 * reread and rewritten with the COMPUTE_FRAMES option (see the\n                 * ClassWriter.toByteArray method). This is not very efficient\n                 * but is much easier and requires much less code than any other\n                 * method I can think of.\n                 */\n                cw.invalidFrames = true;\n            }\n        }\n        // updates the exception handler block labels\n        Handler h = firstHandler;\n        while (h != null) {\n            getNewOffset(allIndexes, allSizes, h.start);\n            getNewOffset(allIndexes, allSizes, h.end);\n            getNewOffset(allIndexes, allSizes, h.handler);\n            h = h.next;\n        }\n        // updates the instructions addresses in the\n        // local var and line number tables\n        for (i = 0; i < 2; ++i) {\n            ByteVector bv = i == 0 ? localVar : localVarType;\n            if (bv != null) {\n                b = bv.data;\n                u = 0;\n                while (u < bv.length) {\n                    label = readUnsignedShort(b, u);\n                    newOffset = getNewOffset(allIndexes, allSizes, 0, label);\n                    writeShort(b, u, newOffset);\n                    label += readUnsignedShort(b, u + 2);\n                    newOffset = getNewOffset(allIndexes, allSizes, 0, label) - newOffset;\n                    writeShort(b, u + 2, newOffset);\n                    u += 10;\n                }\n            }\n        }\n        if (lineNumber != null) {\n            b = lineNumber.data;\n            u = 0;\n            while (u < lineNumber.length) {\n                writeShort(b, u, getNewOffset(allIndexes, allSizes, 0, readUnsignedShort(b, u)));\n                u += 4;\n            }\n        }\n        // updates the labels of the other attributes\n        Attribute attr = cattrs;\n        while (attr != null) {\n            Label[] labels = attr.getLabels();\n            if (labels != null) {\n                for (i = labels.length - 1; i >= 0; --i) {\n                    getNewOffset(allIndexes, allSizes, labels[i]);\n                }\n            }\n            attr = attr.next;\n        }\n        // replaces old bytecodes with new ones\n        code = newCode;\n    }\n\n    /**\n     * Reads an unsigned short value in the given byte array.\n     *\n     * @param b a byte array.\n     * @param index the start index of the value to be read.\n     * @return the read value.\n     */\n    static int readUnsignedShort(final byte[] b, final int index) {\n        return ((b[index] & 0xFF) << 8) | (b[index + 1] & 0xFF);\n    }\n\n    /**\n     * Reads a signed short value in the given byte array.\n     *\n     * @param b a byte array.\n     * @param index the start index of the value to be read.\n     * @return the read value.\n     */\n    static short readShort(final byte[] b, final int index) {\n        return (short) (((b[index] & 0xFF) << 8) | (b[index + 1] & 0xFF));\n    }\n\n    /**\n     * Reads a signed int value in the given byte array.\n     *\n     * @param b a byte array.\n     * @param index the start index of the value to be read.\n     * @return the read value.\n     */\n    static int readInt(final byte[] b, final int index) {\n        return ((b[index] & 0xFF) << 24) | ((b[index + 1] & 0xFF) << 16) | ((b[index + 2] & 0xFF) << 8) | (b[index + 3] & 0xFF);\n    }\n\n    /**\n     * Writes a short value in the given byte array.\n     *\n     * @param b a byte array.\n     * @param index where the first byte of the short value must be written.\n     * @param s the value to be written in the given byte array.\n     */\n    static void writeShort(final byte[] b, final int index, final int s) {\n        b[index] = (byte) (s >>> 8);\n        b[index + 1] = (byte) s;\n    }\n\n    /**\n     * Computes the future value of a bytecode offset. <p> Note: it is possible\n     * to have several entries for the same instruction in the <tt>indexes</tt>\n     * and <tt>sizes</tt>: two entries (index=a,size=b) and (index=a,size=b')\n     * are equivalent to a single entry (index=a,size=b+b').\n     *\n     * @param indexes current positions of the instructions to be resized. Each\n     *        instruction must be designated by the index of its <i>last</i>\n     *        byte, plus one (or, in other words, by the index of the <i>first</i>\n     *        byte of the <i>next</i> instruction).\n     * @param sizes the number of bytes to be <i>added</i> to the above\n     *        instructions. More precisely, for each i < <tt>len</tt>,\n     *        <tt>sizes</tt>[i] bytes will be added at the end of the\n     *        instruction designated by <tt>indexes</tt>[i] or, if\n     *        <tt>sizes</tt>[i] is negative, the <i>last</i> |<tt>sizes[i]</tt>|\n     *        bytes of the instruction will be removed (the instruction size\n     *        <i>must not</i> become negative or null).\n     * @param begin index of the first byte of the source instruction.\n     * @param end index of the first byte of the target instruction.\n     * @return the future value of the given bytecode offset.\n     */\n    static int getNewOffset(final int[] indexes, final int[] sizes, final int begin, final int end) {\n        int offset = end - begin;\n        for (int i = 0; i < indexes.length; ++i) {\n            if (begin < indexes[i] && indexes[i] <= end) {\n                // forward jump\n                offset += sizes[i];\n            } else if (end < indexes[i] && indexes[i] <= begin) {\n                // backward jump\n                offset -= sizes[i];\n            }\n        }\n        return offset;\n    }\n\n    /**\n     * Updates the offset of the given label.\n     *\n     * @param indexes current positions of the instructions to be resized. Each\n     *        instruction must be designated by the index of its <i>last</i>\n     *        byte, plus one (or, in other words, by the index of the <i>first</i>\n     *        byte of the <i>next</i> instruction).\n     * @param sizes the number of bytes to be <i>added</i> to the above\n     *        instructions. More precisely, for each i < <tt>len</tt>,\n     *        <tt>sizes</tt>[i] bytes will be added at the end of the\n     *        instruction designated by <tt>indexes</tt>[i] or, if\n     *        <tt>sizes</tt>[i] is negative, the <i>last</i> |<tt>sizes[i]</tt>|\n     *        bytes of the instruction will be removed (the instruction size\n     *        <i>must not</i> become negative or null).\n     * @param label the label whose offset must be updated.\n     */\n    static void getNewOffset(final int[] indexes, final int[] sizes, final Label label) {\n        if ((label.status & Label.RESIZED) == 0) {\n            label.position = getNewOffset(indexes, sizes, 0, label.position);\n            label.status |= Label.RESIZED;\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/MethodWriterTest0.java",
		"test_prompt": "// MethodWriterTest0.java\npackage org.objectweb.asm.jip;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MethodWriter}.\n* It contains ten unit test cases for the {@link MethodWriter#visitAnnotationDefault()} method.\n*/\nclass MethodWriterTest0 {"
	},
	{
		"original_code": "// MethodWriter.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\n/**\n * A {@link MethodVisitor} that generates methods in bytecode form. Each visit\n * method of this class appends the bytecode corresponding to the visited\n * instruction to a byte vector, in the order these methods are called.\n *\n * @author Eric Bruneton\n * @author Eugene Kuleshov\n */\nclass MethodWriter implements MethodVisitor {\n\n    /**\n     * Pseudo access flag used to denote constructors.\n     */\n    static final int ACC_CONSTRUCTOR = 262144;\n\n    /**\n     * Frame has exactly the same locals as the previous stack map frame and\n     * number of stack items is zero.\n     */\n    // to 63 (0-3f)\n    static final int SAME_FRAME = 0;\n\n    /**\n     * Frame has exactly the same locals as the previous stack map frame and\n     * number of stack items is 1\n     */\n    // to 127 (40-7f)\n    static final int SAME_LOCALS_1_STACK_ITEM_FRAME = 64;\n\n    /**\n     * Reserved for future use\n     */\n    static final int RESERVED = 128;\n\n    /**\n     * Frame has exactly the same locals as the previous stack map frame and\n     * number of stack items is 1. Offset is bigger then 63;\n     */\n    // f7\n    static final int SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED = 247;\n\n    /**\n     * Frame where current locals are the same as the locals in the previous\n     * frame, except that the k last locals are absent. The value of k is given\n     * by the formula 251-frame_type.\n     */\n    // to 250 (f8-fA)\n    static final int CHOP_FRAME = 248;\n\n    /**\n     * Frame has exactly the same locals as the previous stack map frame and\n     * number of stack items is zero. Offset is bigger then 63;\n     */\n    // fb\n    static final int SAME_FRAME_EXTENDED = 251;\n\n    /**\n     * Frame where current locals are the same as the locals in the previous\n     * frame, except that k additional locals are defined. The value of k is\n     * given by the formula frame_type-251.\n     */\n    // to 254 // fc-fe\n    static final int APPEND_FRAME = 252;\n\n    /**\n     * Full frame\n     */\n    // ff\n    static final int FULL_FRAME = 255;\n\n    /**\n     * Indicates that the stack map frames must be recomputed from scratch. In\n     * this case the maximum stack size and number of local variables is also\n     * recomputed from scratch.\n     *\n     * @see #compute\n     */\n    private static final int FRAMES = 0;\n\n    /**\n     * Indicates that the maximum stack size and number of local variables must\n     * be automatically computed.\n     *\n     * @see #compute\n     */\n    private static final int MAXS = 1;\n\n    /**\n     * Indicates that nothing must be automatically computed.\n     *\n     * @see #compute\n     */\n    private static final int NOTHING = 2;\n\n    /**\n     * Next method writer (see {@link ClassWriter#firstMethod firstMethod}).\n     */\n    MethodWriter next;\n\n    /**\n     * The class writer to which this method must be added.\n     */\n    final ClassWriter cw;\n\n    /**\n     * Access flags of this method.\n     */\n    private int access;\n\n    /**\n     * The index of the constant pool item that contains the name of this\n     * method.\n     */\n    private final int name;\n\n    /**\n     * The index of the constant pool item that contains the descriptor of this\n     * method.\n     */\n    private final int desc;\n\n    /**\n     * The descriptor of this method.\n     */\n    private final String descriptor;\n\n    /**\n     * The signature of this method.\n     */\n    String signature;\n\n    /**\n     * If not zero, indicates that the code of this method must be copied from\n     * the ClassReader associated to this writer in <code>cw.cr</code>. More\n     * precisely, this field gives the index of the first byte to copied from\n     * <code>cw.cr.b</code>.\n     */\n    int classReaderOffset;\n\n    /**\n     * If not zero, indicates that the code of this method must be copied from\n     * the ClassReader associated to this writer in <code>cw.cr</code>. More\n     * precisely, this field gives the number of bytes to copied from\n     * <code>cw.cr.b</code>.\n     */\n    int classReaderLength;\n\n    /**\n     * Number of exceptions that can be thrown by this method.\n     */\n    int exceptionCount;\n\n    /**\n     * The exceptions that can be thrown by this method. More precisely, this\n     * array contains the indexes of the constant pool items that contain the\n     * internal names of these exception classes.\n     */\n    int[] exceptions;\n\n    /**\n     * The annotation default attribute of this method. May be <tt>null</tt>.\n     */\n    private ByteVector annd;\n\n    /**\n     * The runtime visible annotations of this method. May be <tt>null</tt>.\n     */\n    private AnnotationWriter anns;\n\n    /**\n     * The runtime invisible annotations of this method. May be <tt>null</tt>.\n     */\n    private AnnotationWriter ianns;\n\n    /**\n     * The runtime visible parameter annotations of this method. May be\n     * <tt>null</tt>.\n     */\n    private AnnotationWriter[] panns;\n\n    /**\n     * The runtime invisible parameter annotations of this method. May be\n     * <tt>null</tt>.\n     */\n    private AnnotationWriter[] ipanns;\n\n    /**\n     * The number of synthetic parameters of this method.\n     */\n    private int synthetics;\n\n    /**\n     * The non standard attributes of the method.\n     */\n    private Attribute attrs;\n\n    /**\n     * The bytecode of this method.\n     */\n    private ByteVector code = new ByteVector();\n\n    /**\n     * Maximum stack size of this method.\n     */\n    private int maxStack;\n\n    /**\n     * Maximum number of local variables for this method.\n     */\n    private int maxLocals;\n\n    /**\n     * Number of stack map frames in the StackMapTable attribute.\n     */\n    private int frameCount;\n\n    /**\n     * The StackMapTable attribute.\n     */\n    private ByteVector stackMap;\n\n    /**\n     * The offset of the last frame that was written in the StackMapTable\n     * attribute.\n     */\n    private int previousFrameOffset;\n\n    /**\n     * The last frame that was written in the StackMapTable attribute.\n     *\n     * @see #frame\n     */\n    private int[] previousFrame;\n\n    /**\n     * Index of the next element to be added in {@link #frame}.\n     */\n    private int frameIndex;\n\n    /**\n     * The current stack map frame. The first element contains the offset of the\n     * instruction to which the frame corresponds, the second element is the\n     * number of locals and the third one is the number of stack elements. The\n     * local variables start at index 3 and are followed by the operand stack\n     * values. In summary frame[0] = offset, frame[1] = nLocal, frame[2] =\n     * nStack, frame[3] = nLocal. All types are encoded as integers, with the\n     * same format as the one used in {@link Label}, but limited to BASE types.\n     */\n    private int[] frame;\n\n    /**\n     * Number of elements in the exception handler list.\n     */\n    private int handlerCount;\n\n    /**\n     * The first element in the exception handler list.\n     */\n    private Handler firstHandler;\n\n    /**\n     * The last element in the exception handler list.\n     */\n    private Handler lastHandler;\n\n    /**\n     * Number of entries in the LocalVariableTable attribute.\n     */\n    private int localVarCount;\n\n    /**\n     * The LocalVariableTable attribute.\n     */\n    private ByteVector localVar;\n\n    /**\n     * Number of entries in the LocalVariableTypeTable attribute.\n     */\n    private int localVarTypeCount;\n\n    /**\n     * The LocalVariableTypeTable attribute.\n     */\n    private ByteVector localVarType;\n\n    /**\n     * Number of entries in the LineNumberTable attribute.\n     */\n    private int lineNumberCount;\n\n    /**\n     * The LineNumberTable attribute.\n     */\n    private ByteVector lineNumber;\n\n    /**\n     * The non standard attributes of the method's code.\n     */\n    private Attribute cattrs;\n\n    /**\n     * Indicates if some jump instructions are too small and need to be resized.\n     */\n    private boolean resize;\n\n    /**\n     * The number of subroutines in this method.\n     */\n    private int subroutines;\n\n    // ------------------------------------------------------------------------\n    /*\n     * Fields for the control flow graph analysis algorithm (used to compute the\n     * maximum stack size). A control flow graph contains one node per \"basic\n     * block\", and one edge per \"jump\" from one basic block to another. Each\n     * node (i.e., each basic block) is represented by the Label object that\n     * corresponds to the first instruction of this basic block. Each node also\n     * stores the list of its successors in the graph, as a linked list of Edge\n     * objects.\n     */\n    /**\n     * Indicates what must be automatically computed.\n     *\n     * @see #FRAMES\n     * @see #MAXS\n     * @see #NOTHING\n     */\n    private final int compute;\n\n    /**\n     * A list of labels. This list is the list of basic blocks in the method,\n     * i.e. a list of Label objects linked to each other by their\n     * {@link Label#successor} field, in the order they are visited by\n     * {@link MethodVisitor#visitLabel}, and starting with the first basic block.\n     */\n    private Label labels;\n\n    /**\n     * The previous basic block.\n     */\n    private Label previousBlock;\n\n    /**\n     * The current basic block.\n     */\n    private Label currentBlock;\n\n    /**\n     * The (relative) stack size after the last visited instruction. This size\n     * is relative to the beginning of the current basic block, i.e., the true\n     * stack size after the last visited instruction is equal to the\n     * {@link Label#inputStackTop beginStackSize} of the current basic block\n     * plus <tt>stackSize</tt>.\n     */\n    private int stackSize;\n\n    /**\n     * The (relative) maximum stack size after the last visited instruction.\n     * This size is relative to the beginning of the current basic block, i.e.,\n     * the true maximum stack size after the last visited instruction is equal\n     * to the {@link Label#inputStackTop beginStackSize} of the current basic\n     * block plus <tt>stackSize</tt>.\n     */\n    private int maxStackSize;\n\n    // ------------------------------------------------------------------------\n    // Constructor\n    // ------------------------------------------------------------------------\n    /**\n     * Constructs a new {@link MethodWriter}.\n     *\n     * @param cw the class writer in which the method must be added.\n     * @param access the method's access flags (see {@link Opcodes}).\n     * @param name the method's name.\n     * @param desc the method's descriptor (see {@link Type}).\n     * @param signature the method's signature. May be <tt>null</tt>.\n     * @param exceptions the internal names of the method's exceptions. May be\n     *        <tt>null</tt>.\n     * @param computeMaxs <tt>true</tt> if the maximum stack size and number\n     *        of local variables must be automatically computed.\n     * @param computeFrames <tt>true</tt> if the stack map tables must be\n     *        recomputed from scratch.\n     */\n    MethodWriter(final ClassWriter cw, final int access, final String name, final String desc, final String signature, final String[] exceptions, final boolean computeMaxs, final boolean computeFrames) {\n        if (cw.firstMethod == null) {\n            cw.firstMethod = this;\n        } else {\n            cw.lastMethod.next = this;\n        }\n        cw.lastMethod = this;\n        this.cw = cw;\n        this.access = access;\n        this.name = cw.newUTF8(name);\n        this.desc = cw.newUTF8(desc);\n        this.descriptor = desc;\n        if (ClassReader.SIGNATURES) {\n            this.signature = signature;\n        }\n        if (exceptions != null && exceptions.length > 0) {\n            exceptionCount = exceptions.length;\n            this.exceptions = new int[exceptionCount];\n            for (int i = 0; i < exceptionCount; ++i) {\n                this.exceptions[i] = cw.newClass(exceptions[i]);\n            }\n        }\n        this.compute = computeFrames ? FRAMES : (computeMaxs ? MAXS : NOTHING);\n        if (computeMaxs || computeFrames) {\n            if (computeFrames && \"<init>\".equals(name)) {\n                this.access |= ACC_CONSTRUCTOR;\n            }\n            // updates maxLocals\n            int size = Type.getArgumentsAndReturnSizes(descriptor) >> 2;\n            if ((access & Opcodes.ACC_STATIC) != 0) {\n                --size;\n            }\n            maxLocals = size;\n            // creates and visits the label for the first basic block\n            labels = new Label();\n            labels.status |= Label.PUSHED;\n            visitLabel(labels);\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Implementation of the MethodVisitor interface\n    // ------------------------------------------------------------------------\n    public AnnotationVisitor visitAnnotationDefault() {\n        if (!ClassReader.ANNOTATIONS) {\n            return null;\n        }\n        annd = new ByteVector();\n        return new AnnotationWriter(cw, false, annd, null, 0);\n    }\n\n    public AnnotationVisitor visitAnnotation(final String desc, final boolean visible) {\n        if (!ClassReader.ANNOTATIONS) {\n            return null;\n        }\n        ByteVector bv = new ByteVector();\n        // write type, and reserve space for values count\n        bv.putShort(cw.newUTF8(desc)).putShort(0);\n        AnnotationWriter aw = new AnnotationWriter(cw, true, bv, bv, 2);\n        if (visible) {\n            aw.next = anns;\n            anns = aw;\n        } else {\n            aw.next = ianns;\n            ianns = aw;\n        }\n        return aw;\n    }\n\n    public AnnotationVisitor visitParameterAnnotation(final int parameter, final String desc, final boolean visible) {\n        if (!ClassReader.ANNOTATIONS) {\n            return null;\n        }\n        ByteVector bv = new ByteVector();\n        if (\"Ljava/lang/Synthetic;\".equals(desc)) {\n            // workaround for a bug in javac with synthetic parameters\n            // see ClassReader.readParameterAnnotations\n            synthetics = Math.max(synthetics, parameter + 1);\n            return new AnnotationWriter(cw, false, bv, null, 0);\n        }\n        // write type, and reserve space for values count\n        bv.putShort(cw.newUTF8(desc)).putShort(0);\n        AnnotationWriter aw = new AnnotationWriter(cw, true, bv, bv, 2);\n        if (visible) {\n            if (panns == null) {\n                panns = new AnnotationWriter[Type.getArgumentTypes(descriptor).length];\n            }\n            aw.next = panns[parameter];\n            panns[parameter] = aw;\n        } else {\n            if (ipanns == null) {\n                ipanns = new AnnotationWriter[Type.getArgumentTypes(descriptor).length];\n            }\n            aw.next = ipanns[parameter];\n            ipanns[parameter] = aw;\n        }\n        return aw;\n    }\n\n    public void visitAttribute(final Attribute attr) {\n        if (attr.isCodeAttribute()) {\n            attr.next = cattrs;\n            cattrs = attr;\n        } else {\n            attr.next = attrs;\n            attrs = attr;\n        }\n    }\n\n    public void visitCode() {\n    }\n\n    public void visitFrame(final int type, final int nLocal, final Object[] local, final int nStack, final Object[] stack) {\n        if (!ClassReader.FRAMES || compute == FRAMES) {\n            return;\n        }\n        if (type == Opcodes.F_NEW) {\n            startFrame(code.length, nLocal, nStack);\n            for (int i = 0; i < nLocal; ++i) {\n                if (local[i] instanceof String) {\n                    frame[frameIndex++] = Frame.OBJECT | cw.addType((String) local[i]);\n                } else if (local[i] instanceof Integer) {\n                    frame[frameIndex++] = ((Integer) local[i]).intValue();\n                } else {\n                    frame[frameIndex++] = Frame.UNINITIALIZED | cw.addUninitializedType(\"\", ((Label) local[i]).position);\n                }\n            }\n            for (int i = 0; i < nStack; ++i) {\n                if (stack[i] instanceof String) {\n                    frame[frameIndex++] = Frame.OBJECT | cw.addType((String) stack[i]);\n                } else if (stack[i] instanceof Integer) {\n                    frame[frameIndex++] = ((Integer) stack[i]).intValue();\n                } else {\n                    frame[frameIndex++] = Frame.UNINITIALIZED | cw.addUninitializedType(\"\", ((Label) stack[i]).position);\n                }\n            }\n            endFrame();\n        } else {\n            int delta;\n            if (stackMap == null) {\n                stackMap = new ByteVector();\n                delta = code.length;\n            } else {\n                delta = code.length - previousFrameOffset - 1;\n                if (delta < 0) {\n                    if (type == Opcodes.F_SAME) {\n                        return;\n                    } else {\n                        throw new IllegalStateException();\n                    }\n                }\n            }\n            switch(type) {\n                case Opcodes.F_FULL:\n                    stackMap.putByte(FULL_FRAME).putShort(delta).putShort(nLocal);\n                    for (int i = 0; i < nLocal; ++i) {\n                        writeFrameType(local[i]);\n                    }\n                    stackMap.putShort(nStack);\n                    for (int i = 0; i < nStack; ++i) {\n                        writeFrameType(stack[i]);\n                    }\n                    break;\n                case Opcodes.F_APPEND:\n                    stackMap.putByte(SAME_FRAME_EXTENDED + nLocal).putShort(delta);\n                    for (int i = 0; i < nLocal; ++i) {\n                        writeFrameType(local[i]);\n                    }\n                    break;\n                case Opcodes.F_CHOP:\n                    stackMap.putByte(SAME_FRAME_EXTENDED - nLocal).putShort(delta);\n                    break;\n                case Opcodes.F_SAME:\n                    if (delta < 64) {\n                        stackMap.putByte(delta);\n                    } else {\n                        stackMap.putByte(SAME_FRAME_EXTENDED).putShort(delta);\n                    }\n                    break;\n                case Opcodes.F_SAME1:\n                    if (delta < 64) {\n                        stackMap.putByte(SAME_LOCALS_1_STACK_ITEM_FRAME + delta);\n                    } else {\n                        stackMap.putByte(SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED).putShort(delta);\n                    }\n                    writeFrameType(stack[0]);\n                    break;\n            }\n            previousFrameOffset = code.length;\n            ++frameCount;\n        }\n    }\n\n    public void visitInsn(final int opcode) {\n        // adds the instruction to the bytecode of the method\n        code.putByte(opcode);\n        // update currentBlock\n        // Label currentBlock = this.currentBlock;\n        if (currentBlock != null) {\n            if (compute == FRAMES) {\n                currentBlock.frame.execute(opcode, 0, null, null);\n            } else {\n                // updates current and max stack sizes\n                int size = stackSize + Frame.SIZE[opcode];\n                if (size > maxStackSize) {\n                    maxStackSize = size;\n                }\n                stackSize = size;\n            }\n            // if opcode == ATHROW or xRETURN, ends current block (no successor)\n            if ((opcode >= Opcodes.IRETURN && opcode <= Opcodes.RETURN) || opcode == Opcodes.ATHROW) {\n                noSuccessor();\n            }\n        }\n    }\n\n    public void visitIntInsn(final int opcode, final int operand) {\n        // Label currentBlock = this.currentBlock;\n        if (currentBlock != null) {\n            if (compute == FRAMES) {\n                currentBlock.frame.execute(opcode, operand, null, null);\n            } else if (opcode != Opcodes.NEWARRAY) {\n                // updates current and max stack sizes only for NEWARRAY\n                // (stack size variation = 0 for BIPUSH or SIPUSH)\n                int size = stackSize + 1;\n                if (size > maxStackSize) {\n                    maxStackSize = size;\n                }\n                stackSize = size;\n            }\n        }\n        // adds the instruction to the bytecode of the method\n        if (opcode == Opcodes.SIPUSH) {\n            code.put12(opcode, operand);\n        } else {\n            // BIPUSH or NEWARRAY\n            code.put11(opcode, operand);\n        }\n    }\n\n    public void visitVarInsn(final int opcode, final int var) {\n        // Label currentBlock = this.currentBlock;\n        if (currentBlock != null) {\n            if (compute == FRAMES) {\n                currentBlock.frame.execute(opcode, var, null, null);\n            } else {\n                // updates current and max stack sizes\n                if (opcode == Opcodes.RET) {\n                    // no stack change, but end of current block (no successor)\n                    currentBlock.status |= Label.RET;\n                    // save 'stackSize' here for future use\n                    // (see {@link #findSubroutineSuccessors})\n                    currentBlock.inputStackTop = stackSize;\n                    noSuccessor();\n                } else {\n                    // xLOAD or xSTORE\n                    int size = stackSize + Frame.SIZE[opcode];\n                    if (size > maxStackSize) {\n                        maxStackSize = size;\n                    }\n                    stackSize = size;\n                }\n            }\n        }\n        if (compute != NOTHING) {\n            // updates max locals\n            int n;\n            if (opcode == Opcodes.LLOAD || opcode == Opcodes.DLOAD || opcode == Opcodes.LSTORE || opcode == Opcodes.DSTORE) {\n                n = var + 2;\n            } else {\n                n = var + 1;\n            }\n            if (n > maxLocals) {\n                maxLocals = n;\n            }\n        }\n        // adds the instruction to the bytecode of the method\n        if (var < 4 && opcode != Opcodes.RET) {\n            int opt;\n            if (opcode < Opcodes.ISTORE) {\n                /* ILOAD_0 */\n                opt = 26 + ((opcode - Opcodes.ILOAD) << 2) + var;\n            } else {\n                /* ISTORE_0 */\n                opt = 59 + ((opcode - Opcodes.ISTORE) << 2) + var;\n            }\n            code.putByte(opt);\n        } else if (var >= 256) {\n            code.putByte(196).put12(opcode, var);\n        } else {\n            code.put11(opcode, var);\n        }\n        if (opcode >= Opcodes.ISTORE && compute == FRAMES && handlerCount > 0) {\n            visitLabel(new Label());\n        }\n    }\n\n    public void visitTypeInsn(final int opcode, final String type) {\n        Item i = cw.newClassItem(type);\n        // Label currentBlock = this.currentBlock;\n        if (currentBlock != null) {\n            if (compute == FRAMES) {\n                currentBlock.frame.execute(opcode, code.length, cw, i);\n            } else if (opcode == Opcodes.NEW) {\n                // updates current and max stack sizes only if opcode == NEW\n                // (no stack change for ANEWARRAY, CHECKCAST, INSTANCEOF)\n                int size = stackSize + 1;\n                if (size > maxStackSize) {\n                    maxStackSize = size;\n                }\n                stackSize = size;\n            }\n        }\n        // adds the instruction to the bytecode of the method\n        code.put12(opcode, i.index);\n    }\n\n    public void visitFieldInsn(final int opcode, final String owner, final String name, final String desc) {\n        Item i = cw.newFieldItem(owner, name, desc);\n        // Label currentBlock = this.currentBlock;\n        if (currentBlock != null) {\n            if (compute == FRAMES) {\n                currentBlock.frame.execute(opcode, 0, cw, i);\n            } else {\n                int size;\n                // computes the stack size variation\n                char c = desc.charAt(0);\n                switch(opcode) {\n                    case Opcodes.GETSTATIC:\n                        size = stackSize + (c == 'D' || c == 'J' ? 2 : 1);\n                        break;\n                    case Opcodes.PUTSTATIC:\n                        size = stackSize + (c == 'D' || c == 'J' ? -2 : -1);\n                        break;\n                    case Opcodes.GETFIELD:\n                        size = stackSize + (c == 'D' || c == 'J' ? 1 : 0);\n                        break;\n                    // case Constants.PUTFIELD:\n                    default:\n                        size = stackSize + (c == 'D' || c == 'J' ? -3 : -2);\n                        break;\n                }\n                // updates current and max stack sizes\n                if (size > maxStackSize) {\n                    maxStackSize = size;\n                }\n                stackSize = size;\n            }\n        }\n        // adds the instruction to the bytecode of the method\n        code.put12(opcode, i.index);\n    }\n\n    public void visitMethodInsn(final int opcode, final String owner, final String name, final String desc) {\n        boolean itf = opcode == Opcodes.INVOKEINTERFACE;\n        Item i = (opcode == Opcodes.INVOKEDYNAMIC) ? cw.newNameTypeItem(name, desc) : cw.newMethodItem(owner, name, desc, itf);\n        int argSize = i.intVal;\n        // Label currentBlock = this.currentBlock;\n        if (currentBlock != null) {\n            if (compute == FRAMES) {\n                currentBlock.frame.execute(opcode, 0, cw, i);\n            } else {\n                /*\n                 * computes the stack size variation. In order not to recompute\n                 * several times this variation for the same Item, we use the\n                 * intVal field of this item to store this variation, once it\n                 * has been computed. More precisely this intVal field stores\n                 * the sizes of the arguments and of the return value\n                 * corresponding to desc.\n                 */\n                if (argSize == 0) {\n                    // the above sizes have not been computed yet,\n                    // so we compute them...\n                    argSize = Type.getArgumentsAndReturnSizes(desc);\n                    // ... and we save them in order\n                    // not to recompute them in the future\n                    i.intVal = argSize;\n                }\n                int size;\n                if (opcode == Opcodes.INVOKESTATIC || opcode == Opcodes.INVOKEDYNAMIC) {\n                    size = stackSize - (argSize >> 2) + (argSize & 0x03) + 1;\n                } else {\n                    size = stackSize - (argSize >> 2) + (argSize & 0x03);\n                }\n                // updates current and max stack sizes\n                if (size > maxStackSize) {\n                    maxStackSize = size;\n                }\n                stackSize = size;\n            }\n        }\n        // adds the instruction to the bytecode of the method\n        if (itf) {\n            if (argSize == 0) {\n                argSize = Type.getArgumentsAndReturnSizes(desc);\n                i.intVal = argSize;\n            }\n            code.put12(Opcodes.INVOKEINTERFACE, i.index).put11(argSize >> 2, 0);\n        } else {\n            code.put12(opcode, i.index);\n            if (opcode == Opcodes.INVOKEDYNAMIC) {\n                code.putShort(0);\n            }\n        }\n    }\n\n    public void visitJumpInsn(final int opcode, final Label label) {\n        Label nextInsn = null;\n        // Label currentBlock = this.currentBlock;\n        if (currentBlock != null) {\n            if (compute == FRAMES) {\n                currentBlock.frame.execute(opcode, 0, null, null);\n                // 'label' is the target of a jump instruction\n                label.getFirst().status |= Label.TARGET;\n                // adds 'label' as a successor of this basic block\n                addSuccessor(Edge.NORMAL, label);\n                if (opcode != Opcodes.GOTO) {\n                    // creates a Label for the next basic block\n                    nextInsn = new Label();\n                }\n            } else {\n                if (opcode == Opcodes.JSR) {\n                    if ((label.status & Label.SUBROUTINE) == 0) {\n                        label.status |= Label.SUBROUTINE;\n                        ++subroutines;\n                    }\n                    currentBlock.status |= Label.JSR;\n                    addSuccessor(stackSize + 1, label);\n                    // creates a Label for the next basic block\n                    nextInsn = new Label();\n                    /*\n                     * note that, by construction in this method, a JSR block\n                     * has at least two successors in the control flow graph:\n                     * the first one leads the next instruction after the JSR,\n                     * while the second one leads to the JSR target.\n                     */\n                } else {\n                    // updates current stack size (max stack size unchanged\n                    // because stack size variation always negative in this\n                    // case)\n                    stackSize += Frame.SIZE[opcode];\n                    addSuccessor(stackSize, label);\n                }\n            }\n        }\n        // adds the instruction to the bytecode of the method\n        if ((label.status & Label.RESOLVED) != 0 && label.position - code.length < Short.MIN_VALUE) {\n            /*\n             * case of a backward jump with an offset < -32768. In this case we\n             * automatically replace GOTO with GOTO_W, JSR with JSR_W and IFxxx\n             * <l> with IFNOTxxx <l'> GOTO_W <l>, where IFNOTxxx is the\n             * \"opposite\" opcode of IFxxx (i.e., IFNE for IFEQ) and where <l'>\n             * designates the instruction just after the GOTO_W.\n             */\n            if (opcode == Opcodes.GOTO) {\n                // GOTO_W\n                code.putByte(200);\n            } else if (opcode == Opcodes.JSR) {\n                // JSR_W\n                code.putByte(201);\n            } else {\n                // if the IF instruction is transformed into IFNOT GOTO_W the\n                // next instruction becomes the target of the IFNOT instruction\n                if (nextInsn != null) {\n                    nextInsn.status |= Label.TARGET;\n                }\n                code.putByte(opcode <= 166 ? ((opcode + 1) ^ 1) - 1 : opcode ^ 1);\n                // jump offset\n                code.putShort(8);\n                // GOTO_W\n                code.putByte(200);\n            }\n            label.put(this, code, code.length - 1, true);\n        } else {\n            /*\n             * case of a backward jump with an offset >= -32768, or of a forward\n             * jump with, of course, an unknown offset. In these cases we store\n             * the offset in 2 bytes (which will be increased in\n             * resizeInstructions, if needed).\n             */\n            code.putByte(opcode);\n            label.put(this, code, code.length - 1, false);\n        }\n        if (currentBlock != null) {\n            if (nextInsn != null) {\n                // if the jump instruction is not a GOTO, the next instruction\n                // is also a successor of this instruction. Calling visitLabel\n                // adds the label of this next instruction as a successor of the\n                // current block, and starts a new basic block\n                visitLabel(nextInsn);\n            }\n            if (opcode == Opcodes.GOTO) {\n                noSuccessor();\n            }\n        }\n    }\n\n    public void visitLabel(final Label label) {\n        // resolves previous forward references to label, if any\n        resize |= label.resolve(this, code.length, code.data);\n        // updates currentBlock\n        if ((label.status & Label.DEBUG) != 0) {\n            return;\n        }\n        if (compute == FRAMES) {\n            if (currentBlock != null) {\n                if (label.position == currentBlock.position) {\n                    // successive labels, do not start a new basic block\n                    currentBlock.status |= (label.status & Label.TARGET);\n                    label.frame = currentBlock.frame;\n                    return;\n                }\n                // ends current block (with one new successor)\n                addSuccessor(Edge.NORMAL, label);\n            }\n            // begins a new current block\n            currentBlock = label;\n            if (label.frame == null) {\n                label.frame = new Frame();\n                label.frame.owner = label;\n            }\n            // updates the basic block list\n            if (previousBlock != null) {\n                if (label.position == previousBlock.position) {\n                    previousBlock.status |= (label.status & Label.TARGET);\n                    label.frame = previousBlock.frame;\n                    currentBlock = previousBlock;\n                    return;\n                }\n                previousBlock.successor = label;\n            }\n            previousBlock = label;\n        } else if (compute == MAXS) {\n            if (currentBlock != null) {\n                // ends current block (with one new successor)\n                currentBlock.outputStackMax = maxStackSize;\n                addSuccessor(stackSize, label);\n            }\n            // begins a new current block\n            currentBlock = label;\n            // resets the relative current and max stack sizes\n            stackSize = 0;\n            maxStackSize = 0;\n            // updates the basic block list\n            if (previousBlock != null) {\n                previousBlock.successor = label;\n            }\n            previousBlock = label;\n        }\n    }\n\n    public void visitLdcInsn(final Object cst) {\n        Item i = cw.newConstItem(cst);\n        // Label currentBlock = this.currentBlock;\n        if (currentBlock != null) {\n            if (compute == FRAMES) {\n                currentBlock.frame.execute(Opcodes.LDC, 0, cw, i);\n            } else {\n                int size;\n                // computes the stack size variation\n                if (i.type == ClassWriter.LONG || i.type == ClassWriter.DOUBLE) {\n                    size = stackSize + 2;\n                } else {\n                    size = stackSize + 1;\n                }\n                // updates current and max stack sizes\n                if (size > maxStackSize) {\n                    maxStackSize = size;\n                }\n                stackSize = size;\n            }\n        }\n        // adds the instruction to the bytecode of the method\n        int index = i.index;\n        if (i.type == ClassWriter.LONG || i.type == ClassWriter.DOUBLE) {\n            code.put12(20, /* LDC2_W */\n            index);\n        } else if (index >= 256) {\n            code.put12(19, /* LDC_W */\n            index);\n        } else {\n            code.put11(Opcodes.LDC, index);\n        }\n    }\n\n    public void visitIincInsn(final int var, final int increment) {\n        if (currentBlock != null) {\n            if (compute == FRAMES) {\n                currentBlock.frame.execute(Opcodes.IINC, var, null, null);\n            }\n        }\n        if (compute != NOTHING) {\n            // updates max locals\n            int n = var + 1;\n            if (n > maxLocals) {\n                maxLocals = n;\n            }\n        }\n        // adds the instruction to the bytecode of the method\n        if ((var > 255) || (increment > 127) || (increment < -128)) {\n            code.putByte(196).put12(Opcodes.IINC, var).putShort(increment);\n        } else {\n            code.putByte(Opcodes.IINC).put11(var, increment);\n        }\n    }\n\n    public void visitTableSwitchInsn(final int min, final int max, final Label dflt, final Label[] labels) {\n        // adds the instruction to the bytecode of the method\n        int source = code.length;\n        code.putByte(Opcodes.TABLESWITCH);\n        code.putByteArray(null, 0, (4 - code.length % 4) % 4);\n        dflt.put(this, code, source, true);\n        code.putInt(min).putInt(max);\n        for (int i = 0; i < labels.length; ++i) {\n            labels[i].put(this, code, source, true);\n        }\n        // updates currentBlock\n        visitSwitchInsn(dflt, labels);\n    }\n\n    public void visitLookupSwitchInsn(final Label dflt, final int[] keys, final Label[] labels) {\n        // adds the instruction to the bytecode of the method\n        int source = code.length;\n        code.putByte(Opcodes.LOOKUPSWITCH);\n        code.putByteArray(null, 0, (4 - code.length % 4) % 4);\n        dflt.put(this, code, source, true);\n        code.putInt(labels.length);\n        for (int i = 0; i < labels.length; ++i) {\n            code.putInt(keys[i]);\n            labels[i].put(this, code, source, true);\n        }\n        // updates currentBlock\n        visitSwitchInsn(dflt, labels);\n    }\n\n    private void visitSwitchInsn(final Label dflt, final Label[] labels) {\n        // Label currentBlock = this.currentBlock;\n        if (currentBlock != null) {\n            if (compute == FRAMES) {\n                currentBlock.frame.execute(Opcodes.LOOKUPSWITCH, 0, null, null);\n                // adds current block successors\n                addSuccessor(Edge.NORMAL, dflt);\n                dflt.getFirst().status |= Label.TARGET;\n                for (int i = 0; i < labels.length; ++i) {\n                    addSuccessor(Edge.NORMAL, labels[i]);\n                    labels[i].getFirst().status |= Label.TARGET;\n                }\n            } else {\n                // updates current stack size (max stack size unchanged)\n                --stackSize;\n                // adds current block successors\n                addSuccessor(stackSize, dflt);\n                for (int i = 0; i < labels.length; ++i) {\n                    addSuccessor(stackSize, labels[i]);\n                }\n            }\n            // ends current block\n            noSuccessor();\n        }\n    }\n\n    public void visitMultiANewArrayInsn(final String desc, final int dims) {\n        Item i = cw.newClassItem(desc);\n        // Label currentBlock = this.currentBlock;\n        if (currentBlock != null) {\n            if (compute == FRAMES) {\n                currentBlock.frame.execute(Opcodes.MULTIANEWARRAY, dims, cw, i);\n            } else {\n                // updates current stack size (max stack size unchanged because\n                // stack size variation always negative or null)\n                stackSize += 1 - dims;\n            }\n        }\n        // adds the instruction to the bytecode of the method\n        code.put12(Opcodes.MULTIANEWARRAY, i.index).putByte(dims);\n    }\n\n    public void visitTryCatchBlock(final Label start, final Label end, final Label handler, final String type) {\n        ++handlerCount;\n        Handler h = new Handler();\n        h.start = start;\n        h.end = end;\n        h.handler = handler;\n        h.desc = type;\n        h.type = type != null ? cw.newClass(type) : 0;\n        if (lastHandler == null) {\n            firstHandler = h;\n        } else {\n            lastHandler.next = h;\n        }\n        lastHandler = h;\n    }\n\n    public void visitLocalVariable(final String name, final String desc, final String signature, final Label start, final Label end, final int index) {\n        if (signature != null) {\n            if (localVarType == null) {\n                localVarType = new ByteVector();\n            }\n            ++localVarTypeCount;\n            localVarType.putShort(start.position).putShort(end.position - start.position).putShort(cw.newUTF8(name)).putShort(cw.newUTF8(signature)).putShort(index);\n        }\n        if (localVar == null) {\n            localVar = new ByteVector();\n        }\n        ++localVarCount;\n        localVar.putShort(start.position).putShort(end.position - start.position).putShort(cw.newUTF8(name)).putShort(cw.newUTF8(desc)).putShort(index);\n        if (compute != NOTHING) {\n            // updates max locals\n            char c = desc.charAt(0);\n            int n = index + (c == 'J' || c == 'D' ? 2 : 1);\n            if (n > maxLocals) {\n                maxLocals = n;\n            }\n        }\n    }\n\n    public void visitLineNumber(final int line, final Label start) {\n        if (lineNumber == null) {\n            lineNumber = new ByteVector();\n        }\n        ++lineNumberCount;\n        lineNumber.putShort(start.position);\n        lineNumber.putShort(line);\n    }\n\n    public void visitMaxs(final int maxStack, final int maxLocals) {\n        if (ClassReader.FRAMES && compute == FRAMES) {\n            // completes the control flow graph with exception handler blocks\n            Handler handler = firstHandler;\n            while (handler != null) {\n                Label l = handler.start.getFirst();\n                Label h = handler.handler.getFirst();\n                Label e = handler.end.getFirst();\n                // computes the kind of the edges to 'h'\n                String t = handler.desc == null ? \"java/lang/Throwable\" : handler.desc;\n                int kind = Frame.OBJECT | cw.addType(t);\n                // h is an exception handler\n                h.status |= Label.TARGET;\n                // adds 'h' as a successor of labels between 'start' and 'end'\n                while (l != e) {\n                    // creates an edge to 'h'\n                    Edge b = new Edge();\n                    b.info = kind;\n                    b.successor = h;\n                    // adds it to the successors of 'l'\n                    b.next = l.successors;\n                    l.successors = b;\n                    // goes to the next label\n                    l = l.successor;\n                }\n                handler = handler.next;\n            }\n            // creates and visits the first (implicit) frame\n            Frame f = labels.frame;\n            Type[] args = Type.getArgumentTypes(descriptor);\n            f.initInputFrame(cw, access, args, this.maxLocals);\n            visitFrame(f);\n            /*\n             * fix point algorithm: mark the first basic block as 'changed'\n             * (i.e. put it in the 'changed' list) and, while there are changed\n             * basic blocks, choose one, mark it as unchanged, and update its\n             * successors (which can be changed in the process).\n             */\n            int max = 0;\n            Label changed = labels;\n            while (changed != null) {\n                // removes a basic block from the list of changed basic blocks\n                Label l = changed;\n                changed = changed.next;\n                l.next = null;\n                f = l.frame;\n                // a reachable jump target must be stored in the stack map\n                if ((l.status & Label.TARGET) != 0) {\n                    l.status |= Label.STORE;\n                }\n                // all visited labels are reachable, by definition\n                l.status |= Label.REACHABLE;\n                // updates the (absolute) maximum stack size\n                int blockMax = f.inputStack.length + l.outputStackMax;\n                if (blockMax > max) {\n                    max = blockMax;\n                }\n                // updates the successors of the current basic block\n                Edge e = l.successors;\n                while (e != null) {\n                    Label n = e.successor.getFirst();\n                    boolean change = f.merge(cw, n.frame, e.info);\n                    if (change && n.next == null) {\n                        // if n has changed and is not already in the 'changed'\n                        // list, adds it to this list\n                        n.next = changed;\n                        changed = n;\n                    }\n                    e = e.next;\n                }\n            }\n            // visits all the frames that must be stored in the stack map\n            Label l = labels;\n            while (l != null) {\n                f = l.frame;\n                if ((l.status & Label.STORE) != 0) {\n                    visitFrame(f);\n                }\n                if ((l.status & Label.REACHABLE) == 0) {\n                    // finds start and end of dead basic block\n                    Label k = l.successor;\n                    int start = l.position;\n                    int end = (k == null ? code.length : k.position) - 1;\n                    // if non empty basic block\n                    if (end >= start) {\n                        max = Math.max(max, 1);\n                        // replaces instructions with NOP ... NOP ATHROW\n                        for (int i = start; i < end; ++i) {\n                            code.data[i] = Opcodes.NOP;\n                        }\n                        code.data[end] = (byte) Opcodes.ATHROW;\n                        // emits a frame for this unreachable block\n                        startFrame(start, 0, 1);\n                        frame[frameIndex++] = Frame.OBJECT | cw.addType(\"java/lang/Throwable\");\n                        endFrame();\n                    }\n                }\n                l = l.successor;\n            }\n            this.maxStack = max;\n        } else if (compute == MAXS) {\n            // completes the control flow graph with exception handler blocks\n            Handler handler = firstHandler;\n            while (handler != null) {\n                Label l = handler.start;\n                Label h = handler.handler;\n                Label e = handler.end;\n                // adds 'h' as a successor of labels between 'start' and 'end'\n                while (l != e) {\n                    // creates an edge to 'h'\n                    Edge b = new Edge();\n                    b.info = Edge.EXCEPTION;\n                    b.successor = h;\n                    // adds it to the successors of 'l'\n                    if ((l.status & Label.JSR) == 0) {\n                        b.next = l.successors;\n                        l.successors = b;\n                    } else {\n                        // if l is a JSR block, adds b after the first two edges\n                        // to preserve the hypothesis about JSR block successors\n                        // order (see {@link #visitJumpInsn})\n                        b.next = l.successors.next.next;\n                        l.successors.next.next = b;\n                    }\n                    // goes to the next label\n                    l = l.successor;\n                }\n                handler = handler.next;\n            }\n            if (subroutines > 0) {\n                // completes the control flow graph with the RET successors\n                /*\n                 * first step: finds the subroutines. This step determines, for\n                 * each basic block, to which subroutine(s) it belongs.\n                 */\n                // finds the basic blocks that belong to the \"main\" subroutine\n                int id = 0;\n                labels.visitSubroutine(null, 1, subroutines);\n                // finds the basic blocks that belong to the real subroutines\n                Label l = labels;\n                while (l != null) {\n                    if ((l.status & Label.JSR) != 0) {\n                        // the subroutine is defined by l's TARGET, not by l\n                        Label subroutine = l.successors.next.successor;\n                        // if this subroutine has not been visited yet...\n                        if ((subroutine.status & Label.VISITED) == 0) {\n                            // ...assigns it a new id and finds its basic blocks\n                            id += 1;\n                            subroutine.visitSubroutine(null, (id / 32L) << 32 | (1L << (id % 32)), subroutines);\n                        }\n                    }\n                    l = l.successor;\n                }\n                // second step: finds the successors of RET blocks\n                l = labels;\n                while (l != null) {\n                    if ((l.status & Label.JSR) != 0) {\n                        Label L = labels;\n                        while (L != null) {\n                            L.status &= ~Label.VISITED2;\n                            L = L.successor;\n                        }\n                        // the subroutine is defined by l's TARGET, not by l\n                        Label subroutine = l.successors.next.successor;\n                        subroutine.visitSubroutine(l, 0, subroutines);\n                    }\n                    l = l.successor;\n                }\n            }\n            /*\n             * control flow analysis algorithm: while the block stack is not\n             * empty, pop a block from this stack, update the max stack size,\n             * compute the true (non relative) begin stack size of the\n             * successors of this block, and push these successors onto the\n             * stack (unless they have already been pushed onto the stack).\n             * Note: by hypothesis, the {@link Label#inputStackTop} of the\n             * blocks in the block stack are the true (non relative) beginning\n             * stack sizes of these blocks.\n             */\n            int max = 0;\n            Label stack = labels;\n            while (stack != null) {\n                // pops a block from the stack\n                Label l = stack;\n                stack = stack.next;\n                // computes the true (non relative) max stack size of this block\n                int start = l.inputStackTop;\n                int blockMax = start + l.outputStackMax;\n                // updates the global max stack size\n                if (blockMax > max) {\n                    max = blockMax;\n                }\n                // analyzes the successors of the block\n                Edge b = l.successors;\n                if ((l.status & Label.JSR) != 0) {\n                    // ignores the first edge of JSR blocks (virtual successor)\n                    b = b.next;\n                }\n                while (b != null) {\n                    l = b.successor;\n                    // if this successor has not already been pushed...\n                    if ((l.status & Label.PUSHED) == 0) {\n                        // computes its true beginning stack size...\n                        l.inputStackTop = b.info == Edge.EXCEPTION ? 1 : start + b.info;\n                        // ...and pushes it onto the stack\n                        l.status |= Label.PUSHED;\n                        l.next = stack;\n                        stack = l;\n                    }\n                    b = b.next;\n                }\n            }\n            this.maxStack = max;\n        } else {\n            this.maxStack = maxStack;\n            this.maxLocals = maxLocals;\n        }\n    }\n\n    public void visitEnd() {\n    }\n\n    // ------------------------------------------------------------------------\n    // Utility methods: control flow analysis algorithm\n    // ------------------------------------------------------------------------\n    /**\n     * Adds a successor to the {@link #currentBlock currentBlock} block.\n     *\n     * @param info information about the control flow edge to be added.\n     * @param successor the successor block to be added to the current block.\n     */\n    private void addSuccessor(final int info, final Label successor) {\n        // creates and initializes an Edge object...\n        Edge b = new Edge();\n        b.info = info;\n        b.successor = successor;\n        // ...and adds it to the successor list of the currentBlock block\n        b.next = currentBlock.successors;\n        currentBlock.successors = b;\n    }\n\n    /**\n     * Ends the current basic block. This method must be used in the case where\n     * the current basic block does not have any successor.\n     */\n    private void noSuccessor() {\n        if (compute == FRAMES) {\n            Label l = new Label();\n            l.frame = new Frame();\n            l.frame.owner = l;\n            l.resolve(this, code.length, code.data);\n            previousBlock.successor = l;\n            previousBlock = l;\n        } else {\n            currentBlock.outputStackMax = maxStackSize;\n        }\n        currentBlock = null;\n    }\n\n    // ------------------------------------------------------------------------\n    // Utility methods: stack map frames\n    // ------------------------------------------------------------------------\n    /**\n     * Visits a frame that has been computed from scratch.\n     *\n     * @param f the frame that must be visited.\n     */\n    private void visitFrame(final Frame f) {\n        int i, t;\n        int nTop = 0;\n        int nLocal = 0;\n        int nStack = 0;\n        int[] locals = f.inputLocals;\n        int[] stacks = f.inputStack;\n        // computes the number of locals (ignores TOP types that are just after\n        // a LONG or a DOUBLE, and all trailing TOP types)\n        for (i = 0; i < locals.length; ++i) {\n            t = locals[i];\n            if (t == Frame.TOP) {\n                ++nTop;\n            } else {\n                nLocal += nTop + 1;\n                nTop = 0;\n            }\n            if (t == Frame.LONG || t == Frame.DOUBLE) {\n                ++i;\n            }\n        }\n        // computes the stack size (ignores TOP types that are just after\n        // a LONG or a DOUBLE)\n        for (i = 0; i < stacks.length; ++i) {\n            t = stacks[i];\n            ++nStack;\n            if (t == Frame.LONG || t == Frame.DOUBLE) {\n                ++i;\n            }\n        }\n        // visits the frame and its content\n        startFrame(f.owner.position, nLocal, nStack);\n        for (i = 0; nLocal > 0; ++i, --nLocal) {\n            t = locals[i];\n            frame[frameIndex++] = t;\n            if (t == Frame.LONG || t == Frame.DOUBLE) {\n                ++i;\n            }\n        }\n        for (i = 0; i < stacks.length; ++i) {\n            t = stacks[i];\n            frame[frameIndex++] = t;\n            if (t == Frame.LONG || t == Frame.DOUBLE) {\n                ++i;\n            }\n        }\n        endFrame();\n    }\n\n    /**\n     * Starts the visit of a stack map frame.\n     *\n     * @param offset the offset of the instruction to which the frame\n     *        corresponds.\n     * @param nLocal the number of local variables in the frame.\n     * @param nStack the number of stack elements in the frame.\n     */\n    private void startFrame(final int offset, final int nLocal, final int nStack) {\n        int n = 3 + nLocal + nStack;\n        if (frame == null || frame.length < n) {\n            frame = new int[n];\n        }\n        frame[0] = offset;\n        frame[1] = nLocal;\n        frame[2] = nStack;\n        frameIndex = 3;\n    }\n\n    /**\n     * Checks if the visit of the current frame {@link #frame} is finished, and\n     * if yes, write it in the StackMapTable attribute.\n     */\n    private void endFrame() {\n        if (previousFrame != null) {\n            // do not write the first frame\n            if (stackMap == null) {\n                stackMap = new ByteVector();\n            }\n            writeFrame();\n            ++frameCount;\n        }\n        previousFrame = frame;\n        frame = null;\n    }\n\n    /**\n     * Compress and writes the current frame {@link #frame} in the StackMapTable\n     * attribute.\n     */\n    private void writeFrame() {\n        int clocalsSize = frame[1];\n        int cstackSize = frame[2];\n        if ((cw.version & 0xFFFF) < Opcodes.V1_6) {\n            stackMap.putShort(frame[0]).putShort(clocalsSize);\n            writeFrameTypes(3, 3 + clocalsSize);\n            stackMap.putShort(cstackSize);\n            writeFrameTypes(3 + clocalsSize, 3 + clocalsSize + cstackSize);\n            return;\n        }\n        int localsSize = previousFrame[1];\n        int type = FULL_FRAME;\n        int k = 0;\n        int delta;\n        if (frameCount == 0) {\n            delta = frame[0];\n        } else {\n            delta = frame[0] - previousFrame[0] - 1;\n        }\n        if (cstackSize == 0) {\n            k = clocalsSize - localsSize;\n            switch(k) {\n                case -3:\n                case -2:\n                case -1:\n                    type = CHOP_FRAME;\n                    localsSize = clocalsSize;\n                    break;\n                case 0:\n                    type = delta < 64 ? SAME_FRAME : SAME_FRAME_EXTENDED;\n                    break;\n                case 1:\n                case 2:\n                case 3:\n                    type = APPEND_FRAME;\n                    break;\n            }\n        } else if (clocalsSize == localsSize && cstackSize == 1) {\n            type = delta < 63 ? SAME_LOCALS_1_STACK_ITEM_FRAME : SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED;\n        }\n        if (type != FULL_FRAME) {\n            // verify if locals are the same\n            int l = 3;\n            for (int j = 0; j < localsSize; j++) {\n                if (frame[l] != previousFrame[l]) {\n                    type = FULL_FRAME;\n                    break;\n                }\n                l++;\n            }\n        }\n        switch(type) {\n            case SAME_FRAME:\n                stackMap.putByte(delta);\n                break;\n            case SAME_LOCALS_1_STACK_ITEM_FRAME:\n                stackMap.putByte(SAME_LOCALS_1_STACK_ITEM_FRAME + delta);\n                writeFrameTypes(3 + clocalsSize, 4 + clocalsSize);\n                break;\n            case SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED:\n                stackMap.putByte(SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED).putShort(delta);\n                writeFrameTypes(3 + clocalsSize, 4 + clocalsSize);\n                break;\n            case SAME_FRAME_EXTENDED:\n                stackMap.putByte(SAME_FRAME_EXTENDED).putShort(delta);\n                break;\n            case CHOP_FRAME:\n                stackMap.putByte(SAME_FRAME_EXTENDED + k).putShort(delta);\n                break;\n            case APPEND_FRAME:\n                stackMap.putByte(SAME_FRAME_EXTENDED + k).putShort(delta);\n                writeFrameTypes(3 + localsSize, 3 + clocalsSize);\n                break;\n            // case FULL_FRAME:\n            default:\n                stackMap.putByte(FULL_FRAME).putShort(delta).putShort(clocalsSize);\n                writeFrameTypes(3, 3 + clocalsSize);\n                stackMap.putShort(cstackSize);\n                writeFrameTypes(3 + clocalsSize, 3 + clocalsSize + cstackSize);\n        }\n    }\n\n    /**\n     * Writes some types of the current frame {@link #frame} into the\n     * StackMapTableAttribute. This method converts types from the format used\n     * in {@link Label} to the format used in StackMapTable attributes. In\n     * particular, it converts type table indexes to constant pool indexes.\n     *\n     * @param start index of the first type in {@link #frame} to write.\n     * @param end index of last type in {@link #frame} to write (exclusive).\n     */\n    private void writeFrameTypes(final int start, final int end) {\n        for (int i = start; i < end; ++i) {\n            int t = frame[i];\n            int d = t & Frame.DIM;\n            if (d == 0) {\n                int v = t & Frame.BASE_VALUE;\n                switch(t & Frame.BASE_KIND) {\n                    case Frame.OBJECT:\n                        stackMap.putByte(7).putShort(cw.newClass(cw.typeTable[v].strVal1));\n                        break;\n                    case Frame.UNINITIALIZED:\n                        stackMap.putByte(8).putShort(cw.typeTable[v].intVal);\n                        break;\n                    default:\n                        stackMap.putByte(v);\n                }\n            } else {\n                StringBuffer buf = new StringBuffer();\n                d >>= 28;\n                while (d-- > 0) {\n                    buf.append('[');\n                }\n                if ((t & Frame.BASE_KIND) == Frame.OBJECT) {\n                    buf.append('L');\n                    buf.append(cw.typeTable[t & Frame.BASE_VALUE].strVal1);\n                    buf.append(';');\n                } else {\n                    switch(t & 0xF) {\n                        case 1:\n                            buf.append('I');\n                            break;\n                        case 2:\n                            buf.append('F');\n                            break;\n                        case 3:\n                            buf.append('D');\n                            break;\n                        case 9:\n                            buf.append('Z');\n                            break;\n                        case 10:\n                            buf.append('B');\n                            break;\n                        case 11:\n                            buf.append('C');\n                            break;\n                        case 12:\n                            buf.append('S');\n                            break;\n                        default:\n                            buf.append('J');\n                    }\n                }\n                stackMap.putByte(7).putShort(cw.newClass(buf.toString()));\n            }\n        }\n    }\n\n    private void writeFrameType(final Object type) {\n        if (type instanceof String) {\n            stackMap.putByte(7).putShort(cw.newClass((String) type));\n        } else if (type instanceof Integer) {\n            stackMap.putByte(((Integer) type).intValue());\n        } else {\n            stackMap.putByte(8).putShort(((Label) type).position);\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Utility methods: dump bytecode array\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the size of the bytecode of this method.\n     *\n     * @return the size of the bytecode of this method.\n     */\n    final int getSize() {\n        if (classReaderOffset != 0) {\n            return 6 + classReaderLength;\n        }\n        if (resize) {\n            // replaces the temporary jump opcodes introduced by Label.resolve.\n            if (ClassReader.RESIZE) {\n                resizeInstructions();\n            } else {\n                throw new RuntimeException(\"Method code too large!\");\n            }\n        }\n        int size = 8;\n        if (code.length > 0) {\n            cw.newUTF8(\"Code\");\n            size += 18 + code.length + 8 * handlerCount;\n            if (localVar != null) {\n                cw.newUTF8(\"LocalVariableTable\");\n                size += 8 + localVar.length;\n            }\n            if (localVarType != null) {\n                cw.newUTF8(\"LocalVariableTypeTable\");\n                size += 8 + localVarType.length;\n            }\n            if (lineNumber != null) {\n                cw.newUTF8(\"LineNumberTable\");\n                size += 8 + lineNumber.length;\n            }\n            if (stackMap != null) {\n                boolean zip = (cw.version & 0xFFFF) >= Opcodes.V1_6;\n                cw.newUTF8(zip ? \"StackMapTable\" : \"StackMap\");\n                size += 8 + stackMap.length;\n            }\n            if (cattrs != null) {\n                size += cattrs.getSize(cw, code.data, code.length, maxStack, maxLocals);\n            }\n        }\n        if (exceptionCount > 0) {\n            cw.newUTF8(\"Exceptions\");\n            size += 8 + 2 * exceptionCount;\n        }\n        if ((access & Opcodes.ACC_SYNTHETIC) != 0 && (cw.version & 0xffff) < Opcodes.V1_5) {\n            cw.newUTF8(\"Synthetic\");\n            size += 6;\n        }\n        if ((access & Opcodes.ACC_DEPRECATED) != 0) {\n            cw.newUTF8(\"Deprecated\");\n            size += 6;\n        }\n        if (ClassReader.SIGNATURES && signature != null) {\n            cw.newUTF8(\"Signature\");\n            cw.newUTF8(signature);\n            size += 8;\n        }\n        if (ClassReader.ANNOTATIONS && annd != null) {\n            cw.newUTF8(\"AnnotationDefault\");\n            size += 6 + annd.length;\n        }\n        if (ClassReader.ANNOTATIONS && anns != null) {\n            cw.newUTF8(\"RuntimeVisibleAnnotations\");\n            size += 8 + anns.getSize();\n        }\n        if (ClassReader.ANNOTATIONS && ianns != null) {\n            cw.newUTF8(\"RuntimeInvisibleAnnotations\");\n            size += 8 + ianns.getSize();\n        }\n        if (ClassReader.ANNOTATIONS && panns != null) {\n            cw.newUTF8(\"RuntimeVisibleParameterAnnotations\");\n            size += 7 + 2 * (panns.length - synthetics);\n            for (int i = panns.length - 1; i >= synthetics; --i) {\n                size += panns[i] == null ? 0 : panns[i].getSize();\n            }\n        }\n        if (ClassReader.ANNOTATIONS && ipanns != null) {\n            cw.newUTF8(\"RuntimeInvisibleParameterAnnotations\");\n            size += 7 + 2 * (ipanns.length - synthetics);\n            for (int i = ipanns.length - 1; i >= synthetics; --i) {\n                size += ipanns[i] == null ? 0 : ipanns[i].getSize();\n            }\n        }\n        if (attrs != null) {\n            size += attrs.getSize(cw, null, 0, -1, -1);\n        }\n        return size;\n    }\n\n    /**\n     * Puts the bytecode of this method in the given byte vector.\n     *\n     * @param out the byte vector into which the bytecode of this method must be\n     *        copied.\n     */\n    final void put(final ByteVector out) {\n        out.putShort(access).putShort(name).putShort(desc);\n        if (classReaderOffset != 0) {\n            out.putByteArray(cw.cr.b, classReaderOffset, classReaderLength);\n            return;\n        }\n        int attributeCount = 0;\n        if (code.length > 0) {\n            ++attributeCount;\n        }\n        if (exceptionCount > 0) {\n            ++attributeCount;\n        }\n        if ((access & Opcodes.ACC_SYNTHETIC) != 0 && (cw.version & 0xffff) < Opcodes.V1_5) {\n            ++attributeCount;\n        }\n        if ((access & Opcodes.ACC_DEPRECATED) != 0) {\n            ++attributeCount;\n        }\n        if (ClassReader.SIGNATURES && signature != null) {\n            ++attributeCount;\n        }\n        if (ClassReader.ANNOTATIONS && annd != null) {\n            ++attributeCount;\n        }\n        if (ClassReader.ANNOTATIONS && anns != null) {\n            ++attributeCount;\n        }\n        if (ClassReader.ANNOTATIONS && ianns != null) {\n            ++attributeCount;\n        }\n        if (ClassReader.ANNOTATIONS && panns != null) {\n            ++attributeCount;\n        }\n        if (ClassReader.ANNOTATIONS && ipanns != null) {\n            ++attributeCount;\n        }\n        if (attrs != null) {\n            attributeCount += attrs.getCount();\n        }\n        out.putShort(attributeCount);\n        if (code.length > 0) {\n            int size = 12 + code.length + 8 * handlerCount;\n            if (localVar != null) {\n                size += 8 + localVar.length;\n            }\n            if (localVarType != null) {\n                size += 8 + localVarType.length;\n            }\n            if (lineNumber != null) {\n                size += 8 + lineNumber.length;\n            }\n            if (stackMap != null) {\n                size += 8 + stackMap.length;\n            }\n            if (cattrs != null) {\n                size += cattrs.getSize(cw, code.data, code.length, maxStack, maxLocals);\n            }\n            out.putShort(cw.newUTF8(\"Code\")).putInt(size);\n            out.putShort(maxStack).putShort(maxLocals);\n            out.putInt(code.length).putByteArray(code.data, 0, code.length);\n            out.putShort(handlerCount);\n            if (handlerCount > 0) {\n                Handler h = firstHandler;\n                while (h != null) {\n                    out.putShort(h.start.position).putShort(h.end.position).putShort(h.handler.position).putShort(h.type);\n                    h = h.next;\n                }\n            }\n            attributeCount = 0;\n            if (localVar != null) {\n                ++attributeCount;\n            }\n            if (localVarType != null) {\n                ++attributeCount;\n            }\n            if (lineNumber != null) {\n                ++attributeCount;\n            }\n            if (stackMap != null) {\n                ++attributeCount;\n            }\n            if (cattrs != null) {\n                attributeCount += cattrs.getCount();\n            }\n            out.putShort(attributeCount);\n            if (localVar != null) {\n                out.putShort(cw.newUTF8(\"LocalVariableTable\"));\n                out.putInt(localVar.length + 2).putShort(localVarCount);\n                out.putByteArray(localVar.data, 0, localVar.length);\n            }\n            if (localVarType != null) {\n                out.putShort(cw.newUTF8(\"LocalVariableTypeTable\"));\n                out.putInt(localVarType.length + 2).putShort(localVarTypeCount);\n                out.putByteArray(localVarType.data, 0, localVarType.length);\n            }\n            if (lineNumber != null) {\n                out.putShort(cw.newUTF8(\"LineNumberTable\"));\n                out.putInt(lineNumber.length + 2).putShort(lineNumberCount);\n                out.putByteArray(lineNumber.data, 0, lineNumber.length);\n            }\n            if (stackMap != null) {\n                boolean zip = (cw.version & 0xFFFF) >= Opcodes.V1_6;\n                out.putShort(cw.newUTF8(zip ? \"StackMapTable\" : \"StackMap\"));\n                out.putInt(stackMap.length + 2).putShort(frameCount);\n                out.putByteArray(stackMap.data, 0, stackMap.length);\n            }\n            if (cattrs != null) {\n                cattrs.put(cw, code.data, code.length, maxLocals, maxStack, out);\n            }\n        }\n        if (exceptionCount > 0) {\n            out.putShort(cw.newUTF8(\"Exceptions\")).putInt(2 * exceptionCount + 2);\n            out.putShort(exceptionCount);\n            for (int i = 0; i < exceptionCount; ++i) {\n                out.putShort(exceptions[i]);\n            }\n        }\n        if ((access & Opcodes.ACC_SYNTHETIC) != 0 && (cw.version & 0xffff) < Opcodes.V1_5) {\n            out.putShort(cw.newUTF8(\"Synthetic\")).putInt(0);\n        }\n        if ((access & Opcodes.ACC_DEPRECATED) != 0) {\n            out.putShort(cw.newUTF8(\"Deprecated\")).putInt(0);\n        }\n        if (ClassReader.SIGNATURES && signature != null) {\n            out.putShort(cw.newUTF8(\"Signature\")).putInt(2).putShort(cw.newUTF8(signature));\n        }\n        if (ClassReader.ANNOTATIONS && annd != null) {\n            out.putShort(cw.newUTF8(\"AnnotationDefault\"));\n            out.putInt(annd.length);\n            out.putByteArray(annd.data, 0, annd.length);\n        }\n        if (ClassReader.ANNOTATIONS && anns != null) {\n            out.putShort(cw.newUTF8(\"RuntimeVisibleAnnotations\"));\n            anns.put(out);\n        }\n        if (ClassReader.ANNOTATIONS && ianns != null) {\n            out.putShort(cw.newUTF8(\"RuntimeInvisibleAnnotations\"));\n            ianns.put(out);\n        }\n        if (ClassReader.ANNOTATIONS && panns != null) {\n            out.putShort(cw.newUTF8(\"RuntimeVisibleParameterAnnotations\"));\n            AnnotationWriter.put(panns, synthetics, out);\n        }\n        if (ClassReader.ANNOTATIONS && ipanns != null) {\n            out.putShort(cw.newUTF8(\"RuntimeInvisibleParameterAnnotations\"));\n            AnnotationWriter.put(ipanns, synthetics, out);\n        }\n        if (attrs != null) {\n            attrs.put(cw, null, 0, -1, -1, out);\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Utility methods: instruction resizing (used to handle GOTO_W and JSR_W)\n    // ------------------------------------------------------------------------\n    /**\n     * Resizes and replaces the temporary instructions inserted by\n     * {@link Label#resolve} for wide forward jumps, while keeping jump offsets\n     * and instruction addresses consistent. This may require to resize other\n     * existing instructions, or even to introduce new instructions: for\n     * example, increasing the size of an instruction by 2 at the middle of a\n     * method can increases the offset of an IFEQ instruction from 32766 to\n     * 32768, in which case IFEQ 32766 must be replaced with IFNEQ 8 GOTO_W\n     * 32765. This, in turn, may require to increase the size of another jump\n     * instruction, and so on... All these operations are handled automatically\n     * by this method. <p> <i>This method must be called after all the method\n     * that is being built has been visited</i>. In particular, the\n     * {@link Label Label} objects used to construct the method are no longer\n     * valid after this method has been called.\n     */\n    private void resizeInstructions() {\n        // bytecode of the method\n        byte[] b = code.data;\n        // indexes in b\n        int u, v, label;\n        // loop indexes\n        int i, j;\n        /*\n         * 1st step: As explained above, resizing an instruction may require to\n         * resize another one, which may require to resize yet another one, and\n         * so on. The first step of the algorithm consists in finding all the\n         * instructions that need to be resized, without modifying the code.\n         * This is done by the following \"fix point\" algorithm:\n         * \n         * Parse the code to find the jump instructions whose offset will need\n         * more than 2 bytes to be stored (the future offset is computed from\n         * the current offset and from the number of bytes that will be inserted\n         * or removed between the source and target instructions). For each such\n         * instruction, adds an entry in (a copy of) the indexes and sizes\n         * arrays (if this has not already been done in a previous iteration!).\n         * \n         * If at least one entry has been added during the previous step, go\n         * back to the beginning, otherwise stop.\n         * \n         * In fact the real algorithm is complicated by the fact that the size\n         * of TABLESWITCH and LOOKUPSWITCH instructions depends on their\n         * position in the bytecode (because of padding). In order to ensure the\n         * convergence of the algorithm, the number of bytes to be added or\n         * removed from these instructions is over estimated during the previous\n         * loop, and computed exactly only after the loop is finished (this\n         * requires another pass to parse the bytecode of the method).\n         */\n        // copy of indexes\n        int[] allIndexes = new int[0];\n        // copy of sizes\n        int[] allSizes = new int[0];\n        // instructions to be resized\n        boolean[] resize;\n        // future offset of a jump instruction\n        int newOffset;\n        resize = new boolean[code.length];\n        // 3 = loop again, 2 = loop ended, 1 = last pass, 0 = done\n        int state = 3;\n        do {\n            if (state == 3) {\n                state = 2;\n            }\n            u = 0;\n            while (u < b.length) {\n                // opcode of current instruction\n                int opcode = b[u] & 0xFF;\n                // bytes to be added after this instruction\n                int insert = 0;\n                switch(ClassWriter.TYPE[opcode]) {\n                    case ClassWriter.NOARG_INSN:\n                    case ClassWriter.IMPLVAR_INSN:\n                        u += 1;\n                        break;\n                    case ClassWriter.LABEL_INSN:\n                        if (opcode > 201) {\n                            // converts temporary opcodes 202 to 217, 218 and\n                            // 219 to IFEQ ... JSR (inclusive), IFNULL and\n                            // IFNONNULL\n                            opcode = opcode < 218 ? opcode - 49 : opcode - 20;\n                            label = u + readUnsignedShort(b, u + 1);\n                        } else {\n                            label = u + readShort(b, u + 1);\n                        }\n                        newOffset = getNewOffset(allIndexes, allSizes, u, label);\n                        if (newOffset < Short.MIN_VALUE || newOffset > Short.MAX_VALUE) {\n                            if (!resize[u]) {\n                                if (opcode == Opcodes.GOTO || opcode == Opcodes.JSR) {\n                                    // two additional bytes will be required to\n                                    // replace this GOTO or JSR instruction with\n                                    // a GOTO_W or a JSR_W\n                                    insert = 2;\n                                } else {\n                                    // five additional bytes will be required to\n                                    // replace this IFxxx <l> instruction with\n                                    // IFNOTxxx <l'> GOTO_W <l>, where IFNOTxxx\n                                    // is the \"opposite\" opcode of IFxxx (i.e.,\n                                    // IFNE for IFEQ) and where <l'> designates\n                                    // the instruction just after the GOTO_W.\n                                    insert = 5;\n                                }\n                                resize[u] = true;\n                            }\n                        }\n                        u += 3;\n                        break;\n                    case ClassWriter.LABELW_INSN:\n                        u += 5;\n                        break;\n                    case ClassWriter.TABL_INSN:\n                        if (state == 1) {\n                            // true number of bytes to be added (or removed)\n                            // from this instruction = (future number of padding\n                            // bytes - current number of padding byte) -\n                            // previously over estimated variation =\n                            // = ((3 - newOffset%4) - (3 - u%4)) - u%4\n                            // = (-newOffset%4 + u%4) - u%4\n                            // = -(newOffset & 3)\n                            newOffset = getNewOffset(allIndexes, allSizes, 0, u);\n                            insert = -(newOffset & 3);\n                        } else if (!resize[u]) {\n                            // over estimation of the number of bytes to be\n                            // added to this instruction = 3 - current number\n                            // of padding bytes = 3 - (3 - u%4) = u%4 = u & 3\n                            insert = u & 3;\n                            resize[u] = true;\n                        }\n                        // skips instruction\n                        u = u + 4 - (u & 3);\n                        u += 4 * (readInt(b, u + 8) - readInt(b, u + 4) + 1) + 12;\n                        break;\n                    case ClassWriter.LOOK_INSN:\n                        if (state == 1) {\n                            // like TABL_INSN\n                            newOffset = getNewOffset(allIndexes, allSizes, 0, u);\n                            insert = -(newOffset & 3);\n                        } else if (!resize[u]) {\n                            // like TABL_INSN\n                            insert = u & 3;\n                            resize[u] = true;\n                        }\n                        // skips instruction\n                        u = u + 4 - (u & 3);\n                        u += 8 * readInt(b, u + 4) + 8;\n                        break;\n                    case ClassWriter.WIDE_INSN:\n                        opcode = b[u + 1] & 0xFF;\n                        if (opcode == Opcodes.IINC) {\n                            u += 6;\n                        } else {\n                            u += 4;\n                        }\n                        break;\n                    case ClassWriter.VAR_INSN:\n                    case ClassWriter.SBYTE_INSN:\n                    case ClassWriter.LDC_INSN:\n                        u += 2;\n                        break;\n                    case ClassWriter.SHORT_INSN:\n                    case ClassWriter.LDCW_INSN:\n                    case ClassWriter.FIELDORMETH_INSN:\n                    case ClassWriter.TYPE_INSN:\n                    case ClassWriter.IINC_INSN:\n                        u += 3;\n                        break;\n                    case ClassWriter.ITFDYNMETH_INSN:\n                        u += 5;\n                        break;\n                    // case ClassWriter.MANA_INSN:\n                    default:\n                        u += 4;\n                        break;\n                }\n                if (insert != 0) {\n                    // adds a new (u, insert) entry in the allIndexes and\n                    // allSizes arrays\n                    int[] newIndexes = new int[allIndexes.length + 1];\n                    int[] newSizes = new int[allSizes.length + 1];\n                    System.arraycopy(allIndexes, 0, newIndexes, 0, allIndexes.length);\n                    System.arraycopy(allSizes, 0, newSizes, 0, allSizes.length);\n                    newIndexes[allIndexes.length] = u;\n                    newSizes[allSizes.length] = insert;\n                    allIndexes = newIndexes;\n                    allSizes = newSizes;\n                    if (insert > 0) {\n                        state = 3;\n                    }\n                }\n            }\n            if (state < 3) {\n                --state;\n            }\n        } while (state != 0);\n        // 2nd step:\n        // copies the bytecode of the method into a new bytevector, updates the\n        // offsets, and inserts (or removes) bytes as requested.\n        ByteVector newCode = new ByteVector(code.length);\n        u = 0;\n        while (u < code.length) {\n            int opcode = b[u] & 0xFF;\n            switch(ClassWriter.TYPE[opcode]) {\n                case ClassWriter.NOARG_INSN:\n                case ClassWriter.IMPLVAR_INSN:\n                    newCode.putByte(opcode);\n                    u += 1;\n                    break;\n                case ClassWriter.LABEL_INSN:\n                    if (opcode > 201) {\n                        // changes temporary opcodes 202 to 217 (inclusive), 218\n                        // and 219 to IFEQ ... JSR (inclusive), IFNULL and\n                        // IFNONNULL\n                        opcode = opcode < 218 ? opcode - 49 : opcode - 20;\n                        label = u + readUnsignedShort(b, u + 1);\n                    } else {\n                        label = u + readShort(b, u + 1);\n                    }\n                    newOffset = getNewOffset(allIndexes, allSizes, u, label);\n                    if (resize[u]) {\n                        // replaces GOTO with GOTO_W, JSR with JSR_W and IFxxx\n                        // <l> with IFNOTxxx <l'> GOTO_W <l>, where IFNOTxxx is\n                        // the \"opposite\" opcode of IFxxx (i.e., IFNE for IFEQ)\n                        // and where <l'> designates the instruction just after\n                        // the GOTO_W.\n                        if (opcode == Opcodes.GOTO) {\n                            // GOTO_W\n                            newCode.putByte(200);\n                        } else if (opcode == Opcodes.JSR) {\n                            // JSR_W\n                            newCode.putByte(201);\n                        } else {\n                            newCode.putByte(opcode <= 166 ? ((opcode + 1) ^ 1) - 1 : opcode ^ 1);\n                            // jump offset\n                            newCode.putShort(8);\n                            // GOTO_W\n                            newCode.putByte(200);\n                            // newOffset now computed from start of GOTO_W\n                            newOffset -= 3;\n                        }\n                        newCode.putInt(newOffset);\n                    } else {\n                        newCode.putByte(opcode);\n                        newCode.putShort(newOffset);\n                    }\n                    u += 3;\n                    break;\n                case ClassWriter.LABELW_INSN:\n                    label = u + readInt(b, u + 1);\n                    newOffset = getNewOffset(allIndexes, allSizes, u, label);\n                    newCode.putByte(opcode);\n                    newCode.putInt(newOffset);\n                    u += 5;\n                    break;\n                case ClassWriter.TABL_INSN:\n                    // skips 0 to 3 padding bytes\n                    v = u;\n                    u = u + 4 - (v & 3);\n                    // reads and copies instruction\n                    newCode.putByte(Opcodes.TABLESWITCH);\n                    newCode.putByteArray(null, 0, (4 - newCode.length % 4) % 4);\n                    label = v + readInt(b, u);\n                    u += 4;\n                    newOffset = getNewOffset(allIndexes, allSizes, v, label);\n                    newCode.putInt(newOffset);\n                    j = readInt(b, u);\n                    u += 4;\n                    newCode.putInt(j);\n                    j = readInt(b, u) - j + 1;\n                    u += 4;\n                    newCode.putInt(readInt(b, u - 4));\n                    for (; j > 0; --j) {\n                        label = v + readInt(b, u);\n                        u += 4;\n                        newOffset = getNewOffset(allIndexes, allSizes, v, label);\n                        newCode.putInt(newOffset);\n                    }\n                    break;\n                case ClassWriter.LOOK_INSN:\n                    // skips 0 to 3 padding bytes\n                    v = u;\n                    u = u + 4 - (v & 3);\n                    // reads and copies instruction\n                    newCode.putByte(Opcodes.LOOKUPSWITCH);\n                    newCode.putByteArray(null, 0, (4 - newCode.length % 4) % 4);\n                    label = v + readInt(b, u);\n                    u += 4;\n                    newOffset = getNewOffset(allIndexes, allSizes, v, label);\n                    newCode.putInt(newOffset);\n                    j = readInt(b, u);\n                    u += 4;\n                    newCode.putInt(j);\n                    for (; j > 0; --j) {\n                        newCode.putInt(readInt(b, u));\n                        u += 4;\n                        label = v + readInt(b, u);\n                        u += 4;\n                        newOffset = getNewOffset(allIndexes, allSizes, v, label);\n                        newCode.putInt(newOffset);\n                    }\n                    break;\n                case ClassWriter.WIDE_INSN:\n                    opcode = b[u + 1] & 0xFF;\n                    if (opcode == Opcodes.IINC) {\n                        newCode.putByteArray(b, u, 6);\n                        u += 6;\n                    } else {\n                        newCode.putByteArray(b, u, 4);\n                        u += 4;\n                    }\n                    break;\n                case ClassWriter.VAR_INSN:\n                case ClassWriter.SBYTE_INSN:\n                case ClassWriter.LDC_INSN:\n                    newCode.putByteArray(b, u, 2);\n                    u += 2;\n                    break;\n                case ClassWriter.SHORT_INSN:\n                case ClassWriter.LDCW_INSN:\n                case ClassWriter.FIELDORMETH_INSN:\n                case ClassWriter.TYPE_INSN:\n                case ClassWriter.IINC_INSN:\n                    newCode.putByteArray(b, u, 3);\n                    u += 3;\n                    break;\n                case ClassWriter.ITFDYNMETH_INSN:\n                    newCode.putByteArray(b, u, 5);\n                    u += 5;\n                    break;\n                // case MANA_INSN:\n                default:\n                    newCode.putByteArray(b, u, 4);\n                    u += 4;\n                    break;\n            }\n        }\n        // recomputes the stack map frames\n        if (frameCount > 0) {\n            if (compute == FRAMES) {\n                frameCount = 0;\n                stackMap = null;\n                previousFrame = null;\n                frame = null;\n                Frame f = new Frame();\n                f.owner = labels;\n                Type[] args = Type.getArgumentTypes(descriptor);\n                f.initInputFrame(cw, access, args, maxLocals);\n                visitFrame(f);\n                Label l = labels;\n                while (l != null) {\n                    /*\n                     * here we need the original label position. getNewOffset\n                     * must therefore never have been called for this label.\n                     */\n                    u = l.position - 3;\n                    if ((l.status & Label.STORE) != 0 || (u >= 0 && resize[u])) {\n                        getNewOffset(allIndexes, allSizes, l);\n                        // TODO update offsets in UNINITIALIZED values\n                        visitFrame(l.frame);\n                    }\n                    l = l.successor;\n                }\n            } else {\n                /*\n                 * Resizing an existing stack map frame table is really hard.\n                 * Not only the table must be parsed to update the offets, but\n                 * new frames may be needed for jump instructions that were\n                 * inserted by this method. And updating the offsets or\n                 * inserting frames can change the format of the following\n                 * frames, in case of packed frames. In practice the whole table\n                 * must be recomputed. For this the frames are marked as\n                 * potentially invalid. This will cause the whole class to be\n                 * reread and rewritten with the COMPUTE_FRAMES option (see the\n                 * ClassWriter.toByteArray method). This is not very efficient\n                 * but is much easier and requires much less code than any other\n                 * method I can think of.\n                 */\n                cw.invalidFrames = true;\n            }\n        }\n        // updates the exception handler block labels\n        Handler h = firstHandler;\n        while (h != null) {\n            getNewOffset(allIndexes, allSizes, h.start);\n            getNewOffset(allIndexes, allSizes, h.end);\n            getNewOffset(allIndexes, allSizes, h.handler);\n            h = h.next;\n        }\n        // updates the instructions addresses in the\n        // local var and line number tables\n        for (i = 0; i < 2; ++i) {\n            ByteVector bv = i == 0 ? localVar : localVarType;\n            if (bv != null) {\n                b = bv.data;\n                u = 0;\n                while (u < bv.length) {\n                    label = readUnsignedShort(b, u);\n                    newOffset = getNewOffset(allIndexes, allSizes, 0, label);\n                    writeShort(b, u, newOffset);\n                    label += readUnsignedShort(b, u + 2);\n                    newOffset = getNewOffset(allIndexes, allSizes, 0, label) - newOffset;\n                    writeShort(b, u + 2, newOffset);\n                    u += 10;\n                }\n            }\n        }\n        if (lineNumber != null) {\n            b = lineNumber.data;\n            u = 0;\n            while (u < lineNumber.length) {\n                writeShort(b, u, getNewOffset(allIndexes, allSizes, 0, readUnsignedShort(b, u)));\n                u += 4;\n            }\n        }\n        // updates the labels of the other attributes\n        Attribute attr = cattrs;\n        while (attr != null) {\n            Label[] labels = attr.getLabels();\n            if (labels != null) {\n                for (i = labels.length - 1; i >= 0; --i) {\n                    getNewOffset(allIndexes, allSizes, labels[i]);\n                }\n            }\n            attr = attr.next;\n        }\n        // replaces old bytecodes with new ones\n        code = newCode;\n    }\n\n    /**\n     * Reads an unsigned short value in the given byte array.\n     *\n     * @param b a byte array.\n     * @param index the start index of the value to be read.\n     * @return the read value.\n     */\n    static int readUnsignedShort(final byte[] b, final int index) {\n        return ((b[index] & 0xFF) << 8) | (b[index + 1] & 0xFF);\n    }\n\n    /**\n     * Reads a signed short value in the given byte array.\n     *\n     * @param b a byte array.\n     * @param index the start index of the value to be read.\n     * @return the read value.\n     */\n    static short readShort(final byte[] b, final int index) {\n        return (short) (((b[index] & 0xFF) << 8) | (b[index + 1] & 0xFF));\n    }\n\n    /**\n     * Reads a signed int value in the given byte array.\n     *\n     * @param b a byte array.\n     * @param index the start index of the value to be read.\n     * @return the read value.\n     */\n    static int readInt(final byte[] b, final int index) {\n        return ((b[index] & 0xFF) << 24) | ((b[index + 1] & 0xFF) << 16) | ((b[index + 2] & 0xFF) << 8) | (b[index + 3] & 0xFF);\n    }\n\n    /**\n     * Writes a short value in the given byte array.\n     *\n     * @param b a byte array.\n     * @param index where the first byte of the short value must be written.\n     * @param s the value to be written in the given byte array.\n     */\n    static void writeShort(final byte[] b, final int index, final int s) {\n        b[index] = (byte) (s >>> 8);\n        b[index + 1] = (byte) s;\n    }\n\n    /**\n     * Computes the future value of a bytecode offset. <p> Note: it is possible\n     * to have several entries for the same instruction in the <tt>indexes</tt>\n     * and <tt>sizes</tt>: two entries (index=a,size=b) and (index=a,size=b')\n     * are equivalent to a single entry (index=a,size=b+b').\n     *\n     * @param indexes current positions of the instructions to be resized. Each\n     *        instruction must be designated by the index of its <i>last</i>\n     *        byte, plus one (or, in other words, by the index of the <i>first</i>\n     *        byte of the <i>next</i> instruction).\n     * @param sizes the number of bytes to be <i>added</i> to the above\n     *        instructions. More precisely, for each i < <tt>len</tt>,\n     *        <tt>sizes</tt>[i] bytes will be added at the end of the\n     *        instruction designated by <tt>indexes</tt>[i] or, if\n     *        <tt>sizes</tt>[i] is negative, the <i>last</i> |<tt>sizes[i]</tt>|\n     *        bytes of the instruction will be removed (the instruction size\n     *        <i>must not</i> become negative or null).\n     * @param begin index of the first byte of the source instruction.\n     * @param end index of the first byte of the target instruction.\n     * @return the future value of the given bytecode offset.\n     */\n    static int getNewOffset(final int[] indexes, final int[] sizes, final int begin, final int end) {\n        int offset = end - begin;\n        for (int i = 0; i < indexes.length; ++i) {\n            if (begin < indexes[i] && indexes[i] <= end) {\n                // forward jump\n                offset += sizes[i];\n            } else if (end < indexes[i] && indexes[i] <= begin) {\n                // backward jump\n                offset -= sizes[i];\n            }\n        }\n        return offset;\n    }\n\n    /**\n     * Updates the offset of the given label.\n     *\n     * @param indexes current positions of the instructions to be resized. Each\n     *        instruction must be designated by the index of its <i>last</i>\n     *        byte, plus one (or, in other words, by the index of the <i>first</i>\n     *        byte of the <i>next</i> instruction).\n     * @param sizes the number of bytes to be <i>added</i> to the above\n     *        instructions. More precisely, for each i < <tt>len</tt>,\n     *        <tt>sizes</tt>[i] bytes will be added at the end of the\n     *        instruction designated by <tt>indexes</tt>[i] or, if\n     *        <tt>sizes</tt>[i] is negative, the <i>last</i> |<tt>sizes[i]</tt>|\n     *        bytes of the instruction will be removed (the instruction size\n     *        <i>must not</i> become negative or null).\n     * @param label the label whose offset must be updated.\n     */\n    static void getNewOffset(final int[] indexes, final int[] sizes, final Label label) {\n        if ((label.status & Label.RESIZED) == 0) {\n            label.position = getNewOffset(indexes, sizes, 0, label.position);\n            label.status |= Label.RESIZED;\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/MethodWriterTest1.java",
		"test_prompt": "// MethodWriterTest1.java\npackage org.objectweb.asm.jip;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MethodWriter}.\n* It contains ten unit test cases for the {@link MethodWriter#visitAnnotation(String, boolean)} method.\n*/\nclass MethodWriterTest1 {"
	},
	{
		"original_code": "// MethodWriter.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\n/**\n * A {@link MethodVisitor} that generates methods in bytecode form. Each visit\n * method of this class appends the bytecode corresponding to the visited\n * instruction to a byte vector, in the order these methods are called.\n *\n * @author Eric Bruneton\n * @author Eugene Kuleshov\n */\nclass MethodWriter implements MethodVisitor {\n\n    /**\n     * Pseudo access flag used to denote constructors.\n     */\n    static final int ACC_CONSTRUCTOR = 262144;\n\n    /**\n     * Frame has exactly the same locals as the previous stack map frame and\n     * number of stack items is zero.\n     */\n    // to 63 (0-3f)\n    static final int SAME_FRAME = 0;\n\n    /**\n     * Frame has exactly the same locals as the previous stack map frame and\n     * number of stack items is 1\n     */\n    // to 127 (40-7f)\n    static final int SAME_LOCALS_1_STACK_ITEM_FRAME = 64;\n\n    /**\n     * Reserved for future use\n     */\n    static final int RESERVED = 128;\n\n    /**\n     * Frame has exactly the same locals as the previous stack map frame and\n     * number of stack items is 1. Offset is bigger then 63;\n     */\n    // f7\n    static final int SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED = 247;\n\n    /**\n     * Frame where current locals are the same as the locals in the previous\n     * frame, except that the k last locals are absent. The value of k is given\n     * by the formula 251-frame_type.\n     */\n    // to 250 (f8-fA)\n    static final int CHOP_FRAME = 248;\n\n    /**\n     * Frame has exactly the same locals as the previous stack map frame and\n     * number of stack items is zero. Offset is bigger then 63;\n     */\n    // fb\n    static final int SAME_FRAME_EXTENDED = 251;\n\n    /**\n     * Frame where current locals are the same as the locals in the previous\n     * frame, except that k additional locals are defined. The value of k is\n     * given by the formula frame_type-251.\n     */\n    // to 254 // fc-fe\n    static final int APPEND_FRAME = 252;\n\n    /**\n     * Full frame\n     */\n    // ff\n    static final int FULL_FRAME = 255;\n\n    /**\n     * Indicates that the stack map frames must be recomputed from scratch. In\n     * this case the maximum stack size and number of local variables is also\n     * recomputed from scratch.\n     *\n     * @see #compute\n     */\n    private static final int FRAMES = 0;\n\n    /**\n     * Indicates that the maximum stack size and number of local variables must\n     * be automatically computed.\n     *\n     * @see #compute\n     */\n    private static final int MAXS = 1;\n\n    /**\n     * Indicates that nothing must be automatically computed.\n     *\n     * @see #compute\n     */\n    private static final int NOTHING = 2;\n\n    /**\n     * Next method writer (see {@link ClassWriter#firstMethod firstMethod}).\n     */\n    MethodWriter next;\n\n    /**\n     * The class writer to which this method must be added.\n     */\n    final ClassWriter cw;\n\n    /**\n     * Access flags of this method.\n     */\n    private int access;\n\n    /**\n     * The index of the constant pool item that contains the name of this\n     * method.\n     */\n    private final int name;\n\n    /**\n     * The index of the constant pool item that contains the descriptor of this\n     * method.\n     */\n    private final int desc;\n\n    /**\n     * The descriptor of this method.\n     */\n    private final String descriptor;\n\n    /**\n     * The signature of this method.\n     */\n    String signature;\n\n    /**\n     * If not zero, indicates that the code of this method must be copied from\n     * the ClassReader associated to this writer in <code>cw.cr</code>. More\n     * precisely, this field gives the index of the first byte to copied from\n     * <code>cw.cr.b</code>.\n     */\n    int classReaderOffset;\n\n    /**\n     * If not zero, indicates that the code of this method must be copied from\n     * the ClassReader associated to this writer in <code>cw.cr</code>. More\n     * precisely, this field gives the number of bytes to copied from\n     * <code>cw.cr.b</code>.\n     */\n    int classReaderLength;\n\n    /**\n     * Number of exceptions that can be thrown by this method.\n     */\n    int exceptionCount;\n\n    /**\n     * The exceptions that can be thrown by this method. More precisely, this\n     * array contains the indexes of the constant pool items that contain the\n     * internal names of these exception classes.\n     */\n    int[] exceptions;\n\n    /**\n     * The annotation default attribute of this method. May be <tt>null</tt>.\n     */\n    private ByteVector annd;\n\n    /**\n     * The runtime visible annotations of this method. May be <tt>null</tt>.\n     */\n    private AnnotationWriter anns;\n\n    /**\n     * The runtime invisible annotations of this method. May be <tt>null</tt>.\n     */\n    private AnnotationWriter ianns;\n\n    /**\n     * The runtime visible parameter annotations of this method. May be\n     * <tt>null</tt>.\n     */\n    private AnnotationWriter[] panns;\n\n    /**\n     * The runtime invisible parameter annotations of this method. May be\n     * <tt>null</tt>.\n     */\n    private AnnotationWriter[] ipanns;\n\n    /**\n     * The number of synthetic parameters of this method.\n     */\n    private int synthetics;\n\n    /**\n     * The non standard attributes of the method.\n     */\n    private Attribute attrs;\n\n    /**\n     * The bytecode of this method.\n     */\n    private ByteVector code = new ByteVector();\n\n    /**\n     * Maximum stack size of this method.\n     */\n    private int maxStack;\n\n    /**\n     * Maximum number of local variables for this method.\n     */\n    private int maxLocals;\n\n    /**\n     * Number of stack map frames in the StackMapTable attribute.\n     */\n    private int frameCount;\n\n    /**\n     * The StackMapTable attribute.\n     */\n    private ByteVector stackMap;\n\n    /**\n     * The offset of the last frame that was written in the StackMapTable\n     * attribute.\n     */\n    private int previousFrameOffset;\n\n    /**\n     * The last frame that was written in the StackMapTable attribute.\n     *\n     * @see #frame\n     */\n    private int[] previousFrame;\n\n    /**\n     * Index of the next element to be added in {@link #frame}.\n     */\n    private int frameIndex;\n\n    /**\n     * The current stack map frame. The first element contains the offset of the\n     * instruction to which the frame corresponds, the second element is the\n     * number of locals and the third one is the number of stack elements. The\n     * local variables start at index 3 and are followed by the operand stack\n     * values. In summary frame[0] = offset, frame[1] = nLocal, frame[2] =\n     * nStack, frame[3] = nLocal. All types are encoded as integers, with the\n     * same format as the one used in {@link Label}, but limited to BASE types.\n     */\n    private int[] frame;\n\n    /**\n     * Number of elements in the exception handler list.\n     */\n    private int handlerCount;\n\n    /**\n     * The first element in the exception handler list.\n     */\n    private Handler firstHandler;\n\n    /**\n     * The last element in the exception handler list.\n     */\n    private Handler lastHandler;\n\n    /**\n     * Number of entries in the LocalVariableTable attribute.\n     */\n    private int localVarCount;\n\n    /**\n     * The LocalVariableTable attribute.\n     */\n    private ByteVector localVar;\n\n    /**\n     * Number of entries in the LocalVariableTypeTable attribute.\n     */\n    private int localVarTypeCount;\n\n    /**\n     * The LocalVariableTypeTable attribute.\n     */\n    private ByteVector localVarType;\n\n    /**\n     * Number of entries in the LineNumberTable attribute.\n     */\n    private int lineNumberCount;\n\n    /**\n     * The LineNumberTable attribute.\n     */\n    private ByteVector lineNumber;\n\n    /**\n     * The non standard attributes of the method's code.\n     */\n    private Attribute cattrs;\n\n    /**\n     * Indicates if some jump instructions are too small and need to be resized.\n     */\n    private boolean resize;\n\n    /**\n     * The number of subroutines in this method.\n     */\n    private int subroutines;\n\n    // ------------------------------------------------------------------------\n    /*\n     * Fields for the control flow graph analysis algorithm (used to compute the\n     * maximum stack size). A control flow graph contains one node per \"basic\n     * block\", and one edge per \"jump\" from one basic block to another. Each\n     * node (i.e., each basic block) is represented by the Label object that\n     * corresponds to the first instruction of this basic block. Each node also\n     * stores the list of its successors in the graph, as a linked list of Edge\n     * objects.\n     */\n    /**\n     * Indicates what must be automatically computed.\n     *\n     * @see #FRAMES\n     * @see #MAXS\n     * @see #NOTHING\n     */\n    private final int compute;\n\n    /**\n     * A list of labels. This list is the list of basic blocks in the method,\n     * i.e. a list of Label objects linked to each other by their\n     * {@link Label#successor} field, in the order they are visited by\n     * {@link MethodVisitor#visitLabel}, and starting with the first basic block.\n     */\n    private Label labels;\n\n    /**\n     * The previous basic block.\n     */\n    private Label previousBlock;\n\n    /**\n     * The current basic block.\n     */\n    private Label currentBlock;\n\n    /**\n     * The (relative) stack size after the last visited instruction. This size\n     * is relative to the beginning of the current basic block, i.e., the true\n     * stack size after the last visited instruction is equal to the\n     * {@link Label#inputStackTop beginStackSize} of the current basic block\n     * plus <tt>stackSize</tt>.\n     */\n    private int stackSize;\n\n    /**\n     * The (relative) maximum stack size after the last visited instruction.\n     * This size is relative to the beginning of the current basic block, i.e.,\n     * the true maximum stack size after the last visited instruction is equal\n     * to the {@link Label#inputStackTop beginStackSize} of the current basic\n     * block plus <tt>stackSize</tt>.\n     */\n    private int maxStackSize;\n\n    // ------------------------------------------------------------------------\n    // Constructor\n    // ------------------------------------------------------------------------\n    /**\n     * Constructs a new {@link MethodWriter}.\n     *\n     * @param cw the class writer in which the method must be added.\n     * @param access the method's access flags (see {@link Opcodes}).\n     * @param name the method's name.\n     * @param desc the method's descriptor (see {@link Type}).\n     * @param signature the method's signature. May be <tt>null</tt>.\n     * @param exceptions the internal names of the method's exceptions. May be\n     *        <tt>null</tt>.\n     * @param computeMaxs <tt>true</tt> if the maximum stack size and number\n     *        of local variables must be automatically computed.\n     * @param computeFrames <tt>true</tt> if the stack map tables must be\n     *        recomputed from scratch.\n     */\n    MethodWriter(final ClassWriter cw, final int access, final String name, final String desc, final String signature, final String[] exceptions, final boolean computeMaxs, final boolean computeFrames) {\n        if (cw.firstMethod == null) {\n            cw.firstMethod = this;\n        } else {\n            cw.lastMethod.next = this;\n        }\n        cw.lastMethod = this;\n        this.cw = cw;\n        this.access = access;\n        this.name = cw.newUTF8(name);\n        this.desc = cw.newUTF8(desc);\n        this.descriptor = desc;\n        if (ClassReader.SIGNATURES) {\n            this.signature = signature;\n        }\n        if (exceptions != null && exceptions.length > 0) {\n            exceptionCount = exceptions.length;\n            this.exceptions = new int[exceptionCount];\n            for (int i = 0; i < exceptionCount; ++i) {\n                this.exceptions[i] = cw.newClass(exceptions[i]);\n            }\n        }\n        this.compute = computeFrames ? FRAMES : (computeMaxs ? MAXS : NOTHING);\n        if (computeMaxs || computeFrames) {\n            if (computeFrames && \"<init>\".equals(name)) {\n                this.access |= ACC_CONSTRUCTOR;\n            }\n            // updates maxLocals\n            int size = Type.getArgumentsAndReturnSizes(descriptor) >> 2;\n            if ((access & Opcodes.ACC_STATIC) != 0) {\n                --size;\n            }\n            maxLocals = size;\n            // creates and visits the label for the first basic block\n            labels = new Label();\n            labels.status |= Label.PUSHED;\n            visitLabel(labels);\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Implementation of the MethodVisitor interface\n    // ------------------------------------------------------------------------\n    public AnnotationVisitor visitAnnotationDefault() {\n        if (!ClassReader.ANNOTATIONS) {\n            return null;\n        }\n        annd = new ByteVector();\n        return new AnnotationWriter(cw, false, annd, null, 0);\n    }\n\n    public AnnotationVisitor visitAnnotation(final String desc, final boolean visible) {\n        if (!ClassReader.ANNOTATIONS) {\n            return null;\n        }\n        ByteVector bv = new ByteVector();\n        // write type, and reserve space for values count\n        bv.putShort(cw.newUTF8(desc)).putShort(0);\n        AnnotationWriter aw = new AnnotationWriter(cw, true, bv, bv, 2);\n        if (visible) {\n            aw.next = anns;\n            anns = aw;\n        } else {\n            aw.next = ianns;\n            ianns = aw;\n        }\n        return aw;\n    }\n\n    public AnnotationVisitor visitParameterAnnotation(final int parameter, final String desc, final boolean visible) {\n        if (!ClassReader.ANNOTATIONS) {\n            return null;\n        }\n        ByteVector bv = new ByteVector();\n        if (\"Ljava/lang/Synthetic;\".equals(desc)) {\n            // workaround for a bug in javac with synthetic parameters\n            // see ClassReader.readParameterAnnotations\n            synthetics = Math.max(synthetics, parameter + 1);\n            return new AnnotationWriter(cw, false, bv, null, 0);\n        }\n        // write type, and reserve space for values count\n        bv.putShort(cw.newUTF8(desc)).putShort(0);\n        AnnotationWriter aw = new AnnotationWriter(cw, true, bv, bv, 2);\n        if (visible) {\n            if (panns == null) {\n                panns = new AnnotationWriter[Type.getArgumentTypes(descriptor).length];\n            }\n            aw.next = panns[parameter];\n            panns[parameter] = aw;\n        } else {\n            if (ipanns == null) {\n                ipanns = new AnnotationWriter[Type.getArgumentTypes(descriptor).length];\n            }\n            aw.next = ipanns[parameter];\n            ipanns[parameter] = aw;\n        }\n        return aw;\n    }\n\n    public void visitAttribute(final Attribute attr) {\n        if (attr.isCodeAttribute()) {\n            attr.next = cattrs;\n            cattrs = attr;\n        } else {\n            attr.next = attrs;\n            attrs = attr;\n        }\n    }\n\n    public void visitCode() {\n    }\n\n    public void visitFrame(final int type, final int nLocal, final Object[] local, final int nStack, final Object[] stack) {\n        if (!ClassReader.FRAMES || compute == FRAMES) {\n            return;\n        }\n        if (type == Opcodes.F_NEW) {\n            startFrame(code.length, nLocal, nStack);\n            for (int i = 0; i < nLocal; ++i) {\n                if (local[i] instanceof String) {\n                    frame[frameIndex++] = Frame.OBJECT | cw.addType((String) local[i]);\n                } else if (local[i] instanceof Integer) {\n                    frame[frameIndex++] = ((Integer) local[i]).intValue();\n                } else {\n                    frame[frameIndex++] = Frame.UNINITIALIZED | cw.addUninitializedType(\"\", ((Label) local[i]).position);\n                }\n            }\n            for (int i = 0; i < nStack; ++i) {\n                if (stack[i] instanceof String) {\n                    frame[frameIndex++] = Frame.OBJECT | cw.addType((String) stack[i]);\n                } else if (stack[i] instanceof Integer) {\n                    frame[frameIndex++] = ((Integer) stack[i]).intValue();\n                } else {\n                    frame[frameIndex++] = Frame.UNINITIALIZED | cw.addUninitializedType(\"\", ((Label) stack[i]).position);\n                }\n            }\n            endFrame();\n        } else {\n            int delta;\n            if (stackMap == null) {\n                stackMap = new ByteVector();\n                delta = code.length;\n            } else {\n                delta = code.length - previousFrameOffset - 1;\n                if (delta < 0) {\n                    if (type == Opcodes.F_SAME) {\n                        return;\n                    } else {\n                        throw new IllegalStateException();\n                    }\n                }\n            }\n            switch(type) {\n                case Opcodes.F_FULL:\n                    stackMap.putByte(FULL_FRAME).putShort(delta).putShort(nLocal);\n                    for (int i = 0; i < nLocal; ++i) {\n                        writeFrameType(local[i]);\n                    }\n                    stackMap.putShort(nStack);\n                    for (int i = 0; i < nStack; ++i) {\n                        writeFrameType(stack[i]);\n                    }\n                    break;\n                case Opcodes.F_APPEND:\n                    stackMap.putByte(SAME_FRAME_EXTENDED + nLocal).putShort(delta);\n                    for (int i = 0; i < nLocal; ++i) {\n                        writeFrameType(local[i]);\n                    }\n                    break;\n                case Opcodes.F_CHOP:\n                    stackMap.putByte(SAME_FRAME_EXTENDED - nLocal).putShort(delta);\n                    break;\n                case Opcodes.F_SAME:\n                    if (delta < 64) {\n                        stackMap.putByte(delta);\n                    } else {\n                        stackMap.putByte(SAME_FRAME_EXTENDED).putShort(delta);\n                    }\n                    break;\n                case Opcodes.F_SAME1:\n                    if (delta < 64) {\n                        stackMap.putByte(SAME_LOCALS_1_STACK_ITEM_FRAME + delta);\n                    } else {\n                        stackMap.putByte(SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED).putShort(delta);\n                    }\n                    writeFrameType(stack[0]);\n                    break;\n            }\n            previousFrameOffset = code.length;\n            ++frameCount;\n        }\n    }\n\n    public void visitInsn(final int opcode) {\n        // adds the instruction to the bytecode of the method\n        code.putByte(opcode);\n        // update currentBlock\n        // Label currentBlock = this.currentBlock;\n        if (currentBlock != null) {\n            if (compute == FRAMES) {\n                currentBlock.frame.execute(opcode, 0, null, null);\n            } else {\n                // updates current and max stack sizes\n                int size = stackSize + Frame.SIZE[opcode];\n                if (size > maxStackSize) {\n                    maxStackSize = size;\n                }\n                stackSize = size;\n            }\n            // if opcode == ATHROW or xRETURN, ends current block (no successor)\n            if ((opcode >= Opcodes.IRETURN && opcode <= Opcodes.RETURN) || opcode == Opcodes.ATHROW) {\n                noSuccessor();\n            }\n        }\n    }\n\n    public void visitIntInsn(final int opcode, final int operand) {\n        // Label currentBlock = this.currentBlock;\n        if (currentBlock != null) {\n            if (compute == FRAMES) {\n                currentBlock.frame.execute(opcode, operand, null, null);\n            } else if (opcode != Opcodes.NEWARRAY) {\n                // updates current and max stack sizes only for NEWARRAY\n                // (stack size variation = 0 for BIPUSH or SIPUSH)\n                int size = stackSize + 1;\n                if (size > maxStackSize) {\n                    maxStackSize = size;\n                }\n                stackSize = size;\n            }\n        }\n        // adds the instruction to the bytecode of the method\n        if (opcode == Opcodes.SIPUSH) {\n            code.put12(opcode, operand);\n        } else {\n            // BIPUSH or NEWARRAY\n            code.put11(opcode, operand);\n        }\n    }\n\n    public void visitVarInsn(final int opcode, final int var) {\n        // Label currentBlock = this.currentBlock;\n        if (currentBlock != null) {\n            if (compute == FRAMES) {\n                currentBlock.frame.execute(opcode, var, null, null);\n            } else {\n                // updates current and max stack sizes\n                if (opcode == Opcodes.RET) {\n                    // no stack change, but end of current block (no successor)\n                    currentBlock.status |= Label.RET;\n                    // save 'stackSize' here for future use\n                    // (see {@link #findSubroutineSuccessors})\n                    currentBlock.inputStackTop = stackSize;\n                    noSuccessor();\n                } else {\n                    // xLOAD or xSTORE\n                    int size = stackSize + Frame.SIZE[opcode];\n                    if (size > maxStackSize) {\n                        maxStackSize = size;\n                    }\n                    stackSize = size;\n                }\n            }\n        }\n        if (compute != NOTHING) {\n            // updates max locals\n            int n;\n            if (opcode == Opcodes.LLOAD || opcode == Opcodes.DLOAD || opcode == Opcodes.LSTORE || opcode == Opcodes.DSTORE) {\n                n = var + 2;\n            } else {\n                n = var + 1;\n            }\n            if (n > maxLocals) {\n                maxLocals = n;\n            }\n        }\n        // adds the instruction to the bytecode of the method\n        if (var < 4 && opcode != Opcodes.RET) {\n            int opt;\n            if (opcode < Opcodes.ISTORE) {\n                /* ILOAD_0 */\n                opt = 26 + ((opcode - Opcodes.ILOAD) << 2) + var;\n            } else {\n                /* ISTORE_0 */\n                opt = 59 + ((opcode - Opcodes.ISTORE) << 2) + var;\n            }\n            code.putByte(opt);\n        } else if (var >= 256) {\n            code.putByte(196).put12(opcode, var);\n        } else {\n            code.put11(opcode, var);\n        }\n        if (opcode >= Opcodes.ISTORE && compute == FRAMES && handlerCount > 0) {\n            visitLabel(new Label());\n        }\n    }\n\n    public void visitTypeInsn(final int opcode, final String type) {\n        Item i = cw.newClassItem(type);\n        // Label currentBlock = this.currentBlock;\n        if (currentBlock != null) {\n            if (compute == FRAMES) {\n                currentBlock.frame.execute(opcode, code.length, cw, i);\n            } else if (opcode == Opcodes.NEW) {\n                // updates current and max stack sizes only if opcode == NEW\n                // (no stack change for ANEWARRAY, CHECKCAST, INSTANCEOF)\n                int size = stackSize + 1;\n                if (size > maxStackSize) {\n                    maxStackSize = size;\n                }\n                stackSize = size;\n            }\n        }\n        // adds the instruction to the bytecode of the method\n        code.put12(opcode, i.index);\n    }\n\n    public void visitFieldInsn(final int opcode, final String owner, final String name, final String desc) {\n        Item i = cw.newFieldItem(owner, name, desc);\n        // Label currentBlock = this.currentBlock;\n        if (currentBlock != null) {\n            if (compute == FRAMES) {\n                currentBlock.frame.execute(opcode, 0, cw, i);\n            } else {\n                int size;\n                // computes the stack size variation\n                char c = desc.charAt(0);\n                switch(opcode) {\n                    case Opcodes.GETSTATIC:\n                        size = stackSize + (c == 'D' || c == 'J' ? 2 : 1);\n                        break;\n                    case Opcodes.PUTSTATIC:\n                        size = stackSize + (c == 'D' || c == 'J' ? -2 : -1);\n                        break;\n                    case Opcodes.GETFIELD:\n                        size = stackSize + (c == 'D' || c == 'J' ? 1 : 0);\n                        break;\n                    // case Constants.PUTFIELD:\n                    default:\n                        size = stackSize + (c == 'D' || c == 'J' ? -3 : -2);\n                        break;\n                }\n                // updates current and max stack sizes\n                if (size > maxStackSize) {\n                    maxStackSize = size;\n                }\n                stackSize = size;\n            }\n        }\n        // adds the instruction to the bytecode of the method\n        code.put12(opcode, i.index);\n    }\n\n    public void visitMethodInsn(final int opcode, final String owner, final String name, final String desc) {\n        boolean itf = opcode == Opcodes.INVOKEINTERFACE;\n        Item i = (opcode == Opcodes.INVOKEDYNAMIC) ? cw.newNameTypeItem(name, desc) : cw.newMethodItem(owner, name, desc, itf);\n        int argSize = i.intVal;\n        // Label currentBlock = this.currentBlock;\n        if (currentBlock != null) {\n            if (compute == FRAMES) {\n                currentBlock.frame.execute(opcode, 0, cw, i);\n            } else {\n                /*\n                 * computes the stack size variation. In order not to recompute\n                 * several times this variation for the same Item, we use the\n                 * intVal field of this item to store this variation, once it\n                 * has been computed. More precisely this intVal field stores\n                 * the sizes of the arguments and of the return value\n                 * corresponding to desc.\n                 */\n                if (argSize == 0) {\n                    // the above sizes have not been computed yet,\n                    // so we compute them...\n                    argSize = Type.getArgumentsAndReturnSizes(desc);\n                    // ... and we save them in order\n                    // not to recompute them in the future\n                    i.intVal = argSize;\n                }\n                int size;\n                if (opcode == Opcodes.INVOKESTATIC || opcode == Opcodes.INVOKEDYNAMIC) {\n                    size = stackSize - (argSize >> 2) + (argSize & 0x03) + 1;\n                } else {\n                    size = stackSize - (argSize >> 2) + (argSize & 0x03);\n                }\n                // updates current and max stack sizes\n                if (size > maxStackSize) {\n                    maxStackSize = size;\n                }\n                stackSize = size;\n            }\n        }\n        // adds the instruction to the bytecode of the method\n        if (itf) {\n            if (argSize == 0) {\n                argSize = Type.getArgumentsAndReturnSizes(desc);\n                i.intVal = argSize;\n            }\n            code.put12(Opcodes.INVOKEINTERFACE, i.index).put11(argSize >> 2, 0);\n        } else {\n            code.put12(opcode, i.index);\n            if (opcode == Opcodes.INVOKEDYNAMIC) {\n                code.putShort(0);\n            }\n        }\n    }\n\n    public void visitJumpInsn(final int opcode, final Label label) {\n        Label nextInsn = null;\n        // Label currentBlock = this.currentBlock;\n        if (currentBlock != null) {\n            if (compute == FRAMES) {\n                currentBlock.frame.execute(opcode, 0, null, null);\n                // 'label' is the target of a jump instruction\n                label.getFirst().status |= Label.TARGET;\n                // adds 'label' as a successor of this basic block\n                addSuccessor(Edge.NORMAL, label);\n                if (opcode != Opcodes.GOTO) {\n                    // creates a Label for the next basic block\n                    nextInsn = new Label();\n                }\n            } else {\n                if (opcode == Opcodes.JSR) {\n                    if ((label.status & Label.SUBROUTINE) == 0) {\n                        label.status |= Label.SUBROUTINE;\n                        ++subroutines;\n                    }\n                    currentBlock.status |= Label.JSR;\n                    addSuccessor(stackSize + 1, label);\n                    // creates a Label for the next basic block\n                    nextInsn = new Label();\n                    /*\n                     * note that, by construction in this method, a JSR block\n                     * has at least two successors in the control flow graph:\n                     * the first one leads the next instruction after the JSR,\n                     * while the second one leads to the JSR target.\n                     */\n                } else {\n                    // updates current stack size (max stack size unchanged\n                    // because stack size variation always negative in this\n                    // case)\n                    stackSize += Frame.SIZE[opcode];\n                    addSuccessor(stackSize, label);\n                }\n            }\n        }\n        // adds the instruction to the bytecode of the method\n        if ((label.status & Label.RESOLVED) != 0 && label.position - code.length < Short.MIN_VALUE) {\n            /*\n             * case of a backward jump with an offset < -32768. In this case we\n             * automatically replace GOTO with GOTO_W, JSR with JSR_W and IFxxx\n             * <l> with IFNOTxxx <l'> GOTO_W <l>, where IFNOTxxx is the\n             * \"opposite\" opcode of IFxxx (i.e., IFNE for IFEQ) and where <l'>\n             * designates the instruction just after the GOTO_W.\n             */\n            if (opcode == Opcodes.GOTO) {\n                // GOTO_W\n                code.putByte(200);\n            } else if (opcode == Opcodes.JSR) {\n                // JSR_W\n                code.putByte(201);\n            } else {\n                // if the IF instruction is transformed into IFNOT GOTO_W the\n                // next instruction becomes the target of the IFNOT instruction\n                if (nextInsn != null) {\n                    nextInsn.status |= Label.TARGET;\n                }\n                code.putByte(opcode <= 166 ? ((opcode + 1) ^ 1) - 1 : opcode ^ 1);\n                // jump offset\n                code.putShort(8);\n                // GOTO_W\n                code.putByte(200);\n            }\n            label.put(this, code, code.length - 1, true);\n        } else {\n            /*\n             * case of a backward jump with an offset >= -32768, or of a forward\n             * jump with, of course, an unknown offset. In these cases we store\n             * the offset in 2 bytes (which will be increased in\n             * resizeInstructions, if needed).\n             */\n            code.putByte(opcode);\n            label.put(this, code, code.length - 1, false);\n        }\n        if (currentBlock != null) {\n            if (nextInsn != null) {\n                // if the jump instruction is not a GOTO, the next instruction\n                // is also a successor of this instruction. Calling visitLabel\n                // adds the label of this next instruction as a successor of the\n                // current block, and starts a new basic block\n                visitLabel(nextInsn);\n            }\n            if (opcode == Opcodes.GOTO) {\n                noSuccessor();\n            }\n        }\n    }\n\n    public void visitLabel(final Label label) {\n        // resolves previous forward references to label, if any\n        resize |= label.resolve(this, code.length, code.data);\n        // updates currentBlock\n        if ((label.status & Label.DEBUG) != 0) {\n            return;\n        }\n        if (compute == FRAMES) {\n            if (currentBlock != null) {\n                if (label.position == currentBlock.position) {\n                    // successive labels, do not start a new basic block\n                    currentBlock.status |= (label.status & Label.TARGET);\n                    label.frame = currentBlock.frame;\n                    return;\n                }\n                // ends current block (with one new successor)\n                addSuccessor(Edge.NORMAL, label);\n            }\n            // begins a new current block\n            currentBlock = label;\n            if (label.frame == null) {\n                label.frame = new Frame();\n                label.frame.owner = label;\n            }\n            // updates the basic block list\n            if (previousBlock != null) {\n                if (label.position == previousBlock.position) {\n                    previousBlock.status |= (label.status & Label.TARGET);\n                    label.frame = previousBlock.frame;\n                    currentBlock = previousBlock;\n                    return;\n                }\n                previousBlock.successor = label;\n            }\n            previousBlock = label;\n        } else if (compute == MAXS) {\n            if (currentBlock != null) {\n                // ends current block (with one new successor)\n                currentBlock.outputStackMax = maxStackSize;\n                addSuccessor(stackSize, label);\n            }\n            // begins a new current block\n            currentBlock = label;\n            // resets the relative current and max stack sizes\n            stackSize = 0;\n            maxStackSize = 0;\n            // updates the basic block list\n            if (previousBlock != null) {\n                previousBlock.successor = label;\n            }\n            previousBlock = label;\n        }\n    }\n\n    public void visitLdcInsn(final Object cst) {\n        Item i = cw.newConstItem(cst);\n        // Label currentBlock = this.currentBlock;\n        if (currentBlock != null) {\n            if (compute == FRAMES) {\n                currentBlock.frame.execute(Opcodes.LDC, 0, cw, i);\n            } else {\n                int size;\n                // computes the stack size variation\n                if (i.type == ClassWriter.LONG || i.type == ClassWriter.DOUBLE) {\n                    size = stackSize + 2;\n                } else {\n                    size = stackSize + 1;\n                }\n                // updates current and max stack sizes\n                if (size > maxStackSize) {\n                    maxStackSize = size;\n                }\n                stackSize = size;\n            }\n        }\n        // adds the instruction to the bytecode of the method\n        int index = i.index;\n        if (i.type == ClassWriter.LONG || i.type == ClassWriter.DOUBLE) {\n            code.put12(20, /* LDC2_W */\n            index);\n        } else if (index >= 256) {\n            code.put12(19, /* LDC_W */\n            index);\n        } else {\n            code.put11(Opcodes.LDC, index);\n        }\n    }\n\n    public void visitIincInsn(final int var, final int increment) {\n        if (currentBlock != null) {\n            if (compute == FRAMES) {\n                currentBlock.frame.execute(Opcodes.IINC, var, null, null);\n            }\n        }\n        if (compute != NOTHING) {\n            // updates max locals\n            int n = var + 1;\n            if (n > maxLocals) {\n                maxLocals = n;\n            }\n        }\n        // adds the instruction to the bytecode of the method\n        if ((var > 255) || (increment > 127) || (increment < -128)) {\n            code.putByte(196).put12(Opcodes.IINC, var).putShort(increment);\n        } else {\n            code.putByte(Opcodes.IINC).put11(var, increment);\n        }\n    }\n\n    public void visitTableSwitchInsn(final int min, final int max, final Label dflt, final Label[] labels) {\n        // adds the instruction to the bytecode of the method\n        int source = code.length;\n        code.putByte(Opcodes.TABLESWITCH);\n        code.putByteArray(null, 0, (4 - code.length % 4) % 4);\n        dflt.put(this, code, source, true);\n        code.putInt(min).putInt(max);\n        for (int i = 0; i < labels.length; ++i) {\n            labels[i].put(this, code, source, true);\n        }\n        // updates currentBlock\n        visitSwitchInsn(dflt, labels);\n    }\n\n    public void visitLookupSwitchInsn(final Label dflt, final int[] keys, final Label[] labels) {\n        // adds the instruction to the bytecode of the method\n        int source = code.length;\n        code.putByte(Opcodes.LOOKUPSWITCH);\n        code.putByteArray(null, 0, (4 - code.length % 4) % 4);\n        dflt.put(this, code, source, true);\n        code.putInt(labels.length);\n        for (int i = 0; i < labels.length; ++i) {\n            code.putInt(keys[i]);\n            labels[i].put(this, code, source, true);\n        }\n        // updates currentBlock\n        visitSwitchInsn(dflt, labels);\n    }\n\n    private void visitSwitchInsn(final Label dflt, final Label[] labels) {\n        // Label currentBlock = this.currentBlock;\n        if (currentBlock != null) {\n            if (compute == FRAMES) {\n                currentBlock.frame.execute(Opcodes.LOOKUPSWITCH, 0, null, null);\n                // adds current block successors\n                addSuccessor(Edge.NORMAL, dflt);\n                dflt.getFirst().status |= Label.TARGET;\n                for (int i = 0; i < labels.length; ++i) {\n                    addSuccessor(Edge.NORMAL, labels[i]);\n                    labels[i].getFirst().status |= Label.TARGET;\n                }\n            } else {\n                // updates current stack size (max stack size unchanged)\n                --stackSize;\n                // adds current block successors\n                addSuccessor(stackSize, dflt);\n                for (int i = 0; i < labels.length; ++i) {\n                    addSuccessor(stackSize, labels[i]);\n                }\n            }\n            // ends current block\n            noSuccessor();\n        }\n    }\n\n    public void visitMultiANewArrayInsn(final String desc, final int dims) {\n        Item i = cw.newClassItem(desc);\n        // Label currentBlock = this.currentBlock;\n        if (currentBlock != null) {\n            if (compute == FRAMES) {\n                currentBlock.frame.execute(Opcodes.MULTIANEWARRAY, dims, cw, i);\n            } else {\n                // updates current stack size (max stack size unchanged because\n                // stack size variation always negative or null)\n                stackSize += 1 - dims;\n            }\n        }\n        // adds the instruction to the bytecode of the method\n        code.put12(Opcodes.MULTIANEWARRAY, i.index).putByte(dims);\n    }\n\n    public void visitTryCatchBlock(final Label start, final Label end, final Label handler, final String type) {\n        ++handlerCount;\n        Handler h = new Handler();\n        h.start = start;\n        h.end = end;\n        h.handler = handler;\n        h.desc = type;\n        h.type = type != null ? cw.newClass(type) : 0;\n        if (lastHandler == null) {\n            firstHandler = h;\n        } else {\n            lastHandler.next = h;\n        }\n        lastHandler = h;\n    }\n\n    public void visitLocalVariable(final String name, final String desc, final String signature, final Label start, final Label end, final int index) {\n        if (signature != null) {\n            if (localVarType == null) {\n                localVarType = new ByteVector();\n            }\n            ++localVarTypeCount;\n            localVarType.putShort(start.position).putShort(end.position - start.position).putShort(cw.newUTF8(name)).putShort(cw.newUTF8(signature)).putShort(index);\n        }\n        if (localVar == null) {\n            localVar = new ByteVector();\n        }\n        ++localVarCount;\n        localVar.putShort(start.position).putShort(end.position - start.position).putShort(cw.newUTF8(name)).putShort(cw.newUTF8(desc)).putShort(index);\n        if (compute != NOTHING) {\n            // updates max locals\n            char c = desc.charAt(0);\n            int n = index + (c == 'J' || c == 'D' ? 2 : 1);\n            if (n > maxLocals) {\n                maxLocals = n;\n            }\n        }\n    }\n\n    public void visitLineNumber(final int line, final Label start) {\n        if (lineNumber == null) {\n            lineNumber = new ByteVector();\n        }\n        ++lineNumberCount;\n        lineNumber.putShort(start.position);\n        lineNumber.putShort(line);\n    }\n\n    public void visitMaxs(final int maxStack, final int maxLocals) {\n        if (ClassReader.FRAMES && compute == FRAMES) {\n            // completes the control flow graph with exception handler blocks\n            Handler handler = firstHandler;\n            while (handler != null) {\n                Label l = handler.start.getFirst();\n                Label h = handler.handler.getFirst();\n                Label e = handler.end.getFirst();\n                // computes the kind of the edges to 'h'\n                String t = handler.desc == null ? \"java/lang/Throwable\" : handler.desc;\n                int kind = Frame.OBJECT | cw.addType(t);\n                // h is an exception handler\n                h.status |= Label.TARGET;\n                // adds 'h' as a successor of labels between 'start' and 'end'\n                while (l != e) {\n                    // creates an edge to 'h'\n                    Edge b = new Edge();\n                    b.info = kind;\n                    b.successor = h;\n                    // adds it to the successors of 'l'\n                    b.next = l.successors;\n                    l.successors = b;\n                    // goes to the next label\n                    l = l.successor;\n                }\n                handler = handler.next;\n            }\n            // creates and visits the first (implicit) frame\n            Frame f = labels.frame;\n            Type[] args = Type.getArgumentTypes(descriptor);\n            f.initInputFrame(cw, access, args, this.maxLocals);\n            visitFrame(f);\n            /*\n             * fix point algorithm: mark the first basic block as 'changed'\n             * (i.e. put it in the 'changed' list) and, while there are changed\n             * basic blocks, choose one, mark it as unchanged, and update its\n             * successors (which can be changed in the process).\n             */\n            int max = 0;\n            Label changed = labels;\n            while (changed != null) {\n                // removes a basic block from the list of changed basic blocks\n                Label l = changed;\n                changed = changed.next;\n                l.next = null;\n                f = l.frame;\n                // a reachable jump target must be stored in the stack map\n                if ((l.status & Label.TARGET) != 0) {\n                    l.status |= Label.STORE;\n                }\n                // all visited labels are reachable, by definition\n                l.status |= Label.REACHABLE;\n                // updates the (absolute) maximum stack size\n                int blockMax = f.inputStack.length + l.outputStackMax;\n                if (blockMax > max) {\n                    max = blockMax;\n                }\n                // updates the successors of the current basic block\n                Edge e = l.successors;\n                while (e != null) {\n                    Label n = e.successor.getFirst();\n                    boolean change = f.merge(cw, n.frame, e.info);\n                    if (change && n.next == null) {\n                        // if n has changed and is not already in the 'changed'\n                        // list, adds it to this list\n                        n.next = changed;\n                        changed = n;\n                    }\n                    e = e.next;\n                }\n            }\n            // visits all the frames that must be stored in the stack map\n            Label l = labels;\n            while (l != null) {\n                f = l.frame;\n                if ((l.status & Label.STORE) != 0) {\n                    visitFrame(f);\n                }\n                if ((l.status & Label.REACHABLE) == 0) {\n                    // finds start and end of dead basic block\n                    Label k = l.successor;\n                    int start = l.position;\n                    int end = (k == null ? code.length : k.position) - 1;\n                    // if non empty basic block\n                    if (end >= start) {\n                        max = Math.max(max, 1);\n                        // replaces instructions with NOP ... NOP ATHROW\n                        for (int i = start; i < end; ++i) {\n                            code.data[i] = Opcodes.NOP;\n                        }\n                        code.data[end] = (byte) Opcodes.ATHROW;\n                        // emits a frame for this unreachable block\n                        startFrame(start, 0, 1);\n                        frame[frameIndex++] = Frame.OBJECT | cw.addType(\"java/lang/Throwable\");\n                        endFrame();\n                    }\n                }\n                l = l.successor;\n            }\n            this.maxStack = max;\n        } else if (compute == MAXS) {\n            // completes the control flow graph with exception handler blocks\n            Handler handler = firstHandler;\n            while (handler != null) {\n                Label l = handler.start;\n                Label h = handler.handler;\n                Label e = handler.end;\n                // adds 'h' as a successor of labels between 'start' and 'end'\n                while (l != e) {\n                    // creates an edge to 'h'\n                    Edge b = new Edge();\n                    b.info = Edge.EXCEPTION;\n                    b.successor = h;\n                    // adds it to the successors of 'l'\n                    if ((l.status & Label.JSR) == 0) {\n                        b.next = l.successors;\n                        l.successors = b;\n                    } else {\n                        // if l is a JSR block, adds b after the first two edges\n                        // to preserve the hypothesis about JSR block successors\n                        // order (see {@link #visitJumpInsn})\n                        b.next = l.successors.next.next;\n                        l.successors.next.next = b;\n                    }\n                    // goes to the next label\n                    l = l.successor;\n                }\n                handler = handler.next;\n            }\n            if (subroutines > 0) {\n                // completes the control flow graph with the RET successors\n                /*\n                 * first step: finds the subroutines. This step determines, for\n                 * each basic block, to which subroutine(s) it belongs.\n                 */\n                // finds the basic blocks that belong to the \"main\" subroutine\n                int id = 0;\n                labels.visitSubroutine(null, 1, subroutines);\n                // finds the basic blocks that belong to the real subroutines\n                Label l = labels;\n                while (l != null) {\n                    if ((l.status & Label.JSR) != 0) {\n                        // the subroutine is defined by l's TARGET, not by l\n                        Label subroutine = l.successors.next.successor;\n                        // if this subroutine has not been visited yet...\n                        if ((subroutine.status & Label.VISITED) == 0) {\n                            // ...assigns it a new id and finds its basic blocks\n                            id += 1;\n                            subroutine.visitSubroutine(null, (id / 32L) << 32 | (1L << (id % 32)), subroutines);\n                        }\n                    }\n                    l = l.successor;\n                }\n                // second step: finds the successors of RET blocks\n                l = labels;\n                while (l != null) {\n                    if ((l.status & Label.JSR) != 0) {\n                        Label L = labels;\n                        while (L != null) {\n                            L.status &= ~Label.VISITED2;\n                            L = L.successor;\n                        }\n                        // the subroutine is defined by l's TARGET, not by l\n                        Label subroutine = l.successors.next.successor;\n                        subroutine.visitSubroutine(l, 0, subroutines);\n                    }\n                    l = l.successor;\n                }\n            }\n            /*\n             * control flow analysis algorithm: while the block stack is not\n             * empty, pop a block from this stack, update the max stack size,\n             * compute the true (non relative) begin stack size of the\n             * successors of this block, and push these successors onto the\n             * stack (unless they have already been pushed onto the stack).\n             * Note: by hypothesis, the {@link Label#inputStackTop} of the\n             * blocks in the block stack are the true (non relative) beginning\n             * stack sizes of these blocks.\n             */\n            int max = 0;\n            Label stack = labels;\n            while (stack != null) {\n                // pops a block from the stack\n                Label l = stack;\n                stack = stack.next;\n                // computes the true (non relative) max stack size of this block\n                int start = l.inputStackTop;\n                int blockMax = start + l.outputStackMax;\n                // updates the global max stack size\n                if (blockMax > max) {\n                    max = blockMax;\n                }\n                // analyzes the successors of the block\n                Edge b = l.successors;\n                if ((l.status & Label.JSR) != 0) {\n                    // ignores the first edge of JSR blocks (virtual successor)\n                    b = b.next;\n                }\n                while (b != null) {\n                    l = b.successor;\n                    // if this successor has not already been pushed...\n                    if ((l.status & Label.PUSHED) == 0) {\n                        // computes its true beginning stack size...\n                        l.inputStackTop = b.info == Edge.EXCEPTION ? 1 : start + b.info;\n                        // ...and pushes it onto the stack\n                        l.status |= Label.PUSHED;\n                        l.next = stack;\n                        stack = l;\n                    }\n                    b = b.next;\n                }\n            }\n            this.maxStack = max;\n        } else {\n            this.maxStack = maxStack;\n            this.maxLocals = maxLocals;\n        }\n    }\n\n    public void visitEnd() {\n    }\n\n    // ------------------------------------------------------------------------\n    // Utility methods: control flow analysis algorithm\n    // ------------------------------------------------------------------------\n    /**\n     * Adds a successor to the {@link #currentBlock currentBlock} block.\n     *\n     * @param info information about the control flow edge to be added.\n     * @param successor the successor block to be added to the current block.\n     */\n    private void addSuccessor(final int info, final Label successor) {\n        // creates and initializes an Edge object...\n        Edge b = new Edge();\n        b.info = info;\n        b.successor = successor;\n        // ...and adds it to the successor list of the currentBlock block\n        b.next = currentBlock.successors;\n        currentBlock.successors = b;\n    }\n\n    /**\n     * Ends the current basic block. This method must be used in the case where\n     * the current basic block does not have any successor.\n     */\n    private void noSuccessor() {\n        if (compute == FRAMES) {\n            Label l = new Label();\n            l.frame = new Frame();\n            l.frame.owner = l;\n            l.resolve(this, code.length, code.data);\n            previousBlock.successor = l;\n            previousBlock = l;\n        } else {\n            currentBlock.outputStackMax = maxStackSize;\n        }\n        currentBlock = null;\n    }\n\n    // ------------------------------------------------------------------------\n    // Utility methods: stack map frames\n    // ------------------------------------------------------------------------\n    /**\n     * Visits a frame that has been computed from scratch.\n     *\n     * @param f the frame that must be visited.\n     */\n    private void visitFrame(final Frame f) {\n        int i, t;\n        int nTop = 0;\n        int nLocal = 0;\n        int nStack = 0;\n        int[] locals = f.inputLocals;\n        int[] stacks = f.inputStack;\n        // computes the number of locals (ignores TOP types that are just after\n        // a LONG or a DOUBLE, and all trailing TOP types)\n        for (i = 0; i < locals.length; ++i) {\n            t = locals[i];\n            if (t == Frame.TOP) {\n                ++nTop;\n            } else {\n                nLocal += nTop + 1;\n                nTop = 0;\n            }\n            if (t == Frame.LONG || t == Frame.DOUBLE) {\n                ++i;\n            }\n        }\n        // computes the stack size (ignores TOP types that are just after\n        // a LONG or a DOUBLE)\n        for (i = 0; i < stacks.length; ++i) {\n            t = stacks[i];\n            ++nStack;\n            if (t == Frame.LONG || t == Frame.DOUBLE) {\n                ++i;\n            }\n        }\n        // visits the frame and its content\n        startFrame(f.owner.position, nLocal, nStack);\n        for (i = 0; nLocal > 0; ++i, --nLocal) {\n            t = locals[i];\n            frame[frameIndex++] = t;\n            if (t == Frame.LONG || t == Frame.DOUBLE) {\n                ++i;\n            }\n        }\n        for (i = 0; i < stacks.length; ++i) {\n            t = stacks[i];\n            frame[frameIndex++] = t;\n            if (t == Frame.LONG || t == Frame.DOUBLE) {\n                ++i;\n            }\n        }\n        endFrame();\n    }\n\n    /**\n     * Starts the visit of a stack map frame.\n     *\n     * @param offset the offset of the instruction to which the frame\n     *        corresponds.\n     * @param nLocal the number of local variables in the frame.\n     * @param nStack the number of stack elements in the frame.\n     */\n    private void startFrame(final int offset, final int nLocal, final int nStack) {\n        int n = 3 + nLocal + nStack;\n        if (frame == null || frame.length < n) {\n            frame = new int[n];\n        }\n        frame[0] = offset;\n        frame[1] = nLocal;\n        frame[2] = nStack;\n        frameIndex = 3;\n    }\n\n    /**\n     * Checks if the visit of the current frame {@link #frame} is finished, and\n     * if yes, write it in the StackMapTable attribute.\n     */\n    private void endFrame() {\n        if (previousFrame != null) {\n            // do not write the first frame\n            if (stackMap == null) {\n                stackMap = new ByteVector();\n            }\n            writeFrame();\n            ++frameCount;\n        }\n        previousFrame = frame;\n        frame = null;\n    }\n\n    /**\n     * Compress and writes the current frame {@link #frame} in the StackMapTable\n     * attribute.\n     */\n    private void writeFrame() {\n        int clocalsSize = frame[1];\n        int cstackSize = frame[2];\n        if ((cw.version & 0xFFFF) < Opcodes.V1_6) {\n            stackMap.putShort(frame[0]).putShort(clocalsSize);\n            writeFrameTypes(3, 3 + clocalsSize);\n            stackMap.putShort(cstackSize);\n            writeFrameTypes(3 + clocalsSize, 3 + clocalsSize + cstackSize);\n            return;\n        }\n        int localsSize = previousFrame[1];\n        int type = FULL_FRAME;\n        int k = 0;\n        int delta;\n        if (frameCount == 0) {\n            delta = frame[0];\n        } else {\n            delta = frame[0] - previousFrame[0] - 1;\n        }\n        if (cstackSize == 0) {\n            k = clocalsSize - localsSize;\n            switch(k) {\n                case -3:\n                case -2:\n                case -1:\n                    type = CHOP_FRAME;\n                    localsSize = clocalsSize;\n                    break;\n                case 0:\n                    type = delta < 64 ? SAME_FRAME : SAME_FRAME_EXTENDED;\n                    break;\n                case 1:\n                case 2:\n                case 3:\n                    type = APPEND_FRAME;\n                    break;\n            }\n        } else if (clocalsSize == localsSize && cstackSize == 1) {\n            type = delta < 63 ? SAME_LOCALS_1_STACK_ITEM_FRAME : SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED;\n        }\n        if (type != FULL_FRAME) {\n            // verify if locals are the same\n            int l = 3;\n            for (int j = 0; j < localsSize; j++) {\n                if (frame[l] != previousFrame[l]) {\n                    type = FULL_FRAME;\n                    break;\n                }\n                l++;\n            }\n        }\n        switch(type) {\n            case SAME_FRAME:\n                stackMap.putByte(delta);\n                break;\n            case SAME_LOCALS_1_STACK_ITEM_FRAME:\n                stackMap.putByte(SAME_LOCALS_1_STACK_ITEM_FRAME + delta);\n                writeFrameTypes(3 + clocalsSize, 4 + clocalsSize);\n                break;\n            case SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED:\n                stackMap.putByte(SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED).putShort(delta);\n                writeFrameTypes(3 + clocalsSize, 4 + clocalsSize);\n                break;\n            case SAME_FRAME_EXTENDED:\n                stackMap.putByte(SAME_FRAME_EXTENDED).putShort(delta);\n                break;\n            case CHOP_FRAME:\n                stackMap.putByte(SAME_FRAME_EXTENDED + k).putShort(delta);\n                break;\n            case APPEND_FRAME:\n                stackMap.putByte(SAME_FRAME_EXTENDED + k).putShort(delta);\n                writeFrameTypes(3 + localsSize, 3 + clocalsSize);\n                break;\n            // case FULL_FRAME:\n            default:\n                stackMap.putByte(FULL_FRAME).putShort(delta).putShort(clocalsSize);\n                writeFrameTypes(3, 3 + clocalsSize);\n                stackMap.putShort(cstackSize);\n                writeFrameTypes(3 + clocalsSize, 3 + clocalsSize + cstackSize);\n        }\n    }\n\n    /**\n     * Writes some types of the current frame {@link #frame} into the\n     * StackMapTableAttribute. This method converts types from the format used\n     * in {@link Label} to the format used in StackMapTable attributes. In\n     * particular, it converts type table indexes to constant pool indexes.\n     *\n     * @param start index of the first type in {@link #frame} to write.\n     * @param end index of last type in {@link #frame} to write (exclusive).\n     */\n    private void writeFrameTypes(final int start, final int end) {\n        for (int i = start; i < end; ++i) {\n            int t = frame[i];\n            int d = t & Frame.DIM;\n            if (d == 0) {\n                int v = t & Frame.BASE_VALUE;\n                switch(t & Frame.BASE_KIND) {\n                    case Frame.OBJECT:\n                        stackMap.putByte(7).putShort(cw.newClass(cw.typeTable[v].strVal1));\n                        break;\n                    case Frame.UNINITIALIZED:\n                        stackMap.putByte(8).putShort(cw.typeTable[v].intVal);\n                        break;\n                    default:\n                        stackMap.putByte(v);\n                }\n            } else {\n                StringBuffer buf = new StringBuffer();\n                d >>= 28;\n                while (d-- > 0) {\n                    buf.append('[');\n                }\n                if ((t & Frame.BASE_KIND) == Frame.OBJECT) {\n                    buf.append('L');\n                    buf.append(cw.typeTable[t & Frame.BASE_VALUE].strVal1);\n                    buf.append(';');\n                } else {\n                    switch(t & 0xF) {\n                        case 1:\n                            buf.append('I');\n                            break;\n                        case 2:\n                            buf.append('F');\n                            break;\n                        case 3:\n                            buf.append('D');\n                            break;\n                        case 9:\n                            buf.append('Z');\n                            break;\n                        case 10:\n                            buf.append('B');\n                            break;\n                        case 11:\n                            buf.append('C');\n                            break;\n                        case 12:\n                            buf.append('S');\n                            break;\n                        default:\n                            buf.append('J');\n                    }\n                }\n                stackMap.putByte(7).putShort(cw.newClass(buf.toString()));\n            }\n        }\n    }\n\n    private void writeFrameType(final Object type) {\n        if (type instanceof String) {\n            stackMap.putByte(7).putShort(cw.newClass((String) type));\n        } else if (type instanceof Integer) {\n            stackMap.putByte(((Integer) type).intValue());\n        } else {\n            stackMap.putByte(8).putShort(((Label) type).position);\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Utility methods: dump bytecode array\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the size of the bytecode of this method.\n     *\n     * @return the size of the bytecode of this method.\n     */\n    final int getSize() {\n        if (classReaderOffset != 0) {\n            return 6 + classReaderLength;\n        }\n        if (resize) {\n            // replaces the temporary jump opcodes introduced by Label.resolve.\n            if (ClassReader.RESIZE) {\n                resizeInstructions();\n            } else {\n                throw new RuntimeException(\"Method code too large!\");\n            }\n        }\n        int size = 8;\n        if (code.length > 0) {\n            cw.newUTF8(\"Code\");\n            size += 18 + code.length + 8 * handlerCount;\n            if (localVar != null) {\n                cw.newUTF8(\"LocalVariableTable\");\n                size += 8 + localVar.length;\n            }\n            if (localVarType != null) {\n                cw.newUTF8(\"LocalVariableTypeTable\");\n                size += 8 + localVarType.length;\n            }\n            if (lineNumber != null) {\n                cw.newUTF8(\"LineNumberTable\");\n                size += 8 + lineNumber.length;\n            }\n            if (stackMap != null) {\n                boolean zip = (cw.version & 0xFFFF) >= Opcodes.V1_6;\n                cw.newUTF8(zip ? \"StackMapTable\" : \"StackMap\");\n                size += 8 + stackMap.length;\n            }\n            if (cattrs != null) {\n                size += cattrs.getSize(cw, code.data, code.length, maxStack, maxLocals);\n            }\n        }\n        if (exceptionCount > 0) {\n            cw.newUTF8(\"Exceptions\");\n            size += 8 + 2 * exceptionCount;\n        }\n        if ((access & Opcodes.ACC_SYNTHETIC) != 0 && (cw.version & 0xffff) < Opcodes.V1_5) {\n            cw.newUTF8(\"Synthetic\");\n            size += 6;\n        }\n        if ((access & Opcodes.ACC_DEPRECATED) != 0) {\n            cw.newUTF8(\"Deprecated\");\n            size += 6;\n        }\n        if (ClassReader.SIGNATURES && signature != null) {\n            cw.newUTF8(\"Signature\");\n            cw.newUTF8(signature);\n            size += 8;\n        }\n        if (ClassReader.ANNOTATIONS && annd != null) {\n            cw.newUTF8(\"AnnotationDefault\");\n            size += 6 + annd.length;\n        }\n        if (ClassReader.ANNOTATIONS && anns != null) {\n            cw.newUTF8(\"RuntimeVisibleAnnotations\");\n            size += 8 + anns.getSize();\n        }\n        if (ClassReader.ANNOTATIONS && ianns != null) {\n            cw.newUTF8(\"RuntimeInvisibleAnnotations\");\n            size += 8 + ianns.getSize();\n        }\n        if (ClassReader.ANNOTATIONS && panns != null) {\n            cw.newUTF8(\"RuntimeVisibleParameterAnnotations\");\n            size += 7 + 2 * (panns.length - synthetics);\n            for (int i = panns.length - 1; i >= synthetics; --i) {\n                size += panns[i] == null ? 0 : panns[i].getSize();\n            }\n        }\n        if (ClassReader.ANNOTATIONS && ipanns != null) {\n            cw.newUTF8(\"RuntimeInvisibleParameterAnnotations\");\n            size += 7 + 2 * (ipanns.length - synthetics);\n            for (int i = ipanns.length - 1; i >= synthetics; --i) {\n                size += ipanns[i] == null ? 0 : ipanns[i].getSize();\n            }\n        }\n        if (attrs != null) {\n            size += attrs.getSize(cw, null, 0, -1, -1);\n        }\n        return size;\n    }\n\n    /**\n     * Puts the bytecode of this method in the given byte vector.\n     *\n     * @param out the byte vector into which the bytecode of this method must be\n     *        copied.\n     */\n    final void put(final ByteVector out) {\n        out.putShort(access).putShort(name).putShort(desc);\n        if (classReaderOffset != 0) {\n            out.putByteArray(cw.cr.b, classReaderOffset, classReaderLength);\n            return;\n        }\n        int attributeCount = 0;\n        if (code.length > 0) {\n            ++attributeCount;\n        }\n        if (exceptionCount > 0) {\n            ++attributeCount;\n        }\n        if ((access & Opcodes.ACC_SYNTHETIC) != 0 && (cw.version & 0xffff) < Opcodes.V1_5) {\n            ++attributeCount;\n        }\n        if ((access & Opcodes.ACC_DEPRECATED) != 0) {\n            ++attributeCount;\n        }\n        if (ClassReader.SIGNATURES && signature != null) {\n            ++attributeCount;\n        }\n        if (ClassReader.ANNOTATIONS && annd != null) {\n            ++attributeCount;\n        }\n        if (ClassReader.ANNOTATIONS && anns != null) {\n            ++attributeCount;\n        }\n        if (ClassReader.ANNOTATIONS && ianns != null) {\n            ++attributeCount;\n        }\n        if (ClassReader.ANNOTATIONS && panns != null) {\n            ++attributeCount;\n        }\n        if (ClassReader.ANNOTATIONS && ipanns != null) {\n            ++attributeCount;\n        }\n        if (attrs != null) {\n            attributeCount += attrs.getCount();\n        }\n        out.putShort(attributeCount);\n        if (code.length > 0) {\n            int size = 12 + code.length + 8 * handlerCount;\n            if (localVar != null) {\n                size += 8 + localVar.length;\n            }\n            if (localVarType != null) {\n                size += 8 + localVarType.length;\n            }\n            if (lineNumber != null) {\n                size += 8 + lineNumber.length;\n            }\n            if (stackMap != null) {\n                size += 8 + stackMap.length;\n            }\n            if (cattrs != null) {\n                size += cattrs.getSize(cw, code.data, code.length, maxStack, maxLocals);\n            }\n            out.putShort(cw.newUTF8(\"Code\")).putInt(size);\n            out.putShort(maxStack).putShort(maxLocals);\n            out.putInt(code.length).putByteArray(code.data, 0, code.length);\n            out.putShort(handlerCount);\n            if (handlerCount > 0) {\n                Handler h = firstHandler;\n                while (h != null) {\n                    out.putShort(h.start.position).putShort(h.end.position).putShort(h.handler.position).putShort(h.type);\n                    h = h.next;\n                }\n            }\n            attributeCount = 0;\n            if (localVar != null) {\n                ++attributeCount;\n            }\n            if (localVarType != null) {\n                ++attributeCount;\n            }\n            if (lineNumber != null) {\n                ++attributeCount;\n            }\n            if (stackMap != null) {\n                ++attributeCount;\n            }\n            if (cattrs != null) {\n                attributeCount += cattrs.getCount();\n            }\n            out.putShort(attributeCount);\n            if (localVar != null) {\n                out.putShort(cw.newUTF8(\"LocalVariableTable\"));\n                out.putInt(localVar.length + 2).putShort(localVarCount);\n                out.putByteArray(localVar.data, 0, localVar.length);\n            }\n            if (localVarType != null) {\n                out.putShort(cw.newUTF8(\"LocalVariableTypeTable\"));\n                out.putInt(localVarType.length + 2).putShort(localVarTypeCount);\n                out.putByteArray(localVarType.data, 0, localVarType.length);\n            }\n            if (lineNumber != null) {\n                out.putShort(cw.newUTF8(\"LineNumberTable\"));\n                out.putInt(lineNumber.length + 2).putShort(lineNumberCount);\n                out.putByteArray(lineNumber.data, 0, lineNumber.length);\n            }\n            if (stackMap != null) {\n                boolean zip = (cw.version & 0xFFFF) >= Opcodes.V1_6;\n                out.putShort(cw.newUTF8(zip ? \"StackMapTable\" : \"StackMap\"));\n                out.putInt(stackMap.length + 2).putShort(frameCount);\n                out.putByteArray(stackMap.data, 0, stackMap.length);\n            }\n            if (cattrs != null) {\n                cattrs.put(cw, code.data, code.length, maxLocals, maxStack, out);\n            }\n        }\n        if (exceptionCount > 0) {\n            out.putShort(cw.newUTF8(\"Exceptions\")).putInt(2 * exceptionCount + 2);\n            out.putShort(exceptionCount);\n            for (int i = 0; i < exceptionCount; ++i) {\n                out.putShort(exceptions[i]);\n            }\n        }\n        if ((access & Opcodes.ACC_SYNTHETIC) != 0 && (cw.version & 0xffff) < Opcodes.V1_5) {\n            out.putShort(cw.newUTF8(\"Synthetic\")).putInt(0);\n        }\n        if ((access & Opcodes.ACC_DEPRECATED) != 0) {\n            out.putShort(cw.newUTF8(\"Deprecated\")).putInt(0);\n        }\n        if (ClassReader.SIGNATURES && signature != null) {\n            out.putShort(cw.newUTF8(\"Signature\")).putInt(2).putShort(cw.newUTF8(signature));\n        }\n        if (ClassReader.ANNOTATIONS && annd != null) {\n            out.putShort(cw.newUTF8(\"AnnotationDefault\"));\n            out.putInt(annd.length);\n            out.putByteArray(annd.data, 0, annd.length);\n        }\n        if (ClassReader.ANNOTATIONS && anns != null) {\n            out.putShort(cw.newUTF8(\"RuntimeVisibleAnnotations\"));\n            anns.put(out);\n        }\n        if (ClassReader.ANNOTATIONS && ianns != null) {\n            out.putShort(cw.newUTF8(\"RuntimeInvisibleAnnotations\"));\n            ianns.put(out);\n        }\n        if (ClassReader.ANNOTATIONS && panns != null) {\n            out.putShort(cw.newUTF8(\"RuntimeVisibleParameterAnnotations\"));\n            AnnotationWriter.put(panns, synthetics, out);\n        }\n        if (ClassReader.ANNOTATIONS && ipanns != null) {\n            out.putShort(cw.newUTF8(\"RuntimeInvisibleParameterAnnotations\"));\n            AnnotationWriter.put(ipanns, synthetics, out);\n        }\n        if (attrs != null) {\n            attrs.put(cw, null, 0, -1, -1, out);\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Utility methods: instruction resizing (used to handle GOTO_W and JSR_W)\n    // ------------------------------------------------------------------------\n    /**\n     * Resizes and replaces the temporary instructions inserted by\n     * {@link Label#resolve} for wide forward jumps, while keeping jump offsets\n     * and instruction addresses consistent. This may require to resize other\n     * existing instructions, or even to introduce new instructions: for\n     * example, increasing the size of an instruction by 2 at the middle of a\n     * method can increases the offset of an IFEQ instruction from 32766 to\n     * 32768, in which case IFEQ 32766 must be replaced with IFNEQ 8 GOTO_W\n     * 32765. This, in turn, may require to increase the size of another jump\n     * instruction, and so on... All these operations are handled automatically\n     * by this method. <p> <i>This method must be called after all the method\n     * that is being built has been visited</i>. In particular, the\n     * {@link Label Label} objects used to construct the method are no longer\n     * valid after this method has been called.\n     */\n    private void resizeInstructions() {\n        // bytecode of the method\n        byte[] b = code.data;\n        // indexes in b\n        int u, v, label;\n        // loop indexes\n        int i, j;\n        /*\n         * 1st step: As explained above, resizing an instruction may require to\n         * resize another one, which may require to resize yet another one, and\n         * so on. The first step of the algorithm consists in finding all the\n         * instructions that need to be resized, without modifying the code.\n         * This is done by the following \"fix point\" algorithm:\n         * \n         * Parse the code to find the jump instructions whose offset will need\n         * more than 2 bytes to be stored (the future offset is computed from\n         * the current offset and from the number of bytes that will be inserted\n         * or removed between the source and target instructions). For each such\n         * instruction, adds an entry in (a copy of) the indexes and sizes\n         * arrays (if this has not already been done in a previous iteration!).\n         * \n         * If at least one entry has been added during the previous step, go\n         * back to the beginning, otherwise stop.\n         * \n         * In fact the real algorithm is complicated by the fact that the size\n         * of TABLESWITCH and LOOKUPSWITCH instructions depends on their\n         * position in the bytecode (because of padding). In order to ensure the\n         * convergence of the algorithm, the number of bytes to be added or\n         * removed from these instructions is over estimated during the previous\n         * loop, and computed exactly only after the loop is finished (this\n         * requires another pass to parse the bytecode of the method).\n         */\n        // copy of indexes\n        int[] allIndexes = new int[0];\n        // copy of sizes\n        int[] allSizes = new int[0];\n        // instructions to be resized\n        boolean[] resize;\n        // future offset of a jump instruction\n        int newOffset;\n        resize = new boolean[code.length];\n        // 3 = loop again, 2 = loop ended, 1 = last pass, 0 = done\n        int state = 3;\n        do {\n            if (state == 3) {\n                state = 2;\n            }\n            u = 0;\n            while (u < b.length) {\n                // opcode of current instruction\n                int opcode = b[u] & 0xFF;\n                // bytes to be added after this instruction\n                int insert = 0;\n                switch(ClassWriter.TYPE[opcode]) {\n                    case ClassWriter.NOARG_INSN:\n                    case ClassWriter.IMPLVAR_INSN:\n                        u += 1;\n                        break;\n                    case ClassWriter.LABEL_INSN:\n                        if (opcode > 201) {\n                            // converts temporary opcodes 202 to 217, 218 and\n                            // 219 to IFEQ ... JSR (inclusive), IFNULL and\n                            // IFNONNULL\n                            opcode = opcode < 218 ? opcode - 49 : opcode - 20;\n                            label = u + readUnsignedShort(b, u + 1);\n                        } else {\n                            label = u + readShort(b, u + 1);\n                        }\n                        newOffset = getNewOffset(allIndexes, allSizes, u, label);\n                        if (newOffset < Short.MIN_VALUE || newOffset > Short.MAX_VALUE) {\n                            if (!resize[u]) {\n                                if (opcode == Opcodes.GOTO || opcode == Opcodes.JSR) {\n                                    // two additional bytes will be required to\n                                    // replace this GOTO or JSR instruction with\n                                    // a GOTO_W or a JSR_W\n                                    insert = 2;\n                                } else {\n                                    // five additional bytes will be required to\n                                    // replace this IFxxx <l> instruction with\n                                    // IFNOTxxx <l'> GOTO_W <l>, where IFNOTxxx\n                                    // is the \"opposite\" opcode of IFxxx (i.e.,\n                                    // IFNE for IFEQ) and where <l'> designates\n                                    // the instruction just after the GOTO_W.\n                                    insert = 5;\n                                }\n                                resize[u] = true;\n                            }\n                        }\n                        u += 3;\n                        break;\n                    case ClassWriter.LABELW_INSN:\n                        u += 5;\n                        break;\n                    case ClassWriter.TABL_INSN:\n                        if (state == 1) {\n                            // true number of bytes to be added (or removed)\n                            // from this instruction = (future number of padding\n                            // bytes - current number of padding byte) -\n                            // previously over estimated variation =\n                            // = ((3 - newOffset%4) - (3 - u%4)) - u%4\n                            // = (-newOffset%4 + u%4) - u%4\n                            // = -(newOffset & 3)\n                            newOffset = getNewOffset(allIndexes, allSizes, 0, u);\n                            insert = -(newOffset & 3);\n                        } else if (!resize[u]) {\n                            // over estimation of the number of bytes to be\n                            // added to this instruction = 3 - current number\n                            // of padding bytes = 3 - (3 - u%4) = u%4 = u & 3\n                            insert = u & 3;\n                            resize[u] = true;\n                        }\n                        // skips instruction\n                        u = u + 4 - (u & 3);\n                        u += 4 * (readInt(b, u + 8) - readInt(b, u + 4) + 1) + 12;\n                        break;\n                    case ClassWriter.LOOK_INSN:\n                        if (state == 1) {\n                            // like TABL_INSN\n                            newOffset = getNewOffset(allIndexes, allSizes, 0, u);\n                            insert = -(newOffset & 3);\n                        } else if (!resize[u]) {\n                            // like TABL_INSN\n                            insert = u & 3;\n                            resize[u] = true;\n                        }\n                        // skips instruction\n                        u = u + 4 - (u & 3);\n                        u += 8 * readInt(b, u + 4) + 8;\n                        break;\n                    case ClassWriter.WIDE_INSN:\n                        opcode = b[u + 1] & 0xFF;\n                        if (opcode == Opcodes.IINC) {\n                            u += 6;\n                        } else {\n                            u += 4;\n                        }\n                        break;\n                    case ClassWriter.VAR_INSN:\n                    case ClassWriter.SBYTE_INSN:\n                    case ClassWriter.LDC_INSN:\n                        u += 2;\n                        break;\n                    case ClassWriter.SHORT_INSN:\n                    case ClassWriter.LDCW_INSN:\n                    case ClassWriter.FIELDORMETH_INSN:\n                    case ClassWriter.TYPE_INSN:\n                    case ClassWriter.IINC_INSN:\n                        u += 3;\n                        break;\n                    case ClassWriter.ITFDYNMETH_INSN:\n                        u += 5;\n                        break;\n                    // case ClassWriter.MANA_INSN:\n                    default:\n                        u += 4;\n                        break;\n                }\n                if (insert != 0) {\n                    // adds a new (u, insert) entry in the allIndexes and\n                    // allSizes arrays\n                    int[] newIndexes = new int[allIndexes.length + 1];\n                    int[] newSizes = new int[allSizes.length + 1];\n                    System.arraycopy(allIndexes, 0, newIndexes, 0, allIndexes.length);\n                    System.arraycopy(allSizes, 0, newSizes, 0, allSizes.length);\n                    newIndexes[allIndexes.length] = u;\n                    newSizes[allSizes.length] = insert;\n                    allIndexes = newIndexes;\n                    allSizes = newSizes;\n                    if (insert > 0) {\n                        state = 3;\n                    }\n                }\n            }\n            if (state < 3) {\n                --state;\n            }\n        } while (state != 0);\n        // 2nd step:\n        // copies the bytecode of the method into a new bytevector, updates the\n        // offsets, and inserts (or removes) bytes as requested.\n        ByteVector newCode = new ByteVector(code.length);\n        u = 0;\n        while (u < code.length) {\n            int opcode = b[u] & 0xFF;\n            switch(ClassWriter.TYPE[opcode]) {\n                case ClassWriter.NOARG_INSN:\n                case ClassWriter.IMPLVAR_INSN:\n                    newCode.putByte(opcode);\n                    u += 1;\n                    break;\n                case ClassWriter.LABEL_INSN:\n                    if (opcode > 201) {\n                        // changes temporary opcodes 202 to 217 (inclusive), 218\n                        // and 219 to IFEQ ... JSR (inclusive), IFNULL and\n                        // IFNONNULL\n                        opcode = opcode < 218 ? opcode - 49 : opcode - 20;\n                        label = u + readUnsignedShort(b, u + 1);\n                    } else {\n                        label = u + readShort(b, u + 1);\n                    }\n                    newOffset = getNewOffset(allIndexes, allSizes, u, label);\n                    if (resize[u]) {\n                        // replaces GOTO with GOTO_W, JSR with JSR_W and IFxxx\n                        // <l> with IFNOTxxx <l'> GOTO_W <l>, where IFNOTxxx is\n                        // the \"opposite\" opcode of IFxxx (i.e., IFNE for IFEQ)\n                        // and where <l'> designates the instruction just after\n                        // the GOTO_W.\n                        if (opcode == Opcodes.GOTO) {\n                            // GOTO_W\n                            newCode.putByte(200);\n                        } else if (opcode == Opcodes.JSR) {\n                            // JSR_W\n                            newCode.putByte(201);\n                        } else {\n                            newCode.putByte(opcode <= 166 ? ((opcode + 1) ^ 1) - 1 : opcode ^ 1);\n                            // jump offset\n                            newCode.putShort(8);\n                            // GOTO_W\n                            newCode.putByte(200);\n                            // newOffset now computed from start of GOTO_W\n                            newOffset -= 3;\n                        }\n                        newCode.putInt(newOffset);\n                    } else {\n                        newCode.putByte(opcode);\n                        newCode.putShort(newOffset);\n                    }\n                    u += 3;\n                    break;\n                case ClassWriter.LABELW_INSN:\n                    label = u + readInt(b, u + 1);\n                    newOffset = getNewOffset(allIndexes, allSizes, u, label);\n                    newCode.putByte(opcode);\n                    newCode.putInt(newOffset);\n                    u += 5;\n                    break;\n                case ClassWriter.TABL_INSN:\n                    // skips 0 to 3 padding bytes\n                    v = u;\n                    u = u + 4 - (v & 3);\n                    // reads and copies instruction\n                    newCode.putByte(Opcodes.TABLESWITCH);\n                    newCode.putByteArray(null, 0, (4 - newCode.length % 4) % 4);\n                    label = v + readInt(b, u);\n                    u += 4;\n                    newOffset = getNewOffset(allIndexes, allSizes, v, label);\n                    newCode.putInt(newOffset);\n                    j = readInt(b, u);\n                    u += 4;\n                    newCode.putInt(j);\n                    j = readInt(b, u) - j + 1;\n                    u += 4;\n                    newCode.putInt(readInt(b, u - 4));\n                    for (; j > 0; --j) {\n                        label = v + readInt(b, u);\n                        u += 4;\n                        newOffset = getNewOffset(allIndexes, allSizes, v, label);\n                        newCode.putInt(newOffset);\n                    }\n                    break;\n                case ClassWriter.LOOK_INSN:\n                    // skips 0 to 3 padding bytes\n                    v = u;\n                    u = u + 4 - (v & 3);\n                    // reads and copies instruction\n                    newCode.putByte(Opcodes.LOOKUPSWITCH);\n                    newCode.putByteArray(null, 0, (4 - newCode.length % 4) % 4);\n                    label = v + readInt(b, u);\n                    u += 4;\n                    newOffset = getNewOffset(allIndexes, allSizes, v, label);\n                    newCode.putInt(newOffset);\n                    j = readInt(b, u);\n                    u += 4;\n                    newCode.putInt(j);\n                    for (; j > 0; --j) {\n                        newCode.putInt(readInt(b, u));\n                        u += 4;\n                        label = v + readInt(b, u);\n                        u += 4;\n                        newOffset = getNewOffset(allIndexes, allSizes, v, label);\n                        newCode.putInt(newOffset);\n                    }\n                    break;\n                case ClassWriter.WIDE_INSN:\n                    opcode = b[u + 1] & 0xFF;\n                    if (opcode == Opcodes.IINC) {\n                        newCode.putByteArray(b, u, 6);\n                        u += 6;\n                    } else {\n                        newCode.putByteArray(b, u, 4);\n                        u += 4;\n                    }\n                    break;\n                case ClassWriter.VAR_INSN:\n                case ClassWriter.SBYTE_INSN:\n                case ClassWriter.LDC_INSN:\n                    newCode.putByteArray(b, u, 2);\n                    u += 2;\n                    break;\n                case ClassWriter.SHORT_INSN:\n                case ClassWriter.LDCW_INSN:\n                case ClassWriter.FIELDORMETH_INSN:\n                case ClassWriter.TYPE_INSN:\n                case ClassWriter.IINC_INSN:\n                    newCode.putByteArray(b, u, 3);\n                    u += 3;\n                    break;\n                case ClassWriter.ITFDYNMETH_INSN:\n                    newCode.putByteArray(b, u, 5);\n                    u += 5;\n                    break;\n                // case MANA_INSN:\n                default:\n                    newCode.putByteArray(b, u, 4);\n                    u += 4;\n                    break;\n            }\n        }\n        // recomputes the stack map frames\n        if (frameCount > 0) {\n            if (compute == FRAMES) {\n                frameCount = 0;\n                stackMap = null;\n                previousFrame = null;\n                frame = null;\n                Frame f = new Frame();\n                f.owner = labels;\n                Type[] args = Type.getArgumentTypes(descriptor);\n                f.initInputFrame(cw, access, args, maxLocals);\n                visitFrame(f);\n                Label l = labels;\n                while (l != null) {\n                    /*\n                     * here we need the original label position. getNewOffset\n                     * must therefore never have been called for this label.\n                     */\n                    u = l.position - 3;\n                    if ((l.status & Label.STORE) != 0 || (u >= 0 && resize[u])) {\n                        getNewOffset(allIndexes, allSizes, l);\n                        // TODO update offsets in UNINITIALIZED values\n                        visitFrame(l.frame);\n                    }\n                    l = l.successor;\n                }\n            } else {\n                /*\n                 * Resizing an existing stack map frame table is really hard.\n                 * Not only the table must be parsed to update the offets, but\n                 * new frames may be needed for jump instructions that were\n                 * inserted by this method. And updating the offsets or\n                 * inserting frames can change the format of the following\n                 * frames, in case of packed frames. In practice the whole table\n                 * must be recomputed. For this the frames are marked as\n                 * potentially invalid. This will cause the whole class to be\n                 * reread and rewritten with the COMPUTE_FRAMES option (see the\n                 * ClassWriter.toByteArray method). This is not very efficient\n                 * but is much easier and requires much less code than any other\n                 * method I can think of.\n                 */\n                cw.invalidFrames = true;\n            }\n        }\n        // updates the exception handler block labels\n        Handler h = firstHandler;\n        while (h != null) {\n            getNewOffset(allIndexes, allSizes, h.start);\n            getNewOffset(allIndexes, allSizes, h.end);\n            getNewOffset(allIndexes, allSizes, h.handler);\n            h = h.next;\n        }\n        // updates the instructions addresses in the\n        // local var and line number tables\n        for (i = 0; i < 2; ++i) {\n            ByteVector bv = i == 0 ? localVar : localVarType;\n            if (bv != null) {\n                b = bv.data;\n                u = 0;\n                while (u < bv.length) {\n                    label = readUnsignedShort(b, u);\n                    newOffset = getNewOffset(allIndexes, allSizes, 0, label);\n                    writeShort(b, u, newOffset);\n                    label += readUnsignedShort(b, u + 2);\n                    newOffset = getNewOffset(allIndexes, allSizes, 0, label) - newOffset;\n                    writeShort(b, u + 2, newOffset);\n                    u += 10;\n                }\n            }\n        }\n        if (lineNumber != null) {\n            b = lineNumber.data;\n            u = 0;\n            while (u < lineNumber.length) {\n                writeShort(b, u, getNewOffset(allIndexes, allSizes, 0, readUnsignedShort(b, u)));\n                u += 4;\n            }\n        }\n        // updates the labels of the other attributes\n        Attribute attr = cattrs;\n        while (attr != null) {\n            Label[] labels = attr.getLabels();\n            if (labels != null) {\n                for (i = labels.length - 1; i >= 0; --i) {\n                    getNewOffset(allIndexes, allSizes, labels[i]);\n                }\n            }\n            attr = attr.next;\n        }\n        // replaces old bytecodes with new ones\n        code = newCode;\n    }\n\n    /**\n     * Reads an unsigned short value in the given byte array.\n     *\n     * @param b a byte array.\n     * @param index the start index of the value to be read.\n     * @return the read value.\n     */\n    static int readUnsignedShort(final byte[] b, final int index) {\n        return ((b[index] & 0xFF) << 8) | (b[index + 1] & 0xFF);\n    }\n\n    /**\n     * Reads a signed short value in the given byte array.\n     *\n     * @param b a byte array.\n     * @param index the start index of the value to be read.\n     * @return the read value.\n     */\n    static short readShort(final byte[] b, final int index) {\n        return (short) (((b[index] & 0xFF) << 8) | (b[index + 1] & 0xFF));\n    }\n\n    /**\n     * Reads a signed int value in the given byte array.\n     *\n     * @param b a byte array.\n     * @param index the start index of the value to be read.\n     * @return the read value.\n     */\n    static int readInt(final byte[] b, final int index) {\n        return ((b[index] & 0xFF) << 24) | ((b[index + 1] & 0xFF) << 16) | ((b[index + 2] & 0xFF) << 8) | (b[index + 3] & 0xFF);\n    }\n\n    /**\n     * Writes a short value in the given byte array.\n     *\n     * @param b a byte array.\n     * @param index where the first byte of the short value must be written.\n     * @param s the value to be written in the given byte array.\n     */\n    static void writeShort(final byte[] b, final int index, final int s) {\n        b[index] = (byte) (s >>> 8);\n        b[index + 1] = (byte) s;\n    }\n\n    /**\n     * Computes the future value of a bytecode offset. <p> Note: it is possible\n     * to have several entries for the same instruction in the <tt>indexes</tt>\n     * and <tt>sizes</tt>: two entries (index=a,size=b) and (index=a,size=b')\n     * are equivalent to a single entry (index=a,size=b+b').\n     *\n     * @param indexes current positions of the instructions to be resized. Each\n     *        instruction must be designated by the index of its <i>last</i>\n     *        byte, plus one (or, in other words, by the index of the <i>first</i>\n     *        byte of the <i>next</i> instruction).\n     * @param sizes the number of bytes to be <i>added</i> to the above\n     *        instructions. More precisely, for each i < <tt>len</tt>,\n     *        <tt>sizes</tt>[i] bytes will be added at the end of the\n     *        instruction designated by <tt>indexes</tt>[i] or, if\n     *        <tt>sizes</tt>[i] is negative, the <i>last</i> |<tt>sizes[i]</tt>|\n     *        bytes of the instruction will be removed (the instruction size\n     *        <i>must not</i> become negative or null).\n     * @param begin index of the first byte of the source instruction.\n     * @param end index of the first byte of the target instruction.\n     * @return the future value of the given bytecode offset.\n     */\n    static int getNewOffset(final int[] indexes, final int[] sizes, final int begin, final int end) {\n        int offset = end - begin;\n        for (int i = 0; i < indexes.length; ++i) {\n            if (begin < indexes[i] && indexes[i] <= end) {\n                // forward jump\n                offset += sizes[i];\n            } else if (end < indexes[i] && indexes[i] <= begin) {\n                // backward jump\n                offset -= sizes[i];\n            }\n        }\n        return offset;\n    }\n\n    /**\n     * Updates the offset of the given label.\n     *\n     * @param indexes current positions of the instructions to be resized. Each\n     *        instruction must be designated by the index of its <i>last</i>\n     *        byte, plus one (or, in other words, by the index of the <i>first</i>\n     *        byte of the <i>next</i> instruction).\n     * @param sizes the number of bytes to be <i>added</i> to the above\n     *        instructions. More precisely, for each i < <tt>len</tt>,\n     *        <tt>sizes</tt>[i] bytes will be added at the end of the\n     *        instruction designated by <tt>indexes</tt>[i] or, if\n     *        <tt>sizes</tt>[i] is negative, the <i>last</i> |<tt>sizes[i]</tt>|\n     *        bytes of the instruction will be removed (the instruction size\n     *        <i>must not</i> become negative or null).\n     * @param label the label whose offset must be updated.\n     */\n    static void getNewOffset(final int[] indexes, final int[] sizes, final Label label) {\n        if ((label.status & Label.RESIZED) == 0) {\n            label.position = getNewOffset(indexes, sizes, 0, label.position);\n            label.status |= Label.RESIZED;\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/MethodWriterTest2.java",
		"test_prompt": "// MethodWriterTest2.java\npackage org.objectweb.asm.jip;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MethodWriter}.\n* It contains ten unit test cases for the {@link MethodWriter#visitParameterAnnotation(int, String, boolean)} method.\n*/\nclass MethodWriterTest2 {"
	},
	{
		"original_code": "// StackMapAttribute.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2005 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip.attrs;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport org.objectweb.asm.jip.Attribute;\nimport org.objectweb.asm.jip.ByteVector;\nimport org.objectweb.asm.jip.ClassReader;\nimport org.objectweb.asm.jip.ClassWriter;\nimport org.objectweb.asm.jip.Label;\n\n/**\n * StackMapAttribute is used by CDLC preverifier. Definition is given in\n * appendix \"CLDC Byte Code Typechecker Specification\" from CDLC 1.1\n * specification. <p> <i>Note that this implementation does not calculate\n * StackMapFrame structures from the method bytecode. If method code is changed\n * or generated from scratch, then developer is responsible to prepare a correct\n * StackMapFrame structures.</i> <p> The format of the stack map in the class\n * file is given below. In the following, <ul> <li>if the length of the\n * method's byte code1 is 65535 or less, then <tt>uoffset</tt> represents the\n * type u2; otherwise <tt>uoffset</tt> represents the type u4.</li> <li>If\n * the maximum number of local variables for the method is 65535 or less, then\n * <tt>ulocalvar</tt> represents the type u2; otherwise <tt>ulocalvar</tt>\n * represents the type u4.</li> <li>If the maximum size of the operand stack\n * is 65535 or less, then <tt>ustack</tt> represents the type u2; otherwise\n * ustack represents the type u4.</li> </ul>\n *\n * <pre>\n * stack_map { // attribute StackMap\n *   u2 attribute_name_index;\n *   u4 attribute_length\n *   uoffset number_of_entries;\n *   stack_map_frame entries[number_of_entries];\n * }\n * </pre>\n *\n * Each stack map frame has the following format:\n *\n * <pre>\n * stack_map_frame {\n *   uoffset offset;\n *   ulocalvar number_of_locals;\n *   verification_type_info locals[number_of_locals];\n *   ustack number_of_stack_items;\n *   verification_type_info stack[number_of_stack_items];\n * }\n * </pre>\n *\n * The <tt>verification_type_info</tt> structure consists of a one-byte tag\n * followed by zero or more bytes, giving more information about the tag. Each\n * <tt>verification_type_info</tt> structure specifies the verification type\n * of one or two locations.\n *\n * <pre>\n * union verification_type_info {\n *   Top_variable_info;\n *   Integer_variable_info;\n *   Float_variable_info;\n *   Long_variable_info;\n *   Double_variable_info;\n *   Null_variable_info;\n *   UninitializedThis_variable_info;\n *   Object_variable_info;\n *   Uninitialized_variable_info;\n * }\n *\n * Top_variable_info {\n *   u1 tag = ITEM_Top; // 0\n * }\n *\n * Integer_variable_info {\n *   u1 tag = ITEM_Integer; // 1\n * }\n *\n * Float_variable_info {\n *   u1 tag = ITEM_Float; // 2\n * }\n *\n * Long_variable_info {\n *   u1 tag = ITEM_Long; // 4\n * }\n *\n * Double_variable_info {\n *   u1 tag = ITEM_Double; // 3\n * }\n *\n * Null_variable_info {\n *  u1 tag = ITEM_Null; // 5\n * }\n *\n * UninitializedThis_variable_info {\n *   u1 tag = ITEM_UninitializedThis; // 6\n * }\n *\n * Object_variable_info {\n *   u1 tag = ITEM_Object; // 7\n *   u2 cpool_index;\n * }\n *\n * Uninitialized_variable_info {\n *   u1 tag = ITEM_Uninitialized // 8\n *   uoffset offset;\n * }\n * </pre>\n *\n * @see <a href=\"http://www.jcp.org/en/jsr/detail?id=139\">JSR 139 : Connected\n *      Limited Device Configuration 1.1</a>\n *\n * @author Eugene Kuleshov\n */\npublic class StackMapAttribute extends Attribute {\n\n    static final int MAX_SIZE = 65535;\n\n    /**\n     * A List of <code>StackMapFrame</code> instances.\n     */\n    public List frames = new ArrayList();\n\n    public StackMapAttribute() {\n        super(\"StackMap\");\n    }\n\n    public StackMapAttribute(List frames) {\n        this();\n        this.frames = frames;\n    }\n\n    public List getFrames() {\n        return frames;\n    }\n\n    public StackMapFrame getFrame(Label label) {\n        for (int i = 0; i < frames.size(); i++) {\n            StackMapFrame frame = (StackMapFrame) frames.get(i);\n            if (frame.label == label) {\n                return frame;\n            }\n        }\n        return null;\n    }\n\n    public boolean isUnknown() {\n        return false;\n    }\n\n    public boolean isCodeAttribute() {\n        return true;\n    }\n\n    protected Attribute read(ClassReader cr, int off, int len, char[] buf, int codeOff, Label[] labels) {\n        StackMapAttribute attr = new StackMapAttribute();\n        // note that this is not the size of Code attribute\n        boolean isExtCodeSize = cr.readInt(codeOff + 4) > MAX_SIZE;\n        boolean isExtLocals = cr.readUnsignedShort(codeOff + 2) > MAX_SIZE;\n        boolean isExtStack = cr.readUnsignedShort(codeOff) > MAX_SIZE;\n        int size = 0;\n        if (isExtCodeSize) {\n            size = cr.readInt(off);\n            off += 4;\n        } else {\n            size = cr.readUnsignedShort(off);\n            off += 2;\n        }\n        for (int i = 0; i < size; i++) {\n            int offset;\n            if (isExtCodeSize) {\n                offset = cr.readInt(off);\n                off += 4;\n            } else {\n                offset = cr.readUnsignedShort(off);\n                off += 2;\n            }\n            Label label = getLabel(offset, labels);\n            List locals = new ArrayList();\n            List stack = new ArrayList();\n            off = readTypeInfo(cr, off, locals, labels, buf, isExtLocals, isExtCodeSize);\n            off = readTypeInfo(cr, off, stack, labels, buf, isExtStack, isExtCodeSize);\n            attr.frames.add(new StackMapFrame(label, locals, stack));\n        }\n        return attr;\n    }\n\n    private int readTypeInfo(ClassReader cr, int off, List info, Label[] labels, char[] buf, boolean isExt, boolean isExtCode) {\n        int n = 0;\n        if (isExt) {\n            n = cr.readInt(off);\n            off += 4;\n        } else {\n            n = cr.readUnsignedShort(off);\n            off += 2;\n        }\n        for (int j = 0; j < n; j++) {\n            int itemType = cr.readByte(off++);\n            StackMapType typeInfo = StackMapType.getTypeInfo(itemType);\n            info.add(typeInfo);\n            switch(itemType) {\n                case //\n                StackMapType.ITEM_Object:\n                    typeInfo.setObject(cr.readClass(off, buf));\n                    off += 2;\n                    break;\n                case //\n                StackMapType.ITEM_Uninitialized:\n                    int offset;\n                    if (isExtCode) {\n                        offset = cr.readInt(off);\n                        off += 4;\n                    } else {\n                        offset = cr.readUnsignedShort(off);\n                        off += 2;\n                    }\n                    typeInfo.setLabel(getLabel(offset, labels));\n                    break;\n            }\n        }\n        return off;\n    }\n\n    private void writeTypeInfo(ByteVector bv, ClassWriter cw, List info, int max) {\n        if (max > StackMapAttribute.MAX_SIZE) {\n            bv.putInt(info.size());\n        } else {\n            bv.putShort(info.size());\n        }\n        for (int j = 0; j < info.size(); j++) {\n            StackMapType typeInfo = (StackMapType) info.get(j);\n            bv.putByte(typeInfo.getType());\n            switch(typeInfo.getType()) {\n                case //\n                StackMapType.ITEM_Object:\n                    bv.putShort(cw.newClass(typeInfo.getObject()));\n                    break;\n                case //\n                StackMapType.ITEM_Uninitialized:\n                    bv.putShort(typeInfo.getLabel().getOffset());\n                    break;\n            }\n        }\n    }\n\n    private Label getLabel(int offset, Label[] labels) {\n        Label l = labels[offset];\n        if (l != null) {\n            return l;\n        }\n        return labels[offset] = new Label();\n    }\n\n    protected ByteVector write(ClassWriter cw, byte[] code, int len, int maxStack, int maxLocals) {\n        ByteVector bv = new ByteVector();\n        if (code != null && code.length > MAX_SIZE) {\n            // TODO verify value\n            bv.putInt(frames.size());\n        } else {\n            bv.putShort(frames.size());\n        }\n        for (int i = 0; i < frames.size(); i++) {\n            writeFrame((StackMapFrame) frames.get(i), cw, maxStack, maxLocals, bv);\n        }\n        return bv;\n    }\n\n    protected Label[] getLabels() {\n        HashSet labels = new HashSet();\n        for (int i = 0; i < frames.size(); i++) {\n            getFrameLabels((StackMapFrame) frames.get(i), labels);\n        }\n        return (Label[]) labels.toArray(new Label[labels.size()]);\n    }\n\n    private void writeFrame(StackMapFrame frame, ClassWriter cw, int maxStack, int maxLocals, ByteVector bv) {\n        bv.putShort(frame.label.getOffset());\n        writeTypeInfo(bv, cw, frame.locals, maxLocals);\n        writeTypeInfo(bv, cw, frame.stack, maxStack);\n    }\n\n    private void getFrameLabels(StackMapFrame frame, Set labels) {\n        labels.add(frame.label);\n        getTypeInfoLabels(labels, frame.locals);\n        getTypeInfoLabels(labels, frame.stack);\n    }\n\n    private void getTypeInfoLabels(Set labels, List info) {\n        for (Iterator it = info.iterator(); it.hasNext(); ) {\n            StackMapType typeInfo = (StackMapType) it.next();\n            if (typeInfo.getType() == StackMapType.ITEM_Uninitialized) {\n                labels.add(typeInfo.getLabel());\n            }\n        }\n    }\n\n    public String toString() {\n        StringBuffer sb = new StringBuffer(\"StackMap[\");\n        for (int i = 0; i < frames.size(); i++) {\n            sb.append('\\n').append('[').append(frames.get(i)).append(']');\n        }\n        sb.append(\"\\n]\");\n        return sb.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/attrs/StackMapAttributeTest0.java",
		"test_prompt": "// StackMapAttributeTest0.java\npackage org.objectweb.asm.jip.attrs;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport org.objectweb.asm.jip.Attribute;\nimport org.objectweb.asm.jip.ByteVector;\nimport org.objectweb.asm.jip.ClassReader;\nimport org.objectweb.asm.jip.ClassWriter;\nimport org.objectweb.asm.jip.Label;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StackMapAttribute}.\n* It contains ten unit test cases for the {@link StackMapAttribute#isUnknown()} method.\n*/\nclass StackMapAttributeTest0 {"
	},
	{
		"original_code": "// StackMapAttribute.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2005 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip.attrs;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport org.objectweb.asm.jip.Attribute;\nimport org.objectweb.asm.jip.ByteVector;\nimport org.objectweb.asm.jip.ClassReader;\nimport org.objectweb.asm.jip.ClassWriter;\nimport org.objectweb.asm.jip.Label;\n\n/**\n * StackMapAttribute is used by CDLC preverifier. Definition is given in\n * appendix \"CLDC Byte Code Typechecker Specification\" from CDLC 1.1\n * specification. <p> <i>Note that this implementation does not calculate\n * StackMapFrame structures from the method bytecode. If method code is changed\n * or generated from scratch, then developer is responsible to prepare a correct\n * StackMapFrame structures.</i> <p> The format of the stack map in the class\n * file is given below. In the following, <ul> <li>if the length of the\n * method's byte code1 is 65535 or less, then <tt>uoffset</tt> represents the\n * type u2; otherwise <tt>uoffset</tt> represents the type u4.</li> <li>If\n * the maximum number of local variables for the method is 65535 or less, then\n * <tt>ulocalvar</tt> represents the type u2; otherwise <tt>ulocalvar</tt>\n * represents the type u4.</li> <li>If the maximum size of the operand stack\n * is 65535 or less, then <tt>ustack</tt> represents the type u2; otherwise\n * ustack represents the type u4.</li> </ul>\n *\n * <pre>\n * stack_map { // attribute StackMap\n *   u2 attribute_name_index;\n *   u4 attribute_length\n *   uoffset number_of_entries;\n *   stack_map_frame entries[number_of_entries];\n * }\n * </pre>\n *\n * Each stack map frame has the following format:\n *\n * <pre>\n * stack_map_frame {\n *   uoffset offset;\n *   ulocalvar number_of_locals;\n *   verification_type_info locals[number_of_locals];\n *   ustack number_of_stack_items;\n *   verification_type_info stack[number_of_stack_items];\n * }\n * </pre>\n *\n * The <tt>verification_type_info</tt> structure consists of a one-byte tag\n * followed by zero or more bytes, giving more information about the tag. Each\n * <tt>verification_type_info</tt> structure specifies the verification type\n * of one or two locations.\n *\n * <pre>\n * union verification_type_info {\n *   Top_variable_info;\n *   Integer_variable_info;\n *   Float_variable_info;\n *   Long_variable_info;\n *   Double_variable_info;\n *   Null_variable_info;\n *   UninitializedThis_variable_info;\n *   Object_variable_info;\n *   Uninitialized_variable_info;\n * }\n *\n * Top_variable_info {\n *   u1 tag = ITEM_Top; // 0\n * }\n *\n * Integer_variable_info {\n *   u1 tag = ITEM_Integer; // 1\n * }\n *\n * Float_variable_info {\n *   u1 tag = ITEM_Float; // 2\n * }\n *\n * Long_variable_info {\n *   u1 tag = ITEM_Long; // 4\n * }\n *\n * Double_variable_info {\n *   u1 tag = ITEM_Double; // 3\n * }\n *\n * Null_variable_info {\n *  u1 tag = ITEM_Null; // 5\n * }\n *\n * UninitializedThis_variable_info {\n *   u1 tag = ITEM_UninitializedThis; // 6\n * }\n *\n * Object_variable_info {\n *   u1 tag = ITEM_Object; // 7\n *   u2 cpool_index;\n * }\n *\n * Uninitialized_variable_info {\n *   u1 tag = ITEM_Uninitialized // 8\n *   uoffset offset;\n * }\n * </pre>\n *\n * @see <a href=\"http://www.jcp.org/en/jsr/detail?id=139\">JSR 139 : Connected\n *      Limited Device Configuration 1.1</a>\n *\n * @author Eugene Kuleshov\n */\npublic class StackMapAttribute extends Attribute {\n\n    static final int MAX_SIZE = 65535;\n\n    /**\n     * A List of <code>StackMapFrame</code> instances.\n     */\n    public List frames = new ArrayList();\n\n    public StackMapAttribute() {\n        super(\"StackMap\");\n    }\n\n    public StackMapAttribute(List frames) {\n        this();\n        this.frames = frames;\n    }\n\n    public List getFrames() {\n        return frames;\n    }\n\n    public StackMapFrame getFrame(Label label) {\n        for (int i = 0; i < frames.size(); i++) {\n            StackMapFrame frame = (StackMapFrame) frames.get(i);\n            if (frame.label == label) {\n                return frame;\n            }\n        }\n        return null;\n    }\n\n    public boolean isUnknown() {\n        return false;\n    }\n\n    public boolean isCodeAttribute() {\n        return true;\n    }\n\n    protected Attribute read(ClassReader cr, int off, int len, char[] buf, int codeOff, Label[] labels) {\n        StackMapAttribute attr = new StackMapAttribute();\n        // note that this is not the size of Code attribute\n        boolean isExtCodeSize = cr.readInt(codeOff + 4) > MAX_SIZE;\n        boolean isExtLocals = cr.readUnsignedShort(codeOff + 2) > MAX_SIZE;\n        boolean isExtStack = cr.readUnsignedShort(codeOff) > MAX_SIZE;\n        int size = 0;\n        if (isExtCodeSize) {\n            size = cr.readInt(off);\n            off += 4;\n        } else {\n            size = cr.readUnsignedShort(off);\n            off += 2;\n        }\n        for (int i = 0; i < size; i++) {\n            int offset;\n            if (isExtCodeSize) {\n                offset = cr.readInt(off);\n                off += 4;\n            } else {\n                offset = cr.readUnsignedShort(off);\n                off += 2;\n            }\n            Label label = getLabel(offset, labels);\n            List locals = new ArrayList();\n            List stack = new ArrayList();\n            off = readTypeInfo(cr, off, locals, labels, buf, isExtLocals, isExtCodeSize);\n            off = readTypeInfo(cr, off, stack, labels, buf, isExtStack, isExtCodeSize);\n            attr.frames.add(new StackMapFrame(label, locals, stack));\n        }\n        return attr;\n    }\n\n    private int readTypeInfo(ClassReader cr, int off, List info, Label[] labels, char[] buf, boolean isExt, boolean isExtCode) {\n        int n = 0;\n        if (isExt) {\n            n = cr.readInt(off);\n            off += 4;\n        } else {\n            n = cr.readUnsignedShort(off);\n            off += 2;\n        }\n        for (int j = 0; j < n; j++) {\n            int itemType = cr.readByte(off++);\n            StackMapType typeInfo = StackMapType.getTypeInfo(itemType);\n            info.add(typeInfo);\n            switch(itemType) {\n                case //\n                StackMapType.ITEM_Object:\n                    typeInfo.setObject(cr.readClass(off, buf));\n                    off += 2;\n                    break;\n                case //\n                StackMapType.ITEM_Uninitialized:\n                    int offset;\n                    if (isExtCode) {\n                        offset = cr.readInt(off);\n                        off += 4;\n                    } else {\n                        offset = cr.readUnsignedShort(off);\n                        off += 2;\n                    }\n                    typeInfo.setLabel(getLabel(offset, labels));\n                    break;\n            }\n        }\n        return off;\n    }\n\n    private void writeTypeInfo(ByteVector bv, ClassWriter cw, List info, int max) {\n        if (max > StackMapAttribute.MAX_SIZE) {\n            bv.putInt(info.size());\n        } else {\n            bv.putShort(info.size());\n        }\n        for (int j = 0; j < info.size(); j++) {\n            StackMapType typeInfo = (StackMapType) info.get(j);\n            bv.putByte(typeInfo.getType());\n            switch(typeInfo.getType()) {\n                case //\n                StackMapType.ITEM_Object:\n                    bv.putShort(cw.newClass(typeInfo.getObject()));\n                    break;\n                case //\n                StackMapType.ITEM_Uninitialized:\n                    bv.putShort(typeInfo.getLabel().getOffset());\n                    break;\n            }\n        }\n    }\n\n    private Label getLabel(int offset, Label[] labels) {\n        Label l = labels[offset];\n        if (l != null) {\n            return l;\n        }\n        return labels[offset] = new Label();\n    }\n\n    protected ByteVector write(ClassWriter cw, byte[] code, int len, int maxStack, int maxLocals) {\n        ByteVector bv = new ByteVector();\n        if (code != null && code.length > MAX_SIZE) {\n            // TODO verify value\n            bv.putInt(frames.size());\n        } else {\n            bv.putShort(frames.size());\n        }\n        for (int i = 0; i < frames.size(); i++) {\n            writeFrame((StackMapFrame) frames.get(i), cw, maxStack, maxLocals, bv);\n        }\n        return bv;\n    }\n\n    protected Label[] getLabels() {\n        HashSet labels = new HashSet();\n        for (int i = 0; i < frames.size(); i++) {\n            getFrameLabels((StackMapFrame) frames.get(i), labels);\n        }\n        return (Label[]) labels.toArray(new Label[labels.size()]);\n    }\n\n    private void writeFrame(StackMapFrame frame, ClassWriter cw, int maxStack, int maxLocals, ByteVector bv) {\n        bv.putShort(frame.label.getOffset());\n        writeTypeInfo(bv, cw, frame.locals, maxLocals);\n        writeTypeInfo(bv, cw, frame.stack, maxStack);\n    }\n\n    private void getFrameLabels(StackMapFrame frame, Set labels) {\n        labels.add(frame.label);\n        getTypeInfoLabels(labels, frame.locals);\n        getTypeInfoLabels(labels, frame.stack);\n    }\n\n    private void getTypeInfoLabels(Set labels, List info) {\n        for (Iterator it = info.iterator(); it.hasNext(); ) {\n            StackMapType typeInfo = (StackMapType) it.next();\n            if (typeInfo.getType() == StackMapType.ITEM_Uninitialized) {\n                labels.add(typeInfo.getLabel());\n            }\n        }\n    }\n\n    public String toString() {\n        StringBuffer sb = new StringBuffer(\"StackMap[\");\n        for (int i = 0; i < frames.size(); i++) {\n            sb.append('\\n').append('[').append(frames.get(i)).append(']');\n        }\n        sb.append(\"\\n]\");\n        return sb.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/attrs/StackMapAttributeTest1.java",
		"test_prompt": "// StackMapAttributeTest1.java\npackage org.objectweb.asm.jip.attrs;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport org.objectweb.asm.jip.Attribute;\nimport org.objectweb.asm.jip.ByteVector;\nimport org.objectweb.asm.jip.ClassReader;\nimport org.objectweb.asm.jip.ClassWriter;\nimport org.objectweb.asm.jip.Label;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StackMapAttribute}.\n* It contains ten unit test cases for the {@link StackMapAttribute#isCodeAttribute()} method.\n*/\nclass StackMapAttributeTest1 {"
	},
	{
		"original_code": "// StackMapType.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2005 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip.attrs;\n\nimport org.objectweb.asm.jip.Label;\n\n/**\n * Verification type info used by {@link StackMapAttribute}.\n *\n * @see <a href=\"http://www.jcp.org/en/jsr/detail?id=139\">JSR 139 : Connected\n *      Limited Device Configuration 1.1</a>\n *\n * @see \"ClassFileFormat-Java6.fm Page 138 Friday, April 15, 2005 3:22 PM\"\n *\n * @author Eugene Kuleshov\n */\npublic class StackMapType {\n\n    public static final int ITEM_Top = 0;\n\n    public static final int ITEM_Integer = 1;\n\n    public static final int ITEM_Float = 2;\n\n    public static final int ITEM_Double = 3;\n\n    public static final int ITEM_Long = 4;\n\n    public static final int ITEM_Null = 5;\n\n    public static final int ITEM_UninitializedThis = 6;\n\n    public static final int ITEM_Object = 7;\n\n    public static final int ITEM_Uninitialized = 8;\n\n    public static final String[] ITEM_NAMES = { \"Top\", \"Integer\", \"Float\", \"Double\", \"Long\", \"Null\", \"UninitializedThis\", \"Object\", \"Uninitialized\" };\n\n    private int type;\n\n    private Label offset;\n\n    private String object;\n\n    private StackMapType(int type) {\n        this.type = type;\n    }\n\n    public int getType() {\n        return type;\n    }\n\n    public static StackMapType getTypeInfo(int itemType) {\n        if (itemType < ITEM_Top || itemType > ITEM_Uninitialized) {\n            throw new IllegalArgumentException(\"\" + itemType);\n        }\n        return new StackMapType(itemType);\n    }\n\n    public void setLabel(Label offset) {\n        this.offset = offset;\n    }\n\n    public void setObject(String object) {\n        this.object = object;\n    }\n\n    public Label getLabel() {\n        return offset;\n    }\n\n    public String getObject() {\n        return object;\n    }\n\n    public String toString() {\n        StringBuffer sb = new StringBuffer(ITEM_NAMES[type]);\n        if (type == ITEM_Object) {\n            sb.append(\":\").append(object);\n        }\n        if (type == ITEM_Uninitialized) {\n            sb.append(\":L\").append(System.identityHashCode(offset));\n        }\n        return sb.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/attrs/StackMapTypeTest.java",
		"test_prompt": "// StackMapTypeTest.java\npackage org.objectweb.asm.jip.attrs;\n\nimport org.objectweb.asm.jip.Label;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StackMapType}.\n* It contains ten unit test cases for the {@link StackMapType#getTypeInfo(int)} method.\n*/\nclass StackMapTypeTest {"
	},
	{
		"original_code": "// StackMapTableAttribute.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2005 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip.attrs;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport org.objectweb.asm.jip.Attribute;\nimport org.objectweb.asm.jip.ByteVector;\nimport org.objectweb.asm.jip.ClassReader;\nimport org.objectweb.asm.jip.ClassWriter;\nimport org.objectweb.asm.jip.Label;\nimport org.objectweb.asm.jip.Opcodes;\nimport org.objectweb.asm.jip.Type;\n\n/**\n * The stack map attribute is used during the process of verification by\n * typechecking (4.11.1). <br> <br> A stack map attribute consists of zero or\n * more stack map frames. Each stack map frame specifies (either explicitly or\n * implicitly) a bytecode offset, the verification types (4.11.1) for the local\n * variables, and the verification types for the operand stack. <br> <br> The\n * type checker deals with and manipulates the expected types of a method's\n * local variables and operand stack. Throughout this section, a location refers\n * to either a single local variable or to a single operand stack entry. <br>\n * <br> We will use the terms stack frame map and type state interchangeably to\n * describe a mapping from locations in the operand stack and local variables of\n * a method to verification types. We will usually use the term stack frame map\n * when such a mapping is provided in the class file, and the term type state\n * when the mapping is inferred by the type checker. <br> <br> If a method's\n * Code attribute does not have a StackMapTable attribute, it has an implicit\n * stack map attribute. This implicit stack map attribute is equivalent to a\n * StackMapTable attribute with number_of_entries equal to zero. A method's Code\n * attribute may have at most one StackMapTable attribute, otherwise a\n * java.lang.ClassFormatError is thrown. <br> <br> The format of the stack map\n * in the class file is given below. In the following, if the length of the\n * method's byte code is 65535 or less, then uoffset represents the type u2;\n * otherwise uoffset represents the type u4. If the maximum number of local\n * variables for the method is 65535 or less, then <code>ulocalvar</code>\n * represents the type u2; otherwise ulocalvar represents the type u4. If the\n * maximum size of the operand stack is 65535 or less, then <code>ustack</code>\n * represents the type u2; otherwise ustack represents the type u4.\n *\n * <pre>\n * stack_map { // attribute StackMapTable\n *   u2 attribute_name_index;\n *   u4 attribute_length\n *   uoffset number_of_entries;\n *   stack_map_frame entries[number_of_entries];\n * }\n * </pre>\n *\n * Each stack_map_frame structure specifies the type state at a particular byte\n * code offset. Each frame type specifies (explicitly or implicitly) a value,\n * offset_delta, that is used to calulate the actual byte code offset at which\n * it applies. The byte code offset at which the frame applies is given by\n * adding <code>1 + offset_delta</code> to the <code>offset</code> of the\n * previous frame, unless the previous frame is the initial frame of the method,\n * in which case the byte code offset is <code>offset_delta</code>. <br> <br>\n * <i>Note that the length of the byte codes is not the same as the length of\n * the Code attribute. The byte codes are embedded in the Code attribute, along\n * with other information.</i> <br> <br> By using an offset delta rather than\n * the actual byte code offset we ensure, by definition, that stack map frames\n * are in the correctly sorted order. Furthermore, by consistently using the\n * formula <code>offset_delta + 1</code> for all explicit frames, we guarantee\n * the absence of duplicates. <br> <br> All frame types, even full_frame, rely\n * on the previous frame for some of their semantics. This raises the question\n * of what is the very first frame? The initial frame is implicit, and computed\n * from the method descriptor. See the Prolog code for methodInitialStacFrame.\n * <br> <br> The stack_map_frame structure consists of a one-byte tag followed\n * by zero or more bytes, giving more information, depending upon the tag. <br>\n * <br> A stack map frame may belong to one of several frame types\n *\n * <pre>\n * union stack_map_frame {\n *   same_frame;\n *   same_locals_1_stack_item_frame;\n *   chop_frame;\n *   same_frame_extended;\n *   append_frame;\n *   full_frame;\n * }\n * </pre>\n *\n * The frame type same_frame is represented by tags in the range [0-63]. If the\n * frame type is same_frame, it means the frame has exactly the same locals as\n * the previous stack map frame and that the number of stack items is zero. The\n * offset_delta value for the frame is the value of the tag field, frame_type.\n * The form of such a frame is then:\n *\n * <pre>\n * same_frame {\n *   u1 frame_type = SAME;  // 0-63\n * }\n * </pre>\n *\n * The frame type same_locals_1_stack_item_frame is represented by tags in the\n * range [64, 127]. If the frame_type is same_locals_1_stack_item_frame, it\n * means the frame has exactly the same locals as the previous stack map frame\n * and that the number of stack items is 1. The offset_delta value for the frame\n * is the value (frame_type - 64). There is a verification_type_info following\n * the frame_type for the one stack item. The form of such a frame is then:\n *\n * <pre>\n * same_locals_1_stack_item_frame {\n *   u1 frame_type = SAME_LOCALS_1_STACK_ITEM;  // 64-127\n *    verification_type_info stack[1];\n * }\n * </pre>\n *\n * Tags in the range [128-247] are reserved for future use. <br> <br> The frame\n * type chop_frame is represented by tags in the range [248-250]. If the\n * frame_type is chop_frame, it means that the current locals are the same as\n * the locals in the previous frame, except that the k last locals are absent.\n * The value of k is given by the formula 251-frame_type. <br> <br> The form of\n * such a frame is then:\n *\n * <pre>\n * chop_frame {\n *   u1 frame_type=CHOP;  // 248-250\n *   uoffset offset_delta;\n * }\n * </pre>\n *\n * The frame type same_frame_extended is represented by the tag value 251. If\n * the frame type is same_frame_extended, it means the frame has exactly the\n * same locals as the previous stack map frame and that the number of stack\n * items is zero. The form of such a frame is then:\n *\n * <pre>\n * same_frame_extended {\n *   u1 frame_type = SAME_FRAME_EXTENDED;  // 251\n *   uoffset offset_delta;\n * }\n * </pre>\n *\n * The frame type append_frame is represented by tags in the range [252-254]. If\n * the frame_type is append_frame, it means that the current locals are the same\n * as the locals in the previous frame, except that k additional locals are\n * defined. The value of k is given by the formula frame_type-251. <br> <br> The\n * form of such a frame is then:\n *\n * <pre>\n * append_frame {\n *   u1 frame_type =APPEND;  // 252-254\n *   uoffset offset_delta;\n *   verification_type_info locals[frame_type -251];\n * }\n * </pre>\n *\n * The 0th entry in locals represents the type of the first additional local\n * variable. If locals[M] represents local variable N, then locals[M+1]\n * represents local variable N+1 if locals[M] is one of Top_variable_info,\n * Integer_variable_info, Float_variable_info, Null_variable_info,\n * UninitializedThis_variable_info, Object_variable_info, or\n * Uninitialized_variable_info, otherwise locals[M+1] represents local variable\n * N+2. It is an error if, for any index i, locals[i] represents a local\n * variable whose index is greater than the maximum number of local variables\n * for the method. <br> <br> The frame type full_frame is represented by the tag\n * value 255. The form of such a frame is then:\n *\n * <pre>\n * full_frame {\n *   u1 frame_type = FULL_FRAME;  // 255\n *   uoffset offset_delta;\n *   ulocalvar number_of_locals;\n *   verification_type_info locals[number_of_locals];\n *   ustack number_of_stack_items;\n *   verification_type_info stack[number_of_stack_items];\n * }\n * </pre>\n *\n * The 0th entry in locals represents the type of local variable 0. If locals[M]\n * represents local variable N, then locals[M+1] represents local variable N+1\n * if locals[M] is one of Top_variable_info, Integer_variable_info,\n * Float_variable_info, Null_variable_info, UninitializedThis_variable_info,\n * Object_variable_info, or Uninitialized_variable_info, otherwise locals[M+1]\n * represents local variable N+2. It is an error if, for any index i, locals[i]\n * represents a local variable whose index is greater than the maximum number of\n * local variables for the method. <br> <br> The 0th entry in stack represents\n * the type of the bottom of the stack, and subsequent entries represent types\n * of stack elements closer to the top of the operand stack. We shall refer to\n * the bottom element of the stack as stack element 0, and to subsequent\n * elements as stack element 1, 2 etc. If stack[M] represents stack element N,\n * then stack[M+1] represents stack element N+1 if stack[M] is one of\n * Top_variable_info, Integer_variable_info, Float_variable_info,\n * Null_variable_info, UninitializedThis_variable_info, Object_variable_info, or\n * Uninitialized_variable_info, otherwise stack[M+1] represents stack element\n * N+2. It is an error if, for any index i, stack[i] represents a stack entry\n * whose index is greater than the maximum operand stack size for the method.\n * <br> <br> We say that an instruction in the byte code has a corresponding\n * stack map frame if the offset in the offset field of the stack map frame is\n * the same as the offset of the instruction in the byte codes. <br> <br> The\n * verification_type_info structure consists of a one-byte tag followed by zero\n * or more bytes, giving more information about the tag. Each\n * verification_type_info structure specifies the verification type of one or\n * two locations.\n *\n * <pre>\n * union verification_type_info {\n *   Top_variable_info;\n *   Integer_variable_info;\n *   Float_variable_info;\n *   Long_variable_info;\n *   Double_variable_info;\n *   Null_variable_info;\n *   UninitializedThis_variable_info;\n *   Object_variable_info;\n *   Uninitialized_variable_info;\n * }\n * </pre>\n *\n * The Top_variable_info type indicates that the local variable has the\n * verification type top (T.)\n *\n * <pre>\n * Top_variable_info {\n *   u1 tag = ITEM_Top; // 0\n * }\n * </pre>\n *\n * The Integer_variable_info type indicates that the location contains the\n * verification type int.\n *\n * <pre>\n * Integer_variable_info {\n *   u1 tag = ITEM_Integer; // 1\n * }\n * </pre>\n *\n * The Float_variable_info type indicates that the location contains the\n * verification type float.\n *\n * <pre>\n * Float_variable_info {\n *   u1 tag = ITEM_Float; // 2\n * }\n * </pre>\n *\n * The Long_variable_info type indicates that the location contains the\n * verification type long. If the location is a local variable, then:\n *\n * <ul> <li>It must not be the local variable with the highest index.</li>\n * <li>The next higher numbered local variable contains the verification type\n * T.</li> </ul>\n *\n * If the location is an operand stack entry, then:\n *\n * <ul> <li>The current location must not be the topmost location of the\n * operand stack.</li> <li>the next location closer to the top of the operand\n * stack contains the verification type T.</li> </ul>\n *\n * This structure gives the contents of two locations in the operand stack or in\n * the local variables.\n *\n * <pre>\n * Long_variable_info {\n *   u1 tag = ITEM_Long; // 4\n * }\n * </pre>\n *\n * The Double_variable_info type indicates that the location contains the\n * verification type double. If the location is a local variable, then:\n *\n * <ul> <li>It must not be the local variable with the highest index.</li>\n * <li>The next higher numbered local variable contains the verification type\n * T. <li> </ul>\n *\n * If the location is an operand stack entry, then:\n *\n * <ul> <li>The current location must not be the topmost location of the\n * operand stack.</li> <li>the next location closer to the top of the operand\n * stack contains the verification type T.</li> </ul>\n *\n * This structure gives the contents of two locations in in the operand stack or\n * in the local variables.\n *\n * <pre>\n * Double_variable_info {\n *   u1 tag = ITEM_Double; // 3\n * }\n * </pre>\n *\n * The Null_variable_info type indicates that location contains the verification\n * type null.\n *\n * <pre>\n * Null_variable_info {\n *   u1 tag = ITEM_Null; // 5\n * }\n * </pre>\n *\n * The UninitializedThis_variable_info type indicates that the location contains\n * the verification type uninitializedThis.\n *\n * <pre>\n * UninitializedThis_variable_info {\n *   u1 tag = ITEM_UninitializedThis; // 6\n * }\n * </pre>\n *\n * The Object_variable_info type indicates that the location contains an\n * instance of the class referenced by the constant pool entry.\n *\n * <pre>\n * Object_variable_info {\n *   u1 tag = ITEM_Object; // 7\n *   u2 cpool_index;\n * }\n * </pre>\n *\n * The Uninitialized_variable_info indicates that the location contains the\n * verification type uninitialized(offset). The offset item indicates the offset\n * of the new instruction that created the object being stored in the location.\n *\n * <pre>\n * Uninitialized_variable_info {\n *   u1 tag = ITEM_Uninitialized // 8\n *   uoffset offset;\n * }\n * </pre>\n *\n * @see \"ClassFileFormat-Java6.fm Page 138 Friday, April 15, 2005 3:22 PM\"\n *\n * @author Eugene Kuleshov\n */\npublic class StackMapTableAttribute extends Attribute {\n\n    /**\n     * Frame has exactly the same locals as the previous stack map frame and\n     * number of stack items is zero.\n     */\n    // to 63 (0-3f)\n    public static final int SAME_FRAME = 0;\n\n    /**\n     * Frame has exactly the same locals as the previous stack map frame and\n     * number of stack items is 1\n     */\n    // to 127\n    public static final int SAME_LOCALS_1_STACK_ITEM_FRAME = 64;\n\n    // (40-7f)\n    /**\n     * Reserved for future use\n     */\n    public static final int RESERVED = 128;\n\n    /**\n     * Frame has exactly the same locals as the previous stack map frame and\n     * number of stack items is 1. Offset is bigger then 63;\n     */\n    // f7\n    public static final int SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED = 247;\n\n    /**\n     * Frame where current locals are the same as the locals in the previous\n     * frame, except that the k last locals are absent. The value of k is given\n     * by the formula 251-frame_type.\n     */\n    // to 250 (f8-fA)\n    public static final int CHOP_FRAME = 248;\n\n    /**\n     * Frame has exactly the same locals as the previous stack map frame and\n     * number of stack items is zero. Offset is bigger then 63;\n     */\n    // fb\n    public static final int SAME_FRAME_EXTENDED = 251;\n\n    /**\n     * Frame where current locals are the same as the locals in the previous\n     * frame, except that k additional locals are defined. The value of k is\n     * given by the formula frame_type-251.\n     */\n    // to 254 // fc-fe\n    public static final int APPEND_FRAME = 252;\n\n    /**\n     * Full frame\n     */\n    // ff\n    public static final int FULL_FRAME = 255;\n\n    private static final int MAX_SHORT = 65535;\n\n    /**\n     * A <code>List</code> of <code>StackMapFrame</code> instances.\n     */\n    private List frames;\n\n    public StackMapTableAttribute() {\n        super(\"StackMapTable\");\n    }\n\n    public StackMapTableAttribute(List frames) {\n        this();\n        this.frames = frames;\n    }\n\n    public List getFrames() {\n        return frames;\n    }\n\n    public StackMapFrame getFrame(Label label) {\n        for (int i = 0; i < frames.size(); i++) {\n            StackMapFrame frame = (StackMapFrame) frames.get(i);\n            if (frame.label == label) {\n                return frame;\n            }\n        }\n        return null;\n    }\n\n    public boolean isUnknown() {\n        return false;\n    }\n\n    public boolean isCodeAttribute() {\n        return true;\n    }\n\n    protected Attribute read(ClassReader cr, int off, int len, char[] buf, int codeOff, Label[] labels) {\n        ArrayList frames = new ArrayList();\n        // note that this is not the size of Code attribute\n        boolean isExtCodeSize = cr.readInt(codeOff + 4) > MAX_SHORT;\n        boolean isExtLocals = cr.readUnsignedShort(codeOff + 2) > MAX_SHORT;\n        boolean isExtStack = cr.readUnsignedShort(codeOff) > MAX_SHORT;\n        int offset = 0;\n        int methodOff = getMethodOff(cr, codeOff, buf);\n        StackMapFrame frame = new StackMapFrame(getLabel(offset, labels), // owner\n        calculateLocals(// owner\n        cr.readClass(cr.header + 2, buf), // method access\n        cr.readUnsignedShort(methodOff), // method name\n        cr.readUTF8(methodOff + 2, buf), // method desc\n        cr.readUTF8(methodOff + 4, buf)), Collections.EMPTY_LIST);\n        frames.add(frame);\n        // System.err.println( cr.readUTF8( methodOff + 2, buf));\n        // System.err.println( offset +\" delta:\" + 0 +\" : \"+ frame);\n        int size;\n        if (isExtCodeSize) {\n            size = cr.readInt(off);\n            off += 4;\n        } else {\n            size = cr.readUnsignedShort(off);\n            off += 2;\n        }\n        for (; size > 0; size--) {\n            // & 0xff;\n            int tag = cr.readByte(off);\n            off++;\n            List stack;\n            List locals;\n            int offsetDelta;\n            if (tag < SAME_LOCALS_1_STACK_ITEM_FRAME) {\n                // SAME_FRAME\n                offsetDelta = tag;\n                locals = new ArrayList(frame.locals);\n                stack = Collections.EMPTY_LIST;\n            } else if (tag < RESERVED) {\n                // SAME_LOCALS_1_STACK_ITEM_FRAME\n                offsetDelta = tag - SAME_LOCALS_1_STACK_ITEM_FRAME;\n                locals = new ArrayList(frame.locals);\n                stack = new ArrayList();\n                // read verification_type_info stack[1];\n                off = readType(stack, isExtCodeSize, cr, off, labels, buf);\n            } else {\n                if (isExtCodeSize) {\n                    offsetDelta = cr.readInt(off);\n                    off += 4;\n                } else {\n                    offsetDelta = cr.readUnsignedShort(off);\n                    off += 2;\n                }\n                if (tag == SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {\n                    // SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED\n                    locals = new ArrayList(frame.locals);\n                    stack = new ArrayList();\n                    // read verification_type_info stack[1];\n                    off = readType(stack, isExtCodeSize, cr, off, labels, buf);\n                } else if (tag >= CHOP_FRAME && tag < SAME_FRAME_EXTENDED) {\n                    // CHOP_FRAME\n                    stack = Collections.EMPTY_LIST;\n                    int k = SAME_FRAME_EXTENDED - tag;\n                    // copy locals from prev frame and chop last k\n                    locals = new ArrayList(frame.locals.subList(0, frame.locals.size() - k));\n                } else if (tag == SAME_FRAME_EXTENDED) {\n                    // SAME_FRAME_EXTENDED\n                    stack = Collections.EMPTY_LIST;\n                    locals = new ArrayList(frame.locals);\n                } else if (/* tag>=APPEND && */\n                tag < FULL_FRAME) {\n                    // APPEND_FRAME\n                    stack = Collections.EMPTY_LIST;\n                    // copy locals from prev frame and append new k\n                    locals = new ArrayList(frame.locals);\n                    for (int k = tag - SAME_FRAME_EXTENDED; k > 0; k--) {\n                        off = readType(locals, isExtCodeSize, cr, off, labels, buf);\n                    }\n                } else if (tag == FULL_FRAME) {\n                    // FULL_FRAME\n                    // read verification_type_info locals[number_of_locals];\n                    locals = new ArrayList();\n                    off = readTypes(locals, isExtLocals, isExtCodeSize, cr, off, labels, buf);\n                    // read verification_type_info stack[number_of_stack_items];\n                    stack = new ArrayList();\n                    off = readTypes(stack, isExtStack, isExtCodeSize, cr, off, labels, buf);\n                } else {\n                    throw new RuntimeException(\"Unknown frame type \" + tag + \" after offset \" + offset);\n                }\n            }\n            offset += offsetDelta;\n            Label offsetLabel = getLabel(offset, labels);\n            frame = new StackMapFrame(offsetLabel, locals, stack);\n            frames.add(frame);\n            // System.err.println( tag +\" \" + offset +\" delta:\" + offsetDelta +\n            // \" frameType:\"+ frameType+\" : \"+ frame);\n            offset++;\n        }\n        return new StackMapTableAttribute(frames);\n    }\n\n    protected ByteVector write(ClassWriter cw, byte[] code, int len, int maxStack, int maxLocals) {\n        ByteVector bv = new ByteVector();\n        // TODO verify this value (MAX_SHORT)\n        boolean isExtCodeSize = code != null && code.length > MAX_SHORT;\n        writeSize(frames.size() - 1, bv, isExtCodeSize);\n        if (frames.size() < 2) {\n            return bv;\n        }\n        boolean isExtLocals = maxLocals > MAX_SHORT;\n        boolean isExtStack = maxStack > MAX_SHORT;\n        // skip the first frame\n        StackMapFrame frame = (StackMapFrame) frames.get(0);\n        List locals = frame.locals;\n        int offset = frame.label.getOffset();\n        for (int i = 1; i < frames.size(); i++) {\n            frame = (StackMapFrame) frames.get(i);\n            List clocals = frame.locals;\n            List cstack = frame.stack;\n            int coffset = frame.label.getOffset();\n            int clocalsSize = clocals.size();\n            int cstackSize = cstack.size();\n            int localsSize = locals.size();\n            int delta = coffset - offset;\n            int type = FULL_FRAME;\n            int k = 0;\n            if (cstackSize == 0) {\n                k = clocalsSize - localsSize;\n                switch(k) {\n                    case -3:\n                    case -2:\n                    case -1:\n                        // CHOP or FULL\n                        type = CHOP_FRAME;\n                        // for full_frame check\n                        localsSize = clocalsSize;\n                        break;\n                    case 0:\n                        // SAME, SAME_EXTENDED or FULL\n                        type = delta < 64 ? SAME_FRAME : SAME_FRAME_EXTENDED;\n                        break;\n                    case 1:\n                    case 2:\n                    case 3:\n                        // APPEND or FULL\n                        type = APPEND_FRAME;\n                        break;\n                }\n            } else if (localsSize == clocalsSize && cstackSize == 1) {\n                // SAME_LOCAL_1_STACK or FULL\n                type = delta < 63 ? SAME_LOCALS_1_STACK_ITEM_FRAME : SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED;\n            }\n            if (type != FULL_FRAME) {\n                // verify if stack and locals are the same\n                for (int j = 0; j < localsSize && type != FULL_FRAME; j++) {\n                    if (!locals.get(j).equals(clocals.get(j)))\n                        type = FULL_FRAME;\n                }\n            }\n            switch(type) {\n                case SAME_FRAME:\n                    bv.putByte(delta);\n                    break;\n                case SAME_LOCALS_1_STACK_ITEM_FRAME:\n                    bv.putByte(SAME_LOCALS_1_STACK_ITEM_FRAME + delta);\n                    writeTypeInfos(bv, cw, cstack, 0, 1);\n                    break;\n                case SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED:\n                    bv.putByte(SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED);\n                    writeSize(delta, bv, isExtCodeSize);\n                    writeTypeInfos(bv, cw, cstack, 0, 1);\n                    break;\n                case SAME_FRAME_EXTENDED:\n                    bv.putByte(SAME_FRAME_EXTENDED);\n                    writeSize(delta, bv, isExtCodeSize);\n                    break;\n                case CHOP_FRAME:\n                    // negative k\n                    bv.putByte(SAME_FRAME_EXTENDED + k);\n                    writeSize(delta, bv, isExtCodeSize);\n                    break;\n                case APPEND_FRAME:\n                    // positive k\n                    bv.putByte(SAME_FRAME_EXTENDED + k);\n                    writeSize(delta, bv, isExtCodeSize);\n                    writeTypeInfos(bv, cw, clocals, clocalsSize - 1, clocalsSize);\n                    break;\n                case FULL_FRAME:\n                    bv.putByte(FULL_FRAME);\n                    writeSize(delta, bv, isExtCodeSize);\n                    writeSize(clocalsSize, bv, isExtLocals);\n                    writeTypeInfos(bv, cw, clocals, 0, clocalsSize);\n                    writeSize(cstackSize, bv, isExtStack);\n                    writeTypeInfos(bv, cw, cstack, 0, cstackSize);\n                    break;\n                default:\n                    throw new RuntimeException();\n            }\n            // compensating non first offset\n            offset = coffset + 1;\n            locals = clocals;\n        }\n        return bv;\n    }\n\n    private void writeSize(int delta, ByteVector bv, boolean isExt) {\n        if (isExt) {\n            bv.putInt(delta);\n        } else {\n            bv.putShort(delta);\n        }\n    }\n\n    private void writeTypeInfos(ByteVector bv, ClassWriter cw, List info, int start, int end) {\n        for (int j = start; j < end; j++) {\n            StackMapType typeInfo = (StackMapType) info.get(j);\n            bv.putByte(typeInfo.getType());\n            switch(typeInfo.getType()) {\n                case //\n                StackMapType.ITEM_Object:\n                    bv.putShort(cw.newClass(typeInfo.getObject()));\n                    break;\n                case //\n                StackMapType.ITEM_Uninitialized:\n                    bv.putShort(typeInfo.getLabel().getOffset());\n                    break;\n            }\n        }\n    }\n\n    public static int getMethodOff(ClassReader cr, int codeOff, char[] buf) {\n        int off = cr.header + 6;\n        int interfacesCount = cr.readUnsignedShort(off);\n        off += 2 + interfacesCount * 2;\n        int fieldsCount = cr.readUnsignedShort(off);\n        off += 2;\n        for (; fieldsCount > 0; --fieldsCount) {\n            // field attributes\n            int attrCount = cr.readUnsignedShort(off + 6);\n            off += 8;\n            for (; attrCount > 0; --attrCount) {\n                off += 6 + cr.readInt(off + 2);\n            }\n        }\n        int methodsCount = cr.readUnsignedShort(off);\n        off += 2;\n        for (; methodsCount > 0; --methodsCount) {\n            int methodOff = off;\n            // method attributes\n            int attrCount = cr.readUnsignedShort(off + 6);\n            off += 8;\n            for (; attrCount > 0; --attrCount) {\n                String attrName = cr.readUTF8(off, buf);\n                off += 6;\n                if (attrName.equals(\"Code\")) {\n                    if (codeOff == off) {\n                        return methodOff;\n                    }\n                }\n                off += cr.readInt(off - 4);\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Use method signature and access flags to resolve initial locals state.\n     *\n     * @param className name of the method's owner class.\n     * @param access access flags of the method.\n     * @param methodName name of the method.\n     * @param methodDesc descriptor of the method.\n     * @return list of <code>StackMapType</code> instances representing locals\n     *         for an initial frame.\n     */\n    public static List calculateLocals(String className, int access, String methodName, String methodDesc) {\n        List locals = new ArrayList();\n        // TODO\n        if (\"<init>\".equals(methodName) && !className.equals(\"java/lang/Object\")) {\n            StackMapType typeInfo = StackMapType.getTypeInfo(StackMapType.ITEM_UninitializedThis);\n            // this\n            typeInfo.setObject(className);\n            locals.add(typeInfo);\n        } else if ((access & Opcodes.ACC_STATIC) == 0) {\n            StackMapType typeInfo = StackMapType.getTypeInfo(StackMapType.ITEM_Object);\n            // this\n            typeInfo.setObject(className);\n            locals.add(typeInfo);\n        }\n        Type[] types = Type.getArgumentTypes(methodDesc);\n        for (int i = 0; i < types.length; i++) {\n            Type t = types[i];\n            StackMapType smt;\n            switch(t.getSort()) {\n                case Type.LONG:\n                    smt = StackMapType.getTypeInfo(StackMapType.ITEM_Long);\n                    break;\n                case Type.DOUBLE:\n                    smt = StackMapType.getTypeInfo(StackMapType.ITEM_Double);\n                    break;\n                case Type.FLOAT:\n                    smt = StackMapType.getTypeInfo(StackMapType.ITEM_Float);\n                    break;\n                case Type.ARRAY:\n                case Type.OBJECT:\n                    smt = StackMapType.getTypeInfo(StackMapType.ITEM_Object);\n                    // TODO verify name\n                    smt.setObject(t.getDescriptor());\n                    break;\n                default:\n                    smt = StackMapType.getTypeInfo(StackMapType.ITEM_Integer);\n                    break;\n            }\n        }\n        return locals;\n    }\n\n    private int readTypes(List info, boolean isExt, boolean isExtCodeSize, ClassReader cr, int off, Label[] labels, char[] buf) {\n        int n = 0;\n        if (isExt) {\n            n = cr.readInt(off);\n            off += 4;\n        } else {\n            n = cr.readUnsignedShort(off);\n            off += 2;\n        }\n        for (; n > 0; n--) {\n            off = readType(info, isExtCodeSize, cr, off, labels, buf);\n        }\n        return off;\n    }\n\n    private int readType(List info, boolean isExtCodeSize, ClassReader cr, int off, Label[] labels, char[] buf) {\n        int itemType = cr.readByte(off++);\n        StackMapType typeInfo = StackMapType.getTypeInfo(itemType);\n        info.add(typeInfo);\n        switch(itemType) {\n            // case StackMapType.ITEM_Long: //\n            // case StackMapType.ITEM_Double: //\n            // info.add(StackMapType.getTypeInfo(StackMapType.ITEM_Top));\n            // break;\n            case //\n            StackMapType.ITEM_Object:\n                typeInfo.setObject(cr.readClass(off, buf));\n                off += 2;\n                break;\n            case //\n            StackMapType.ITEM_Uninitialized:\n                int offset;\n                if (isExtCodeSize) {\n                    offset = cr.readInt(off);\n                    off += 4;\n                } else {\n                    offset = cr.readUnsignedShort(off);\n                    off += 2;\n                }\n                typeInfo.setLabel(getLabel(offset, labels));\n                break;\n        }\n        return off;\n    }\n\n    private Label getLabel(int offset, Label[] labels) {\n        Label l = labels[offset];\n        if (l != null) {\n            return l;\n        }\n        return labels[offset] = new Label();\n    }\n\n    public String toString() {\n        StringBuffer sb = new StringBuffer(\"StackMapTable[\");\n        for (int i = 0; i < frames.size(); i++) {\n            sb.append('\\n').append('[').append(frames.get(i)).append(']');\n        }\n        sb.append(\"\\n]\");\n        return sb.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/attrs/StackMapTableAttributeTest0.java",
		"test_prompt": "// StackMapTableAttributeTest0.java\npackage org.objectweb.asm.jip.attrs;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport org.objectweb.asm.jip.Attribute;\nimport org.objectweb.asm.jip.ByteVector;\nimport org.objectweb.asm.jip.ClassReader;\nimport org.objectweb.asm.jip.ClassWriter;\nimport org.objectweb.asm.jip.Label;\nimport org.objectweb.asm.jip.Opcodes;\nimport org.objectweb.asm.jip.Type;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StackMapTableAttribute}.\n* It contains ten unit test cases for the {@link StackMapTableAttribute#isUnknown()} method.\n*/\nclass StackMapTableAttributeTest0 {"
	},
	{
		"original_code": "// StackMapTableAttribute.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2005 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip.attrs;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport org.objectweb.asm.jip.Attribute;\nimport org.objectweb.asm.jip.ByteVector;\nimport org.objectweb.asm.jip.ClassReader;\nimport org.objectweb.asm.jip.ClassWriter;\nimport org.objectweb.asm.jip.Label;\nimport org.objectweb.asm.jip.Opcodes;\nimport org.objectweb.asm.jip.Type;\n\n/**\n * The stack map attribute is used during the process of verification by\n * typechecking (4.11.1). <br> <br> A stack map attribute consists of zero or\n * more stack map frames. Each stack map frame specifies (either explicitly or\n * implicitly) a bytecode offset, the verification types (4.11.1) for the local\n * variables, and the verification types for the operand stack. <br> <br> The\n * type checker deals with and manipulates the expected types of a method's\n * local variables and operand stack. Throughout this section, a location refers\n * to either a single local variable or to a single operand stack entry. <br>\n * <br> We will use the terms stack frame map and type state interchangeably to\n * describe a mapping from locations in the operand stack and local variables of\n * a method to verification types. We will usually use the term stack frame map\n * when such a mapping is provided in the class file, and the term type state\n * when the mapping is inferred by the type checker. <br> <br> If a method's\n * Code attribute does not have a StackMapTable attribute, it has an implicit\n * stack map attribute. This implicit stack map attribute is equivalent to a\n * StackMapTable attribute with number_of_entries equal to zero. A method's Code\n * attribute may have at most one StackMapTable attribute, otherwise a\n * java.lang.ClassFormatError is thrown. <br> <br> The format of the stack map\n * in the class file is given below. In the following, if the length of the\n * method's byte code is 65535 or less, then uoffset represents the type u2;\n * otherwise uoffset represents the type u4. If the maximum number of local\n * variables for the method is 65535 or less, then <code>ulocalvar</code>\n * represents the type u2; otherwise ulocalvar represents the type u4. If the\n * maximum size of the operand stack is 65535 or less, then <code>ustack</code>\n * represents the type u2; otherwise ustack represents the type u4.\n *\n * <pre>\n * stack_map { // attribute StackMapTable\n *   u2 attribute_name_index;\n *   u4 attribute_length\n *   uoffset number_of_entries;\n *   stack_map_frame entries[number_of_entries];\n * }\n * </pre>\n *\n * Each stack_map_frame structure specifies the type state at a particular byte\n * code offset. Each frame type specifies (explicitly or implicitly) a value,\n * offset_delta, that is used to calulate the actual byte code offset at which\n * it applies. The byte code offset at which the frame applies is given by\n * adding <code>1 + offset_delta</code> to the <code>offset</code> of the\n * previous frame, unless the previous frame is the initial frame of the method,\n * in which case the byte code offset is <code>offset_delta</code>. <br> <br>\n * <i>Note that the length of the byte codes is not the same as the length of\n * the Code attribute. The byte codes are embedded in the Code attribute, along\n * with other information.</i> <br> <br> By using an offset delta rather than\n * the actual byte code offset we ensure, by definition, that stack map frames\n * are in the correctly sorted order. Furthermore, by consistently using the\n * formula <code>offset_delta + 1</code> for all explicit frames, we guarantee\n * the absence of duplicates. <br> <br> All frame types, even full_frame, rely\n * on the previous frame for some of their semantics. This raises the question\n * of what is the very first frame? The initial frame is implicit, and computed\n * from the method descriptor. See the Prolog code for methodInitialStacFrame.\n * <br> <br> The stack_map_frame structure consists of a one-byte tag followed\n * by zero or more bytes, giving more information, depending upon the tag. <br>\n * <br> A stack map frame may belong to one of several frame types\n *\n * <pre>\n * union stack_map_frame {\n *   same_frame;\n *   same_locals_1_stack_item_frame;\n *   chop_frame;\n *   same_frame_extended;\n *   append_frame;\n *   full_frame;\n * }\n * </pre>\n *\n * The frame type same_frame is represented by tags in the range [0-63]. If the\n * frame type is same_frame, it means the frame has exactly the same locals as\n * the previous stack map frame and that the number of stack items is zero. The\n * offset_delta value for the frame is the value of the tag field, frame_type.\n * The form of such a frame is then:\n *\n * <pre>\n * same_frame {\n *   u1 frame_type = SAME;  // 0-63\n * }\n * </pre>\n *\n * The frame type same_locals_1_stack_item_frame is represented by tags in the\n * range [64, 127]. If the frame_type is same_locals_1_stack_item_frame, it\n * means the frame has exactly the same locals as the previous stack map frame\n * and that the number of stack items is 1. The offset_delta value for the frame\n * is the value (frame_type - 64). There is a verification_type_info following\n * the frame_type for the one stack item. The form of such a frame is then:\n *\n * <pre>\n * same_locals_1_stack_item_frame {\n *   u1 frame_type = SAME_LOCALS_1_STACK_ITEM;  // 64-127\n *    verification_type_info stack[1];\n * }\n * </pre>\n *\n * Tags in the range [128-247] are reserved for future use. <br> <br> The frame\n * type chop_frame is represented by tags in the range [248-250]. If the\n * frame_type is chop_frame, it means that the current locals are the same as\n * the locals in the previous frame, except that the k last locals are absent.\n * The value of k is given by the formula 251-frame_type. <br> <br> The form of\n * such a frame is then:\n *\n * <pre>\n * chop_frame {\n *   u1 frame_type=CHOP;  // 248-250\n *   uoffset offset_delta;\n * }\n * </pre>\n *\n * The frame type same_frame_extended is represented by the tag value 251. If\n * the frame type is same_frame_extended, it means the frame has exactly the\n * same locals as the previous stack map frame and that the number of stack\n * items is zero. The form of such a frame is then:\n *\n * <pre>\n * same_frame_extended {\n *   u1 frame_type = SAME_FRAME_EXTENDED;  // 251\n *   uoffset offset_delta;\n * }\n * </pre>\n *\n * The frame type append_frame is represented by tags in the range [252-254]. If\n * the frame_type is append_frame, it means that the current locals are the same\n * as the locals in the previous frame, except that k additional locals are\n * defined. The value of k is given by the formula frame_type-251. <br> <br> The\n * form of such a frame is then:\n *\n * <pre>\n * append_frame {\n *   u1 frame_type =APPEND;  // 252-254\n *   uoffset offset_delta;\n *   verification_type_info locals[frame_type -251];\n * }\n * </pre>\n *\n * The 0th entry in locals represents the type of the first additional local\n * variable. If locals[M] represents local variable N, then locals[M+1]\n * represents local variable N+1 if locals[M] is one of Top_variable_info,\n * Integer_variable_info, Float_variable_info, Null_variable_info,\n * UninitializedThis_variable_info, Object_variable_info, or\n * Uninitialized_variable_info, otherwise locals[M+1] represents local variable\n * N+2. It is an error if, for any index i, locals[i] represents a local\n * variable whose index is greater than the maximum number of local variables\n * for the method. <br> <br> The frame type full_frame is represented by the tag\n * value 255. The form of such a frame is then:\n *\n * <pre>\n * full_frame {\n *   u1 frame_type = FULL_FRAME;  // 255\n *   uoffset offset_delta;\n *   ulocalvar number_of_locals;\n *   verification_type_info locals[number_of_locals];\n *   ustack number_of_stack_items;\n *   verification_type_info stack[number_of_stack_items];\n * }\n * </pre>\n *\n * The 0th entry in locals represents the type of local variable 0. If locals[M]\n * represents local variable N, then locals[M+1] represents local variable N+1\n * if locals[M] is one of Top_variable_info, Integer_variable_info,\n * Float_variable_info, Null_variable_info, UninitializedThis_variable_info,\n * Object_variable_info, or Uninitialized_variable_info, otherwise locals[M+1]\n * represents local variable N+2. It is an error if, for any index i, locals[i]\n * represents a local variable whose index is greater than the maximum number of\n * local variables for the method. <br> <br> The 0th entry in stack represents\n * the type of the bottom of the stack, and subsequent entries represent types\n * of stack elements closer to the top of the operand stack. We shall refer to\n * the bottom element of the stack as stack element 0, and to subsequent\n * elements as stack element 1, 2 etc. If stack[M] represents stack element N,\n * then stack[M+1] represents stack element N+1 if stack[M] is one of\n * Top_variable_info, Integer_variable_info, Float_variable_info,\n * Null_variable_info, UninitializedThis_variable_info, Object_variable_info, or\n * Uninitialized_variable_info, otherwise stack[M+1] represents stack element\n * N+2. It is an error if, for any index i, stack[i] represents a stack entry\n * whose index is greater than the maximum operand stack size for the method.\n * <br> <br> We say that an instruction in the byte code has a corresponding\n * stack map frame if the offset in the offset field of the stack map frame is\n * the same as the offset of the instruction in the byte codes. <br> <br> The\n * verification_type_info structure consists of a one-byte tag followed by zero\n * or more bytes, giving more information about the tag. Each\n * verification_type_info structure specifies the verification type of one or\n * two locations.\n *\n * <pre>\n * union verification_type_info {\n *   Top_variable_info;\n *   Integer_variable_info;\n *   Float_variable_info;\n *   Long_variable_info;\n *   Double_variable_info;\n *   Null_variable_info;\n *   UninitializedThis_variable_info;\n *   Object_variable_info;\n *   Uninitialized_variable_info;\n * }\n * </pre>\n *\n * The Top_variable_info type indicates that the local variable has the\n * verification type top (T.)\n *\n * <pre>\n * Top_variable_info {\n *   u1 tag = ITEM_Top; // 0\n * }\n * </pre>\n *\n * The Integer_variable_info type indicates that the location contains the\n * verification type int.\n *\n * <pre>\n * Integer_variable_info {\n *   u1 tag = ITEM_Integer; // 1\n * }\n * </pre>\n *\n * The Float_variable_info type indicates that the location contains the\n * verification type float.\n *\n * <pre>\n * Float_variable_info {\n *   u1 tag = ITEM_Float; // 2\n * }\n * </pre>\n *\n * The Long_variable_info type indicates that the location contains the\n * verification type long. If the location is a local variable, then:\n *\n * <ul> <li>It must not be the local variable with the highest index.</li>\n * <li>The next higher numbered local variable contains the verification type\n * T.</li> </ul>\n *\n * If the location is an operand stack entry, then:\n *\n * <ul> <li>The current location must not be the topmost location of the\n * operand stack.</li> <li>the next location closer to the top of the operand\n * stack contains the verification type T.</li> </ul>\n *\n * This structure gives the contents of two locations in the operand stack or in\n * the local variables.\n *\n * <pre>\n * Long_variable_info {\n *   u1 tag = ITEM_Long; // 4\n * }\n * </pre>\n *\n * The Double_variable_info type indicates that the location contains the\n * verification type double. If the location is a local variable, then:\n *\n * <ul> <li>It must not be the local variable with the highest index.</li>\n * <li>The next higher numbered local variable contains the verification type\n * T. <li> </ul>\n *\n * If the location is an operand stack entry, then:\n *\n * <ul> <li>The current location must not be the topmost location of the\n * operand stack.</li> <li>the next location closer to the top of the operand\n * stack contains the verification type T.</li> </ul>\n *\n * This structure gives the contents of two locations in in the operand stack or\n * in the local variables.\n *\n * <pre>\n * Double_variable_info {\n *   u1 tag = ITEM_Double; // 3\n * }\n * </pre>\n *\n * The Null_variable_info type indicates that location contains the verification\n * type null.\n *\n * <pre>\n * Null_variable_info {\n *   u1 tag = ITEM_Null; // 5\n * }\n * </pre>\n *\n * The UninitializedThis_variable_info type indicates that the location contains\n * the verification type uninitializedThis.\n *\n * <pre>\n * UninitializedThis_variable_info {\n *   u1 tag = ITEM_UninitializedThis; // 6\n * }\n * </pre>\n *\n * The Object_variable_info type indicates that the location contains an\n * instance of the class referenced by the constant pool entry.\n *\n * <pre>\n * Object_variable_info {\n *   u1 tag = ITEM_Object; // 7\n *   u2 cpool_index;\n * }\n * </pre>\n *\n * The Uninitialized_variable_info indicates that the location contains the\n * verification type uninitialized(offset). The offset item indicates the offset\n * of the new instruction that created the object being stored in the location.\n *\n * <pre>\n * Uninitialized_variable_info {\n *   u1 tag = ITEM_Uninitialized // 8\n *   uoffset offset;\n * }\n * </pre>\n *\n * @see \"ClassFileFormat-Java6.fm Page 138 Friday, April 15, 2005 3:22 PM\"\n *\n * @author Eugene Kuleshov\n */\npublic class StackMapTableAttribute extends Attribute {\n\n    /**\n     * Frame has exactly the same locals as the previous stack map frame and\n     * number of stack items is zero.\n     */\n    // to 63 (0-3f)\n    public static final int SAME_FRAME = 0;\n\n    /**\n     * Frame has exactly the same locals as the previous stack map frame and\n     * number of stack items is 1\n     */\n    // to 127\n    public static final int SAME_LOCALS_1_STACK_ITEM_FRAME = 64;\n\n    // (40-7f)\n    /**\n     * Reserved for future use\n     */\n    public static final int RESERVED = 128;\n\n    /**\n     * Frame has exactly the same locals as the previous stack map frame and\n     * number of stack items is 1. Offset is bigger then 63;\n     */\n    // f7\n    public static final int SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED = 247;\n\n    /**\n     * Frame where current locals are the same as the locals in the previous\n     * frame, except that the k last locals are absent. The value of k is given\n     * by the formula 251-frame_type.\n     */\n    // to 250 (f8-fA)\n    public static final int CHOP_FRAME = 248;\n\n    /**\n     * Frame has exactly the same locals as the previous stack map frame and\n     * number of stack items is zero. Offset is bigger then 63;\n     */\n    // fb\n    public static final int SAME_FRAME_EXTENDED = 251;\n\n    /**\n     * Frame where current locals are the same as the locals in the previous\n     * frame, except that k additional locals are defined. The value of k is\n     * given by the formula frame_type-251.\n     */\n    // to 254 // fc-fe\n    public static final int APPEND_FRAME = 252;\n\n    /**\n     * Full frame\n     */\n    // ff\n    public static final int FULL_FRAME = 255;\n\n    private static final int MAX_SHORT = 65535;\n\n    /**\n     * A <code>List</code> of <code>StackMapFrame</code> instances.\n     */\n    private List frames;\n\n    public StackMapTableAttribute() {\n        super(\"StackMapTable\");\n    }\n\n    public StackMapTableAttribute(List frames) {\n        this();\n        this.frames = frames;\n    }\n\n    public List getFrames() {\n        return frames;\n    }\n\n    public StackMapFrame getFrame(Label label) {\n        for (int i = 0; i < frames.size(); i++) {\n            StackMapFrame frame = (StackMapFrame) frames.get(i);\n            if (frame.label == label) {\n                return frame;\n            }\n        }\n        return null;\n    }\n\n    public boolean isUnknown() {\n        return false;\n    }\n\n    public boolean isCodeAttribute() {\n        return true;\n    }\n\n    protected Attribute read(ClassReader cr, int off, int len, char[] buf, int codeOff, Label[] labels) {\n        ArrayList frames = new ArrayList();\n        // note that this is not the size of Code attribute\n        boolean isExtCodeSize = cr.readInt(codeOff + 4) > MAX_SHORT;\n        boolean isExtLocals = cr.readUnsignedShort(codeOff + 2) > MAX_SHORT;\n        boolean isExtStack = cr.readUnsignedShort(codeOff) > MAX_SHORT;\n        int offset = 0;\n        int methodOff = getMethodOff(cr, codeOff, buf);\n        StackMapFrame frame = new StackMapFrame(getLabel(offset, labels), // owner\n        calculateLocals(// owner\n        cr.readClass(cr.header + 2, buf), // method access\n        cr.readUnsignedShort(methodOff), // method name\n        cr.readUTF8(methodOff + 2, buf), // method desc\n        cr.readUTF8(methodOff + 4, buf)), Collections.EMPTY_LIST);\n        frames.add(frame);\n        // System.err.println( cr.readUTF8( methodOff + 2, buf));\n        // System.err.println( offset +\" delta:\" + 0 +\" : \"+ frame);\n        int size;\n        if (isExtCodeSize) {\n            size = cr.readInt(off);\n            off += 4;\n        } else {\n            size = cr.readUnsignedShort(off);\n            off += 2;\n        }\n        for (; size > 0; size--) {\n            // & 0xff;\n            int tag = cr.readByte(off);\n            off++;\n            List stack;\n            List locals;\n            int offsetDelta;\n            if (tag < SAME_LOCALS_1_STACK_ITEM_FRAME) {\n                // SAME_FRAME\n                offsetDelta = tag;\n                locals = new ArrayList(frame.locals);\n                stack = Collections.EMPTY_LIST;\n            } else if (tag < RESERVED) {\n                // SAME_LOCALS_1_STACK_ITEM_FRAME\n                offsetDelta = tag - SAME_LOCALS_1_STACK_ITEM_FRAME;\n                locals = new ArrayList(frame.locals);\n                stack = new ArrayList();\n                // read verification_type_info stack[1];\n                off = readType(stack, isExtCodeSize, cr, off, labels, buf);\n            } else {\n                if (isExtCodeSize) {\n                    offsetDelta = cr.readInt(off);\n                    off += 4;\n                } else {\n                    offsetDelta = cr.readUnsignedShort(off);\n                    off += 2;\n                }\n                if (tag == SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {\n                    // SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED\n                    locals = new ArrayList(frame.locals);\n                    stack = new ArrayList();\n                    // read verification_type_info stack[1];\n                    off = readType(stack, isExtCodeSize, cr, off, labels, buf);\n                } else if (tag >= CHOP_FRAME && tag < SAME_FRAME_EXTENDED) {\n                    // CHOP_FRAME\n                    stack = Collections.EMPTY_LIST;\n                    int k = SAME_FRAME_EXTENDED - tag;\n                    // copy locals from prev frame and chop last k\n                    locals = new ArrayList(frame.locals.subList(0, frame.locals.size() - k));\n                } else if (tag == SAME_FRAME_EXTENDED) {\n                    // SAME_FRAME_EXTENDED\n                    stack = Collections.EMPTY_LIST;\n                    locals = new ArrayList(frame.locals);\n                } else if (/* tag>=APPEND && */\n                tag < FULL_FRAME) {\n                    // APPEND_FRAME\n                    stack = Collections.EMPTY_LIST;\n                    // copy locals from prev frame and append new k\n                    locals = new ArrayList(frame.locals);\n                    for (int k = tag - SAME_FRAME_EXTENDED; k > 0; k--) {\n                        off = readType(locals, isExtCodeSize, cr, off, labels, buf);\n                    }\n                } else if (tag == FULL_FRAME) {\n                    // FULL_FRAME\n                    // read verification_type_info locals[number_of_locals];\n                    locals = new ArrayList();\n                    off = readTypes(locals, isExtLocals, isExtCodeSize, cr, off, labels, buf);\n                    // read verification_type_info stack[number_of_stack_items];\n                    stack = new ArrayList();\n                    off = readTypes(stack, isExtStack, isExtCodeSize, cr, off, labels, buf);\n                } else {\n                    throw new RuntimeException(\"Unknown frame type \" + tag + \" after offset \" + offset);\n                }\n            }\n            offset += offsetDelta;\n            Label offsetLabel = getLabel(offset, labels);\n            frame = new StackMapFrame(offsetLabel, locals, stack);\n            frames.add(frame);\n            // System.err.println( tag +\" \" + offset +\" delta:\" + offsetDelta +\n            // \" frameType:\"+ frameType+\" : \"+ frame);\n            offset++;\n        }\n        return new StackMapTableAttribute(frames);\n    }\n\n    protected ByteVector write(ClassWriter cw, byte[] code, int len, int maxStack, int maxLocals) {\n        ByteVector bv = new ByteVector();\n        // TODO verify this value (MAX_SHORT)\n        boolean isExtCodeSize = code != null && code.length > MAX_SHORT;\n        writeSize(frames.size() - 1, bv, isExtCodeSize);\n        if (frames.size() < 2) {\n            return bv;\n        }\n        boolean isExtLocals = maxLocals > MAX_SHORT;\n        boolean isExtStack = maxStack > MAX_SHORT;\n        // skip the first frame\n        StackMapFrame frame = (StackMapFrame) frames.get(0);\n        List locals = frame.locals;\n        int offset = frame.label.getOffset();\n        for (int i = 1; i < frames.size(); i++) {\n            frame = (StackMapFrame) frames.get(i);\n            List clocals = frame.locals;\n            List cstack = frame.stack;\n            int coffset = frame.label.getOffset();\n            int clocalsSize = clocals.size();\n            int cstackSize = cstack.size();\n            int localsSize = locals.size();\n            int delta = coffset - offset;\n            int type = FULL_FRAME;\n            int k = 0;\n            if (cstackSize == 0) {\n                k = clocalsSize - localsSize;\n                switch(k) {\n                    case -3:\n                    case -2:\n                    case -1:\n                        // CHOP or FULL\n                        type = CHOP_FRAME;\n                        // for full_frame check\n                        localsSize = clocalsSize;\n                        break;\n                    case 0:\n                        // SAME, SAME_EXTENDED or FULL\n                        type = delta < 64 ? SAME_FRAME : SAME_FRAME_EXTENDED;\n                        break;\n                    case 1:\n                    case 2:\n                    case 3:\n                        // APPEND or FULL\n                        type = APPEND_FRAME;\n                        break;\n                }\n            } else if (localsSize == clocalsSize && cstackSize == 1) {\n                // SAME_LOCAL_1_STACK or FULL\n                type = delta < 63 ? SAME_LOCALS_1_STACK_ITEM_FRAME : SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED;\n            }\n            if (type != FULL_FRAME) {\n                // verify if stack and locals are the same\n                for (int j = 0; j < localsSize && type != FULL_FRAME; j++) {\n                    if (!locals.get(j).equals(clocals.get(j)))\n                        type = FULL_FRAME;\n                }\n            }\n            switch(type) {\n                case SAME_FRAME:\n                    bv.putByte(delta);\n                    break;\n                case SAME_LOCALS_1_STACK_ITEM_FRAME:\n                    bv.putByte(SAME_LOCALS_1_STACK_ITEM_FRAME + delta);\n                    writeTypeInfos(bv, cw, cstack, 0, 1);\n                    break;\n                case SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED:\n                    bv.putByte(SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED);\n                    writeSize(delta, bv, isExtCodeSize);\n                    writeTypeInfos(bv, cw, cstack, 0, 1);\n                    break;\n                case SAME_FRAME_EXTENDED:\n                    bv.putByte(SAME_FRAME_EXTENDED);\n                    writeSize(delta, bv, isExtCodeSize);\n                    break;\n                case CHOP_FRAME:\n                    // negative k\n                    bv.putByte(SAME_FRAME_EXTENDED + k);\n                    writeSize(delta, bv, isExtCodeSize);\n                    break;\n                case APPEND_FRAME:\n                    // positive k\n                    bv.putByte(SAME_FRAME_EXTENDED + k);\n                    writeSize(delta, bv, isExtCodeSize);\n                    writeTypeInfos(bv, cw, clocals, clocalsSize - 1, clocalsSize);\n                    break;\n                case FULL_FRAME:\n                    bv.putByte(FULL_FRAME);\n                    writeSize(delta, bv, isExtCodeSize);\n                    writeSize(clocalsSize, bv, isExtLocals);\n                    writeTypeInfos(bv, cw, clocals, 0, clocalsSize);\n                    writeSize(cstackSize, bv, isExtStack);\n                    writeTypeInfos(bv, cw, cstack, 0, cstackSize);\n                    break;\n                default:\n                    throw new RuntimeException();\n            }\n            // compensating non first offset\n            offset = coffset + 1;\n            locals = clocals;\n        }\n        return bv;\n    }\n\n    private void writeSize(int delta, ByteVector bv, boolean isExt) {\n        if (isExt) {\n            bv.putInt(delta);\n        } else {\n            bv.putShort(delta);\n        }\n    }\n\n    private void writeTypeInfos(ByteVector bv, ClassWriter cw, List info, int start, int end) {\n        for (int j = start; j < end; j++) {\n            StackMapType typeInfo = (StackMapType) info.get(j);\n            bv.putByte(typeInfo.getType());\n            switch(typeInfo.getType()) {\n                case //\n                StackMapType.ITEM_Object:\n                    bv.putShort(cw.newClass(typeInfo.getObject()));\n                    break;\n                case //\n                StackMapType.ITEM_Uninitialized:\n                    bv.putShort(typeInfo.getLabel().getOffset());\n                    break;\n            }\n        }\n    }\n\n    public static int getMethodOff(ClassReader cr, int codeOff, char[] buf) {\n        int off = cr.header + 6;\n        int interfacesCount = cr.readUnsignedShort(off);\n        off += 2 + interfacesCount * 2;\n        int fieldsCount = cr.readUnsignedShort(off);\n        off += 2;\n        for (; fieldsCount > 0; --fieldsCount) {\n            // field attributes\n            int attrCount = cr.readUnsignedShort(off + 6);\n            off += 8;\n            for (; attrCount > 0; --attrCount) {\n                off += 6 + cr.readInt(off + 2);\n            }\n        }\n        int methodsCount = cr.readUnsignedShort(off);\n        off += 2;\n        for (; methodsCount > 0; --methodsCount) {\n            int methodOff = off;\n            // method attributes\n            int attrCount = cr.readUnsignedShort(off + 6);\n            off += 8;\n            for (; attrCount > 0; --attrCount) {\n                String attrName = cr.readUTF8(off, buf);\n                off += 6;\n                if (attrName.equals(\"Code\")) {\n                    if (codeOff == off) {\n                        return methodOff;\n                    }\n                }\n                off += cr.readInt(off - 4);\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Use method signature and access flags to resolve initial locals state.\n     *\n     * @param className name of the method's owner class.\n     * @param access access flags of the method.\n     * @param methodName name of the method.\n     * @param methodDesc descriptor of the method.\n     * @return list of <code>StackMapType</code> instances representing locals\n     *         for an initial frame.\n     */\n    public static List calculateLocals(String className, int access, String methodName, String methodDesc) {\n        List locals = new ArrayList();\n        // TODO\n        if (\"<init>\".equals(methodName) && !className.equals(\"java/lang/Object\")) {\n            StackMapType typeInfo = StackMapType.getTypeInfo(StackMapType.ITEM_UninitializedThis);\n            // this\n            typeInfo.setObject(className);\n            locals.add(typeInfo);\n        } else if ((access & Opcodes.ACC_STATIC) == 0) {\n            StackMapType typeInfo = StackMapType.getTypeInfo(StackMapType.ITEM_Object);\n            // this\n            typeInfo.setObject(className);\n            locals.add(typeInfo);\n        }\n        Type[] types = Type.getArgumentTypes(methodDesc);\n        for (int i = 0; i < types.length; i++) {\n            Type t = types[i];\n            StackMapType smt;\n            switch(t.getSort()) {\n                case Type.LONG:\n                    smt = StackMapType.getTypeInfo(StackMapType.ITEM_Long);\n                    break;\n                case Type.DOUBLE:\n                    smt = StackMapType.getTypeInfo(StackMapType.ITEM_Double);\n                    break;\n                case Type.FLOAT:\n                    smt = StackMapType.getTypeInfo(StackMapType.ITEM_Float);\n                    break;\n                case Type.ARRAY:\n                case Type.OBJECT:\n                    smt = StackMapType.getTypeInfo(StackMapType.ITEM_Object);\n                    // TODO verify name\n                    smt.setObject(t.getDescriptor());\n                    break;\n                default:\n                    smt = StackMapType.getTypeInfo(StackMapType.ITEM_Integer);\n                    break;\n            }\n        }\n        return locals;\n    }\n\n    private int readTypes(List info, boolean isExt, boolean isExtCodeSize, ClassReader cr, int off, Label[] labels, char[] buf) {\n        int n = 0;\n        if (isExt) {\n            n = cr.readInt(off);\n            off += 4;\n        } else {\n            n = cr.readUnsignedShort(off);\n            off += 2;\n        }\n        for (; n > 0; n--) {\n            off = readType(info, isExtCodeSize, cr, off, labels, buf);\n        }\n        return off;\n    }\n\n    private int readType(List info, boolean isExtCodeSize, ClassReader cr, int off, Label[] labels, char[] buf) {\n        int itemType = cr.readByte(off++);\n        StackMapType typeInfo = StackMapType.getTypeInfo(itemType);\n        info.add(typeInfo);\n        switch(itemType) {\n            // case StackMapType.ITEM_Long: //\n            // case StackMapType.ITEM_Double: //\n            // info.add(StackMapType.getTypeInfo(StackMapType.ITEM_Top));\n            // break;\n            case //\n            StackMapType.ITEM_Object:\n                typeInfo.setObject(cr.readClass(off, buf));\n                off += 2;\n                break;\n            case //\n            StackMapType.ITEM_Uninitialized:\n                int offset;\n                if (isExtCodeSize) {\n                    offset = cr.readInt(off);\n                    off += 4;\n                } else {\n                    offset = cr.readUnsignedShort(off);\n                    off += 2;\n                }\n                typeInfo.setLabel(getLabel(offset, labels));\n                break;\n        }\n        return off;\n    }\n\n    private Label getLabel(int offset, Label[] labels) {\n        Label l = labels[offset];\n        if (l != null) {\n            return l;\n        }\n        return labels[offset] = new Label();\n    }\n\n    public String toString() {\n        StringBuffer sb = new StringBuffer(\"StackMapTable[\");\n        for (int i = 0; i < frames.size(); i++) {\n            sb.append('\\n').append('[').append(frames.get(i)).append(']');\n        }\n        sb.append(\"\\n]\");\n        return sb.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/attrs/StackMapTableAttributeTest1.java",
		"test_prompt": "// StackMapTableAttributeTest1.java\npackage org.objectweb.asm.jip.attrs;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport org.objectweb.asm.jip.Attribute;\nimport org.objectweb.asm.jip.ByteVector;\nimport org.objectweb.asm.jip.ClassReader;\nimport org.objectweb.asm.jip.ClassWriter;\nimport org.objectweb.asm.jip.Label;\nimport org.objectweb.asm.jip.Opcodes;\nimport org.objectweb.asm.jip.Type;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StackMapTableAttribute}.\n* It contains ten unit test cases for the {@link StackMapTableAttribute#isCodeAttribute()} method.\n*/\nclass StackMapTableAttributeTest1 {"
	},
	{
		"original_code": "// StackMapTableAttribute.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2005 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip.attrs;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport org.objectweb.asm.jip.Attribute;\nimport org.objectweb.asm.jip.ByteVector;\nimport org.objectweb.asm.jip.ClassReader;\nimport org.objectweb.asm.jip.ClassWriter;\nimport org.objectweb.asm.jip.Label;\nimport org.objectweb.asm.jip.Opcodes;\nimport org.objectweb.asm.jip.Type;\n\n/**\n * The stack map attribute is used during the process of verification by\n * typechecking (4.11.1). <br> <br> A stack map attribute consists of zero or\n * more stack map frames. Each stack map frame specifies (either explicitly or\n * implicitly) a bytecode offset, the verification types (4.11.1) for the local\n * variables, and the verification types for the operand stack. <br> <br> The\n * type checker deals with and manipulates the expected types of a method's\n * local variables and operand stack. Throughout this section, a location refers\n * to either a single local variable or to a single operand stack entry. <br>\n * <br> We will use the terms stack frame map and type state interchangeably to\n * describe a mapping from locations in the operand stack and local variables of\n * a method to verification types. We will usually use the term stack frame map\n * when such a mapping is provided in the class file, and the term type state\n * when the mapping is inferred by the type checker. <br> <br> If a method's\n * Code attribute does not have a StackMapTable attribute, it has an implicit\n * stack map attribute. This implicit stack map attribute is equivalent to a\n * StackMapTable attribute with number_of_entries equal to zero. A method's Code\n * attribute may have at most one StackMapTable attribute, otherwise a\n * java.lang.ClassFormatError is thrown. <br> <br> The format of the stack map\n * in the class file is given below. In the following, if the length of the\n * method's byte code is 65535 or less, then uoffset represents the type u2;\n * otherwise uoffset represents the type u4. If the maximum number of local\n * variables for the method is 65535 or less, then <code>ulocalvar</code>\n * represents the type u2; otherwise ulocalvar represents the type u4. If the\n * maximum size of the operand stack is 65535 or less, then <code>ustack</code>\n * represents the type u2; otherwise ustack represents the type u4.\n *\n * <pre>\n * stack_map { // attribute StackMapTable\n *   u2 attribute_name_index;\n *   u4 attribute_length\n *   uoffset number_of_entries;\n *   stack_map_frame entries[number_of_entries];\n * }\n * </pre>\n *\n * Each stack_map_frame structure specifies the type state at a particular byte\n * code offset. Each frame type specifies (explicitly or implicitly) a value,\n * offset_delta, that is used to calulate the actual byte code offset at which\n * it applies. The byte code offset at which the frame applies is given by\n * adding <code>1 + offset_delta</code> to the <code>offset</code> of the\n * previous frame, unless the previous frame is the initial frame of the method,\n * in which case the byte code offset is <code>offset_delta</code>. <br> <br>\n * <i>Note that the length of the byte codes is not the same as the length of\n * the Code attribute. The byte codes are embedded in the Code attribute, along\n * with other information.</i> <br> <br> By using an offset delta rather than\n * the actual byte code offset we ensure, by definition, that stack map frames\n * are in the correctly sorted order. Furthermore, by consistently using the\n * formula <code>offset_delta + 1</code> for all explicit frames, we guarantee\n * the absence of duplicates. <br> <br> All frame types, even full_frame, rely\n * on the previous frame for some of their semantics. This raises the question\n * of what is the very first frame? The initial frame is implicit, and computed\n * from the method descriptor. See the Prolog code for methodInitialStacFrame.\n * <br> <br> The stack_map_frame structure consists of a one-byte tag followed\n * by zero or more bytes, giving more information, depending upon the tag. <br>\n * <br> A stack map frame may belong to one of several frame types\n *\n * <pre>\n * union stack_map_frame {\n *   same_frame;\n *   same_locals_1_stack_item_frame;\n *   chop_frame;\n *   same_frame_extended;\n *   append_frame;\n *   full_frame;\n * }\n * </pre>\n *\n * The frame type same_frame is represented by tags in the range [0-63]. If the\n * frame type is same_frame, it means the frame has exactly the same locals as\n * the previous stack map frame and that the number of stack items is zero. The\n * offset_delta value for the frame is the value of the tag field, frame_type.\n * The form of such a frame is then:\n *\n * <pre>\n * same_frame {\n *   u1 frame_type = SAME;  // 0-63\n * }\n * </pre>\n *\n * The frame type same_locals_1_stack_item_frame is represented by tags in the\n * range [64, 127]. If the frame_type is same_locals_1_stack_item_frame, it\n * means the frame has exactly the same locals as the previous stack map frame\n * and that the number of stack items is 1. The offset_delta value for the frame\n * is the value (frame_type - 64). There is a verification_type_info following\n * the frame_type for the one stack item. The form of such a frame is then:\n *\n * <pre>\n * same_locals_1_stack_item_frame {\n *   u1 frame_type = SAME_LOCALS_1_STACK_ITEM;  // 64-127\n *    verification_type_info stack[1];\n * }\n * </pre>\n *\n * Tags in the range [128-247] are reserved for future use. <br> <br> The frame\n * type chop_frame is represented by tags in the range [248-250]. If the\n * frame_type is chop_frame, it means that the current locals are the same as\n * the locals in the previous frame, except that the k last locals are absent.\n * The value of k is given by the formula 251-frame_type. <br> <br> The form of\n * such a frame is then:\n *\n * <pre>\n * chop_frame {\n *   u1 frame_type=CHOP;  // 248-250\n *   uoffset offset_delta;\n * }\n * </pre>\n *\n * The frame type same_frame_extended is represented by the tag value 251. If\n * the frame type is same_frame_extended, it means the frame has exactly the\n * same locals as the previous stack map frame and that the number of stack\n * items is zero. The form of such a frame is then:\n *\n * <pre>\n * same_frame_extended {\n *   u1 frame_type = SAME_FRAME_EXTENDED;  // 251\n *   uoffset offset_delta;\n * }\n * </pre>\n *\n * The frame type append_frame is represented by tags in the range [252-254]. If\n * the frame_type is append_frame, it means that the current locals are the same\n * as the locals in the previous frame, except that k additional locals are\n * defined. The value of k is given by the formula frame_type-251. <br> <br> The\n * form of such a frame is then:\n *\n * <pre>\n * append_frame {\n *   u1 frame_type =APPEND;  // 252-254\n *   uoffset offset_delta;\n *   verification_type_info locals[frame_type -251];\n * }\n * </pre>\n *\n * The 0th entry in locals represents the type of the first additional local\n * variable. If locals[M] represents local variable N, then locals[M+1]\n * represents local variable N+1 if locals[M] is one of Top_variable_info,\n * Integer_variable_info, Float_variable_info, Null_variable_info,\n * UninitializedThis_variable_info, Object_variable_info, or\n * Uninitialized_variable_info, otherwise locals[M+1] represents local variable\n * N+2. It is an error if, for any index i, locals[i] represents a local\n * variable whose index is greater than the maximum number of local variables\n * for the method. <br> <br> The frame type full_frame is represented by the tag\n * value 255. The form of such a frame is then:\n *\n * <pre>\n * full_frame {\n *   u1 frame_type = FULL_FRAME;  // 255\n *   uoffset offset_delta;\n *   ulocalvar number_of_locals;\n *   verification_type_info locals[number_of_locals];\n *   ustack number_of_stack_items;\n *   verification_type_info stack[number_of_stack_items];\n * }\n * </pre>\n *\n * The 0th entry in locals represents the type of local variable 0. If locals[M]\n * represents local variable N, then locals[M+1] represents local variable N+1\n * if locals[M] is one of Top_variable_info, Integer_variable_info,\n * Float_variable_info, Null_variable_info, UninitializedThis_variable_info,\n * Object_variable_info, or Uninitialized_variable_info, otherwise locals[M+1]\n * represents local variable N+2. It is an error if, for any index i, locals[i]\n * represents a local variable whose index is greater than the maximum number of\n * local variables for the method. <br> <br> The 0th entry in stack represents\n * the type of the bottom of the stack, and subsequent entries represent types\n * of stack elements closer to the top of the operand stack. We shall refer to\n * the bottom element of the stack as stack element 0, and to subsequent\n * elements as stack element 1, 2 etc. If stack[M] represents stack element N,\n * then stack[M+1] represents stack element N+1 if stack[M] is one of\n * Top_variable_info, Integer_variable_info, Float_variable_info,\n * Null_variable_info, UninitializedThis_variable_info, Object_variable_info, or\n * Uninitialized_variable_info, otherwise stack[M+1] represents stack element\n * N+2. It is an error if, for any index i, stack[i] represents a stack entry\n * whose index is greater than the maximum operand stack size for the method.\n * <br> <br> We say that an instruction in the byte code has a corresponding\n * stack map frame if the offset in the offset field of the stack map frame is\n * the same as the offset of the instruction in the byte codes. <br> <br> The\n * verification_type_info structure consists of a one-byte tag followed by zero\n * or more bytes, giving more information about the tag. Each\n * verification_type_info structure specifies the verification type of one or\n * two locations.\n *\n * <pre>\n * union verification_type_info {\n *   Top_variable_info;\n *   Integer_variable_info;\n *   Float_variable_info;\n *   Long_variable_info;\n *   Double_variable_info;\n *   Null_variable_info;\n *   UninitializedThis_variable_info;\n *   Object_variable_info;\n *   Uninitialized_variable_info;\n * }\n * </pre>\n *\n * The Top_variable_info type indicates that the local variable has the\n * verification type top (T.)\n *\n * <pre>\n * Top_variable_info {\n *   u1 tag = ITEM_Top; // 0\n * }\n * </pre>\n *\n * The Integer_variable_info type indicates that the location contains the\n * verification type int.\n *\n * <pre>\n * Integer_variable_info {\n *   u1 tag = ITEM_Integer; // 1\n * }\n * </pre>\n *\n * The Float_variable_info type indicates that the location contains the\n * verification type float.\n *\n * <pre>\n * Float_variable_info {\n *   u1 tag = ITEM_Float; // 2\n * }\n * </pre>\n *\n * The Long_variable_info type indicates that the location contains the\n * verification type long. If the location is a local variable, then:\n *\n * <ul> <li>It must not be the local variable with the highest index.</li>\n * <li>The next higher numbered local variable contains the verification type\n * T.</li> </ul>\n *\n * If the location is an operand stack entry, then:\n *\n * <ul> <li>The current location must not be the topmost location of the\n * operand stack.</li> <li>the next location closer to the top of the operand\n * stack contains the verification type T.</li> </ul>\n *\n * This structure gives the contents of two locations in the operand stack or in\n * the local variables.\n *\n * <pre>\n * Long_variable_info {\n *   u1 tag = ITEM_Long; // 4\n * }\n * </pre>\n *\n * The Double_variable_info type indicates that the location contains the\n * verification type double. If the location is a local variable, then:\n *\n * <ul> <li>It must not be the local variable with the highest index.</li>\n * <li>The next higher numbered local variable contains the verification type\n * T. <li> </ul>\n *\n * If the location is an operand stack entry, then:\n *\n * <ul> <li>The current location must not be the topmost location of the\n * operand stack.</li> <li>the next location closer to the top of the operand\n * stack contains the verification type T.</li> </ul>\n *\n * This structure gives the contents of two locations in in the operand stack or\n * in the local variables.\n *\n * <pre>\n * Double_variable_info {\n *   u1 tag = ITEM_Double; // 3\n * }\n * </pre>\n *\n * The Null_variable_info type indicates that location contains the verification\n * type null.\n *\n * <pre>\n * Null_variable_info {\n *   u1 tag = ITEM_Null; // 5\n * }\n * </pre>\n *\n * The UninitializedThis_variable_info type indicates that the location contains\n * the verification type uninitializedThis.\n *\n * <pre>\n * UninitializedThis_variable_info {\n *   u1 tag = ITEM_UninitializedThis; // 6\n * }\n * </pre>\n *\n * The Object_variable_info type indicates that the location contains an\n * instance of the class referenced by the constant pool entry.\n *\n * <pre>\n * Object_variable_info {\n *   u1 tag = ITEM_Object; // 7\n *   u2 cpool_index;\n * }\n * </pre>\n *\n * The Uninitialized_variable_info indicates that the location contains the\n * verification type uninitialized(offset). The offset item indicates the offset\n * of the new instruction that created the object being stored in the location.\n *\n * <pre>\n * Uninitialized_variable_info {\n *   u1 tag = ITEM_Uninitialized // 8\n *   uoffset offset;\n * }\n * </pre>\n *\n * @see \"ClassFileFormat-Java6.fm Page 138 Friday, April 15, 2005 3:22 PM\"\n *\n * @author Eugene Kuleshov\n */\npublic class StackMapTableAttribute extends Attribute {\n\n    /**\n     * Frame has exactly the same locals as the previous stack map frame and\n     * number of stack items is zero.\n     */\n    // to 63 (0-3f)\n    public static final int SAME_FRAME = 0;\n\n    /**\n     * Frame has exactly the same locals as the previous stack map frame and\n     * number of stack items is 1\n     */\n    // to 127\n    public static final int SAME_LOCALS_1_STACK_ITEM_FRAME = 64;\n\n    // (40-7f)\n    /**\n     * Reserved for future use\n     */\n    public static final int RESERVED = 128;\n\n    /**\n     * Frame has exactly the same locals as the previous stack map frame and\n     * number of stack items is 1. Offset is bigger then 63;\n     */\n    // f7\n    public static final int SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED = 247;\n\n    /**\n     * Frame where current locals are the same as the locals in the previous\n     * frame, except that the k last locals are absent. The value of k is given\n     * by the formula 251-frame_type.\n     */\n    // to 250 (f8-fA)\n    public static final int CHOP_FRAME = 248;\n\n    /**\n     * Frame has exactly the same locals as the previous stack map frame and\n     * number of stack items is zero. Offset is bigger then 63;\n     */\n    // fb\n    public static final int SAME_FRAME_EXTENDED = 251;\n\n    /**\n     * Frame where current locals are the same as the locals in the previous\n     * frame, except that k additional locals are defined. The value of k is\n     * given by the formula frame_type-251.\n     */\n    // to 254 // fc-fe\n    public static final int APPEND_FRAME = 252;\n\n    /**\n     * Full frame\n     */\n    // ff\n    public static final int FULL_FRAME = 255;\n\n    private static final int MAX_SHORT = 65535;\n\n    /**\n     * A <code>List</code> of <code>StackMapFrame</code> instances.\n     */\n    private List frames;\n\n    public StackMapTableAttribute() {\n        super(\"StackMapTable\");\n    }\n\n    public StackMapTableAttribute(List frames) {\n        this();\n        this.frames = frames;\n    }\n\n    public List getFrames() {\n        return frames;\n    }\n\n    public StackMapFrame getFrame(Label label) {\n        for (int i = 0; i < frames.size(); i++) {\n            StackMapFrame frame = (StackMapFrame) frames.get(i);\n            if (frame.label == label) {\n                return frame;\n            }\n        }\n        return null;\n    }\n\n    public boolean isUnknown() {\n        return false;\n    }\n\n    public boolean isCodeAttribute() {\n        return true;\n    }\n\n    protected Attribute read(ClassReader cr, int off, int len, char[] buf, int codeOff, Label[] labels) {\n        ArrayList frames = new ArrayList();\n        // note that this is not the size of Code attribute\n        boolean isExtCodeSize = cr.readInt(codeOff + 4) > MAX_SHORT;\n        boolean isExtLocals = cr.readUnsignedShort(codeOff + 2) > MAX_SHORT;\n        boolean isExtStack = cr.readUnsignedShort(codeOff) > MAX_SHORT;\n        int offset = 0;\n        int methodOff = getMethodOff(cr, codeOff, buf);\n        StackMapFrame frame = new StackMapFrame(getLabel(offset, labels), // owner\n        calculateLocals(// owner\n        cr.readClass(cr.header + 2, buf), // method access\n        cr.readUnsignedShort(methodOff), // method name\n        cr.readUTF8(methodOff + 2, buf), // method desc\n        cr.readUTF8(methodOff + 4, buf)), Collections.EMPTY_LIST);\n        frames.add(frame);\n        // System.err.println( cr.readUTF8( methodOff + 2, buf));\n        // System.err.println( offset +\" delta:\" + 0 +\" : \"+ frame);\n        int size;\n        if (isExtCodeSize) {\n            size = cr.readInt(off);\n            off += 4;\n        } else {\n            size = cr.readUnsignedShort(off);\n            off += 2;\n        }\n        for (; size > 0; size--) {\n            // & 0xff;\n            int tag = cr.readByte(off);\n            off++;\n            List stack;\n            List locals;\n            int offsetDelta;\n            if (tag < SAME_LOCALS_1_STACK_ITEM_FRAME) {\n                // SAME_FRAME\n                offsetDelta = tag;\n                locals = new ArrayList(frame.locals);\n                stack = Collections.EMPTY_LIST;\n            } else if (tag < RESERVED) {\n                // SAME_LOCALS_1_STACK_ITEM_FRAME\n                offsetDelta = tag - SAME_LOCALS_1_STACK_ITEM_FRAME;\n                locals = new ArrayList(frame.locals);\n                stack = new ArrayList();\n                // read verification_type_info stack[1];\n                off = readType(stack, isExtCodeSize, cr, off, labels, buf);\n            } else {\n                if (isExtCodeSize) {\n                    offsetDelta = cr.readInt(off);\n                    off += 4;\n                } else {\n                    offsetDelta = cr.readUnsignedShort(off);\n                    off += 2;\n                }\n                if (tag == SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {\n                    // SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED\n                    locals = new ArrayList(frame.locals);\n                    stack = new ArrayList();\n                    // read verification_type_info stack[1];\n                    off = readType(stack, isExtCodeSize, cr, off, labels, buf);\n                } else if (tag >= CHOP_FRAME && tag < SAME_FRAME_EXTENDED) {\n                    // CHOP_FRAME\n                    stack = Collections.EMPTY_LIST;\n                    int k = SAME_FRAME_EXTENDED - tag;\n                    // copy locals from prev frame and chop last k\n                    locals = new ArrayList(frame.locals.subList(0, frame.locals.size() - k));\n                } else if (tag == SAME_FRAME_EXTENDED) {\n                    // SAME_FRAME_EXTENDED\n                    stack = Collections.EMPTY_LIST;\n                    locals = new ArrayList(frame.locals);\n                } else if (/* tag>=APPEND && */\n                tag < FULL_FRAME) {\n                    // APPEND_FRAME\n                    stack = Collections.EMPTY_LIST;\n                    // copy locals from prev frame and append new k\n                    locals = new ArrayList(frame.locals);\n                    for (int k = tag - SAME_FRAME_EXTENDED; k > 0; k--) {\n                        off = readType(locals, isExtCodeSize, cr, off, labels, buf);\n                    }\n                } else if (tag == FULL_FRAME) {\n                    // FULL_FRAME\n                    // read verification_type_info locals[number_of_locals];\n                    locals = new ArrayList();\n                    off = readTypes(locals, isExtLocals, isExtCodeSize, cr, off, labels, buf);\n                    // read verification_type_info stack[number_of_stack_items];\n                    stack = new ArrayList();\n                    off = readTypes(stack, isExtStack, isExtCodeSize, cr, off, labels, buf);\n                } else {\n                    throw new RuntimeException(\"Unknown frame type \" + tag + \" after offset \" + offset);\n                }\n            }\n            offset += offsetDelta;\n            Label offsetLabel = getLabel(offset, labels);\n            frame = new StackMapFrame(offsetLabel, locals, stack);\n            frames.add(frame);\n            // System.err.println( tag +\" \" + offset +\" delta:\" + offsetDelta +\n            // \" frameType:\"+ frameType+\" : \"+ frame);\n            offset++;\n        }\n        return new StackMapTableAttribute(frames);\n    }\n\n    protected ByteVector write(ClassWriter cw, byte[] code, int len, int maxStack, int maxLocals) {\n        ByteVector bv = new ByteVector();\n        // TODO verify this value (MAX_SHORT)\n        boolean isExtCodeSize = code != null && code.length > MAX_SHORT;\n        writeSize(frames.size() - 1, bv, isExtCodeSize);\n        if (frames.size() < 2) {\n            return bv;\n        }\n        boolean isExtLocals = maxLocals > MAX_SHORT;\n        boolean isExtStack = maxStack > MAX_SHORT;\n        // skip the first frame\n        StackMapFrame frame = (StackMapFrame) frames.get(0);\n        List locals = frame.locals;\n        int offset = frame.label.getOffset();\n        for (int i = 1; i < frames.size(); i++) {\n            frame = (StackMapFrame) frames.get(i);\n            List clocals = frame.locals;\n            List cstack = frame.stack;\n            int coffset = frame.label.getOffset();\n            int clocalsSize = clocals.size();\n            int cstackSize = cstack.size();\n            int localsSize = locals.size();\n            int delta = coffset - offset;\n            int type = FULL_FRAME;\n            int k = 0;\n            if (cstackSize == 0) {\n                k = clocalsSize - localsSize;\n                switch(k) {\n                    case -3:\n                    case -2:\n                    case -1:\n                        // CHOP or FULL\n                        type = CHOP_FRAME;\n                        // for full_frame check\n                        localsSize = clocalsSize;\n                        break;\n                    case 0:\n                        // SAME, SAME_EXTENDED or FULL\n                        type = delta < 64 ? SAME_FRAME : SAME_FRAME_EXTENDED;\n                        break;\n                    case 1:\n                    case 2:\n                    case 3:\n                        // APPEND or FULL\n                        type = APPEND_FRAME;\n                        break;\n                }\n            } else if (localsSize == clocalsSize && cstackSize == 1) {\n                // SAME_LOCAL_1_STACK or FULL\n                type = delta < 63 ? SAME_LOCALS_1_STACK_ITEM_FRAME : SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED;\n            }\n            if (type != FULL_FRAME) {\n                // verify if stack and locals are the same\n                for (int j = 0; j < localsSize && type != FULL_FRAME; j++) {\n                    if (!locals.get(j).equals(clocals.get(j)))\n                        type = FULL_FRAME;\n                }\n            }\n            switch(type) {\n                case SAME_FRAME:\n                    bv.putByte(delta);\n                    break;\n                case SAME_LOCALS_1_STACK_ITEM_FRAME:\n                    bv.putByte(SAME_LOCALS_1_STACK_ITEM_FRAME + delta);\n                    writeTypeInfos(bv, cw, cstack, 0, 1);\n                    break;\n                case SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED:\n                    bv.putByte(SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED);\n                    writeSize(delta, bv, isExtCodeSize);\n                    writeTypeInfos(bv, cw, cstack, 0, 1);\n                    break;\n                case SAME_FRAME_EXTENDED:\n                    bv.putByte(SAME_FRAME_EXTENDED);\n                    writeSize(delta, bv, isExtCodeSize);\n                    break;\n                case CHOP_FRAME:\n                    // negative k\n                    bv.putByte(SAME_FRAME_EXTENDED + k);\n                    writeSize(delta, bv, isExtCodeSize);\n                    break;\n                case APPEND_FRAME:\n                    // positive k\n                    bv.putByte(SAME_FRAME_EXTENDED + k);\n                    writeSize(delta, bv, isExtCodeSize);\n                    writeTypeInfos(bv, cw, clocals, clocalsSize - 1, clocalsSize);\n                    break;\n                case FULL_FRAME:\n                    bv.putByte(FULL_FRAME);\n                    writeSize(delta, bv, isExtCodeSize);\n                    writeSize(clocalsSize, bv, isExtLocals);\n                    writeTypeInfos(bv, cw, clocals, 0, clocalsSize);\n                    writeSize(cstackSize, bv, isExtStack);\n                    writeTypeInfos(bv, cw, cstack, 0, cstackSize);\n                    break;\n                default:\n                    throw new RuntimeException();\n            }\n            // compensating non first offset\n            offset = coffset + 1;\n            locals = clocals;\n        }\n        return bv;\n    }\n\n    private void writeSize(int delta, ByteVector bv, boolean isExt) {\n        if (isExt) {\n            bv.putInt(delta);\n        } else {\n            bv.putShort(delta);\n        }\n    }\n\n    private void writeTypeInfos(ByteVector bv, ClassWriter cw, List info, int start, int end) {\n        for (int j = start; j < end; j++) {\n            StackMapType typeInfo = (StackMapType) info.get(j);\n            bv.putByte(typeInfo.getType());\n            switch(typeInfo.getType()) {\n                case //\n                StackMapType.ITEM_Object:\n                    bv.putShort(cw.newClass(typeInfo.getObject()));\n                    break;\n                case //\n                StackMapType.ITEM_Uninitialized:\n                    bv.putShort(typeInfo.getLabel().getOffset());\n                    break;\n            }\n        }\n    }\n\n    public static int getMethodOff(ClassReader cr, int codeOff, char[] buf) {\n        int off = cr.header + 6;\n        int interfacesCount = cr.readUnsignedShort(off);\n        off += 2 + interfacesCount * 2;\n        int fieldsCount = cr.readUnsignedShort(off);\n        off += 2;\n        for (; fieldsCount > 0; --fieldsCount) {\n            // field attributes\n            int attrCount = cr.readUnsignedShort(off + 6);\n            off += 8;\n            for (; attrCount > 0; --attrCount) {\n                off += 6 + cr.readInt(off + 2);\n            }\n        }\n        int methodsCount = cr.readUnsignedShort(off);\n        off += 2;\n        for (; methodsCount > 0; --methodsCount) {\n            int methodOff = off;\n            // method attributes\n            int attrCount = cr.readUnsignedShort(off + 6);\n            off += 8;\n            for (; attrCount > 0; --attrCount) {\n                String attrName = cr.readUTF8(off, buf);\n                off += 6;\n                if (attrName.equals(\"Code\")) {\n                    if (codeOff == off) {\n                        return methodOff;\n                    }\n                }\n                off += cr.readInt(off - 4);\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Use method signature and access flags to resolve initial locals state.\n     *\n     * @param className name of the method's owner class.\n     * @param access access flags of the method.\n     * @param methodName name of the method.\n     * @param methodDesc descriptor of the method.\n     * @return list of <code>StackMapType</code> instances representing locals\n     *         for an initial frame.\n     */\n    public static List calculateLocals(String className, int access, String methodName, String methodDesc) {\n        List locals = new ArrayList();\n        // TODO\n        if (\"<init>\".equals(methodName) && !className.equals(\"java/lang/Object\")) {\n            StackMapType typeInfo = StackMapType.getTypeInfo(StackMapType.ITEM_UninitializedThis);\n            // this\n            typeInfo.setObject(className);\n            locals.add(typeInfo);\n        } else if ((access & Opcodes.ACC_STATIC) == 0) {\n            StackMapType typeInfo = StackMapType.getTypeInfo(StackMapType.ITEM_Object);\n            // this\n            typeInfo.setObject(className);\n            locals.add(typeInfo);\n        }\n        Type[] types = Type.getArgumentTypes(methodDesc);\n        for (int i = 0; i < types.length; i++) {\n            Type t = types[i];\n            StackMapType smt;\n            switch(t.getSort()) {\n                case Type.LONG:\n                    smt = StackMapType.getTypeInfo(StackMapType.ITEM_Long);\n                    break;\n                case Type.DOUBLE:\n                    smt = StackMapType.getTypeInfo(StackMapType.ITEM_Double);\n                    break;\n                case Type.FLOAT:\n                    smt = StackMapType.getTypeInfo(StackMapType.ITEM_Float);\n                    break;\n                case Type.ARRAY:\n                case Type.OBJECT:\n                    smt = StackMapType.getTypeInfo(StackMapType.ITEM_Object);\n                    // TODO verify name\n                    smt.setObject(t.getDescriptor());\n                    break;\n                default:\n                    smt = StackMapType.getTypeInfo(StackMapType.ITEM_Integer);\n                    break;\n            }\n        }\n        return locals;\n    }\n\n    private int readTypes(List info, boolean isExt, boolean isExtCodeSize, ClassReader cr, int off, Label[] labels, char[] buf) {\n        int n = 0;\n        if (isExt) {\n            n = cr.readInt(off);\n            off += 4;\n        } else {\n            n = cr.readUnsignedShort(off);\n            off += 2;\n        }\n        for (; n > 0; n--) {\n            off = readType(info, isExtCodeSize, cr, off, labels, buf);\n        }\n        return off;\n    }\n\n    private int readType(List info, boolean isExtCodeSize, ClassReader cr, int off, Label[] labels, char[] buf) {\n        int itemType = cr.readByte(off++);\n        StackMapType typeInfo = StackMapType.getTypeInfo(itemType);\n        info.add(typeInfo);\n        switch(itemType) {\n            // case StackMapType.ITEM_Long: //\n            // case StackMapType.ITEM_Double: //\n            // info.add(StackMapType.getTypeInfo(StackMapType.ITEM_Top));\n            // break;\n            case //\n            StackMapType.ITEM_Object:\n                typeInfo.setObject(cr.readClass(off, buf));\n                off += 2;\n                break;\n            case //\n            StackMapType.ITEM_Uninitialized:\n                int offset;\n                if (isExtCodeSize) {\n                    offset = cr.readInt(off);\n                    off += 4;\n                } else {\n                    offset = cr.readUnsignedShort(off);\n                    off += 2;\n                }\n                typeInfo.setLabel(getLabel(offset, labels));\n                break;\n        }\n        return off;\n    }\n\n    private Label getLabel(int offset, Label[] labels) {\n        Label l = labels[offset];\n        if (l != null) {\n            return l;\n        }\n        return labels[offset] = new Label();\n    }\n\n    public String toString() {\n        StringBuffer sb = new StringBuffer(\"StackMapTable[\");\n        for (int i = 0; i < frames.size(); i++) {\n            sb.append('\\n').append('[').append(frames.get(i)).append(']');\n        }\n        sb.append(\"\\n]\");\n        return sb.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/attrs/StackMapTableAttributeTest2.java",
		"test_prompt": "// StackMapTableAttributeTest2.java\npackage org.objectweb.asm.jip.attrs;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport org.objectweb.asm.jip.Attribute;\nimport org.objectweb.asm.jip.ByteVector;\nimport org.objectweb.asm.jip.ClassReader;\nimport org.objectweb.asm.jip.ClassWriter;\nimport org.objectweb.asm.jip.Label;\nimport org.objectweb.asm.jip.Opcodes;\nimport org.objectweb.asm.jip.Type;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StackMapTableAttribute}.\n* It contains ten unit test cases for the {@link StackMapTableAttribute#getMethodOff(ClassReader, int, char[])} method.\n*/\nclass StackMapTableAttributeTest2 {"
	},
	{
		"original_code": "// StackMapTableAttribute.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2005 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip.attrs;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport org.objectweb.asm.jip.Attribute;\nimport org.objectweb.asm.jip.ByteVector;\nimport org.objectweb.asm.jip.ClassReader;\nimport org.objectweb.asm.jip.ClassWriter;\nimport org.objectweb.asm.jip.Label;\nimport org.objectweb.asm.jip.Opcodes;\nimport org.objectweb.asm.jip.Type;\n\n/**\n * The stack map attribute is used during the process of verification by\n * typechecking (4.11.1). <br> <br> A stack map attribute consists of zero or\n * more stack map frames. Each stack map frame specifies (either explicitly or\n * implicitly) a bytecode offset, the verification types (4.11.1) for the local\n * variables, and the verification types for the operand stack. <br> <br> The\n * type checker deals with and manipulates the expected types of a method's\n * local variables and operand stack. Throughout this section, a location refers\n * to either a single local variable or to a single operand stack entry. <br>\n * <br> We will use the terms stack frame map and type state interchangeably to\n * describe a mapping from locations in the operand stack and local variables of\n * a method to verification types. We will usually use the term stack frame map\n * when such a mapping is provided in the class file, and the term type state\n * when the mapping is inferred by the type checker. <br> <br> If a method's\n * Code attribute does not have a StackMapTable attribute, it has an implicit\n * stack map attribute. This implicit stack map attribute is equivalent to a\n * StackMapTable attribute with number_of_entries equal to zero. A method's Code\n * attribute may have at most one StackMapTable attribute, otherwise a\n * java.lang.ClassFormatError is thrown. <br> <br> The format of the stack map\n * in the class file is given below. In the following, if the length of the\n * method's byte code is 65535 or less, then uoffset represents the type u2;\n * otherwise uoffset represents the type u4. If the maximum number of local\n * variables for the method is 65535 or less, then <code>ulocalvar</code>\n * represents the type u2; otherwise ulocalvar represents the type u4. If the\n * maximum size of the operand stack is 65535 or less, then <code>ustack</code>\n * represents the type u2; otherwise ustack represents the type u4.\n *\n * <pre>\n * stack_map { // attribute StackMapTable\n *   u2 attribute_name_index;\n *   u4 attribute_length\n *   uoffset number_of_entries;\n *   stack_map_frame entries[number_of_entries];\n * }\n * </pre>\n *\n * Each stack_map_frame structure specifies the type state at a particular byte\n * code offset. Each frame type specifies (explicitly or implicitly) a value,\n * offset_delta, that is used to calulate the actual byte code offset at which\n * it applies. The byte code offset at which the frame applies is given by\n * adding <code>1 + offset_delta</code> to the <code>offset</code> of the\n * previous frame, unless the previous frame is the initial frame of the method,\n * in which case the byte code offset is <code>offset_delta</code>. <br> <br>\n * <i>Note that the length of the byte codes is not the same as the length of\n * the Code attribute. The byte codes are embedded in the Code attribute, along\n * with other information.</i> <br> <br> By using an offset delta rather than\n * the actual byte code offset we ensure, by definition, that stack map frames\n * are in the correctly sorted order. Furthermore, by consistently using the\n * formula <code>offset_delta + 1</code> for all explicit frames, we guarantee\n * the absence of duplicates. <br> <br> All frame types, even full_frame, rely\n * on the previous frame for some of their semantics. This raises the question\n * of what is the very first frame? The initial frame is implicit, and computed\n * from the method descriptor. See the Prolog code for methodInitialStacFrame.\n * <br> <br> The stack_map_frame structure consists of a one-byte tag followed\n * by zero or more bytes, giving more information, depending upon the tag. <br>\n * <br> A stack map frame may belong to one of several frame types\n *\n * <pre>\n * union stack_map_frame {\n *   same_frame;\n *   same_locals_1_stack_item_frame;\n *   chop_frame;\n *   same_frame_extended;\n *   append_frame;\n *   full_frame;\n * }\n * </pre>\n *\n * The frame type same_frame is represented by tags in the range [0-63]. If the\n * frame type is same_frame, it means the frame has exactly the same locals as\n * the previous stack map frame and that the number of stack items is zero. The\n * offset_delta value for the frame is the value of the tag field, frame_type.\n * The form of such a frame is then:\n *\n * <pre>\n * same_frame {\n *   u1 frame_type = SAME;  // 0-63\n * }\n * </pre>\n *\n * The frame type same_locals_1_stack_item_frame is represented by tags in the\n * range [64, 127]. If the frame_type is same_locals_1_stack_item_frame, it\n * means the frame has exactly the same locals as the previous stack map frame\n * and that the number of stack items is 1. The offset_delta value for the frame\n * is the value (frame_type - 64). There is a verification_type_info following\n * the frame_type for the one stack item. The form of such a frame is then:\n *\n * <pre>\n * same_locals_1_stack_item_frame {\n *   u1 frame_type = SAME_LOCALS_1_STACK_ITEM;  // 64-127\n *    verification_type_info stack[1];\n * }\n * </pre>\n *\n * Tags in the range [128-247] are reserved for future use. <br> <br> The frame\n * type chop_frame is represented by tags in the range [248-250]. If the\n * frame_type is chop_frame, it means that the current locals are the same as\n * the locals in the previous frame, except that the k last locals are absent.\n * The value of k is given by the formula 251-frame_type. <br> <br> The form of\n * such a frame is then:\n *\n * <pre>\n * chop_frame {\n *   u1 frame_type=CHOP;  // 248-250\n *   uoffset offset_delta;\n * }\n * </pre>\n *\n * The frame type same_frame_extended is represented by the tag value 251. If\n * the frame type is same_frame_extended, it means the frame has exactly the\n * same locals as the previous stack map frame and that the number of stack\n * items is zero. The form of such a frame is then:\n *\n * <pre>\n * same_frame_extended {\n *   u1 frame_type = SAME_FRAME_EXTENDED;  // 251\n *   uoffset offset_delta;\n * }\n * </pre>\n *\n * The frame type append_frame is represented by tags in the range [252-254]. If\n * the frame_type is append_frame, it means that the current locals are the same\n * as the locals in the previous frame, except that k additional locals are\n * defined. The value of k is given by the formula frame_type-251. <br> <br> The\n * form of such a frame is then:\n *\n * <pre>\n * append_frame {\n *   u1 frame_type =APPEND;  // 252-254\n *   uoffset offset_delta;\n *   verification_type_info locals[frame_type -251];\n * }\n * </pre>\n *\n * The 0th entry in locals represents the type of the first additional local\n * variable. If locals[M] represents local variable N, then locals[M+1]\n * represents local variable N+1 if locals[M] is one of Top_variable_info,\n * Integer_variable_info, Float_variable_info, Null_variable_info,\n * UninitializedThis_variable_info, Object_variable_info, or\n * Uninitialized_variable_info, otherwise locals[M+1] represents local variable\n * N+2. It is an error if, for any index i, locals[i] represents a local\n * variable whose index is greater than the maximum number of local variables\n * for the method. <br> <br> The frame type full_frame is represented by the tag\n * value 255. The form of such a frame is then:\n *\n * <pre>\n * full_frame {\n *   u1 frame_type = FULL_FRAME;  // 255\n *   uoffset offset_delta;\n *   ulocalvar number_of_locals;\n *   verification_type_info locals[number_of_locals];\n *   ustack number_of_stack_items;\n *   verification_type_info stack[number_of_stack_items];\n * }\n * </pre>\n *\n * The 0th entry in locals represents the type of local variable 0. If locals[M]\n * represents local variable N, then locals[M+1] represents local variable N+1\n * if locals[M] is one of Top_variable_info, Integer_variable_info,\n * Float_variable_info, Null_variable_info, UninitializedThis_variable_info,\n * Object_variable_info, or Uninitialized_variable_info, otherwise locals[M+1]\n * represents local variable N+2. It is an error if, for any index i, locals[i]\n * represents a local variable whose index is greater than the maximum number of\n * local variables for the method. <br> <br> The 0th entry in stack represents\n * the type of the bottom of the stack, and subsequent entries represent types\n * of stack elements closer to the top of the operand stack. We shall refer to\n * the bottom element of the stack as stack element 0, and to subsequent\n * elements as stack element 1, 2 etc. If stack[M] represents stack element N,\n * then stack[M+1] represents stack element N+1 if stack[M] is one of\n * Top_variable_info, Integer_variable_info, Float_variable_info,\n * Null_variable_info, UninitializedThis_variable_info, Object_variable_info, or\n * Uninitialized_variable_info, otherwise stack[M+1] represents stack element\n * N+2. It is an error if, for any index i, stack[i] represents a stack entry\n * whose index is greater than the maximum operand stack size for the method.\n * <br> <br> We say that an instruction in the byte code has a corresponding\n * stack map frame if the offset in the offset field of the stack map frame is\n * the same as the offset of the instruction in the byte codes. <br> <br> The\n * verification_type_info structure consists of a one-byte tag followed by zero\n * or more bytes, giving more information about the tag. Each\n * verification_type_info structure specifies the verification type of one or\n * two locations.\n *\n * <pre>\n * union verification_type_info {\n *   Top_variable_info;\n *   Integer_variable_info;\n *   Float_variable_info;\n *   Long_variable_info;\n *   Double_variable_info;\n *   Null_variable_info;\n *   UninitializedThis_variable_info;\n *   Object_variable_info;\n *   Uninitialized_variable_info;\n * }\n * </pre>\n *\n * The Top_variable_info type indicates that the local variable has the\n * verification type top (T.)\n *\n * <pre>\n * Top_variable_info {\n *   u1 tag = ITEM_Top; // 0\n * }\n * </pre>\n *\n * The Integer_variable_info type indicates that the location contains the\n * verification type int.\n *\n * <pre>\n * Integer_variable_info {\n *   u1 tag = ITEM_Integer; // 1\n * }\n * </pre>\n *\n * The Float_variable_info type indicates that the location contains the\n * verification type float.\n *\n * <pre>\n * Float_variable_info {\n *   u1 tag = ITEM_Float; // 2\n * }\n * </pre>\n *\n * The Long_variable_info type indicates that the location contains the\n * verification type long. If the location is a local variable, then:\n *\n * <ul> <li>It must not be the local variable with the highest index.</li>\n * <li>The next higher numbered local variable contains the verification type\n * T.</li> </ul>\n *\n * If the location is an operand stack entry, then:\n *\n * <ul> <li>The current location must not be the topmost location of the\n * operand stack.</li> <li>the next location closer to the top of the operand\n * stack contains the verification type T.</li> </ul>\n *\n * This structure gives the contents of two locations in the operand stack or in\n * the local variables.\n *\n * <pre>\n * Long_variable_info {\n *   u1 tag = ITEM_Long; // 4\n * }\n * </pre>\n *\n * The Double_variable_info type indicates that the location contains the\n * verification type double. If the location is a local variable, then:\n *\n * <ul> <li>It must not be the local variable with the highest index.</li>\n * <li>The next higher numbered local variable contains the verification type\n * T. <li> </ul>\n *\n * If the location is an operand stack entry, then:\n *\n * <ul> <li>The current location must not be the topmost location of the\n * operand stack.</li> <li>the next location closer to the top of the operand\n * stack contains the verification type T.</li> </ul>\n *\n * This structure gives the contents of two locations in in the operand stack or\n * in the local variables.\n *\n * <pre>\n * Double_variable_info {\n *   u1 tag = ITEM_Double; // 3\n * }\n * </pre>\n *\n * The Null_variable_info type indicates that location contains the verification\n * type null.\n *\n * <pre>\n * Null_variable_info {\n *   u1 tag = ITEM_Null; // 5\n * }\n * </pre>\n *\n * The UninitializedThis_variable_info type indicates that the location contains\n * the verification type uninitializedThis.\n *\n * <pre>\n * UninitializedThis_variable_info {\n *   u1 tag = ITEM_UninitializedThis; // 6\n * }\n * </pre>\n *\n * The Object_variable_info type indicates that the location contains an\n * instance of the class referenced by the constant pool entry.\n *\n * <pre>\n * Object_variable_info {\n *   u1 tag = ITEM_Object; // 7\n *   u2 cpool_index;\n * }\n * </pre>\n *\n * The Uninitialized_variable_info indicates that the location contains the\n * verification type uninitialized(offset). The offset item indicates the offset\n * of the new instruction that created the object being stored in the location.\n *\n * <pre>\n * Uninitialized_variable_info {\n *   u1 tag = ITEM_Uninitialized // 8\n *   uoffset offset;\n * }\n * </pre>\n *\n * @see \"ClassFileFormat-Java6.fm Page 138 Friday, April 15, 2005 3:22 PM\"\n *\n * @author Eugene Kuleshov\n */\npublic class StackMapTableAttribute extends Attribute {\n\n    /**\n     * Frame has exactly the same locals as the previous stack map frame and\n     * number of stack items is zero.\n     */\n    // to 63 (0-3f)\n    public static final int SAME_FRAME = 0;\n\n    /**\n     * Frame has exactly the same locals as the previous stack map frame and\n     * number of stack items is 1\n     */\n    // to 127\n    public static final int SAME_LOCALS_1_STACK_ITEM_FRAME = 64;\n\n    // (40-7f)\n    /**\n     * Reserved for future use\n     */\n    public static final int RESERVED = 128;\n\n    /**\n     * Frame has exactly the same locals as the previous stack map frame and\n     * number of stack items is 1. Offset is bigger then 63;\n     */\n    // f7\n    public static final int SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED = 247;\n\n    /**\n     * Frame where current locals are the same as the locals in the previous\n     * frame, except that the k last locals are absent. The value of k is given\n     * by the formula 251-frame_type.\n     */\n    // to 250 (f8-fA)\n    public static final int CHOP_FRAME = 248;\n\n    /**\n     * Frame has exactly the same locals as the previous stack map frame and\n     * number of stack items is zero. Offset is bigger then 63;\n     */\n    // fb\n    public static final int SAME_FRAME_EXTENDED = 251;\n\n    /**\n     * Frame where current locals are the same as the locals in the previous\n     * frame, except that k additional locals are defined. The value of k is\n     * given by the formula frame_type-251.\n     */\n    // to 254 // fc-fe\n    public static final int APPEND_FRAME = 252;\n\n    /**\n     * Full frame\n     */\n    // ff\n    public static final int FULL_FRAME = 255;\n\n    private static final int MAX_SHORT = 65535;\n\n    /**\n     * A <code>List</code> of <code>StackMapFrame</code> instances.\n     */\n    private List frames;\n\n    public StackMapTableAttribute() {\n        super(\"StackMapTable\");\n    }\n\n    public StackMapTableAttribute(List frames) {\n        this();\n        this.frames = frames;\n    }\n\n    public List getFrames() {\n        return frames;\n    }\n\n    public StackMapFrame getFrame(Label label) {\n        for (int i = 0; i < frames.size(); i++) {\n            StackMapFrame frame = (StackMapFrame) frames.get(i);\n            if (frame.label == label) {\n                return frame;\n            }\n        }\n        return null;\n    }\n\n    public boolean isUnknown() {\n        return false;\n    }\n\n    public boolean isCodeAttribute() {\n        return true;\n    }\n\n    protected Attribute read(ClassReader cr, int off, int len, char[] buf, int codeOff, Label[] labels) {\n        ArrayList frames = new ArrayList();\n        // note that this is not the size of Code attribute\n        boolean isExtCodeSize = cr.readInt(codeOff + 4) > MAX_SHORT;\n        boolean isExtLocals = cr.readUnsignedShort(codeOff + 2) > MAX_SHORT;\n        boolean isExtStack = cr.readUnsignedShort(codeOff) > MAX_SHORT;\n        int offset = 0;\n        int methodOff = getMethodOff(cr, codeOff, buf);\n        StackMapFrame frame = new StackMapFrame(getLabel(offset, labels), // owner\n        calculateLocals(// owner\n        cr.readClass(cr.header + 2, buf), // method access\n        cr.readUnsignedShort(methodOff), // method name\n        cr.readUTF8(methodOff + 2, buf), // method desc\n        cr.readUTF8(methodOff + 4, buf)), Collections.EMPTY_LIST);\n        frames.add(frame);\n        // System.err.println( cr.readUTF8( methodOff + 2, buf));\n        // System.err.println( offset +\" delta:\" + 0 +\" : \"+ frame);\n        int size;\n        if (isExtCodeSize) {\n            size = cr.readInt(off);\n            off += 4;\n        } else {\n            size = cr.readUnsignedShort(off);\n            off += 2;\n        }\n        for (; size > 0; size--) {\n            // & 0xff;\n            int tag = cr.readByte(off);\n            off++;\n            List stack;\n            List locals;\n            int offsetDelta;\n            if (tag < SAME_LOCALS_1_STACK_ITEM_FRAME) {\n                // SAME_FRAME\n                offsetDelta = tag;\n                locals = new ArrayList(frame.locals);\n                stack = Collections.EMPTY_LIST;\n            } else if (tag < RESERVED) {\n                // SAME_LOCALS_1_STACK_ITEM_FRAME\n                offsetDelta = tag - SAME_LOCALS_1_STACK_ITEM_FRAME;\n                locals = new ArrayList(frame.locals);\n                stack = new ArrayList();\n                // read verification_type_info stack[1];\n                off = readType(stack, isExtCodeSize, cr, off, labels, buf);\n            } else {\n                if (isExtCodeSize) {\n                    offsetDelta = cr.readInt(off);\n                    off += 4;\n                } else {\n                    offsetDelta = cr.readUnsignedShort(off);\n                    off += 2;\n                }\n                if (tag == SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {\n                    // SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED\n                    locals = new ArrayList(frame.locals);\n                    stack = new ArrayList();\n                    // read verification_type_info stack[1];\n                    off = readType(stack, isExtCodeSize, cr, off, labels, buf);\n                } else if (tag >= CHOP_FRAME && tag < SAME_FRAME_EXTENDED) {\n                    // CHOP_FRAME\n                    stack = Collections.EMPTY_LIST;\n                    int k = SAME_FRAME_EXTENDED - tag;\n                    // copy locals from prev frame and chop last k\n                    locals = new ArrayList(frame.locals.subList(0, frame.locals.size() - k));\n                } else if (tag == SAME_FRAME_EXTENDED) {\n                    // SAME_FRAME_EXTENDED\n                    stack = Collections.EMPTY_LIST;\n                    locals = new ArrayList(frame.locals);\n                } else if (/* tag>=APPEND && */\n                tag < FULL_FRAME) {\n                    // APPEND_FRAME\n                    stack = Collections.EMPTY_LIST;\n                    // copy locals from prev frame and append new k\n                    locals = new ArrayList(frame.locals);\n                    for (int k = tag - SAME_FRAME_EXTENDED; k > 0; k--) {\n                        off = readType(locals, isExtCodeSize, cr, off, labels, buf);\n                    }\n                } else if (tag == FULL_FRAME) {\n                    // FULL_FRAME\n                    // read verification_type_info locals[number_of_locals];\n                    locals = new ArrayList();\n                    off = readTypes(locals, isExtLocals, isExtCodeSize, cr, off, labels, buf);\n                    // read verification_type_info stack[number_of_stack_items];\n                    stack = new ArrayList();\n                    off = readTypes(stack, isExtStack, isExtCodeSize, cr, off, labels, buf);\n                } else {\n                    throw new RuntimeException(\"Unknown frame type \" + tag + \" after offset \" + offset);\n                }\n            }\n            offset += offsetDelta;\n            Label offsetLabel = getLabel(offset, labels);\n            frame = new StackMapFrame(offsetLabel, locals, stack);\n            frames.add(frame);\n            // System.err.println( tag +\" \" + offset +\" delta:\" + offsetDelta +\n            // \" frameType:\"+ frameType+\" : \"+ frame);\n            offset++;\n        }\n        return new StackMapTableAttribute(frames);\n    }\n\n    protected ByteVector write(ClassWriter cw, byte[] code, int len, int maxStack, int maxLocals) {\n        ByteVector bv = new ByteVector();\n        // TODO verify this value (MAX_SHORT)\n        boolean isExtCodeSize = code != null && code.length > MAX_SHORT;\n        writeSize(frames.size() - 1, bv, isExtCodeSize);\n        if (frames.size() < 2) {\n            return bv;\n        }\n        boolean isExtLocals = maxLocals > MAX_SHORT;\n        boolean isExtStack = maxStack > MAX_SHORT;\n        // skip the first frame\n        StackMapFrame frame = (StackMapFrame) frames.get(0);\n        List locals = frame.locals;\n        int offset = frame.label.getOffset();\n        for (int i = 1; i < frames.size(); i++) {\n            frame = (StackMapFrame) frames.get(i);\n            List clocals = frame.locals;\n            List cstack = frame.stack;\n            int coffset = frame.label.getOffset();\n            int clocalsSize = clocals.size();\n            int cstackSize = cstack.size();\n            int localsSize = locals.size();\n            int delta = coffset - offset;\n            int type = FULL_FRAME;\n            int k = 0;\n            if (cstackSize == 0) {\n                k = clocalsSize - localsSize;\n                switch(k) {\n                    case -3:\n                    case -2:\n                    case -1:\n                        // CHOP or FULL\n                        type = CHOP_FRAME;\n                        // for full_frame check\n                        localsSize = clocalsSize;\n                        break;\n                    case 0:\n                        // SAME, SAME_EXTENDED or FULL\n                        type = delta < 64 ? SAME_FRAME : SAME_FRAME_EXTENDED;\n                        break;\n                    case 1:\n                    case 2:\n                    case 3:\n                        // APPEND or FULL\n                        type = APPEND_FRAME;\n                        break;\n                }\n            } else if (localsSize == clocalsSize && cstackSize == 1) {\n                // SAME_LOCAL_1_STACK or FULL\n                type = delta < 63 ? SAME_LOCALS_1_STACK_ITEM_FRAME : SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED;\n            }\n            if (type != FULL_FRAME) {\n                // verify if stack and locals are the same\n                for (int j = 0; j < localsSize && type != FULL_FRAME; j++) {\n                    if (!locals.get(j).equals(clocals.get(j)))\n                        type = FULL_FRAME;\n                }\n            }\n            switch(type) {\n                case SAME_FRAME:\n                    bv.putByte(delta);\n                    break;\n                case SAME_LOCALS_1_STACK_ITEM_FRAME:\n                    bv.putByte(SAME_LOCALS_1_STACK_ITEM_FRAME + delta);\n                    writeTypeInfos(bv, cw, cstack, 0, 1);\n                    break;\n                case SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED:\n                    bv.putByte(SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED);\n                    writeSize(delta, bv, isExtCodeSize);\n                    writeTypeInfos(bv, cw, cstack, 0, 1);\n                    break;\n                case SAME_FRAME_EXTENDED:\n                    bv.putByte(SAME_FRAME_EXTENDED);\n                    writeSize(delta, bv, isExtCodeSize);\n                    break;\n                case CHOP_FRAME:\n                    // negative k\n                    bv.putByte(SAME_FRAME_EXTENDED + k);\n                    writeSize(delta, bv, isExtCodeSize);\n                    break;\n                case APPEND_FRAME:\n                    // positive k\n                    bv.putByte(SAME_FRAME_EXTENDED + k);\n                    writeSize(delta, bv, isExtCodeSize);\n                    writeTypeInfos(bv, cw, clocals, clocalsSize - 1, clocalsSize);\n                    break;\n                case FULL_FRAME:\n                    bv.putByte(FULL_FRAME);\n                    writeSize(delta, bv, isExtCodeSize);\n                    writeSize(clocalsSize, bv, isExtLocals);\n                    writeTypeInfos(bv, cw, clocals, 0, clocalsSize);\n                    writeSize(cstackSize, bv, isExtStack);\n                    writeTypeInfos(bv, cw, cstack, 0, cstackSize);\n                    break;\n                default:\n                    throw new RuntimeException();\n            }\n            // compensating non first offset\n            offset = coffset + 1;\n            locals = clocals;\n        }\n        return bv;\n    }\n\n    private void writeSize(int delta, ByteVector bv, boolean isExt) {\n        if (isExt) {\n            bv.putInt(delta);\n        } else {\n            bv.putShort(delta);\n        }\n    }\n\n    private void writeTypeInfos(ByteVector bv, ClassWriter cw, List info, int start, int end) {\n        for (int j = start; j < end; j++) {\n            StackMapType typeInfo = (StackMapType) info.get(j);\n            bv.putByte(typeInfo.getType());\n            switch(typeInfo.getType()) {\n                case //\n                StackMapType.ITEM_Object:\n                    bv.putShort(cw.newClass(typeInfo.getObject()));\n                    break;\n                case //\n                StackMapType.ITEM_Uninitialized:\n                    bv.putShort(typeInfo.getLabel().getOffset());\n                    break;\n            }\n        }\n    }\n\n    public static int getMethodOff(ClassReader cr, int codeOff, char[] buf) {\n        int off = cr.header + 6;\n        int interfacesCount = cr.readUnsignedShort(off);\n        off += 2 + interfacesCount * 2;\n        int fieldsCount = cr.readUnsignedShort(off);\n        off += 2;\n        for (; fieldsCount > 0; --fieldsCount) {\n            // field attributes\n            int attrCount = cr.readUnsignedShort(off + 6);\n            off += 8;\n            for (; attrCount > 0; --attrCount) {\n                off += 6 + cr.readInt(off + 2);\n            }\n        }\n        int methodsCount = cr.readUnsignedShort(off);\n        off += 2;\n        for (; methodsCount > 0; --methodsCount) {\n            int methodOff = off;\n            // method attributes\n            int attrCount = cr.readUnsignedShort(off + 6);\n            off += 8;\n            for (; attrCount > 0; --attrCount) {\n                String attrName = cr.readUTF8(off, buf);\n                off += 6;\n                if (attrName.equals(\"Code\")) {\n                    if (codeOff == off) {\n                        return methodOff;\n                    }\n                }\n                off += cr.readInt(off - 4);\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Use method signature and access flags to resolve initial locals state.\n     *\n     * @param className name of the method's owner class.\n     * @param access access flags of the method.\n     * @param methodName name of the method.\n     * @param methodDesc descriptor of the method.\n     * @return list of <code>StackMapType</code> instances representing locals\n     *         for an initial frame.\n     */\n    public static List calculateLocals(String className, int access, String methodName, String methodDesc) {\n        List locals = new ArrayList();\n        // TODO\n        if (\"<init>\".equals(methodName) && !className.equals(\"java/lang/Object\")) {\n            StackMapType typeInfo = StackMapType.getTypeInfo(StackMapType.ITEM_UninitializedThis);\n            // this\n            typeInfo.setObject(className);\n            locals.add(typeInfo);\n        } else if ((access & Opcodes.ACC_STATIC) == 0) {\n            StackMapType typeInfo = StackMapType.getTypeInfo(StackMapType.ITEM_Object);\n            // this\n            typeInfo.setObject(className);\n            locals.add(typeInfo);\n        }\n        Type[] types = Type.getArgumentTypes(methodDesc);\n        for (int i = 0; i < types.length; i++) {\n            Type t = types[i];\n            StackMapType smt;\n            switch(t.getSort()) {\n                case Type.LONG:\n                    smt = StackMapType.getTypeInfo(StackMapType.ITEM_Long);\n                    break;\n                case Type.DOUBLE:\n                    smt = StackMapType.getTypeInfo(StackMapType.ITEM_Double);\n                    break;\n                case Type.FLOAT:\n                    smt = StackMapType.getTypeInfo(StackMapType.ITEM_Float);\n                    break;\n                case Type.ARRAY:\n                case Type.OBJECT:\n                    smt = StackMapType.getTypeInfo(StackMapType.ITEM_Object);\n                    // TODO verify name\n                    smt.setObject(t.getDescriptor());\n                    break;\n                default:\n                    smt = StackMapType.getTypeInfo(StackMapType.ITEM_Integer);\n                    break;\n            }\n        }\n        return locals;\n    }\n\n    private int readTypes(List info, boolean isExt, boolean isExtCodeSize, ClassReader cr, int off, Label[] labels, char[] buf) {\n        int n = 0;\n        if (isExt) {\n            n = cr.readInt(off);\n            off += 4;\n        } else {\n            n = cr.readUnsignedShort(off);\n            off += 2;\n        }\n        for (; n > 0; n--) {\n            off = readType(info, isExtCodeSize, cr, off, labels, buf);\n        }\n        return off;\n    }\n\n    private int readType(List info, boolean isExtCodeSize, ClassReader cr, int off, Label[] labels, char[] buf) {\n        int itemType = cr.readByte(off++);\n        StackMapType typeInfo = StackMapType.getTypeInfo(itemType);\n        info.add(typeInfo);\n        switch(itemType) {\n            // case StackMapType.ITEM_Long: //\n            // case StackMapType.ITEM_Double: //\n            // info.add(StackMapType.getTypeInfo(StackMapType.ITEM_Top));\n            // break;\n            case //\n            StackMapType.ITEM_Object:\n                typeInfo.setObject(cr.readClass(off, buf));\n                off += 2;\n                break;\n            case //\n            StackMapType.ITEM_Uninitialized:\n                int offset;\n                if (isExtCodeSize) {\n                    offset = cr.readInt(off);\n                    off += 4;\n                } else {\n                    offset = cr.readUnsignedShort(off);\n                    off += 2;\n                }\n                typeInfo.setLabel(getLabel(offset, labels));\n                break;\n        }\n        return off;\n    }\n\n    private Label getLabel(int offset, Label[] labels) {\n        Label l = labels[offset];\n        if (l != null) {\n            return l;\n        }\n        return labels[offset] = new Label();\n    }\n\n    public String toString() {\n        StringBuffer sb = new StringBuffer(\"StackMapTable[\");\n        for (int i = 0; i < frames.size(); i++) {\n            sb.append('\\n').append('[').append(frames.get(i)).append(']');\n        }\n        sb.append(\"\\n]\");\n        return sb.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/attrs/StackMapTableAttributeTest3.java",
		"test_prompt": "// StackMapTableAttributeTest3.java\npackage org.objectweb.asm.jip.attrs;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport org.objectweb.asm.jip.Attribute;\nimport org.objectweb.asm.jip.ByteVector;\nimport org.objectweb.asm.jip.ClassReader;\nimport org.objectweb.asm.jip.ClassWriter;\nimport org.objectweb.asm.jip.Label;\nimport org.objectweb.asm.jip.Opcodes;\nimport org.objectweb.asm.jip.Type;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StackMapTableAttribute}.\n* It contains ten unit test cases for the {@link StackMapTableAttribute#calculateLocals(String, int, String, String)} method.\n*/\nclass StackMapTableAttributeTest3 {"
	},
	{
		"original_code": "// Type.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\n\n/**\n * A Java type. This class can be used to make it easier to manipulate type and\n * method descriptors.\n *\n * @author Eric Bruneton\n * @author Chris Nokleberg\n */\npublic class Type {\n\n    /**\n     * The sort of the <tt>void</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int VOID = 0;\n\n    /**\n     * The sort of the <tt>boolean</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int BOOLEAN = 1;\n\n    /**\n     * The sort of the <tt>char</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int CHAR = 2;\n\n    /**\n     * The sort of the <tt>byte</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int BYTE = 3;\n\n    /**\n     * The sort of the <tt>short</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int SHORT = 4;\n\n    /**\n     * The sort of the <tt>int</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int INT = 5;\n\n    /**\n     * The sort of the <tt>float</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int FLOAT = 6;\n\n    /**\n     * The sort of the <tt>long</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int LONG = 7;\n\n    /**\n     * The sort of the <tt>double</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int DOUBLE = 8;\n\n    /**\n     * The sort of array reference types. See {@link #getSort getSort}.\n     */\n    public static final int ARRAY = 9;\n\n    /**\n     * The sort of object reference type. See {@link #getSort getSort}.\n     */\n    public static final int OBJECT = 10;\n\n    /**\n     * The <tt>void</tt> type.\n     */\n    public static final Type VOID_TYPE = new Type(VOID, null, ('V' << 24) | (5 << 16) | (0 << 8) | 0, 1);\n\n    /**\n     * The <tt>boolean</tt> type.\n     */\n    public static final Type BOOLEAN_TYPE = new Type(BOOLEAN, null, ('Z' << 24) | (0 << 16) | (5 << 8) | 1, 1);\n\n    /**\n     * The <tt>char</tt> type.\n     */\n    public static final Type CHAR_TYPE = new Type(CHAR, null, ('C' << 24) | (0 << 16) | (6 << 8) | 1, 1);\n\n    /**\n     * The <tt>byte</tt> type.\n     */\n    public static final Type BYTE_TYPE = new Type(BYTE, null, ('B' << 24) | (0 << 16) | (5 << 8) | 1, 1);\n\n    /**\n     * The <tt>short</tt> type.\n     */\n    public static final Type SHORT_TYPE = new Type(SHORT, null, ('S' << 24) | (0 << 16) | (7 << 8) | 1, 1);\n\n    /**\n     * The <tt>int</tt> type.\n     */\n    public static final Type INT_TYPE = new Type(INT, null, ('I' << 24) | (0 << 16) | (0 << 8) | 1, 1);\n\n    /**\n     * The <tt>float</tt> type.\n     */\n    public static final Type FLOAT_TYPE = new Type(FLOAT, null, ('F' << 24) | (2 << 16) | (2 << 8) | 1, 1);\n\n    /**\n     * The <tt>long</tt> type.\n     */\n    public static final Type LONG_TYPE = new Type(LONG, null, ('J' << 24) | (1 << 16) | (1 << 8) | 2, 1);\n\n    /**\n     * The <tt>double</tt> type.\n     */\n    public static final Type DOUBLE_TYPE = new Type(DOUBLE, null, ('D' << 24) | (3 << 16) | (3 << 8) | 2, 1);\n\n    // ------------------------------------------------------------------------\n    // Fields\n    // ------------------------------------------------------------------------\n    /**\n     * The sort of this Java type.\n     */\n    private final int sort;\n\n    /**\n     * A buffer containing the internal name of this Java type. This field is\n     * only used for reference types.\n     */\n    private final char[] buf;\n\n    /**\n     * The offset of the internal name of this Java type in {@link #buf buf} or,\n     * for primitive types, the size, descriptor and getOpcode offsets for this\n     * type (byte 0 contains the size, byte 1 the descriptor, byte 2 the offset\n     * for IALOAD or IASTORE, byte 3 the offset for all other instructions).\n     */\n    private final int off;\n\n    /**\n     * The length of the internal name of this Java type.\n     */\n    private final int len;\n\n    // ------------------------------------------------------------------------\n    // Constructors\n    // ------------------------------------------------------------------------\n    /**\n     * Constructs a reference type.\n     *\n     * @param sort the sort of the reference type to be constructed.\n     * @param buf a buffer containing the descriptor of the previous type.\n     * @param off the offset of this descriptor in the previous buffer.\n     * @param len the length of this descriptor.\n     */\n    private Type(final int sort, final char[] buf, final int off, final int len) {\n        this.sort = sort;\n        this.buf = buf;\n        this.off = off;\n        this.len = len;\n    }\n\n    /**\n     * Returns the Java type corresponding to the given type descriptor.\n     *\n     * @param typeDescriptor a type descriptor.\n     * @return the Java type corresponding to the given type descriptor.\n     */\n    public static Type getType(final String typeDescriptor) {\n        return getType(typeDescriptor.toCharArray(), 0);\n    }\n\n    /**\n     * Returns the Java type corresponding to the given internal name.\n     *\n     * @param internalName an internal name.\n     * @return the Java type corresponding to the given internal name.\n     */\n    public static Type getObjectType(final String internalName) {\n        char[] buf = internalName.toCharArray();\n        return new Type(buf[0] == '[' ? ARRAY : OBJECT, buf, 0, buf.length);\n    }\n\n    /**\n     * Returns the Java type corresponding to the given class.\n     *\n     * @param c a class.\n     * @return the Java type corresponding to the given class.\n     */\n    public static Type getType(final Class c) {\n        if (c.isPrimitive()) {\n            if (c == Integer.TYPE) {\n                return INT_TYPE;\n            } else if (c == Void.TYPE) {\n                return VOID_TYPE;\n            } else if (c == Boolean.TYPE) {\n                return BOOLEAN_TYPE;\n            } else if (c == Byte.TYPE) {\n                return BYTE_TYPE;\n            } else if (c == Character.TYPE) {\n                return CHAR_TYPE;\n            } else if (c == Short.TYPE) {\n                return SHORT_TYPE;\n            } else if (c == Double.TYPE) {\n                return DOUBLE_TYPE;\n            } else if (c == Float.TYPE) {\n                return FLOAT_TYPE;\n            } else /* if (c == Long.TYPE) */\n            {\n                return LONG_TYPE;\n            }\n        } else {\n            return getType(getDescriptor(c));\n        }\n    }\n\n    /**\n     * Returns the Java types corresponding to the argument types of the given\n     * method descriptor.\n     *\n     * @param methodDescriptor a method descriptor.\n     * @return the Java types corresponding to the argument types of the given\n     *         method descriptor.\n     */\n    public static Type[] getArgumentTypes(final String methodDescriptor) {\n        char[] buf = methodDescriptor.toCharArray();\n        int off = 1;\n        int size = 0;\n        while (true) {\n            char car = buf[off++];\n            if (car == ')') {\n                break;\n            } else if (car == 'L') {\n                while (buf[off++] != ';') {\n                }\n                ++size;\n            } else if (car != '[') {\n                ++size;\n            }\n        }\n        Type[] args = new Type[size];\n        off = 1;\n        size = 0;\n        while (buf[off] != ')') {\n            args[size] = getType(buf, off);\n            off += args[size].len + (args[size].sort == OBJECT ? 2 : 0);\n            size += 1;\n        }\n        return args;\n    }\n\n    /**\n     * Returns the Java types corresponding to the argument types of the given\n     * method.\n     *\n     * @param method a method.\n     * @return the Java types corresponding to the argument types of the given\n     *         method.\n     */\n    public static Type[] getArgumentTypes(final Method method) {\n        Class[] classes = method.getParameterTypes();\n        Type[] types = new Type[classes.length];\n        for (int i = classes.length - 1; i >= 0; --i) {\n            types[i] = getType(classes[i]);\n        }\n        return types;\n    }\n\n    /**\n     * Returns the Java type corresponding to the return type of the given\n     * method descriptor.\n     *\n     * @param methodDescriptor a method descriptor.\n     * @return the Java type corresponding to the return type of the given\n     *         method descriptor.\n     */\n    public static Type getReturnType(final String methodDescriptor) {\n        char[] buf = methodDescriptor.toCharArray();\n        return getType(buf, methodDescriptor.indexOf(')') + 1);\n    }\n\n    /**\n     * Returns the Java type corresponding to the return type of the given\n     * method.\n     *\n     * @param method a method.\n     * @return the Java type corresponding to the return type of the given\n     *         method.\n     */\n    public static Type getReturnType(final Method method) {\n        return getType(method.getReturnType());\n    }\n\n    /**\n     * Computes the size of the arguments and of the return value of a method.\n     *\n     * @param desc the descriptor of a method.\n     * @return the size of the arguments of the method (plus one for the\n     *         implicit this argument), argSize, and the size of its return\n     *         value, retSize, packed into a single int i =\n     *         <tt>(argSize << 2) | retSize</tt> (argSize is therefore equal\n     *         to <tt>i >> 2</tt>, and retSize to <tt>i & 0x03</tt>).\n     */\n    public static int getArgumentsAndReturnSizes(final String desc) {\n        int n = 1;\n        int c = 1;\n        while (true) {\n            char car = desc.charAt(c++);\n            if (car == ')') {\n                car = desc.charAt(c);\n                return n << 2 | (car == 'V' ? 0 : (car == 'D' || car == 'J' ? 2 : 1));\n            } else if (car == 'L') {\n                while (desc.charAt(c++) != ';') {\n                }\n                n += 1;\n            } else if (car == '[') {\n                while ((car = desc.charAt(c)) == '[') {\n                    ++c;\n                }\n                if (car == 'D' || car == 'J') {\n                    n -= 1;\n                }\n            } else if (car == 'D' || car == 'J') {\n                n += 2;\n            } else {\n                n += 1;\n            }\n        }\n    }\n\n    /**\n     * Returns the Java type corresponding to the given type descriptor.\n     *\n     * @param buf a buffer containing a type descriptor.\n     * @param off the offset of this descriptor in the previous buffer.\n     * @return the Java type corresponding to the given type descriptor.\n     */\n    private static Type getType(final char[] buf, final int off) {\n        int len;\n        switch(buf[off]) {\n            case 'V':\n                return VOID_TYPE;\n            case 'Z':\n                return BOOLEAN_TYPE;\n            case 'C':\n                return CHAR_TYPE;\n            case 'B':\n                return BYTE_TYPE;\n            case 'S':\n                return SHORT_TYPE;\n            case 'I':\n                return INT_TYPE;\n            case 'F':\n                return FLOAT_TYPE;\n            case 'J':\n                return LONG_TYPE;\n            case 'D':\n                return DOUBLE_TYPE;\n            case '[':\n                len = 1;\n                while (buf[off + len] == '[') {\n                    ++len;\n                }\n                if (buf[off + len] == 'L') {\n                    ++len;\n                    while (buf[off + len] != ';') {\n                        ++len;\n                    }\n                }\n                return new Type(ARRAY, buf, off, len + 1);\n            // case 'L':\n            default:\n                len = 1;\n                while (buf[off + len] != ';') {\n                    ++len;\n                }\n                return new Type(OBJECT, buf, off + 1, len - 1);\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Accessors\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the sort of this Java type.\n     *\n     * @return {@link #VOID VOID}, {@link #BOOLEAN BOOLEAN},\n     *         {@link #CHAR CHAR}, {@link #BYTE BYTE}, {@link #SHORT SHORT},\n     *         {@link #INT INT}, {@link #FLOAT FLOAT}, {@link #LONG LONG},\n     *         {@link #DOUBLE DOUBLE}, {@link #ARRAY ARRAY} or\n     *         {@link #OBJECT OBJECT}.\n     */\n    public int getSort() {\n        return sort;\n    }\n\n    /**\n     * Returns the number of dimensions of this array type. This method should\n     * only be used for an array type.\n     *\n     * @return the number of dimensions of this array type.\n     */\n    public int getDimensions() {\n        int i = 1;\n        while (buf[off + i] == '[') {\n            ++i;\n        }\n        return i;\n    }\n\n    /**\n     * Returns the type of the elements of this array type. This method should\n     * only be used for an array type.\n     *\n     * @return Returns the type of the elements of this array type.\n     */\n    public Type getElementType() {\n        return getType(buf, off + getDimensions());\n    }\n\n    /**\n     * Returns the name of the class corresponding to this type.\n     *\n     * @return the fully qualified name of the class corresponding to this type.\n     */\n    public String getClassName() {\n        switch(sort) {\n            case VOID:\n                return \"void\";\n            case BOOLEAN:\n                return \"boolean\";\n            case CHAR:\n                return \"char\";\n            case BYTE:\n                return \"byte\";\n            case SHORT:\n                return \"short\";\n            case INT:\n                return \"int\";\n            case FLOAT:\n                return \"float\";\n            case LONG:\n                return \"long\";\n            case DOUBLE:\n                return \"double\";\n            case ARRAY:\n                StringBuffer b = new StringBuffer(getElementType().getClassName());\n                for (int i = getDimensions(); i > 0; --i) {\n                    b.append(\"[]\");\n                }\n                return b.toString();\n            // case OBJECT:\n            default:\n                return new String(buf, off, len).replace('/', '.');\n        }\n    }\n\n    /**\n     * Returns the internal name of the class corresponding to this object or\n     * array type. The internal name of a class is its fully qualified name (as\n     * returned by Class.getName(), where '.' are replaced by '/'. This method\n     * should only be used for an object or array type.\n     *\n     * @return the internal name of the class corresponding to this object type.\n     */\n    public String getInternalName() {\n        return new String(buf, off, len);\n    }\n\n    // ------------------------------------------------------------------------\n    // Conversion to type descriptors\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the descriptor corresponding to this Java type.\n     *\n     * @return the descriptor corresponding to this Java type.\n     */\n    public String getDescriptor() {\n        StringBuffer buf = new StringBuffer();\n        getDescriptor(buf);\n        return buf.toString();\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given argument and return\n     * types.\n     *\n     * @param returnType the return type of the method.\n     * @param argumentTypes the argument types of the method.\n     * @return the descriptor corresponding to the given argument and return\n     *         types.\n     */\n    public static String getMethodDescriptor(final Type returnType, final Type[] argumentTypes) {\n        StringBuffer buf = new StringBuffer();\n        buf.append('(');\n        for (int i = 0; i < argumentTypes.length; ++i) {\n            argumentTypes[i].getDescriptor(buf);\n        }\n        buf.append(')');\n        returnType.getDescriptor(buf);\n        return buf.toString();\n    }\n\n    /**\n     * Appends the descriptor corresponding to this Java type to the given\n     * string buffer.\n     *\n     * @param buf the string buffer to which the descriptor must be appended.\n     */\n    private void getDescriptor(final StringBuffer buf) {\n        if (this.buf == null) {\n            // descriptor is in byte 3 of 'off' for primitive types (buf == null)\n            buf.append((char) ((off & 0xFF000000) >>> 24));\n        } else if (sort == ARRAY) {\n            buf.append(this.buf, off, len);\n        } else {\n            // sort == OBJECT\n            buf.append('L');\n            buf.append(this.buf, off, len);\n            buf.append(';');\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Direct conversion from classes to type descriptors,\n    // without intermediate Type objects\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the internal name of the given class. The internal name of a\n     * class is its fully qualified name, as returned by Class.getName(), where\n     * '.' are replaced by '/'.\n     *\n     * @param c an object or array class.\n     * @return the internal name of the given class.\n     */\n    public static String getInternalName(final Class c) {\n        return c.getName().replace('.', '/');\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given Java type.\n     *\n     * @param c an object class, a primitive class or an array class.\n     * @return the descriptor corresponding to the given class.\n     */\n    public static String getDescriptor(final Class c) {\n        StringBuffer buf = new StringBuffer();\n        getDescriptor(buf, c);\n        return buf.toString();\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given constructor.\n     *\n     * @param c a {@link Constructor Constructor} object.\n     * @return the descriptor of the given constructor.\n     */\n    public static String getConstructorDescriptor(final Constructor c) {\n        Class[] parameters = c.getParameterTypes();\n        StringBuffer buf = new StringBuffer();\n        buf.append('(');\n        for (int i = 0; i < parameters.length; ++i) {\n            getDescriptor(buf, parameters[i]);\n        }\n        return buf.append(\")V\").toString();\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given method.\n     *\n     * @param m a {@link Method Method} object.\n     * @return the descriptor of the given method.\n     */\n    public static String getMethodDescriptor(final Method m) {\n        Class[] parameters = m.getParameterTypes();\n        StringBuffer buf = new StringBuffer();\n        buf.append('(');\n        for (int i = 0; i < parameters.length; ++i) {\n            getDescriptor(buf, parameters[i]);\n        }\n        buf.append(')');\n        getDescriptor(buf, m.getReturnType());\n        return buf.toString();\n    }\n\n    /**\n     * Appends the descriptor of the given class to the given string buffer.\n     *\n     * @param buf the string buffer to which the descriptor must be appended.\n     * @param c the class whose descriptor must be computed.\n     */\n    private static void getDescriptor(final StringBuffer buf, final Class c) {\n        Class d = c;\n        while (true) {\n            if (d.isPrimitive()) {\n                char car;\n                if (d == Integer.TYPE) {\n                    car = 'I';\n                } else if (d == Void.TYPE) {\n                    car = 'V';\n                } else if (d == Boolean.TYPE) {\n                    car = 'Z';\n                } else if (d == Byte.TYPE) {\n                    car = 'B';\n                } else if (d == Character.TYPE) {\n                    car = 'C';\n                } else if (d == Short.TYPE) {\n                    car = 'S';\n                } else if (d == Double.TYPE) {\n                    car = 'D';\n                } else if (d == Float.TYPE) {\n                    car = 'F';\n                } else /* if (d == Long.TYPE) */\n                {\n                    car = 'J';\n                }\n                buf.append(car);\n                return;\n            } else if (d.isArray()) {\n                buf.append('[');\n                d = d.getComponentType();\n            } else {\n                buf.append('L');\n                String name = d.getName();\n                int len = name.length();\n                for (int i = 0; i < len; ++i) {\n                    char car = name.charAt(i);\n                    buf.append(car == '.' ? '/' : car);\n                }\n                buf.append(';');\n                return;\n            }\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Corresponding size and opcodes\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the size of values of this type.\n     *\n     * @return the size of values of this type, i.e., 2 for <tt>long</tt> and\n     *         <tt>double</tt>, 0 for <tt>void</tt> and 1 otherwise.\n     */\n    public int getSize() {\n        // the size is in byte 0 of 'off' for primitive types (buf == null)\n        return buf == null ? (off & 0xFF) : 1;\n    }\n\n    /**\n     * Returns a JVM instruction opcode adapted to this Java type.\n     *\n     * @param opcode a JVM instruction opcode. This opcode must be one of ILOAD,\n     *        ISTORE, IALOAD, IASTORE, IADD, ISUB, IMUL, IDIV, IREM, INEG, ISHL,\n     *        ISHR, IUSHR, IAND, IOR, IXOR and IRETURN.\n     * @return an opcode that is similar to the given opcode, but adapted to\n     *         this Java type. For example, if this type is <tt>float</tt> and\n     *         <tt>opcode</tt> is IRETURN, this method returns FRETURN.\n     */\n    public int getOpcode(final int opcode) {\n        if (opcode == Opcodes.IALOAD || opcode == Opcodes.IASTORE) {\n            // the offset for IALOAD or IASTORE is in byte 1 of 'off' for\n            // primitive types (buf == null)\n            return opcode + (buf == null ? (off & 0xFF00) >> 8 : 4);\n        } else {\n            // the offset for other instructions is in byte 2 of 'off' for\n            // primitive types (buf == null)\n            return opcode + (buf == null ? (off & 0xFF0000) >> 16 : 4);\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Equals, hashCode and toString\n    // ------------------------------------------------------------------------\n    /**\n     * Tests if the given object is equal to this type.\n     *\n     * @param o the object to be compared to this type.\n     * @return <tt>true</tt> if the given object is equal to this type.\n     */\n    public boolean equals(final Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (!(o instanceof Type)) {\n            return false;\n        }\n        Type t = (Type) o;\n        if (sort != t.sort) {\n            return false;\n        }\n        if (sort == OBJECT || sort == ARRAY) {\n            if (len != t.len) {\n                return false;\n            }\n            for (int i = off, j = t.off, end = i + len; i < end; i++, j++) {\n                if (buf[i] != t.buf[j]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code value for this type.\n     *\n     * @return a hash code value for this type.\n     */\n    public int hashCode() {\n        int hc = 13 * sort;\n        if (sort == OBJECT || sort == ARRAY) {\n            for (int i = off, end = i + len; i < end; i++) {\n                hc = 17 * (hc + buf[i]);\n            }\n        }\n        return hc;\n    }\n\n    /**\n     * Returns a string representation of this type.\n     *\n     * @return the descriptor of this type.\n     */\n    public String toString() {\n        return getDescriptor();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/TypeTest0.java",
		"test_prompt": "// TypeTest0.java\npackage org.objectweb.asm.jip;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Type}.\n* It contains ten unit test cases for the {@link Type#getType(String)} method.\n*/\nclass TypeTest0 {"
	},
	{
		"original_code": "// Type.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\n\n/**\n * A Java type. This class can be used to make it easier to manipulate type and\n * method descriptors.\n *\n * @author Eric Bruneton\n * @author Chris Nokleberg\n */\npublic class Type {\n\n    /**\n     * The sort of the <tt>void</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int VOID = 0;\n\n    /**\n     * The sort of the <tt>boolean</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int BOOLEAN = 1;\n\n    /**\n     * The sort of the <tt>char</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int CHAR = 2;\n\n    /**\n     * The sort of the <tt>byte</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int BYTE = 3;\n\n    /**\n     * The sort of the <tt>short</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int SHORT = 4;\n\n    /**\n     * The sort of the <tt>int</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int INT = 5;\n\n    /**\n     * The sort of the <tt>float</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int FLOAT = 6;\n\n    /**\n     * The sort of the <tt>long</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int LONG = 7;\n\n    /**\n     * The sort of the <tt>double</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int DOUBLE = 8;\n\n    /**\n     * The sort of array reference types. See {@link #getSort getSort}.\n     */\n    public static final int ARRAY = 9;\n\n    /**\n     * The sort of object reference type. See {@link #getSort getSort}.\n     */\n    public static final int OBJECT = 10;\n\n    /**\n     * The <tt>void</tt> type.\n     */\n    public static final Type VOID_TYPE = new Type(VOID, null, ('V' << 24) | (5 << 16) | (0 << 8) | 0, 1);\n\n    /**\n     * The <tt>boolean</tt> type.\n     */\n    public static final Type BOOLEAN_TYPE = new Type(BOOLEAN, null, ('Z' << 24) | (0 << 16) | (5 << 8) | 1, 1);\n\n    /**\n     * The <tt>char</tt> type.\n     */\n    public static final Type CHAR_TYPE = new Type(CHAR, null, ('C' << 24) | (0 << 16) | (6 << 8) | 1, 1);\n\n    /**\n     * The <tt>byte</tt> type.\n     */\n    public static final Type BYTE_TYPE = new Type(BYTE, null, ('B' << 24) | (0 << 16) | (5 << 8) | 1, 1);\n\n    /**\n     * The <tt>short</tt> type.\n     */\n    public static final Type SHORT_TYPE = new Type(SHORT, null, ('S' << 24) | (0 << 16) | (7 << 8) | 1, 1);\n\n    /**\n     * The <tt>int</tt> type.\n     */\n    public static final Type INT_TYPE = new Type(INT, null, ('I' << 24) | (0 << 16) | (0 << 8) | 1, 1);\n\n    /**\n     * The <tt>float</tt> type.\n     */\n    public static final Type FLOAT_TYPE = new Type(FLOAT, null, ('F' << 24) | (2 << 16) | (2 << 8) | 1, 1);\n\n    /**\n     * The <tt>long</tt> type.\n     */\n    public static final Type LONG_TYPE = new Type(LONG, null, ('J' << 24) | (1 << 16) | (1 << 8) | 2, 1);\n\n    /**\n     * The <tt>double</tt> type.\n     */\n    public static final Type DOUBLE_TYPE = new Type(DOUBLE, null, ('D' << 24) | (3 << 16) | (3 << 8) | 2, 1);\n\n    // ------------------------------------------------------------------------\n    // Fields\n    // ------------------------------------------------------------------------\n    /**\n     * The sort of this Java type.\n     */\n    private final int sort;\n\n    /**\n     * A buffer containing the internal name of this Java type. This field is\n     * only used for reference types.\n     */\n    private final char[] buf;\n\n    /**\n     * The offset of the internal name of this Java type in {@link #buf buf} or,\n     * for primitive types, the size, descriptor and getOpcode offsets for this\n     * type (byte 0 contains the size, byte 1 the descriptor, byte 2 the offset\n     * for IALOAD or IASTORE, byte 3 the offset for all other instructions).\n     */\n    private final int off;\n\n    /**\n     * The length of the internal name of this Java type.\n     */\n    private final int len;\n\n    // ------------------------------------------------------------------------\n    // Constructors\n    // ------------------------------------------------------------------------\n    /**\n     * Constructs a reference type.\n     *\n     * @param sort the sort of the reference type to be constructed.\n     * @param buf a buffer containing the descriptor of the previous type.\n     * @param off the offset of this descriptor in the previous buffer.\n     * @param len the length of this descriptor.\n     */\n    private Type(final int sort, final char[] buf, final int off, final int len) {\n        this.sort = sort;\n        this.buf = buf;\n        this.off = off;\n        this.len = len;\n    }\n\n    /**\n     * Returns the Java type corresponding to the given type descriptor.\n     *\n     * @param typeDescriptor a type descriptor.\n     * @return the Java type corresponding to the given type descriptor.\n     */\n    public static Type getType(final String typeDescriptor) {\n        return getType(typeDescriptor.toCharArray(), 0);\n    }\n\n    /**\n     * Returns the Java type corresponding to the given internal name.\n     *\n     * @param internalName an internal name.\n     * @return the Java type corresponding to the given internal name.\n     */\n    public static Type getObjectType(final String internalName) {\n        char[] buf = internalName.toCharArray();\n        return new Type(buf[0] == '[' ? ARRAY : OBJECT, buf, 0, buf.length);\n    }\n\n    /**\n     * Returns the Java type corresponding to the given class.\n     *\n     * @param c a class.\n     * @return the Java type corresponding to the given class.\n     */\n    public static Type getType(final Class c) {\n        if (c.isPrimitive()) {\n            if (c == Integer.TYPE) {\n                return INT_TYPE;\n            } else if (c == Void.TYPE) {\n                return VOID_TYPE;\n            } else if (c == Boolean.TYPE) {\n                return BOOLEAN_TYPE;\n            } else if (c == Byte.TYPE) {\n                return BYTE_TYPE;\n            } else if (c == Character.TYPE) {\n                return CHAR_TYPE;\n            } else if (c == Short.TYPE) {\n                return SHORT_TYPE;\n            } else if (c == Double.TYPE) {\n                return DOUBLE_TYPE;\n            } else if (c == Float.TYPE) {\n                return FLOAT_TYPE;\n            } else /* if (c == Long.TYPE) */\n            {\n                return LONG_TYPE;\n            }\n        } else {\n            return getType(getDescriptor(c));\n        }\n    }\n\n    /**\n     * Returns the Java types corresponding to the argument types of the given\n     * method descriptor.\n     *\n     * @param methodDescriptor a method descriptor.\n     * @return the Java types corresponding to the argument types of the given\n     *         method descriptor.\n     */\n    public static Type[] getArgumentTypes(final String methodDescriptor) {\n        char[] buf = methodDescriptor.toCharArray();\n        int off = 1;\n        int size = 0;\n        while (true) {\n            char car = buf[off++];\n            if (car == ')') {\n                break;\n            } else if (car == 'L') {\n                while (buf[off++] != ';') {\n                }\n                ++size;\n            } else if (car != '[') {\n                ++size;\n            }\n        }\n        Type[] args = new Type[size];\n        off = 1;\n        size = 0;\n        while (buf[off] != ')') {\n            args[size] = getType(buf, off);\n            off += args[size].len + (args[size].sort == OBJECT ? 2 : 0);\n            size += 1;\n        }\n        return args;\n    }\n\n    /**\n     * Returns the Java types corresponding to the argument types of the given\n     * method.\n     *\n     * @param method a method.\n     * @return the Java types corresponding to the argument types of the given\n     *         method.\n     */\n    public static Type[] getArgumentTypes(final Method method) {\n        Class[] classes = method.getParameterTypes();\n        Type[] types = new Type[classes.length];\n        for (int i = classes.length - 1; i >= 0; --i) {\n            types[i] = getType(classes[i]);\n        }\n        return types;\n    }\n\n    /**\n     * Returns the Java type corresponding to the return type of the given\n     * method descriptor.\n     *\n     * @param methodDescriptor a method descriptor.\n     * @return the Java type corresponding to the return type of the given\n     *         method descriptor.\n     */\n    public static Type getReturnType(final String methodDescriptor) {\n        char[] buf = methodDescriptor.toCharArray();\n        return getType(buf, methodDescriptor.indexOf(')') + 1);\n    }\n\n    /**\n     * Returns the Java type corresponding to the return type of the given\n     * method.\n     *\n     * @param method a method.\n     * @return the Java type corresponding to the return type of the given\n     *         method.\n     */\n    public static Type getReturnType(final Method method) {\n        return getType(method.getReturnType());\n    }\n\n    /**\n     * Computes the size of the arguments and of the return value of a method.\n     *\n     * @param desc the descriptor of a method.\n     * @return the size of the arguments of the method (plus one for the\n     *         implicit this argument), argSize, and the size of its return\n     *         value, retSize, packed into a single int i =\n     *         <tt>(argSize << 2) | retSize</tt> (argSize is therefore equal\n     *         to <tt>i >> 2</tt>, and retSize to <tt>i & 0x03</tt>).\n     */\n    public static int getArgumentsAndReturnSizes(final String desc) {\n        int n = 1;\n        int c = 1;\n        while (true) {\n            char car = desc.charAt(c++);\n            if (car == ')') {\n                car = desc.charAt(c);\n                return n << 2 | (car == 'V' ? 0 : (car == 'D' || car == 'J' ? 2 : 1));\n            } else if (car == 'L') {\n                while (desc.charAt(c++) != ';') {\n                }\n                n += 1;\n            } else if (car == '[') {\n                while ((car = desc.charAt(c)) == '[') {\n                    ++c;\n                }\n                if (car == 'D' || car == 'J') {\n                    n -= 1;\n                }\n            } else if (car == 'D' || car == 'J') {\n                n += 2;\n            } else {\n                n += 1;\n            }\n        }\n    }\n\n    /**\n     * Returns the Java type corresponding to the given type descriptor.\n     *\n     * @param buf a buffer containing a type descriptor.\n     * @param off the offset of this descriptor in the previous buffer.\n     * @return the Java type corresponding to the given type descriptor.\n     */\n    private static Type getType(final char[] buf, final int off) {\n        int len;\n        switch(buf[off]) {\n            case 'V':\n                return VOID_TYPE;\n            case 'Z':\n                return BOOLEAN_TYPE;\n            case 'C':\n                return CHAR_TYPE;\n            case 'B':\n                return BYTE_TYPE;\n            case 'S':\n                return SHORT_TYPE;\n            case 'I':\n                return INT_TYPE;\n            case 'F':\n                return FLOAT_TYPE;\n            case 'J':\n                return LONG_TYPE;\n            case 'D':\n                return DOUBLE_TYPE;\n            case '[':\n                len = 1;\n                while (buf[off + len] == '[') {\n                    ++len;\n                }\n                if (buf[off + len] == 'L') {\n                    ++len;\n                    while (buf[off + len] != ';') {\n                        ++len;\n                    }\n                }\n                return new Type(ARRAY, buf, off, len + 1);\n            // case 'L':\n            default:\n                len = 1;\n                while (buf[off + len] != ';') {\n                    ++len;\n                }\n                return new Type(OBJECT, buf, off + 1, len - 1);\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Accessors\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the sort of this Java type.\n     *\n     * @return {@link #VOID VOID}, {@link #BOOLEAN BOOLEAN},\n     *         {@link #CHAR CHAR}, {@link #BYTE BYTE}, {@link #SHORT SHORT},\n     *         {@link #INT INT}, {@link #FLOAT FLOAT}, {@link #LONG LONG},\n     *         {@link #DOUBLE DOUBLE}, {@link #ARRAY ARRAY} or\n     *         {@link #OBJECT OBJECT}.\n     */\n    public int getSort() {\n        return sort;\n    }\n\n    /**\n     * Returns the number of dimensions of this array type. This method should\n     * only be used for an array type.\n     *\n     * @return the number of dimensions of this array type.\n     */\n    public int getDimensions() {\n        int i = 1;\n        while (buf[off + i] == '[') {\n            ++i;\n        }\n        return i;\n    }\n\n    /**\n     * Returns the type of the elements of this array type. This method should\n     * only be used for an array type.\n     *\n     * @return Returns the type of the elements of this array type.\n     */\n    public Type getElementType() {\n        return getType(buf, off + getDimensions());\n    }\n\n    /**\n     * Returns the name of the class corresponding to this type.\n     *\n     * @return the fully qualified name of the class corresponding to this type.\n     */\n    public String getClassName() {\n        switch(sort) {\n            case VOID:\n                return \"void\";\n            case BOOLEAN:\n                return \"boolean\";\n            case CHAR:\n                return \"char\";\n            case BYTE:\n                return \"byte\";\n            case SHORT:\n                return \"short\";\n            case INT:\n                return \"int\";\n            case FLOAT:\n                return \"float\";\n            case LONG:\n                return \"long\";\n            case DOUBLE:\n                return \"double\";\n            case ARRAY:\n                StringBuffer b = new StringBuffer(getElementType().getClassName());\n                for (int i = getDimensions(); i > 0; --i) {\n                    b.append(\"[]\");\n                }\n                return b.toString();\n            // case OBJECT:\n            default:\n                return new String(buf, off, len).replace('/', '.');\n        }\n    }\n\n    /**\n     * Returns the internal name of the class corresponding to this object or\n     * array type. The internal name of a class is its fully qualified name (as\n     * returned by Class.getName(), where '.' are replaced by '/'. This method\n     * should only be used for an object or array type.\n     *\n     * @return the internal name of the class corresponding to this object type.\n     */\n    public String getInternalName() {\n        return new String(buf, off, len);\n    }\n\n    // ------------------------------------------------------------------------\n    // Conversion to type descriptors\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the descriptor corresponding to this Java type.\n     *\n     * @return the descriptor corresponding to this Java type.\n     */\n    public String getDescriptor() {\n        StringBuffer buf = new StringBuffer();\n        getDescriptor(buf);\n        return buf.toString();\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given argument and return\n     * types.\n     *\n     * @param returnType the return type of the method.\n     * @param argumentTypes the argument types of the method.\n     * @return the descriptor corresponding to the given argument and return\n     *         types.\n     */\n    public static String getMethodDescriptor(final Type returnType, final Type[] argumentTypes) {\n        StringBuffer buf = new StringBuffer();\n        buf.append('(');\n        for (int i = 0; i < argumentTypes.length; ++i) {\n            argumentTypes[i].getDescriptor(buf);\n        }\n        buf.append(')');\n        returnType.getDescriptor(buf);\n        return buf.toString();\n    }\n\n    /**\n     * Appends the descriptor corresponding to this Java type to the given\n     * string buffer.\n     *\n     * @param buf the string buffer to which the descriptor must be appended.\n     */\n    private void getDescriptor(final StringBuffer buf) {\n        if (this.buf == null) {\n            // descriptor is in byte 3 of 'off' for primitive types (buf == null)\n            buf.append((char) ((off & 0xFF000000) >>> 24));\n        } else if (sort == ARRAY) {\n            buf.append(this.buf, off, len);\n        } else {\n            // sort == OBJECT\n            buf.append('L');\n            buf.append(this.buf, off, len);\n            buf.append(';');\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Direct conversion from classes to type descriptors,\n    // without intermediate Type objects\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the internal name of the given class. The internal name of a\n     * class is its fully qualified name, as returned by Class.getName(), where\n     * '.' are replaced by '/'.\n     *\n     * @param c an object or array class.\n     * @return the internal name of the given class.\n     */\n    public static String getInternalName(final Class c) {\n        return c.getName().replace('.', '/');\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given Java type.\n     *\n     * @param c an object class, a primitive class or an array class.\n     * @return the descriptor corresponding to the given class.\n     */\n    public static String getDescriptor(final Class c) {\n        StringBuffer buf = new StringBuffer();\n        getDescriptor(buf, c);\n        return buf.toString();\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given constructor.\n     *\n     * @param c a {@link Constructor Constructor} object.\n     * @return the descriptor of the given constructor.\n     */\n    public static String getConstructorDescriptor(final Constructor c) {\n        Class[] parameters = c.getParameterTypes();\n        StringBuffer buf = new StringBuffer();\n        buf.append('(');\n        for (int i = 0; i < parameters.length; ++i) {\n            getDescriptor(buf, parameters[i]);\n        }\n        return buf.append(\")V\").toString();\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given method.\n     *\n     * @param m a {@link Method Method} object.\n     * @return the descriptor of the given method.\n     */\n    public static String getMethodDescriptor(final Method m) {\n        Class[] parameters = m.getParameterTypes();\n        StringBuffer buf = new StringBuffer();\n        buf.append('(');\n        for (int i = 0; i < parameters.length; ++i) {\n            getDescriptor(buf, parameters[i]);\n        }\n        buf.append(')');\n        getDescriptor(buf, m.getReturnType());\n        return buf.toString();\n    }\n\n    /**\n     * Appends the descriptor of the given class to the given string buffer.\n     *\n     * @param buf the string buffer to which the descriptor must be appended.\n     * @param c the class whose descriptor must be computed.\n     */\n    private static void getDescriptor(final StringBuffer buf, final Class c) {\n        Class d = c;\n        while (true) {\n            if (d.isPrimitive()) {\n                char car;\n                if (d == Integer.TYPE) {\n                    car = 'I';\n                } else if (d == Void.TYPE) {\n                    car = 'V';\n                } else if (d == Boolean.TYPE) {\n                    car = 'Z';\n                } else if (d == Byte.TYPE) {\n                    car = 'B';\n                } else if (d == Character.TYPE) {\n                    car = 'C';\n                } else if (d == Short.TYPE) {\n                    car = 'S';\n                } else if (d == Double.TYPE) {\n                    car = 'D';\n                } else if (d == Float.TYPE) {\n                    car = 'F';\n                } else /* if (d == Long.TYPE) */\n                {\n                    car = 'J';\n                }\n                buf.append(car);\n                return;\n            } else if (d.isArray()) {\n                buf.append('[');\n                d = d.getComponentType();\n            } else {\n                buf.append('L');\n                String name = d.getName();\n                int len = name.length();\n                for (int i = 0; i < len; ++i) {\n                    char car = name.charAt(i);\n                    buf.append(car == '.' ? '/' : car);\n                }\n                buf.append(';');\n                return;\n            }\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Corresponding size and opcodes\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the size of values of this type.\n     *\n     * @return the size of values of this type, i.e., 2 for <tt>long</tt> and\n     *         <tt>double</tt>, 0 for <tt>void</tt> and 1 otherwise.\n     */\n    public int getSize() {\n        // the size is in byte 0 of 'off' for primitive types (buf == null)\n        return buf == null ? (off & 0xFF) : 1;\n    }\n\n    /**\n     * Returns a JVM instruction opcode adapted to this Java type.\n     *\n     * @param opcode a JVM instruction opcode. This opcode must be one of ILOAD,\n     *        ISTORE, IALOAD, IASTORE, IADD, ISUB, IMUL, IDIV, IREM, INEG, ISHL,\n     *        ISHR, IUSHR, IAND, IOR, IXOR and IRETURN.\n     * @return an opcode that is similar to the given opcode, but adapted to\n     *         this Java type. For example, if this type is <tt>float</tt> and\n     *         <tt>opcode</tt> is IRETURN, this method returns FRETURN.\n     */\n    public int getOpcode(final int opcode) {\n        if (opcode == Opcodes.IALOAD || opcode == Opcodes.IASTORE) {\n            // the offset for IALOAD or IASTORE is in byte 1 of 'off' for\n            // primitive types (buf == null)\n            return opcode + (buf == null ? (off & 0xFF00) >> 8 : 4);\n        } else {\n            // the offset for other instructions is in byte 2 of 'off' for\n            // primitive types (buf == null)\n            return opcode + (buf == null ? (off & 0xFF0000) >> 16 : 4);\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Equals, hashCode and toString\n    // ------------------------------------------------------------------------\n    /**\n     * Tests if the given object is equal to this type.\n     *\n     * @param o the object to be compared to this type.\n     * @return <tt>true</tt> if the given object is equal to this type.\n     */\n    public boolean equals(final Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (!(o instanceof Type)) {\n            return false;\n        }\n        Type t = (Type) o;\n        if (sort != t.sort) {\n            return false;\n        }\n        if (sort == OBJECT || sort == ARRAY) {\n            if (len != t.len) {\n                return false;\n            }\n            for (int i = off, j = t.off, end = i + len; i < end; i++, j++) {\n                if (buf[i] != t.buf[j]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code value for this type.\n     *\n     * @return a hash code value for this type.\n     */\n    public int hashCode() {\n        int hc = 13 * sort;\n        if (sort == OBJECT || sort == ARRAY) {\n            for (int i = off, end = i + len; i < end; i++) {\n                hc = 17 * (hc + buf[i]);\n            }\n        }\n        return hc;\n    }\n\n    /**\n     * Returns a string representation of this type.\n     *\n     * @return the descriptor of this type.\n     */\n    public String toString() {\n        return getDescriptor();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/TypeTest1.java",
		"test_prompt": "// TypeTest1.java\npackage org.objectweb.asm.jip;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Type}.\n* It contains ten unit test cases for the {@link Type#getObjectType(String)} method.\n*/\nclass TypeTest1 {"
	},
	{
		"original_code": "// Type.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\n\n/**\n * A Java type. This class can be used to make it easier to manipulate type and\n * method descriptors.\n *\n * @author Eric Bruneton\n * @author Chris Nokleberg\n */\npublic class Type {\n\n    /**\n     * The sort of the <tt>void</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int VOID = 0;\n\n    /**\n     * The sort of the <tt>boolean</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int BOOLEAN = 1;\n\n    /**\n     * The sort of the <tt>char</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int CHAR = 2;\n\n    /**\n     * The sort of the <tt>byte</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int BYTE = 3;\n\n    /**\n     * The sort of the <tt>short</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int SHORT = 4;\n\n    /**\n     * The sort of the <tt>int</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int INT = 5;\n\n    /**\n     * The sort of the <tt>float</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int FLOAT = 6;\n\n    /**\n     * The sort of the <tt>long</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int LONG = 7;\n\n    /**\n     * The sort of the <tt>double</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int DOUBLE = 8;\n\n    /**\n     * The sort of array reference types. See {@link #getSort getSort}.\n     */\n    public static final int ARRAY = 9;\n\n    /**\n     * The sort of object reference type. See {@link #getSort getSort}.\n     */\n    public static final int OBJECT = 10;\n\n    /**\n     * The <tt>void</tt> type.\n     */\n    public static final Type VOID_TYPE = new Type(VOID, null, ('V' << 24) | (5 << 16) | (0 << 8) | 0, 1);\n\n    /**\n     * The <tt>boolean</tt> type.\n     */\n    public static final Type BOOLEAN_TYPE = new Type(BOOLEAN, null, ('Z' << 24) | (0 << 16) | (5 << 8) | 1, 1);\n\n    /**\n     * The <tt>char</tt> type.\n     */\n    public static final Type CHAR_TYPE = new Type(CHAR, null, ('C' << 24) | (0 << 16) | (6 << 8) | 1, 1);\n\n    /**\n     * The <tt>byte</tt> type.\n     */\n    public static final Type BYTE_TYPE = new Type(BYTE, null, ('B' << 24) | (0 << 16) | (5 << 8) | 1, 1);\n\n    /**\n     * The <tt>short</tt> type.\n     */\n    public static final Type SHORT_TYPE = new Type(SHORT, null, ('S' << 24) | (0 << 16) | (7 << 8) | 1, 1);\n\n    /**\n     * The <tt>int</tt> type.\n     */\n    public static final Type INT_TYPE = new Type(INT, null, ('I' << 24) | (0 << 16) | (0 << 8) | 1, 1);\n\n    /**\n     * The <tt>float</tt> type.\n     */\n    public static final Type FLOAT_TYPE = new Type(FLOAT, null, ('F' << 24) | (2 << 16) | (2 << 8) | 1, 1);\n\n    /**\n     * The <tt>long</tt> type.\n     */\n    public static final Type LONG_TYPE = new Type(LONG, null, ('J' << 24) | (1 << 16) | (1 << 8) | 2, 1);\n\n    /**\n     * The <tt>double</tt> type.\n     */\n    public static final Type DOUBLE_TYPE = new Type(DOUBLE, null, ('D' << 24) | (3 << 16) | (3 << 8) | 2, 1);\n\n    // ------------------------------------------------------------------------\n    // Fields\n    // ------------------------------------------------------------------------\n    /**\n     * The sort of this Java type.\n     */\n    private final int sort;\n\n    /**\n     * A buffer containing the internal name of this Java type. This field is\n     * only used for reference types.\n     */\n    private final char[] buf;\n\n    /**\n     * The offset of the internal name of this Java type in {@link #buf buf} or,\n     * for primitive types, the size, descriptor and getOpcode offsets for this\n     * type (byte 0 contains the size, byte 1 the descriptor, byte 2 the offset\n     * for IALOAD or IASTORE, byte 3 the offset for all other instructions).\n     */\n    private final int off;\n\n    /**\n     * The length of the internal name of this Java type.\n     */\n    private final int len;\n\n    // ------------------------------------------------------------------------\n    // Constructors\n    // ------------------------------------------------------------------------\n    /**\n     * Constructs a reference type.\n     *\n     * @param sort the sort of the reference type to be constructed.\n     * @param buf a buffer containing the descriptor of the previous type.\n     * @param off the offset of this descriptor in the previous buffer.\n     * @param len the length of this descriptor.\n     */\n    private Type(final int sort, final char[] buf, final int off, final int len) {\n        this.sort = sort;\n        this.buf = buf;\n        this.off = off;\n        this.len = len;\n    }\n\n    /**\n     * Returns the Java type corresponding to the given type descriptor.\n     *\n     * @param typeDescriptor a type descriptor.\n     * @return the Java type corresponding to the given type descriptor.\n     */\n    public static Type getType(final String typeDescriptor) {\n        return getType(typeDescriptor.toCharArray(), 0);\n    }\n\n    /**\n     * Returns the Java type corresponding to the given internal name.\n     *\n     * @param internalName an internal name.\n     * @return the Java type corresponding to the given internal name.\n     */\n    public static Type getObjectType(final String internalName) {\n        char[] buf = internalName.toCharArray();\n        return new Type(buf[0] == '[' ? ARRAY : OBJECT, buf, 0, buf.length);\n    }\n\n    /**\n     * Returns the Java type corresponding to the given class.\n     *\n     * @param c a class.\n     * @return the Java type corresponding to the given class.\n     */\n    public static Type getType(final Class c) {\n        if (c.isPrimitive()) {\n            if (c == Integer.TYPE) {\n                return INT_TYPE;\n            } else if (c == Void.TYPE) {\n                return VOID_TYPE;\n            } else if (c == Boolean.TYPE) {\n                return BOOLEAN_TYPE;\n            } else if (c == Byte.TYPE) {\n                return BYTE_TYPE;\n            } else if (c == Character.TYPE) {\n                return CHAR_TYPE;\n            } else if (c == Short.TYPE) {\n                return SHORT_TYPE;\n            } else if (c == Double.TYPE) {\n                return DOUBLE_TYPE;\n            } else if (c == Float.TYPE) {\n                return FLOAT_TYPE;\n            } else /* if (c == Long.TYPE) */\n            {\n                return LONG_TYPE;\n            }\n        } else {\n            return getType(getDescriptor(c));\n        }\n    }\n\n    /**\n     * Returns the Java types corresponding to the argument types of the given\n     * method descriptor.\n     *\n     * @param methodDescriptor a method descriptor.\n     * @return the Java types corresponding to the argument types of the given\n     *         method descriptor.\n     */\n    public static Type[] getArgumentTypes(final String methodDescriptor) {\n        char[] buf = methodDescriptor.toCharArray();\n        int off = 1;\n        int size = 0;\n        while (true) {\n            char car = buf[off++];\n            if (car == ')') {\n                break;\n            } else if (car == 'L') {\n                while (buf[off++] != ';') {\n                }\n                ++size;\n            } else if (car != '[') {\n                ++size;\n            }\n        }\n        Type[] args = new Type[size];\n        off = 1;\n        size = 0;\n        while (buf[off] != ')') {\n            args[size] = getType(buf, off);\n            off += args[size].len + (args[size].sort == OBJECT ? 2 : 0);\n            size += 1;\n        }\n        return args;\n    }\n\n    /**\n     * Returns the Java types corresponding to the argument types of the given\n     * method.\n     *\n     * @param method a method.\n     * @return the Java types corresponding to the argument types of the given\n     *         method.\n     */\n    public static Type[] getArgumentTypes(final Method method) {\n        Class[] classes = method.getParameterTypes();\n        Type[] types = new Type[classes.length];\n        for (int i = classes.length - 1; i >= 0; --i) {\n            types[i] = getType(classes[i]);\n        }\n        return types;\n    }\n\n    /**\n     * Returns the Java type corresponding to the return type of the given\n     * method descriptor.\n     *\n     * @param methodDescriptor a method descriptor.\n     * @return the Java type corresponding to the return type of the given\n     *         method descriptor.\n     */\n    public static Type getReturnType(final String methodDescriptor) {\n        char[] buf = methodDescriptor.toCharArray();\n        return getType(buf, methodDescriptor.indexOf(')') + 1);\n    }\n\n    /**\n     * Returns the Java type corresponding to the return type of the given\n     * method.\n     *\n     * @param method a method.\n     * @return the Java type corresponding to the return type of the given\n     *         method.\n     */\n    public static Type getReturnType(final Method method) {\n        return getType(method.getReturnType());\n    }\n\n    /**\n     * Computes the size of the arguments and of the return value of a method.\n     *\n     * @param desc the descriptor of a method.\n     * @return the size of the arguments of the method (plus one for the\n     *         implicit this argument), argSize, and the size of its return\n     *         value, retSize, packed into a single int i =\n     *         <tt>(argSize << 2) | retSize</tt> (argSize is therefore equal\n     *         to <tt>i >> 2</tt>, and retSize to <tt>i & 0x03</tt>).\n     */\n    public static int getArgumentsAndReturnSizes(final String desc) {\n        int n = 1;\n        int c = 1;\n        while (true) {\n            char car = desc.charAt(c++);\n            if (car == ')') {\n                car = desc.charAt(c);\n                return n << 2 | (car == 'V' ? 0 : (car == 'D' || car == 'J' ? 2 : 1));\n            } else if (car == 'L') {\n                while (desc.charAt(c++) != ';') {\n                }\n                n += 1;\n            } else if (car == '[') {\n                while ((car = desc.charAt(c)) == '[') {\n                    ++c;\n                }\n                if (car == 'D' || car == 'J') {\n                    n -= 1;\n                }\n            } else if (car == 'D' || car == 'J') {\n                n += 2;\n            } else {\n                n += 1;\n            }\n        }\n    }\n\n    /**\n     * Returns the Java type corresponding to the given type descriptor.\n     *\n     * @param buf a buffer containing a type descriptor.\n     * @param off the offset of this descriptor in the previous buffer.\n     * @return the Java type corresponding to the given type descriptor.\n     */\n    private static Type getType(final char[] buf, final int off) {\n        int len;\n        switch(buf[off]) {\n            case 'V':\n                return VOID_TYPE;\n            case 'Z':\n                return BOOLEAN_TYPE;\n            case 'C':\n                return CHAR_TYPE;\n            case 'B':\n                return BYTE_TYPE;\n            case 'S':\n                return SHORT_TYPE;\n            case 'I':\n                return INT_TYPE;\n            case 'F':\n                return FLOAT_TYPE;\n            case 'J':\n                return LONG_TYPE;\n            case 'D':\n                return DOUBLE_TYPE;\n            case '[':\n                len = 1;\n                while (buf[off + len] == '[') {\n                    ++len;\n                }\n                if (buf[off + len] == 'L') {\n                    ++len;\n                    while (buf[off + len] != ';') {\n                        ++len;\n                    }\n                }\n                return new Type(ARRAY, buf, off, len + 1);\n            // case 'L':\n            default:\n                len = 1;\n                while (buf[off + len] != ';') {\n                    ++len;\n                }\n                return new Type(OBJECT, buf, off + 1, len - 1);\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Accessors\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the sort of this Java type.\n     *\n     * @return {@link #VOID VOID}, {@link #BOOLEAN BOOLEAN},\n     *         {@link #CHAR CHAR}, {@link #BYTE BYTE}, {@link #SHORT SHORT},\n     *         {@link #INT INT}, {@link #FLOAT FLOAT}, {@link #LONG LONG},\n     *         {@link #DOUBLE DOUBLE}, {@link #ARRAY ARRAY} or\n     *         {@link #OBJECT OBJECT}.\n     */\n    public int getSort() {\n        return sort;\n    }\n\n    /**\n     * Returns the number of dimensions of this array type. This method should\n     * only be used for an array type.\n     *\n     * @return the number of dimensions of this array type.\n     */\n    public int getDimensions() {\n        int i = 1;\n        while (buf[off + i] == '[') {\n            ++i;\n        }\n        return i;\n    }\n\n    /**\n     * Returns the type of the elements of this array type. This method should\n     * only be used for an array type.\n     *\n     * @return Returns the type of the elements of this array type.\n     */\n    public Type getElementType() {\n        return getType(buf, off + getDimensions());\n    }\n\n    /**\n     * Returns the name of the class corresponding to this type.\n     *\n     * @return the fully qualified name of the class corresponding to this type.\n     */\n    public String getClassName() {\n        switch(sort) {\n            case VOID:\n                return \"void\";\n            case BOOLEAN:\n                return \"boolean\";\n            case CHAR:\n                return \"char\";\n            case BYTE:\n                return \"byte\";\n            case SHORT:\n                return \"short\";\n            case INT:\n                return \"int\";\n            case FLOAT:\n                return \"float\";\n            case LONG:\n                return \"long\";\n            case DOUBLE:\n                return \"double\";\n            case ARRAY:\n                StringBuffer b = new StringBuffer(getElementType().getClassName());\n                for (int i = getDimensions(); i > 0; --i) {\n                    b.append(\"[]\");\n                }\n                return b.toString();\n            // case OBJECT:\n            default:\n                return new String(buf, off, len).replace('/', '.');\n        }\n    }\n\n    /**\n     * Returns the internal name of the class corresponding to this object or\n     * array type. The internal name of a class is its fully qualified name (as\n     * returned by Class.getName(), where '.' are replaced by '/'. This method\n     * should only be used for an object or array type.\n     *\n     * @return the internal name of the class corresponding to this object type.\n     */\n    public String getInternalName() {\n        return new String(buf, off, len);\n    }\n\n    // ------------------------------------------------------------------------\n    // Conversion to type descriptors\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the descriptor corresponding to this Java type.\n     *\n     * @return the descriptor corresponding to this Java type.\n     */\n    public String getDescriptor() {\n        StringBuffer buf = new StringBuffer();\n        getDescriptor(buf);\n        return buf.toString();\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given argument and return\n     * types.\n     *\n     * @param returnType the return type of the method.\n     * @param argumentTypes the argument types of the method.\n     * @return the descriptor corresponding to the given argument and return\n     *         types.\n     */\n    public static String getMethodDescriptor(final Type returnType, final Type[] argumentTypes) {\n        StringBuffer buf = new StringBuffer();\n        buf.append('(');\n        for (int i = 0; i < argumentTypes.length; ++i) {\n            argumentTypes[i].getDescriptor(buf);\n        }\n        buf.append(')');\n        returnType.getDescriptor(buf);\n        return buf.toString();\n    }\n\n    /**\n     * Appends the descriptor corresponding to this Java type to the given\n     * string buffer.\n     *\n     * @param buf the string buffer to which the descriptor must be appended.\n     */\n    private void getDescriptor(final StringBuffer buf) {\n        if (this.buf == null) {\n            // descriptor is in byte 3 of 'off' for primitive types (buf == null)\n            buf.append((char) ((off & 0xFF000000) >>> 24));\n        } else if (sort == ARRAY) {\n            buf.append(this.buf, off, len);\n        } else {\n            // sort == OBJECT\n            buf.append('L');\n            buf.append(this.buf, off, len);\n            buf.append(';');\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Direct conversion from classes to type descriptors,\n    // without intermediate Type objects\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the internal name of the given class. The internal name of a\n     * class is its fully qualified name, as returned by Class.getName(), where\n     * '.' are replaced by '/'.\n     *\n     * @param c an object or array class.\n     * @return the internal name of the given class.\n     */\n    public static String getInternalName(final Class c) {\n        return c.getName().replace('.', '/');\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given Java type.\n     *\n     * @param c an object class, a primitive class or an array class.\n     * @return the descriptor corresponding to the given class.\n     */\n    public static String getDescriptor(final Class c) {\n        StringBuffer buf = new StringBuffer();\n        getDescriptor(buf, c);\n        return buf.toString();\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given constructor.\n     *\n     * @param c a {@link Constructor Constructor} object.\n     * @return the descriptor of the given constructor.\n     */\n    public static String getConstructorDescriptor(final Constructor c) {\n        Class[] parameters = c.getParameterTypes();\n        StringBuffer buf = new StringBuffer();\n        buf.append('(');\n        for (int i = 0; i < parameters.length; ++i) {\n            getDescriptor(buf, parameters[i]);\n        }\n        return buf.append(\")V\").toString();\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given method.\n     *\n     * @param m a {@link Method Method} object.\n     * @return the descriptor of the given method.\n     */\n    public static String getMethodDescriptor(final Method m) {\n        Class[] parameters = m.getParameterTypes();\n        StringBuffer buf = new StringBuffer();\n        buf.append('(');\n        for (int i = 0; i < parameters.length; ++i) {\n            getDescriptor(buf, parameters[i]);\n        }\n        buf.append(')');\n        getDescriptor(buf, m.getReturnType());\n        return buf.toString();\n    }\n\n    /**\n     * Appends the descriptor of the given class to the given string buffer.\n     *\n     * @param buf the string buffer to which the descriptor must be appended.\n     * @param c the class whose descriptor must be computed.\n     */\n    private static void getDescriptor(final StringBuffer buf, final Class c) {\n        Class d = c;\n        while (true) {\n            if (d.isPrimitive()) {\n                char car;\n                if (d == Integer.TYPE) {\n                    car = 'I';\n                } else if (d == Void.TYPE) {\n                    car = 'V';\n                } else if (d == Boolean.TYPE) {\n                    car = 'Z';\n                } else if (d == Byte.TYPE) {\n                    car = 'B';\n                } else if (d == Character.TYPE) {\n                    car = 'C';\n                } else if (d == Short.TYPE) {\n                    car = 'S';\n                } else if (d == Double.TYPE) {\n                    car = 'D';\n                } else if (d == Float.TYPE) {\n                    car = 'F';\n                } else /* if (d == Long.TYPE) */\n                {\n                    car = 'J';\n                }\n                buf.append(car);\n                return;\n            } else if (d.isArray()) {\n                buf.append('[');\n                d = d.getComponentType();\n            } else {\n                buf.append('L');\n                String name = d.getName();\n                int len = name.length();\n                for (int i = 0; i < len; ++i) {\n                    char car = name.charAt(i);\n                    buf.append(car == '.' ? '/' : car);\n                }\n                buf.append(';');\n                return;\n            }\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Corresponding size and opcodes\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the size of values of this type.\n     *\n     * @return the size of values of this type, i.e., 2 for <tt>long</tt> and\n     *         <tt>double</tt>, 0 for <tt>void</tt> and 1 otherwise.\n     */\n    public int getSize() {\n        // the size is in byte 0 of 'off' for primitive types (buf == null)\n        return buf == null ? (off & 0xFF) : 1;\n    }\n\n    /**\n     * Returns a JVM instruction opcode adapted to this Java type.\n     *\n     * @param opcode a JVM instruction opcode. This opcode must be one of ILOAD,\n     *        ISTORE, IALOAD, IASTORE, IADD, ISUB, IMUL, IDIV, IREM, INEG, ISHL,\n     *        ISHR, IUSHR, IAND, IOR, IXOR and IRETURN.\n     * @return an opcode that is similar to the given opcode, but adapted to\n     *         this Java type. For example, if this type is <tt>float</tt> and\n     *         <tt>opcode</tt> is IRETURN, this method returns FRETURN.\n     */\n    public int getOpcode(final int opcode) {\n        if (opcode == Opcodes.IALOAD || opcode == Opcodes.IASTORE) {\n            // the offset for IALOAD or IASTORE is in byte 1 of 'off' for\n            // primitive types (buf == null)\n            return opcode + (buf == null ? (off & 0xFF00) >> 8 : 4);\n        } else {\n            // the offset for other instructions is in byte 2 of 'off' for\n            // primitive types (buf == null)\n            return opcode + (buf == null ? (off & 0xFF0000) >> 16 : 4);\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Equals, hashCode and toString\n    // ------------------------------------------------------------------------\n    /**\n     * Tests if the given object is equal to this type.\n     *\n     * @param o the object to be compared to this type.\n     * @return <tt>true</tt> if the given object is equal to this type.\n     */\n    public boolean equals(final Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (!(o instanceof Type)) {\n            return false;\n        }\n        Type t = (Type) o;\n        if (sort != t.sort) {\n            return false;\n        }\n        if (sort == OBJECT || sort == ARRAY) {\n            if (len != t.len) {\n                return false;\n            }\n            for (int i = off, j = t.off, end = i + len; i < end; i++, j++) {\n                if (buf[i] != t.buf[j]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code value for this type.\n     *\n     * @return a hash code value for this type.\n     */\n    public int hashCode() {\n        int hc = 13 * sort;\n        if (sort == OBJECT || sort == ARRAY) {\n            for (int i = off, end = i + len; i < end; i++) {\n                hc = 17 * (hc + buf[i]);\n            }\n        }\n        return hc;\n    }\n\n    /**\n     * Returns a string representation of this type.\n     *\n     * @return the descriptor of this type.\n     */\n    public String toString() {\n        return getDescriptor();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/TypeTest2.java",
		"test_prompt": "// TypeTest2.java\npackage org.objectweb.asm.jip;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Type}.\n* It contains ten unit test cases for the {@link Type#getType(Class)} method.\n*/\nclass TypeTest2 {"
	},
	{
		"original_code": "// Type.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\n\n/**\n * A Java type. This class can be used to make it easier to manipulate type and\n * method descriptors.\n *\n * @author Eric Bruneton\n * @author Chris Nokleberg\n */\npublic class Type {\n\n    /**\n     * The sort of the <tt>void</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int VOID = 0;\n\n    /**\n     * The sort of the <tt>boolean</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int BOOLEAN = 1;\n\n    /**\n     * The sort of the <tt>char</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int CHAR = 2;\n\n    /**\n     * The sort of the <tt>byte</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int BYTE = 3;\n\n    /**\n     * The sort of the <tt>short</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int SHORT = 4;\n\n    /**\n     * The sort of the <tt>int</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int INT = 5;\n\n    /**\n     * The sort of the <tt>float</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int FLOAT = 6;\n\n    /**\n     * The sort of the <tt>long</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int LONG = 7;\n\n    /**\n     * The sort of the <tt>double</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int DOUBLE = 8;\n\n    /**\n     * The sort of array reference types. See {@link #getSort getSort}.\n     */\n    public static final int ARRAY = 9;\n\n    /**\n     * The sort of object reference type. See {@link #getSort getSort}.\n     */\n    public static final int OBJECT = 10;\n\n    /**\n     * The <tt>void</tt> type.\n     */\n    public static final Type VOID_TYPE = new Type(VOID, null, ('V' << 24) | (5 << 16) | (0 << 8) | 0, 1);\n\n    /**\n     * The <tt>boolean</tt> type.\n     */\n    public static final Type BOOLEAN_TYPE = new Type(BOOLEAN, null, ('Z' << 24) | (0 << 16) | (5 << 8) | 1, 1);\n\n    /**\n     * The <tt>char</tt> type.\n     */\n    public static final Type CHAR_TYPE = new Type(CHAR, null, ('C' << 24) | (0 << 16) | (6 << 8) | 1, 1);\n\n    /**\n     * The <tt>byte</tt> type.\n     */\n    public static final Type BYTE_TYPE = new Type(BYTE, null, ('B' << 24) | (0 << 16) | (5 << 8) | 1, 1);\n\n    /**\n     * The <tt>short</tt> type.\n     */\n    public static final Type SHORT_TYPE = new Type(SHORT, null, ('S' << 24) | (0 << 16) | (7 << 8) | 1, 1);\n\n    /**\n     * The <tt>int</tt> type.\n     */\n    public static final Type INT_TYPE = new Type(INT, null, ('I' << 24) | (0 << 16) | (0 << 8) | 1, 1);\n\n    /**\n     * The <tt>float</tt> type.\n     */\n    public static final Type FLOAT_TYPE = new Type(FLOAT, null, ('F' << 24) | (2 << 16) | (2 << 8) | 1, 1);\n\n    /**\n     * The <tt>long</tt> type.\n     */\n    public static final Type LONG_TYPE = new Type(LONG, null, ('J' << 24) | (1 << 16) | (1 << 8) | 2, 1);\n\n    /**\n     * The <tt>double</tt> type.\n     */\n    public static final Type DOUBLE_TYPE = new Type(DOUBLE, null, ('D' << 24) | (3 << 16) | (3 << 8) | 2, 1);\n\n    // ------------------------------------------------------------------------\n    // Fields\n    // ------------------------------------------------------------------------\n    /**\n     * The sort of this Java type.\n     */\n    private final int sort;\n\n    /**\n     * A buffer containing the internal name of this Java type. This field is\n     * only used for reference types.\n     */\n    private final char[] buf;\n\n    /**\n     * The offset of the internal name of this Java type in {@link #buf buf} or,\n     * for primitive types, the size, descriptor and getOpcode offsets for this\n     * type (byte 0 contains the size, byte 1 the descriptor, byte 2 the offset\n     * for IALOAD or IASTORE, byte 3 the offset for all other instructions).\n     */\n    private final int off;\n\n    /**\n     * The length of the internal name of this Java type.\n     */\n    private final int len;\n\n    // ------------------------------------------------------------------------\n    // Constructors\n    // ------------------------------------------------------------------------\n    /**\n     * Constructs a reference type.\n     *\n     * @param sort the sort of the reference type to be constructed.\n     * @param buf a buffer containing the descriptor of the previous type.\n     * @param off the offset of this descriptor in the previous buffer.\n     * @param len the length of this descriptor.\n     */\n    private Type(final int sort, final char[] buf, final int off, final int len) {\n        this.sort = sort;\n        this.buf = buf;\n        this.off = off;\n        this.len = len;\n    }\n\n    /**\n     * Returns the Java type corresponding to the given type descriptor.\n     *\n     * @param typeDescriptor a type descriptor.\n     * @return the Java type corresponding to the given type descriptor.\n     */\n    public static Type getType(final String typeDescriptor) {\n        return getType(typeDescriptor.toCharArray(), 0);\n    }\n\n    /**\n     * Returns the Java type corresponding to the given internal name.\n     *\n     * @param internalName an internal name.\n     * @return the Java type corresponding to the given internal name.\n     */\n    public static Type getObjectType(final String internalName) {\n        char[] buf = internalName.toCharArray();\n        return new Type(buf[0] == '[' ? ARRAY : OBJECT, buf, 0, buf.length);\n    }\n\n    /**\n     * Returns the Java type corresponding to the given class.\n     *\n     * @param c a class.\n     * @return the Java type corresponding to the given class.\n     */\n    public static Type getType(final Class c) {\n        if (c.isPrimitive()) {\n            if (c == Integer.TYPE) {\n                return INT_TYPE;\n            } else if (c == Void.TYPE) {\n                return VOID_TYPE;\n            } else if (c == Boolean.TYPE) {\n                return BOOLEAN_TYPE;\n            } else if (c == Byte.TYPE) {\n                return BYTE_TYPE;\n            } else if (c == Character.TYPE) {\n                return CHAR_TYPE;\n            } else if (c == Short.TYPE) {\n                return SHORT_TYPE;\n            } else if (c == Double.TYPE) {\n                return DOUBLE_TYPE;\n            } else if (c == Float.TYPE) {\n                return FLOAT_TYPE;\n            } else /* if (c == Long.TYPE) */\n            {\n                return LONG_TYPE;\n            }\n        } else {\n            return getType(getDescriptor(c));\n        }\n    }\n\n    /**\n     * Returns the Java types corresponding to the argument types of the given\n     * method descriptor.\n     *\n     * @param methodDescriptor a method descriptor.\n     * @return the Java types corresponding to the argument types of the given\n     *         method descriptor.\n     */\n    public static Type[] getArgumentTypes(final String methodDescriptor) {\n        char[] buf = methodDescriptor.toCharArray();\n        int off = 1;\n        int size = 0;\n        while (true) {\n            char car = buf[off++];\n            if (car == ')') {\n                break;\n            } else if (car == 'L') {\n                while (buf[off++] != ';') {\n                }\n                ++size;\n            } else if (car != '[') {\n                ++size;\n            }\n        }\n        Type[] args = new Type[size];\n        off = 1;\n        size = 0;\n        while (buf[off] != ')') {\n            args[size] = getType(buf, off);\n            off += args[size].len + (args[size].sort == OBJECT ? 2 : 0);\n            size += 1;\n        }\n        return args;\n    }\n\n    /**\n     * Returns the Java types corresponding to the argument types of the given\n     * method.\n     *\n     * @param method a method.\n     * @return the Java types corresponding to the argument types of the given\n     *         method.\n     */\n    public static Type[] getArgumentTypes(final Method method) {\n        Class[] classes = method.getParameterTypes();\n        Type[] types = new Type[classes.length];\n        for (int i = classes.length - 1; i >= 0; --i) {\n            types[i] = getType(classes[i]);\n        }\n        return types;\n    }\n\n    /**\n     * Returns the Java type corresponding to the return type of the given\n     * method descriptor.\n     *\n     * @param methodDescriptor a method descriptor.\n     * @return the Java type corresponding to the return type of the given\n     *         method descriptor.\n     */\n    public static Type getReturnType(final String methodDescriptor) {\n        char[] buf = methodDescriptor.toCharArray();\n        return getType(buf, methodDescriptor.indexOf(')') + 1);\n    }\n\n    /**\n     * Returns the Java type corresponding to the return type of the given\n     * method.\n     *\n     * @param method a method.\n     * @return the Java type corresponding to the return type of the given\n     *         method.\n     */\n    public static Type getReturnType(final Method method) {\n        return getType(method.getReturnType());\n    }\n\n    /**\n     * Computes the size of the arguments and of the return value of a method.\n     *\n     * @param desc the descriptor of a method.\n     * @return the size of the arguments of the method (plus one for the\n     *         implicit this argument), argSize, and the size of its return\n     *         value, retSize, packed into a single int i =\n     *         <tt>(argSize << 2) | retSize</tt> (argSize is therefore equal\n     *         to <tt>i >> 2</tt>, and retSize to <tt>i & 0x03</tt>).\n     */\n    public static int getArgumentsAndReturnSizes(final String desc) {\n        int n = 1;\n        int c = 1;\n        while (true) {\n            char car = desc.charAt(c++);\n            if (car == ')') {\n                car = desc.charAt(c);\n                return n << 2 | (car == 'V' ? 0 : (car == 'D' || car == 'J' ? 2 : 1));\n            } else if (car == 'L') {\n                while (desc.charAt(c++) != ';') {\n                }\n                n += 1;\n            } else if (car == '[') {\n                while ((car = desc.charAt(c)) == '[') {\n                    ++c;\n                }\n                if (car == 'D' || car == 'J') {\n                    n -= 1;\n                }\n            } else if (car == 'D' || car == 'J') {\n                n += 2;\n            } else {\n                n += 1;\n            }\n        }\n    }\n\n    /**\n     * Returns the Java type corresponding to the given type descriptor.\n     *\n     * @param buf a buffer containing a type descriptor.\n     * @param off the offset of this descriptor in the previous buffer.\n     * @return the Java type corresponding to the given type descriptor.\n     */\n    private static Type getType(final char[] buf, final int off) {\n        int len;\n        switch(buf[off]) {\n            case 'V':\n                return VOID_TYPE;\n            case 'Z':\n                return BOOLEAN_TYPE;\n            case 'C':\n                return CHAR_TYPE;\n            case 'B':\n                return BYTE_TYPE;\n            case 'S':\n                return SHORT_TYPE;\n            case 'I':\n                return INT_TYPE;\n            case 'F':\n                return FLOAT_TYPE;\n            case 'J':\n                return LONG_TYPE;\n            case 'D':\n                return DOUBLE_TYPE;\n            case '[':\n                len = 1;\n                while (buf[off + len] == '[') {\n                    ++len;\n                }\n                if (buf[off + len] == 'L') {\n                    ++len;\n                    while (buf[off + len] != ';') {\n                        ++len;\n                    }\n                }\n                return new Type(ARRAY, buf, off, len + 1);\n            // case 'L':\n            default:\n                len = 1;\n                while (buf[off + len] != ';') {\n                    ++len;\n                }\n                return new Type(OBJECT, buf, off + 1, len - 1);\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Accessors\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the sort of this Java type.\n     *\n     * @return {@link #VOID VOID}, {@link #BOOLEAN BOOLEAN},\n     *         {@link #CHAR CHAR}, {@link #BYTE BYTE}, {@link #SHORT SHORT},\n     *         {@link #INT INT}, {@link #FLOAT FLOAT}, {@link #LONG LONG},\n     *         {@link #DOUBLE DOUBLE}, {@link #ARRAY ARRAY} or\n     *         {@link #OBJECT OBJECT}.\n     */\n    public int getSort() {\n        return sort;\n    }\n\n    /**\n     * Returns the number of dimensions of this array type. This method should\n     * only be used for an array type.\n     *\n     * @return the number of dimensions of this array type.\n     */\n    public int getDimensions() {\n        int i = 1;\n        while (buf[off + i] == '[') {\n            ++i;\n        }\n        return i;\n    }\n\n    /**\n     * Returns the type of the elements of this array type. This method should\n     * only be used for an array type.\n     *\n     * @return Returns the type of the elements of this array type.\n     */\n    public Type getElementType() {\n        return getType(buf, off + getDimensions());\n    }\n\n    /**\n     * Returns the name of the class corresponding to this type.\n     *\n     * @return the fully qualified name of the class corresponding to this type.\n     */\n    public String getClassName() {\n        switch(sort) {\n            case VOID:\n                return \"void\";\n            case BOOLEAN:\n                return \"boolean\";\n            case CHAR:\n                return \"char\";\n            case BYTE:\n                return \"byte\";\n            case SHORT:\n                return \"short\";\n            case INT:\n                return \"int\";\n            case FLOAT:\n                return \"float\";\n            case LONG:\n                return \"long\";\n            case DOUBLE:\n                return \"double\";\n            case ARRAY:\n                StringBuffer b = new StringBuffer(getElementType().getClassName());\n                for (int i = getDimensions(); i > 0; --i) {\n                    b.append(\"[]\");\n                }\n                return b.toString();\n            // case OBJECT:\n            default:\n                return new String(buf, off, len).replace('/', '.');\n        }\n    }\n\n    /**\n     * Returns the internal name of the class corresponding to this object or\n     * array type. The internal name of a class is its fully qualified name (as\n     * returned by Class.getName(), where '.' are replaced by '/'. This method\n     * should only be used for an object or array type.\n     *\n     * @return the internal name of the class corresponding to this object type.\n     */\n    public String getInternalName() {\n        return new String(buf, off, len);\n    }\n\n    // ------------------------------------------------------------------------\n    // Conversion to type descriptors\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the descriptor corresponding to this Java type.\n     *\n     * @return the descriptor corresponding to this Java type.\n     */\n    public String getDescriptor() {\n        StringBuffer buf = new StringBuffer();\n        getDescriptor(buf);\n        return buf.toString();\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given argument and return\n     * types.\n     *\n     * @param returnType the return type of the method.\n     * @param argumentTypes the argument types of the method.\n     * @return the descriptor corresponding to the given argument and return\n     *         types.\n     */\n    public static String getMethodDescriptor(final Type returnType, final Type[] argumentTypes) {\n        StringBuffer buf = new StringBuffer();\n        buf.append('(');\n        for (int i = 0; i < argumentTypes.length; ++i) {\n            argumentTypes[i].getDescriptor(buf);\n        }\n        buf.append(')');\n        returnType.getDescriptor(buf);\n        return buf.toString();\n    }\n\n    /**\n     * Appends the descriptor corresponding to this Java type to the given\n     * string buffer.\n     *\n     * @param buf the string buffer to which the descriptor must be appended.\n     */\n    private void getDescriptor(final StringBuffer buf) {\n        if (this.buf == null) {\n            // descriptor is in byte 3 of 'off' for primitive types (buf == null)\n            buf.append((char) ((off & 0xFF000000) >>> 24));\n        } else if (sort == ARRAY) {\n            buf.append(this.buf, off, len);\n        } else {\n            // sort == OBJECT\n            buf.append('L');\n            buf.append(this.buf, off, len);\n            buf.append(';');\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Direct conversion from classes to type descriptors,\n    // without intermediate Type objects\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the internal name of the given class. The internal name of a\n     * class is its fully qualified name, as returned by Class.getName(), where\n     * '.' are replaced by '/'.\n     *\n     * @param c an object or array class.\n     * @return the internal name of the given class.\n     */\n    public static String getInternalName(final Class c) {\n        return c.getName().replace('.', '/');\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given Java type.\n     *\n     * @param c an object class, a primitive class or an array class.\n     * @return the descriptor corresponding to the given class.\n     */\n    public static String getDescriptor(final Class c) {\n        StringBuffer buf = new StringBuffer();\n        getDescriptor(buf, c);\n        return buf.toString();\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given constructor.\n     *\n     * @param c a {@link Constructor Constructor} object.\n     * @return the descriptor of the given constructor.\n     */\n    public static String getConstructorDescriptor(final Constructor c) {\n        Class[] parameters = c.getParameterTypes();\n        StringBuffer buf = new StringBuffer();\n        buf.append('(');\n        for (int i = 0; i < parameters.length; ++i) {\n            getDescriptor(buf, parameters[i]);\n        }\n        return buf.append(\")V\").toString();\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given method.\n     *\n     * @param m a {@link Method Method} object.\n     * @return the descriptor of the given method.\n     */\n    public static String getMethodDescriptor(final Method m) {\n        Class[] parameters = m.getParameterTypes();\n        StringBuffer buf = new StringBuffer();\n        buf.append('(');\n        for (int i = 0; i < parameters.length; ++i) {\n            getDescriptor(buf, parameters[i]);\n        }\n        buf.append(')');\n        getDescriptor(buf, m.getReturnType());\n        return buf.toString();\n    }\n\n    /**\n     * Appends the descriptor of the given class to the given string buffer.\n     *\n     * @param buf the string buffer to which the descriptor must be appended.\n     * @param c the class whose descriptor must be computed.\n     */\n    private static void getDescriptor(final StringBuffer buf, final Class c) {\n        Class d = c;\n        while (true) {\n            if (d.isPrimitive()) {\n                char car;\n                if (d == Integer.TYPE) {\n                    car = 'I';\n                } else if (d == Void.TYPE) {\n                    car = 'V';\n                } else if (d == Boolean.TYPE) {\n                    car = 'Z';\n                } else if (d == Byte.TYPE) {\n                    car = 'B';\n                } else if (d == Character.TYPE) {\n                    car = 'C';\n                } else if (d == Short.TYPE) {\n                    car = 'S';\n                } else if (d == Double.TYPE) {\n                    car = 'D';\n                } else if (d == Float.TYPE) {\n                    car = 'F';\n                } else /* if (d == Long.TYPE) */\n                {\n                    car = 'J';\n                }\n                buf.append(car);\n                return;\n            } else if (d.isArray()) {\n                buf.append('[');\n                d = d.getComponentType();\n            } else {\n                buf.append('L');\n                String name = d.getName();\n                int len = name.length();\n                for (int i = 0; i < len; ++i) {\n                    char car = name.charAt(i);\n                    buf.append(car == '.' ? '/' : car);\n                }\n                buf.append(';');\n                return;\n            }\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Corresponding size and opcodes\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the size of values of this type.\n     *\n     * @return the size of values of this type, i.e., 2 for <tt>long</tt> and\n     *         <tt>double</tt>, 0 for <tt>void</tt> and 1 otherwise.\n     */\n    public int getSize() {\n        // the size is in byte 0 of 'off' for primitive types (buf == null)\n        return buf == null ? (off & 0xFF) : 1;\n    }\n\n    /**\n     * Returns a JVM instruction opcode adapted to this Java type.\n     *\n     * @param opcode a JVM instruction opcode. This opcode must be one of ILOAD,\n     *        ISTORE, IALOAD, IASTORE, IADD, ISUB, IMUL, IDIV, IREM, INEG, ISHL,\n     *        ISHR, IUSHR, IAND, IOR, IXOR and IRETURN.\n     * @return an opcode that is similar to the given opcode, but adapted to\n     *         this Java type. For example, if this type is <tt>float</tt> and\n     *         <tt>opcode</tt> is IRETURN, this method returns FRETURN.\n     */\n    public int getOpcode(final int opcode) {\n        if (opcode == Opcodes.IALOAD || opcode == Opcodes.IASTORE) {\n            // the offset for IALOAD or IASTORE is in byte 1 of 'off' for\n            // primitive types (buf == null)\n            return opcode + (buf == null ? (off & 0xFF00) >> 8 : 4);\n        } else {\n            // the offset for other instructions is in byte 2 of 'off' for\n            // primitive types (buf == null)\n            return opcode + (buf == null ? (off & 0xFF0000) >> 16 : 4);\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Equals, hashCode and toString\n    // ------------------------------------------------------------------------\n    /**\n     * Tests if the given object is equal to this type.\n     *\n     * @param o the object to be compared to this type.\n     * @return <tt>true</tt> if the given object is equal to this type.\n     */\n    public boolean equals(final Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (!(o instanceof Type)) {\n            return false;\n        }\n        Type t = (Type) o;\n        if (sort != t.sort) {\n            return false;\n        }\n        if (sort == OBJECT || sort == ARRAY) {\n            if (len != t.len) {\n                return false;\n            }\n            for (int i = off, j = t.off, end = i + len; i < end; i++, j++) {\n                if (buf[i] != t.buf[j]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code value for this type.\n     *\n     * @return a hash code value for this type.\n     */\n    public int hashCode() {\n        int hc = 13 * sort;\n        if (sort == OBJECT || sort == ARRAY) {\n            for (int i = off, end = i + len; i < end; i++) {\n                hc = 17 * (hc + buf[i]);\n            }\n        }\n        return hc;\n    }\n\n    /**\n     * Returns a string representation of this type.\n     *\n     * @return the descriptor of this type.\n     */\n    public String toString() {\n        return getDescriptor();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/TypeTest3.java",
		"test_prompt": "// TypeTest3.java\npackage org.objectweb.asm.jip;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Type}.\n* It contains ten unit test cases for the {@link Type#getArgumentTypes(String)} method.\n*/\nclass TypeTest3 {"
	},
	{
		"original_code": "// Type.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\n\n/**\n * A Java type. This class can be used to make it easier to manipulate type and\n * method descriptors.\n *\n * @author Eric Bruneton\n * @author Chris Nokleberg\n */\npublic class Type {\n\n    /**\n     * The sort of the <tt>void</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int VOID = 0;\n\n    /**\n     * The sort of the <tt>boolean</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int BOOLEAN = 1;\n\n    /**\n     * The sort of the <tt>char</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int CHAR = 2;\n\n    /**\n     * The sort of the <tt>byte</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int BYTE = 3;\n\n    /**\n     * The sort of the <tt>short</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int SHORT = 4;\n\n    /**\n     * The sort of the <tt>int</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int INT = 5;\n\n    /**\n     * The sort of the <tt>float</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int FLOAT = 6;\n\n    /**\n     * The sort of the <tt>long</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int LONG = 7;\n\n    /**\n     * The sort of the <tt>double</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int DOUBLE = 8;\n\n    /**\n     * The sort of array reference types. See {@link #getSort getSort}.\n     */\n    public static final int ARRAY = 9;\n\n    /**\n     * The sort of object reference type. See {@link #getSort getSort}.\n     */\n    public static final int OBJECT = 10;\n\n    /**\n     * The <tt>void</tt> type.\n     */\n    public static final Type VOID_TYPE = new Type(VOID, null, ('V' << 24) | (5 << 16) | (0 << 8) | 0, 1);\n\n    /**\n     * The <tt>boolean</tt> type.\n     */\n    public static final Type BOOLEAN_TYPE = new Type(BOOLEAN, null, ('Z' << 24) | (0 << 16) | (5 << 8) | 1, 1);\n\n    /**\n     * The <tt>char</tt> type.\n     */\n    public static final Type CHAR_TYPE = new Type(CHAR, null, ('C' << 24) | (0 << 16) | (6 << 8) | 1, 1);\n\n    /**\n     * The <tt>byte</tt> type.\n     */\n    public static final Type BYTE_TYPE = new Type(BYTE, null, ('B' << 24) | (0 << 16) | (5 << 8) | 1, 1);\n\n    /**\n     * The <tt>short</tt> type.\n     */\n    public static final Type SHORT_TYPE = new Type(SHORT, null, ('S' << 24) | (0 << 16) | (7 << 8) | 1, 1);\n\n    /**\n     * The <tt>int</tt> type.\n     */\n    public static final Type INT_TYPE = new Type(INT, null, ('I' << 24) | (0 << 16) | (0 << 8) | 1, 1);\n\n    /**\n     * The <tt>float</tt> type.\n     */\n    public static final Type FLOAT_TYPE = new Type(FLOAT, null, ('F' << 24) | (2 << 16) | (2 << 8) | 1, 1);\n\n    /**\n     * The <tt>long</tt> type.\n     */\n    public static final Type LONG_TYPE = new Type(LONG, null, ('J' << 24) | (1 << 16) | (1 << 8) | 2, 1);\n\n    /**\n     * The <tt>double</tt> type.\n     */\n    public static final Type DOUBLE_TYPE = new Type(DOUBLE, null, ('D' << 24) | (3 << 16) | (3 << 8) | 2, 1);\n\n    // ------------------------------------------------------------------------\n    // Fields\n    // ------------------------------------------------------------------------\n    /**\n     * The sort of this Java type.\n     */\n    private final int sort;\n\n    /**\n     * A buffer containing the internal name of this Java type. This field is\n     * only used for reference types.\n     */\n    private final char[] buf;\n\n    /**\n     * The offset of the internal name of this Java type in {@link #buf buf} or,\n     * for primitive types, the size, descriptor and getOpcode offsets for this\n     * type (byte 0 contains the size, byte 1 the descriptor, byte 2 the offset\n     * for IALOAD or IASTORE, byte 3 the offset for all other instructions).\n     */\n    private final int off;\n\n    /**\n     * The length of the internal name of this Java type.\n     */\n    private final int len;\n\n    // ------------------------------------------------------------------------\n    // Constructors\n    // ------------------------------------------------------------------------\n    /**\n     * Constructs a reference type.\n     *\n     * @param sort the sort of the reference type to be constructed.\n     * @param buf a buffer containing the descriptor of the previous type.\n     * @param off the offset of this descriptor in the previous buffer.\n     * @param len the length of this descriptor.\n     */\n    private Type(final int sort, final char[] buf, final int off, final int len) {\n        this.sort = sort;\n        this.buf = buf;\n        this.off = off;\n        this.len = len;\n    }\n\n    /**\n     * Returns the Java type corresponding to the given type descriptor.\n     *\n     * @param typeDescriptor a type descriptor.\n     * @return the Java type corresponding to the given type descriptor.\n     */\n    public static Type getType(final String typeDescriptor) {\n        return getType(typeDescriptor.toCharArray(), 0);\n    }\n\n    /**\n     * Returns the Java type corresponding to the given internal name.\n     *\n     * @param internalName an internal name.\n     * @return the Java type corresponding to the given internal name.\n     */\n    public static Type getObjectType(final String internalName) {\n        char[] buf = internalName.toCharArray();\n        return new Type(buf[0] == '[' ? ARRAY : OBJECT, buf, 0, buf.length);\n    }\n\n    /**\n     * Returns the Java type corresponding to the given class.\n     *\n     * @param c a class.\n     * @return the Java type corresponding to the given class.\n     */\n    public static Type getType(final Class c) {\n        if (c.isPrimitive()) {\n            if (c == Integer.TYPE) {\n                return INT_TYPE;\n            } else if (c == Void.TYPE) {\n                return VOID_TYPE;\n            } else if (c == Boolean.TYPE) {\n                return BOOLEAN_TYPE;\n            } else if (c == Byte.TYPE) {\n                return BYTE_TYPE;\n            } else if (c == Character.TYPE) {\n                return CHAR_TYPE;\n            } else if (c == Short.TYPE) {\n                return SHORT_TYPE;\n            } else if (c == Double.TYPE) {\n                return DOUBLE_TYPE;\n            } else if (c == Float.TYPE) {\n                return FLOAT_TYPE;\n            } else /* if (c == Long.TYPE) */\n            {\n                return LONG_TYPE;\n            }\n        } else {\n            return getType(getDescriptor(c));\n        }\n    }\n\n    /**\n     * Returns the Java types corresponding to the argument types of the given\n     * method descriptor.\n     *\n     * @param methodDescriptor a method descriptor.\n     * @return the Java types corresponding to the argument types of the given\n     *         method descriptor.\n     */\n    public static Type[] getArgumentTypes(final String methodDescriptor) {\n        char[] buf = methodDescriptor.toCharArray();\n        int off = 1;\n        int size = 0;\n        while (true) {\n            char car = buf[off++];\n            if (car == ')') {\n                break;\n            } else if (car == 'L') {\n                while (buf[off++] != ';') {\n                }\n                ++size;\n            } else if (car != '[') {\n                ++size;\n            }\n        }\n        Type[] args = new Type[size];\n        off = 1;\n        size = 0;\n        while (buf[off] != ')') {\n            args[size] = getType(buf, off);\n            off += args[size].len + (args[size].sort == OBJECT ? 2 : 0);\n            size += 1;\n        }\n        return args;\n    }\n\n    /**\n     * Returns the Java types corresponding to the argument types of the given\n     * method.\n     *\n     * @param method a method.\n     * @return the Java types corresponding to the argument types of the given\n     *         method.\n     */\n    public static Type[] getArgumentTypes(final Method method) {\n        Class[] classes = method.getParameterTypes();\n        Type[] types = new Type[classes.length];\n        for (int i = classes.length - 1; i >= 0; --i) {\n            types[i] = getType(classes[i]);\n        }\n        return types;\n    }\n\n    /**\n     * Returns the Java type corresponding to the return type of the given\n     * method descriptor.\n     *\n     * @param methodDescriptor a method descriptor.\n     * @return the Java type corresponding to the return type of the given\n     *         method descriptor.\n     */\n    public static Type getReturnType(final String methodDescriptor) {\n        char[] buf = methodDescriptor.toCharArray();\n        return getType(buf, methodDescriptor.indexOf(')') + 1);\n    }\n\n    /**\n     * Returns the Java type corresponding to the return type of the given\n     * method.\n     *\n     * @param method a method.\n     * @return the Java type corresponding to the return type of the given\n     *         method.\n     */\n    public static Type getReturnType(final Method method) {\n        return getType(method.getReturnType());\n    }\n\n    /**\n     * Computes the size of the arguments and of the return value of a method.\n     *\n     * @param desc the descriptor of a method.\n     * @return the size of the arguments of the method (plus one for the\n     *         implicit this argument), argSize, and the size of its return\n     *         value, retSize, packed into a single int i =\n     *         <tt>(argSize << 2) | retSize</tt> (argSize is therefore equal\n     *         to <tt>i >> 2</tt>, and retSize to <tt>i & 0x03</tt>).\n     */\n    public static int getArgumentsAndReturnSizes(final String desc) {\n        int n = 1;\n        int c = 1;\n        while (true) {\n            char car = desc.charAt(c++);\n            if (car == ')') {\n                car = desc.charAt(c);\n                return n << 2 | (car == 'V' ? 0 : (car == 'D' || car == 'J' ? 2 : 1));\n            } else if (car == 'L') {\n                while (desc.charAt(c++) != ';') {\n                }\n                n += 1;\n            } else if (car == '[') {\n                while ((car = desc.charAt(c)) == '[') {\n                    ++c;\n                }\n                if (car == 'D' || car == 'J') {\n                    n -= 1;\n                }\n            } else if (car == 'D' || car == 'J') {\n                n += 2;\n            } else {\n                n += 1;\n            }\n        }\n    }\n\n    /**\n     * Returns the Java type corresponding to the given type descriptor.\n     *\n     * @param buf a buffer containing a type descriptor.\n     * @param off the offset of this descriptor in the previous buffer.\n     * @return the Java type corresponding to the given type descriptor.\n     */\n    private static Type getType(final char[] buf, final int off) {\n        int len;\n        switch(buf[off]) {\n            case 'V':\n                return VOID_TYPE;\n            case 'Z':\n                return BOOLEAN_TYPE;\n            case 'C':\n                return CHAR_TYPE;\n            case 'B':\n                return BYTE_TYPE;\n            case 'S':\n                return SHORT_TYPE;\n            case 'I':\n                return INT_TYPE;\n            case 'F':\n                return FLOAT_TYPE;\n            case 'J':\n                return LONG_TYPE;\n            case 'D':\n                return DOUBLE_TYPE;\n            case '[':\n                len = 1;\n                while (buf[off + len] == '[') {\n                    ++len;\n                }\n                if (buf[off + len] == 'L') {\n                    ++len;\n                    while (buf[off + len] != ';') {\n                        ++len;\n                    }\n                }\n                return new Type(ARRAY, buf, off, len + 1);\n            // case 'L':\n            default:\n                len = 1;\n                while (buf[off + len] != ';') {\n                    ++len;\n                }\n                return new Type(OBJECT, buf, off + 1, len - 1);\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Accessors\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the sort of this Java type.\n     *\n     * @return {@link #VOID VOID}, {@link #BOOLEAN BOOLEAN},\n     *         {@link #CHAR CHAR}, {@link #BYTE BYTE}, {@link #SHORT SHORT},\n     *         {@link #INT INT}, {@link #FLOAT FLOAT}, {@link #LONG LONG},\n     *         {@link #DOUBLE DOUBLE}, {@link #ARRAY ARRAY} or\n     *         {@link #OBJECT OBJECT}.\n     */\n    public int getSort() {\n        return sort;\n    }\n\n    /**\n     * Returns the number of dimensions of this array type. This method should\n     * only be used for an array type.\n     *\n     * @return the number of dimensions of this array type.\n     */\n    public int getDimensions() {\n        int i = 1;\n        while (buf[off + i] == '[') {\n            ++i;\n        }\n        return i;\n    }\n\n    /**\n     * Returns the type of the elements of this array type. This method should\n     * only be used for an array type.\n     *\n     * @return Returns the type of the elements of this array type.\n     */\n    public Type getElementType() {\n        return getType(buf, off + getDimensions());\n    }\n\n    /**\n     * Returns the name of the class corresponding to this type.\n     *\n     * @return the fully qualified name of the class corresponding to this type.\n     */\n    public String getClassName() {\n        switch(sort) {\n            case VOID:\n                return \"void\";\n            case BOOLEAN:\n                return \"boolean\";\n            case CHAR:\n                return \"char\";\n            case BYTE:\n                return \"byte\";\n            case SHORT:\n                return \"short\";\n            case INT:\n                return \"int\";\n            case FLOAT:\n                return \"float\";\n            case LONG:\n                return \"long\";\n            case DOUBLE:\n                return \"double\";\n            case ARRAY:\n                StringBuffer b = new StringBuffer(getElementType().getClassName());\n                for (int i = getDimensions(); i > 0; --i) {\n                    b.append(\"[]\");\n                }\n                return b.toString();\n            // case OBJECT:\n            default:\n                return new String(buf, off, len).replace('/', '.');\n        }\n    }\n\n    /**\n     * Returns the internal name of the class corresponding to this object or\n     * array type. The internal name of a class is its fully qualified name (as\n     * returned by Class.getName(), where '.' are replaced by '/'. This method\n     * should only be used for an object or array type.\n     *\n     * @return the internal name of the class corresponding to this object type.\n     */\n    public String getInternalName() {\n        return new String(buf, off, len);\n    }\n\n    // ------------------------------------------------------------------------\n    // Conversion to type descriptors\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the descriptor corresponding to this Java type.\n     *\n     * @return the descriptor corresponding to this Java type.\n     */\n    public String getDescriptor() {\n        StringBuffer buf = new StringBuffer();\n        getDescriptor(buf);\n        return buf.toString();\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given argument and return\n     * types.\n     *\n     * @param returnType the return type of the method.\n     * @param argumentTypes the argument types of the method.\n     * @return the descriptor corresponding to the given argument and return\n     *         types.\n     */\n    public static String getMethodDescriptor(final Type returnType, final Type[] argumentTypes) {\n        StringBuffer buf = new StringBuffer();\n        buf.append('(');\n        for (int i = 0; i < argumentTypes.length; ++i) {\n            argumentTypes[i].getDescriptor(buf);\n        }\n        buf.append(')');\n        returnType.getDescriptor(buf);\n        return buf.toString();\n    }\n\n    /**\n     * Appends the descriptor corresponding to this Java type to the given\n     * string buffer.\n     *\n     * @param buf the string buffer to which the descriptor must be appended.\n     */\n    private void getDescriptor(final StringBuffer buf) {\n        if (this.buf == null) {\n            // descriptor is in byte 3 of 'off' for primitive types (buf == null)\n            buf.append((char) ((off & 0xFF000000) >>> 24));\n        } else if (sort == ARRAY) {\n            buf.append(this.buf, off, len);\n        } else {\n            // sort == OBJECT\n            buf.append('L');\n            buf.append(this.buf, off, len);\n            buf.append(';');\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Direct conversion from classes to type descriptors,\n    // without intermediate Type objects\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the internal name of the given class. The internal name of a\n     * class is its fully qualified name, as returned by Class.getName(), where\n     * '.' are replaced by '/'.\n     *\n     * @param c an object or array class.\n     * @return the internal name of the given class.\n     */\n    public static String getInternalName(final Class c) {\n        return c.getName().replace('.', '/');\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given Java type.\n     *\n     * @param c an object class, a primitive class or an array class.\n     * @return the descriptor corresponding to the given class.\n     */\n    public static String getDescriptor(final Class c) {\n        StringBuffer buf = new StringBuffer();\n        getDescriptor(buf, c);\n        return buf.toString();\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given constructor.\n     *\n     * @param c a {@link Constructor Constructor} object.\n     * @return the descriptor of the given constructor.\n     */\n    public static String getConstructorDescriptor(final Constructor c) {\n        Class[] parameters = c.getParameterTypes();\n        StringBuffer buf = new StringBuffer();\n        buf.append('(');\n        for (int i = 0; i < parameters.length; ++i) {\n            getDescriptor(buf, parameters[i]);\n        }\n        return buf.append(\")V\").toString();\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given method.\n     *\n     * @param m a {@link Method Method} object.\n     * @return the descriptor of the given method.\n     */\n    public static String getMethodDescriptor(final Method m) {\n        Class[] parameters = m.getParameterTypes();\n        StringBuffer buf = new StringBuffer();\n        buf.append('(');\n        for (int i = 0; i < parameters.length; ++i) {\n            getDescriptor(buf, parameters[i]);\n        }\n        buf.append(')');\n        getDescriptor(buf, m.getReturnType());\n        return buf.toString();\n    }\n\n    /**\n     * Appends the descriptor of the given class to the given string buffer.\n     *\n     * @param buf the string buffer to which the descriptor must be appended.\n     * @param c the class whose descriptor must be computed.\n     */\n    private static void getDescriptor(final StringBuffer buf, final Class c) {\n        Class d = c;\n        while (true) {\n            if (d.isPrimitive()) {\n                char car;\n                if (d == Integer.TYPE) {\n                    car = 'I';\n                } else if (d == Void.TYPE) {\n                    car = 'V';\n                } else if (d == Boolean.TYPE) {\n                    car = 'Z';\n                } else if (d == Byte.TYPE) {\n                    car = 'B';\n                } else if (d == Character.TYPE) {\n                    car = 'C';\n                } else if (d == Short.TYPE) {\n                    car = 'S';\n                } else if (d == Double.TYPE) {\n                    car = 'D';\n                } else if (d == Float.TYPE) {\n                    car = 'F';\n                } else /* if (d == Long.TYPE) */\n                {\n                    car = 'J';\n                }\n                buf.append(car);\n                return;\n            } else if (d.isArray()) {\n                buf.append('[');\n                d = d.getComponentType();\n            } else {\n                buf.append('L');\n                String name = d.getName();\n                int len = name.length();\n                for (int i = 0; i < len; ++i) {\n                    char car = name.charAt(i);\n                    buf.append(car == '.' ? '/' : car);\n                }\n                buf.append(';');\n                return;\n            }\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Corresponding size and opcodes\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the size of values of this type.\n     *\n     * @return the size of values of this type, i.e., 2 for <tt>long</tt> and\n     *         <tt>double</tt>, 0 for <tt>void</tt> and 1 otherwise.\n     */\n    public int getSize() {\n        // the size is in byte 0 of 'off' for primitive types (buf == null)\n        return buf == null ? (off & 0xFF) : 1;\n    }\n\n    /**\n     * Returns a JVM instruction opcode adapted to this Java type.\n     *\n     * @param opcode a JVM instruction opcode. This opcode must be one of ILOAD,\n     *        ISTORE, IALOAD, IASTORE, IADD, ISUB, IMUL, IDIV, IREM, INEG, ISHL,\n     *        ISHR, IUSHR, IAND, IOR, IXOR and IRETURN.\n     * @return an opcode that is similar to the given opcode, but adapted to\n     *         this Java type. For example, if this type is <tt>float</tt> and\n     *         <tt>opcode</tt> is IRETURN, this method returns FRETURN.\n     */\n    public int getOpcode(final int opcode) {\n        if (opcode == Opcodes.IALOAD || opcode == Opcodes.IASTORE) {\n            // the offset for IALOAD or IASTORE is in byte 1 of 'off' for\n            // primitive types (buf == null)\n            return opcode + (buf == null ? (off & 0xFF00) >> 8 : 4);\n        } else {\n            // the offset for other instructions is in byte 2 of 'off' for\n            // primitive types (buf == null)\n            return opcode + (buf == null ? (off & 0xFF0000) >> 16 : 4);\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Equals, hashCode and toString\n    // ------------------------------------------------------------------------\n    /**\n     * Tests if the given object is equal to this type.\n     *\n     * @param o the object to be compared to this type.\n     * @return <tt>true</tt> if the given object is equal to this type.\n     */\n    public boolean equals(final Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (!(o instanceof Type)) {\n            return false;\n        }\n        Type t = (Type) o;\n        if (sort != t.sort) {\n            return false;\n        }\n        if (sort == OBJECT || sort == ARRAY) {\n            if (len != t.len) {\n                return false;\n            }\n            for (int i = off, j = t.off, end = i + len; i < end; i++, j++) {\n                if (buf[i] != t.buf[j]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code value for this type.\n     *\n     * @return a hash code value for this type.\n     */\n    public int hashCode() {\n        int hc = 13 * sort;\n        if (sort == OBJECT || sort == ARRAY) {\n            for (int i = off, end = i + len; i < end; i++) {\n                hc = 17 * (hc + buf[i]);\n            }\n        }\n        return hc;\n    }\n\n    /**\n     * Returns a string representation of this type.\n     *\n     * @return the descriptor of this type.\n     */\n    public String toString() {\n        return getDescriptor();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/TypeTest4.java",
		"test_prompt": "// TypeTest4.java\npackage org.objectweb.asm.jip;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Type}.\n* It contains ten unit test cases for the {@link Type#getArgumentTypes(Method)} method.\n*/\nclass TypeTest4 {"
	},
	{
		"original_code": "// Type.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\n\n/**\n * A Java type. This class can be used to make it easier to manipulate type and\n * method descriptors.\n *\n * @author Eric Bruneton\n * @author Chris Nokleberg\n */\npublic class Type {\n\n    /**\n     * The sort of the <tt>void</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int VOID = 0;\n\n    /**\n     * The sort of the <tt>boolean</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int BOOLEAN = 1;\n\n    /**\n     * The sort of the <tt>char</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int CHAR = 2;\n\n    /**\n     * The sort of the <tt>byte</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int BYTE = 3;\n\n    /**\n     * The sort of the <tt>short</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int SHORT = 4;\n\n    /**\n     * The sort of the <tt>int</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int INT = 5;\n\n    /**\n     * The sort of the <tt>float</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int FLOAT = 6;\n\n    /**\n     * The sort of the <tt>long</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int LONG = 7;\n\n    /**\n     * The sort of the <tt>double</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int DOUBLE = 8;\n\n    /**\n     * The sort of array reference types. See {@link #getSort getSort}.\n     */\n    public static final int ARRAY = 9;\n\n    /**\n     * The sort of object reference type. See {@link #getSort getSort}.\n     */\n    public static final int OBJECT = 10;\n\n    /**\n     * The <tt>void</tt> type.\n     */\n    public static final Type VOID_TYPE = new Type(VOID, null, ('V' << 24) | (5 << 16) | (0 << 8) | 0, 1);\n\n    /**\n     * The <tt>boolean</tt> type.\n     */\n    public static final Type BOOLEAN_TYPE = new Type(BOOLEAN, null, ('Z' << 24) | (0 << 16) | (5 << 8) | 1, 1);\n\n    /**\n     * The <tt>char</tt> type.\n     */\n    public static final Type CHAR_TYPE = new Type(CHAR, null, ('C' << 24) | (0 << 16) | (6 << 8) | 1, 1);\n\n    /**\n     * The <tt>byte</tt> type.\n     */\n    public static final Type BYTE_TYPE = new Type(BYTE, null, ('B' << 24) | (0 << 16) | (5 << 8) | 1, 1);\n\n    /**\n     * The <tt>short</tt> type.\n     */\n    public static final Type SHORT_TYPE = new Type(SHORT, null, ('S' << 24) | (0 << 16) | (7 << 8) | 1, 1);\n\n    /**\n     * The <tt>int</tt> type.\n     */\n    public static final Type INT_TYPE = new Type(INT, null, ('I' << 24) | (0 << 16) | (0 << 8) | 1, 1);\n\n    /**\n     * The <tt>float</tt> type.\n     */\n    public static final Type FLOAT_TYPE = new Type(FLOAT, null, ('F' << 24) | (2 << 16) | (2 << 8) | 1, 1);\n\n    /**\n     * The <tt>long</tt> type.\n     */\n    public static final Type LONG_TYPE = new Type(LONG, null, ('J' << 24) | (1 << 16) | (1 << 8) | 2, 1);\n\n    /**\n     * The <tt>double</tt> type.\n     */\n    public static final Type DOUBLE_TYPE = new Type(DOUBLE, null, ('D' << 24) | (3 << 16) | (3 << 8) | 2, 1);\n\n    // ------------------------------------------------------------------------\n    // Fields\n    // ------------------------------------------------------------------------\n    /**\n     * The sort of this Java type.\n     */\n    private final int sort;\n\n    /**\n     * A buffer containing the internal name of this Java type. This field is\n     * only used for reference types.\n     */\n    private final char[] buf;\n\n    /**\n     * The offset of the internal name of this Java type in {@link #buf buf} or,\n     * for primitive types, the size, descriptor and getOpcode offsets for this\n     * type (byte 0 contains the size, byte 1 the descriptor, byte 2 the offset\n     * for IALOAD or IASTORE, byte 3 the offset for all other instructions).\n     */\n    private final int off;\n\n    /**\n     * The length of the internal name of this Java type.\n     */\n    private final int len;\n\n    // ------------------------------------------------------------------------\n    // Constructors\n    // ------------------------------------------------------------------------\n    /**\n     * Constructs a reference type.\n     *\n     * @param sort the sort of the reference type to be constructed.\n     * @param buf a buffer containing the descriptor of the previous type.\n     * @param off the offset of this descriptor in the previous buffer.\n     * @param len the length of this descriptor.\n     */\n    private Type(final int sort, final char[] buf, final int off, final int len) {\n        this.sort = sort;\n        this.buf = buf;\n        this.off = off;\n        this.len = len;\n    }\n\n    /**\n     * Returns the Java type corresponding to the given type descriptor.\n     *\n     * @param typeDescriptor a type descriptor.\n     * @return the Java type corresponding to the given type descriptor.\n     */\n    public static Type getType(final String typeDescriptor) {\n        return getType(typeDescriptor.toCharArray(), 0);\n    }\n\n    /**\n     * Returns the Java type corresponding to the given internal name.\n     *\n     * @param internalName an internal name.\n     * @return the Java type corresponding to the given internal name.\n     */\n    public static Type getObjectType(final String internalName) {\n        char[] buf = internalName.toCharArray();\n        return new Type(buf[0] == '[' ? ARRAY : OBJECT, buf, 0, buf.length);\n    }\n\n    /**\n     * Returns the Java type corresponding to the given class.\n     *\n     * @param c a class.\n     * @return the Java type corresponding to the given class.\n     */\n    public static Type getType(final Class c) {\n        if (c.isPrimitive()) {\n            if (c == Integer.TYPE) {\n                return INT_TYPE;\n            } else if (c == Void.TYPE) {\n                return VOID_TYPE;\n            } else if (c == Boolean.TYPE) {\n                return BOOLEAN_TYPE;\n            } else if (c == Byte.TYPE) {\n                return BYTE_TYPE;\n            } else if (c == Character.TYPE) {\n                return CHAR_TYPE;\n            } else if (c == Short.TYPE) {\n                return SHORT_TYPE;\n            } else if (c == Double.TYPE) {\n                return DOUBLE_TYPE;\n            } else if (c == Float.TYPE) {\n                return FLOAT_TYPE;\n            } else /* if (c == Long.TYPE) */\n            {\n                return LONG_TYPE;\n            }\n        } else {\n            return getType(getDescriptor(c));\n        }\n    }\n\n    /**\n     * Returns the Java types corresponding to the argument types of the given\n     * method descriptor.\n     *\n     * @param methodDescriptor a method descriptor.\n     * @return the Java types corresponding to the argument types of the given\n     *         method descriptor.\n     */\n    public static Type[] getArgumentTypes(final String methodDescriptor) {\n        char[] buf = methodDescriptor.toCharArray();\n        int off = 1;\n        int size = 0;\n        while (true) {\n            char car = buf[off++];\n            if (car == ')') {\n                break;\n            } else if (car == 'L') {\n                while (buf[off++] != ';') {\n                }\n                ++size;\n            } else if (car != '[') {\n                ++size;\n            }\n        }\n        Type[] args = new Type[size];\n        off = 1;\n        size = 0;\n        while (buf[off] != ')') {\n            args[size] = getType(buf, off);\n            off += args[size].len + (args[size].sort == OBJECT ? 2 : 0);\n            size += 1;\n        }\n        return args;\n    }\n\n    /**\n     * Returns the Java types corresponding to the argument types of the given\n     * method.\n     *\n     * @param method a method.\n     * @return the Java types corresponding to the argument types of the given\n     *         method.\n     */\n    public static Type[] getArgumentTypes(final Method method) {\n        Class[] classes = method.getParameterTypes();\n        Type[] types = new Type[classes.length];\n        for (int i = classes.length - 1; i >= 0; --i) {\n            types[i] = getType(classes[i]);\n        }\n        return types;\n    }\n\n    /**\n     * Returns the Java type corresponding to the return type of the given\n     * method descriptor.\n     *\n     * @param methodDescriptor a method descriptor.\n     * @return the Java type corresponding to the return type of the given\n     *         method descriptor.\n     */\n    public static Type getReturnType(final String methodDescriptor) {\n        char[] buf = methodDescriptor.toCharArray();\n        return getType(buf, methodDescriptor.indexOf(')') + 1);\n    }\n\n    /**\n     * Returns the Java type corresponding to the return type of the given\n     * method.\n     *\n     * @param method a method.\n     * @return the Java type corresponding to the return type of the given\n     *         method.\n     */\n    public static Type getReturnType(final Method method) {\n        return getType(method.getReturnType());\n    }\n\n    /**\n     * Computes the size of the arguments and of the return value of a method.\n     *\n     * @param desc the descriptor of a method.\n     * @return the size of the arguments of the method (plus one for the\n     *         implicit this argument), argSize, and the size of its return\n     *         value, retSize, packed into a single int i =\n     *         <tt>(argSize << 2) | retSize</tt> (argSize is therefore equal\n     *         to <tt>i >> 2</tt>, and retSize to <tt>i & 0x03</tt>).\n     */\n    public static int getArgumentsAndReturnSizes(final String desc) {\n        int n = 1;\n        int c = 1;\n        while (true) {\n            char car = desc.charAt(c++);\n            if (car == ')') {\n                car = desc.charAt(c);\n                return n << 2 | (car == 'V' ? 0 : (car == 'D' || car == 'J' ? 2 : 1));\n            } else if (car == 'L') {\n                while (desc.charAt(c++) != ';') {\n                }\n                n += 1;\n            } else if (car == '[') {\n                while ((car = desc.charAt(c)) == '[') {\n                    ++c;\n                }\n                if (car == 'D' || car == 'J') {\n                    n -= 1;\n                }\n            } else if (car == 'D' || car == 'J') {\n                n += 2;\n            } else {\n                n += 1;\n            }\n        }\n    }\n\n    /**\n     * Returns the Java type corresponding to the given type descriptor.\n     *\n     * @param buf a buffer containing a type descriptor.\n     * @param off the offset of this descriptor in the previous buffer.\n     * @return the Java type corresponding to the given type descriptor.\n     */\n    private static Type getType(final char[] buf, final int off) {\n        int len;\n        switch(buf[off]) {\n            case 'V':\n                return VOID_TYPE;\n            case 'Z':\n                return BOOLEAN_TYPE;\n            case 'C':\n                return CHAR_TYPE;\n            case 'B':\n                return BYTE_TYPE;\n            case 'S':\n                return SHORT_TYPE;\n            case 'I':\n                return INT_TYPE;\n            case 'F':\n                return FLOAT_TYPE;\n            case 'J':\n                return LONG_TYPE;\n            case 'D':\n                return DOUBLE_TYPE;\n            case '[':\n                len = 1;\n                while (buf[off + len] == '[') {\n                    ++len;\n                }\n                if (buf[off + len] == 'L') {\n                    ++len;\n                    while (buf[off + len] != ';') {\n                        ++len;\n                    }\n                }\n                return new Type(ARRAY, buf, off, len + 1);\n            // case 'L':\n            default:\n                len = 1;\n                while (buf[off + len] != ';') {\n                    ++len;\n                }\n                return new Type(OBJECT, buf, off + 1, len - 1);\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Accessors\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the sort of this Java type.\n     *\n     * @return {@link #VOID VOID}, {@link #BOOLEAN BOOLEAN},\n     *         {@link #CHAR CHAR}, {@link #BYTE BYTE}, {@link #SHORT SHORT},\n     *         {@link #INT INT}, {@link #FLOAT FLOAT}, {@link #LONG LONG},\n     *         {@link #DOUBLE DOUBLE}, {@link #ARRAY ARRAY} or\n     *         {@link #OBJECT OBJECT}.\n     */\n    public int getSort() {\n        return sort;\n    }\n\n    /**\n     * Returns the number of dimensions of this array type. This method should\n     * only be used for an array type.\n     *\n     * @return the number of dimensions of this array type.\n     */\n    public int getDimensions() {\n        int i = 1;\n        while (buf[off + i] == '[') {\n            ++i;\n        }\n        return i;\n    }\n\n    /**\n     * Returns the type of the elements of this array type. This method should\n     * only be used for an array type.\n     *\n     * @return Returns the type of the elements of this array type.\n     */\n    public Type getElementType() {\n        return getType(buf, off + getDimensions());\n    }\n\n    /**\n     * Returns the name of the class corresponding to this type.\n     *\n     * @return the fully qualified name of the class corresponding to this type.\n     */\n    public String getClassName() {\n        switch(sort) {\n            case VOID:\n                return \"void\";\n            case BOOLEAN:\n                return \"boolean\";\n            case CHAR:\n                return \"char\";\n            case BYTE:\n                return \"byte\";\n            case SHORT:\n                return \"short\";\n            case INT:\n                return \"int\";\n            case FLOAT:\n                return \"float\";\n            case LONG:\n                return \"long\";\n            case DOUBLE:\n                return \"double\";\n            case ARRAY:\n                StringBuffer b = new StringBuffer(getElementType().getClassName());\n                for (int i = getDimensions(); i > 0; --i) {\n                    b.append(\"[]\");\n                }\n                return b.toString();\n            // case OBJECT:\n            default:\n                return new String(buf, off, len).replace('/', '.');\n        }\n    }\n\n    /**\n     * Returns the internal name of the class corresponding to this object or\n     * array type. The internal name of a class is its fully qualified name (as\n     * returned by Class.getName(), where '.' are replaced by '/'. This method\n     * should only be used for an object or array type.\n     *\n     * @return the internal name of the class corresponding to this object type.\n     */\n    public String getInternalName() {\n        return new String(buf, off, len);\n    }\n\n    // ------------------------------------------------------------------------\n    // Conversion to type descriptors\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the descriptor corresponding to this Java type.\n     *\n     * @return the descriptor corresponding to this Java type.\n     */\n    public String getDescriptor() {\n        StringBuffer buf = new StringBuffer();\n        getDescriptor(buf);\n        return buf.toString();\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given argument and return\n     * types.\n     *\n     * @param returnType the return type of the method.\n     * @param argumentTypes the argument types of the method.\n     * @return the descriptor corresponding to the given argument and return\n     *         types.\n     */\n    public static String getMethodDescriptor(final Type returnType, final Type[] argumentTypes) {\n        StringBuffer buf = new StringBuffer();\n        buf.append('(');\n        for (int i = 0; i < argumentTypes.length; ++i) {\n            argumentTypes[i].getDescriptor(buf);\n        }\n        buf.append(')');\n        returnType.getDescriptor(buf);\n        return buf.toString();\n    }\n\n    /**\n     * Appends the descriptor corresponding to this Java type to the given\n     * string buffer.\n     *\n     * @param buf the string buffer to which the descriptor must be appended.\n     */\n    private void getDescriptor(final StringBuffer buf) {\n        if (this.buf == null) {\n            // descriptor is in byte 3 of 'off' for primitive types (buf == null)\n            buf.append((char) ((off & 0xFF000000) >>> 24));\n        } else if (sort == ARRAY) {\n            buf.append(this.buf, off, len);\n        } else {\n            // sort == OBJECT\n            buf.append('L');\n            buf.append(this.buf, off, len);\n            buf.append(';');\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Direct conversion from classes to type descriptors,\n    // without intermediate Type objects\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the internal name of the given class. The internal name of a\n     * class is its fully qualified name, as returned by Class.getName(), where\n     * '.' are replaced by '/'.\n     *\n     * @param c an object or array class.\n     * @return the internal name of the given class.\n     */\n    public static String getInternalName(final Class c) {\n        return c.getName().replace('.', '/');\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given Java type.\n     *\n     * @param c an object class, a primitive class or an array class.\n     * @return the descriptor corresponding to the given class.\n     */\n    public static String getDescriptor(final Class c) {\n        StringBuffer buf = new StringBuffer();\n        getDescriptor(buf, c);\n        return buf.toString();\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given constructor.\n     *\n     * @param c a {@link Constructor Constructor} object.\n     * @return the descriptor of the given constructor.\n     */\n    public static String getConstructorDescriptor(final Constructor c) {\n        Class[] parameters = c.getParameterTypes();\n        StringBuffer buf = new StringBuffer();\n        buf.append('(');\n        for (int i = 0; i < parameters.length; ++i) {\n            getDescriptor(buf, parameters[i]);\n        }\n        return buf.append(\")V\").toString();\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given method.\n     *\n     * @param m a {@link Method Method} object.\n     * @return the descriptor of the given method.\n     */\n    public static String getMethodDescriptor(final Method m) {\n        Class[] parameters = m.getParameterTypes();\n        StringBuffer buf = new StringBuffer();\n        buf.append('(');\n        for (int i = 0; i < parameters.length; ++i) {\n            getDescriptor(buf, parameters[i]);\n        }\n        buf.append(')');\n        getDescriptor(buf, m.getReturnType());\n        return buf.toString();\n    }\n\n    /**\n     * Appends the descriptor of the given class to the given string buffer.\n     *\n     * @param buf the string buffer to which the descriptor must be appended.\n     * @param c the class whose descriptor must be computed.\n     */\n    private static void getDescriptor(final StringBuffer buf, final Class c) {\n        Class d = c;\n        while (true) {\n            if (d.isPrimitive()) {\n                char car;\n                if (d == Integer.TYPE) {\n                    car = 'I';\n                } else if (d == Void.TYPE) {\n                    car = 'V';\n                } else if (d == Boolean.TYPE) {\n                    car = 'Z';\n                } else if (d == Byte.TYPE) {\n                    car = 'B';\n                } else if (d == Character.TYPE) {\n                    car = 'C';\n                } else if (d == Short.TYPE) {\n                    car = 'S';\n                } else if (d == Double.TYPE) {\n                    car = 'D';\n                } else if (d == Float.TYPE) {\n                    car = 'F';\n                } else /* if (d == Long.TYPE) */\n                {\n                    car = 'J';\n                }\n                buf.append(car);\n                return;\n            } else if (d.isArray()) {\n                buf.append('[');\n                d = d.getComponentType();\n            } else {\n                buf.append('L');\n                String name = d.getName();\n                int len = name.length();\n                for (int i = 0; i < len; ++i) {\n                    char car = name.charAt(i);\n                    buf.append(car == '.' ? '/' : car);\n                }\n                buf.append(';');\n                return;\n            }\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Corresponding size and opcodes\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the size of values of this type.\n     *\n     * @return the size of values of this type, i.e., 2 for <tt>long</tt> and\n     *         <tt>double</tt>, 0 for <tt>void</tt> and 1 otherwise.\n     */\n    public int getSize() {\n        // the size is in byte 0 of 'off' for primitive types (buf == null)\n        return buf == null ? (off & 0xFF) : 1;\n    }\n\n    /**\n     * Returns a JVM instruction opcode adapted to this Java type.\n     *\n     * @param opcode a JVM instruction opcode. This opcode must be one of ILOAD,\n     *        ISTORE, IALOAD, IASTORE, IADD, ISUB, IMUL, IDIV, IREM, INEG, ISHL,\n     *        ISHR, IUSHR, IAND, IOR, IXOR and IRETURN.\n     * @return an opcode that is similar to the given opcode, but adapted to\n     *         this Java type. For example, if this type is <tt>float</tt> and\n     *         <tt>opcode</tt> is IRETURN, this method returns FRETURN.\n     */\n    public int getOpcode(final int opcode) {\n        if (opcode == Opcodes.IALOAD || opcode == Opcodes.IASTORE) {\n            // the offset for IALOAD or IASTORE is in byte 1 of 'off' for\n            // primitive types (buf == null)\n            return opcode + (buf == null ? (off & 0xFF00) >> 8 : 4);\n        } else {\n            // the offset for other instructions is in byte 2 of 'off' for\n            // primitive types (buf == null)\n            return opcode + (buf == null ? (off & 0xFF0000) >> 16 : 4);\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Equals, hashCode and toString\n    // ------------------------------------------------------------------------\n    /**\n     * Tests if the given object is equal to this type.\n     *\n     * @param o the object to be compared to this type.\n     * @return <tt>true</tt> if the given object is equal to this type.\n     */\n    public boolean equals(final Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (!(o instanceof Type)) {\n            return false;\n        }\n        Type t = (Type) o;\n        if (sort != t.sort) {\n            return false;\n        }\n        if (sort == OBJECT || sort == ARRAY) {\n            if (len != t.len) {\n                return false;\n            }\n            for (int i = off, j = t.off, end = i + len; i < end; i++, j++) {\n                if (buf[i] != t.buf[j]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code value for this type.\n     *\n     * @return a hash code value for this type.\n     */\n    public int hashCode() {\n        int hc = 13 * sort;\n        if (sort == OBJECT || sort == ARRAY) {\n            for (int i = off, end = i + len; i < end; i++) {\n                hc = 17 * (hc + buf[i]);\n            }\n        }\n        return hc;\n    }\n\n    /**\n     * Returns a string representation of this type.\n     *\n     * @return the descriptor of this type.\n     */\n    public String toString() {\n        return getDescriptor();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/TypeTest5.java",
		"test_prompt": "// TypeTest5.java\npackage org.objectweb.asm.jip;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Type}.\n* It contains ten unit test cases for the {@link Type#getReturnType(String)} method.\n*/\nclass TypeTest5 {"
	},
	{
		"original_code": "// Type.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\n\n/**\n * A Java type. This class can be used to make it easier to manipulate type and\n * method descriptors.\n *\n * @author Eric Bruneton\n * @author Chris Nokleberg\n */\npublic class Type {\n\n    /**\n     * The sort of the <tt>void</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int VOID = 0;\n\n    /**\n     * The sort of the <tt>boolean</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int BOOLEAN = 1;\n\n    /**\n     * The sort of the <tt>char</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int CHAR = 2;\n\n    /**\n     * The sort of the <tt>byte</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int BYTE = 3;\n\n    /**\n     * The sort of the <tt>short</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int SHORT = 4;\n\n    /**\n     * The sort of the <tt>int</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int INT = 5;\n\n    /**\n     * The sort of the <tt>float</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int FLOAT = 6;\n\n    /**\n     * The sort of the <tt>long</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int LONG = 7;\n\n    /**\n     * The sort of the <tt>double</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int DOUBLE = 8;\n\n    /**\n     * The sort of array reference types. See {@link #getSort getSort}.\n     */\n    public static final int ARRAY = 9;\n\n    /**\n     * The sort of object reference type. See {@link #getSort getSort}.\n     */\n    public static final int OBJECT = 10;\n\n    /**\n     * The <tt>void</tt> type.\n     */\n    public static final Type VOID_TYPE = new Type(VOID, null, ('V' << 24) | (5 << 16) | (0 << 8) | 0, 1);\n\n    /**\n     * The <tt>boolean</tt> type.\n     */\n    public static final Type BOOLEAN_TYPE = new Type(BOOLEAN, null, ('Z' << 24) | (0 << 16) | (5 << 8) | 1, 1);\n\n    /**\n     * The <tt>char</tt> type.\n     */\n    public static final Type CHAR_TYPE = new Type(CHAR, null, ('C' << 24) | (0 << 16) | (6 << 8) | 1, 1);\n\n    /**\n     * The <tt>byte</tt> type.\n     */\n    public static final Type BYTE_TYPE = new Type(BYTE, null, ('B' << 24) | (0 << 16) | (5 << 8) | 1, 1);\n\n    /**\n     * The <tt>short</tt> type.\n     */\n    public static final Type SHORT_TYPE = new Type(SHORT, null, ('S' << 24) | (0 << 16) | (7 << 8) | 1, 1);\n\n    /**\n     * The <tt>int</tt> type.\n     */\n    public static final Type INT_TYPE = new Type(INT, null, ('I' << 24) | (0 << 16) | (0 << 8) | 1, 1);\n\n    /**\n     * The <tt>float</tt> type.\n     */\n    public static final Type FLOAT_TYPE = new Type(FLOAT, null, ('F' << 24) | (2 << 16) | (2 << 8) | 1, 1);\n\n    /**\n     * The <tt>long</tt> type.\n     */\n    public static final Type LONG_TYPE = new Type(LONG, null, ('J' << 24) | (1 << 16) | (1 << 8) | 2, 1);\n\n    /**\n     * The <tt>double</tt> type.\n     */\n    public static final Type DOUBLE_TYPE = new Type(DOUBLE, null, ('D' << 24) | (3 << 16) | (3 << 8) | 2, 1);\n\n    // ------------------------------------------------------------------------\n    // Fields\n    // ------------------------------------------------------------------------\n    /**\n     * The sort of this Java type.\n     */\n    private final int sort;\n\n    /**\n     * A buffer containing the internal name of this Java type. This field is\n     * only used for reference types.\n     */\n    private final char[] buf;\n\n    /**\n     * The offset of the internal name of this Java type in {@link #buf buf} or,\n     * for primitive types, the size, descriptor and getOpcode offsets for this\n     * type (byte 0 contains the size, byte 1 the descriptor, byte 2 the offset\n     * for IALOAD or IASTORE, byte 3 the offset for all other instructions).\n     */\n    private final int off;\n\n    /**\n     * The length of the internal name of this Java type.\n     */\n    private final int len;\n\n    // ------------------------------------------------------------------------\n    // Constructors\n    // ------------------------------------------------------------------------\n    /**\n     * Constructs a reference type.\n     *\n     * @param sort the sort of the reference type to be constructed.\n     * @param buf a buffer containing the descriptor of the previous type.\n     * @param off the offset of this descriptor in the previous buffer.\n     * @param len the length of this descriptor.\n     */\n    private Type(final int sort, final char[] buf, final int off, final int len) {\n        this.sort = sort;\n        this.buf = buf;\n        this.off = off;\n        this.len = len;\n    }\n\n    /**\n     * Returns the Java type corresponding to the given type descriptor.\n     *\n     * @param typeDescriptor a type descriptor.\n     * @return the Java type corresponding to the given type descriptor.\n     */\n    public static Type getType(final String typeDescriptor) {\n        return getType(typeDescriptor.toCharArray(), 0);\n    }\n\n    /**\n     * Returns the Java type corresponding to the given internal name.\n     *\n     * @param internalName an internal name.\n     * @return the Java type corresponding to the given internal name.\n     */\n    public static Type getObjectType(final String internalName) {\n        char[] buf = internalName.toCharArray();\n        return new Type(buf[0] == '[' ? ARRAY : OBJECT, buf, 0, buf.length);\n    }\n\n    /**\n     * Returns the Java type corresponding to the given class.\n     *\n     * @param c a class.\n     * @return the Java type corresponding to the given class.\n     */\n    public static Type getType(final Class c) {\n        if (c.isPrimitive()) {\n            if (c == Integer.TYPE) {\n                return INT_TYPE;\n            } else if (c == Void.TYPE) {\n                return VOID_TYPE;\n            } else if (c == Boolean.TYPE) {\n                return BOOLEAN_TYPE;\n            } else if (c == Byte.TYPE) {\n                return BYTE_TYPE;\n            } else if (c == Character.TYPE) {\n                return CHAR_TYPE;\n            } else if (c == Short.TYPE) {\n                return SHORT_TYPE;\n            } else if (c == Double.TYPE) {\n                return DOUBLE_TYPE;\n            } else if (c == Float.TYPE) {\n                return FLOAT_TYPE;\n            } else /* if (c == Long.TYPE) */\n            {\n                return LONG_TYPE;\n            }\n        } else {\n            return getType(getDescriptor(c));\n        }\n    }\n\n    /**\n     * Returns the Java types corresponding to the argument types of the given\n     * method descriptor.\n     *\n     * @param methodDescriptor a method descriptor.\n     * @return the Java types corresponding to the argument types of the given\n     *         method descriptor.\n     */\n    public static Type[] getArgumentTypes(final String methodDescriptor) {\n        char[] buf = methodDescriptor.toCharArray();\n        int off = 1;\n        int size = 0;\n        while (true) {\n            char car = buf[off++];\n            if (car == ')') {\n                break;\n            } else if (car == 'L') {\n                while (buf[off++] != ';') {\n                }\n                ++size;\n            } else if (car != '[') {\n                ++size;\n            }\n        }\n        Type[] args = new Type[size];\n        off = 1;\n        size = 0;\n        while (buf[off] != ')') {\n            args[size] = getType(buf, off);\n            off += args[size].len + (args[size].sort == OBJECT ? 2 : 0);\n            size += 1;\n        }\n        return args;\n    }\n\n    /**\n     * Returns the Java types corresponding to the argument types of the given\n     * method.\n     *\n     * @param method a method.\n     * @return the Java types corresponding to the argument types of the given\n     *         method.\n     */\n    public static Type[] getArgumentTypes(final Method method) {\n        Class[] classes = method.getParameterTypes();\n        Type[] types = new Type[classes.length];\n        for (int i = classes.length - 1; i >= 0; --i) {\n            types[i] = getType(classes[i]);\n        }\n        return types;\n    }\n\n    /**\n     * Returns the Java type corresponding to the return type of the given\n     * method descriptor.\n     *\n     * @param methodDescriptor a method descriptor.\n     * @return the Java type corresponding to the return type of the given\n     *         method descriptor.\n     */\n    public static Type getReturnType(final String methodDescriptor) {\n        char[] buf = methodDescriptor.toCharArray();\n        return getType(buf, methodDescriptor.indexOf(')') + 1);\n    }\n\n    /**\n     * Returns the Java type corresponding to the return type of the given\n     * method.\n     *\n     * @param method a method.\n     * @return the Java type corresponding to the return type of the given\n     *         method.\n     */\n    public static Type getReturnType(final Method method) {\n        return getType(method.getReturnType());\n    }\n\n    /**\n     * Computes the size of the arguments and of the return value of a method.\n     *\n     * @param desc the descriptor of a method.\n     * @return the size of the arguments of the method (plus one for the\n     *         implicit this argument), argSize, and the size of its return\n     *         value, retSize, packed into a single int i =\n     *         <tt>(argSize << 2) | retSize</tt> (argSize is therefore equal\n     *         to <tt>i >> 2</tt>, and retSize to <tt>i & 0x03</tt>).\n     */\n    public static int getArgumentsAndReturnSizes(final String desc) {\n        int n = 1;\n        int c = 1;\n        while (true) {\n            char car = desc.charAt(c++);\n            if (car == ')') {\n                car = desc.charAt(c);\n                return n << 2 | (car == 'V' ? 0 : (car == 'D' || car == 'J' ? 2 : 1));\n            } else if (car == 'L') {\n                while (desc.charAt(c++) != ';') {\n                }\n                n += 1;\n            } else if (car == '[') {\n                while ((car = desc.charAt(c)) == '[') {\n                    ++c;\n                }\n                if (car == 'D' || car == 'J') {\n                    n -= 1;\n                }\n            } else if (car == 'D' || car == 'J') {\n                n += 2;\n            } else {\n                n += 1;\n            }\n        }\n    }\n\n    /**\n     * Returns the Java type corresponding to the given type descriptor.\n     *\n     * @param buf a buffer containing a type descriptor.\n     * @param off the offset of this descriptor in the previous buffer.\n     * @return the Java type corresponding to the given type descriptor.\n     */\n    private static Type getType(final char[] buf, final int off) {\n        int len;\n        switch(buf[off]) {\n            case 'V':\n                return VOID_TYPE;\n            case 'Z':\n                return BOOLEAN_TYPE;\n            case 'C':\n                return CHAR_TYPE;\n            case 'B':\n                return BYTE_TYPE;\n            case 'S':\n                return SHORT_TYPE;\n            case 'I':\n                return INT_TYPE;\n            case 'F':\n                return FLOAT_TYPE;\n            case 'J':\n                return LONG_TYPE;\n            case 'D':\n                return DOUBLE_TYPE;\n            case '[':\n                len = 1;\n                while (buf[off + len] == '[') {\n                    ++len;\n                }\n                if (buf[off + len] == 'L') {\n                    ++len;\n                    while (buf[off + len] != ';') {\n                        ++len;\n                    }\n                }\n                return new Type(ARRAY, buf, off, len + 1);\n            // case 'L':\n            default:\n                len = 1;\n                while (buf[off + len] != ';') {\n                    ++len;\n                }\n                return new Type(OBJECT, buf, off + 1, len - 1);\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Accessors\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the sort of this Java type.\n     *\n     * @return {@link #VOID VOID}, {@link #BOOLEAN BOOLEAN},\n     *         {@link #CHAR CHAR}, {@link #BYTE BYTE}, {@link #SHORT SHORT},\n     *         {@link #INT INT}, {@link #FLOAT FLOAT}, {@link #LONG LONG},\n     *         {@link #DOUBLE DOUBLE}, {@link #ARRAY ARRAY} or\n     *         {@link #OBJECT OBJECT}.\n     */\n    public int getSort() {\n        return sort;\n    }\n\n    /**\n     * Returns the number of dimensions of this array type. This method should\n     * only be used for an array type.\n     *\n     * @return the number of dimensions of this array type.\n     */\n    public int getDimensions() {\n        int i = 1;\n        while (buf[off + i] == '[') {\n            ++i;\n        }\n        return i;\n    }\n\n    /**\n     * Returns the type of the elements of this array type. This method should\n     * only be used for an array type.\n     *\n     * @return Returns the type of the elements of this array type.\n     */\n    public Type getElementType() {\n        return getType(buf, off + getDimensions());\n    }\n\n    /**\n     * Returns the name of the class corresponding to this type.\n     *\n     * @return the fully qualified name of the class corresponding to this type.\n     */\n    public String getClassName() {\n        switch(sort) {\n            case VOID:\n                return \"void\";\n            case BOOLEAN:\n                return \"boolean\";\n            case CHAR:\n                return \"char\";\n            case BYTE:\n                return \"byte\";\n            case SHORT:\n                return \"short\";\n            case INT:\n                return \"int\";\n            case FLOAT:\n                return \"float\";\n            case LONG:\n                return \"long\";\n            case DOUBLE:\n                return \"double\";\n            case ARRAY:\n                StringBuffer b = new StringBuffer(getElementType().getClassName());\n                for (int i = getDimensions(); i > 0; --i) {\n                    b.append(\"[]\");\n                }\n                return b.toString();\n            // case OBJECT:\n            default:\n                return new String(buf, off, len).replace('/', '.');\n        }\n    }\n\n    /**\n     * Returns the internal name of the class corresponding to this object or\n     * array type. The internal name of a class is its fully qualified name (as\n     * returned by Class.getName(), where '.' are replaced by '/'. This method\n     * should only be used for an object or array type.\n     *\n     * @return the internal name of the class corresponding to this object type.\n     */\n    public String getInternalName() {\n        return new String(buf, off, len);\n    }\n\n    // ------------------------------------------------------------------------\n    // Conversion to type descriptors\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the descriptor corresponding to this Java type.\n     *\n     * @return the descriptor corresponding to this Java type.\n     */\n    public String getDescriptor() {\n        StringBuffer buf = new StringBuffer();\n        getDescriptor(buf);\n        return buf.toString();\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given argument and return\n     * types.\n     *\n     * @param returnType the return type of the method.\n     * @param argumentTypes the argument types of the method.\n     * @return the descriptor corresponding to the given argument and return\n     *         types.\n     */\n    public static String getMethodDescriptor(final Type returnType, final Type[] argumentTypes) {\n        StringBuffer buf = new StringBuffer();\n        buf.append('(');\n        for (int i = 0; i < argumentTypes.length; ++i) {\n            argumentTypes[i].getDescriptor(buf);\n        }\n        buf.append(')');\n        returnType.getDescriptor(buf);\n        return buf.toString();\n    }\n\n    /**\n     * Appends the descriptor corresponding to this Java type to the given\n     * string buffer.\n     *\n     * @param buf the string buffer to which the descriptor must be appended.\n     */\n    private void getDescriptor(final StringBuffer buf) {\n        if (this.buf == null) {\n            // descriptor is in byte 3 of 'off' for primitive types (buf == null)\n            buf.append((char) ((off & 0xFF000000) >>> 24));\n        } else if (sort == ARRAY) {\n            buf.append(this.buf, off, len);\n        } else {\n            // sort == OBJECT\n            buf.append('L');\n            buf.append(this.buf, off, len);\n            buf.append(';');\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Direct conversion from classes to type descriptors,\n    // without intermediate Type objects\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the internal name of the given class. The internal name of a\n     * class is its fully qualified name, as returned by Class.getName(), where\n     * '.' are replaced by '/'.\n     *\n     * @param c an object or array class.\n     * @return the internal name of the given class.\n     */\n    public static String getInternalName(final Class c) {\n        return c.getName().replace('.', '/');\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given Java type.\n     *\n     * @param c an object class, a primitive class or an array class.\n     * @return the descriptor corresponding to the given class.\n     */\n    public static String getDescriptor(final Class c) {\n        StringBuffer buf = new StringBuffer();\n        getDescriptor(buf, c);\n        return buf.toString();\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given constructor.\n     *\n     * @param c a {@link Constructor Constructor} object.\n     * @return the descriptor of the given constructor.\n     */\n    public static String getConstructorDescriptor(final Constructor c) {\n        Class[] parameters = c.getParameterTypes();\n        StringBuffer buf = new StringBuffer();\n        buf.append('(');\n        for (int i = 0; i < parameters.length; ++i) {\n            getDescriptor(buf, parameters[i]);\n        }\n        return buf.append(\")V\").toString();\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given method.\n     *\n     * @param m a {@link Method Method} object.\n     * @return the descriptor of the given method.\n     */\n    public static String getMethodDescriptor(final Method m) {\n        Class[] parameters = m.getParameterTypes();\n        StringBuffer buf = new StringBuffer();\n        buf.append('(');\n        for (int i = 0; i < parameters.length; ++i) {\n            getDescriptor(buf, parameters[i]);\n        }\n        buf.append(')');\n        getDescriptor(buf, m.getReturnType());\n        return buf.toString();\n    }\n\n    /**\n     * Appends the descriptor of the given class to the given string buffer.\n     *\n     * @param buf the string buffer to which the descriptor must be appended.\n     * @param c the class whose descriptor must be computed.\n     */\n    private static void getDescriptor(final StringBuffer buf, final Class c) {\n        Class d = c;\n        while (true) {\n            if (d.isPrimitive()) {\n                char car;\n                if (d == Integer.TYPE) {\n                    car = 'I';\n                } else if (d == Void.TYPE) {\n                    car = 'V';\n                } else if (d == Boolean.TYPE) {\n                    car = 'Z';\n                } else if (d == Byte.TYPE) {\n                    car = 'B';\n                } else if (d == Character.TYPE) {\n                    car = 'C';\n                } else if (d == Short.TYPE) {\n                    car = 'S';\n                } else if (d == Double.TYPE) {\n                    car = 'D';\n                } else if (d == Float.TYPE) {\n                    car = 'F';\n                } else /* if (d == Long.TYPE) */\n                {\n                    car = 'J';\n                }\n                buf.append(car);\n                return;\n            } else if (d.isArray()) {\n                buf.append('[');\n                d = d.getComponentType();\n            } else {\n                buf.append('L');\n                String name = d.getName();\n                int len = name.length();\n                for (int i = 0; i < len; ++i) {\n                    char car = name.charAt(i);\n                    buf.append(car == '.' ? '/' : car);\n                }\n                buf.append(';');\n                return;\n            }\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Corresponding size and opcodes\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the size of values of this type.\n     *\n     * @return the size of values of this type, i.e., 2 for <tt>long</tt> and\n     *         <tt>double</tt>, 0 for <tt>void</tt> and 1 otherwise.\n     */\n    public int getSize() {\n        // the size is in byte 0 of 'off' for primitive types (buf == null)\n        return buf == null ? (off & 0xFF) : 1;\n    }\n\n    /**\n     * Returns a JVM instruction opcode adapted to this Java type.\n     *\n     * @param opcode a JVM instruction opcode. This opcode must be one of ILOAD,\n     *        ISTORE, IALOAD, IASTORE, IADD, ISUB, IMUL, IDIV, IREM, INEG, ISHL,\n     *        ISHR, IUSHR, IAND, IOR, IXOR and IRETURN.\n     * @return an opcode that is similar to the given opcode, but adapted to\n     *         this Java type. For example, if this type is <tt>float</tt> and\n     *         <tt>opcode</tt> is IRETURN, this method returns FRETURN.\n     */\n    public int getOpcode(final int opcode) {\n        if (opcode == Opcodes.IALOAD || opcode == Opcodes.IASTORE) {\n            // the offset for IALOAD or IASTORE is in byte 1 of 'off' for\n            // primitive types (buf == null)\n            return opcode + (buf == null ? (off & 0xFF00) >> 8 : 4);\n        } else {\n            // the offset for other instructions is in byte 2 of 'off' for\n            // primitive types (buf == null)\n            return opcode + (buf == null ? (off & 0xFF0000) >> 16 : 4);\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Equals, hashCode and toString\n    // ------------------------------------------------------------------------\n    /**\n     * Tests if the given object is equal to this type.\n     *\n     * @param o the object to be compared to this type.\n     * @return <tt>true</tt> if the given object is equal to this type.\n     */\n    public boolean equals(final Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (!(o instanceof Type)) {\n            return false;\n        }\n        Type t = (Type) o;\n        if (sort != t.sort) {\n            return false;\n        }\n        if (sort == OBJECT || sort == ARRAY) {\n            if (len != t.len) {\n                return false;\n            }\n            for (int i = off, j = t.off, end = i + len; i < end; i++, j++) {\n                if (buf[i] != t.buf[j]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code value for this type.\n     *\n     * @return a hash code value for this type.\n     */\n    public int hashCode() {\n        int hc = 13 * sort;\n        if (sort == OBJECT || sort == ARRAY) {\n            for (int i = off, end = i + len; i < end; i++) {\n                hc = 17 * (hc + buf[i]);\n            }\n        }\n        return hc;\n    }\n\n    /**\n     * Returns a string representation of this type.\n     *\n     * @return the descriptor of this type.\n     */\n    public String toString() {\n        return getDescriptor();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/TypeTest6.java",
		"test_prompt": "// TypeTest6.java\npackage org.objectweb.asm.jip;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Type}.\n* It contains ten unit test cases for the {@link Type#getReturnType(Method)} method.\n*/\nclass TypeTest6 {"
	},
	{
		"original_code": "// Type.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\n\n/**\n * A Java type. This class can be used to make it easier to manipulate type and\n * method descriptors.\n *\n * @author Eric Bruneton\n * @author Chris Nokleberg\n */\npublic class Type {\n\n    /**\n     * The sort of the <tt>void</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int VOID = 0;\n\n    /**\n     * The sort of the <tt>boolean</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int BOOLEAN = 1;\n\n    /**\n     * The sort of the <tt>char</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int CHAR = 2;\n\n    /**\n     * The sort of the <tt>byte</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int BYTE = 3;\n\n    /**\n     * The sort of the <tt>short</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int SHORT = 4;\n\n    /**\n     * The sort of the <tt>int</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int INT = 5;\n\n    /**\n     * The sort of the <tt>float</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int FLOAT = 6;\n\n    /**\n     * The sort of the <tt>long</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int LONG = 7;\n\n    /**\n     * The sort of the <tt>double</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int DOUBLE = 8;\n\n    /**\n     * The sort of array reference types. See {@link #getSort getSort}.\n     */\n    public static final int ARRAY = 9;\n\n    /**\n     * The sort of object reference type. See {@link #getSort getSort}.\n     */\n    public static final int OBJECT = 10;\n\n    /**\n     * The <tt>void</tt> type.\n     */\n    public static final Type VOID_TYPE = new Type(VOID, null, ('V' << 24) | (5 << 16) | (0 << 8) | 0, 1);\n\n    /**\n     * The <tt>boolean</tt> type.\n     */\n    public static final Type BOOLEAN_TYPE = new Type(BOOLEAN, null, ('Z' << 24) | (0 << 16) | (5 << 8) | 1, 1);\n\n    /**\n     * The <tt>char</tt> type.\n     */\n    public static final Type CHAR_TYPE = new Type(CHAR, null, ('C' << 24) | (0 << 16) | (6 << 8) | 1, 1);\n\n    /**\n     * The <tt>byte</tt> type.\n     */\n    public static final Type BYTE_TYPE = new Type(BYTE, null, ('B' << 24) | (0 << 16) | (5 << 8) | 1, 1);\n\n    /**\n     * The <tt>short</tt> type.\n     */\n    public static final Type SHORT_TYPE = new Type(SHORT, null, ('S' << 24) | (0 << 16) | (7 << 8) | 1, 1);\n\n    /**\n     * The <tt>int</tt> type.\n     */\n    public static final Type INT_TYPE = new Type(INT, null, ('I' << 24) | (0 << 16) | (0 << 8) | 1, 1);\n\n    /**\n     * The <tt>float</tt> type.\n     */\n    public static final Type FLOAT_TYPE = new Type(FLOAT, null, ('F' << 24) | (2 << 16) | (2 << 8) | 1, 1);\n\n    /**\n     * The <tt>long</tt> type.\n     */\n    public static final Type LONG_TYPE = new Type(LONG, null, ('J' << 24) | (1 << 16) | (1 << 8) | 2, 1);\n\n    /**\n     * The <tt>double</tt> type.\n     */\n    public static final Type DOUBLE_TYPE = new Type(DOUBLE, null, ('D' << 24) | (3 << 16) | (3 << 8) | 2, 1);\n\n    // ------------------------------------------------------------------------\n    // Fields\n    // ------------------------------------------------------------------------\n    /**\n     * The sort of this Java type.\n     */\n    private final int sort;\n\n    /**\n     * A buffer containing the internal name of this Java type. This field is\n     * only used for reference types.\n     */\n    private final char[] buf;\n\n    /**\n     * The offset of the internal name of this Java type in {@link #buf buf} or,\n     * for primitive types, the size, descriptor and getOpcode offsets for this\n     * type (byte 0 contains the size, byte 1 the descriptor, byte 2 the offset\n     * for IALOAD or IASTORE, byte 3 the offset for all other instructions).\n     */\n    private final int off;\n\n    /**\n     * The length of the internal name of this Java type.\n     */\n    private final int len;\n\n    // ------------------------------------------------------------------------\n    // Constructors\n    // ------------------------------------------------------------------------\n    /**\n     * Constructs a reference type.\n     *\n     * @param sort the sort of the reference type to be constructed.\n     * @param buf a buffer containing the descriptor of the previous type.\n     * @param off the offset of this descriptor in the previous buffer.\n     * @param len the length of this descriptor.\n     */\n    private Type(final int sort, final char[] buf, final int off, final int len) {\n        this.sort = sort;\n        this.buf = buf;\n        this.off = off;\n        this.len = len;\n    }\n\n    /**\n     * Returns the Java type corresponding to the given type descriptor.\n     *\n     * @param typeDescriptor a type descriptor.\n     * @return the Java type corresponding to the given type descriptor.\n     */\n    public static Type getType(final String typeDescriptor) {\n        return getType(typeDescriptor.toCharArray(), 0);\n    }\n\n    /**\n     * Returns the Java type corresponding to the given internal name.\n     *\n     * @param internalName an internal name.\n     * @return the Java type corresponding to the given internal name.\n     */\n    public static Type getObjectType(final String internalName) {\n        char[] buf = internalName.toCharArray();\n        return new Type(buf[0] == '[' ? ARRAY : OBJECT, buf, 0, buf.length);\n    }\n\n    /**\n     * Returns the Java type corresponding to the given class.\n     *\n     * @param c a class.\n     * @return the Java type corresponding to the given class.\n     */\n    public static Type getType(final Class c) {\n        if (c.isPrimitive()) {\n            if (c == Integer.TYPE) {\n                return INT_TYPE;\n            } else if (c == Void.TYPE) {\n                return VOID_TYPE;\n            } else if (c == Boolean.TYPE) {\n                return BOOLEAN_TYPE;\n            } else if (c == Byte.TYPE) {\n                return BYTE_TYPE;\n            } else if (c == Character.TYPE) {\n                return CHAR_TYPE;\n            } else if (c == Short.TYPE) {\n                return SHORT_TYPE;\n            } else if (c == Double.TYPE) {\n                return DOUBLE_TYPE;\n            } else if (c == Float.TYPE) {\n                return FLOAT_TYPE;\n            } else /* if (c == Long.TYPE) */\n            {\n                return LONG_TYPE;\n            }\n        } else {\n            return getType(getDescriptor(c));\n        }\n    }\n\n    /**\n     * Returns the Java types corresponding to the argument types of the given\n     * method descriptor.\n     *\n     * @param methodDescriptor a method descriptor.\n     * @return the Java types corresponding to the argument types of the given\n     *         method descriptor.\n     */\n    public static Type[] getArgumentTypes(final String methodDescriptor) {\n        char[] buf = methodDescriptor.toCharArray();\n        int off = 1;\n        int size = 0;\n        while (true) {\n            char car = buf[off++];\n            if (car == ')') {\n                break;\n            } else if (car == 'L') {\n                while (buf[off++] != ';') {\n                }\n                ++size;\n            } else if (car != '[') {\n                ++size;\n            }\n        }\n        Type[] args = new Type[size];\n        off = 1;\n        size = 0;\n        while (buf[off] != ')') {\n            args[size] = getType(buf, off);\n            off += args[size].len + (args[size].sort == OBJECT ? 2 : 0);\n            size += 1;\n        }\n        return args;\n    }\n\n    /**\n     * Returns the Java types corresponding to the argument types of the given\n     * method.\n     *\n     * @param method a method.\n     * @return the Java types corresponding to the argument types of the given\n     *         method.\n     */\n    public static Type[] getArgumentTypes(final Method method) {\n        Class[] classes = method.getParameterTypes();\n        Type[] types = new Type[classes.length];\n        for (int i = classes.length - 1; i >= 0; --i) {\n            types[i] = getType(classes[i]);\n        }\n        return types;\n    }\n\n    /**\n     * Returns the Java type corresponding to the return type of the given\n     * method descriptor.\n     *\n     * @param methodDescriptor a method descriptor.\n     * @return the Java type corresponding to the return type of the given\n     *         method descriptor.\n     */\n    public static Type getReturnType(final String methodDescriptor) {\n        char[] buf = methodDescriptor.toCharArray();\n        return getType(buf, methodDescriptor.indexOf(')') + 1);\n    }\n\n    /**\n     * Returns the Java type corresponding to the return type of the given\n     * method.\n     *\n     * @param method a method.\n     * @return the Java type corresponding to the return type of the given\n     *         method.\n     */\n    public static Type getReturnType(final Method method) {\n        return getType(method.getReturnType());\n    }\n\n    /**\n     * Computes the size of the arguments and of the return value of a method.\n     *\n     * @param desc the descriptor of a method.\n     * @return the size of the arguments of the method (plus one for the\n     *         implicit this argument), argSize, and the size of its return\n     *         value, retSize, packed into a single int i =\n     *         <tt>(argSize << 2) | retSize</tt> (argSize is therefore equal\n     *         to <tt>i >> 2</tt>, and retSize to <tt>i & 0x03</tt>).\n     */\n    public static int getArgumentsAndReturnSizes(final String desc) {\n        int n = 1;\n        int c = 1;\n        while (true) {\n            char car = desc.charAt(c++);\n            if (car == ')') {\n                car = desc.charAt(c);\n                return n << 2 | (car == 'V' ? 0 : (car == 'D' || car == 'J' ? 2 : 1));\n            } else if (car == 'L') {\n                while (desc.charAt(c++) != ';') {\n                }\n                n += 1;\n            } else if (car == '[') {\n                while ((car = desc.charAt(c)) == '[') {\n                    ++c;\n                }\n                if (car == 'D' || car == 'J') {\n                    n -= 1;\n                }\n            } else if (car == 'D' || car == 'J') {\n                n += 2;\n            } else {\n                n += 1;\n            }\n        }\n    }\n\n    /**\n     * Returns the Java type corresponding to the given type descriptor.\n     *\n     * @param buf a buffer containing a type descriptor.\n     * @param off the offset of this descriptor in the previous buffer.\n     * @return the Java type corresponding to the given type descriptor.\n     */\n    private static Type getType(final char[] buf, final int off) {\n        int len;\n        switch(buf[off]) {\n            case 'V':\n                return VOID_TYPE;\n            case 'Z':\n                return BOOLEAN_TYPE;\n            case 'C':\n                return CHAR_TYPE;\n            case 'B':\n                return BYTE_TYPE;\n            case 'S':\n                return SHORT_TYPE;\n            case 'I':\n                return INT_TYPE;\n            case 'F':\n                return FLOAT_TYPE;\n            case 'J':\n                return LONG_TYPE;\n            case 'D':\n                return DOUBLE_TYPE;\n            case '[':\n                len = 1;\n                while (buf[off + len] == '[') {\n                    ++len;\n                }\n                if (buf[off + len] == 'L') {\n                    ++len;\n                    while (buf[off + len] != ';') {\n                        ++len;\n                    }\n                }\n                return new Type(ARRAY, buf, off, len + 1);\n            // case 'L':\n            default:\n                len = 1;\n                while (buf[off + len] != ';') {\n                    ++len;\n                }\n                return new Type(OBJECT, buf, off + 1, len - 1);\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Accessors\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the sort of this Java type.\n     *\n     * @return {@link #VOID VOID}, {@link #BOOLEAN BOOLEAN},\n     *         {@link #CHAR CHAR}, {@link #BYTE BYTE}, {@link #SHORT SHORT},\n     *         {@link #INT INT}, {@link #FLOAT FLOAT}, {@link #LONG LONG},\n     *         {@link #DOUBLE DOUBLE}, {@link #ARRAY ARRAY} or\n     *         {@link #OBJECT OBJECT}.\n     */\n    public int getSort() {\n        return sort;\n    }\n\n    /**\n     * Returns the number of dimensions of this array type. This method should\n     * only be used for an array type.\n     *\n     * @return the number of dimensions of this array type.\n     */\n    public int getDimensions() {\n        int i = 1;\n        while (buf[off + i] == '[') {\n            ++i;\n        }\n        return i;\n    }\n\n    /**\n     * Returns the type of the elements of this array type. This method should\n     * only be used for an array type.\n     *\n     * @return Returns the type of the elements of this array type.\n     */\n    public Type getElementType() {\n        return getType(buf, off + getDimensions());\n    }\n\n    /**\n     * Returns the name of the class corresponding to this type.\n     *\n     * @return the fully qualified name of the class corresponding to this type.\n     */\n    public String getClassName() {\n        switch(sort) {\n            case VOID:\n                return \"void\";\n            case BOOLEAN:\n                return \"boolean\";\n            case CHAR:\n                return \"char\";\n            case BYTE:\n                return \"byte\";\n            case SHORT:\n                return \"short\";\n            case INT:\n                return \"int\";\n            case FLOAT:\n                return \"float\";\n            case LONG:\n                return \"long\";\n            case DOUBLE:\n                return \"double\";\n            case ARRAY:\n                StringBuffer b = new StringBuffer(getElementType().getClassName());\n                for (int i = getDimensions(); i > 0; --i) {\n                    b.append(\"[]\");\n                }\n                return b.toString();\n            // case OBJECT:\n            default:\n                return new String(buf, off, len).replace('/', '.');\n        }\n    }\n\n    /**\n     * Returns the internal name of the class corresponding to this object or\n     * array type. The internal name of a class is its fully qualified name (as\n     * returned by Class.getName(), where '.' are replaced by '/'. This method\n     * should only be used for an object or array type.\n     *\n     * @return the internal name of the class corresponding to this object type.\n     */\n    public String getInternalName() {\n        return new String(buf, off, len);\n    }\n\n    // ------------------------------------------------------------------------\n    // Conversion to type descriptors\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the descriptor corresponding to this Java type.\n     *\n     * @return the descriptor corresponding to this Java type.\n     */\n    public String getDescriptor() {\n        StringBuffer buf = new StringBuffer();\n        getDescriptor(buf);\n        return buf.toString();\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given argument and return\n     * types.\n     *\n     * @param returnType the return type of the method.\n     * @param argumentTypes the argument types of the method.\n     * @return the descriptor corresponding to the given argument and return\n     *         types.\n     */\n    public static String getMethodDescriptor(final Type returnType, final Type[] argumentTypes) {\n        StringBuffer buf = new StringBuffer();\n        buf.append('(');\n        for (int i = 0; i < argumentTypes.length; ++i) {\n            argumentTypes[i].getDescriptor(buf);\n        }\n        buf.append(')');\n        returnType.getDescriptor(buf);\n        return buf.toString();\n    }\n\n    /**\n     * Appends the descriptor corresponding to this Java type to the given\n     * string buffer.\n     *\n     * @param buf the string buffer to which the descriptor must be appended.\n     */\n    private void getDescriptor(final StringBuffer buf) {\n        if (this.buf == null) {\n            // descriptor is in byte 3 of 'off' for primitive types (buf == null)\n            buf.append((char) ((off & 0xFF000000) >>> 24));\n        } else if (sort == ARRAY) {\n            buf.append(this.buf, off, len);\n        } else {\n            // sort == OBJECT\n            buf.append('L');\n            buf.append(this.buf, off, len);\n            buf.append(';');\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Direct conversion from classes to type descriptors,\n    // without intermediate Type objects\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the internal name of the given class. The internal name of a\n     * class is its fully qualified name, as returned by Class.getName(), where\n     * '.' are replaced by '/'.\n     *\n     * @param c an object or array class.\n     * @return the internal name of the given class.\n     */\n    public static String getInternalName(final Class c) {\n        return c.getName().replace('.', '/');\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given Java type.\n     *\n     * @param c an object class, a primitive class or an array class.\n     * @return the descriptor corresponding to the given class.\n     */\n    public static String getDescriptor(final Class c) {\n        StringBuffer buf = new StringBuffer();\n        getDescriptor(buf, c);\n        return buf.toString();\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given constructor.\n     *\n     * @param c a {@link Constructor Constructor} object.\n     * @return the descriptor of the given constructor.\n     */\n    public static String getConstructorDescriptor(final Constructor c) {\n        Class[] parameters = c.getParameterTypes();\n        StringBuffer buf = new StringBuffer();\n        buf.append('(');\n        for (int i = 0; i < parameters.length; ++i) {\n            getDescriptor(buf, parameters[i]);\n        }\n        return buf.append(\")V\").toString();\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given method.\n     *\n     * @param m a {@link Method Method} object.\n     * @return the descriptor of the given method.\n     */\n    public static String getMethodDescriptor(final Method m) {\n        Class[] parameters = m.getParameterTypes();\n        StringBuffer buf = new StringBuffer();\n        buf.append('(');\n        for (int i = 0; i < parameters.length; ++i) {\n            getDescriptor(buf, parameters[i]);\n        }\n        buf.append(')');\n        getDescriptor(buf, m.getReturnType());\n        return buf.toString();\n    }\n\n    /**\n     * Appends the descriptor of the given class to the given string buffer.\n     *\n     * @param buf the string buffer to which the descriptor must be appended.\n     * @param c the class whose descriptor must be computed.\n     */\n    private static void getDescriptor(final StringBuffer buf, final Class c) {\n        Class d = c;\n        while (true) {\n            if (d.isPrimitive()) {\n                char car;\n                if (d == Integer.TYPE) {\n                    car = 'I';\n                } else if (d == Void.TYPE) {\n                    car = 'V';\n                } else if (d == Boolean.TYPE) {\n                    car = 'Z';\n                } else if (d == Byte.TYPE) {\n                    car = 'B';\n                } else if (d == Character.TYPE) {\n                    car = 'C';\n                } else if (d == Short.TYPE) {\n                    car = 'S';\n                } else if (d == Double.TYPE) {\n                    car = 'D';\n                } else if (d == Float.TYPE) {\n                    car = 'F';\n                } else /* if (d == Long.TYPE) */\n                {\n                    car = 'J';\n                }\n                buf.append(car);\n                return;\n            } else if (d.isArray()) {\n                buf.append('[');\n                d = d.getComponentType();\n            } else {\n                buf.append('L');\n                String name = d.getName();\n                int len = name.length();\n                for (int i = 0; i < len; ++i) {\n                    char car = name.charAt(i);\n                    buf.append(car == '.' ? '/' : car);\n                }\n                buf.append(';');\n                return;\n            }\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Corresponding size and opcodes\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the size of values of this type.\n     *\n     * @return the size of values of this type, i.e., 2 for <tt>long</tt> and\n     *         <tt>double</tt>, 0 for <tt>void</tt> and 1 otherwise.\n     */\n    public int getSize() {\n        // the size is in byte 0 of 'off' for primitive types (buf == null)\n        return buf == null ? (off & 0xFF) : 1;\n    }\n\n    /**\n     * Returns a JVM instruction opcode adapted to this Java type.\n     *\n     * @param opcode a JVM instruction opcode. This opcode must be one of ILOAD,\n     *        ISTORE, IALOAD, IASTORE, IADD, ISUB, IMUL, IDIV, IREM, INEG, ISHL,\n     *        ISHR, IUSHR, IAND, IOR, IXOR and IRETURN.\n     * @return an opcode that is similar to the given opcode, but adapted to\n     *         this Java type. For example, if this type is <tt>float</tt> and\n     *         <tt>opcode</tt> is IRETURN, this method returns FRETURN.\n     */\n    public int getOpcode(final int opcode) {\n        if (opcode == Opcodes.IALOAD || opcode == Opcodes.IASTORE) {\n            // the offset for IALOAD or IASTORE is in byte 1 of 'off' for\n            // primitive types (buf == null)\n            return opcode + (buf == null ? (off & 0xFF00) >> 8 : 4);\n        } else {\n            // the offset for other instructions is in byte 2 of 'off' for\n            // primitive types (buf == null)\n            return opcode + (buf == null ? (off & 0xFF0000) >> 16 : 4);\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Equals, hashCode and toString\n    // ------------------------------------------------------------------------\n    /**\n     * Tests if the given object is equal to this type.\n     *\n     * @param o the object to be compared to this type.\n     * @return <tt>true</tt> if the given object is equal to this type.\n     */\n    public boolean equals(final Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (!(o instanceof Type)) {\n            return false;\n        }\n        Type t = (Type) o;\n        if (sort != t.sort) {\n            return false;\n        }\n        if (sort == OBJECT || sort == ARRAY) {\n            if (len != t.len) {\n                return false;\n            }\n            for (int i = off, j = t.off, end = i + len; i < end; i++, j++) {\n                if (buf[i] != t.buf[j]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code value for this type.\n     *\n     * @return a hash code value for this type.\n     */\n    public int hashCode() {\n        int hc = 13 * sort;\n        if (sort == OBJECT || sort == ARRAY) {\n            for (int i = off, end = i + len; i < end; i++) {\n                hc = 17 * (hc + buf[i]);\n            }\n        }\n        return hc;\n    }\n\n    /**\n     * Returns a string representation of this type.\n     *\n     * @return the descriptor of this type.\n     */\n    public String toString() {\n        return getDescriptor();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/TypeTest7.java",
		"test_prompt": "// TypeTest7.java\npackage org.objectweb.asm.jip;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Type}.\n* It contains ten unit test cases for the {@link Type#getArgumentsAndReturnSizes(String)} method.\n*/\nclass TypeTest7 {"
	},
	{
		"original_code": "// Type.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\n\n/**\n * A Java type. This class can be used to make it easier to manipulate type and\n * method descriptors.\n *\n * @author Eric Bruneton\n * @author Chris Nokleberg\n */\npublic class Type {\n\n    /**\n     * The sort of the <tt>void</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int VOID = 0;\n\n    /**\n     * The sort of the <tt>boolean</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int BOOLEAN = 1;\n\n    /**\n     * The sort of the <tt>char</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int CHAR = 2;\n\n    /**\n     * The sort of the <tt>byte</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int BYTE = 3;\n\n    /**\n     * The sort of the <tt>short</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int SHORT = 4;\n\n    /**\n     * The sort of the <tt>int</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int INT = 5;\n\n    /**\n     * The sort of the <tt>float</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int FLOAT = 6;\n\n    /**\n     * The sort of the <tt>long</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int LONG = 7;\n\n    /**\n     * The sort of the <tt>double</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int DOUBLE = 8;\n\n    /**\n     * The sort of array reference types. See {@link #getSort getSort}.\n     */\n    public static final int ARRAY = 9;\n\n    /**\n     * The sort of object reference type. See {@link #getSort getSort}.\n     */\n    public static final int OBJECT = 10;\n\n    /**\n     * The <tt>void</tt> type.\n     */\n    public static final Type VOID_TYPE = new Type(VOID, null, ('V' << 24) | (5 << 16) | (0 << 8) | 0, 1);\n\n    /**\n     * The <tt>boolean</tt> type.\n     */\n    public static final Type BOOLEAN_TYPE = new Type(BOOLEAN, null, ('Z' << 24) | (0 << 16) | (5 << 8) | 1, 1);\n\n    /**\n     * The <tt>char</tt> type.\n     */\n    public static final Type CHAR_TYPE = new Type(CHAR, null, ('C' << 24) | (0 << 16) | (6 << 8) | 1, 1);\n\n    /**\n     * The <tt>byte</tt> type.\n     */\n    public static final Type BYTE_TYPE = new Type(BYTE, null, ('B' << 24) | (0 << 16) | (5 << 8) | 1, 1);\n\n    /**\n     * The <tt>short</tt> type.\n     */\n    public static final Type SHORT_TYPE = new Type(SHORT, null, ('S' << 24) | (0 << 16) | (7 << 8) | 1, 1);\n\n    /**\n     * The <tt>int</tt> type.\n     */\n    public static final Type INT_TYPE = new Type(INT, null, ('I' << 24) | (0 << 16) | (0 << 8) | 1, 1);\n\n    /**\n     * The <tt>float</tt> type.\n     */\n    public static final Type FLOAT_TYPE = new Type(FLOAT, null, ('F' << 24) | (2 << 16) | (2 << 8) | 1, 1);\n\n    /**\n     * The <tt>long</tt> type.\n     */\n    public static final Type LONG_TYPE = new Type(LONG, null, ('J' << 24) | (1 << 16) | (1 << 8) | 2, 1);\n\n    /**\n     * The <tt>double</tt> type.\n     */\n    public static final Type DOUBLE_TYPE = new Type(DOUBLE, null, ('D' << 24) | (3 << 16) | (3 << 8) | 2, 1);\n\n    // ------------------------------------------------------------------------\n    // Fields\n    // ------------------------------------------------------------------------\n    /**\n     * The sort of this Java type.\n     */\n    private final int sort;\n\n    /**\n     * A buffer containing the internal name of this Java type. This field is\n     * only used for reference types.\n     */\n    private final char[] buf;\n\n    /**\n     * The offset of the internal name of this Java type in {@link #buf buf} or,\n     * for primitive types, the size, descriptor and getOpcode offsets for this\n     * type (byte 0 contains the size, byte 1 the descriptor, byte 2 the offset\n     * for IALOAD or IASTORE, byte 3 the offset for all other instructions).\n     */\n    private final int off;\n\n    /**\n     * The length of the internal name of this Java type.\n     */\n    private final int len;\n\n    // ------------------------------------------------------------------------\n    // Constructors\n    // ------------------------------------------------------------------------\n    /**\n     * Constructs a reference type.\n     *\n     * @param sort the sort of the reference type to be constructed.\n     * @param buf a buffer containing the descriptor of the previous type.\n     * @param off the offset of this descriptor in the previous buffer.\n     * @param len the length of this descriptor.\n     */\n    private Type(final int sort, final char[] buf, final int off, final int len) {\n        this.sort = sort;\n        this.buf = buf;\n        this.off = off;\n        this.len = len;\n    }\n\n    /**\n     * Returns the Java type corresponding to the given type descriptor.\n     *\n     * @param typeDescriptor a type descriptor.\n     * @return the Java type corresponding to the given type descriptor.\n     */\n    public static Type getType(final String typeDescriptor) {\n        return getType(typeDescriptor.toCharArray(), 0);\n    }\n\n    /**\n     * Returns the Java type corresponding to the given internal name.\n     *\n     * @param internalName an internal name.\n     * @return the Java type corresponding to the given internal name.\n     */\n    public static Type getObjectType(final String internalName) {\n        char[] buf = internalName.toCharArray();\n        return new Type(buf[0] == '[' ? ARRAY : OBJECT, buf, 0, buf.length);\n    }\n\n    /**\n     * Returns the Java type corresponding to the given class.\n     *\n     * @param c a class.\n     * @return the Java type corresponding to the given class.\n     */\n    public static Type getType(final Class c) {\n        if (c.isPrimitive()) {\n            if (c == Integer.TYPE) {\n                return INT_TYPE;\n            } else if (c == Void.TYPE) {\n                return VOID_TYPE;\n            } else if (c == Boolean.TYPE) {\n                return BOOLEAN_TYPE;\n            } else if (c == Byte.TYPE) {\n                return BYTE_TYPE;\n            } else if (c == Character.TYPE) {\n                return CHAR_TYPE;\n            } else if (c == Short.TYPE) {\n                return SHORT_TYPE;\n            } else if (c == Double.TYPE) {\n                return DOUBLE_TYPE;\n            } else if (c == Float.TYPE) {\n                return FLOAT_TYPE;\n            } else /* if (c == Long.TYPE) */\n            {\n                return LONG_TYPE;\n            }\n        } else {\n            return getType(getDescriptor(c));\n        }\n    }\n\n    /**\n     * Returns the Java types corresponding to the argument types of the given\n     * method descriptor.\n     *\n     * @param methodDescriptor a method descriptor.\n     * @return the Java types corresponding to the argument types of the given\n     *         method descriptor.\n     */\n    public static Type[] getArgumentTypes(final String methodDescriptor) {\n        char[] buf = methodDescriptor.toCharArray();\n        int off = 1;\n        int size = 0;\n        while (true) {\n            char car = buf[off++];\n            if (car == ')') {\n                break;\n            } else if (car == 'L') {\n                while (buf[off++] != ';') {\n                }\n                ++size;\n            } else if (car != '[') {\n                ++size;\n            }\n        }\n        Type[] args = new Type[size];\n        off = 1;\n        size = 0;\n        while (buf[off] != ')') {\n            args[size] = getType(buf, off);\n            off += args[size].len + (args[size].sort == OBJECT ? 2 : 0);\n            size += 1;\n        }\n        return args;\n    }\n\n    /**\n     * Returns the Java types corresponding to the argument types of the given\n     * method.\n     *\n     * @param method a method.\n     * @return the Java types corresponding to the argument types of the given\n     *         method.\n     */\n    public static Type[] getArgumentTypes(final Method method) {\n        Class[] classes = method.getParameterTypes();\n        Type[] types = new Type[classes.length];\n        for (int i = classes.length - 1; i >= 0; --i) {\n            types[i] = getType(classes[i]);\n        }\n        return types;\n    }\n\n    /**\n     * Returns the Java type corresponding to the return type of the given\n     * method descriptor.\n     *\n     * @param methodDescriptor a method descriptor.\n     * @return the Java type corresponding to the return type of the given\n     *         method descriptor.\n     */\n    public static Type getReturnType(final String methodDescriptor) {\n        char[] buf = methodDescriptor.toCharArray();\n        return getType(buf, methodDescriptor.indexOf(')') + 1);\n    }\n\n    /**\n     * Returns the Java type corresponding to the return type of the given\n     * method.\n     *\n     * @param method a method.\n     * @return the Java type corresponding to the return type of the given\n     *         method.\n     */\n    public static Type getReturnType(final Method method) {\n        return getType(method.getReturnType());\n    }\n\n    /**\n     * Computes the size of the arguments and of the return value of a method.\n     *\n     * @param desc the descriptor of a method.\n     * @return the size of the arguments of the method (plus one for the\n     *         implicit this argument), argSize, and the size of its return\n     *         value, retSize, packed into a single int i =\n     *         <tt>(argSize << 2) | retSize</tt> (argSize is therefore equal\n     *         to <tt>i >> 2</tt>, and retSize to <tt>i & 0x03</tt>).\n     */\n    public static int getArgumentsAndReturnSizes(final String desc) {\n        int n = 1;\n        int c = 1;\n        while (true) {\n            char car = desc.charAt(c++);\n            if (car == ')') {\n                car = desc.charAt(c);\n                return n << 2 | (car == 'V' ? 0 : (car == 'D' || car == 'J' ? 2 : 1));\n            } else if (car == 'L') {\n                while (desc.charAt(c++) != ';') {\n                }\n                n += 1;\n            } else if (car == '[') {\n                while ((car = desc.charAt(c)) == '[') {\n                    ++c;\n                }\n                if (car == 'D' || car == 'J') {\n                    n -= 1;\n                }\n            } else if (car == 'D' || car == 'J') {\n                n += 2;\n            } else {\n                n += 1;\n            }\n        }\n    }\n\n    /**\n     * Returns the Java type corresponding to the given type descriptor.\n     *\n     * @param buf a buffer containing a type descriptor.\n     * @param off the offset of this descriptor in the previous buffer.\n     * @return the Java type corresponding to the given type descriptor.\n     */\n    private static Type getType(final char[] buf, final int off) {\n        int len;\n        switch(buf[off]) {\n            case 'V':\n                return VOID_TYPE;\n            case 'Z':\n                return BOOLEAN_TYPE;\n            case 'C':\n                return CHAR_TYPE;\n            case 'B':\n                return BYTE_TYPE;\n            case 'S':\n                return SHORT_TYPE;\n            case 'I':\n                return INT_TYPE;\n            case 'F':\n                return FLOAT_TYPE;\n            case 'J':\n                return LONG_TYPE;\n            case 'D':\n                return DOUBLE_TYPE;\n            case '[':\n                len = 1;\n                while (buf[off + len] == '[') {\n                    ++len;\n                }\n                if (buf[off + len] == 'L') {\n                    ++len;\n                    while (buf[off + len] != ';') {\n                        ++len;\n                    }\n                }\n                return new Type(ARRAY, buf, off, len + 1);\n            // case 'L':\n            default:\n                len = 1;\n                while (buf[off + len] != ';') {\n                    ++len;\n                }\n                return new Type(OBJECT, buf, off + 1, len - 1);\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Accessors\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the sort of this Java type.\n     *\n     * @return {@link #VOID VOID}, {@link #BOOLEAN BOOLEAN},\n     *         {@link #CHAR CHAR}, {@link #BYTE BYTE}, {@link #SHORT SHORT},\n     *         {@link #INT INT}, {@link #FLOAT FLOAT}, {@link #LONG LONG},\n     *         {@link #DOUBLE DOUBLE}, {@link #ARRAY ARRAY} or\n     *         {@link #OBJECT OBJECT}.\n     */\n    public int getSort() {\n        return sort;\n    }\n\n    /**\n     * Returns the number of dimensions of this array type. This method should\n     * only be used for an array type.\n     *\n     * @return the number of dimensions of this array type.\n     */\n    public int getDimensions() {\n        int i = 1;\n        while (buf[off + i] == '[') {\n            ++i;\n        }\n        return i;\n    }\n\n    /**\n     * Returns the type of the elements of this array type. This method should\n     * only be used for an array type.\n     *\n     * @return Returns the type of the elements of this array type.\n     */\n    public Type getElementType() {\n        return getType(buf, off + getDimensions());\n    }\n\n    /**\n     * Returns the name of the class corresponding to this type.\n     *\n     * @return the fully qualified name of the class corresponding to this type.\n     */\n    public String getClassName() {\n        switch(sort) {\n            case VOID:\n                return \"void\";\n            case BOOLEAN:\n                return \"boolean\";\n            case CHAR:\n                return \"char\";\n            case BYTE:\n                return \"byte\";\n            case SHORT:\n                return \"short\";\n            case INT:\n                return \"int\";\n            case FLOAT:\n                return \"float\";\n            case LONG:\n                return \"long\";\n            case DOUBLE:\n                return \"double\";\n            case ARRAY:\n                StringBuffer b = new StringBuffer(getElementType().getClassName());\n                for (int i = getDimensions(); i > 0; --i) {\n                    b.append(\"[]\");\n                }\n                return b.toString();\n            // case OBJECT:\n            default:\n                return new String(buf, off, len).replace('/', '.');\n        }\n    }\n\n    /**\n     * Returns the internal name of the class corresponding to this object or\n     * array type. The internal name of a class is its fully qualified name (as\n     * returned by Class.getName(), where '.' are replaced by '/'. This method\n     * should only be used for an object or array type.\n     *\n     * @return the internal name of the class corresponding to this object type.\n     */\n    public String getInternalName() {\n        return new String(buf, off, len);\n    }\n\n    // ------------------------------------------------------------------------\n    // Conversion to type descriptors\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the descriptor corresponding to this Java type.\n     *\n     * @return the descriptor corresponding to this Java type.\n     */\n    public String getDescriptor() {\n        StringBuffer buf = new StringBuffer();\n        getDescriptor(buf);\n        return buf.toString();\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given argument and return\n     * types.\n     *\n     * @param returnType the return type of the method.\n     * @param argumentTypes the argument types of the method.\n     * @return the descriptor corresponding to the given argument and return\n     *         types.\n     */\n    public static String getMethodDescriptor(final Type returnType, final Type[] argumentTypes) {\n        StringBuffer buf = new StringBuffer();\n        buf.append('(');\n        for (int i = 0; i < argumentTypes.length; ++i) {\n            argumentTypes[i].getDescriptor(buf);\n        }\n        buf.append(')');\n        returnType.getDescriptor(buf);\n        return buf.toString();\n    }\n\n    /**\n     * Appends the descriptor corresponding to this Java type to the given\n     * string buffer.\n     *\n     * @param buf the string buffer to which the descriptor must be appended.\n     */\n    private void getDescriptor(final StringBuffer buf) {\n        if (this.buf == null) {\n            // descriptor is in byte 3 of 'off' for primitive types (buf == null)\n            buf.append((char) ((off & 0xFF000000) >>> 24));\n        } else if (sort == ARRAY) {\n            buf.append(this.buf, off, len);\n        } else {\n            // sort == OBJECT\n            buf.append('L');\n            buf.append(this.buf, off, len);\n            buf.append(';');\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Direct conversion from classes to type descriptors,\n    // without intermediate Type objects\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the internal name of the given class. The internal name of a\n     * class is its fully qualified name, as returned by Class.getName(), where\n     * '.' are replaced by '/'.\n     *\n     * @param c an object or array class.\n     * @return the internal name of the given class.\n     */\n    public static String getInternalName(final Class c) {\n        return c.getName().replace('.', '/');\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given Java type.\n     *\n     * @param c an object class, a primitive class or an array class.\n     * @return the descriptor corresponding to the given class.\n     */\n    public static String getDescriptor(final Class c) {\n        StringBuffer buf = new StringBuffer();\n        getDescriptor(buf, c);\n        return buf.toString();\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given constructor.\n     *\n     * @param c a {@link Constructor Constructor} object.\n     * @return the descriptor of the given constructor.\n     */\n    public static String getConstructorDescriptor(final Constructor c) {\n        Class[] parameters = c.getParameterTypes();\n        StringBuffer buf = new StringBuffer();\n        buf.append('(');\n        for (int i = 0; i < parameters.length; ++i) {\n            getDescriptor(buf, parameters[i]);\n        }\n        return buf.append(\")V\").toString();\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given method.\n     *\n     * @param m a {@link Method Method} object.\n     * @return the descriptor of the given method.\n     */\n    public static String getMethodDescriptor(final Method m) {\n        Class[] parameters = m.getParameterTypes();\n        StringBuffer buf = new StringBuffer();\n        buf.append('(');\n        for (int i = 0; i < parameters.length; ++i) {\n            getDescriptor(buf, parameters[i]);\n        }\n        buf.append(')');\n        getDescriptor(buf, m.getReturnType());\n        return buf.toString();\n    }\n\n    /**\n     * Appends the descriptor of the given class to the given string buffer.\n     *\n     * @param buf the string buffer to which the descriptor must be appended.\n     * @param c the class whose descriptor must be computed.\n     */\n    private static void getDescriptor(final StringBuffer buf, final Class c) {\n        Class d = c;\n        while (true) {\n            if (d.isPrimitive()) {\n                char car;\n                if (d == Integer.TYPE) {\n                    car = 'I';\n                } else if (d == Void.TYPE) {\n                    car = 'V';\n                } else if (d == Boolean.TYPE) {\n                    car = 'Z';\n                } else if (d == Byte.TYPE) {\n                    car = 'B';\n                } else if (d == Character.TYPE) {\n                    car = 'C';\n                } else if (d == Short.TYPE) {\n                    car = 'S';\n                } else if (d == Double.TYPE) {\n                    car = 'D';\n                } else if (d == Float.TYPE) {\n                    car = 'F';\n                } else /* if (d == Long.TYPE) */\n                {\n                    car = 'J';\n                }\n                buf.append(car);\n                return;\n            } else if (d.isArray()) {\n                buf.append('[');\n                d = d.getComponentType();\n            } else {\n                buf.append('L');\n                String name = d.getName();\n                int len = name.length();\n                for (int i = 0; i < len; ++i) {\n                    char car = name.charAt(i);\n                    buf.append(car == '.' ? '/' : car);\n                }\n                buf.append(';');\n                return;\n            }\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Corresponding size and opcodes\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the size of values of this type.\n     *\n     * @return the size of values of this type, i.e., 2 for <tt>long</tt> and\n     *         <tt>double</tt>, 0 for <tt>void</tt> and 1 otherwise.\n     */\n    public int getSize() {\n        // the size is in byte 0 of 'off' for primitive types (buf == null)\n        return buf == null ? (off & 0xFF) : 1;\n    }\n\n    /**\n     * Returns a JVM instruction opcode adapted to this Java type.\n     *\n     * @param opcode a JVM instruction opcode. This opcode must be one of ILOAD,\n     *        ISTORE, IALOAD, IASTORE, IADD, ISUB, IMUL, IDIV, IREM, INEG, ISHL,\n     *        ISHR, IUSHR, IAND, IOR, IXOR and IRETURN.\n     * @return an opcode that is similar to the given opcode, but adapted to\n     *         this Java type. For example, if this type is <tt>float</tt> and\n     *         <tt>opcode</tt> is IRETURN, this method returns FRETURN.\n     */\n    public int getOpcode(final int opcode) {\n        if (opcode == Opcodes.IALOAD || opcode == Opcodes.IASTORE) {\n            // the offset for IALOAD or IASTORE is in byte 1 of 'off' for\n            // primitive types (buf == null)\n            return opcode + (buf == null ? (off & 0xFF00) >> 8 : 4);\n        } else {\n            // the offset for other instructions is in byte 2 of 'off' for\n            // primitive types (buf == null)\n            return opcode + (buf == null ? (off & 0xFF0000) >> 16 : 4);\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Equals, hashCode and toString\n    // ------------------------------------------------------------------------\n    /**\n     * Tests if the given object is equal to this type.\n     *\n     * @param o the object to be compared to this type.\n     * @return <tt>true</tt> if the given object is equal to this type.\n     */\n    public boolean equals(final Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (!(o instanceof Type)) {\n            return false;\n        }\n        Type t = (Type) o;\n        if (sort != t.sort) {\n            return false;\n        }\n        if (sort == OBJECT || sort == ARRAY) {\n            if (len != t.len) {\n                return false;\n            }\n            for (int i = off, j = t.off, end = i + len; i < end; i++, j++) {\n                if (buf[i] != t.buf[j]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code value for this type.\n     *\n     * @return a hash code value for this type.\n     */\n    public int hashCode() {\n        int hc = 13 * sort;\n        if (sort == OBJECT || sort == ARRAY) {\n            for (int i = off, end = i + len; i < end; i++) {\n                hc = 17 * (hc + buf[i]);\n            }\n        }\n        return hc;\n    }\n\n    /**\n     * Returns a string representation of this type.\n     *\n     * @return the descriptor of this type.\n     */\n    public String toString() {\n        return getDescriptor();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/TypeTest8.java",
		"test_prompt": "// TypeTest8.java\npackage org.objectweb.asm.jip;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Type}.\n* It contains ten unit test cases for the {@link Type#getMethodDescriptor(Type, Type[])} method.\n*/\nclass TypeTest8 {"
	},
	{
		"original_code": "// Type.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\n\n/**\n * A Java type. This class can be used to make it easier to manipulate type and\n * method descriptors.\n *\n * @author Eric Bruneton\n * @author Chris Nokleberg\n */\npublic class Type {\n\n    /**\n     * The sort of the <tt>void</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int VOID = 0;\n\n    /**\n     * The sort of the <tt>boolean</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int BOOLEAN = 1;\n\n    /**\n     * The sort of the <tt>char</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int CHAR = 2;\n\n    /**\n     * The sort of the <tt>byte</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int BYTE = 3;\n\n    /**\n     * The sort of the <tt>short</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int SHORT = 4;\n\n    /**\n     * The sort of the <tt>int</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int INT = 5;\n\n    /**\n     * The sort of the <tt>float</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int FLOAT = 6;\n\n    /**\n     * The sort of the <tt>long</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int LONG = 7;\n\n    /**\n     * The sort of the <tt>double</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int DOUBLE = 8;\n\n    /**\n     * The sort of array reference types. See {@link #getSort getSort}.\n     */\n    public static final int ARRAY = 9;\n\n    /**\n     * The sort of object reference type. See {@link #getSort getSort}.\n     */\n    public static final int OBJECT = 10;\n\n    /**\n     * The <tt>void</tt> type.\n     */\n    public static final Type VOID_TYPE = new Type(VOID, null, ('V' << 24) | (5 << 16) | (0 << 8) | 0, 1);\n\n    /**\n     * The <tt>boolean</tt> type.\n     */\n    public static final Type BOOLEAN_TYPE = new Type(BOOLEAN, null, ('Z' << 24) | (0 << 16) | (5 << 8) | 1, 1);\n\n    /**\n     * The <tt>char</tt> type.\n     */\n    public static final Type CHAR_TYPE = new Type(CHAR, null, ('C' << 24) | (0 << 16) | (6 << 8) | 1, 1);\n\n    /**\n     * The <tt>byte</tt> type.\n     */\n    public static final Type BYTE_TYPE = new Type(BYTE, null, ('B' << 24) | (0 << 16) | (5 << 8) | 1, 1);\n\n    /**\n     * The <tt>short</tt> type.\n     */\n    public static final Type SHORT_TYPE = new Type(SHORT, null, ('S' << 24) | (0 << 16) | (7 << 8) | 1, 1);\n\n    /**\n     * The <tt>int</tt> type.\n     */\n    public static final Type INT_TYPE = new Type(INT, null, ('I' << 24) | (0 << 16) | (0 << 8) | 1, 1);\n\n    /**\n     * The <tt>float</tt> type.\n     */\n    public static final Type FLOAT_TYPE = new Type(FLOAT, null, ('F' << 24) | (2 << 16) | (2 << 8) | 1, 1);\n\n    /**\n     * The <tt>long</tt> type.\n     */\n    public static final Type LONG_TYPE = new Type(LONG, null, ('J' << 24) | (1 << 16) | (1 << 8) | 2, 1);\n\n    /**\n     * The <tt>double</tt> type.\n     */\n    public static final Type DOUBLE_TYPE = new Type(DOUBLE, null, ('D' << 24) | (3 << 16) | (3 << 8) | 2, 1);\n\n    // ------------------------------------------------------------------------\n    // Fields\n    // ------------------------------------------------------------------------\n    /**\n     * The sort of this Java type.\n     */\n    private final int sort;\n\n    /**\n     * A buffer containing the internal name of this Java type. This field is\n     * only used for reference types.\n     */\n    private final char[] buf;\n\n    /**\n     * The offset of the internal name of this Java type in {@link #buf buf} or,\n     * for primitive types, the size, descriptor and getOpcode offsets for this\n     * type (byte 0 contains the size, byte 1 the descriptor, byte 2 the offset\n     * for IALOAD or IASTORE, byte 3 the offset for all other instructions).\n     */\n    private final int off;\n\n    /**\n     * The length of the internal name of this Java type.\n     */\n    private final int len;\n\n    // ------------------------------------------------------------------------\n    // Constructors\n    // ------------------------------------------------------------------------\n    /**\n     * Constructs a reference type.\n     *\n     * @param sort the sort of the reference type to be constructed.\n     * @param buf a buffer containing the descriptor of the previous type.\n     * @param off the offset of this descriptor in the previous buffer.\n     * @param len the length of this descriptor.\n     */\n    private Type(final int sort, final char[] buf, final int off, final int len) {\n        this.sort = sort;\n        this.buf = buf;\n        this.off = off;\n        this.len = len;\n    }\n\n    /**\n     * Returns the Java type corresponding to the given type descriptor.\n     *\n     * @param typeDescriptor a type descriptor.\n     * @return the Java type corresponding to the given type descriptor.\n     */\n    public static Type getType(final String typeDescriptor) {\n        return getType(typeDescriptor.toCharArray(), 0);\n    }\n\n    /**\n     * Returns the Java type corresponding to the given internal name.\n     *\n     * @param internalName an internal name.\n     * @return the Java type corresponding to the given internal name.\n     */\n    public static Type getObjectType(final String internalName) {\n        char[] buf = internalName.toCharArray();\n        return new Type(buf[0] == '[' ? ARRAY : OBJECT, buf, 0, buf.length);\n    }\n\n    /**\n     * Returns the Java type corresponding to the given class.\n     *\n     * @param c a class.\n     * @return the Java type corresponding to the given class.\n     */\n    public static Type getType(final Class c) {\n        if (c.isPrimitive()) {\n            if (c == Integer.TYPE) {\n                return INT_TYPE;\n            } else if (c == Void.TYPE) {\n                return VOID_TYPE;\n            } else if (c == Boolean.TYPE) {\n                return BOOLEAN_TYPE;\n            } else if (c == Byte.TYPE) {\n                return BYTE_TYPE;\n            } else if (c == Character.TYPE) {\n                return CHAR_TYPE;\n            } else if (c == Short.TYPE) {\n                return SHORT_TYPE;\n            } else if (c == Double.TYPE) {\n                return DOUBLE_TYPE;\n            } else if (c == Float.TYPE) {\n                return FLOAT_TYPE;\n            } else /* if (c == Long.TYPE) */\n            {\n                return LONG_TYPE;\n            }\n        } else {\n            return getType(getDescriptor(c));\n        }\n    }\n\n    /**\n     * Returns the Java types corresponding to the argument types of the given\n     * method descriptor.\n     *\n     * @param methodDescriptor a method descriptor.\n     * @return the Java types corresponding to the argument types of the given\n     *         method descriptor.\n     */\n    public static Type[] getArgumentTypes(final String methodDescriptor) {\n        char[] buf = methodDescriptor.toCharArray();\n        int off = 1;\n        int size = 0;\n        while (true) {\n            char car = buf[off++];\n            if (car == ')') {\n                break;\n            } else if (car == 'L') {\n                while (buf[off++] != ';') {\n                }\n                ++size;\n            } else if (car != '[') {\n                ++size;\n            }\n        }\n        Type[] args = new Type[size];\n        off = 1;\n        size = 0;\n        while (buf[off] != ')') {\n            args[size] = getType(buf, off);\n            off += args[size].len + (args[size].sort == OBJECT ? 2 : 0);\n            size += 1;\n        }\n        return args;\n    }\n\n    /**\n     * Returns the Java types corresponding to the argument types of the given\n     * method.\n     *\n     * @param method a method.\n     * @return the Java types corresponding to the argument types of the given\n     *         method.\n     */\n    public static Type[] getArgumentTypes(final Method method) {\n        Class[] classes = method.getParameterTypes();\n        Type[] types = new Type[classes.length];\n        for (int i = classes.length - 1; i >= 0; --i) {\n            types[i] = getType(classes[i]);\n        }\n        return types;\n    }\n\n    /**\n     * Returns the Java type corresponding to the return type of the given\n     * method descriptor.\n     *\n     * @param methodDescriptor a method descriptor.\n     * @return the Java type corresponding to the return type of the given\n     *         method descriptor.\n     */\n    public static Type getReturnType(final String methodDescriptor) {\n        char[] buf = methodDescriptor.toCharArray();\n        return getType(buf, methodDescriptor.indexOf(')') + 1);\n    }\n\n    /**\n     * Returns the Java type corresponding to the return type of the given\n     * method.\n     *\n     * @param method a method.\n     * @return the Java type corresponding to the return type of the given\n     *         method.\n     */\n    public static Type getReturnType(final Method method) {\n        return getType(method.getReturnType());\n    }\n\n    /**\n     * Computes the size of the arguments and of the return value of a method.\n     *\n     * @param desc the descriptor of a method.\n     * @return the size of the arguments of the method (plus one for the\n     *         implicit this argument), argSize, and the size of its return\n     *         value, retSize, packed into a single int i =\n     *         <tt>(argSize << 2) | retSize</tt> (argSize is therefore equal\n     *         to <tt>i >> 2</tt>, and retSize to <tt>i & 0x03</tt>).\n     */\n    public static int getArgumentsAndReturnSizes(final String desc) {\n        int n = 1;\n        int c = 1;\n        while (true) {\n            char car = desc.charAt(c++);\n            if (car == ')') {\n                car = desc.charAt(c);\n                return n << 2 | (car == 'V' ? 0 : (car == 'D' || car == 'J' ? 2 : 1));\n            } else if (car == 'L') {\n                while (desc.charAt(c++) != ';') {\n                }\n                n += 1;\n            } else if (car == '[') {\n                while ((car = desc.charAt(c)) == '[') {\n                    ++c;\n                }\n                if (car == 'D' || car == 'J') {\n                    n -= 1;\n                }\n            } else if (car == 'D' || car == 'J') {\n                n += 2;\n            } else {\n                n += 1;\n            }\n        }\n    }\n\n    /**\n     * Returns the Java type corresponding to the given type descriptor.\n     *\n     * @param buf a buffer containing a type descriptor.\n     * @param off the offset of this descriptor in the previous buffer.\n     * @return the Java type corresponding to the given type descriptor.\n     */\n    private static Type getType(final char[] buf, final int off) {\n        int len;\n        switch(buf[off]) {\n            case 'V':\n                return VOID_TYPE;\n            case 'Z':\n                return BOOLEAN_TYPE;\n            case 'C':\n                return CHAR_TYPE;\n            case 'B':\n                return BYTE_TYPE;\n            case 'S':\n                return SHORT_TYPE;\n            case 'I':\n                return INT_TYPE;\n            case 'F':\n                return FLOAT_TYPE;\n            case 'J':\n                return LONG_TYPE;\n            case 'D':\n                return DOUBLE_TYPE;\n            case '[':\n                len = 1;\n                while (buf[off + len] == '[') {\n                    ++len;\n                }\n                if (buf[off + len] == 'L') {\n                    ++len;\n                    while (buf[off + len] != ';') {\n                        ++len;\n                    }\n                }\n                return new Type(ARRAY, buf, off, len + 1);\n            // case 'L':\n            default:\n                len = 1;\n                while (buf[off + len] != ';') {\n                    ++len;\n                }\n                return new Type(OBJECT, buf, off + 1, len - 1);\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Accessors\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the sort of this Java type.\n     *\n     * @return {@link #VOID VOID}, {@link #BOOLEAN BOOLEAN},\n     *         {@link #CHAR CHAR}, {@link #BYTE BYTE}, {@link #SHORT SHORT},\n     *         {@link #INT INT}, {@link #FLOAT FLOAT}, {@link #LONG LONG},\n     *         {@link #DOUBLE DOUBLE}, {@link #ARRAY ARRAY} or\n     *         {@link #OBJECT OBJECT}.\n     */\n    public int getSort() {\n        return sort;\n    }\n\n    /**\n     * Returns the number of dimensions of this array type. This method should\n     * only be used for an array type.\n     *\n     * @return the number of dimensions of this array type.\n     */\n    public int getDimensions() {\n        int i = 1;\n        while (buf[off + i] == '[') {\n            ++i;\n        }\n        return i;\n    }\n\n    /**\n     * Returns the type of the elements of this array type. This method should\n     * only be used for an array type.\n     *\n     * @return Returns the type of the elements of this array type.\n     */\n    public Type getElementType() {\n        return getType(buf, off + getDimensions());\n    }\n\n    /**\n     * Returns the name of the class corresponding to this type.\n     *\n     * @return the fully qualified name of the class corresponding to this type.\n     */\n    public String getClassName() {\n        switch(sort) {\n            case VOID:\n                return \"void\";\n            case BOOLEAN:\n                return \"boolean\";\n            case CHAR:\n                return \"char\";\n            case BYTE:\n                return \"byte\";\n            case SHORT:\n                return \"short\";\n            case INT:\n                return \"int\";\n            case FLOAT:\n                return \"float\";\n            case LONG:\n                return \"long\";\n            case DOUBLE:\n                return \"double\";\n            case ARRAY:\n                StringBuffer b = new StringBuffer(getElementType().getClassName());\n                for (int i = getDimensions(); i > 0; --i) {\n                    b.append(\"[]\");\n                }\n                return b.toString();\n            // case OBJECT:\n            default:\n                return new String(buf, off, len).replace('/', '.');\n        }\n    }\n\n    /**\n     * Returns the internal name of the class corresponding to this object or\n     * array type. The internal name of a class is its fully qualified name (as\n     * returned by Class.getName(), where '.' are replaced by '/'. This method\n     * should only be used for an object or array type.\n     *\n     * @return the internal name of the class corresponding to this object type.\n     */\n    public String getInternalName() {\n        return new String(buf, off, len);\n    }\n\n    // ------------------------------------------------------------------------\n    // Conversion to type descriptors\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the descriptor corresponding to this Java type.\n     *\n     * @return the descriptor corresponding to this Java type.\n     */\n    public String getDescriptor() {\n        StringBuffer buf = new StringBuffer();\n        getDescriptor(buf);\n        return buf.toString();\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given argument and return\n     * types.\n     *\n     * @param returnType the return type of the method.\n     * @param argumentTypes the argument types of the method.\n     * @return the descriptor corresponding to the given argument and return\n     *         types.\n     */\n    public static String getMethodDescriptor(final Type returnType, final Type[] argumentTypes) {\n        StringBuffer buf = new StringBuffer();\n        buf.append('(');\n        for (int i = 0; i < argumentTypes.length; ++i) {\n            argumentTypes[i].getDescriptor(buf);\n        }\n        buf.append(')');\n        returnType.getDescriptor(buf);\n        return buf.toString();\n    }\n\n    /**\n     * Appends the descriptor corresponding to this Java type to the given\n     * string buffer.\n     *\n     * @param buf the string buffer to which the descriptor must be appended.\n     */\n    private void getDescriptor(final StringBuffer buf) {\n        if (this.buf == null) {\n            // descriptor is in byte 3 of 'off' for primitive types (buf == null)\n            buf.append((char) ((off & 0xFF000000) >>> 24));\n        } else if (sort == ARRAY) {\n            buf.append(this.buf, off, len);\n        } else {\n            // sort == OBJECT\n            buf.append('L');\n            buf.append(this.buf, off, len);\n            buf.append(';');\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Direct conversion from classes to type descriptors,\n    // without intermediate Type objects\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the internal name of the given class. The internal name of a\n     * class is its fully qualified name, as returned by Class.getName(), where\n     * '.' are replaced by '/'.\n     *\n     * @param c an object or array class.\n     * @return the internal name of the given class.\n     */\n    public static String getInternalName(final Class c) {\n        return c.getName().replace('.', '/');\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given Java type.\n     *\n     * @param c an object class, a primitive class or an array class.\n     * @return the descriptor corresponding to the given class.\n     */\n    public static String getDescriptor(final Class c) {\n        StringBuffer buf = new StringBuffer();\n        getDescriptor(buf, c);\n        return buf.toString();\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given constructor.\n     *\n     * @param c a {@link Constructor Constructor} object.\n     * @return the descriptor of the given constructor.\n     */\n    public static String getConstructorDescriptor(final Constructor c) {\n        Class[] parameters = c.getParameterTypes();\n        StringBuffer buf = new StringBuffer();\n        buf.append('(');\n        for (int i = 0; i < parameters.length; ++i) {\n            getDescriptor(buf, parameters[i]);\n        }\n        return buf.append(\")V\").toString();\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given method.\n     *\n     * @param m a {@link Method Method} object.\n     * @return the descriptor of the given method.\n     */\n    public static String getMethodDescriptor(final Method m) {\n        Class[] parameters = m.getParameterTypes();\n        StringBuffer buf = new StringBuffer();\n        buf.append('(');\n        for (int i = 0; i < parameters.length; ++i) {\n            getDescriptor(buf, parameters[i]);\n        }\n        buf.append(')');\n        getDescriptor(buf, m.getReturnType());\n        return buf.toString();\n    }\n\n    /**\n     * Appends the descriptor of the given class to the given string buffer.\n     *\n     * @param buf the string buffer to which the descriptor must be appended.\n     * @param c the class whose descriptor must be computed.\n     */\n    private static void getDescriptor(final StringBuffer buf, final Class c) {\n        Class d = c;\n        while (true) {\n            if (d.isPrimitive()) {\n                char car;\n                if (d == Integer.TYPE) {\n                    car = 'I';\n                } else if (d == Void.TYPE) {\n                    car = 'V';\n                } else if (d == Boolean.TYPE) {\n                    car = 'Z';\n                } else if (d == Byte.TYPE) {\n                    car = 'B';\n                } else if (d == Character.TYPE) {\n                    car = 'C';\n                } else if (d == Short.TYPE) {\n                    car = 'S';\n                } else if (d == Double.TYPE) {\n                    car = 'D';\n                } else if (d == Float.TYPE) {\n                    car = 'F';\n                } else /* if (d == Long.TYPE) */\n                {\n                    car = 'J';\n                }\n                buf.append(car);\n                return;\n            } else if (d.isArray()) {\n                buf.append('[');\n                d = d.getComponentType();\n            } else {\n                buf.append('L');\n                String name = d.getName();\n                int len = name.length();\n                for (int i = 0; i < len; ++i) {\n                    char car = name.charAt(i);\n                    buf.append(car == '.' ? '/' : car);\n                }\n                buf.append(';');\n                return;\n            }\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Corresponding size and opcodes\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the size of values of this type.\n     *\n     * @return the size of values of this type, i.e., 2 for <tt>long</tt> and\n     *         <tt>double</tt>, 0 for <tt>void</tt> and 1 otherwise.\n     */\n    public int getSize() {\n        // the size is in byte 0 of 'off' for primitive types (buf == null)\n        return buf == null ? (off & 0xFF) : 1;\n    }\n\n    /**\n     * Returns a JVM instruction opcode adapted to this Java type.\n     *\n     * @param opcode a JVM instruction opcode. This opcode must be one of ILOAD,\n     *        ISTORE, IALOAD, IASTORE, IADD, ISUB, IMUL, IDIV, IREM, INEG, ISHL,\n     *        ISHR, IUSHR, IAND, IOR, IXOR and IRETURN.\n     * @return an opcode that is similar to the given opcode, but adapted to\n     *         this Java type. For example, if this type is <tt>float</tt> and\n     *         <tt>opcode</tt> is IRETURN, this method returns FRETURN.\n     */\n    public int getOpcode(final int opcode) {\n        if (opcode == Opcodes.IALOAD || opcode == Opcodes.IASTORE) {\n            // the offset for IALOAD or IASTORE is in byte 1 of 'off' for\n            // primitive types (buf == null)\n            return opcode + (buf == null ? (off & 0xFF00) >> 8 : 4);\n        } else {\n            // the offset for other instructions is in byte 2 of 'off' for\n            // primitive types (buf == null)\n            return opcode + (buf == null ? (off & 0xFF0000) >> 16 : 4);\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Equals, hashCode and toString\n    // ------------------------------------------------------------------------\n    /**\n     * Tests if the given object is equal to this type.\n     *\n     * @param o the object to be compared to this type.\n     * @return <tt>true</tt> if the given object is equal to this type.\n     */\n    public boolean equals(final Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (!(o instanceof Type)) {\n            return false;\n        }\n        Type t = (Type) o;\n        if (sort != t.sort) {\n            return false;\n        }\n        if (sort == OBJECT || sort == ARRAY) {\n            if (len != t.len) {\n                return false;\n            }\n            for (int i = off, j = t.off, end = i + len; i < end; i++, j++) {\n                if (buf[i] != t.buf[j]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code value for this type.\n     *\n     * @return a hash code value for this type.\n     */\n    public int hashCode() {\n        int hc = 13 * sort;\n        if (sort == OBJECT || sort == ARRAY) {\n            for (int i = off, end = i + len; i < end; i++) {\n                hc = 17 * (hc + buf[i]);\n            }\n        }\n        return hc;\n    }\n\n    /**\n     * Returns a string representation of this type.\n     *\n     * @return the descriptor of this type.\n     */\n    public String toString() {\n        return getDescriptor();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/TypeTest9.java",
		"test_prompt": "// TypeTest9.java\npackage org.objectweb.asm.jip;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Type}.\n* It contains ten unit test cases for the {@link Type#getInternalName(Class)} method.\n*/\nclass TypeTest9 {"
	},
	{
		"original_code": "// Type.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\n\n/**\n * A Java type. This class can be used to make it easier to manipulate type and\n * method descriptors.\n *\n * @author Eric Bruneton\n * @author Chris Nokleberg\n */\npublic class Type {\n\n    /**\n     * The sort of the <tt>void</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int VOID = 0;\n\n    /**\n     * The sort of the <tt>boolean</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int BOOLEAN = 1;\n\n    /**\n     * The sort of the <tt>char</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int CHAR = 2;\n\n    /**\n     * The sort of the <tt>byte</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int BYTE = 3;\n\n    /**\n     * The sort of the <tt>short</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int SHORT = 4;\n\n    /**\n     * The sort of the <tt>int</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int INT = 5;\n\n    /**\n     * The sort of the <tt>float</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int FLOAT = 6;\n\n    /**\n     * The sort of the <tt>long</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int LONG = 7;\n\n    /**\n     * The sort of the <tt>double</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int DOUBLE = 8;\n\n    /**\n     * The sort of array reference types. See {@link #getSort getSort}.\n     */\n    public static final int ARRAY = 9;\n\n    /**\n     * The sort of object reference type. See {@link #getSort getSort}.\n     */\n    public static final int OBJECT = 10;\n\n    /**\n     * The <tt>void</tt> type.\n     */\n    public static final Type VOID_TYPE = new Type(VOID, null, ('V' << 24) | (5 << 16) | (0 << 8) | 0, 1);\n\n    /**\n     * The <tt>boolean</tt> type.\n     */\n    public static final Type BOOLEAN_TYPE = new Type(BOOLEAN, null, ('Z' << 24) | (0 << 16) | (5 << 8) | 1, 1);\n\n    /**\n     * The <tt>char</tt> type.\n     */\n    public static final Type CHAR_TYPE = new Type(CHAR, null, ('C' << 24) | (0 << 16) | (6 << 8) | 1, 1);\n\n    /**\n     * The <tt>byte</tt> type.\n     */\n    public static final Type BYTE_TYPE = new Type(BYTE, null, ('B' << 24) | (0 << 16) | (5 << 8) | 1, 1);\n\n    /**\n     * The <tt>short</tt> type.\n     */\n    public static final Type SHORT_TYPE = new Type(SHORT, null, ('S' << 24) | (0 << 16) | (7 << 8) | 1, 1);\n\n    /**\n     * The <tt>int</tt> type.\n     */\n    public static final Type INT_TYPE = new Type(INT, null, ('I' << 24) | (0 << 16) | (0 << 8) | 1, 1);\n\n    /**\n     * The <tt>float</tt> type.\n     */\n    public static final Type FLOAT_TYPE = new Type(FLOAT, null, ('F' << 24) | (2 << 16) | (2 << 8) | 1, 1);\n\n    /**\n     * The <tt>long</tt> type.\n     */\n    public static final Type LONG_TYPE = new Type(LONG, null, ('J' << 24) | (1 << 16) | (1 << 8) | 2, 1);\n\n    /**\n     * The <tt>double</tt> type.\n     */\n    public static final Type DOUBLE_TYPE = new Type(DOUBLE, null, ('D' << 24) | (3 << 16) | (3 << 8) | 2, 1);\n\n    // ------------------------------------------------------------------------\n    // Fields\n    // ------------------------------------------------------------------------\n    /**\n     * The sort of this Java type.\n     */\n    private final int sort;\n\n    /**\n     * A buffer containing the internal name of this Java type. This field is\n     * only used for reference types.\n     */\n    private final char[] buf;\n\n    /**\n     * The offset of the internal name of this Java type in {@link #buf buf} or,\n     * for primitive types, the size, descriptor and getOpcode offsets for this\n     * type (byte 0 contains the size, byte 1 the descriptor, byte 2 the offset\n     * for IALOAD or IASTORE, byte 3 the offset for all other instructions).\n     */\n    private final int off;\n\n    /**\n     * The length of the internal name of this Java type.\n     */\n    private final int len;\n\n    // ------------------------------------------------------------------------\n    // Constructors\n    // ------------------------------------------------------------------------\n    /**\n     * Constructs a reference type.\n     *\n     * @param sort the sort of the reference type to be constructed.\n     * @param buf a buffer containing the descriptor of the previous type.\n     * @param off the offset of this descriptor in the previous buffer.\n     * @param len the length of this descriptor.\n     */\n    private Type(final int sort, final char[] buf, final int off, final int len) {\n        this.sort = sort;\n        this.buf = buf;\n        this.off = off;\n        this.len = len;\n    }\n\n    /**\n     * Returns the Java type corresponding to the given type descriptor.\n     *\n     * @param typeDescriptor a type descriptor.\n     * @return the Java type corresponding to the given type descriptor.\n     */\n    public static Type getType(final String typeDescriptor) {\n        return getType(typeDescriptor.toCharArray(), 0);\n    }\n\n    /**\n     * Returns the Java type corresponding to the given internal name.\n     *\n     * @param internalName an internal name.\n     * @return the Java type corresponding to the given internal name.\n     */\n    public static Type getObjectType(final String internalName) {\n        char[] buf = internalName.toCharArray();\n        return new Type(buf[0] == '[' ? ARRAY : OBJECT, buf, 0, buf.length);\n    }\n\n    /**\n     * Returns the Java type corresponding to the given class.\n     *\n     * @param c a class.\n     * @return the Java type corresponding to the given class.\n     */\n    public static Type getType(final Class c) {\n        if (c.isPrimitive()) {\n            if (c == Integer.TYPE) {\n                return INT_TYPE;\n            } else if (c == Void.TYPE) {\n                return VOID_TYPE;\n            } else if (c == Boolean.TYPE) {\n                return BOOLEAN_TYPE;\n            } else if (c == Byte.TYPE) {\n                return BYTE_TYPE;\n            } else if (c == Character.TYPE) {\n                return CHAR_TYPE;\n            } else if (c == Short.TYPE) {\n                return SHORT_TYPE;\n            } else if (c == Double.TYPE) {\n                return DOUBLE_TYPE;\n            } else if (c == Float.TYPE) {\n                return FLOAT_TYPE;\n            } else /* if (c == Long.TYPE) */\n            {\n                return LONG_TYPE;\n            }\n        } else {\n            return getType(getDescriptor(c));\n        }\n    }\n\n    /**\n     * Returns the Java types corresponding to the argument types of the given\n     * method descriptor.\n     *\n     * @param methodDescriptor a method descriptor.\n     * @return the Java types corresponding to the argument types of the given\n     *         method descriptor.\n     */\n    public static Type[] getArgumentTypes(final String methodDescriptor) {\n        char[] buf = methodDescriptor.toCharArray();\n        int off = 1;\n        int size = 0;\n        while (true) {\n            char car = buf[off++];\n            if (car == ')') {\n                break;\n            } else if (car == 'L') {\n                while (buf[off++] != ';') {\n                }\n                ++size;\n            } else if (car != '[') {\n                ++size;\n            }\n        }\n        Type[] args = new Type[size];\n        off = 1;\n        size = 0;\n        while (buf[off] != ')') {\n            args[size] = getType(buf, off);\n            off += args[size].len + (args[size].sort == OBJECT ? 2 : 0);\n            size += 1;\n        }\n        return args;\n    }\n\n    /**\n     * Returns the Java types corresponding to the argument types of the given\n     * method.\n     *\n     * @param method a method.\n     * @return the Java types corresponding to the argument types of the given\n     *         method.\n     */\n    public static Type[] getArgumentTypes(final Method method) {\n        Class[] classes = method.getParameterTypes();\n        Type[] types = new Type[classes.length];\n        for (int i = classes.length - 1; i >= 0; --i) {\n            types[i] = getType(classes[i]);\n        }\n        return types;\n    }\n\n    /**\n     * Returns the Java type corresponding to the return type of the given\n     * method descriptor.\n     *\n     * @param methodDescriptor a method descriptor.\n     * @return the Java type corresponding to the return type of the given\n     *         method descriptor.\n     */\n    public static Type getReturnType(final String methodDescriptor) {\n        char[] buf = methodDescriptor.toCharArray();\n        return getType(buf, methodDescriptor.indexOf(')') + 1);\n    }\n\n    /**\n     * Returns the Java type corresponding to the return type of the given\n     * method.\n     *\n     * @param method a method.\n     * @return the Java type corresponding to the return type of the given\n     *         method.\n     */\n    public static Type getReturnType(final Method method) {\n        return getType(method.getReturnType());\n    }\n\n    /**\n     * Computes the size of the arguments and of the return value of a method.\n     *\n     * @param desc the descriptor of a method.\n     * @return the size of the arguments of the method (plus one for the\n     *         implicit this argument), argSize, and the size of its return\n     *         value, retSize, packed into a single int i =\n     *         <tt>(argSize << 2) | retSize</tt> (argSize is therefore equal\n     *         to <tt>i >> 2</tt>, and retSize to <tt>i & 0x03</tt>).\n     */\n    public static int getArgumentsAndReturnSizes(final String desc) {\n        int n = 1;\n        int c = 1;\n        while (true) {\n            char car = desc.charAt(c++);\n            if (car == ')') {\n                car = desc.charAt(c);\n                return n << 2 | (car == 'V' ? 0 : (car == 'D' || car == 'J' ? 2 : 1));\n            } else if (car == 'L') {\n                while (desc.charAt(c++) != ';') {\n                }\n                n += 1;\n            } else if (car == '[') {\n                while ((car = desc.charAt(c)) == '[') {\n                    ++c;\n                }\n                if (car == 'D' || car == 'J') {\n                    n -= 1;\n                }\n            } else if (car == 'D' || car == 'J') {\n                n += 2;\n            } else {\n                n += 1;\n            }\n        }\n    }\n\n    /**\n     * Returns the Java type corresponding to the given type descriptor.\n     *\n     * @param buf a buffer containing a type descriptor.\n     * @param off the offset of this descriptor in the previous buffer.\n     * @return the Java type corresponding to the given type descriptor.\n     */\n    private static Type getType(final char[] buf, final int off) {\n        int len;\n        switch(buf[off]) {\n            case 'V':\n                return VOID_TYPE;\n            case 'Z':\n                return BOOLEAN_TYPE;\n            case 'C':\n                return CHAR_TYPE;\n            case 'B':\n                return BYTE_TYPE;\n            case 'S':\n                return SHORT_TYPE;\n            case 'I':\n                return INT_TYPE;\n            case 'F':\n                return FLOAT_TYPE;\n            case 'J':\n                return LONG_TYPE;\n            case 'D':\n                return DOUBLE_TYPE;\n            case '[':\n                len = 1;\n                while (buf[off + len] == '[') {\n                    ++len;\n                }\n                if (buf[off + len] == 'L') {\n                    ++len;\n                    while (buf[off + len] != ';') {\n                        ++len;\n                    }\n                }\n                return new Type(ARRAY, buf, off, len + 1);\n            // case 'L':\n            default:\n                len = 1;\n                while (buf[off + len] != ';') {\n                    ++len;\n                }\n                return new Type(OBJECT, buf, off + 1, len - 1);\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Accessors\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the sort of this Java type.\n     *\n     * @return {@link #VOID VOID}, {@link #BOOLEAN BOOLEAN},\n     *         {@link #CHAR CHAR}, {@link #BYTE BYTE}, {@link #SHORT SHORT},\n     *         {@link #INT INT}, {@link #FLOAT FLOAT}, {@link #LONG LONG},\n     *         {@link #DOUBLE DOUBLE}, {@link #ARRAY ARRAY} or\n     *         {@link #OBJECT OBJECT}.\n     */\n    public int getSort() {\n        return sort;\n    }\n\n    /**\n     * Returns the number of dimensions of this array type. This method should\n     * only be used for an array type.\n     *\n     * @return the number of dimensions of this array type.\n     */\n    public int getDimensions() {\n        int i = 1;\n        while (buf[off + i] == '[') {\n            ++i;\n        }\n        return i;\n    }\n\n    /**\n     * Returns the type of the elements of this array type. This method should\n     * only be used for an array type.\n     *\n     * @return Returns the type of the elements of this array type.\n     */\n    public Type getElementType() {\n        return getType(buf, off + getDimensions());\n    }\n\n    /**\n     * Returns the name of the class corresponding to this type.\n     *\n     * @return the fully qualified name of the class corresponding to this type.\n     */\n    public String getClassName() {\n        switch(sort) {\n            case VOID:\n                return \"void\";\n            case BOOLEAN:\n                return \"boolean\";\n            case CHAR:\n                return \"char\";\n            case BYTE:\n                return \"byte\";\n            case SHORT:\n                return \"short\";\n            case INT:\n                return \"int\";\n            case FLOAT:\n                return \"float\";\n            case LONG:\n                return \"long\";\n            case DOUBLE:\n                return \"double\";\n            case ARRAY:\n                StringBuffer b = new StringBuffer(getElementType().getClassName());\n                for (int i = getDimensions(); i > 0; --i) {\n                    b.append(\"[]\");\n                }\n                return b.toString();\n            // case OBJECT:\n            default:\n                return new String(buf, off, len).replace('/', '.');\n        }\n    }\n\n    /**\n     * Returns the internal name of the class corresponding to this object or\n     * array type. The internal name of a class is its fully qualified name (as\n     * returned by Class.getName(), where '.' are replaced by '/'. This method\n     * should only be used for an object or array type.\n     *\n     * @return the internal name of the class corresponding to this object type.\n     */\n    public String getInternalName() {\n        return new String(buf, off, len);\n    }\n\n    // ------------------------------------------------------------------------\n    // Conversion to type descriptors\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the descriptor corresponding to this Java type.\n     *\n     * @return the descriptor corresponding to this Java type.\n     */\n    public String getDescriptor() {\n        StringBuffer buf = new StringBuffer();\n        getDescriptor(buf);\n        return buf.toString();\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given argument and return\n     * types.\n     *\n     * @param returnType the return type of the method.\n     * @param argumentTypes the argument types of the method.\n     * @return the descriptor corresponding to the given argument and return\n     *         types.\n     */\n    public static String getMethodDescriptor(final Type returnType, final Type[] argumentTypes) {\n        StringBuffer buf = new StringBuffer();\n        buf.append('(');\n        for (int i = 0; i < argumentTypes.length; ++i) {\n            argumentTypes[i].getDescriptor(buf);\n        }\n        buf.append(')');\n        returnType.getDescriptor(buf);\n        return buf.toString();\n    }\n\n    /**\n     * Appends the descriptor corresponding to this Java type to the given\n     * string buffer.\n     *\n     * @param buf the string buffer to which the descriptor must be appended.\n     */\n    private void getDescriptor(final StringBuffer buf) {\n        if (this.buf == null) {\n            // descriptor is in byte 3 of 'off' for primitive types (buf == null)\n            buf.append((char) ((off & 0xFF000000) >>> 24));\n        } else if (sort == ARRAY) {\n            buf.append(this.buf, off, len);\n        } else {\n            // sort == OBJECT\n            buf.append('L');\n            buf.append(this.buf, off, len);\n            buf.append(';');\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Direct conversion from classes to type descriptors,\n    // without intermediate Type objects\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the internal name of the given class. The internal name of a\n     * class is its fully qualified name, as returned by Class.getName(), where\n     * '.' are replaced by '/'.\n     *\n     * @param c an object or array class.\n     * @return the internal name of the given class.\n     */\n    public static String getInternalName(final Class c) {\n        return c.getName().replace('.', '/');\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given Java type.\n     *\n     * @param c an object class, a primitive class or an array class.\n     * @return the descriptor corresponding to the given class.\n     */\n    public static String getDescriptor(final Class c) {\n        StringBuffer buf = new StringBuffer();\n        getDescriptor(buf, c);\n        return buf.toString();\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given constructor.\n     *\n     * @param c a {@link Constructor Constructor} object.\n     * @return the descriptor of the given constructor.\n     */\n    public static String getConstructorDescriptor(final Constructor c) {\n        Class[] parameters = c.getParameterTypes();\n        StringBuffer buf = new StringBuffer();\n        buf.append('(');\n        for (int i = 0; i < parameters.length; ++i) {\n            getDescriptor(buf, parameters[i]);\n        }\n        return buf.append(\")V\").toString();\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given method.\n     *\n     * @param m a {@link Method Method} object.\n     * @return the descriptor of the given method.\n     */\n    public static String getMethodDescriptor(final Method m) {\n        Class[] parameters = m.getParameterTypes();\n        StringBuffer buf = new StringBuffer();\n        buf.append('(');\n        for (int i = 0; i < parameters.length; ++i) {\n            getDescriptor(buf, parameters[i]);\n        }\n        buf.append(')');\n        getDescriptor(buf, m.getReturnType());\n        return buf.toString();\n    }\n\n    /**\n     * Appends the descriptor of the given class to the given string buffer.\n     *\n     * @param buf the string buffer to which the descriptor must be appended.\n     * @param c the class whose descriptor must be computed.\n     */\n    private static void getDescriptor(final StringBuffer buf, final Class c) {\n        Class d = c;\n        while (true) {\n            if (d.isPrimitive()) {\n                char car;\n                if (d == Integer.TYPE) {\n                    car = 'I';\n                } else if (d == Void.TYPE) {\n                    car = 'V';\n                } else if (d == Boolean.TYPE) {\n                    car = 'Z';\n                } else if (d == Byte.TYPE) {\n                    car = 'B';\n                } else if (d == Character.TYPE) {\n                    car = 'C';\n                } else if (d == Short.TYPE) {\n                    car = 'S';\n                } else if (d == Double.TYPE) {\n                    car = 'D';\n                } else if (d == Float.TYPE) {\n                    car = 'F';\n                } else /* if (d == Long.TYPE) */\n                {\n                    car = 'J';\n                }\n                buf.append(car);\n                return;\n            } else if (d.isArray()) {\n                buf.append('[');\n                d = d.getComponentType();\n            } else {\n                buf.append('L');\n                String name = d.getName();\n                int len = name.length();\n                for (int i = 0; i < len; ++i) {\n                    char car = name.charAt(i);\n                    buf.append(car == '.' ? '/' : car);\n                }\n                buf.append(';');\n                return;\n            }\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Corresponding size and opcodes\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the size of values of this type.\n     *\n     * @return the size of values of this type, i.e., 2 for <tt>long</tt> and\n     *         <tt>double</tt>, 0 for <tt>void</tt> and 1 otherwise.\n     */\n    public int getSize() {\n        // the size is in byte 0 of 'off' for primitive types (buf == null)\n        return buf == null ? (off & 0xFF) : 1;\n    }\n\n    /**\n     * Returns a JVM instruction opcode adapted to this Java type.\n     *\n     * @param opcode a JVM instruction opcode. This opcode must be one of ILOAD,\n     *        ISTORE, IALOAD, IASTORE, IADD, ISUB, IMUL, IDIV, IREM, INEG, ISHL,\n     *        ISHR, IUSHR, IAND, IOR, IXOR and IRETURN.\n     * @return an opcode that is similar to the given opcode, but adapted to\n     *         this Java type. For example, if this type is <tt>float</tt> and\n     *         <tt>opcode</tt> is IRETURN, this method returns FRETURN.\n     */\n    public int getOpcode(final int opcode) {\n        if (opcode == Opcodes.IALOAD || opcode == Opcodes.IASTORE) {\n            // the offset for IALOAD or IASTORE is in byte 1 of 'off' for\n            // primitive types (buf == null)\n            return opcode + (buf == null ? (off & 0xFF00) >> 8 : 4);\n        } else {\n            // the offset for other instructions is in byte 2 of 'off' for\n            // primitive types (buf == null)\n            return opcode + (buf == null ? (off & 0xFF0000) >> 16 : 4);\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Equals, hashCode and toString\n    // ------------------------------------------------------------------------\n    /**\n     * Tests if the given object is equal to this type.\n     *\n     * @param o the object to be compared to this type.\n     * @return <tt>true</tt> if the given object is equal to this type.\n     */\n    public boolean equals(final Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (!(o instanceof Type)) {\n            return false;\n        }\n        Type t = (Type) o;\n        if (sort != t.sort) {\n            return false;\n        }\n        if (sort == OBJECT || sort == ARRAY) {\n            if (len != t.len) {\n                return false;\n            }\n            for (int i = off, j = t.off, end = i + len; i < end; i++, j++) {\n                if (buf[i] != t.buf[j]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code value for this type.\n     *\n     * @return a hash code value for this type.\n     */\n    public int hashCode() {\n        int hc = 13 * sort;\n        if (sort == OBJECT || sort == ARRAY) {\n            for (int i = off, end = i + len; i < end; i++) {\n                hc = 17 * (hc + buf[i]);\n            }\n        }\n        return hc;\n    }\n\n    /**\n     * Returns a string representation of this type.\n     *\n     * @return the descriptor of this type.\n     */\n    public String toString() {\n        return getDescriptor();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/TypeTest10.java",
		"test_prompt": "// TypeTest10.java\npackage org.objectweb.asm.jip;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Type}.\n* It contains ten unit test cases for the {@link Type#getDescriptor(Class)} method.\n*/\nclass TypeTest10 {"
	},
	{
		"original_code": "// Type.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\n\n/**\n * A Java type. This class can be used to make it easier to manipulate type and\n * method descriptors.\n *\n * @author Eric Bruneton\n * @author Chris Nokleberg\n */\npublic class Type {\n\n    /**\n     * The sort of the <tt>void</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int VOID = 0;\n\n    /**\n     * The sort of the <tt>boolean</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int BOOLEAN = 1;\n\n    /**\n     * The sort of the <tt>char</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int CHAR = 2;\n\n    /**\n     * The sort of the <tt>byte</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int BYTE = 3;\n\n    /**\n     * The sort of the <tt>short</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int SHORT = 4;\n\n    /**\n     * The sort of the <tt>int</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int INT = 5;\n\n    /**\n     * The sort of the <tt>float</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int FLOAT = 6;\n\n    /**\n     * The sort of the <tt>long</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int LONG = 7;\n\n    /**\n     * The sort of the <tt>double</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int DOUBLE = 8;\n\n    /**\n     * The sort of array reference types. See {@link #getSort getSort}.\n     */\n    public static final int ARRAY = 9;\n\n    /**\n     * The sort of object reference type. See {@link #getSort getSort}.\n     */\n    public static final int OBJECT = 10;\n\n    /**\n     * The <tt>void</tt> type.\n     */\n    public static final Type VOID_TYPE = new Type(VOID, null, ('V' << 24) | (5 << 16) | (0 << 8) | 0, 1);\n\n    /**\n     * The <tt>boolean</tt> type.\n     */\n    public static final Type BOOLEAN_TYPE = new Type(BOOLEAN, null, ('Z' << 24) | (0 << 16) | (5 << 8) | 1, 1);\n\n    /**\n     * The <tt>char</tt> type.\n     */\n    public static final Type CHAR_TYPE = new Type(CHAR, null, ('C' << 24) | (0 << 16) | (6 << 8) | 1, 1);\n\n    /**\n     * The <tt>byte</tt> type.\n     */\n    public static final Type BYTE_TYPE = new Type(BYTE, null, ('B' << 24) | (0 << 16) | (5 << 8) | 1, 1);\n\n    /**\n     * The <tt>short</tt> type.\n     */\n    public static final Type SHORT_TYPE = new Type(SHORT, null, ('S' << 24) | (0 << 16) | (7 << 8) | 1, 1);\n\n    /**\n     * The <tt>int</tt> type.\n     */\n    public static final Type INT_TYPE = new Type(INT, null, ('I' << 24) | (0 << 16) | (0 << 8) | 1, 1);\n\n    /**\n     * The <tt>float</tt> type.\n     */\n    public static final Type FLOAT_TYPE = new Type(FLOAT, null, ('F' << 24) | (2 << 16) | (2 << 8) | 1, 1);\n\n    /**\n     * The <tt>long</tt> type.\n     */\n    public static final Type LONG_TYPE = new Type(LONG, null, ('J' << 24) | (1 << 16) | (1 << 8) | 2, 1);\n\n    /**\n     * The <tt>double</tt> type.\n     */\n    public static final Type DOUBLE_TYPE = new Type(DOUBLE, null, ('D' << 24) | (3 << 16) | (3 << 8) | 2, 1);\n\n    // ------------------------------------------------------------------------\n    // Fields\n    // ------------------------------------------------------------------------\n    /**\n     * The sort of this Java type.\n     */\n    private final int sort;\n\n    /**\n     * A buffer containing the internal name of this Java type. This field is\n     * only used for reference types.\n     */\n    private final char[] buf;\n\n    /**\n     * The offset of the internal name of this Java type in {@link #buf buf} or,\n     * for primitive types, the size, descriptor and getOpcode offsets for this\n     * type (byte 0 contains the size, byte 1 the descriptor, byte 2 the offset\n     * for IALOAD or IASTORE, byte 3 the offset for all other instructions).\n     */\n    private final int off;\n\n    /**\n     * The length of the internal name of this Java type.\n     */\n    private final int len;\n\n    // ------------------------------------------------------------------------\n    // Constructors\n    // ------------------------------------------------------------------------\n    /**\n     * Constructs a reference type.\n     *\n     * @param sort the sort of the reference type to be constructed.\n     * @param buf a buffer containing the descriptor of the previous type.\n     * @param off the offset of this descriptor in the previous buffer.\n     * @param len the length of this descriptor.\n     */\n    private Type(final int sort, final char[] buf, final int off, final int len) {\n        this.sort = sort;\n        this.buf = buf;\n        this.off = off;\n        this.len = len;\n    }\n\n    /**\n     * Returns the Java type corresponding to the given type descriptor.\n     *\n     * @param typeDescriptor a type descriptor.\n     * @return the Java type corresponding to the given type descriptor.\n     */\n    public static Type getType(final String typeDescriptor) {\n        return getType(typeDescriptor.toCharArray(), 0);\n    }\n\n    /**\n     * Returns the Java type corresponding to the given internal name.\n     *\n     * @param internalName an internal name.\n     * @return the Java type corresponding to the given internal name.\n     */\n    public static Type getObjectType(final String internalName) {\n        char[] buf = internalName.toCharArray();\n        return new Type(buf[0] == '[' ? ARRAY : OBJECT, buf, 0, buf.length);\n    }\n\n    /**\n     * Returns the Java type corresponding to the given class.\n     *\n     * @param c a class.\n     * @return the Java type corresponding to the given class.\n     */\n    public static Type getType(final Class c) {\n        if (c.isPrimitive()) {\n            if (c == Integer.TYPE) {\n                return INT_TYPE;\n            } else if (c == Void.TYPE) {\n                return VOID_TYPE;\n            } else if (c == Boolean.TYPE) {\n                return BOOLEAN_TYPE;\n            } else if (c == Byte.TYPE) {\n                return BYTE_TYPE;\n            } else if (c == Character.TYPE) {\n                return CHAR_TYPE;\n            } else if (c == Short.TYPE) {\n                return SHORT_TYPE;\n            } else if (c == Double.TYPE) {\n                return DOUBLE_TYPE;\n            } else if (c == Float.TYPE) {\n                return FLOAT_TYPE;\n            } else /* if (c == Long.TYPE) */\n            {\n                return LONG_TYPE;\n            }\n        } else {\n            return getType(getDescriptor(c));\n        }\n    }\n\n    /**\n     * Returns the Java types corresponding to the argument types of the given\n     * method descriptor.\n     *\n     * @param methodDescriptor a method descriptor.\n     * @return the Java types corresponding to the argument types of the given\n     *         method descriptor.\n     */\n    public static Type[] getArgumentTypes(final String methodDescriptor) {\n        char[] buf = methodDescriptor.toCharArray();\n        int off = 1;\n        int size = 0;\n        while (true) {\n            char car = buf[off++];\n            if (car == ')') {\n                break;\n            } else if (car == 'L') {\n                while (buf[off++] != ';') {\n                }\n                ++size;\n            } else if (car != '[') {\n                ++size;\n            }\n        }\n        Type[] args = new Type[size];\n        off = 1;\n        size = 0;\n        while (buf[off] != ')') {\n            args[size] = getType(buf, off);\n            off += args[size].len + (args[size].sort == OBJECT ? 2 : 0);\n            size += 1;\n        }\n        return args;\n    }\n\n    /**\n     * Returns the Java types corresponding to the argument types of the given\n     * method.\n     *\n     * @param method a method.\n     * @return the Java types corresponding to the argument types of the given\n     *         method.\n     */\n    public static Type[] getArgumentTypes(final Method method) {\n        Class[] classes = method.getParameterTypes();\n        Type[] types = new Type[classes.length];\n        for (int i = classes.length - 1; i >= 0; --i) {\n            types[i] = getType(classes[i]);\n        }\n        return types;\n    }\n\n    /**\n     * Returns the Java type corresponding to the return type of the given\n     * method descriptor.\n     *\n     * @param methodDescriptor a method descriptor.\n     * @return the Java type corresponding to the return type of the given\n     *         method descriptor.\n     */\n    public static Type getReturnType(final String methodDescriptor) {\n        char[] buf = methodDescriptor.toCharArray();\n        return getType(buf, methodDescriptor.indexOf(')') + 1);\n    }\n\n    /**\n     * Returns the Java type corresponding to the return type of the given\n     * method.\n     *\n     * @param method a method.\n     * @return the Java type corresponding to the return type of the given\n     *         method.\n     */\n    public static Type getReturnType(final Method method) {\n        return getType(method.getReturnType());\n    }\n\n    /**\n     * Computes the size of the arguments and of the return value of a method.\n     *\n     * @param desc the descriptor of a method.\n     * @return the size of the arguments of the method (plus one for the\n     *         implicit this argument), argSize, and the size of its return\n     *         value, retSize, packed into a single int i =\n     *         <tt>(argSize << 2) | retSize</tt> (argSize is therefore equal\n     *         to <tt>i >> 2</tt>, and retSize to <tt>i & 0x03</tt>).\n     */\n    public static int getArgumentsAndReturnSizes(final String desc) {\n        int n = 1;\n        int c = 1;\n        while (true) {\n            char car = desc.charAt(c++);\n            if (car == ')') {\n                car = desc.charAt(c);\n                return n << 2 | (car == 'V' ? 0 : (car == 'D' || car == 'J' ? 2 : 1));\n            } else if (car == 'L') {\n                while (desc.charAt(c++) != ';') {\n                }\n                n += 1;\n            } else if (car == '[') {\n                while ((car = desc.charAt(c)) == '[') {\n                    ++c;\n                }\n                if (car == 'D' || car == 'J') {\n                    n -= 1;\n                }\n            } else if (car == 'D' || car == 'J') {\n                n += 2;\n            } else {\n                n += 1;\n            }\n        }\n    }\n\n    /**\n     * Returns the Java type corresponding to the given type descriptor.\n     *\n     * @param buf a buffer containing a type descriptor.\n     * @param off the offset of this descriptor in the previous buffer.\n     * @return the Java type corresponding to the given type descriptor.\n     */\n    private static Type getType(final char[] buf, final int off) {\n        int len;\n        switch(buf[off]) {\n            case 'V':\n                return VOID_TYPE;\n            case 'Z':\n                return BOOLEAN_TYPE;\n            case 'C':\n                return CHAR_TYPE;\n            case 'B':\n                return BYTE_TYPE;\n            case 'S':\n                return SHORT_TYPE;\n            case 'I':\n                return INT_TYPE;\n            case 'F':\n                return FLOAT_TYPE;\n            case 'J':\n                return LONG_TYPE;\n            case 'D':\n                return DOUBLE_TYPE;\n            case '[':\n                len = 1;\n                while (buf[off + len] == '[') {\n                    ++len;\n                }\n                if (buf[off + len] == 'L') {\n                    ++len;\n                    while (buf[off + len] != ';') {\n                        ++len;\n                    }\n                }\n                return new Type(ARRAY, buf, off, len + 1);\n            // case 'L':\n            default:\n                len = 1;\n                while (buf[off + len] != ';') {\n                    ++len;\n                }\n                return new Type(OBJECT, buf, off + 1, len - 1);\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Accessors\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the sort of this Java type.\n     *\n     * @return {@link #VOID VOID}, {@link #BOOLEAN BOOLEAN},\n     *         {@link #CHAR CHAR}, {@link #BYTE BYTE}, {@link #SHORT SHORT},\n     *         {@link #INT INT}, {@link #FLOAT FLOAT}, {@link #LONG LONG},\n     *         {@link #DOUBLE DOUBLE}, {@link #ARRAY ARRAY} or\n     *         {@link #OBJECT OBJECT}.\n     */\n    public int getSort() {\n        return sort;\n    }\n\n    /**\n     * Returns the number of dimensions of this array type. This method should\n     * only be used for an array type.\n     *\n     * @return the number of dimensions of this array type.\n     */\n    public int getDimensions() {\n        int i = 1;\n        while (buf[off + i] == '[') {\n            ++i;\n        }\n        return i;\n    }\n\n    /**\n     * Returns the type of the elements of this array type. This method should\n     * only be used for an array type.\n     *\n     * @return Returns the type of the elements of this array type.\n     */\n    public Type getElementType() {\n        return getType(buf, off + getDimensions());\n    }\n\n    /**\n     * Returns the name of the class corresponding to this type.\n     *\n     * @return the fully qualified name of the class corresponding to this type.\n     */\n    public String getClassName() {\n        switch(sort) {\n            case VOID:\n                return \"void\";\n            case BOOLEAN:\n                return \"boolean\";\n            case CHAR:\n                return \"char\";\n            case BYTE:\n                return \"byte\";\n            case SHORT:\n                return \"short\";\n            case INT:\n                return \"int\";\n            case FLOAT:\n                return \"float\";\n            case LONG:\n                return \"long\";\n            case DOUBLE:\n                return \"double\";\n            case ARRAY:\n                StringBuffer b = new StringBuffer(getElementType().getClassName());\n                for (int i = getDimensions(); i > 0; --i) {\n                    b.append(\"[]\");\n                }\n                return b.toString();\n            // case OBJECT:\n            default:\n                return new String(buf, off, len).replace('/', '.');\n        }\n    }\n\n    /**\n     * Returns the internal name of the class corresponding to this object or\n     * array type. The internal name of a class is its fully qualified name (as\n     * returned by Class.getName(), where '.' are replaced by '/'. This method\n     * should only be used for an object or array type.\n     *\n     * @return the internal name of the class corresponding to this object type.\n     */\n    public String getInternalName() {\n        return new String(buf, off, len);\n    }\n\n    // ------------------------------------------------------------------------\n    // Conversion to type descriptors\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the descriptor corresponding to this Java type.\n     *\n     * @return the descriptor corresponding to this Java type.\n     */\n    public String getDescriptor() {\n        StringBuffer buf = new StringBuffer();\n        getDescriptor(buf);\n        return buf.toString();\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given argument and return\n     * types.\n     *\n     * @param returnType the return type of the method.\n     * @param argumentTypes the argument types of the method.\n     * @return the descriptor corresponding to the given argument and return\n     *         types.\n     */\n    public static String getMethodDescriptor(final Type returnType, final Type[] argumentTypes) {\n        StringBuffer buf = new StringBuffer();\n        buf.append('(');\n        for (int i = 0; i < argumentTypes.length; ++i) {\n            argumentTypes[i].getDescriptor(buf);\n        }\n        buf.append(')');\n        returnType.getDescriptor(buf);\n        return buf.toString();\n    }\n\n    /**\n     * Appends the descriptor corresponding to this Java type to the given\n     * string buffer.\n     *\n     * @param buf the string buffer to which the descriptor must be appended.\n     */\n    private void getDescriptor(final StringBuffer buf) {\n        if (this.buf == null) {\n            // descriptor is in byte 3 of 'off' for primitive types (buf == null)\n            buf.append((char) ((off & 0xFF000000) >>> 24));\n        } else if (sort == ARRAY) {\n            buf.append(this.buf, off, len);\n        } else {\n            // sort == OBJECT\n            buf.append('L');\n            buf.append(this.buf, off, len);\n            buf.append(';');\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Direct conversion from classes to type descriptors,\n    // without intermediate Type objects\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the internal name of the given class. The internal name of a\n     * class is its fully qualified name, as returned by Class.getName(), where\n     * '.' are replaced by '/'.\n     *\n     * @param c an object or array class.\n     * @return the internal name of the given class.\n     */\n    public static String getInternalName(final Class c) {\n        return c.getName().replace('.', '/');\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given Java type.\n     *\n     * @param c an object class, a primitive class or an array class.\n     * @return the descriptor corresponding to the given class.\n     */\n    public static String getDescriptor(final Class c) {\n        StringBuffer buf = new StringBuffer();\n        getDescriptor(buf, c);\n        return buf.toString();\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given constructor.\n     *\n     * @param c a {@link Constructor Constructor} object.\n     * @return the descriptor of the given constructor.\n     */\n    public static String getConstructorDescriptor(final Constructor c) {\n        Class[] parameters = c.getParameterTypes();\n        StringBuffer buf = new StringBuffer();\n        buf.append('(');\n        for (int i = 0; i < parameters.length; ++i) {\n            getDescriptor(buf, parameters[i]);\n        }\n        return buf.append(\")V\").toString();\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given method.\n     *\n     * @param m a {@link Method Method} object.\n     * @return the descriptor of the given method.\n     */\n    public static String getMethodDescriptor(final Method m) {\n        Class[] parameters = m.getParameterTypes();\n        StringBuffer buf = new StringBuffer();\n        buf.append('(');\n        for (int i = 0; i < parameters.length; ++i) {\n            getDescriptor(buf, parameters[i]);\n        }\n        buf.append(')');\n        getDescriptor(buf, m.getReturnType());\n        return buf.toString();\n    }\n\n    /**\n     * Appends the descriptor of the given class to the given string buffer.\n     *\n     * @param buf the string buffer to which the descriptor must be appended.\n     * @param c the class whose descriptor must be computed.\n     */\n    private static void getDescriptor(final StringBuffer buf, final Class c) {\n        Class d = c;\n        while (true) {\n            if (d.isPrimitive()) {\n                char car;\n                if (d == Integer.TYPE) {\n                    car = 'I';\n                } else if (d == Void.TYPE) {\n                    car = 'V';\n                } else if (d == Boolean.TYPE) {\n                    car = 'Z';\n                } else if (d == Byte.TYPE) {\n                    car = 'B';\n                } else if (d == Character.TYPE) {\n                    car = 'C';\n                } else if (d == Short.TYPE) {\n                    car = 'S';\n                } else if (d == Double.TYPE) {\n                    car = 'D';\n                } else if (d == Float.TYPE) {\n                    car = 'F';\n                } else /* if (d == Long.TYPE) */\n                {\n                    car = 'J';\n                }\n                buf.append(car);\n                return;\n            } else if (d.isArray()) {\n                buf.append('[');\n                d = d.getComponentType();\n            } else {\n                buf.append('L');\n                String name = d.getName();\n                int len = name.length();\n                for (int i = 0; i < len; ++i) {\n                    char car = name.charAt(i);\n                    buf.append(car == '.' ? '/' : car);\n                }\n                buf.append(';');\n                return;\n            }\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Corresponding size and opcodes\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the size of values of this type.\n     *\n     * @return the size of values of this type, i.e., 2 for <tt>long</tt> and\n     *         <tt>double</tt>, 0 for <tt>void</tt> and 1 otherwise.\n     */\n    public int getSize() {\n        // the size is in byte 0 of 'off' for primitive types (buf == null)\n        return buf == null ? (off & 0xFF) : 1;\n    }\n\n    /**\n     * Returns a JVM instruction opcode adapted to this Java type.\n     *\n     * @param opcode a JVM instruction opcode. This opcode must be one of ILOAD,\n     *        ISTORE, IALOAD, IASTORE, IADD, ISUB, IMUL, IDIV, IREM, INEG, ISHL,\n     *        ISHR, IUSHR, IAND, IOR, IXOR and IRETURN.\n     * @return an opcode that is similar to the given opcode, but adapted to\n     *         this Java type. For example, if this type is <tt>float</tt> and\n     *         <tt>opcode</tt> is IRETURN, this method returns FRETURN.\n     */\n    public int getOpcode(final int opcode) {\n        if (opcode == Opcodes.IALOAD || opcode == Opcodes.IASTORE) {\n            // the offset for IALOAD or IASTORE is in byte 1 of 'off' for\n            // primitive types (buf == null)\n            return opcode + (buf == null ? (off & 0xFF00) >> 8 : 4);\n        } else {\n            // the offset for other instructions is in byte 2 of 'off' for\n            // primitive types (buf == null)\n            return opcode + (buf == null ? (off & 0xFF0000) >> 16 : 4);\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Equals, hashCode and toString\n    // ------------------------------------------------------------------------\n    /**\n     * Tests if the given object is equal to this type.\n     *\n     * @param o the object to be compared to this type.\n     * @return <tt>true</tt> if the given object is equal to this type.\n     */\n    public boolean equals(final Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (!(o instanceof Type)) {\n            return false;\n        }\n        Type t = (Type) o;\n        if (sort != t.sort) {\n            return false;\n        }\n        if (sort == OBJECT || sort == ARRAY) {\n            if (len != t.len) {\n                return false;\n            }\n            for (int i = off, j = t.off, end = i + len; i < end; i++, j++) {\n                if (buf[i] != t.buf[j]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code value for this type.\n     *\n     * @return a hash code value for this type.\n     */\n    public int hashCode() {\n        int hc = 13 * sort;\n        if (sort == OBJECT || sort == ARRAY) {\n            for (int i = off, end = i + len; i < end; i++) {\n                hc = 17 * (hc + buf[i]);\n            }\n        }\n        return hc;\n    }\n\n    /**\n     * Returns a string representation of this type.\n     *\n     * @return the descriptor of this type.\n     */\n    public String toString() {\n        return getDescriptor();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/TypeTest11.java",
		"test_prompt": "// TypeTest11.java\npackage org.objectweb.asm.jip;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Type}.\n* It contains ten unit test cases for the {@link Type#getConstructorDescriptor(Constructor)} method.\n*/\nclass TypeTest11 {"
	},
	{
		"original_code": "// Type.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\n\n/**\n * A Java type. This class can be used to make it easier to manipulate type and\n * method descriptors.\n *\n * @author Eric Bruneton\n * @author Chris Nokleberg\n */\npublic class Type {\n\n    /**\n     * The sort of the <tt>void</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int VOID = 0;\n\n    /**\n     * The sort of the <tt>boolean</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int BOOLEAN = 1;\n\n    /**\n     * The sort of the <tt>char</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int CHAR = 2;\n\n    /**\n     * The sort of the <tt>byte</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int BYTE = 3;\n\n    /**\n     * The sort of the <tt>short</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int SHORT = 4;\n\n    /**\n     * The sort of the <tt>int</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int INT = 5;\n\n    /**\n     * The sort of the <tt>float</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int FLOAT = 6;\n\n    /**\n     * The sort of the <tt>long</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int LONG = 7;\n\n    /**\n     * The sort of the <tt>double</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int DOUBLE = 8;\n\n    /**\n     * The sort of array reference types. See {@link #getSort getSort}.\n     */\n    public static final int ARRAY = 9;\n\n    /**\n     * The sort of object reference type. See {@link #getSort getSort}.\n     */\n    public static final int OBJECT = 10;\n\n    /**\n     * The <tt>void</tt> type.\n     */\n    public static final Type VOID_TYPE = new Type(VOID, null, ('V' << 24) | (5 << 16) | (0 << 8) | 0, 1);\n\n    /**\n     * The <tt>boolean</tt> type.\n     */\n    public static final Type BOOLEAN_TYPE = new Type(BOOLEAN, null, ('Z' << 24) | (0 << 16) | (5 << 8) | 1, 1);\n\n    /**\n     * The <tt>char</tt> type.\n     */\n    public static final Type CHAR_TYPE = new Type(CHAR, null, ('C' << 24) | (0 << 16) | (6 << 8) | 1, 1);\n\n    /**\n     * The <tt>byte</tt> type.\n     */\n    public static final Type BYTE_TYPE = new Type(BYTE, null, ('B' << 24) | (0 << 16) | (5 << 8) | 1, 1);\n\n    /**\n     * The <tt>short</tt> type.\n     */\n    public static final Type SHORT_TYPE = new Type(SHORT, null, ('S' << 24) | (0 << 16) | (7 << 8) | 1, 1);\n\n    /**\n     * The <tt>int</tt> type.\n     */\n    public static final Type INT_TYPE = new Type(INT, null, ('I' << 24) | (0 << 16) | (0 << 8) | 1, 1);\n\n    /**\n     * The <tt>float</tt> type.\n     */\n    public static final Type FLOAT_TYPE = new Type(FLOAT, null, ('F' << 24) | (2 << 16) | (2 << 8) | 1, 1);\n\n    /**\n     * The <tt>long</tt> type.\n     */\n    public static final Type LONG_TYPE = new Type(LONG, null, ('J' << 24) | (1 << 16) | (1 << 8) | 2, 1);\n\n    /**\n     * The <tt>double</tt> type.\n     */\n    public static final Type DOUBLE_TYPE = new Type(DOUBLE, null, ('D' << 24) | (3 << 16) | (3 << 8) | 2, 1);\n\n    // ------------------------------------------------------------------------\n    // Fields\n    // ------------------------------------------------------------------------\n    /**\n     * The sort of this Java type.\n     */\n    private final int sort;\n\n    /**\n     * A buffer containing the internal name of this Java type. This field is\n     * only used for reference types.\n     */\n    private final char[] buf;\n\n    /**\n     * The offset of the internal name of this Java type in {@link #buf buf} or,\n     * for primitive types, the size, descriptor and getOpcode offsets for this\n     * type (byte 0 contains the size, byte 1 the descriptor, byte 2 the offset\n     * for IALOAD or IASTORE, byte 3 the offset for all other instructions).\n     */\n    private final int off;\n\n    /**\n     * The length of the internal name of this Java type.\n     */\n    private final int len;\n\n    // ------------------------------------------------------------------------\n    // Constructors\n    // ------------------------------------------------------------------------\n    /**\n     * Constructs a reference type.\n     *\n     * @param sort the sort of the reference type to be constructed.\n     * @param buf a buffer containing the descriptor of the previous type.\n     * @param off the offset of this descriptor in the previous buffer.\n     * @param len the length of this descriptor.\n     */\n    private Type(final int sort, final char[] buf, final int off, final int len) {\n        this.sort = sort;\n        this.buf = buf;\n        this.off = off;\n        this.len = len;\n    }\n\n    /**\n     * Returns the Java type corresponding to the given type descriptor.\n     *\n     * @param typeDescriptor a type descriptor.\n     * @return the Java type corresponding to the given type descriptor.\n     */\n    public static Type getType(final String typeDescriptor) {\n        return getType(typeDescriptor.toCharArray(), 0);\n    }\n\n    /**\n     * Returns the Java type corresponding to the given internal name.\n     *\n     * @param internalName an internal name.\n     * @return the Java type corresponding to the given internal name.\n     */\n    public static Type getObjectType(final String internalName) {\n        char[] buf = internalName.toCharArray();\n        return new Type(buf[0] == '[' ? ARRAY : OBJECT, buf, 0, buf.length);\n    }\n\n    /**\n     * Returns the Java type corresponding to the given class.\n     *\n     * @param c a class.\n     * @return the Java type corresponding to the given class.\n     */\n    public static Type getType(final Class c) {\n        if (c.isPrimitive()) {\n            if (c == Integer.TYPE) {\n                return INT_TYPE;\n            } else if (c == Void.TYPE) {\n                return VOID_TYPE;\n            } else if (c == Boolean.TYPE) {\n                return BOOLEAN_TYPE;\n            } else if (c == Byte.TYPE) {\n                return BYTE_TYPE;\n            } else if (c == Character.TYPE) {\n                return CHAR_TYPE;\n            } else if (c == Short.TYPE) {\n                return SHORT_TYPE;\n            } else if (c == Double.TYPE) {\n                return DOUBLE_TYPE;\n            } else if (c == Float.TYPE) {\n                return FLOAT_TYPE;\n            } else /* if (c == Long.TYPE) */\n            {\n                return LONG_TYPE;\n            }\n        } else {\n            return getType(getDescriptor(c));\n        }\n    }\n\n    /**\n     * Returns the Java types corresponding to the argument types of the given\n     * method descriptor.\n     *\n     * @param methodDescriptor a method descriptor.\n     * @return the Java types corresponding to the argument types of the given\n     *         method descriptor.\n     */\n    public static Type[] getArgumentTypes(final String methodDescriptor) {\n        char[] buf = methodDescriptor.toCharArray();\n        int off = 1;\n        int size = 0;\n        while (true) {\n            char car = buf[off++];\n            if (car == ')') {\n                break;\n            } else if (car == 'L') {\n                while (buf[off++] != ';') {\n                }\n                ++size;\n            } else if (car != '[') {\n                ++size;\n            }\n        }\n        Type[] args = new Type[size];\n        off = 1;\n        size = 0;\n        while (buf[off] != ')') {\n            args[size] = getType(buf, off);\n            off += args[size].len + (args[size].sort == OBJECT ? 2 : 0);\n            size += 1;\n        }\n        return args;\n    }\n\n    /**\n     * Returns the Java types corresponding to the argument types of the given\n     * method.\n     *\n     * @param method a method.\n     * @return the Java types corresponding to the argument types of the given\n     *         method.\n     */\n    public static Type[] getArgumentTypes(final Method method) {\n        Class[] classes = method.getParameterTypes();\n        Type[] types = new Type[classes.length];\n        for (int i = classes.length - 1; i >= 0; --i) {\n            types[i] = getType(classes[i]);\n        }\n        return types;\n    }\n\n    /**\n     * Returns the Java type corresponding to the return type of the given\n     * method descriptor.\n     *\n     * @param methodDescriptor a method descriptor.\n     * @return the Java type corresponding to the return type of the given\n     *         method descriptor.\n     */\n    public static Type getReturnType(final String methodDescriptor) {\n        char[] buf = methodDescriptor.toCharArray();\n        return getType(buf, methodDescriptor.indexOf(')') + 1);\n    }\n\n    /**\n     * Returns the Java type corresponding to the return type of the given\n     * method.\n     *\n     * @param method a method.\n     * @return the Java type corresponding to the return type of the given\n     *         method.\n     */\n    public static Type getReturnType(final Method method) {\n        return getType(method.getReturnType());\n    }\n\n    /**\n     * Computes the size of the arguments and of the return value of a method.\n     *\n     * @param desc the descriptor of a method.\n     * @return the size of the arguments of the method (plus one for the\n     *         implicit this argument), argSize, and the size of its return\n     *         value, retSize, packed into a single int i =\n     *         <tt>(argSize << 2) | retSize</tt> (argSize is therefore equal\n     *         to <tt>i >> 2</tt>, and retSize to <tt>i & 0x03</tt>).\n     */\n    public static int getArgumentsAndReturnSizes(final String desc) {\n        int n = 1;\n        int c = 1;\n        while (true) {\n            char car = desc.charAt(c++);\n            if (car == ')') {\n                car = desc.charAt(c);\n                return n << 2 | (car == 'V' ? 0 : (car == 'D' || car == 'J' ? 2 : 1));\n            } else if (car == 'L') {\n                while (desc.charAt(c++) != ';') {\n                }\n                n += 1;\n            } else if (car == '[') {\n                while ((car = desc.charAt(c)) == '[') {\n                    ++c;\n                }\n                if (car == 'D' || car == 'J') {\n                    n -= 1;\n                }\n            } else if (car == 'D' || car == 'J') {\n                n += 2;\n            } else {\n                n += 1;\n            }\n        }\n    }\n\n    /**\n     * Returns the Java type corresponding to the given type descriptor.\n     *\n     * @param buf a buffer containing a type descriptor.\n     * @param off the offset of this descriptor in the previous buffer.\n     * @return the Java type corresponding to the given type descriptor.\n     */\n    private static Type getType(final char[] buf, final int off) {\n        int len;\n        switch(buf[off]) {\n            case 'V':\n                return VOID_TYPE;\n            case 'Z':\n                return BOOLEAN_TYPE;\n            case 'C':\n                return CHAR_TYPE;\n            case 'B':\n                return BYTE_TYPE;\n            case 'S':\n                return SHORT_TYPE;\n            case 'I':\n                return INT_TYPE;\n            case 'F':\n                return FLOAT_TYPE;\n            case 'J':\n                return LONG_TYPE;\n            case 'D':\n                return DOUBLE_TYPE;\n            case '[':\n                len = 1;\n                while (buf[off + len] == '[') {\n                    ++len;\n                }\n                if (buf[off + len] == 'L') {\n                    ++len;\n                    while (buf[off + len] != ';') {\n                        ++len;\n                    }\n                }\n                return new Type(ARRAY, buf, off, len + 1);\n            // case 'L':\n            default:\n                len = 1;\n                while (buf[off + len] != ';') {\n                    ++len;\n                }\n                return new Type(OBJECT, buf, off + 1, len - 1);\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Accessors\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the sort of this Java type.\n     *\n     * @return {@link #VOID VOID}, {@link #BOOLEAN BOOLEAN},\n     *         {@link #CHAR CHAR}, {@link #BYTE BYTE}, {@link #SHORT SHORT},\n     *         {@link #INT INT}, {@link #FLOAT FLOAT}, {@link #LONG LONG},\n     *         {@link #DOUBLE DOUBLE}, {@link #ARRAY ARRAY} or\n     *         {@link #OBJECT OBJECT}.\n     */\n    public int getSort() {\n        return sort;\n    }\n\n    /**\n     * Returns the number of dimensions of this array type. This method should\n     * only be used for an array type.\n     *\n     * @return the number of dimensions of this array type.\n     */\n    public int getDimensions() {\n        int i = 1;\n        while (buf[off + i] == '[') {\n            ++i;\n        }\n        return i;\n    }\n\n    /**\n     * Returns the type of the elements of this array type. This method should\n     * only be used for an array type.\n     *\n     * @return Returns the type of the elements of this array type.\n     */\n    public Type getElementType() {\n        return getType(buf, off + getDimensions());\n    }\n\n    /**\n     * Returns the name of the class corresponding to this type.\n     *\n     * @return the fully qualified name of the class corresponding to this type.\n     */\n    public String getClassName() {\n        switch(sort) {\n            case VOID:\n                return \"void\";\n            case BOOLEAN:\n                return \"boolean\";\n            case CHAR:\n                return \"char\";\n            case BYTE:\n                return \"byte\";\n            case SHORT:\n                return \"short\";\n            case INT:\n                return \"int\";\n            case FLOAT:\n                return \"float\";\n            case LONG:\n                return \"long\";\n            case DOUBLE:\n                return \"double\";\n            case ARRAY:\n                StringBuffer b = new StringBuffer(getElementType().getClassName());\n                for (int i = getDimensions(); i > 0; --i) {\n                    b.append(\"[]\");\n                }\n                return b.toString();\n            // case OBJECT:\n            default:\n                return new String(buf, off, len).replace('/', '.');\n        }\n    }\n\n    /**\n     * Returns the internal name of the class corresponding to this object or\n     * array type. The internal name of a class is its fully qualified name (as\n     * returned by Class.getName(), where '.' are replaced by '/'. This method\n     * should only be used for an object or array type.\n     *\n     * @return the internal name of the class corresponding to this object type.\n     */\n    public String getInternalName() {\n        return new String(buf, off, len);\n    }\n\n    // ------------------------------------------------------------------------\n    // Conversion to type descriptors\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the descriptor corresponding to this Java type.\n     *\n     * @return the descriptor corresponding to this Java type.\n     */\n    public String getDescriptor() {\n        StringBuffer buf = new StringBuffer();\n        getDescriptor(buf);\n        return buf.toString();\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given argument and return\n     * types.\n     *\n     * @param returnType the return type of the method.\n     * @param argumentTypes the argument types of the method.\n     * @return the descriptor corresponding to the given argument and return\n     *         types.\n     */\n    public static String getMethodDescriptor(final Type returnType, final Type[] argumentTypes) {\n        StringBuffer buf = new StringBuffer();\n        buf.append('(');\n        for (int i = 0; i < argumentTypes.length; ++i) {\n            argumentTypes[i].getDescriptor(buf);\n        }\n        buf.append(')');\n        returnType.getDescriptor(buf);\n        return buf.toString();\n    }\n\n    /**\n     * Appends the descriptor corresponding to this Java type to the given\n     * string buffer.\n     *\n     * @param buf the string buffer to which the descriptor must be appended.\n     */\n    private void getDescriptor(final StringBuffer buf) {\n        if (this.buf == null) {\n            // descriptor is in byte 3 of 'off' for primitive types (buf == null)\n            buf.append((char) ((off & 0xFF000000) >>> 24));\n        } else if (sort == ARRAY) {\n            buf.append(this.buf, off, len);\n        } else {\n            // sort == OBJECT\n            buf.append('L');\n            buf.append(this.buf, off, len);\n            buf.append(';');\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Direct conversion from classes to type descriptors,\n    // without intermediate Type objects\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the internal name of the given class. The internal name of a\n     * class is its fully qualified name, as returned by Class.getName(), where\n     * '.' are replaced by '/'.\n     *\n     * @param c an object or array class.\n     * @return the internal name of the given class.\n     */\n    public static String getInternalName(final Class c) {\n        return c.getName().replace('.', '/');\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given Java type.\n     *\n     * @param c an object class, a primitive class or an array class.\n     * @return the descriptor corresponding to the given class.\n     */\n    public static String getDescriptor(final Class c) {\n        StringBuffer buf = new StringBuffer();\n        getDescriptor(buf, c);\n        return buf.toString();\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given constructor.\n     *\n     * @param c a {@link Constructor Constructor} object.\n     * @return the descriptor of the given constructor.\n     */\n    public static String getConstructorDescriptor(final Constructor c) {\n        Class[] parameters = c.getParameterTypes();\n        StringBuffer buf = new StringBuffer();\n        buf.append('(');\n        for (int i = 0; i < parameters.length; ++i) {\n            getDescriptor(buf, parameters[i]);\n        }\n        return buf.append(\")V\").toString();\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given method.\n     *\n     * @param m a {@link Method Method} object.\n     * @return the descriptor of the given method.\n     */\n    public static String getMethodDescriptor(final Method m) {\n        Class[] parameters = m.getParameterTypes();\n        StringBuffer buf = new StringBuffer();\n        buf.append('(');\n        for (int i = 0; i < parameters.length; ++i) {\n            getDescriptor(buf, parameters[i]);\n        }\n        buf.append(')');\n        getDescriptor(buf, m.getReturnType());\n        return buf.toString();\n    }\n\n    /**\n     * Appends the descriptor of the given class to the given string buffer.\n     *\n     * @param buf the string buffer to which the descriptor must be appended.\n     * @param c the class whose descriptor must be computed.\n     */\n    private static void getDescriptor(final StringBuffer buf, final Class c) {\n        Class d = c;\n        while (true) {\n            if (d.isPrimitive()) {\n                char car;\n                if (d == Integer.TYPE) {\n                    car = 'I';\n                } else if (d == Void.TYPE) {\n                    car = 'V';\n                } else if (d == Boolean.TYPE) {\n                    car = 'Z';\n                } else if (d == Byte.TYPE) {\n                    car = 'B';\n                } else if (d == Character.TYPE) {\n                    car = 'C';\n                } else if (d == Short.TYPE) {\n                    car = 'S';\n                } else if (d == Double.TYPE) {\n                    car = 'D';\n                } else if (d == Float.TYPE) {\n                    car = 'F';\n                } else /* if (d == Long.TYPE) */\n                {\n                    car = 'J';\n                }\n                buf.append(car);\n                return;\n            } else if (d.isArray()) {\n                buf.append('[');\n                d = d.getComponentType();\n            } else {\n                buf.append('L');\n                String name = d.getName();\n                int len = name.length();\n                for (int i = 0; i < len; ++i) {\n                    char car = name.charAt(i);\n                    buf.append(car == '.' ? '/' : car);\n                }\n                buf.append(';');\n                return;\n            }\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Corresponding size and opcodes\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the size of values of this type.\n     *\n     * @return the size of values of this type, i.e., 2 for <tt>long</tt> and\n     *         <tt>double</tt>, 0 for <tt>void</tt> and 1 otherwise.\n     */\n    public int getSize() {\n        // the size is in byte 0 of 'off' for primitive types (buf == null)\n        return buf == null ? (off & 0xFF) : 1;\n    }\n\n    /**\n     * Returns a JVM instruction opcode adapted to this Java type.\n     *\n     * @param opcode a JVM instruction opcode. This opcode must be one of ILOAD,\n     *        ISTORE, IALOAD, IASTORE, IADD, ISUB, IMUL, IDIV, IREM, INEG, ISHL,\n     *        ISHR, IUSHR, IAND, IOR, IXOR and IRETURN.\n     * @return an opcode that is similar to the given opcode, but adapted to\n     *         this Java type. For example, if this type is <tt>float</tt> and\n     *         <tt>opcode</tt> is IRETURN, this method returns FRETURN.\n     */\n    public int getOpcode(final int opcode) {\n        if (opcode == Opcodes.IALOAD || opcode == Opcodes.IASTORE) {\n            // the offset for IALOAD or IASTORE is in byte 1 of 'off' for\n            // primitive types (buf == null)\n            return opcode + (buf == null ? (off & 0xFF00) >> 8 : 4);\n        } else {\n            // the offset for other instructions is in byte 2 of 'off' for\n            // primitive types (buf == null)\n            return opcode + (buf == null ? (off & 0xFF0000) >> 16 : 4);\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Equals, hashCode and toString\n    // ------------------------------------------------------------------------\n    /**\n     * Tests if the given object is equal to this type.\n     *\n     * @param o the object to be compared to this type.\n     * @return <tt>true</tt> if the given object is equal to this type.\n     */\n    public boolean equals(final Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (!(o instanceof Type)) {\n            return false;\n        }\n        Type t = (Type) o;\n        if (sort != t.sort) {\n            return false;\n        }\n        if (sort == OBJECT || sort == ARRAY) {\n            if (len != t.len) {\n                return false;\n            }\n            for (int i = off, j = t.off, end = i + len; i < end; i++, j++) {\n                if (buf[i] != t.buf[j]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code value for this type.\n     *\n     * @return a hash code value for this type.\n     */\n    public int hashCode() {\n        int hc = 13 * sort;\n        if (sort == OBJECT || sort == ARRAY) {\n            for (int i = off, end = i + len; i < end; i++) {\n                hc = 17 * (hc + buf[i]);\n            }\n        }\n        return hc;\n    }\n\n    /**\n     * Returns a string representation of this type.\n     *\n     * @return the descriptor of this type.\n     */\n    public String toString() {\n        return getDescriptor();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/TypeTest12.java",
		"test_prompt": "// TypeTest12.java\npackage org.objectweb.asm.jip;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Type}.\n* It contains ten unit test cases for the {@link Type#getMethodDescriptor(Method)} method.\n*/\nclass TypeTest12 {"
	},
	{
		"original_code": "// Type.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\n\n/**\n * A Java type. This class can be used to make it easier to manipulate type and\n * method descriptors.\n *\n * @author Eric Bruneton\n * @author Chris Nokleberg\n */\npublic class Type {\n\n    /**\n     * The sort of the <tt>void</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int VOID = 0;\n\n    /**\n     * The sort of the <tt>boolean</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int BOOLEAN = 1;\n\n    /**\n     * The sort of the <tt>char</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int CHAR = 2;\n\n    /**\n     * The sort of the <tt>byte</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int BYTE = 3;\n\n    /**\n     * The sort of the <tt>short</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int SHORT = 4;\n\n    /**\n     * The sort of the <tt>int</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int INT = 5;\n\n    /**\n     * The sort of the <tt>float</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int FLOAT = 6;\n\n    /**\n     * The sort of the <tt>long</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int LONG = 7;\n\n    /**\n     * The sort of the <tt>double</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int DOUBLE = 8;\n\n    /**\n     * The sort of array reference types. See {@link #getSort getSort}.\n     */\n    public static final int ARRAY = 9;\n\n    /**\n     * The sort of object reference type. See {@link #getSort getSort}.\n     */\n    public static final int OBJECT = 10;\n\n    /**\n     * The <tt>void</tt> type.\n     */\n    public static final Type VOID_TYPE = new Type(VOID, null, ('V' << 24) | (5 << 16) | (0 << 8) | 0, 1);\n\n    /**\n     * The <tt>boolean</tt> type.\n     */\n    public static final Type BOOLEAN_TYPE = new Type(BOOLEAN, null, ('Z' << 24) | (0 << 16) | (5 << 8) | 1, 1);\n\n    /**\n     * The <tt>char</tt> type.\n     */\n    public static final Type CHAR_TYPE = new Type(CHAR, null, ('C' << 24) | (0 << 16) | (6 << 8) | 1, 1);\n\n    /**\n     * The <tt>byte</tt> type.\n     */\n    public static final Type BYTE_TYPE = new Type(BYTE, null, ('B' << 24) | (0 << 16) | (5 << 8) | 1, 1);\n\n    /**\n     * The <tt>short</tt> type.\n     */\n    public static final Type SHORT_TYPE = new Type(SHORT, null, ('S' << 24) | (0 << 16) | (7 << 8) | 1, 1);\n\n    /**\n     * The <tt>int</tt> type.\n     */\n    public static final Type INT_TYPE = new Type(INT, null, ('I' << 24) | (0 << 16) | (0 << 8) | 1, 1);\n\n    /**\n     * The <tt>float</tt> type.\n     */\n    public static final Type FLOAT_TYPE = new Type(FLOAT, null, ('F' << 24) | (2 << 16) | (2 << 8) | 1, 1);\n\n    /**\n     * The <tt>long</tt> type.\n     */\n    public static final Type LONG_TYPE = new Type(LONG, null, ('J' << 24) | (1 << 16) | (1 << 8) | 2, 1);\n\n    /**\n     * The <tt>double</tt> type.\n     */\n    public static final Type DOUBLE_TYPE = new Type(DOUBLE, null, ('D' << 24) | (3 << 16) | (3 << 8) | 2, 1);\n\n    // ------------------------------------------------------------------------\n    // Fields\n    // ------------------------------------------------------------------------\n    /**\n     * The sort of this Java type.\n     */\n    private final int sort;\n\n    /**\n     * A buffer containing the internal name of this Java type. This field is\n     * only used for reference types.\n     */\n    private final char[] buf;\n\n    /**\n     * The offset of the internal name of this Java type in {@link #buf buf} or,\n     * for primitive types, the size, descriptor and getOpcode offsets for this\n     * type (byte 0 contains the size, byte 1 the descriptor, byte 2 the offset\n     * for IALOAD or IASTORE, byte 3 the offset for all other instructions).\n     */\n    private final int off;\n\n    /**\n     * The length of the internal name of this Java type.\n     */\n    private final int len;\n\n    // ------------------------------------------------------------------------\n    // Constructors\n    // ------------------------------------------------------------------------\n    /**\n     * Constructs a reference type.\n     *\n     * @param sort the sort of the reference type to be constructed.\n     * @param buf a buffer containing the descriptor of the previous type.\n     * @param off the offset of this descriptor in the previous buffer.\n     * @param len the length of this descriptor.\n     */\n    private Type(final int sort, final char[] buf, final int off, final int len) {\n        this.sort = sort;\n        this.buf = buf;\n        this.off = off;\n        this.len = len;\n    }\n\n    /**\n     * Returns the Java type corresponding to the given type descriptor.\n     *\n     * @param typeDescriptor a type descriptor.\n     * @return the Java type corresponding to the given type descriptor.\n     */\n    public static Type getType(final String typeDescriptor) {\n        return getType(typeDescriptor.toCharArray(), 0);\n    }\n\n    /**\n     * Returns the Java type corresponding to the given internal name.\n     *\n     * @param internalName an internal name.\n     * @return the Java type corresponding to the given internal name.\n     */\n    public static Type getObjectType(final String internalName) {\n        char[] buf = internalName.toCharArray();\n        return new Type(buf[0] == '[' ? ARRAY : OBJECT, buf, 0, buf.length);\n    }\n\n    /**\n     * Returns the Java type corresponding to the given class.\n     *\n     * @param c a class.\n     * @return the Java type corresponding to the given class.\n     */\n    public static Type getType(final Class c) {\n        if (c.isPrimitive()) {\n            if (c == Integer.TYPE) {\n                return INT_TYPE;\n            } else if (c == Void.TYPE) {\n                return VOID_TYPE;\n            } else if (c == Boolean.TYPE) {\n                return BOOLEAN_TYPE;\n            } else if (c == Byte.TYPE) {\n                return BYTE_TYPE;\n            } else if (c == Character.TYPE) {\n                return CHAR_TYPE;\n            } else if (c == Short.TYPE) {\n                return SHORT_TYPE;\n            } else if (c == Double.TYPE) {\n                return DOUBLE_TYPE;\n            } else if (c == Float.TYPE) {\n                return FLOAT_TYPE;\n            } else /* if (c == Long.TYPE) */\n            {\n                return LONG_TYPE;\n            }\n        } else {\n            return getType(getDescriptor(c));\n        }\n    }\n\n    /**\n     * Returns the Java types corresponding to the argument types of the given\n     * method descriptor.\n     *\n     * @param methodDescriptor a method descriptor.\n     * @return the Java types corresponding to the argument types of the given\n     *         method descriptor.\n     */\n    public static Type[] getArgumentTypes(final String methodDescriptor) {\n        char[] buf = methodDescriptor.toCharArray();\n        int off = 1;\n        int size = 0;\n        while (true) {\n            char car = buf[off++];\n            if (car == ')') {\n                break;\n            } else if (car == 'L') {\n                while (buf[off++] != ';') {\n                }\n                ++size;\n            } else if (car != '[') {\n                ++size;\n            }\n        }\n        Type[] args = new Type[size];\n        off = 1;\n        size = 0;\n        while (buf[off] != ')') {\n            args[size] = getType(buf, off);\n            off += args[size].len + (args[size].sort == OBJECT ? 2 : 0);\n            size += 1;\n        }\n        return args;\n    }\n\n    /**\n     * Returns the Java types corresponding to the argument types of the given\n     * method.\n     *\n     * @param method a method.\n     * @return the Java types corresponding to the argument types of the given\n     *         method.\n     */\n    public static Type[] getArgumentTypes(final Method method) {\n        Class[] classes = method.getParameterTypes();\n        Type[] types = new Type[classes.length];\n        for (int i = classes.length - 1; i >= 0; --i) {\n            types[i] = getType(classes[i]);\n        }\n        return types;\n    }\n\n    /**\n     * Returns the Java type corresponding to the return type of the given\n     * method descriptor.\n     *\n     * @param methodDescriptor a method descriptor.\n     * @return the Java type corresponding to the return type of the given\n     *         method descriptor.\n     */\n    public static Type getReturnType(final String methodDescriptor) {\n        char[] buf = methodDescriptor.toCharArray();\n        return getType(buf, methodDescriptor.indexOf(')') + 1);\n    }\n\n    /**\n     * Returns the Java type corresponding to the return type of the given\n     * method.\n     *\n     * @param method a method.\n     * @return the Java type corresponding to the return type of the given\n     *         method.\n     */\n    public static Type getReturnType(final Method method) {\n        return getType(method.getReturnType());\n    }\n\n    /**\n     * Computes the size of the arguments and of the return value of a method.\n     *\n     * @param desc the descriptor of a method.\n     * @return the size of the arguments of the method (plus one for the\n     *         implicit this argument), argSize, and the size of its return\n     *         value, retSize, packed into a single int i =\n     *         <tt>(argSize << 2) | retSize</tt> (argSize is therefore equal\n     *         to <tt>i >> 2</tt>, and retSize to <tt>i & 0x03</tt>).\n     */\n    public static int getArgumentsAndReturnSizes(final String desc) {\n        int n = 1;\n        int c = 1;\n        while (true) {\n            char car = desc.charAt(c++);\n            if (car == ')') {\n                car = desc.charAt(c);\n                return n << 2 | (car == 'V' ? 0 : (car == 'D' || car == 'J' ? 2 : 1));\n            } else if (car == 'L') {\n                while (desc.charAt(c++) != ';') {\n                }\n                n += 1;\n            } else if (car == '[') {\n                while ((car = desc.charAt(c)) == '[') {\n                    ++c;\n                }\n                if (car == 'D' || car == 'J') {\n                    n -= 1;\n                }\n            } else if (car == 'D' || car == 'J') {\n                n += 2;\n            } else {\n                n += 1;\n            }\n        }\n    }\n\n    /**\n     * Returns the Java type corresponding to the given type descriptor.\n     *\n     * @param buf a buffer containing a type descriptor.\n     * @param off the offset of this descriptor in the previous buffer.\n     * @return the Java type corresponding to the given type descriptor.\n     */\n    private static Type getType(final char[] buf, final int off) {\n        int len;\n        switch(buf[off]) {\n            case 'V':\n                return VOID_TYPE;\n            case 'Z':\n                return BOOLEAN_TYPE;\n            case 'C':\n                return CHAR_TYPE;\n            case 'B':\n                return BYTE_TYPE;\n            case 'S':\n                return SHORT_TYPE;\n            case 'I':\n                return INT_TYPE;\n            case 'F':\n                return FLOAT_TYPE;\n            case 'J':\n                return LONG_TYPE;\n            case 'D':\n                return DOUBLE_TYPE;\n            case '[':\n                len = 1;\n                while (buf[off + len] == '[') {\n                    ++len;\n                }\n                if (buf[off + len] == 'L') {\n                    ++len;\n                    while (buf[off + len] != ';') {\n                        ++len;\n                    }\n                }\n                return new Type(ARRAY, buf, off, len + 1);\n            // case 'L':\n            default:\n                len = 1;\n                while (buf[off + len] != ';') {\n                    ++len;\n                }\n                return new Type(OBJECT, buf, off + 1, len - 1);\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Accessors\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the sort of this Java type.\n     *\n     * @return {@link #VOID VOID}, {@link #BOOLEAN BOOLEAN},\n     *         {@link #CHAR CHAR}, {@link #BYTE BYTE}, {@link #SHORT SHORT},\n     *         {@link #INT INT}, {@link #FLOAT FLOAT}, {@link #LONG LONG},\n     *         {@link #DOUBLE DOUBLE}, {@link #ARRAY ARRAY} or\n     *         {@link #OBJECT OBJECT}.\n     */\n    public int getSort() {\n        return sort;\n    }\n\n    /**\n     * Returns the number of dimensions of this array type. This method should\n     * only be used for an array type.\n     *\n     * @return the number of dimensions of this array type.\n     */\n    public int getDimensions() {\n        int i = 1;\n        while (buf[off + i] == '[') {\n            ++i;\n        }\n        return i;\n    }\n\n    /**\n     * Returns the type of the elements of this array type. This method should\n     * only be used for an array type.\n     *\n     * @return Returns the type of the elements of this array type.\n     */\n    public Type getElementType() {\n        return getType(buf, off + getDimensions());\n    }\n\n    /**\n     * Returns the name of the class corresponding to this type.\n     *\n     * @return the fully qualified name of the class corresponding to this type.\n     */\n    public String getClassName() {\n        switch(sort) {\n            case VOID:\n                return \"void\";\n            case BOOLEAN:\n                return \"boolean\";\n            case CHAR:\n                return \"char\";\n            case BYTE:\n                return \"byte\";\n            case SHORT:\n                return \"short\";\n            case INT:\n                return \"int\";\n            case FLOAT:\n                return \"float\";\n            case LONG:\n                return \"long\";\n            case DOUBLE:\n                return \"double\";\n            case ARRAY:\n                StringBuffer b = new StringBuffer(getElementType().getClassName());\n                for (int i = getDimensions(); i > 0; --i) {\n                    b.append(\"[]\");\n                }\n                return b.toString();\n            // case OBJECT:\n            default:\n                return new String(buf, off, len).replace('/', '.');\n        }\n    }\n\n    /**\n     * Returns the internal name of the class corresponding to this object or\n     * array type. The internal name of a class is its fully qualified name (as\n     * returned by Class.getName(), where '.' are replaced by '/'. This method\n     * should only be used for an object or array type.\n     *\n     * @return the internal name of the class corresponding to this object type.\n     */\n    public String getInternalName() {\n        return new String(buf, off, len);\n    }\n\n    // ------------------------------------------------------------------------\n    // Conversion to type descriptors\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the descriptor corresponding to this Java type.\n     *\n     * @return the descriptor corresponding to this Java type.\n     */\n    public String getDescriptor() {\n        StringBuffer buf = new StringBuffer();\n        getDescriptor(buf);\n        return buf.toString();\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given argument and return\n     * types.\n     *\n     * @param returnType the return type of the method.\n     * @param argumentTypes the argument types of the method.\n     * @return the descriptor corresponding to the given argument and return\n     *         types.\n     */\n    public static String getMethodDescriptor(final Type returnType, final Type[] argumentTypes) {\n        StringBuffer buf = new StringBuffer();\n        buf.append('(');\n        for (int i = 0; i < argumentTypes.length; ++i) {\n            argumentTypes[i].getDescriptor(buf);\n        }\n        buf.append(')');\n        returnType.getDescriptor(buf);\n        return buf.toString();\n    }\n\n    /**\n     * Appends the descriptor corresponding to this Java type to the given\n     * string buffer.\n     *\n     * @param buf the string buffer to which the descriptor must be appended.\n     */\n    private void getDescriptor(final StringBuffer buf) {\n        if (this.buf == null) {\n            // descriptor is in byte 3 of 'off' for primitive types (buf == null)\n            buf.append((char) ((off & 0xFF000000) >>> 24));\n        } else if (sort == ARRAY) {\n            buf.append(this.buf, off, len);\n        } else {\n            // sort == OBJECT\n            buf.append('L');\n            buf.append(this.buf, off, len);\n            buf.append(';');\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Direct conversion from classes to type descriptors,\n    // without intermediate Type objects\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the internal name of the given class. The internal name of a\n     * class is its fully qualified name, as returned by Class.getName(), where\n     * '.' are replaced by '/'.\n     *\n     * @param c an object or array class.\n     * @return the internal name of the given class.\n     */\n    public static String getInternalName(final Class c) {\n        return c.getName().replace('.', '/');\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given Java type.\n     *\n     * @param c an object class, a primitive class or an array class.\n     * @return the descriptor corresponding to the given class.\n     */\n    public static String getDescriptor(final Class c) {\n        StringBuffer buf = new StringBuffer();\n        getDescriptor(buf, c);\n        return buf.toString();\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given constructor.\n     *\n     * @param c a {@link Constructor Constructor} object.\n     * @return the descriptor of the given constructor.\n     */\n    public static String getConstructorDescriptor(final Constructor c) {\n        Class[] parameters = c.getParameterTypes();\n        StringBuffer buf = new StringBuffer();\n        buf.append('(');\n        for (int i = 0; i < parameters.length; ++i) {\n            getDescriptor(buf, parameters[i]);\n        }\n        return buf.append(\")V\").toString();\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given method.\n     *\n     * @param m a {@link Method Method} object.\n     * @return the descriptor of the given method.\n     */\n    public static String getMethodDescriptor(final Method m) {\n        Class[] parameters = m.getParameterTypes();\n        StringBuffer buf = new StringBuffer();\n        buf.append('(');\n        for (int i = 0; i < parameters.length; ++i) {\n            getDescriptor(buf, parameters[i]);\n        }\n        buf.append(')');\n        getDescriptor(buf, m.getReturnType());\n        return buf.toString();\n    }\n\n    /**\n     * Appends the descriptor of the given class to the given string buffer.\n     *\n     * @param buf the string buffer to which the descriptor must be appended.\n     * @param c the class whose descriptor must be computed.\n     */\n    private static void getDescriptor(final StringBuffer buf, final Class c) {\n        Class d = c;\n        while (true) {\n            if (d.isPrimitive()) {\n                char car;\n                if (d == Integer.TYPE) {\n                    car = 'I';\n                } else if (d == Void.TYPE) {\n                    car = 'V';\n                } else if (d == Boolean.TYPE) {\n                    car = 'Z';\n                } else if (d == Byte.TYPE) {\n                    car = 'B';\n                } else if (d == Character.TYPE) {\n                    car = 'C';\n                } else if (d == Short.TYPE) {\n                    car = 'S';\n                } else if (d == Double.TYPE) {\n                    car = 'D';\n                } else if (d == Float.TYPE) {\n                    car = 'F';\n                } else /* if (d == Long.TYPE) */\n                {\n                    car = 'J';\n                }\n                buf.append(car);\n                return;\n            } else if (d.isArray()) {\n                buf.append('[');\n                d = d.getComponentType();\n            } else {\n                buf.append('L');\n                String name = d.getName();\n                int len = name.length();\n                for (int i = 0; i < len; ++i) {\n                    char car = name.charAt(i);\n                    buf.append(car == '.' ? '/' : car);\n                }\n                buf.append(';');\n                return;\n            }\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Corresponding size and opcodes\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the size of values of this type.\n     *\n     * @return the size of values of this type, i.e., 2 for <tt>long</tt> and\n     *         <tt>double</tt>, 0 for <tt>void</tt> and 1 otherwise.\n     */\n    public int getSize() {\n        // the size is in byte 0 of 'off' for primitive types (buf == null)\n        return buf == null ? (off & 0xFF) : 1;\n    }\n\n    /**\n     * Returns a JVM instruction opcode adapted to this Java type.\n     *\n     * @param opcode a JVM instruction opcode. This opcode must be one of ILOAD,\n     *        ISTORE, IALOAD, IASTORE, IADD, ISUB, IMUL, IDIV, IREM, INEG, ISHL,\n     *        ISHR, IUSHR, IAND, IOR, IXOR and IRETURN.\n     * @return an opcode that is similar to the given opcode, but adapted to\n     *         this Java type. For example, if this type is <tt>float</tt> and\n     *         <tt>opcode</tt> is IRETURN, this method returns FRETURN.\n     */\n    public int getOpcode(final int opcode) {\n        if (opcode == Opcodes.IALOAD || opcode == Opcodes.IASTORE) {\n            // the offset for IALOAD or IASTORE is in byte 1 of 'off' for\n            // primitive types (buf == null)\n            return opcode + (buf == null ? (off & 0xFF00) >> 8 : 4);\n        } else {\n            // the offset for other instructions is in byte 2 of 'off' for\n            // primitive types (buf == null)\n            return opcode + (buf == null ? (off & 0xFF0000) >> 16 : 4);\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Equals, hashCode and toString\n    // ------------------------------------------------------------------------\n    /**\n     * Tests if the given object is equal to this type.\n     *\n     * @param o the object to be compared to this type.\n     * @return <tt>true</tt> if the given object is equal to this type.\n     */\n    public boolean equals(final Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (!(o instanceof Type)) {\n            return false;\n        }\n        Type t = (Type) o;\n        if (sort != t.sort) {\n            return false;\n        }\n        if (sort == OBJECT || sort == ARRAY) {\n            if (len != t.len) {\n                return false;\n            }\n            for (int i = off, j = t.off, end = i + len; i < end; i++, j++) {\n                if (buf[i] != t.buf[j]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code value for this type.\n     *\n     * @return a hash code value for this type.\n     */\n    public int hashCode() {\n        int hc = 13 * sort;\n        if (sort == OBJECT || sort == ARRAY) {\n            for (int i = off, end = i + len; i < end; i++) {\n                hc = 17 * (hc + buf[i]);\n            }\n        }\n        return hc;\n    }\n\n    /**\n     * Returns a string representation of this type.\n     *\n     * @return the descriptor of this type.\n     */\n    public String toString() {\n        return getDescriptor();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/TypeTest13.java",
		"test_prompt": "// TypeTest13.java\npackage org.objectweb.asm.jip;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Type}.\n* It contains ten unit test cases for the {@link Type#equals(Object)} method.\n*/\nclass TypeTest13 {"
	},
	{
		"original_code": "// Type.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\n\n/**\n * A Java type. This class can be used to make it easier to manipulate type and\n * method descriptors.\n *\n * @author Eric Bruneton\n * @author Chris Nokleberg\n */\npublic class Type {\n\n    /**\n     * The sort of the <tt>void</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int VOID = 0;\n\n    /**\n     * The sort of the <tt>boolean</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int BOOLEAN = 1;\n\n    /**\n     * The sort of the <tt>char</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int CHAR = 2;\n\n    /**\n     * The sort of the <tt>byte</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int BYTE = 3;\n\n    /**\n     * The sort of the <tt>short</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int SHORT = 4;\n\n    /**\n     * The sort of the <tt>int</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int INT = 5;\n\n    /**\n     * The sort of the <tt>float</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int FLOAT = 6;\n\n    /**\n     * The sort of the <tt>long</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int LONG = 7;\n\n    /**\n     * The sort of the <tt>double</tt> type. See {@link #getSort getSort}.\n     */\n    public static final int DOUBLE = 8;\n\n    /**\n     * The sort of array reference types. See {@link #getSort getSort}.\n     */\n    public static final int ARRAY = 9;\n\n    /**\n     * The sort of object reference type. See {@link #getSort getSort}.\n     */\n    public static final int OBJECT = 10;\n\n    /**\n     * The <tt>void</tt> type.\n     */\n    public static final Type VOID_TYPE = new Type(VOID, null, ('V' << 24) | (5 << 16) | (0 << 8) | 0, 1);\n\n    /**\n     * The <tt>boolean</tt> type.\n     */\n    public static final Type BOOLEAN_TYPE = new Type(BOOLEAN, null, ('Z' << 24) | (0 << 16) | (5 << 8) | 1, 1);\n\n    /**\n     * The <tt>char</tt> type.\n     */\n    public static final Type CHAR_TYPE = new Type(CHAR, null, ('C' << 24) | (0 << 16) | (6 << 8) | 1, 1);\n\n    /**\n     * The <tt>byte</tt> type.\n     */\n    public static final Type BYTE_TYPE = new Type(BYTE, null, ('B' << 24) | (0 << 16) | (5 << 8) | 1, 1);\n\n    /**\n     * The <tt>short</tt> type.\n     */\n    public static final Type SHORT_TYPE = new Type(SHORT, null, ('S' << 24) | (0 << 16) | (7 << 8) | 1, 1);\n\n    /**\n     * The <tt>int</tt> type.\n     */\n    public static final Type INT_TYPE = new Type(INT, null, ('I' << 24) | (0 << 16) | (0 << 8) | 1, 1);\n\n    /**\n     * The <tt>float</tt> type.\n     */\n    public static final Type FLOAT_TYPE = new Type(FLOAT, null, ('F' << 24) | (2 << 16) | (2 << 8) | 1, 1);\n\n    /**\n     * The <tt>long</tt> type.\n     */\n    public static final Type LONG_TYPE = new Type(LONG, null, ('J' << 24) | (1 << 16) | (1 << 8) | 2, 1);\n\n    /**\n     * The <tt>double</tt> type.\n     */\n    public static final Type DOUBLE_TYPE = new Type(DOUBLE, null, ('D' << 24) | (3 << 16) | (3 << 8) | 2, 1);\n\n    // ------------------------------------------------------------------------\n    // Fields\n    // ------------------------------------------------------------------------\n    /**\n     * The sort of this Java type.\n     */\n    private final int sort;\n\n    /**\n     * A buffer containing the internal name of this Java type. This field is\n     * only used for reference types.\n     */\n    private final char[] buf;\n\n    /**\n     * The offset of the internal name of this Java type in {@link #buf buf} or,\n     * for primitive types, the size, descriptor and getOpcode offsets for this\n     * type (byte 0 contains the size, byte 1 the descriptor, byte 2 the offset\n     * for IALOAD or IASTORE, byte 3 the offset for all other instructions).\n     */\n    private final int off;\n\n    /**\n     * The length of the internal name of this Java type.\n     */\n    private final int len;\n\n    // ------------------------------------------------------------------------\n    // Constructors\n    // ------------------------------------------------------------------------\n    /**\n     * Constructs a reference type.\n     *\n     * @param sort the sort of the reference type to be constructed.\n     * @param buf a buffer containing the descriptor of the previous type.\n     * @param off the offset of this descriptor in the previous buffer.\n     * @param len the length of this descriptor.\n     */\n    private Type(final int sort, final char[] buf, final int off, final int len) {\n        this.sort = sort;\n        this.buf = buf;\n        this.off = off;\n        this.len = len;\n    }\n\n    /**\n     * Returns the Java type corresponding to the given type descriptor.\n     *\n     * @param typeDescriptor a type descriptor.\n     * @return the Java type corresponding to the given type descriptor.\n     */\n    public static Type getType(final String typeDescriptor) {\n        return getType(typeDescriptor.toCharArray(), 0);\n    }\n\n    /**\n     * Returns the Java type corresponding to the given internal name.\n     *\n     * @param internalName an internal name.\n     * @return the Java type corresponding to the given internal name.\n     */\n    public static Type getObjectType(final String internalName) {\n        char[] buf = internalName.toCharArray();\n        return new Type(buf[0] == '[' ? ARRAY : OBJECT, buf, 0, buf.length);\n    }\n\n    /**\n     * Returns the Java type corresponding to the given class.\n     *\n     * @param c a class.\n     * @return the Java type corresponding to the given class.\n     */\n    public static Type getType(final Class c) {\n        if (c.isPrimitive()) {\n            if (c == Integer.TYPE) {\n                return INT_TYPE;\n            } else if (c == Void.TYPE) {\n                return VOID_TYPE;\n            } else if (c == Boolean.TYPE) {\n                return BOOLEAN_TYPE;\n            } else if (c == Byte.TYPE) {\n                return BYTE_TYPE;\n            } else if (c == Character.TYPE) {\n                return CHAR_TYPE;\n            } else if (c == Short.TYPE) {\n                return SHORT_TYPE;\n            } else if (c == Double.TYPE) {\n                return DOUBLE_TYPE;\n            } else if (c == Float.TYPE) {\n                return FLOAT_TYPE;\n            } else /* if (c == Long.TYPE) */\n            {\n                return LONG_TYPE;\n            }\n        } else {\n            return getType(getDescriptor(c));\n        }\n    }\n\n    /**\n     * Returns the Java types corresponding to the argument types of the given\n     * method descriptor.\n     *\n     * @param methodDescriptor a method descriptor.\n     * @return the Java types corresponding to the argument types of the given\n     *         method descriptor.\n     */\n    public static Type[] getArgumentTypes(final String methodDescriptor) {\n        char[] buf = methodDescriptor.toCharArray();\n        int off = 1;\n        int size = 0;\n        while (true) {\n            char car = buf[off++];\n            if (car == ')') {\n                break;\n            } else if (car == 'L') {\n                while (buf[off++] != ';') {\n                }\n                ++size;\n            } else if (car != '[') {\n                ++size;\n            }\n        }\n        Type[] args = new Type[size];\n        off = 1;\n        size = 0;\n        while (buf[off] != ')') {\n            args[size] = getType(buf, off);\n            off += args[size].len + (args[size].sort == OBJECT ? 2 : 0);\n            size += 1;\n        }\n        return args;\n    }\n\n    /**\n     * Returns the Java types corresponding to the argument types of the given\n     * method.\n     *\n     * @param method a method.\n     * @return the Java types corresponding to the argument types of the given\n     *         method.\n     */\n    public static Type[] getArgumentTypes(final Method method) {\n        Class[] classes = method.getParameterTypes();\n        Type[] types = new Type[classes.length];\n        for (int i = classes.length - 1; i >= 0; --i) {\n            types[i] = getType(classes[i]);\n        }\n        return types;\n    }\n\n    /**\n     * Returns the Java type corresponding to the return type of the given\n     * method descriptor.\n     *\n     * @param methodDescriptor a method descriptor.\n     * @return the Java type corresponding to the return type of the given\n     *         method descriptor.\n     */\n    public static Type getReturnType(final String methodDescriptor) {\n        char[] buf = methodDescriptor.toCharArray();\n        return getType(buf, methodDescriptor.indexOf(')') + 1);\n    }\n\n    /**\n     * Returns the Java type corresponding to the return type of the given\n     * method.\n     *\n     * @param method a method.\n     * @return the Java type corresponding to the return type of the given\n     *         method.\n     */\n    public static Type getReturnType(final Method method) {\n        return getType(method.getReturnType());\n    }\n\n    /**\n     * Computes the size of the arguments and of the return value of a method.\n     *\n     * @param desc the descriptor of a method.\n     * @return the size of the arguments of the method (plus one for the\n     *         implicit this argument), argSize, and the size of its return\n     *         value, retSize, packed into a single int i =\n     *         <tt>(argSize << 2) | retSize</tt> (argSize is therefore equal\n     *         to <tt>i >> 2</tt>, and retSize to <tt>i & 0x03</tt>).\n     */\n    public static int getArgumentsAndReturnSizes(final String desc) {\n        int n = 1;\n        int c = 1;\n        while (true) {\n            char car = desc.charAt(c++);\n            if (car == ')') {\n                car = desc.charAt(c);\n                return n << 2 | (car == 'V' ? 0 : (car == 'D' || car == 'J' ? 2 : 1));\n            } else if (car == 'L') {\n                while (desc.charAt(c++) != ';') {\n                }\n                n += 1;\n            } else if (car == '[') {\n                while ((car = desc.charAt(c)) == '[') {\n                    ++c;\n                }\n                if (car == 'D' || car == 'J') {\n                    n -= 1;\n                }\n            } else if (car == 'D' || car == 'J') {\n                n += 2;\n            } else {\n                n += 1;\n            }\n        }\n    }\n\n    /**\n     * Returns the Java type corresponding to the given type descriptor.\n     *\n     * @param buf a buffer containing a type descriptor.\n     * @param off the offset of this descriptor in the previous buffer.\n     * @return the Java type corresponding to the given type descriptor.\n     */\n    private static Type getType(final char[] buf, final int off) {\n        int len;\n        switch(buf[off]) {\n            case 'V':\n                return VOID_TYPE;\n            case 'Z':\n                return BOOLEAN_TYPE;\n            case 'C':\n                return CHAR_TYPE;\n            case 'B':\n                return BYTE_TYPE;\n            case 'S':\n                return SHORT_TYPE;\n            case 'I':\n                return INT_TYPE;\n            case 'F':\n                return FLOAT_TYPE;\n            case 'J':\n                return LONG_TYPE;\n            case 'D':\n                return DOUBLE_TYPE;\n            case '[':\n                len = 1;\n                while (buf[off + len] == '[') {\n                    ++len;\n                }\n                if (buf[off + len] == 'L') {\n                    ++len;\n                    while (buf[off + len] != ';') {\n                        ++len;\n                    }\n                }\n                return new Type(ARRAY, buf, off, len + 1);\n            // case 'L':\n            default:\n                len = 1;\n                while (buf[off + len] != ';') {\n                    ++len;\n                }\n                return new Type(OBJECT, buf, off + 1, len - 1);\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Accessors\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the sort of this Java type.\n     *\n     * @return {@link #VOID VOID}, {@link #BOOLEAN BOOLEAN},\n     *         {@link #CHAR CHAR}, {@link #BYTE BYTE}, {@link #SHORT SHORT},\n     *         {@link #INT INT}, {@link #FLOAT FLOAT}, {@link #LONG LONG},\n     *         {@link #DOUBLE DOUBLE}, {@link #ARRAY ARRAY} or\n     *         {@link #OBJECT OBJECT}.\n     */\n    public int getSort() {\n        return sort;\n    }\n\n    /**\n     * Returns the number of dimensions of this array type. This method should\n     * only be used for an array type.\n     *\n     * @return the number of dimensions of this array type.\n     */\n    public int getDimensions() {\n        int i = 1;\n        while (buf[off + i] == '[') {\n            ++i;\n        }\n        return i;\n    }\n\n    /**\n     * Returns the type of the elements of this array type. This method should\n     * only be used for an array type.\n     *\n     * @return Returns the type of the elements of this array type.\n     */\n    public Type getElementType() {\n        return getType(buf, off + getDimensions());\n    }\n\n    /**\n     * Returns the name of the class corresponding to this type.\n     *\n     * @return the fully qualified name of the class corresponding to this type.\n     */\n    public String getClassName() {\n        switch(sort) {\n            case VOID:\n                return \"void\";\n            case BOOLEAN:\n                return \"boolean\";\n            case CHAR:\n                return \"char\";\n            case BYTE:\n                return \"byte\";\n            case SHORT:\n                return \"short\";\n            case INT:\n                return \"int\";\n            case FLOAT:\n                return \"float\";\n            case LONG:\n                return \"long\";\n            case DOUBLE:\n                return \"double\";\n            case ARRAY:\n                StringBuffer b = new StringBuffer(getElementType().getClassName());\n                for (int i = getDimensions(); i > 0; --i) {\n                    b.append(\"[]\");\n                }\n                return b.toString();\n            // case OBJECT:\n            default:\n                return new String(buf, off, len).replace('/', '.');\n        }\n    }\n\n    /**\n     * Returns the internal name of the class corresponding to this object or\n     * array type. The internal name of a class is its fully qualified name (as\n     * returned by Class.getName(), where '.' are replaced by '/'. This method\n     * should only be used for an object or array type.\n     *\n     * @return the internal name of the class corresponding to this object type.\n     */\n    public String getInternalName() {\n        return new String(buf, off, len);\n    }\n\n    // ------------------------------------------------------------------------\n    // Conversion to type descriptors\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the descriptor corresponding to this Java type.\n     *\n     * @return the descriptor corresponding to this Java type.\n     */\n    public String getDescriptor() {\n        StringBuffer buf = new StringBuffer();\n        getDescriptor(buf);\n        return buf.toString();\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given argument and return\n     * types.\n     *\n     * @param returnType the return type of the method.\n     * @param argumentTypes the argument types of the method.\n     * @return the descriptor corresponding to the given argument and return\n     *         types.\n     */\n    public static String getMethodDescriptor(final Type returnType, final Type[] argumentTypes) {\n        StringBuffer buf = new StringBuffer();\n        buf.append('(');\n        for (int i = 0; i < argumentTypes.length; ++i) {\n            argumentTypes[i].getDescriptor(buf);\n        }\n        buf.append(')');\n        returnType.getDescriptor(buf);\n        return buf.toString();\n    }\n\n    /**\n     * Appends the descriptor corresponding to this Java type to the given\n     * string buffer.\n     *\n     * @param buf the string buffer to which the descriptor must be appended.\n     */\n    private void getDescriptor(final StringBuffer buf) {\n        if (this.buf == null) {\n            // descriptor is in byte 3 of 'off' for primitive types (buf == null)\n            buf.append((char) ((off & 0xFF000000) >>> 24));\n        } else if (sort == ARRAY) {\n            buf.append(this.buf, off, len);\n        } else {\n            // sort == OBJECT\n            buf.append('L');\n            buf.append(this.buf, off, len);\n            buf.append(';');\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Direct conversion from classes to type descriptors,\n    // without intermediate Type objects\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the internal name of the given class. The internal name of a\n     * class is its fully qualified name, as returned by Class.getName(), where\n     * '.' are replaced by '/'.\n     *\n     * @param c an object or array class.\n     * @return the internal name of the given class.\n     */\n    public static String getInternalName(final Class c) {\n        return c.getName().replace('.', '/');\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given Java type.\n     *\n     * @param c an object class, a primitive class or an array class.\n     * @return the descriptor corresponding to the given class.\n     */\n    public static String getDescriptor(final Class c) {\n        StringBuffer buf = new StringBuffer();\n        getDescriptor(buf, c);\n        return buf.toString();\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given constructor.\n     *\n     * @param c a {@link Constructor Constructor} object.\n     * @return the descriptor of the given constructor.\n     */\n    public static String getConstructorDescriptor(final Constructor c) {\n        Class[] parameters = c.getParameterTypes();\n        StringBuffer buf = new StringBuffer();\n        buf.append('(');\n        for (int i = 0; i < parameters.length; ++i) {\n            getDescriptor(buf, parameters[i]);\n        }\n        return buf.append(\")V\").toString();\n    }\n\n    /**\n     * Returns the descriptor corresponding to the given method.\n     *\n     * @param m a {@link Method Method} object.\n     * @return the descriptor of the given method.\n     */\n    public static String getMethodDescriptor(final Method m) {\n        Class[] parameters = m.getParameterTypes();\n        StringBuffer buf = new StringBuffer();\n        buf.append('(');\n        for (int i = 0; i < parameters.length; ++i) {\n            getDescriptor(buf, parameters[i]);\n        }\n        buf.append(')');\n        getDescriptor(buf, m.getReturnType());\n        return buf.toString();\n    }\n\n    /**\n     * Appends the descriptor of the given class to the given string buffer.\n     *\n     * @param buf the string buffer to which the descriptor must be appended.\n     * @param c the class whose descriptor must be computed.\n     */\n    private static void getDescriptor(final StringBuffer buf, final Class c) {\n        Class d = c;\n        while (true) {\n            if (d.isPrimitive()) {\n                char car;\n                if (d == Integer.TYPE) {\n                    car = 'I';\n                } else if (d == Void.TYPE) {\n                    car = 'V';\n                } else if (d == Boolean.TYPE) {\n                    car = 'Z';\n                } else if (d == Byte.TYPE) {\n                    car = 'B';\n                } else if (d == Character.TYPE) {\n                    car = 'C';\n                } else if (d == Short.TYPE) {\n                    car = 'S';\n                } else if (d == Double.TYPE) {\n                    car = 'D';\n                } else if (d == Float.TYPE) {\n                    car = 'F';\n                } else /* if (d == Long.TYPE) */\n                {\n                    car = 'J';\n                }\n                buf.append(car);\n                return;\n            } else if (d.isArray()) {\n                buf.append('[');\n                d = d.getComponentType();\n            } else {\n                buf.append('L');\n                String name = d.getName();\n                int len = name.length();\n                for (int i = 0; i < len; ++i) {\n                    char car = name.charAt(i);\n                    buf.append(car == '.' ? '/' : car);\n                }\n                buf.append(';');\n                return;\n            }\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Corresponding size and opcodes\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the size of values of this type.\n     *\n     * @return the size of values of this type, i.e., 2 for <tt>long</tt> and\n     *         <tt>double</tt>, 0 for <tt>void</tt> and 1 otherwise.\n     */\n    public int getSize() {\n        // the size is in byte 0 of 'off' for primitive types (buf == null)\n        return buf == null ? (off & 0xFF) : 1;\n    }\n\n    /**\n     * Returns a JVM instruction opcode adapted to this Java type.\n     *\n     * @param opcode a JVM instruction opcode. This opcode must be one of ILOAD,\n     *        ISTORE, IALOAD, IASTORE, IADD, ISUB, IMUL, IDIV, IREM, INEG, ISHL,\n     *        ISHR, IUSHR, IAND, IOR, IXOR and IRETURN.\n     * @return an opcode that is similar to the given opcode, but adapted to\n     *         this Java type. For example, if this type is <tt>float</tt> and\n     *         <tt>opcode</tt> is IRETURN, this method returns FRETURN.\n     */\n    public int getOpcode(final int opcode) {\n        if (opcode == Opcodes.IALOAD || opcode == Opcodes.IASTORE) {\n            // the offset for IALOAD or IASTORE is in byte 1 of 'off' for\n            // primitive types (buf == null)\n            return opcode + (buf == null ? (off & 0xFF00) >> 8 : 4);\n        } else {\n            // the offset for other instructions is in byte 2 of 'off' for\n            // primitive types (buf == null)\n            return opcode + (buf == null ? (off & 0xFF0000) >> 16 : 4);\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Equals, hashCode and toString\n    // ------------------------------------------------------------------------\n    /**\n     * Tests if the given object is equal to this type.\n     *\n     * @param o the object to be compared to this type.\n     * @return <tt>true</tt> if the given object is equal to this type.\n     */\n    public boolean equals(final Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (!(o instanceof Type)) {\n            return false;\n        }\n        Type t = (Type) o;\n        if (sort != t.sort) {\n            return false;\n        }\n        if (sort == OBJECT || sort == ARRAY) {\n            if (len != t.len) {\n                return false;\n            }\n            for (int i = off, j = t.off, end = i + len; i < end; i++, j++) {\n                if (buf[i] != t.buf[j]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code value for this type.\n     *\n     * @return a hash code value for this type.\n     */\n    public int hashCode() {\n        int hc = 13 * sort;\n        if (sort == OBJECT || sort == ARRAY) {\n            for (int i = off, end = i + len; i < end; i++) {\n                hc = 17 * (hc + buf[i]);\n            }\n        }\n        return hc;\n    }\n\n    /**\n     * Returns a string representation of this type.\n     *\n     * @return the descriptor of this type.\n     */\n    public String toString() {\n        return getDescriptor();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/TypeTest14.java",
		"test_prompt": "// TypeTest14.java\npackage org.objectweb.asm.jip;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Type}.\n* It contains ten unit test cases for the {@link Type#hashCode()} method.\n*/\nclass TypeTest14 {"
	},
	{
		"original_code": "// Method.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip.commons;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.objectweb.asm.jip.Type;\n\n/**\n * A named method descriptor.\n *\n * @author Juozas Baliuka\n * @author Chris Nokleberg\n * @author Eric Bruneton\n */\npublic class Method {\n\n    /**\n     * The method name.\n     */\n    private final String name;\n\n    /**\n     * The method descriptor.\n     */\n    private final String desc;\n\n    /**\n     * Maps primitive Java type names to their descriptors.\n     */\n    private static final Map DESCRIPTORS;\n\n    static {\n        DESCRIPTORS = new HashMap();\n        DESCRIPTORS.put(\"void\", \"V\");\n        DESCRIPTORS.put(\"byte\", \"B\");\n        DESCRIPTORS.put(\"char\", \"C\");\n        DESCRIPTORS.put(\"double\", \"D\");\n        DESCRIPTORS.put(\"float\", \"F\");\n        DESCRIPTORS.put(\"int\", \"I\");\n        DESCRIPTORS.put(\"long\", \"J\");\n        DESCRIPTORS.put(\"short\", \"S\");\n        DESCRIPTORS.put(\"boolean\", \"Z\");\n    }\n\n    /**\n     * Creates a new {@link Method}.\n     *\n     * @param name the method's name.\n     * @param desc the method's descriptor.\n     */\n    public Method(final String name, final String desc) {\n        this.name = name;\n        this.desc = desc;\n    }\n\n    /**\n     * Creates a new {@link Method}.\n     *\n     * @param name the method's name.\n     * @param returnType the method's return type.\n     * @param argumentTypes the method's argument types.\n     */\n    public Method(final String name, final Type returnType, final Type[] argumentTypes) {\n        this(name, Type.getMethodDescriptor(returnType, argumentTypes));\n    }\n\n    /**\n     * Creates a new {@link Method}.\n     *\n     * @param m a java.lang.reflect method descriptor\n     * @return a {@link Method} corresponding to the given Java method\n     *         declaration.\n     */\n    public static Method getMethod(java.lang.reflect.Method m) {\n        return new Method(m.getName(), Type.getMethodDescriptor(m));\n    }\n\n    /**\n     * Creates a new {@link Method}.\n     *\n     * @param c a java.lang.reflect constructor descriptor\n     * @return a {@link Method} corresponding to the given Java constructor\n     *         declaration.\n     */\n    public static Method getMethod(java.lang.reflect.Constructor c) {\n        return new Method(\"<init>\", Type.getConstructorDescriptor(c));\n    }\n\n    /**\n     * Returns a {@link Method} corresponding to the given Java method\n     * declaration.\n     *\n     * @param method a Java method declaration, without argument names, of the\n     *        form \"returnType name (argumentType1, ... argumentTypeN)\", where\n     *        the types are in plain Java (e.g. \"int\", \"float\",\n     *        \"java.util.List\", ...). Classes of the java.lang package can be\n     *        specified by their unqualified name; all other classes names must\n     *        be fully qualified.\n     * @return a {@link Method} corresponding to the given Java method\n     *         declaration.\n     * @throws IllegalArgumentException if <code>method</code> could not get\n     *         parsed.\n     */\n    public static Method getMethod(final String method) throws IllegalArgumentException {\n        return getMethod(method, false);\n    }\n\n    /**\n     * Returns a {@link Method} corresponding to the given Java method\n     * declaration.\n     *\n     * @param method a Java method declaration, without argument names, of the\n     *        form \"returnType name (argumentType1, ... argumentTypeN)\", where\n     *        the types are in plain Java (e.g. \"int\", \"float\",\n     *        \"java.util.List\", ...). Classes of the java.lang package may be\n     *        specified by their unqualified name, depending on the\n     *        defaultPackage argument; all other classes names must be fully\n     *        qualified.\n     * @param defaultPackage true if unqualified class names belong to the\n     *        default package, or false if they correspond to java.lang classes.\n     *        For instance \"Object\" means \"Object\" if this option is true, or\n     *        \"java.lang.Object\" otherwise.\n     * @return a {@link Method} corresponding to the given Java method\n     *         declaration.\n     * @throws IllegalArgumentException if <code>method</code> could not get\n     *         parsed.\n     */\n    public static Method getMethod(final String method, final boolean defaultPackage) throws IllegalArgumentException {\n        int space = method.indexOf(' ');\n        int start = method.indexOf('(', space) + 1;\n        int end = method.indexOf(')', start);\n        if (space == -1 || start == -1 || end == -1) {\n            throw new IllegalArgumentException();\n        }\n        String returnType = method.substring(0, space);\n        String methodName = method.substring(space + 1, start - 1).trim();\n        StringBuffer sb = new StringBuffer();\n        sb.append('(');\n        int p;\n        do {\n            String s;\n            p = method.indexOf(',', start);\n            if (p == -1) {\n                s = map(method.substring(start, end).trim(), defaultPackage);\n            } else {\n                s = map(method.substring(start, p).trim(), defaultPackage);\n                start = p + 1;\n            }\n            sb.append(s);\n        } while (p != -1);\n        sb.append(')');\n        sb.append(map(returnType, defaultPackage));\n        return new Method(methodName, sb.toString());\n    }\n\n    private static String map(final String type, final boolean defaultPackage) {\n        if (\"\".equals(type)) {\n            return type;\n        }\n        StringBuffer sb = new StringBuffer();\n        int index = 0;\n        while ((index = type.indexOf(\"[]\", index) + 1) > 0) {\n            sb.append('[');\n        }\n        String t = type.substring(0, type.length() - sb.length() * 2);\n        String desc = (String) DESCRIPTORS.get(t);\n        if (desc != null) {\n            sb.append(desc);\n        } else {\n            sb.append('L');\n            if (t.indexOf('.') < 0) {\n                if (!defaultPackage) {\n                    sb.append(\"java/lang/\");\n                }\n                sb.append(t);\n            } else {\n                sb.append(t.replace('.', '/'));\n            }\n            sb.append(';');\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Returns the name of the method described by this object.\n     *\n     * @return the name of the method described by this object.\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns the descriptor of the method described by this object.\n     *\n     * @return the descriptor of the method described by this object.\n     */\n    public String getDescriptor() {\n        return desc;\n    }\n\n    /**\n     * Returns the return type of the method described by this object.\n     *\n     * @return the return type of the method described by this object.\n     */\n    public Type getReturnType() {\n        return Type.getReturnType(desc);\n    }\n\n    /**\n     * Returns the argument types of the method described by this object.\n     *\n     * @return the argument types of the method described by this object.\n     */\n    public Type[] getArgumentTypes() {\n        return Type.getArgumentTypes(desc);\n    }\n\n    public String toString() {\n        return name + desc;\n    }\n\n    public boolean equals(final Object o) {\n        if (!(o instanceof Method)) {\n            return false;\n        }\n        Method other = (Method) o;\n        return name.equals(other.name) && desc.equals(other.desc);\n    }\n\n    public int hashCode() {\n        return name.hashCode() ^ desc.hashCode();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/commons/MethodTest0.java",
		"test_prompt": "// MethodTest0.java\npackage org.objectweb.asm.jip.commons;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.objectweb.asm.jip.Type;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Method}.\n* It contains ten unit test cases for the {@link Method#getMethod(java.lang.reflect.Method)} method.\n*/\nclass MethodTest0 {"
	},
	{
		"original_code": "// Method.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip.commons;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.objectweb.asm.jip.Type;\n\n/**\n * A named method descriptor.\n *\n * @author Juozas Baliuka\n * @author Chris Nokleberg\n * @author Eric Bruneton\n */\npublic class Method {\n\n    /**\n     * The method name.\n     */\n    private final String name;\n\n    /**\n     * The method descriptor.\n     */\n    private final String desc;\n\n    /**\n     * Maps primitive Java type names to their descriptors.\n     */\n    private static final Map DESCRIPTORS;\n\n    static {\n        DESCRIPTORS = new HashMap();\n        DESCRIPTORS.put(\"void\", \"V\");\n        DESCRIPTORS.put(\"byte\", \"B\");\n        DESCRIPTORS.put(\"char\", \"C\");\n        DESCRIPTORS.put(\"double\", \"D\");\n        DESCRIPTORS.put(\"float\", \"F\");\n        DESCRIPTORS.put(\"int\", \"I\");\n        DESCRIPTORS.put(\"long\", \"J\");\n        DESCRIPTORS.put(\"short\", \"S\");\n        DESCRIPTORS.put(\"boolean\", \"Z\");\n    }\n\n    /**\n     * Creates a new {@link Method}.\n     *\n     * @param name the method's name.\n     * @param desc the method's descriptor.\n     */\n    public Method(final String name, final String desc) {\n        this.name = name;\n        this.desc = desc;\n    }\n\n    /**\n     * Creates a new {@link Method}.\n     *\n     * @param name the method's name.\n     * @param returnType the method's return type.\n     * @param argumentTypes the method's argument types.\n     */\n    public Method(final String name, final Type returnType, final Type[] argumentTypes) {\n        this(name, Type.getMethodDescriptor(returnType, argumentTypes));\n    }\n\n    /**\n     * Creates a new {@link Method}.\n     *\n     * @param m a java.lang.reflect method descriptor\n     * @return a {@link Method} corresponding to the given Java method\n     *         declaration.\n     */\n    public static Method getMethod(java.lang.reflect.Method m) {\n        return new Method(m.getName(), Type.getMethodDescriptor(m));\n    }\n\n    /**\n     * Creates a new {@link Method}.\n     *\n     * @param c a java.lang.reflect constructor descriptor\n     * @return a {@link Method} corresponding to the given Java constructor\n     *         declaration.\n     */\n    public static Method getMethod(java.lang.reflect.Constructor c) {\n        return new Method(\"<init>\", Type.getConstructorDescriptor(c));\n    }\n\n    /**\n     * Returns a {@link Method} corresponding to the given Java method\n     * declaration.\n     *\n     * @param method a Java method declaration, without argument names, of the\n     *        form \"returnType name (argumentType1, ... argumentTypeN)\", where\n     *        the types are in plain Java (e.g. \"int\", \"float\",\n     *        \"java.util.List\", ...). Classes of the java.lang package can be\n     *        specified by their unqualified name; all other classes names must\n     *        be fully qualified.\n     * @return a {@link Method} corresponding to the given Java method\n     *         declaration.\n     * @throws IllegalArgumentException if <code>method</code> could not get\n     *         parsed.\n     */\n    public static Method getMethod(final String method) throws IllegalArgumentException {\n        return getMethod(method, false);\n    }\n\n    /**\n     * Returns a {@link Method} corresponding to the given Java method\n     * declaration.\n     *\n     * @param method a Java method declaration, without argument names, of the\n     *        form \"returnType name (argumentType1, ... argumentTypeN)\", where\n     *        the types are in plain Java (e.g. \"int\", \"float\",\n     *        \"java.util.List\", ...). Classes of the java.lang package may be\n     *        specified by their unqualified name, depending on the\n     *        defaultPackage argument; all other classes names must be fully\n     *        qualified.\n     * @param defaultPackage true if unqualified class names belong to the\n     *        default package, or false if they correspond to java.lang classes.\n     *        For instance \"Object\" means \"Object\" if this option is true, or\n     *        \"java.lang.Object\" otherwise.\n     * @return a {@link Method} corresponding to the given Java method\n     *         declaration.\n     * @throws IllegalArgumentException if <code>method</code> could not get\n     *         parsed.\n     */\n    public static Method getMethod(final String method, final boolean defaultPackage) throws IllegalArgumentException {\n        int space = method.indexOf(' ');\n        int start = method.indexOf('(', space) + 1;\n        int end = method.indexOf(')', start);\n        if (space == -1 || start == -1 || end == -1) {\n            throw new IllegalArgumentException();\n        }\n        String returnType = method.substring(0, space);\n        String methodName = method.substring(space + 1, start - 1).trim();\n        StringBuffer sb = new StringBuffer();\n        sb.append('(');\n        int p;\n        do {\n            String s;\n            p = method.indexOf(',', start);\n            if (p == -1) {\n                s = map(method.substring(start, end).trim(), defaultPackage);\n            } else {\n                s = map(method.substring(start, p).trim(), defaultPackage);\n                start = p + 1;\n            }\n            sb.append(s);\n        } while (p != -1);\n        sb.append(')');\n        sb.append(map(returnType, defaultPackage));\n        return new Method(methodName, sb.toString());\n    }\n\n    private static String map(final String type, final boolean defaultPackage) {\n        if (\"\".equals(type)) {\n            return type;\n        }\n        StringBuffer sb = new StringBuffer();\n        int index = 0;\n        while ((index = type.indexOf(\"[]\", index) + 1) > 0) {\n            sb.append('[');\n        }\n        String t = type.substring(0, type.length() - sb.length() * 2);\n        String desc = (String) DESCRIPTORS.get(t);\n        if (desc != null) {\n            sb.append(desc);\n        } else {\n            sb.append('L');\n            if (t.indexOf('.') < 0) {\n                if (!defaultPackage) {\n                    sb.append(\"java/lang/\");\n                }\n                sb.append(t);\n            } else {\n                sb.append(t.replace('.', '/'));\n            }\n            sb.append(';');\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Returns the name of the method described by this object.\n     *\n     * @return the name of the method described by this object.\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns the descriptor of the method described by this object.\n     *\n     * @return the descriptor of the method described by this object.\n     */\n    public String getDescriptor() {\n        return desc;\n    }\n\n    /**\n     * Returns the return type of the method described by this object.\n     *\n     * @return the return type of the method described by this object.\n     */\n    public Type getReturnType() {\n        return Type.getReturnType(desc);\n    }\n\n    /**\n     * Returns the argument types of the method described by this object.\n     *\n     * @return the argument types of the method described by this object.\n     */\n    public Type[] getArgumentTypes() {\n        return Type.getArgumentTypes(desc);\n    }\n\n    public String toString() {\n        return name + desc;\n    }\n\n    public boolean equals(final Object o) {\n        if (!(o instanceof Method)) {\n            return false;\n        }\n        Method other = (Method) o;\n        return name.equals(other.name) && desc.equals(other.desc);\n    }\n\n    public int hashCode() {\n        return name.hashCode() ^ desc.hashCode();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/commons/MethodTest1.java",
		"test_prompt": "// MethodTest1.java\npackage org.objectweb.asm.jip.commons;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.objectweb.asm.jip.Type;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Method}.\n* It contains ten unit test cases for the {@link Method#getMethod(java.lang.reflect.Constructor)} method.\n*/\nclass MethodTest1 {"
	},
	{
		"original_code": "// Method.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip.commons;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.objectweb.asm.jip.Type;\n\n/**\n * A named method descriptor.\n *\n * @author Juozas Baliuka\n * @author Chris Nokleberg\n * @author Eric Bruneton\n */\npublic class Method {\n\n    /**\n     * The method name.\n     */\n    private final String name;\n\n    /**\n     * The method descriptor.\n     */\n    private final String desc;\n\n    /**\n     * Maps primitive Java type names to their descriptors.\n     */\n    private static final Map DESCRIPTORS;\n\n    static {\n        DESCRIPTORS = new HashMap();\n        DESCRIPTORS.put(\"void\", \"V\");\n        DESCRIPTORS.put(\"byte\", \"B\");\n        DESCRIPTORS.put(\"char\", \"C\");\n        DESCRIPTORS.put(\"double\", \"D\");\n        DESCRIPTORS.put(\"float\", \"F\");\n        DESCRIPTORS.put(\"int\", \"I\");\n        DESCRIPTORS.put(\"long\", \"J\");\n        DESCRIPTORS.put(\"short\", \"S\");\n        DESCRIPTORS.put(\"boolean\", \"Z\");\n    }\n\n    /**\n     * Creates a new {@link Method}.\n     *\n     * @param name the method's name.\n     * @param desc the method's descriptor.\n     */\n    public Method(final String name, final String desc) {\n        this.name = name;\n        this.desc = desc;\n    }\n\n    /**\n     * Creates a new {@link Method}.\n     *\n     * @param name the method's name.\n     * @param returnType the method's return type.\n     * @param argumentTypes the method's argument types.\n     */\n    public Method(final String name, final Type returnType, final Type[] argumentTypes) {\n        this(name, Type.getMethodDescriptor(returnType, argumentTypes));\n    }\n\n    /**\n     * Creates a new {@link Method}.\n     *\n     * @param m a java.lang.reflect method descriptor\n     * @return a {@link Method} corresponding to the given Java method\n     *         declaration.\n     */\n    public static Method getMethod(java.lang.reflect.Method m) {\n        return new Method(m.getName(), Type.getMethodDescriptor(m));\n    }\n\n    /**\n     * Creates a new {@link Method}.\n     *\n     * @param c a java.lang.reflect constructor descriptor\n     * @return a {@link Method} corresponding to the given Java constructor\n     *         declaration.\n     */\n    public static Method getMethod(java.lang.reflect.Constructor c) {\n        return new Method(\"<init>\", Type.getConstructorDescriptor(c));\n    }\n\n    /**\n     * Returns a {@link Method} corresponding to the given Java method\n     * declaration.\n     *\n     * @param method a Java method declaration, without argument names, of the\n     *        form \"returnType name (argumentType1, ... argumentTypeN)\", where\n     *        the types are in plain Java (e.g. \"int\", \"float\",\n     *        \"java.util.List\", ...). Classes of the java.lang package can be\n     *        specified by their unqualified name; all other classes names must\n     *        be fully qualified.\n     * @return a {@link Method} corresponding to the given Java method\n     *         declaration.\n     * @throws IllegalArgumentException if <code>method</code> could not get\n     *         parsed.\n     */\n    public static Method getMethod(final String method) throws IllegalArgumentException {\n        return getMethod(method, false);\n    }\n\n    /**\n     * Returns a {@link Method} corresponding to the given Java method\n     * declaration.\n     *\n     * @param method a Java method declaration, without argument names, of the\n     *        form \"returnType name (argumentType1, ... argumentTypeN)\", where\n     *        the types are in plain Java (e.g. \"int\", \"float\",\n     *        \"java.util.List\", ...). Classes of the java.lang package may be\n     *        specified by their unqualified name, depending on the\n     *        defaultPackage argument; all other classes names must be fully\n     *        qualified.\n     * @param defaultPackage true if unqualified class names belong to the\n     *        default package, or false if they correspond to java.lang classes.\n     *        For instance \"Object\" means \"Object\" if this option is true, or\n     *        \"java.lang.Object\" otherwise.\n     * @return a {@link Method} corresponding to the given Java method\n     *         declaration.\n     * @throws IllegalArgumentException if <code>method</code> could not get\n     *         parsed.\n     */\n    public static Method getMethod(final String method, final boolean defaultPackage) throws IllegalArgumentException {\n        int space = method.indexOf(' ');\n        int start = method.indexOf('(', space) + 1;\n        int end = method.indexOf(')', start);\n        if (space == -1 || start == -1 || end == -1) {\n            throw new IllegalArgumentException();\n        }\n        String returnType = method.substring(0, space);\n        String methodName = method.substring(space + 1, start - 1).trim();\n        StringBuffer sb = new StringBuffer();\n        sb.append('(');\n        int p;\n        do {\n            String s;\n            p = method.indexOf(',', start);\n            if (p == -1) {\n                s = map(method.substring(start, end).trim(), defaultPackage);\n            } else {\n                s = map(method.substring(start, p).trim(), defaultPackage);\n                start = p + 1;\n            }\n            sb.append(s);\n        } while (p != -1);\n        sb.append(')');\n        sb.append(map(returnType, defaultPackage));\n        return new Method(methodName, sb.toString());\n    }\n\n    private static String map(final String type, final boolean defaultPackage) {\n        if (\"\".equals(type)) {\n            return type;\n        }\n        StringBuffer sb = new StringBuffer();\n        int index = 0;\n        while ((index = type.indexOf(\"[]\", index) + 1) > 0) {\n            sb.append('[');\n        }\n        String t = type.substring(0, type.length() - sb.length() * 2);\n        String desc = (String) DESCRIPTORS.get(t);\n        if (desc != null) {\n            sb.append(desc);\n        } else {\n            sb.append('L');\n            if (t.indexOf('.') < 0) {\n                if (!defaultPackage) {\n                    sb.append(\"java/lang/\");\n                }\n                sb.append(t);\n            } else {\n                sb.append(t.replace('.', '/'));\n            }\n            sb.append(';');\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Returns the name of the method described by this object.\n     *\n     * @return the name of the method described by this object.\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns the descriptor of the method described by this object.\n     *\n     * @return the descriptor of the method described by this object.\n     */\n    public String getDescriptor() {\n        return desc;\n    }\n\n    /**\n     * Returns the return type of the method described by this object.\n     *\n     * @return the return type of the method described by this object.\n     */\n    public Type getReturnType() {\n        return Type.getReturnType(desc);\n    }\n\n    /**\n     * Returns the argument types of the method described by this object.\n     *\n     * @return the argument types of the method described by this object.\n     */\n    public Type[] getArgumentTypes() {\n        return Type.getArgumentTypes(desc);\n    }\n\n    public String toString() {\n        return name + desc;\n    }\n\n    public boolean equals(final Object o) {\n        if (!(o instanceof Method)) {\n            return false;\n        }\n        Method other = (Method) o;\n        return name.equals(other.name) && desc.equals(other.desc);\n    }\n\n    public int hashCode() {\n        return name.hashCode() ^ desc.hashCode();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/commons/MethodTest2.java",
		"test_prompt": "// MethodTest2.java\npackage org.objectweb.asm.jip.commons;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.objectweb.asm.jip.Type;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Method}.\n* It contains ten unit test cases for the {@link Method#getMethod(String)} method.\n*/\nclass MethodTest2 {"
	},
	{
		"original_code": "// Method.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip.commons;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.objectweb.asm.jip.Type;\n\n/**\n * A named method descriptor.\n *\n * @author Juozas Baliuka\n * @author Chris Nokleberg\n * @author Eric Bruneton\n */\npublic class Method {\n\n    /**\n     * The method name.\n     */\n    private final String name;\n\n    /**\n     * The method descriptor.\n     */\n    private final String desc;\n\n    /**\n     * Maps primitive Java type names to their descriptors.\n     */\n    private static final Map DESCRIPTORS;\n\n    static {\n        DESCRIPTORS = new HashMap();\n        DESCRIPTORS.put(\"void\", \"V\");\n        DESCRIPTORS.put(\"byte\", \"B\");\n        DESCRIPTORS.put(\"char\", \"C\");\n        DESCRIPTORS.put(\"double\", \"D\");\n        DESCRIPTORS.put(\"float\", \"F\");\n        DESCRIPTORS.put(\"int\", \"I\");\n        DESCRIPTORS.put(\"long\", \"J\");\n        DESCRIPTORS.put(\"short\", \"S\");\n        DESCRIPTORS.put(\"boolean\", \"Z\");\n    }\n\n    /**\n     * Creates a new {@link Method}.\n     *\n     * @param name the method's name.\n     * @param desc the method's descriptor.\n     */\n    public Method(final String name, final String desc) {\n        this.name = name;\n        this.desc = desc;\n    }\n\n    /**\n     * Creates a new {@link Method}.\n     *\n     * @param name the method's name.\n     * @param returnType the method's return type.\n     * @param argumentTypes the method's argument types.\n     */\n    public Method(final String name, final Type returnType, final Type[] argumentTypes) {\n        this(name, Type.getMethodDescriptor(returnType, argumentTypes));\n    }\n\n    /**\n     * Creates a new {@link Method}.\n     *\n     * @param m a java.lang.reflect method descriptor\n     * @return a {@link Method} corresponding to the given Java method\n     *         declaration.\n     */\n    public static Method getMethod(java.lang.reflect.Method m) {\n        return new Method(m.getName(), Type.getMethodDescriptor(m));\n    }\n\n    /**\n     * Creates a new {@link Method}.\n     *\n     * @param c a java.lang.reflect constructor descriptor\n     * @return a {@link Method} corresponding to the given Java constructor\n     *         declaration.\n     */\n    public static Method getMethod(java.lang.reflect.Constructor c) {\n        return new Method(\"<init>\", Type.getConstructorDescriptor(c));\n    }\n\n    /**\n     * Returns a {@link Method} corresponding to the given Java method\n     * declaration.\n     *\n     * @param method a Java method declaration, without argument names, of the\n     *        form \"returnType name (argumentType1, ... argumentTypeN)\", where\n     *        the types are in plain Java (e.g. \"int\", \"float\",\n     *        \"java.util.List\", ...). Classes of the java.lang package can be\n     *        specified by their unqualified name; all other classes names must\n     *        be fully qualified.\n     * @return a {@link Method} corresponding to the given Java method\n     *         declaration.\n     * @throws IllegalArgumentException if <code>method</code> could not get\n     *         parsed.\n     */\n    public static Method getMethod(final String method) throws IllegalArgumentException {\n        return getMethod(method, false);\n    }\n\n    /**\n     * Returns a {@link Method} corresponding to the given Java method\n     * declaration.\n     *\n     * @param method a Java method declaration, without argument names, of the\n     *        form \"returnType name (argumentType1, ... argumentTypeN)\", where\n     *        the types are in plain Java (e.g. \"int\", \"float\",\n     *        \"java.util.List\", ...). Classes of the java.lang package may be\n     *        specified by their unqualified name, depending on the\n     *        defaultPackage argument; all other classes names must be fully\n     *        qualified.\n     * @param defaultPackage true if unqualified class names belong to the\n     *        default package, or false if they correspond to java.lang classes.\n     *        For instance \"Object\" means \"Object\" if this option is true, or\n     *        \"java.lang.Object\" otherwise.\n     * @return a {@link Method} corresponding to the given Java method\n     *         declaration.\n     * @throws IllegalArgumentException if <code>method</code> could not get\n     *         parsed.\n     */\n    public static Method getMethod(final String method, final boolean defaultPackage) throws IllegalArgumentException {\n        int space = method.indexOf(' ');\n        int start = method.indexOf('(', space) + 1;\n        int end = method.indexOf(')', start);\n        if (space == -1 || start == -1 || end == -1) {\n            throw new IllegalArgumentException();\n        }\n        String returnType = method.substring(0, space);\n        String methodName = method.substring(space + 1, start - 1).trim();\n        StringBuffer sb = new StringBuffer();\n        sb.append('(');\n        int p;\n        do {\n            String s;\n            p = method.indexOf(',', start);\n            if (p == -1) {\n                s = map(method.substring(start, end).trim(), defaultPackage);\n            } else {\n                s = map(method.substring(start, p).trim(), defaultPackage);\n                start = p + 1;\n            }\n            sb.append(s);\n        } while (p != -1);\n        sb.append(')');\n        sb.append(map(returnType, defaultPackage));\n        return new Method(methodName, sb.toString());\n    }\n\n    private static String map(final String type, final boolean defaultPackage) {\n        if (\"\".equals(type)) {\n            return type;\n        }\n        StringBuffer sb = new StringBuffer();\n        int index = 0;\n        while ((index = type.indexOf(\"[]\", index) + 1) > 0) {\n            sb.append('[');\n        }\n        String t = type.substring(0, type.length() - sb.length() * 2);\n        String desc = (String) DESCRIPTORS.get(t);\n        if (desc != null) {\n            sb.append(desc);\n        } else {\n            sb.append('L');\n            if (t.indexOf('.') < 0) {\n                if (!defaultPackage) {\n                    sb.append(\"java/lang/\");\n                }\n                sb.append(t);\n            } else {\n                sb.append(t.replace('.', '/'));\n            }\n            sb.append(';');\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Returns the name of the method described by this object.\n     *\n     * @return the name of the method described by this object.\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns the descriptor of the method described by this object.\n     *\n     * @return the descriptor of the method described by this object.\n     */\n    public String getDescriptor() {\n        return desc;\n    }\n\n    /**\n     * Returns the return type of the method described by this object.\n     *\n     * @return the return type of the method described by this object.\n     */\n    public Type getReturnType() {\n        return Type.getReturnType(desc);\n    }\n\n    /**\n     * Returns the argument types of the method described by this object.\n     *\n     * @return the argument types of the method described by this object.\n     */\n    public Type[] getArgumentTypes() {\n        return Type.getArgumentTypes(desc);\n    }\n\n    public String toString() {\n        return name + desc;\n    }\n\n    public boolean equals(final Object o) {\n        if (!(o instanceof Method)) {\n            return false;\n        }\n        Method other = (Method) o;\n        return name.equals(other.name) && desc.equals(other.desc);\n    }\n\n    public int hashCode() {\n        return name.hashCode() ^ desc.hashCode();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/commons/MethodTest3.java",
		"test_prompt": "// MethodTest3.java\npackage org.objectweb.asm.jip.commons;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.objectweb.asm.jip.Type;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Method}.\n* It contains ten unit test cases for the {@link Method#getMethod(String, boolean)} method.\n*/\nclass MethodTest3 {"
	},
	{
		"original_code": "// Method.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip.commons;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.objectweb.asm.jip.Type;\n\n/**\n * A named method descriptor.\n *\n * @author Juozas Baliuka\n * @author Chris Nokleberg\n * @author Eric Bruneton\n */\npublic class Method {\n\n    /**\n     * The method name.\n     */\n    private final String name;\n\n    /**\n     * The method descriptor.\n     */\n    private final String desc;\n\n    /**\n     * Maps primitive Java type names to their descriptors.\n     */\n    private static final Map DESCRIPTORS;\n\n    static {\n        DESCRIPTORS = new HashMap();\n        DESCRIPTORS.put(\"void\", \"V\");\n        DESCRIPTORS.put(\"byte\", \"B\");\n        DESCRIPTORS.put(\"char\", \"C\");\n        DESCRIPTORS.put(\"double\", \"D\");\n        DESCRIPTORS.put(\"float\", \"F\");\n        DESCRIPTORS.put(\"int\", \"I\");\n        DESCRIPTORS.put(\"long\", \"J\");\n        DESCRIPTORS.put(\"short\", \"S\");\n        DESCRIPTORS.put(\"boolean\", \"Z\");\n    }\n\n    /**\n     * Creates a new {@link Method}.\n     *\n     * @param name the method's name.\n     * @param desc the method's descriptor.\n     */\n    public Method(final String name, final String desc) {\n        this.name = name;\n        this.desc = desc;\n    }\n\n    /**\n     * Creates a new {@link Method}.\n     *\n     * @param name the method's name.\n     * @param returnType the method's return type.\n     * @param argumentTypes the method's argument types.\n     */\n    public Method(final String name, final Type returnType, final Type[] argumentTypes) {\n        this(name, Type.getMethodDescriptor(returnType, argumentTypes));\n    }\n\n    /**\n     * Creates a new {@link Method}.\n     *\n     * @param m a java.lang.reflect method descriptor\n     * @return a {@link Method} corresponding to the given Java method\n     *         declaration.\n     */\n    public static Method getMethod(java.lang.reflect.Method m) {\n        return new Method(m.getName(), Type.getMethodDescriptor(m));\n    }\n\n    /**\n     * Creates a new {@link Method}.\n     *\n     * @param c a java.lang.reflect constructor descriptor\n     * @return a {@link Method} corresponding to the given Java constructor\n     *         declaration.\n     */\n    public static Method getMethod(java.lang.reflect.Constructor c) {\n        return new Method(\"<init>\", Type.getConstructorDescriptor(c));\n    }\n\n    /**\n     * Returns a {@link Method} corresponding to the given Java method\n     * declaration.\n     *\n     * @param method a Java method declaration, without argument names, of the\n     *        form \"returnType name (argumentType1, ... argumentTypeN)\", where\n     *        the types are in plain Java (e.g. \"int\", \"float\",\n     *        \"java.util.List\", ...). Classes of the java.lang package can be\n     *        specified by their unqualified name; all other classes names must\n     *        be fully qualified.\n     * @return a {@link Method} corresponding to the given Java method\n     *         declaration.\n     * @throws IllegalArgumentException if <code>method</code> could not get\n     *         parsed.\n     */\n    public static Method getMethod(final String method) throws IllegalArgumentException {\n        return getMethod(method, false);\n    }\n\n    /**\n     * Returns a {@link Method} corresponding to the given Java method\n     * declaration.\n     *\n     * @param method a Java method declaration, without argument names, of the\n     *        form \"returnType name (argumentType1, ... argumentTypeN)\", where\n     *        the types are in plain Java (e.g. \"int\", \"float\",\n     *        \"java.util.List\", ...). Classes of the java.lang package may be\n     *        specified by their unqualified name, depending on the\n     *        defaultPackage argument; all other classes names must be fully\n     *        qualified.\n     * @param defaultPackage true if unqualified class names belong to the\n     *        default package, or false if they correspond to java.lang classes.\n     *        For instance \"Object\" means \"Object\" if this option is true, or\n     *        \"java.lang.Object\" otherwise.\n     * @return a {@link Method} corresponding to the given Java method\n     *         declaration.\n     * @throws IllegalArgumentException if <code>method</code> could not get\n     *         parsed.\n     */\n    public static Method getMethod(final String method, final boolean defaultPackage) throws IllegalArgumentException {\n        int space = method.indexOf(' ');\n        int start = method.indexOf('(', space) + 1;\n        int end = method.indexOf(')', start);\n        if (space == -1 || start == -1 || end == -1) {\n            throw new IllegalArgumentException();\n        }\n        String returnType = method.substring(0, space);\n        String methodName = method.substring(space + 1, start - 1).trim();\n        StringBuffer sb = new StringBuffer();\n        sb.append('(');\n        int p;\n        do {\n            String s;\n            p = method.indexOf(',', start);\n            if (p == -1) {\n                s = map(method.substring(start, end).trim(), defaultPackage);\n            } else {\n                s = map(method.substring(start, p).trim(), defaultPackage);\n                start = p + 1;\n            }\n            sb.append(s);\n        } while (p != -1);\n        sb.append(')');\n        sb.append(map(returnType, defaultPackage));\n        return new Method(methodName, sb.toString());\n    }\n\n    private static String map(final String type, final boolean defaultPackage) {\n        if (\"\".equals(type)) {\n            return type;\n        }\n        StringBuffer sb = new StringBuffer();\n        int index = 0;\n        while ((index = type.indexOf(\"[]\", index) + 1) > 0) {\n            sb.append('[');\n        }\n        String t = type.substring(0, type.length() - sb.length() * 2);\n        String desc = (String) DESCRIPTORS.get(t);\n        if (desc != null) {\n            sb.append(desc);\n        } else {\n            sb.append('L');\n            if (t.indexOf('.') < 0) {\n                if (!defaultPackage) {\n                    sb.append(\"java/lang/\");\n                }\n                sb.append(t);\n            } else {\n                sb.append(t.replace('.', '/'));\n            }\n            sb.append(';');\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Returns the name of the method described by this object.\n     *\n     * @return the name of the method described by this object.\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns the descriptor of the method described by this object.\n     *\n     * @return the descriptor of the method described by this object.\n     */\n    public String getDescriptor() {\n        return desc;\n    }\n\n    /**\n     * Returns the return type of the method described by this object.\n     *\n     * @return the return type of the method described by this object.\n     */\n    public Type getReturnType() {\n        return Type.getReturnType(desc);\n    }\n\n    /**\n     * Returns the argument types of the method described by this object.\n     *\n     * @return the argument types of the method described by this object.\n     */\n    public Type[] getArgumentTypes() {\n        return Type.getArgumentTypes(desc);\n    }\n\n    public String toString() {\n        return name + desc;\n    }\n\n    public boolean equals(final Object o) {\n        if (!(o instanceof Method)) {\n            return false;\n        }\n        Method other = (Method) o;\n        return name.equals(other.name) && desc.equals(other.desc);\n    }\n\n    public int hashCode() {\n        return name.hashCode() ^ desc.hashCode();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/commons/MethodTest4.java",
		"test_prompt": "// MethodTest4.java\npackage org.objectweb.asm.jip.commons;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.objectweb.asm.jip.Type;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Method}.\n* It contains ten unit test cases for the {@link Method#equals(Object)} method.\n*/\nclass MethodTest4 {"
	},
	{
		"original_code": "// Method.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip.commons;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.objectweb.asm.jip.Type;\n\n/**\n * A named method descriptor.\n *\n * @author Juozas Baliuka\n * @author Chris Nokleberg\n * @author Eric Bruneton\n */\npublic class Method {\n\n    /**\n     * The method name.\n     */\n    private final String name;\n\n    /**\n     * The method descriptor.\n     */\n    private final String desc;\n\n    /**\n     * Maps primitive Java type names to their descriptors.\n     */\n    private static final Map DESCRIPTORS;\n\n    static {\n        DESCRIPTORS = new HashMap();\n        DESCRIPTORS.put(\"void\", \"V\");\n        DESCRIPTORS.put(\"byte\", \"B\");\n        DESCRIPTORS.put(\"char\", \"C\");\n        DESCRIPTORS.put(\"double\", \"D\");\n        DESCRIPTORS.put(\"float\", \"F\");\n        DESCRIPTORS.put(\"int\", \"I\");\n        DESCRIPTORS.put(\"long\", \"J\");\n        DESCRIPTORS.put(\"short\", \"S\");\n        DESCRIPTORS.put(\"boolean\", \"Z\");\n    }\n\n    /**\n     * Creates a new {@link Method}.\n     *\n     * @param name the method's name.\n     * @param desc the method's descriptor.\n     */\n    public Method(final String name, final String desc) {\n        this.name = name;\n        this.desc = desc;\n    }\n\n    /**\n     * Creates a new {@link Method}.\n     *\n     * @param name the method's name.\n     * @param returnType the method's return type.\n     * @param argumentTypes the method's argument types.\n     */\n    public Method(final String name, final Type returnType, final Type[] argumentTypes) {\n        this(name, Type.getMethodDescriptor(returnType, argumentTypes));\n    }\n\n    /**\n     * Creates a new {@link Method}.\n     *\n     * @param m a java.lang.reflect method descriptor\n     * @return a {@link Method} corresponding to the given Java method\n     *         declaration.\n     */\n    public static Method getMethod(java.lang.reflect.Method m) {\n        return new Method(m.getName(), Type.getMethodDescriptor(m));\n    }\n\n    /**\n     * Creates a new {@link Method}.\n     *\n     * @param c a java.lang.reflect constructor descriptor\n     * @return a {@link Method} corresponding to the given Java constructor\n     *         declaration.\n     */\n    public static Method getMethod(java.lang.reflect.Constructor c) {\n        return new Method(\"<init>\", Type.getConstructorDescriptor(c));\n    }\n\n    /**\n     * Returns a {@link Method} corresponding to the given Java method\n     * declaration.\n     *\n     * @param method a Java method declaration, without argument names, of the\n     *        form \"returnType name (argumentType1, ... argumentTypeN)\", where\n     *        the types are in plain Java (e.g. \"int\", \"float\",\n     *        \"java.util.List\", ...). Classes of the java.lang package can be\n     *        specified by their unqualified name; all other classes names must\n     *        be fully qualified.\n     * @return a {@link Method} corresponding to the given Java method\n     *         declaration.\n     * @throws IllegalArgumentException if <code>method</code> could not get\n     *         parsed.\n     */\n    public static Method getMethod(final String method) throws IllegalArgumentException {\n        return getMethod(method, false);\n    }\n\n    /**\n     * Returns a {@link Method} corresponding to the given Java method\n     * declaration.\n     *\n     * @param method a Java method declaration, without argument names, of the\n     *        form \"returnType name (argumentType1, ... argumentTypeN)\", where\n     *        the types are in plain Java (e.g. \"int\", \"float\",\n     *        \"java.util.List\", ...). Classes of the java.lang package may be\n     *        specified by their unqualified name, depending on the\n     *        defaultPackage argument; all other classes names must be fully\n     *        qualified.\n     * @param defaultPackage true if unqualified class names belong to the\n     *        default package, or false if they correspond to java.lang classes.\n     *        For instance \"Object\" means \"Object\" if this option is true, or\n     *        \"java.lang.Object\" otherwise.\n     * @return a {@link Method} corresponding to the given Java method\n     *         declaration.\n     * @throws IllegalArgumentException if <code>method</code> could not get\n     *         parsed.\n     */\n    public static Method getMethod(final String method, final boolean defaultPackage) throws IllegalArgumentException {\n        int space = method.indexOf(' ');\n        int start = method.indexOf('(', space) + 1;\n        int end = method.indexOf(')', start);\n        if (space == -1 || start == -1 || end == -1) {\n            throw new IllegalArgumentException();\n        }\n        String returnType = method.substring(0, space);\n        String methodName = method.substring(space + 1, start - 1).trim();\n        StringBuffer sb = new StringBuffer();\n        sb.append('(');\n        int p;\n        do {\n            String s;\n            p = method.indexOf(',', start);\n            if (p == -1) {\n                s = map(method.substring(start, end).trim(), defaultPackage);\n            } else {\n                s = map(method.substring(start, p).trim(), defaultPackage);\n                start = p + 1;\n            }\n            sb.append(s);\n        } while (p != -1);\n        sb.append(')');\n        sb.append(map(returnType, defaultPackage));\n        return new Method(methodName, sb.toString());\n    }\n\n    private static String map(final String type, final boolean defaultPackage) {\n        if (\"\".equals(type)) {\n            return type;\n        }\n        StringBuffer sb = new StringBuffer();\n        int index = 0;\n        while ((index = type.indexOf(\"[]\", index) + 1) > 0) {\n            sb.append('[');\n        }\n        String t = type.substring(0, type.length() - sb.length() * 2);\n        String desc = (String) DESCRIPTORS.get(t);\n        if (desc != null) {\n            sb.append(desc);\n        } else {\n            sb.append('L');\n            if (t.indexOf('.') < 0) {\n                if (!defaultPackage) {\n                    sb.append(\"java/lang/\");\n                }\n                sb.append(t);\n            } else {\n                sb.append(t.replace('.', '/'));\n            }\n            sb.append(';');\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Returns the name of the method described by this object.\n     *\n     * @return the name of the method described by this object.\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns the descriptor of the method described by this object.\n     *\n     * @return the descriptor of the method described by this object.\n     */\n    public String getDescriptor() {\n        return desc;\n    }\n\n    /**\n     * Returns the return type of the method described by this object.\n     *\n     * @return the return type of the method described by this object.\n     */\n    public Type getReturnType() {\n        return Type.getReturnType(desc);\n    }\n\n    /**\n     * Returns the argument types of the method described by this object.\n     *\n     * @return the argument types of the method described by this object.\n     */\n    public Type[] getArgumentTypes() {\n        return Type.getArgumentTypes(desc);\n    }\n\n    public String toString() {\n        return name + desc;\n    }\n\n    public boolean equals(final Object o) {\n        if (!(o instanceof Method)) {\n            return false;\n        }\n        Method other = (Method) o;\n        return name.equals(other.name) && desc.equals(other.desc);\n    }\n\n    public int hashCode() {\n        return name.hashCode() ^ desc.hashCode();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/commons/MethodTest5.java",
		"test_prompt": "// MethodTest5.java\npackage org.objectweb.asm.jip.commons;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.objectweb.asm.jip.Type;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Method}.\n* It contains ten unit test cases for the {@link Method#hashCode()} method.\n*/\nclass MethodTest5 {"
	},
	{
		"original_code": "// GeneratorAdapter.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip.commons;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport org.objectweb.asm.jip.ClassVisitor;\nimport org.objectweb.asm.jip.Label;\nimport org.objectweb.asm.jip.MethodVisitor;\nimport org.objectweb.asm.jip.Opcodes;\nimport org.objectweb.asm.jip.Type;\n\n/**\n * A {@link org.objectweb.asm.jip.MethodAdapter} with convenient methods to generate\n * code. For example, using this adapter, the class below\n *\n * <pre>\n * public class Example {\n *     public static void main(String[] args) {\n *         System.out.println(&quot;Hello world!&quot;);\n *     }\n * }\n * </pre>\n *\n * can be generated as follows:\n *\n * <pre>\n * ClassWriter cw = new ClassWriter(true);\n * cw.visit(V1_1, ACC_PUBLIC, &quot;Example&quot;, null, &quot;java/lang/Object&quot;, null);\n *\n * Method m = Method.getMethod(&quot;void &lt;init&gt; ()&quot;);\n * GeneratorAdapter mg = new GeneratorAdapter(ACC_PUBLIC, m, null, null, cw);\n * mg.loadThis();\n * mg.invokeConstructor(Type.getType(Object.class), m);\n * mg.returnValue();\n * mg.endMethod();\n *\n * m = Method.getMethod(&quot;void main (String[])&quot;);\n * mg = new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC, m, null, null, cw);\n * mg.getStatic(Type.getType(System.class), &quot;out&quot;, Type.getType(PrintStream.class));\n * mg.push(&quot;Hello world!&quot;);\n * mg.invokeVirtual(Type.getType(PrintStream.class), Method.getMethod(&quot;void println (String)&quot;));\n * mg.returnValue();\n * mg.endMethod();\n *\n * cw.visitEnd();\n * </pre>\n *\n * @author Juozas Baliuka\n * @author Chris Nokleberg\n * @author Eric Bruneton\n */\npublic class GeneratorAdapter extends LocalVariablesSorter {\n\n    private static final String CLDESC = \"Ljava/lang/Class;\";\n\n    private static final Type BYTE_TYPE = Type.getObjectType(\"java/lang/Byte\");\n\n    private static final Type BOOLEAN_TYPE = Type.getObjectType(\"java/lang/Boolean\");\n\n    private static final Type SHORT_TYPE = Type.getObjectType(\"java/lang/Short\");\n\n    private static final Type CHARACTER_TYPE = Type.getObjectType(\"java/lang/Character\");\n\n    private static final Type INTEGER_TYPE = Type.getObjectType(\"java/lang/Integer\");\n\n    private static final Type FLOAT_TYPE = Type.getObjectType(\"java/lang/Float\");\n\n    private static final Type LONG_TYPE = Type.getObjectType(\"java/lang/Long\");\n\n    private static final Type DOUBLE_TYPE = Type.getObjectType(\"java/lang/Double\");\n\n    private static final Type NUMBER_TYPE = Type.getObjectType(\"java/lang/Number\");\n\n    private static final Type OBJECT_TYPE = Type.getObjectType(\"java/lang/Object\");\n\n    private static final Method BOOLEAN_VALUE = Method.getMethod(\"boolean booleanValue()\");\n\n    private static final Method CHAR_VALUE = Method.getMethod(\"char charValue()\");\n\n    private static final Method INT_VALUE = Method.getMethod(\"int intValue()\");\n\n    private static final Method FLOAT_VALUE = Method.getMethod(\"float floatValue()\");\n\n    private static final Method LONG_VALUE = Method.getMethod(\"long longValue()\");\n\n    private static final Method DOUBLE_VALUE = Method.getMethod(\"double doubleValue()\");\n\n    /**\n     * Constant for the {@link #math math} method.\n     */\n    public static final int ADD = Opcodes.IADD;\n\n    /**\n     * Constant for the {@link #math math} method.\n     */\n    public static final int SUB = Opcodes.ISUB;\n\n    /**\n     * Constant for the {@link #math math} method.\n     */\n    public static final int MUL = Opcodes.IMUL;\n\n    /**\n     * Constant for the {@link #math math} method.\n     */\n    public static final int DIV = Opcodes.IDIV;\n\n    /**\n     * Constant for the {@link #math math} method.\n     */\n    public static final int REM = Opcodes.IREM;\n\n    /**\n     * Constant for the {@link #math math} method.\n     */\n    public static final int NEG = Opcodes.INEG;\n\n    /**\n     * Constant for the {@link #math math} method.\n     */\n    public static final int SHL = Opcodes.ISHL;\n\n    /**\n     * Constant for the {@link #math math} method.\n     */\n    public static final int SHR = Opcodes.ISHR;\n\n    /**\n     * Constant for the {@link #math math} method.\n     */\n    public static final int USHR = Opcodes.IUSHR;\n\n    /**\n     * Constant for the {@link #math math} method.\n     */\n    public static final int AND = Opcodes.IAND;\n\n    /**\n     * Constant for the {@link #math math} method.\n     */\n    public static final int OR = Opcodes.IOR;\n\n    /**\n     * Constant for the {@link #math math} method.\n     */\n    public static final int XOR = Opcodes.IXOR;\n\n    /**\n     * Constant for the {@link #ifCmp ifCmp} method.\n     */\n    public static final int EQ = Opcodes.IFEQ;\n\n    /**\n     * Constant for the {@link #ifCmp ifCmp} method.\n     */\n    public static final int NE = Opcodes.IFNE;\n\n    /**\n     * Constant for the {@link #ifCmp ifCmp} method.\n     */\n    public static final int LT = Opcodes.IFLT;\n\n    /**\n     * Constant for the {@link #ifCmp ifCmp} method.\n     */\n    public static final int GE = Opcodes.IFGE;\n\n    /**\n     * Constant for the {@link #ifCmp ifCmp} method.\n     */\n    public static final int GT = Opcodes.IFGT;\n\n    /**\n     * Constant for the {@link #ifCmp ifCmp} method.\n     */\n    public static final int LE = Opcodes.IFLE;\n\n    /**\n     * Access flags of the method visited by this adapter.\n     */\n    private final int access;\n\n    /**\n     * Return type of the method visited by this adapter.\n     */\n    private final Type returnType;\n\n    /**\n     * Argument types of the method visited by this adapter.\n     */\n    private final Type[] argumentTypes;\n\n    /**\n     * Types of the local variables of the method visited by this adapter.\n     */\n    private final List localTypes = new ArrayList();\n\n    /**\n     * Creates a new {@link GeneratorAdapter}.\n     *\n     * @param mv the method visitor to which this adapter delegates calls.\n     * @param access the method's access flags (see {@link Opcodes}).\n     * @param name the method's name.\n     * @param desc the method's descriptor (see {@link Type Type}).\n     */\n    public GeneratorAdapter(final MethodVisitor mv, final int access, final String name, final String desc) {\n        super(access, desc, mv);\n        this.access = access;\n        this.returnType = Type.getReturnType(desc);\n        this.argumentTypes = Type.getArgumentTypes(desc);\n    }\n\n    /**\n     * Creates a new {@link GeneratorAdapter}.\n     *\n     * @param access access flags of the adapted method.\n     * @param method the adapted method.\n     * @param mv the method visitor to which this adapter delegates calls.\n     */\n    public GeneratorAdapter(final int access, final Method method, final MethodVisitor mv) {\n        super(access, method.getDescriptor(), mv);\n        this.access = access;\n        this.returnType = method.getReturnType();\n        this.argumentTypes = method.getArgumentTypes();\n    }\n\n    /**\n     * Creates a new {@link GeneratorAdapter}.\n     *\n     * @param access access flags of the adapted method.\n     * @param method the adapted method.\n     * @param signature the signature of the adapted method (may be\n     *        <tt>null</tt>).\n     * @param exceptions the exceptions thrown by the adapted method (may be\n     *        <tt>null</tt>).\n     * @param cv the class visitor to which this adapter delegates calls.\n     */\n    public GeneratorAdapter(final int access, final Method method, final String signature, final Type[] exceptions, final ClassVisitor cv) {\n        this(access, method, cv.visitMethod(access, method.getName(), method.getDescriptor(), signature, getInternalNames(exceptions)));\n    }\n\n    /**\n     * Returns the internal names of the given types.\n     *\n     * @param types a set of types.\n     * @return the internal names of the given types.\n     */\n    private static String[] getInternalNames(final Type[] types) {\n        if (types == null) {\n            return null;\n        }\n        String[] names = new String[types.length];\n        for (int i = 0; i < names.length; ++i) {\n            names[i] = types[i].getInternalName();\n        }\n        return names;\n    }\n\n    // ------------------------------------------------------------------------\n    // Instructions to push constants on the stack\n    // ------------------------------------------------------------------------\n    /**\n     * Generates the instruction to push the given value on the stack.\n     *\n     * @param value the value to be pushed on the stack.\n     */\n    public void push(final boolean value) {\n        push(value ? 1 : 0);\n    }\n\n    /**\n     * Generates the instruction to push the given value on the stack.\n     *\n     * @param value the value to be pushed on the stack.\n     */\n    public void push(final int value) {\n        if (value >= -1 && value <= 5) {\n            mv.visitInsn(Opcodes.ICONST_0 + value);\n        } else if (value >= Byte.MIN_VALUE && value <= Byte.MAX_VALUE) {\n            mv.visitIntInsn(Opcodes.BIPUSH, value);\n        } else if (value >= Short.MIN_VALUE && value <= Short.MAX_VALUE) {\n            mv.visitIntInsn(Opcodes.SIPUSH, value);\n        } else {\n            mv.visitLdcInsn(new Integer(value));\n        }\n    }\n\n    /**\n     * Generates the instruction to push the given value on the stack.\n     *\n     * @param value the value to be pushed on the stack.\n     */\n    public void push(final long value) {\n        if (value == 0L || value == 1L) {\n            mv.visitInsn(Opcodes.LCONST_0 + (int) value);\n        } else {\n            mv.visitLdcInsn(new Long(value));\n        }\n    }\n\n    /**\n     * Generates the instruction to push the given value on the stack.\n     *\n     * @param value the value to be pushed on the stack.\n     */\n    public void push(final float value) {\n        int bits = Float.floatToIntBits(value);\n        if (bits == 0L || bits == 0x3f800000 || bits == 0x40000000) {\n            // 0..2\n            mv.visitInsn(Opcodes.FCONST_0 + (int) value);\n        } else {\n            mv.visitLdcInsn(new Float(value));\n        }\n    }\n\n    /**\n     * Generates the instruction to push the given value on the stack.\n     *\n     * @param value the value to be pushed on the stack.\n     */\n    public void push(final double value) {\n        long bits = Double.doubleToLongBits(value);\n        if (bits == 0L || bits == 0x3ff0000000000000L) {\n            // +0.0d and 1.0d\n            mv.visitInsn(Opcodes.DCONST_0 + (int) value);\n        } else {\n            mv.visitLdcInsn(new Double(value));\n        }\n    }\n\n    /**\n     * Generates the instruction to push the given value on the stack.\n     *\n     * @param value the value to be pushed on the stack. May be <tt>null</tt>.\n     */\n    public void push(final String value) {\n        if (value == null) {\n            mv.visitInsn(Opcodes.ACONST_NULL);\n        } else {\n            mv.visitLdcInsn(value);\n        }\n    }\n\n    /**\n     * Generates the instruction to push the given value on the stack.\n     *\n     * @param value the value to be pushed on the stack.\n     */\n    public void push(final Type value) {\n        if (value == null) {\n            mv.visitInsn(Opcodes.ACONST_NULL);\n        } else {\n            switch(value.getSort()) {\n                case Type.BOOLEAN:\n                    mv.visitFieldInsn(Opcodes.GETSTATIC, \"java/lang/Boolean\", \"TYPE\", CLDESC);\n                    break;\n                case Type.CHAR:\n                    mv.visitFieldInsn(Opcodes.GETSTATIC, \"java/lang/Character\", \"TYPE\", CLDESC);\n                    break;\n                case Type.BYTE:\n                    mv.visitFieldInsn(Opcodes.GETSTATIC, \"java/lang/Byte\", \"TYPE\", CLDESC);\n                    break;\n                case Type.SHORT:\n                    mv.visitFieldInsn(Opcodes.GETSTATIC, \"java/lang/Short\", \"TYPE\", CLDESC);\n                    break;\n                case Type.INT:\n                    mv.visitFieldInsn(Opcodes.GETSTATIC, \"java/lang/Integer\", \"TYPE\", CLDESC);\n                    break;\n                case Type.FLOAT:\n                    mv.visitFieldInsn(Opcodes.GETSTATIC, \"java/lang/Float\", \"TYPE\", CLDESC);\n                    break;\n                case Type.LONG:\n                    mv.visitFieldInsn(Opcodes.GETSTATIC, \"java/lang/Long\", \"TYPE\", CLDESC);\n                    break;\n                case Type.DOUBLE:\n                    mv.visitFieldInsn(Opcodes.GETSTATIC, \"java/lang/Double\", \"TYPE\", CLDESC);\n                    break;\n                default:\n                    mv.visitLdcInsn(value);\n            }\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Instructions to load and store method arguments\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the index of the given method argument in the frame's local\n     * variables array.\n     *\n     * @param arg the index of a method argument.\n     * @return the index of the given method argument in the frame's local\n     *         variables array.\n     */\n    private int getArgIndex(final int arg) {\n        int index = (access & Opcodes.ACC_STATIC) == 0 ? 1 : 0;\n        for (int i = 0; i < arg; i++) {\n            index += argumentTypes[i].getSize();\n        }\n        return index;\n    }\n\n    /**\n     * Generates the instruction to push a local variable on the stack.\n     *\n     * @param type the type of the local variable to be loaded.\n     * @param index an index in the frame's local variables array.\n     */\n    private void loadInsn(final Type type, final int index) {\n        mv.visitVarInsn(type.getOpcode(Opcodes.ILOAD), index);\n    }\n\n    /**\n     * Generates the instruction to store the top stack value in a local\n     * variable.\n     *\n     * @param type the type of the local variable to be stored.\n     * @param index an index in the frame's local variables array.\n     */\n    private void storeInsn(final Type type, final int index) {\n        mv.visitVarInsn(type.getOpcode(Opcodes.ISTORE), index);\n    }\n\n    /**\n     * Generates the instruction to load 'this' on the stack.\n     */\n    public void loadThis() {\n        if ((access & Opcodes.ACC_STATIC) != 0) {\n            throw new IllegalStateException(\"no 'this' pointer within static method\");\n        }\n        mv.visitVarInsn(Opcodes.ALOAD, 0);\n    }\n\n    /**\n     * Generates the instruction to load the given method argument on the stack.\n     *\n     * @param arg the index of a method argument.\n     */\n    public void loadArg(final int arg) {\n        loadInsn(argumentTypes[arg], getArgIndex(arg));\n    }\n\n    /**\n     * Generates the instructions to load the given method arguments on the\n     * stack.\n     *\n     * @param arg the index of the first method argument to be loaded.\n     * @param count the number of method arguments to be loaded.\n     */\n    public void loadArgs(final int arg, final int count) {\n        int index = getArgIndex(arg);\n        for (int i = 0; i < count; ++i) {\n            Type t = argumentTypes[arg + i];\n            loadInsn(t, index);\n            index += t.getSize();\n        }\n    }\n\n    /**\n     * Generates the instructions to load all the method arguments on the stack.\n     */\n    public void loadArgs() {\n        loadArgs(0, argumentTypes.length);\n    }\n\n    /**\n     * Generates the instructions to load all the method arguments on the stack,\n     * as a single object array.\n     */\n    public void loadArgArray() {\n        push(argumentTypes.length);\n        newArray(OBJECT_TYPE);\n        for (int i = 0; i < argumentTypes.length; i++) {\n            dup();\n            push(i);\n            loadArg(i);\n            box(argumentTypes[i]);\n            arrayStore(OBJECT_TYPE);\n        }\n    }\n\n    /**\n     * Generates the instruction to store the top stack value in the given\n     * method argument.\n     *\n     * @param arg the index of a method argument.\n     */\n    public void storeArg(final int arg) {\n        storeInsn(argumentTypes[arg], getArgIndex(arg));\n    }\n\n    // ------------------------------------------------------------------------\n    // Instructions to load and store local variables\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the type of the given local variable.\n     *\n     * @param local a local variable identifier, as returned by\n     *        {@link LocalVariablesSorter#newLocal(Type) newLocal()}.\n     * @return the type of the given local variable.\n     */\n    public Type getLocalType(final int local) {\n        return (Type) localTypes.get(local - firstLocal);\n    }\n\n    protected void setLocalType(final int local, final Type type) {\n        int index = local - firstLocal;\n        while (localTypes.size() < index + 1) {\n            localTypes.add(null);\n        }\n        localTypes.set(index, type);\n    }\n\n    /**\n     * Generates the instruction to load the given local variable on the stack.\n     *\n     * @param local a local variable identifier, as returned by\n     *        {@link LocalVariablesSorter#newLocal(Type) newLocal()}.\n     */\n    public void loadLocal(final int local) {\n        loadInsn(getLocalType(local), local);\n    }\n\n    /**\n     * Generates the instruction to load the given local variable on the stack.\n     *\n     * @param local a local variable identifier, as returned by\n     *        {@link LocalVariablesSorter#newLocal(Type) newLocal()}.\n     * @param type the type of this local variable.\n     */\n    public void loadLocal(final int local, final Type type) {\n        setLocalType(local, type);\n        loadInsn(type, local);\n    }\n\n    /**\n     * Generates the instruction to store the top stack value in the given local\n     * variable.\n     *\n     * @param local a local variable identifier, as returned by\n     *        {@link LocalVariablesSorter#newLocal(Type) newLocal()}.\n     */\n    public void storeLocal(final int local) {\n        storeInsn(getLocalType(local), local);\n    }\n\n    /**\n     * Generates the instruction to store the top stack value in the given local\n     * variable.\n     *\n     * @param local a local variable identifier, as returned by\n     *        {@link LocalVariablesSorter#newLocal(Type) newLocal()}.\n     * @param type the type of this local variable.\n     */\n    public void storeLocal(final int local, final Type type) {\n        setLocalType(local, type);\n        storeInsn(type, local);\n    }\n\n    /**\n     * Generates the instruction to load an element from an array.\n     *\n     * @param type the type of the array element to be loaded.\n     */\n    public void arrayLoad(final Type type) {\n        mv.visitInsn(type.getOpcode(Opcodes.IALOAD));\n    }\n\n    /**\n     * Generates the instruction to store an element in an array.\n     *\n     * @param type the type of the array element to be stored.\n     */\n    public void arrayStore(final Type type) {\n        mv.visitInsn(type.getOpcode(Opcodes.IASTORE));\n    }\n\n    // ------------------------------------------------------------------------\n    // Instructions to manage the stack\n    // ------------------------------------------------------------------------\n    /**\n     * Generates a POP instruction.\n     */\n    public void pop() {\n        mv.visitInsn(Opcodes.POP);\n    }\n\n    /**\n     * Generates a POP2 instruction.\n     */\n    public void pop2() {\n        mv.visitInsn(Opcodes.POP2);\n    }\n\n    /**\n     * Generates a DUP instruction.\n     */\n    public void dup() {\n        mv.visitInsn(Opcodes.DUP);\n    }\n\n    /**\n     * Generates a DUP2 instruction.\n     */\n    public void dup2() {\n        mv.visitInsn(Opcodes.DUP2);\n    }\n\n    /**\n     * Generates a DUP_X1 instruction.\n     */\n    public void dupX1() {\n        mv.visitInsn(Opcodes.DUP_X1);\n    }\n\n    /**\n     * Generates a DUP_X2 instruction.\n     */\n    public void dupX2() {\n        mv.visitInsn(Opcodes.DUP_X2);\n    }\n\n    /**\n     * Generates a DUP2_X1 instruction.\n     */\n    public void dup2X1() {\n        mv.visitInsn(Opcodes.DUP2_X1);\n    }\n\n    /**\n     * Generates a DUP2_X2 instruction.\n     */\n    public void dup2X2() {\n        mv.visitInsn(Opcodes.DUP2_X2);\n    }\n\n    /**\n     * Generates a SWAP instruction.\n     */\n    public void swap() {\n        mv.visitInsn(Opcodes.SWAP);\n    }\n\n    /**\n     * Generates the instructions to swap the top two stack values.\n     *\n     * @param prev type of the top - 1 stack value.\n     * @param type type of the top stack value.\n     */\n    public void swap(final Type prev, final Type type) {\n        if (type.getSize() == 1) {\n            if (prev.getSize() == 1) {\n                // same as dupX1(), pop();\n                swap();\n            } else {\n                dupX2();\n                pop();\n            }\n        } else {\n            if (prev.getSize() == 1) {\n                dup2X1();\n                pop2();\n            } else {\n                dup2X2();\n                pop2();\n            }\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Instructions to do mathematical and logical operations\n    // ------------------------------------------------------------------------\n    /**\n     * Generates the instruction to do the specified mathematical or logical\n     * operation.\n     *\n     * @param op a mathematical or logical operation. Must be one of ADD, SUB,\n     *        MUL, DIV, REM, NEG, SHL, SHR, USHR, AND, OR, XOR.\n     * @param type the type of the operand(s) for this operation.\n     */\n    public void math(final int op, final Type type) {\n        mv.visitInsn(type.getOpcode(op));\n    }\n\n    /**\n     * Generates the instructions to compute the bitwise negation of the top\n     * stack value.\n     */\n    public void not() {\n        mv.visitInsn(Opcodes.ICONST_1);\n        mv.visitInsn(Opcodes.IXOR);\n    }\n\n    /**\n     * Generates the instruction to increment the given local variable.\n     *\n     * @param local the local variable to be incremented.\n     * @param amount the amount by which the local variable must be incremented.\n     */\n    public void iinc(final int local, final int amount) {\n        mv.visitIincInsn(local, amount);\n    }\n\n    /**\n     * Generates the instructions to cast a numerical value from one type to\n     * another.\n     *\n     * @param from the type of the top stack value\n     * @param to the type into which this value must be cast.\n     */\n    public void cast(final Type from, final Type to) {\n        if (from != to) {\n            if (from == Type.DOUBLE_TYPE) {\n                if (to == Type.FLOAT_TYPE) {\n                    mv.visitInsn(Opcodes.D2F);\n                } else if (to == Type.LONG_TYPE) {\n                    mv.visitInsn(Opcodes.D2L);\n                } else {\n                    mv.visitInsn(Opcodes.D2I);\n                    cast(Type.INT_TYPE, to);\n                }\n            } else if (from == Type.FLOAT_TYPE) {\n                if (to == Type.DOUBLE_TYPE) {\n                    mv.visitInsn(Opcodes.F2D);\n                } else if (to == Type.LONG_TYPE) {\n                    mv.visitInsn(Opcodes.F2L);\n                } else {\n                    mv.visitInsn(Opcodes.F2I);\n                    cast(Type.INT_TYPE, to);\n                }\n            } else if (from == Type.LONG_TYPE) {\n                if (to == Type.DOUBLE_TYPE) {\n                    mv.visitInsn(Opcodes.L2D);\n                } else if (to == Type.FLOAT_TYPE) {\n                    mv.visitInsn(Opcodes.L2F);\n                } else {\n                    mv.visitInsn(Opcodes.L2I);\n                    cast(Type.INT_TYPE, to);\n                }\n            } else {\n                if (to == Type.BYTE_TYPE) {\n                    mv.visitInsn(Opcodes.I2B);\n                } else if (to == Type.CHAR_TYPE) {\n                    mv.visitInsn(Opcodes.I2C);\n                } else if (to == Type.DOUBLE_TYPE) {\n                    mv.visitInsn(Opcodes.I2D);\n                } else if (to == Type.FLOAT_TYPE) {\n                    mv.visitInsn(Opcodes.I2F);\n                } else if (to == Type.LONG_TYPE) {\n                    mv.visitInsn(Opcodes.I2L);\n                } else if (to == Type.SHORT_TYPE) {\n                    mv.visitInsn(Opcodes.I2S);\n                }\n            }\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Instructions to do boxing and unboxing operations\n    // ------------------------------------------------------------------------\n    private static Type getBoxedType(final Type type) {\n        switch(type.getSort()) {\n            case Type.BYTE:\n                return BYTE_TYPE;\n            case Type.BOOLEAN:\n                return BOOLEAN_TYPE;\n            case Type.SHORT:\n                return SHORT_TYPE;\n            case Type.CHAR:\n                return CHARACTER_TYPE;\n            case Type.INT:\n                return INTEGER_TYPE;\n            case Type.FLOAT:\n                return FLOAT_TYPE;\n            case Type.LONG:\n                return LONG_TYPE;\n            case Type.DOUBLE:\n                return DOUBLE_TYPE;\n        }\n        return type;\n    }\n\n    /**\n     * Generates the instructions to box the top stack value. This value is\n     * replaced by its boxed equivalent on top of the stack.\n     *\n     * @param type the type of the top stack value.\n     */\n    public void box(final Type type) {\n        if (type.getSort() == Type.OBJECT || type.getSort() == Type.ARRAY) {\n            return;\n        }\n        if (type == Type.VOID_TYPE) {\n            push((String) null);\n        } else {\n            Type boxed = getBoxedType(type);\n            newInstance(boxed);\n            if (type.getSize() == 2) {\n                // Pp -> Ppo -> oPpo -> ooPpo -> ooPp -> o\n                dupX2();\n                dupX2();\n                pop();\n            } else {\n                // p -> po -> opo -> oop -> o\n                dupX1();\n                swap();\n            }\n            invokeConstructor(boxed, new Method(\"<init>\", Type.VOID_TYPE, new Type[] { type }));\n        }\n    }\n\n    /**\n     * Generates the instructions to box the top stack value using Java 5's\n     * valueOf() method. This value is replaced by its boxed equivalent on top\n     * of the stack.\n     *\n     * @param type the type of the top stack value.\n     * @author Prashant Deva\n     */\n    public void valueOf(final Type type) {\n        if (type.getSort() == Type.OBJECT || type.getSort() == Type.ARRAY) {\n            return;\n        }\n        if (type == Type.VOID_TYPE) {\n            push((String) null);\n        } else {\n            Type boxed = getBoxedType(type);\n            invokeStatic(boxed, new Method(\"valueOf\", boxed, new Type[] { type }));\n        }\n    }\n\n    /**\n     * Generates the instructions to unbox the top stack value. This value is\n     * replaced by its unboxed equivalent on top of the stack.\n     *\n     * @param type the type of the top stack value.\n     */\n    public void unbox(final Type type) {\n        Type t = NUMBER_TYPE;\n        Method sig = null;\n        switch(type.getSort()) {\n            case Type.VOID:\n                return;\n            case Type.CHAR:\n                t = CHARACTER_TYPE;\n                sig = CHAR_VALUE;\n                break;\n            case Type.BOOLEAN:\n                t = BOOLEAN_TYPE;\n                sig = BOOLEAN_VALUE;\n                break;\n            case Type.DOUBLE:\n                sig = DOUBLE_VALUE;\n                break;\n            case Type.FLOAT:\n                sig = FLOAT_VALUE;\n                break;\n            case Type.LONG:\n                sig = LONG_VALUE;\n                break;\n            case Type.INT:\n            case Type.SHORT:\n            case Type.BYTE:\n                sig = INT_VALUE;\n        }\n        if (sig == null) {\n            checkCast(type);\n        } else {\n            checkCast(t);\n            invokeVirtual(t, sig);\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Instructions to jump to other instructions\n    // ------------------------------------------------------------------------\n    /**\n     * Creates a new {@link Label}.\n     *\n     * @return a new {@link Label}.\n     */\n    public Label newLabel() {\n        return new Label();\n    }\n\n    /**\n     * Marks the current code position with the given label.\n     *\n     * @param label a label.\n     */\n    public void mark(final Label label) {\n        mv.visitLabel(label);\n    }\n\n    /**\n     * Marks the current code position with a new label.\n     *\n     * @return the label that was created to mark the current code position.\n     */\n    public Label mark() {\n        Label label = new Label();\n        mv.visitLabel(label);\n        return label;\n    }\n\n    /**\n     * Generates the instructions to jump to a label based on the comparison of\n     * the top two stack values.\n     *\n     * @param type the type of the top two stack values.\n     * @param mode how these values must be compared. One of EQ, NE, LT, GE, GT,\n     *        LE.\n     * @param label where to jump if the comparison result is <tt>true</tt>.\n     */\n    public void ifCmp(final Type type, final int mode, final Label label) {\n        switch(type.getSort()) {\n            case Type.LONG:\n                mv.visitInsn(Opcodes.LCMP);\n                break;\n            case Type.DOUBLE:\n                mv.visitInsn(mode == GE || mode == GT ? Opcodes.DCMPG : Opcodes.DCMPL);\n                break;\n            case Type.FLOAT:\n                mv.visitInsn(mode == GE || mode == GT ? Opcodes.FCMPG : Opcodes.FCMPL);\n                break;\n            case Type.ARRAY:\n            case Type.OBJECT:\n                switch(mode) {\n                    case EQ:\n                        mv.visitJumpInsn(Opcodes.IF_ACMPEQ, label);\n                        return;\n                    case NE:\n                        mv.visitJumpInsn(Opcodes.IF_ACMPNE, label);\n                        return;\n                }\n                throw new IllegalArgumentException(\"Bad comparison for type \" + type);\n            default:\n                int intOp = -1;\n                switch(mode) {\n                    case EQ:\n                        intOp = Opcodes.IF_ICMPEQ;\n                        break;\n                    case NE:\n                        intOp = Opcodes.IF_ICMPNE;\n                        break;\n                    case GE:\n                        intOp = Opcodes.IF_ICMPGE;\n                        break;\n                    case LT:\n                        intOp = Opcodes.IF_ICMPLT;\n                        break;\n                    case LE:\n                        intOp = Opcodes.IF_ICMPLE;\n                        break;\n                    case GT:\n                        intOp = Opcodes.IF_ICMPGT;\n                        break;\n                }\n                mv.visitJumpInsn(intOp, label);\n                return;\n        }\n        mv.visitJumpInsn(mode, label);\n    }\n\n    /**\n     * Generates the instructions to jump to a label based on the comparison of\n     * the top two integer stack values.\n     *\n     * @param mode how these values must be compared. One of EQ, NE, LT, GE, GT,\n     *        LE.\n     * @param label where to jump if the comparison result is <tt>true</tt>.\n     */\n    public void ifICmp(final int mode, final Label label) {\n        ifCmp(Type.INT_TYPE, mode, label);\n    }\n\n    /**\n     * Generates the instructions to jump to a label based on the comparison of\n     * the top integer stack value with zero.\n     *\n     * @param mode how these values must be compared. One of EQ, NE, LT, GE, GT,\n     *        LE.\n     * @param label where to jump if the comparison result is <tt>true</tt>.\n     */\n    public void ifZCmp(final int mode, final Label label) {\n        mv.visitJumpInsn(mode, label);\n    }\n\n    /**\n     * Generates the instruction to jump to the given label if the top stack\n     * value is null.\n     *\n     * @param label where to jump if the condition is <tt>true</tt>.\n     */\n    public void ifNull(final Label label) {\n        mv.visitJumpInsn(Opcodes.IFNULL, label);\n    }\n\n    /**\n     * Generates the instruction to jump to the given label if the top stack\n     * value is not null.\n     *\n     * @param label where to jump if the condition is <tt>true</tt>.\n     */\n    public void ifNonNull(final Label label) {\n        mv.visitJumpInsn(Opcodes.IFNONNULL, label);\n    }\n\n    /**\n     * Generates the instruction to jump to the given label.\n     *\n     * @param label where to jump if the condition is <tt>true</tt>.\n     */\n    public void goTo(final Label label) {\n        mv.visitJumpInsn(Opcodes.GOTO, label);\n    }\n\n    /**\n     * Generates a RET instruction.\n     *\n     * @param local a local variable identifier, as returned by\n     *        {@link LocalVariablesSorter#newLocal(Type) newLocal()}.\n     */\n    public void ret(final int local) {\n        mv.visitVarInsn(Opcodes.RET, local);\n    }\n\n    /**\n     * Generates the instructions for a switch statement.\n     *\n     * @param keys the switch case keys.\n     * @param generator a generator to generate the code for the switch cases.\n     */\n    public void tableSwitch(final int[] keys, final TableSwitchGenerator generator) {\n        float density;\n        if (keys.length == 0) {\n            density = 0;\n        } else {\n            density = (float) keys.length / (keys[keys.length - 1] - keys[0] + 1);\n        }\n        tableSwitch(keys, generator, density >= 0.5f);\n    }\n\n    /**\n     * Generates the instructions for a switch statement.\n     *\n     * @param keys the switch case keys.\n     * @param generator a generator to generate the code for the switch cases.\n     * @param useTable <tt>true</tt> to use a TABLESWITCH instruction, or\n     *        <tt>false</tt> to use a LOOKUPSWITCH instruction.\n     */\n    public void tableSwitch(final int[] keys, final TableSwitchGenerator generator, final boolean useTable) {\n        for (int i = 1; i < keys.length; ++i) {\n            if (keys[i] < keys[i - 1]) {\n                throw new IllegalArgumentException(\"keys must be sorted ascending\");\n            }\n        }\n        Label def = newLabel();\n        Label end = newLabel();\n        if (keys.length > 0) {\n            int len = keys.length;\n            int min = keys[0];\n            int max = keys[len - 1];\n            int range = max - min + 1;\n            if (useTable) {\n                Label[] labels = new Label[range];\n                Arrays.fill(labels, def);\n                for (int i = 0; i < len; ++i) {\n                    labels[keys[i] - min] = newLabel();\n                }\n                mv.visitTableSwitchInsn(min, max, def, labels);\n                for (int i = 0; i < range; ++i) {\n                    Label label = labels[i];\n                    if (label != def) {\n                        mark(label);\n                        generator.generateCase(i + min, end);\n                    }\n                }\n            } else {\n                Label[] labels = new Label[len];\n                for (int i = 0; i < len; ++i) {\n                    labels[i] = newLabel();\n                }\n                mv.visitLookupSwitchInsn(def, keys, labels);\n                for (int i = 0; i < len; ++i) {\n                    mark(labels[i]);\n                    generator.generateCase(keys[i], end);\n                }\n            }\n        }\n        mark(def);\n        generator.generateDefault();\n        mark(end);\n    }\n\n    /**\n     * Generates the instruction to return the top stack value to the caller.\n     */\n    public void returnValue() {\n        mv.visitInsn(returnType.getOpcode(Opcodes.IRETURN));\n    }\n\n    // ------------------------------------------------------------------------\n    // Instructions to load and store fields\n    // ------------------------------------------------------------------------\n    /**\n     * Generates a get field or set field instruction.\n     *\n     * @param opcode the instruction's opcode.\n     * @param ownerType the class in which the field is defined.\n     * @param name the name of the field.\n     * @param fieldType the type of the field.\n     */\n    private void fieldInsn(final int opcode, final Type ownerType, final String name, final Type fieldType) {\n        mv.visitFieldInsn(opcode, ownerType.getInternalName(), name, fieldType.getDescriptor());\n    }\n\n    /**\n     * Generates the instruction to push the value of a static field on the\n     * stack.\n     *\n     * @param owner the class in which the field is defined.\n     * @param name the name of the field.\n     * @param type the type of the field.\n     */\n    public void getStatic(final Type owner, final String name, final Type type) {\n        fieldInsn(Opcodes.GETSTATIC, owner, name, type);\n    }\n\n    /**\n     * Generates the instruction to store the top stack value in a static field.\n     *\n     * @param owner the class in which the field is defined.\n     * @param name the name of the field.\n     * @param type the type of the field.\n     */\n    public void putStatic(final Type owner, final String name, final Type type) {\n        fieldInsn(Opcodes.PUTSTATIC, owner, name, type);\n    }\n\n    /**\n     * Generates the instruction to push the value of a non static field on the\n     * stack.\n     *\n     * @param owner the class in which the field is defined.\n     * @param name the name of the field.\n     * @param type the type of the field.\n     */\n    public void getField(final Type owner, final String name, final Type type) {\n        fieldInsn(Opcodes.GETFIELD, owner, name, type);\n    }\n\n    /**\n     * Generates the instruction to store the top stack value in a non static\n     * field.\n     *\n     * @param owner the class in which the field is defined.\n     * @param name the name of the field.\n     * @param type the type of the field.\n     */\n    public void putField(final Type owner, final String name, final Type type) {\n        fieldInsn(Opcodes.PUTFIELD, owner, name, type);\n    }\n\n    // ------------------------------------------------------------------------\n    // Instructions to invoke methods\n    // ------------------------------------------------------------------------\n    /**\n     * Generates an invoke method instruction.\n     *\n     * @param opcode the instruction's opcode.\n     * @param type the class in which the method is defined.\n     * @param method the method to be invoked.\n     */\n    private void invokeInsn(final int opcode, final Type type, final Method method) {\n        String owner = type.getSort() == Type.ARRAY ? type.getDescriptor() : type.getInternalName();\n        mv.visitMethodInsn(opcode, owner, method.getName(), method.getDescriptor());\n    }\n\n    /**\n     * Generates the instruction to invoke a normal method.\n     *\n     * @param owner the class in which the method is defined.\n     * @param method the method to be invoked.\n     */\n    public void invokeVirtual(final Type owner, final Method method) {\n        invokeInsn(Opcodes.INVOKEVIRTUAL, owner, method);\n    }\n\n    /**\n     * Generates the instruction to invoke a constructor.\n     *\n     * @param type the class in which the constructor is defined.\n     * @param method the constructor to be invoked.\n     */\n    public void invokeConstructor(final Type type, final Method method) {\n        invokeInsn(Opcodes.INVOKESPECIAL, type, method);\n    }\n\n    /**\n     * Generates the instruction to invoke a static method.\n     *\n     * @param owner the class in which the method is defined.\n     * @param method the method to be invoked.\n     */\n    public void invokeStatic(final Type owner, final Method method) {\n        invokeInsn(Opcodes.INVOKESTATIC, owner, method);\n    }\n\n    /**\n     * Generates the instruction to invoke an interface method.\n     *\n     * @param owner the class in which the method is defined.\n     * @param method the method to be invoked.\n     */\n    public void invokeInterface(final Type owner, final Method method) {\n        invokeInsn(Opcodes.INVOKEINTERFACE, owner, method);\n    }\n\n    /**\n     * Generates the instruction to invoke a dynamic method.\n     *\n     * @param method the method to be invoked.\n     */\n    public void invokeDynamic(final Method method) {\n        invokeInsn(Opcodes.INVOKEDYNAMIC, Type.getObjectType(Opcodes.INVOKEDYNAMIC_OWNER), method);\n    }\n\n    // ------------------------------------------------------------------------\n    // Instructions to create objects and arrays\n    // ------------------------------------------------------------------------\n    /**\n     * Generates a type dependent instruction.\n     *\n     * @param opcode the instruction's opcode.\n     * @param type the instruction's operand.\n     */\n    private void typeInsn(final int opcode, final Type type) {\n        mv.visitTypeInsn(opcode, type.getInternalName());\n    }\n\n    /**\n     * Generates the instruction to create a new object.\n     *\n     * @param type the class of the object to be created.\n     */\n    public void newInstance(final Type type) {\n        typeInsn(Opcodes.NEW, type);\n    }\n\n    /**\n     * Generates the instruction to create a new array.\n     *\n     * @param type the type of the array elements.\n     */\n    public void newArray(final Type type) {\n        int typ;\n        switch(type.getSort()) {\n            case Type.BOOLEAN:\n                typ = Opcodes.T_BOOLEAN;\n                break;\n            case Type.CHAR:\n                typ = Opcodes.T_CHAR;\n                break;\n            case Type.BYTE:\n                typ = Opcodes.T_BYTE;\n                break;\n            case Type.SHORT:\n                typ = Opcodes.T_SHORT;\n                break;\n            case Type.INT:\n                typ = Opcodes.T_INT;\n                break;\n            case Type.FLOAT:\n                typ = Opcodes.T_FLOAT;\n                break;\n            case Type.LONG:\n                typ = Opcodes.T_LONG;\n                break;\n            case Type.DOUBLE:\n                typ = Opcodes.T_DOUBLE;\n                break;\n            default:\n                typeInsn(Opcodes.ANEWARRAY, type);\n                return;\n        }\n        mv.visitIntInsn(Opcodes.NEWARRAY, typ);\n    }\n\n    // ------------------------------------------------------------------------\n    // Miscelaneous instructions\n    // ------------------------------------------------------------------------\n    /**\n     * Generates the instruction to compute the length of an array.\n     */\n    public void arrayLength() {\n        mv.visitInsn(Opcodes.ARRAYLENGTH);\n    }\n\n    /**\n     * Generates the instruction to throw an exception.\n     */\n    public void throwException() {\n        mv.visitInsn(Opcodes.ATHROW);\n    }\n\n    /**\n     * Generates the instructions to create and throw an exception. The\n     * exception class must have a constructor with a single String argument.\n     *\n     * @param type the class of the exception to be thrown.\n     * @param msg the detailed message of the exception.\n     */\n    public void throwException(final Type type, final String msg) {\n        newInstance(type);\n        dup();\n        push(msg);\n        invokeConstructor(type, Method.getMethod(\"void <init> (String)\"));\n        throwException();\n    }\n\n    /**\n     * Generates the instruction to check that the top stack value is of the\n     * given type.\n     *\n     * @param type a class or interface type.\n     */\n    public void checkCast(final Type type) {\n        if (!type.equals(OBJECT_TYPE)) {\n            typeInsn(Opcodes.CHECKCAST, type);\n        }\n    }\n\n    /**\n     * Generates the instruction to test if the top stack value is of the given\n     * type.\n     *\n     * @param type a class or interface type.\n     */\n    public void instanceOf(final Type type) {\n        typeInsn(Opcodes.INSTANCEOF, type);\n    }\n\n    /**\n     * Generates the instruction to get the monitor of the top stack value.\n     */\n    public void monitorEnter() {\n        mv.visitInsn(Opcodes.MONITORENTER);\n    }\n\n    /**\n     * Generates the instruction to release the monitor of the top stack value.\n     */\n    public void monitorExit() {\n        mv.visitInsn(Opcodes.MONITOREXIT);\n    }\n\n    // ------------------------------------------------------------------------\n    // Non instructions\n    // ------------------------------------------------------------------------\n    /**\n     * Marks the end of the visited method.\n     */\n    public void endMethod() {\n        if ((access & Opcodes.ACC_ABSTRACT) == 0) {\n            mv.visitMaxs(0, 0);\n        }\n        mv.visitEnd();\n    }\n\n    /**\n     * Marks the start of an exception handler.\n     *\n     * @param start beginning of the exception handler's scope (inclusive).\n     * @param end end of the exception handler's scope (exclusive).\n     * @param exception internal name of the type of exceptions handled by the\n     *        handler.\n     */\n    public void catchException(final Label start, final Label end, final Type exception) {\n        if (exception == null) {\n            mv.visitTryCatchBlock(start, end, mark(), null);\n        } else {\n            mv.visitTryCatchBlock(start, end, mark(), exception.getInternalName());\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/commons/GeneratorAdapterTest0.java",
		"test_prompt": "// GeneratorAdapterTest0.java\npackage org.objectweb.asm.jip.commons;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport org.objectweb.asm.jip.ClassVisitor;\nimport org.objectweb.asm.jip.Label;\nimport org.objectweb.asm.jip.MethodVisitor;\nimport org.objectweb.asm.jip.Opcodes;\nimport org.objectweb.asm.jip.Type;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GeneratorAdapter}.\n* It contains ten unit test cases for the {@link GeneratorAdapter#newLabel()} method.\n*/\nclass GeneratorAdapterTest0 {"
	},
	{
		"original_code": "// GeneratorAdapter.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip.commons;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport org.objectweb.asm.jip.ClassVisitor;\nimport org.objectweb.asm.jip.Label;\nimport org.objectweb.asm.jip.MethodVisitor;\nimport org.objectweb.asm.jip.Opcodes;\nimport org.objectweb.asm.jip.Type;\n\n/**\n * A {@link org.objectweb.asm.jip.MethodAdapter} with convenient methods to generate\n * code. For example, using this adapter, the class below\n *\n * <pre>\n * public class Example {\n *     public static void main(String[] args) {\n *         System.out.println(&quot;Hello world!&quot;);\n *     }\n * }\n * </pre>\n *\n * can be generated as follows:\n *\n * <pre>\n * ClassWriter cw = new ClassWriter(true);\n * cw.visit(V1_1, ACC_PUBLIC, &quot;Example&quot;, null, &quot;java/lang/Object&quot;, null);\n *\n * Method m = Method.getMethod(&quot;void &lt;init&gt; ()&quot;);\n * GeneratorAdapter mg = new GeneratorAdapter(ACC_PUBLIC, m, null, null, cw);\n * mg.loadThis();\n * mg.invokeConstructor(Type.getType(Object.class), m);\n * mg.returnValue();\n * mg.endMethod();\n *\n * m = Method.getMethod(&quot;void main (String[])&quot;);\n * mg = new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC, m, null, null, cw);\n * mg.getStatic(Type.getType(System.class), &quot;out&quot;, Type.getType(PrintStream.class));\n * mg.push(&quot;Hello world!&quot;);\n * mg.invokeVirtual(Type.getType(PrintStream.class), Method.getMethod(&quot;void println (String)&quot;));\n * mg.returnValue();\n * mg.endMethod();\n *\n * cw.visitEnd();\n * </pre>\n *\n * @author Juozas Baliuka\n * @author Chris Nokleberg\n * @author Eric Bruneton\n */\npublic class GeneratorAdapter extends LocalVariablesSorter {\n\n    private static final String CLDESC = \"Ljava/lang/Class;\";\n\n    private static final Type BYTE_TYPE = Type.getObjectType(\"java/lang/Byte\");\n\n    private static final Type BOOLEAN_TYPE = Type.getObjectType(\"java/lang/Boolean\");\n\n    private static final Type SHORT_TYPE = Type.getObjectType(\"java/lang/Short\");\n\n    private static final Type CHARACTER_TYPE = Type.getObjectType(\"java/lang/Character\");\n\n    private static final Type INTEGER_TYPE = Type.getObjectType(\"java/lang/Integer\");\n\n    private static final Type FLOAT_TYPE = Type.getObjectType(\"java/lang/Float\");\n\n    private static final Type LONG_TYPE = Type.getObjectType(\"java/lang/Long\");\n\n    private static final Type DOUBLE_TYPE = Type.getObjectType(\"java/lang/Double\");\n\n    private static final Type NUMBER_TYPE = Type.getObjectType(\"java/lang/Number\");\n\n    private static final Type OBJECT_TYPE = Type.getObjectType(\"java/lang/Object\");\n\n    private static final Method BOOLEAN_VALUE = Method.getMethod(\"boolean booleanValue()\");\n\n    private static final Method CHAR_VALUE = Method.getMethod(\"char charValue()\");\n\n    private static final Method INT_VALUE = Method.getMethod(\"int intValue()\");\n\n    private static final Method FLOAT_VALUE = Method.getMethod(\"float floatValue()\");\n\n    private static final Method LONG_VALUE = Method.getMethod(\"long longValue()\");\n\n    private static final Method DOUBLE_VALUE = Method.getMethod(\"double doubleValue()\");\n\n    /**\n     * Constant for the {@link #math math} method.\n     */\n    public static final int ADD = Opcodes.IADD;\n\n    /**\n     * Constant for the {@link #math math} method.\n     */\n    public static final int SUB = Opcodes.ISUB;\n\n    /**\n     * Constant for the {@link #math math} method.\n     */\n    public static final int MUL = Opcodes.IMUL;\n\n    /**\n     * Constant for the {@link #math math} method.\n     */\n    public static final int DIV = Opcodes.IDIV;\n\n    /**\n     * Constant for the {@link #math math} method.\n     */\n    public static final int REM = Opcodes.IREM;\n\n    /**\n     * Constant for the {@link #math math} method.\n     */\n    public static final int NEG = Opcodes.INEG;\n\n    /**\n     * Constant for the {@link #math math} method.\n     */\n    public static final int SHL = Opcodes.ISHL;\n\n    /**\n     * Constant for the {@link #math math} method.\n     */\n    public static final int SHR = Opcodes.ISHR;\n\n    /**\n     * Constant for the {@link #math math} method.\n     */\n    public static final int USHR = Opcodes.IUSHR;\n\n    /**\n     * Constant for the {@link #math math} method.\n     */\n    public static final int AND = Opcodes.IAND;\n\n    /**\n     * Constant for the {@link #math math} method.\n     */\n    public static final int OR = Opcodes.IOR;\n\n    /**\n     * Constant for the {@link #math math} method.\n     */\n    public static final int XOR = Opcodes.IXOR;\n\n    /**\n     * Constant for the {@link #ifCmp ifCmp} method.\n     */\n    public static final int EQ = Opcodes.IFEQ;\n\n    /**\n     * Constant for the {@link #ifCmp ifCmp} method.\n     */\n    public static final int NE = Opcodes.IFNE;\n\n    /**\n     * Constant for the {@link #ifCmp ifCmp} method.\n     */\n    public static final int LT = Opcodes.IFLT;\n\n    /**\n     * Constant for the {@link #ifCmp ifCmp} method.\n     */\n    public static final int GE = Opcodes.IFGE;\n\n    /**\n     * Constant for the {@link #ifCmp ifCmp} method.\n     */\n    public static final int GT = Opcodes.IFGT;\n\n    /**\n     * Constant for the {@link #ifCmp ifCmp} method.\n     */\n    public static final int LE = Opcodes.IFLE;\n\n    /**\n     * Access flags of the method visited by this adapter.\n     */\n    private final int access;\n\n    /**\n     * Return type of the method visited by this adapter.\n     */\n    private final Type returnType;\n\n    /**\n     * Argument types of the method visited by this adapter.\n     */\n    private final Type[] argumentTypes;\n\n    /**\n     * Types of the local variables of the method visited by this adapter.\n     */\n    private final List localTypes = new ArrayList();\n\n    /**\n     * Creates a new {@link GeneratorAdapter}.\n     *\n     * @param mv the method visitor to which this adapter delegates calls.\n     * @param access the method's access flags (see {@link Opcodes}).\n     * @param name the method's name.\n     * @param desc the method's descriptor (see {@link Type Type}).\n     */\n    public GeneratorAdapter(final MethodVisitor mv, final int access, final String name, final String desc) {\n        super(access, desc, mv);\n        this.access = access;\n        this.returnType = Type.getReturnType(desc);\n        this.argumentTypes = Type.getArgumentTypes(desc);\n    }\n\n    /**\n     * Creates a new {@link GeneratorAdapter}.\n     *\n     * @param access access flags of the adapted method.\n     * @param method the adapted method.\n     * @param mv the method visitor to which this adapter delegates calls.\n     */\n    public GeneratorAdapter(final int access, final Method method, final MethodVisitor mv) {\n        super(access, method.getDescriptor(), mv);\n        this.access = access;\n        this.returnType = method.getReturnType();\n        this.argumentTypes = method.getArgumentTypes();\n    }\n\n    /**\n     * Creates a new {@link GeneratorAdapter}.\n     *\n     * @param access access flags of the adapted method.\n     * @param method the adapted method.\n     * @param signature the signature of the adapted method (may be\n     *        <tt>null</tt>).\n     * @param exceptions the exceptions thrown by the adapted method (may be\n     *        <tt>null</tt>).\n     * @param cv the class visitor to which this adapter delegates calls.\n     */\n    public GeneratorAdapter(final int access, final Method method, final String signature, final Type[] exceptions, final ClassVisitor cv) {\n        this(access, method, cv.visitMethod(access, method.getName(), method.getDescriptor(), signature, getInternalNames(exceptions)));\n    }\n\n    /**\n     * Returns the internal names of the given types.\n     *\n     * @param types a set of types.\n     * @return the internal names of the given types.\n     */\n    private static String[] getInternalNames(final Type[] types) {\n        if (types == null) {\n            return null;\n        }\n        String[] names = new String[types.length];\n        for (int i = 0; i < names.length; ++i) {\n            names[i] = types[i].getInternalName();\n        }\n        return names;\n    }\n\n    // ------------------------------------------------------------------------\n    // Instructions to push constants on the stack\n    // ------------------------------------------------------------------------\n    /**\n     * Generates the instruction to push the given value on the stack.\n     *\n     * @param value the value to be pushed on the stack.\n     */\n    public void push(final boolean value) {\n        push(value ? 1 : 0);\n    }\n\n    /**\n     * Generates the instruction to push the given value on the stack.\n     *\n     * @param value the value to be pushed on the stack.\n     */\n    public void push(final int value) {\n        if (value >= -1 && value <= 5) {\n            mv.visitInsn(Opcodes.ICONST_0 + value);\n        } else if (value >= Byte.MIN_VALUE && value <= Byte.MAX_VALUE) {\n            mv.visitIntInsn(Opcodes.BIPUSH, value);\n        } else if (value >= Short.MIN_VALUE && value <= Short.MAX_VALUE) {\n            mv.visitIntInsn(Opcodes.SIPUSH, value);\n        } else {\n            mv.visitLdcInsn(new Integer(value));\n        }\n    }\n\n    /**\n     * Generates the instruction to push the given value on the stack.\n     *\n     * @param value the value to be pushed on the stack.\n     */\n    public void push(final long value) {\n        if (value == 0L || value == 1L) {\n            mv.visitInsn(Opcodes.LCONST_0 + (int) value);\n        } else {\n            mv.visitLdcInsn(new Long(value));\n        }\n    }\n\n    /**\n     * Generates the instruction to push the given value on the stack.\n     *\n     * @param value the value to be pushed on the stack.\n     */\n    public void push(final float value) {\n        int bits = Float.floatToIntBits(value);\n        if (bits == 0L || bits == 0x3f800000 || bits == 0x40000000) {\n            // 0..2\n            mv.visitInsn(Opcodes.FCONST_0 + (int) value);\n        } else {\n            mv.visitLdcInsn(new Float(value));\n        }\n    }\n\n    /**\n     * Generates the instruction to push the given value on the stack.\n     *\n     * @param value the value to be pushed on the stack.\n     */\n    public void push(final double value) {\n        long bits = Double.doubleToLongBits(value);\n        if (bits == 0L || bits == 0x3ff0000000000000L) {\n            // +0.0d and 1.0d\n            mv.visitInsn(Opcodes.DCONST_0 + (int) value);\n        } else {\n            mv.visitLdcInsn(new Double(value));\n        }\n    }\n\n    /**\n     * Generates the instruction to push the given value on the stack.\n     *\n     * @param value the value to be pushed on the stack. May be <tt>null</tt>.\n     */\n    public void push(final String value) {\n        if (value == null) {\n            mv.visitInsn(Opcodes.ACONST_NULL);\n        } else {\n            mv.visitLdcInsn(value);\n        }\n    }\n\n    /**\n     * Generates the instruction to push the given value on the stack.\n     *\n     * @param value the value to be pushed on the stack.\n     */\n    public void push(final Type value) {\n        if (value == null) {\n            mv.visitInsn(Opcodes.ACONST_NULL);\n        } else {\n            switch(value.getSort()) {\n                case Type.BOOLEAN:\n                    mv.visitFieldInsn(Opcodes.GETSTATIC, \"java/lang/Boolean\", \"TYPE\", CLDESC);\n                    break;\n                case Type.CHAR:\n                    mv.visitFieldInsn(Opcodes.GETSTATIC, \"java/lang/Character\", \"TYPE\", CLDESC);\n                    break;\n                case Type.BYTE:\n                    mv.visitFieldInsn(Opcodes.GETSTATIC, \"java/lang/Byte\", \"TYPE\", CLDESC);\n                    break;\n                case Type.SHORT:\n                    mv.visitFieldInsn(Opcodes.GETSTATIC, \"java/lang/Short\", \"TYPE\", CLDESC);\n                    break;\n                case Type.INT:\n                    mv.visitFieldInsn(Opcodes.GETSTATIC, \"java/lang/Integer\", \"TYPE\", CLDESC);\n                    break;\n                case Type.FLOAT:\n                    mv.visitFieldInsn(Opcodes.GETSTATIC, \"java/lang/Float\", \"TYPE\", CLDESC);\n                    break;\n                case Type.LONG:\n                    mv.visitFieldInsn(Opcodes.GETSTATIC, \"java/lang/Long\", \"TYPE\", CLDESC);\n                    break;\n                case Type.DOUBLE:\n                    mv.visitFieldInsn(Opcodes.GETSTATIC, \"java/lang/Double\", \"TYPE\", CLDESC);\n                    break;\n                default:\n                    mv.visitLdcInsn(value);\n            }\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Instructions to load and store method arguments\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the index of the given method argument in the frame's local\n     * variables array.\n     *\n     * @param arg the index of a method argument.\n     * @return the index of the given method argument in the frame's local\n     *         variables array.\n     */\n    private int getArgIndex(final int arg) {\n        int index = (access & Opcodes.ACC_STATIC) == 0 ? 1 : 0;\n        for (int i = 0; i < arg; i++) {\n            index += argumentTypes[i].getSize();\n        }\n        return index;\n    }\n\n    /**\n     * Generates the instruction to push a local variable on the stack.\n     *\n     * @param type the type of the local variable to be loaded.\n     * @param index an index in the frame's local variables array.\n     */\n    private void loadInsn(final Type type, final int index) {\n        mv.visitVarInsn(type.getOpcode(Opcodes.ILOAD), index);\n    }\n\n    /**\n     * Generates the instruction to store the top stack value in a local\n     * variable.\n     *\n     * @param type the type of the local variable to be stored.\n     * @param index an index in the frame's local variables array.\n     */\n    private void storeInsn(final Type type, final int index) {\n        mv.visitVarInsn(type.getOpcode(Opcodes.ISTORE), index);\n    }\n\n    /**\n     * Generates the instruction to load 'this' on the stack.\n     */\n    public void loadThis() {\n        if ((access & Opcodes.ACC_STATIC) != 0) {\n            throw new IllegalStateException(\"no 'this' pointer within static method\");\n        }\n        mv.visitVarInsn(Opcodes.ALOAD, 0);\n    }\n\n    /**\n     * Generates the instruction to load the given method argument on the stack.\n     *\n     * @param arg the index of a method argument.\n     */\n    public void loadArg(final int arg) {\n        loadInsn(argumentTypes[arg], getArgIndex(arg));\n    }\n\n    /**\n     * Generates the instructions to load the given method arguments on the\n     * stack.\n     *\n     * @param arg the index of the first method argument to be loaded.\n     * @param count the number of method arguments to be loaded.\n     */\n    public void loadArgs(final int arg, final int count) {\n        int index = getArgIndex(arg);\n        for (int i = 0; i < count; ++i) {\n            Type t = argumentTypes[arg + i];\n            loadInsn(t, index);\n            index += t.getSize();\n        }\n    }\n\n    /**\n     * Generates the instructions to load all the method arguments on the stack.\n     */\n    public void loadArgs() {\n        loadArgs(0, argumentTypes.length);\n    }\n\n    /**\n     * Generates the instructions to load all the method arguments on the stack,\n     * as a single object array.\n     */\n    public void loadArgArray() {\n        push(argumentTypes.length);\n        newArray(OBJECT_TYPE);\n        for (int i = 0; i < argumentTypes.length; i++) {\n            dup();\n            push(i);\n            loadArg(i);\n            box(argumentTypes[i]);\n            arrayStore(OBJECT_TYPE);\n        }\n    }\n\n    /**\n     * Generates the instruction to store the top stack value in the given\n     * method argument.\n     *\n     * @param arg the index of a method argument.\n     */\n    public void storeArg(final int arg) {\n        storeInsn(argumentTypes[arg], getArgIndex(arg));\n    }\n\n    // ------------------------------------------------------------------------\n    // Instructions to load and store local variables\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the type of the given local variable.\n     *\n     * @param local a local variable identifier, as returned by\n     *        {@link LocalVariablesSorter#newLocal(Type) newLocal()}.\n     * @return the type of the given local variable.\n     */\n    public Type getLocalType(final int local) {\n        return (Type) localTypes.get(local - firstLocal);\n    }\n\n    protected void setLocalType(final int local, final Type type) {\n        int index = local - firstLocal;\n        while (localTypes.size() < index + 1) {\n            localTypes.add(null);\n        }\n        localTypes.set(index, type);\n    }\n\n    /**\n     * Generates the instruction to load the given local variable on the stack.\n     *\n     * @param local a local variable identifier, as returned by\n     *        {@link LocalVariablesSorter#newLocal(Type) newLocal()}.\n     */\n    public void loadLocal(final int local) {\n        loadInsn(getLocalType(local), local);\n    }\n\n    /**\n     * Generates the instruction to load the given local variable on the stack.\n     *\n     * @param local a local variable identifier, as returned by\n     *        {@link LocalVariablesSorter#newLocal(Type) newLocal()}.\n     * @param type the type of this local variable.\n     */\n    public void loadLocal(final int local, final Type type) {\n        setLocalType(local, type);\n        loadInsn(type, local);\n    }\n\n    /**\n     * Generates the instruction to store the top stack value in the given local\n     * variable.\n     *\n     * @param local a local variable identifier, as returned by\n     *        {@link LocalVariablesSorter#newLocal(Type) newLocal()}.\n     */\n    public void storeLocal(final int local) {\n        storeInsn(getLocalType(local), local);\n    }\n\n    /**\n     * Generates the instruction to store the top stack value in the given local\n     * variable.\n     *\n     * @param local a local variable identifier, as returned by\n     *        {@link LocalVariablesSorter#newLocal(Type) newLocal()}.\n     * @param type the type of this local variable.\n     */\n    public void storeLocal(final int local, final Type type) {\n        setLocalType(local, type);\n        storeInsn(type, local);\n    }\n\n    /**\n     * Generates the instruction to load an element from an array.\n     *\n     * @param type the type of the array element to be loaded.\n     */\n    public void arrayLoad(final Type type) {\n        mv.visitInsn(type.getOpcode(Opcodes.IALOAD));\n    }\n\n    /**\n     * Generates the instruction to store an element in an array.\n     *\n     * @param type the type of the array element to be stored.\n     */\n    public void arrayStore(final Type type) {\n        mv.visitInsn(type.getOpcode(Opcodes.IASTORE));\n    }\n\n    // ------------------------------------------------------------------------\n    // Instructions to manage the stack\n    // ------------------------------------------------------------------------\n    /**\n     * Generates a POP instruction.\n     */\n    public void pop() {\n        mv.visitInsn(Opcodes.POP);\n    }\n\n    /**\n     * Generates a POP2 instruction.\n     */\n    public void pop2() {\n        mv.visitInsn(Opcodes.POP2);\n    }\n\n    /**\n     * Generates a DUP instruction.\n     */\n    public void dup() {\n        mv.visitInsn(Opcodes.DUP);\n    }\n\n    /**\n     * Generates a DUP2 instruction.\n     */\n    public void dup2() {\n        mv.visitInsn(Opcodes.DUP2);\n    }\n\n    /**\n     * Generates a DUP_X1 instruction.\n     */\n    public void dupX1() {\n        mv.visitInsn(Opcodes.DUP_X1);\n    }\n\n    /**\n     * Generates a DUP_X2 instruction.\n     */\n    public void dupX2() {\n        mv.visitInsn(Opcodes.DUP_X2);\n    }\n\n    /**\n     * Generates a DUP2_X1 instruction.\n     */\n    public void dup2X1() {\n        mv.visitInsn(Opcodes.DUP2_X1);\n    }\n\n    /**\n     * Generates a DUP2_X2 instruction.\n     */\n    public void dup2X2() {\n        mv.visitInsn(Opcodes.DUP2_X2);\n    }\n\n    /**\n     * Generates a SWAP instruction.\n     */\n    public void swap() {\n        mv.visitInsn(Opcodes.SWAP);\n    }\n\n    /**\n     * Generates the instructions to swap the top two stack values.\n     *\n     * @param prev type of the top - 1 stack value.\n     * @param type type of the top stack value.\n     */\n    public void swap(final Type prev, final Type type) {\n        if (type.getSize() == 1) {\n            if (prev.getSize() == 1) {\n                // same as dupX1(), pop();\n                swap();\n            } else {\n                dupX2();\n                pop();\n            }\n        } else {\n            if (prev.getSize() == 1) {\n                dup2X1();\n                pop2();\n            } else {\n                dup2X2();\n                pop2();\n            }\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Instructions to do mathematical and logical operations\n    // ------------------------------------------------------------------------\n    /**\n     * Generates the instruction to do the specified mathematical or logical\n     * operation.\n     *\n     * @param op a mathematical or logical operation. Must be one of ADD, SUB,\n     *        MUL, DIV, REM, NEG, SHL, SHR, USHR, AND, OR, XOR.\n     * @param type the type of the operand(s) for this operation.\n     */\n    public void math(final int op, final Type type) {\n        mv.visitInsn(type.getOpcode(op));\n    }\n\n    /**\n     * Generates the instructions to compute the bitwise negation of the top\n     * stack value.\n     */\n    public void not() {\n        mv.visitInsn(Opcodes.ICONST_1);\n        mv.visitInsn(Opcodes.IXOR);\n    }\n\n    /**\n     * Generates the instruction to increment the given local variable.\n     *\n     * @param local the local variable to be incremented.\n     * @param amount the amount by which the local variable must be incremented.\n     */\n    public void iinc(final int local, final int amount) {\n        mv.visitIincInsn(local, amount);\n    }\n\n    /**\n     * Generates the instructions to cast a numerical value from one type to\n     * another.\n     *\n     * @param from the type of the top stack value\n     * @param to the type into which this value must be cast.\n     */\n    public void cast(final Type from, final Type to) {\n        if (from != to) {\n            if (from == Type.DOUBLE_TYPE) {\n                if (to == Type.FLOAT_TYPE) {\n                    mv.visitInsn(Opcodes.D2F);\n                } else if (to == Type.LONG_TYPE) {\n                    mv.visitInsn(Opcodes.D2L);\n                } else {\n                    mv.visitInsn(Opcodes.D2I);\n                    cast(Type.INT_TYPE, to);\n                }\n            } else if (from == Type.FLOAT_TYPE) {\n                if (to == Type.DOUBLE_TYPE) {\n                    mv.visitInsn(Opcodes.F2D);\n                } else if (to == Type.LONG_TYPE) {\n                    mv.visitInsn(Opcodes.F2L);\n                } else {\n                    mv.visitInsn(Opcodes.F2I);\n                    cast(Type.INT_TYPE, to);\n                }\n            } else if (from == Type.LONG_TYPE) {\n                if (to == Type.DOUBLE_TYPE) {\n                    mv.visitInsn(Opcodes.L2D);\n                } else if (to == Type.FLOAT_TYPE) {\n                    mv.visitInsn(Opcodes.L2F);\n                } else {\n                    mv.visitInsn(Opcodes.L2I);\n                    cast(Type.INT_TYPE, to);\n                }\n            } else {\n                if (to == Type.BYTE_TYPE) {\n                    mv.visitInsn(Opcodes.I2B);\n                } else if (to == Type.CHAR_TYPE) {\n                    mv.visitInsn(Opcodes.I2C);\n                } else if (to == Type.DOUBLE_TYPE) {\n                    mv.visitInsn(Opcodes.I2D);\n                } else if (to == Type.FLOAT_TYPE) {\n                    mv.visitInsn(Opcodes.I2F);\n                } else if (to == Type.LONG_TYPE) {\n                    mv.visitInsn(Opcodes.I2L);\n                } else if (to == Type.SHORT_TYPE) {\n                    mv.visitInsn(Opcodes.I2S);\n                }\n            }\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Instructions to do boxing and unboxing operations\n    // ------------------------------------------------------------------------\n    private static Type getBoxedType(final Type type) {\n        switch(type.getSort()) {\n            case Type.BYTE:\n                return BYTE_TYPE;\n            case Type.BOOLEAN:\n                return BOOLEAN_TYPE;\n            case Type.SHORT:\n                return SHORT_TYPE;\n            case Type.CHAR:\n                return CHARACTER_TYPE;\n            case Type.INT:\n                return INTEGER_TYPE;\n            case Type.FLOAT:\n                return FLOAT_TYPE;\n            case Type.LONG:\n                return LONG_TYPE;\n            case Type.DOUBLE:\n                return DOUBLE_TYPE;\n        }\n        return type;\n    }\n\n    /**\n     * Generates the instructions to box the top stack value. This value is\n     * replaced by its boxed equivalent on top of the stack.\n     *\n     * @param type the type of the top stack value.\n     */\n    public void box(final Type type) {\n        if (type.getSort() == Type.OBJECT || type.getSort() == Type.ARRAY) {\n            return;\n        }\n        if (type == Type.VOID_TYPE) {\n            push((String) null);\n        } else {\n            Type boxed = getBoxedType(type);\n            newInstance(boxed);\n            if (type.getSize() == 2) {\n                // Pp -> Ppo -> oPpo -> ooPpo -> ooPp -> o\n                dupX2();\n                dupX2();\n                pop();\n            } else {\n                // p -> po -> opo -> oop -> o\n                dupX1();\n                swap();\n            }\n            invokeConstructor(boxed, new Method(\"<init>\", Type.VOID_TYPE, new Type[] { type }));\n        }\n    }\n\n    /**\n     * Generates the instructions to box the top stack value using Java 5's\n     * valueOf() method. This value is replaced by its boxed equivalent on top\n     * of the stack.\n     *\n     * @param type the type of the top stack value.\n     * @author Prashant Deva\n     */\n    public void valueOf(final Type type) {\n        if (type.getSort() == Type.OBJECT || type.getSort() == Type.ARRAY) {\n            return;\n        }\n        if (type == Type.VOID_TYPE) {\n            push((String) null);\n        } else {\n            Type boxed = getBoxedType(type);\n            invokeStatic(boxed, new Method(\"valueOf\", boxed, new Type[] { type }));\n        }\n    }\n\n    /**\n     * Generates the instructions to unbox the top stack value. This value is\n     * replaced by its unboxed equivalent on top of the stack.\n     *\n     * @param type the type of the top stack value.\n     */\n    public void unbox(final Type type) {\n        Type t = NUMBER_TYPE;\n        Method sig = null;\n        switch(type.getSort()) {\n            case Type.VOID:\n                return;\n            case Type.CHAR:\n                t = CHARACTER_TYPE;\n                sig = CHAR_VALUE;\n                break;\n            case Type.BOOLEAN:\n                t = BOOLEAN_TYPE;\n                sig = BOOLEAN_VALUE;\n                break;\n            case Type.DOUBLE:\n                sig = DOUBLE_VALUE;\n                break;\n            case Type.FLOAT:\n                sig = FLOAT_VALUE;\n                break;\n            case Type.LONG:\n                sig = LONG_VALUE;\n                break;\n            case Type.INT:\n            case Type.SHORT:\n            case Type.BYTE:\n                sig = INT_VALUE;\n        }\n        if (sig == null) {\n            checkCast(type);\n        } else {\n            checkCast(t);\n            invokeVirtual(t, sig);\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Instructions to jump to other instructions\n    // ------------------------------------------------------------------------\n    /**\n     * Creates a new {@link Label}.\n     *\n     * @return a new {@link Label}.\n     */\n    public Label newLabel() {\n        return new Label();\n    }\n\n    /**\n     * Marks the current code position with the given label.\n     *\n     * @param label a label.\n     */\n    public void mark(final Label label) {\n        mv.visitLabel(label);\n    }\n\n    /**\n     * Marks the current code position with a new label.\n     *\n     * @return the label that was created to mark the current code position.\n     */\n    public Label mark() {\n        Label label = new Label();\n        mv.visitLabel(label);\n        return label;\n    }\n\n    /**\n     * Generates the instructions to jump to a label based on the comparison of\n     * the top two stack values.\n     *\n     * @param type the type of the top two stack values.\n     * @param mode how these values must be compared. One of EQ, NE, LT, GE, GT,\n     *        LE.\n     * @param label where to jump if the comparison result is <tt>true</tt>.\n     */\n    public void ifCmp(final Type type, final int mode, final Label label) {\n        switch(type.getSort()) {\n            case Type.LONG:\n                mv.visitInsn(Opcodes.LCMP);\n                break;\n            case Type.DOUBLE:\n                mv.visitInsn(mode == GE || mode == GT ? Opcodes.DCMPG : Opcodes.DCMPL);\n                break;\n            case Type.FLOAT:\n                mv.visitInsn(mode == GE || mode == GT ? Opcodes.FCMPG : Opcodes.FCMPL);\n                break;\n            case Type.ARRAY:\n            case Type.OBJECT:\n                switch(mode) {\n                    case EQ:\n                        mv.visitJumpInsn(Opcodes.IF_ACMPEQ, label);\n                        return;\n                    case NE:\n                        mv.visitJumpInsn(Opcodes.IF_ACMPNE, label);\n                        return;\n                }\n                throw new IllegalArgumentException(\"Bad comparison for type \" + type);\n            default:\n                int intOp = -1;\n                switch(mode) {\n                    case EQ:\n                        intOp = Opcodes.IF_ICMPEQ;\n                        break;\n                    case NE:\n                        intOp = Opcodes.IF_ICMPNE;\n                        break;\n                    case GE:\n                        intOp = Opcodes.IF_ICMPGE;\n                        break;\n                    case LT:\n                        intOp = Opcodes.IF_ICMPLT;\n                        break;\n                    case LE:\n                        intOp = Opcodes.IF_ICMPLE;\n                        break;\n                    case GT:\n                        intOp = Opcodes.IF_ICMPGT;\n                        break;\n                }\n                mv.visitJumpInsn(intOp, label);\n                return;\n        }\n        mv.visitJumpInsn(mode, label);\n    }\n\n    /**\n     * Generates the instructions to jump to a label based on the comparison of\n     * the top two integer stack values.\n     *\n     * @param mode how these values must be compared. One of EQ, NE, LT, GE, GT,\n     *        LE.\n     * @param label where to jump if the comparison result is <tt>true</tt>.\n     */\n    public void ifICmp(final int mode, final Label label) {\n        ifCmp(Type.INT_TYPE, mode, label);\n    }\n\n    /**\n     * Generates the instructions to jump to a label based on the comparison of\n     * the top integer stack value with zero.\n     *\n     * @param mode how these values must be compared. One of EQ, NE, LT, GE, GT,\n     *        LE.\n     * @param label where to jump if the comparison result is <tt>true</tt>.\n     */\n    public void ifZCmp(final int mode, final Label label) {\n        mv.visitJumpInsn(mode, label);\n    }\n\n    /**\n     * Generates the instruction to jump to the given label if the top stack\n     * value is null.\n     *\n     * @param label where to jump if the condition is <tt>true</tt>.\n     */\n    public void ifNull(final Label label) {\n        mv.visitJumpInsn(Opcodes.IFNULL, label);\n    }\n\n    /**\n     * Generates the instruction to jump to the given label if the top stack\n     * value is not null.\n     *\n     * @param label where to jump if the condition is <tt>true</tt>.\n     */\n    public void ifNonNull(final Label label) {\n        mv.visitJumpInsn(Opcodes.IFNONNULL, label);\n    }\n\n    /**\n     * Generates the instruction to jump to the given label.\n     *\n     * @param label where to jump if the condition is <tt>true</tt>.\n     */\n    public void goTo(final Label label) {\n        mv.visitJumpInsn(Opcodes.GOTO, label);\n    }\n\n    /**\n     * Generates a RET instruction.\n     *\n     * @param local a local variable identifier, as returned by\n     *        {@link LocalVariablesSorter#newLocal(Type) newLocal()}.\n     */\n    public void ret(final int local) {\n        mv.visitVarInsn(Opcodes.RET, local);\n    }\n\n    /**\n     * Generates the instructions for a switch statement.\n     *\n     * @param keys the switch case keys.\n     * @param generator a generator to generate the code for the switch cases.\n     */\n    public void tableSwitch(final int[] keys, final TableSwitchGenerator generator) {\n        float density;\n        if (keys.length == 0) {\n            density = 0;\n        } else {\n            density = (float) keys.length / (keys[keys.length - 1] - keys[0] + 1);\n        }\n        tableSwitch(keys, generator, density >= 0.5f);\n    }\n\n    /**\n     * Generates the instructions for a switch statement.\n     *\n     * @param keys the switch case keys.\n     * @param generator a generator to generate the code for the switch cases.\n     * @param useTable <tt>true</tt> to use a TABLESWITCH instruction, or\n     *        <tt>false</tt> to use a LOOKUPSWITCH instruction.\n     */\n    public void tableSwitch(final int[] keys, final TableSwitchGenerator generator, final boolean useTable) {\n        for (int i = 1; i < keys.length; ++i) {\n            if (keys[i] < keys[i - 1]) {\n                throw new IllegalArgumentException(\"keys must be sorted ascending\");\n            }\n        }\n        Label def = newLabel();\n        Label end = newLabel();\n        if (keys.length > 0) {\n            int len = keys.length;\n            int min = keys[0];\n            int max = keys[len - 1];\n            int range = max - min + 1;\n            if (useTable) {\n                Label[] labels = new Label[range];\n                Arrays.fill(labels, def);\n                for (int i = 0; i < len; ++i) {\n                    labels[keys[i] - min] = newLabel();\n                }\n                mv.visitTableSwitchInsn(min, max, def, labels);\n                for (int i = 0; i < range; ++i) {\n                    Label label = labels[i];\n                    if (label != def) {\n                        mark(label);\n                        generator.generateCase(i + min, end);\n                    }\n                }\n            } else {\n                Label[] labels = new Label[len];\n                for (int i = 0; i < len; ++i) {\n                    labels[i] = newLabel();\n                }\n                mv.visitLookupSwitchInsn(def, keys, labels);\n                for (int i = 0; i < len; ++i) {\n                    mark(labels[i]);\n                    generator.generateCase(keys[i], end);\n                }\n            }\n        }\n        mark(def);\n        generator.generateDefault();\n        mark(end);\n    }\n\n    /**\n     * Generates the instruction to return the top stack value to the caller.\n     */\n    public void returnValue() {\n        mv.visitInsn(returnType.getOpcode(Opcodes.IRETURN));\n    }\n\n    // ------------------------------------------------------------------------\n    // Instructions to load and store fields\n    // ------------------------------------------------------------------------\n    /**\n     * Generates a get field or set field instruction.\n     *\n     * @param opcode the instruction's opcode.\n     * @param ownerType the class in which the field is defined.\n     * @param name the name of the field.\n     * @param fieldType the type of the field.\n     */\n    private void fieldInsn(final int opcode, final Type ownerType, final String name, final Type fieldType) {\n        mv.visitFieldInsn(opcode, ownerType.getInternalName(), name, fieldType.getDescriptor());\n    }\n\n    /**\n     * Generates the instruction to push the value of a static field on the\n     * stack.\n     *\n     * @param owner the class in which the field is defined.\n     * @param name the name of the field.\n     * @param type the type of the field.\n     */\n    public void getStatic(final Type owner, final String name, final Type type) {\n        fieldInsn(Opcodes.GETSTATIC, owner, name, type);\n    }\n\n    /**\n     * Generates the instruction to store the top stack value in a static field.\n     *\n     * @param owner the class in which the field is defined.\n     * @param name the name of the field.\n     * @param type the type of the field.\n     */\n    public void putStatic(final Type owner, final String name, final Type type) {\n        fieldInsn(Opcodes.PUTSTATIC, owner, name, type);\n    }\n\n    /**\n     * Generates the instruction to push the value of a non static field on the\n     * stack.\n     *\n     * @param owner the class in which the field is defined.\n     * @param name the name of the field.\n     * @param type the type of the field.\n     */\n    public void getField(final Type owner, final String name, final Type type) {\n        fieldInsn(Opcodes.GETFIELD, owner, name, type);\n    }\n\n    /**\n     * Generates the instruction to store the top stack value in a non static\n     * field.\n     *\n     * @param owner the class in which the field is defined.\n     * @param name the name of the field.\n     * @param type the type of the field.\n     */\n    public void putField(final Type owner, final String name, final Type type) {\n        fieldInsn(Opcodes.PUTFIELD, owner, name, type);\n    }\n\n    // ------------------------------------------------------------------------\n    // Instructions to invoke methods\n    // ------------------------------------------------------------------------\n    /**\n     * Generates an invoke method instruction.\n     *\n     * @param opcode the instruction's opcode.\n     * @param type the class in which the method is defined.\n     * @param method the method to be invoked.\n     */\n    private void invokeInsn(final int opcode, final Type type, final Method method) {\n        String owner = type.getSort() == Type.ARRAY ? type.getDescriptor() : type.getInternalName();\n        mv.visitMethodInsn(opcode, owner, method.getName(), method.getDescriptor());\n    }\n\n    /**\n     * Generates the instruction to invoke a normal method.\n     *\n     * @param owner the class in which the method is defined.\n     * @param method the method to be invoked.\n     */\n    public void invokeVirtual(final Type owner, final Method method) {\n        invokeInsn(Opcodes.INVOKEVIRTUAL, owner, method);\n    }\n\n    /**\n     * Generates the instruction to invoke a constructor.\n     *\n     * @param type the class in which the constructor is defined.\n     * @param method the constructor to be invoked.\n     */\n    public void invokeConstructor(final Type type, final Method method) {\n        invokeInsn(Opcodes.INVOKESPECIAL, type, method);\n    }\n\n    /**\n     * Generates the instruction to invoke a static method.\n     *\n     * @param owner the class in which the method is defined.\n     * @param method the method to be invoked.\n     */\n    public void invokeStatic(final Type owner, final Method method) {\n        invokeInsn(Opcodes.INVOKESTATIC, owner, method);\n    }\n\n    /**\n     * Generates the instruction to invoke an interface method.\n     *\n     * @param owner the class in which the method is defined.\n     * @param method the method to be invoked.\n     */\n    public void invokeInterface(final Type owner, final Method method) {\n        invokeInsn(Opcodes.INVOKEINTERFACE, owner, method);\n    }\n\n    /**\n     * Generates the instruction to invoke a dynamic method.\n     *\n     * @param method the method to be invoked.\n     */\n    public void invokeDynamic(final Method method) {\n        invokeInsn(Opcodes.INVOKEDYNAMIC, Type.getObjectType(Opcodes.INVOKEDYNAMIC_OWNER), method);\n    }\n\n    // ------------------------------------------------------------------------\n    // Instructions to create objects and arrays\n    // ------------------------------------------------------------------------\n    /**\n     * Generates a type dependent instruction.\n     *\n     * @param opcode the instruction's opcode.\n     * @param type the instruction's operand.\n     */\n    private void typeInsn(final int opcode, final Type type) {\n        mv.visitTypeInsn(opcode, type.getInternalName());\n    }\n\n    /**\n     * Generates the instruction to create a new object.\n     *\n     * @param type the class of the object to be created.\n     */\n    public void newInstance(final Type type) {\n        typeInsn(Opcodes.NEW, type);\n    }\n\n    /**\n     * Generates the instruction to create a new array.\n     *\n     * @param type the type of the array elements.\n     */\n    public void newArray(final Type type) {\n        int typ;\n        switch(type.getSort()) {\n            case Type.BOOLEAN:\n                typ = Opcodes.T_BOOLEAN;\n                break;\n            case Type.CHAR:\n                typ = Opcodes.T_CHAR;\n                break;\n            case Type.BYTE:\n                typ = Opcodes.T_BYTE;\n                break;\n            case Type.SHORT:\n                typ = Opcodes.T_SHORT;\n                break;\n            case Type.INT:\n                typ = Opcodes.T_INT;\n                break;\n            case Type.FLOAT:\n                typ = Opcodes.T_FLOAT;\n                break;\n            case Type.LONG:\n                typ = Opcodes.T_LONG;\n                break;\n            case Type.DOUBLE:\n                typ = Opcodes.T_DOUBLE;\n                break;\n            default:\n                typeInsn(Opcodes.ANEWARRAY, type);\n                return;\n        }\n        mv.visitIntInsn(Opcodes.NEWARRAY, typ);\n    }\n\n    // ------------------------------------------------------------------------\n    // Miscelaneous instructions\n    // ------------------------------------------------------------------------\n    /**\n     * Generates the instruction to compute the length of an array.\n     */\n    public void arrayLength() {\n        mv.visitInsn(Opcodes.ARRAYLENGTH);\n    }\n\n    /**\n     * Generates the instruction to throw an exception.\n     */\n    public void throwException() {\n        mv.visitInsn(Opcodes.ATHROW);\n    }\n\n    /**\n     * Generates the instructions to create and throw an exception. The\n     * exception class must have a constructor with a single String argument.\n     *\n     * @param type the class of the exception to be thrown.\n     * @param msg the detailed message of the exception.\n     */\n    public void throwException(final Type type, final String msg) {\n        newInstance(type);\n        dup();\n        push(msg);\n        invokeConstructor(type, Method.getMethod(\"void <init> (String)\"));\n        throwException();\n    }\n\n    /**\n     * Generates the instruction to check that the top stack value is of the\n     * given type.\n     *\n     * @param type a class or interface type.\n     */\n    public void checkCast(final Type type) {\n        if (!type.equals(OBJECT_TYPE)) {\n            typeInsn(Opcodes.CHECKCAST, type);\n        }\n    }\n\n    /**\n     * Generates the instruction to test if the top stack value is of the given\n     * type.\n     *\n     * @param type a class or interface type.\n     */\n    public void instanceOf(final Type type) {\n        typeInsn(Opcodes.INSTANCEOF, type);\n    }\n\n    /**\n     * Generates the instruction to get the monitor of the top stack value.\n     */\n    public void monitorEnter() {\n        mv.visitInsn(Opcodes.MONITORENTER);\n    }\n\n    /**\n     * Generates the instruction to release the monitor of the top stack value.\n     */\n    public void monitorExit() {\n        mv.visitInsn(Opcodes.MONITOREXIT);\n    }\n\n    // ------------------------------------------------------------------------\n    // Non instructions\n    // ------------------------------------------------------------------------\n    /**\n     * Marks the end of the visited method.\n     */\n    public void endMethod() {\n        if ((access & Opcodes.ACC_ABSTRACT) == 0) {\n            mv.visitMaxs(0, 0);\n        }\n        mv.visitEnd();\n    }\n\n    /**\n     * Marks the start of an exception handler.\n     *\n     * @param start beginning of the exception handler's scope (inclusive).\n     * @param end end of the exception handler's scope (exclusive).\n     * @param exception internal name of the type of exceptions handled by the\n     *        handler.\n     */\n    public void catchException(final Label start, final Label end, final Type exception) {\n        if (exception == null) {\n            mv.visitTryCatchBlock(start, end, mark(), null);\n        } else {\n            mv.visitTryCatchBlock(start, end, mark(), exception.getInternalName());\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/commons/GeneratorAdapterTest1.java",
		"test_prompt": "// GeneratorAdapterTest1.java\npackage org.objectweb.asm.jip.commons;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport org.objectweb.asm.jip.ClassVisitor;\nimport org.objectweb.asm.jip.Label;\nimport org.objectweb.asm.jip.MethodVisitor;\nimport org.objectweb.asm.jip.Opcodes;\nimport org.objectweb.asm.jip.Type;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GeneratorAdapter}.\n* It contains ten unit test cases for the {@link GeneratorAdapter#mark()} method.\n*/\nclass GeneratorAdapterTest1 {"
	},
	{
		"original_code": "// StaticInitMerger.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip.commons;\n\nimport org.objectweb.asm.jip.ClassAdapter;\nimport org.objectweb.asm.jip.ClassVisitor;\nimport org.objectweb.asm.jip.MethodVisitor;\nimport org.objectweb.asm.jip.Opcodes;\n\n/**\n * A {@link ClassAdapter} that merges clinit methods into a single one.\n *\n * @author Eric Bruneton\n */\npublic class StaticInitMerger extends ClassAdapter {\n\n    private String name;\n\n    private MethodVisitor clinit;\n\n    private final String prefix;\n\n    private int counter;\n\n    public StaticInitMerger(final String prefix, final ClassVisitor cv) {\n        super(cv);\n        this.prefix = prefix;\n    }\n\n    public void visit(final int version, final int access, final String name, final String signature, final String superName, final String[] interfaces) {\n        cv.visit(version, access, name, signature, superName, interfaces);\n        this.name = name;\n    }\n\n    public MethodVisitor visitMethod(final int access, final String name, final String desc, final String signature, final String[] exceptions) {\n        MethodVisitor mv;\n        if (\"<clinit>\".equals(name)) {\n            int a = Opcodes.ACC_PRIVATE + Opcodes.ACC_STATIC;\n            String n = prefix + counter++;\n            mv = cv.visitMethod(a, n, desc, signature, exceptions);\n            if (clinit == null) {\n                clinit = cv.visitMethod(a, name, desc, null, null);\n            }\n            clinit.visitMethodInsn(Opcodes.INVOKESTATIC, this.name, n, desc);\n        } else {\n            mv = cv.visitMethod(access, name, desc, signature, exceptions);\n        }\n        return mv;\n    }\n\n    public void visitEnd() {\n        if (clinit != null) {\n            clinit.visitInsn(Opcodes.RETURN);\n            clinit.visitMaxs(0, 0);\n        }\n        cv.visitEnd();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/commons/StaticInitMergerTest.java",
		"test_prompt": "// StaticInitMergerTest.java\npackage org.objectweb.asm.jip.commons;\n\nimport org.objectweb.asm.jip.ClassAdapter;\nimport org.objectweb.asm.jip.ClassVisitor;\nimport org.objectweb.asm.jip.MethodVisitor;\nimport org.objectweb.asm.jip.Opcodes;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StaticInitMerger}.\n* It contains ten unit test cases for the {@link StaticInitMerger#visitMethod(int, String, String, String, String[])} method.\n*/\nclass StaticInitMergerTest {"
	},
	{
		"original_code": "// SerialVersionUIDAdder.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip.commons;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.DataOutput;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.security.MessageDigest;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport org.objectweb.asm.jip.ClassAdapter;\nimport org.objectweb.asm.jip.ClassVisitor;\nimport org.objectweb.asm.jip.FieldVisitor;\nimport org.objectweb.asm.jip.MethodVisitor;\nimport org.objectweb.asm.jip.Opcodes;\n\n/**\n * A {@link ClassAdapter} that adds a serial version unique identifier to a\n * class if missing. Here is typical usage of this class:\n *\n * <pre>\n *   ClassWriter cw = new ClassWriter(...);\n *   ClassVisitor sv = new SerialVersionUIDAdder(cw);\n *   ClassVisitor ca = new MyClassAdapter(sv);\n *   new ClassReader(orginalClass).accept(ca, false);\n * </pre>\n *\n * The SVUID algorithm can be found <a href=\n * \"http://java.sun.com/j2se/1.4.2/docs/guide/serialization/spec/class.html\"\n * >http://java.sun.com/j2se/1.4.2/docs/guide/serialization/spec/class.html</a>:\n *\n * <pre>\n * The serialVersionUID is computed using the signature of a stream of bytes\n * that reflect the class definition. The National Institute of Standards and\n * Technology (NIST) Secure Hash Algorithm (SHA-1) is used to compute a\n * signature for the stream. The first two 32-bit quantities are used to form a\n * 64-bit hash. A java.lang.DataOutputStream is used to convert primitive data\n * types to a sequence of bytes. The values input to the stream are defined by\n * the Java Virtual Machine (VM) specification for classes.\n *\n * The sequence of items in the stream is as follows:\n *\n * 1. The class name written using UTF encoding.\n * 2. The class modifiers written as a 32-bit integer.\n * 3. The name of each interface sorted by name written using UTF encoding.\n * 4. For each field of the class sorted by field name (except private static\n * and private transient fields):\n * 1. The name of the field in UTF encoding.\n * 2. The modifiers of the field written as a 32-bit integer.\n * 3. The descriptor of the field in UTF encoding\n * 5. If a class initializer exists, write out the following:\n * 1. The name of the method, &lt;clinit&gt;, in UTF encoding.\n * 2. The modifier of the method, java.lang.reflect.Modifier.STATIC,\n * written as a 32-bit integer.\n * 3. The descriptor of the method, ()V, in UTF encoding.\n * 6. For each non-private constructor sorted by method name and signature:\n * 1. The name of the method, &lt;init&gt;, in UTF encoding.\n * 2. The modifiers of the method written as a 32-bit integer.\n * 3. The descriptor of the method in UTF encoding.\n * 7. For each non-private method sorted by method name and signature:\n * 1. The name of the method in UTF encoding.\n * 2. The modifiers of the method written as a 32-bit integer.\n * 3. The descriptor of the method in UTF encoding.\n * 8. The SHA-1 algorithm is executed on the stream of bytes produced by\n * DataOutputStream and produces five 32-bit values sha[0..4].\n *\n * 9. The hash value is assembled from the first and second 32-bit values of\n * the SHA-1 message digest. If the result of the message digest, the five\n * 32-bit words H0 H1 H2 H3 H4, is in an array of five int values named\n * sha, the hash value would be computed as follows:\n *\n * long hash = ((sha[0] &gt;&gt;&gt; 24) &amp; 0xFF) |\n * ((sha[0] &gt;&gt;&gt; 16) &amp; 0xFF) &lt;&lt; 8 |\n * ((sha[0] &gt;&gt;&gt; 8) &amp; 0xFF) &lt;&lt; 16 |\n * ((sha[0] &gt;&gt;&gt; 0) &amp; 0xFF) &lt;&lt; 24 |\n * ((sha[1] &gt;&gt;&gt; 24) &amp; 0xFF) &lt;&lt; 32 |\n * ((sha[1] &gt;&gt;&gt; 16) &amp; 0xFF) &lt;&lt; 40 |\n * ((sha[1] &gt;&gt;&gt; 8) &amp; 0xFF) &lt;&lt; 48 |\n * ((sha[1] &gt;&gt;&gt; 0) &amp; 0xFF) &lt;&lt; 56;\n * </pre>\n *\n * @author Rajendra Inamdar, Vishal Vishnoi\n */\npublic class SerialVersionUIDAdder extends ClassAdapter {\n\n    /**\n     * Flag that indicates if we need to compute SVUID.\n     */\n    protected boolean computeSVUID;\n\n    /**\n     * Set to true if the class already has SVUID.\n     */\n    protected boolean hasSVUID;\n\n    /**\n     * Classes access flags.\n     */\n    protected int access;\n\n    /**\n     * Internal name of the class\n     */\n    protected String name;\n\n    /**\n     * Interfaces implemented by the class.\n     */\n    protected String[] interfaces;\n\n    /**\n     * Collection of fields. (except private static and private transient\n     * fields)\n     */\n    protected Collection svuidFields;\n\n    /**\n     * Set to true if the class has static initializer.\n     */\n    protected boolean hasStaticInitializer;\n\n    /**\n     * Collection of non-private constructors.\n     */\n    protected Collection svuidConstructors;\n\n    /**\n     * Collection of non-private methods.\n     */\n    protected Collection svuidMethods;\n\n    /**\n     * Creates a new {@link SerialVersionUIDAdder}.\n     *\n     * @param cv a {@link ClassVisitor} to which this visitor will delegate\n     *        calls.\n     */\n    public SerialVersionUIDAdder(final ClassVisitor cv) {\n        super(cv);\n        svuidFields = new ArrayList();\n        svuidConstructors = new ArrayList();\n        svuidMethods = new ArrayList();\n    }\n\n    // ------------------------------------------------------------------------\n    // Overriden methods\n    // ------------------------------------------------------------------------\n    /*\n     * Visit class header and get class name, access , and interfaces\n     * information (step 1,2, and 3) for SVUID computation.\n     */\n    public void visit(final int version, final int access, final String name, final String signature, final String superName, final String[] interfaces) {\n        computeSVUID = (access & Opcodes.ACC_INTERFACE) == 0;\n        if (computeSVUID) {\n            this.name = name;\n            this.access = access;\n            this.interfaces = interfaces;\n        }\n        super.visit(version, access, name, signature, superName, interfaces);\n    }\n\n    /*\n     * Visit the methods and get constructor and method information (step 5 and\n     * 7). Also determine if there is a class initializer (step 6).\n     */\n    public MethodVisitor visitMethod(final int access, final String name, final String desc, final String signature, final String[] exceptions) {\n        if (computeSVUID) {\n            if (\"<clinit>\".equals(name)) {\n                hasStaticInitializer = true;\n            }\n            /*\n             * Remembers non private constructors and methods for SVUID\n             * computation For constructor and method modifiers, only the\n             * ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC, ACC_FINAL,\n             * ACC_SYNCHRONIZED, ACC_NATIVE, ACC_ABSTRACT and ACC_STRICT flags\n             * are used.\n             */\n            int mods = access & (Opcodes.ACC_PUBLIC | Opcodes.ACC_PRIVATE | Opcodes.ACC_PROTECTED | Opcodes.ACC_STATIC | Opcodes.ACC_FINAL | Opcodes.ACC_SYNCHRONIZED | Opcodes.ACC_NATIVE | Opcodes.ACC_ABSTRACT | Opcodes.ACC_STRICT);\n            // all non private methods\n            if ((access & Opcodes.ACC_PRIVATE) == 0) {\n                if (\"<init>\".equals(name)) {\n                    svuidConstructors.add(new Item(name, mods, desc));\n                } else if (!\"<clinit>\".equals(name)) {\n                    svuidMethods.add(new Item(name, mods, desc));\n                }\n            }\n        }\n        return cv.visitMethod(access, name, desc, signature, exceptions);\n    }\n\n    /*\n     * Gets class field information for step 4 of the algorithm. Also determines\n     * if the class already has a SVUID.\n     */\n    public FieldVisitor visitField(final int access, final String name, final String desc, final String signature, final Object value) {\n        if (computeSVUID) {\n            if (\"serialVersionUID\".equals(name)) {\n                // since the class already has SVUID, we won't be computing it.\n                computeSVUID = false;\n                hasSVUID = true;\n            }\n            /*\n             * Remember field for SVUID computation For field modifiers, only\n             * the ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC,\n             * ACC_FINAL, ACC_VOLATILE, and ACC_TRANSIENT flags are used when\n             * computing serialVersionUID values.\n             */\n            if ((access & Opcodes.ACC_PRIVATE) == 0 || (access & (Opcodes.ACC_STATIC | Opcodes.ACC_TRANSIENT)) == 0) {\n                int mods = access & (Opcodes.ACC_PUBLIC | Opcodes.ACC_PRIVATE | Opcodes.ACC_PROTECTED | Opcodes.ACC_STATIC | Opcodes.ACC_FINAL | Opcodes.ACC_VOLATILE | Opcodes.ACC_TRANSIENT);\n                svuidFields.add(new Item(name, mods, desc));\n            }\n        }\n        return super.visitField(access, name, desc, signature, value);\n    }\n\n    /**\n     * Handle a bizarre special case. Nested classes (static classes declared\n     * inside another class) that are protected have their access bit set to\n     * public in their class files to deal with some odd reflection situation.\n     * Our SVUID computation must do as the JVM does and ignore access bits in\n     * the class file in favor of the access bits InnerClass attribute.\n     */\n    public void visitInnerClass(final String aname, final String outerName, final String innerName, final int attr_access) {\n        if ((name != null) && name.equals(aname)) {\n            this.access = attr_access;\n        }\n        super.visitInnerClass(aname, outerName, innerName, attr_access);\n    }\n\n    /*\n     * Add the SVUID if class doesn't have one\n     */\n    public void visitEnd() {\n        // compute SVUID and add it to the class\n        if (computeSVUID && !hasSVUID) {\n            try {\n                cv.visitField(Opcodes.ACC_FINAL + Opcodes.ACC_STATIC, \"serialVersionUID\", \"J\", null, new Long(computeSVUID()));\n            } catch (Throwable e) {\n                throw new RuntimeException(\"Error while computing SVUID for \" + name, e);\n            }\n        }\n        super.visitEnd();\n    }\n\n    // ------------------------------------------------------------------------\n    // Utility methods\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the value of SVUID if the class doesn't have one already. Please\n     * note that 0 is returned if the class already has SVUID, thus use\n     * <code>isHasSVUID</code> to determine if the class already had an SVUID.\n     *\n     * @return Returns the serial version UID\n     */\n    protected long computeSVUID() throws IOException {\n        ByteArrayOutputStream bos;\n        DataOutputStream dos = null;\n        long svuid = 0;\n        try {\n            bos = new ByteArrayOutputStream();\n            dos = new DataOutputStream(bos);\n            /*\n             * 1. The class name written using UTF encoding.\n             */\n            dos.writeUTF(name.replace('/', '.'));\n            /*\n             * 2. The class modifiers written as a 32-bit integer.\n             */\n            dos.writeInt(access & (Opcodes.ACC_PUBLIC | Opcodes.ACC_FINAL | Opcodes.ACC_INTERFACE | Opcodes.ACC_ABSTRACT));\n            /*\n             * 3. The name of each interface sorted by name written using UTF\n             * encoding.\n             */\n            Arrays.sort(interfaces);\n            for (int i = 0; i < interfaces.length; i++) {\n                dos.writeUTF(interfaces[i].replace('/', '.'));\n            }\n            /*\n             * 4. For each field of the class sorted by field name (except\n             * private static and private transient fields):\n             * \n             * 1. The name of the field in UTF encoding. 2. The modifiers of the\n             * field written as a 32-bit integer. 3. The descriptor of the field\n             * in UTF encoding\n             * \n             * Note that field signatures are not dot separated. Method and\n             * constructor signatures are dot separated. Go figure...\n             */\n            writeItems(svuidFields, dos, false);\n            /*\n             * 5. If a class initializer exists, write out the following: 1. The\n             * name of the method, <clinit>, in UTF encoding. 2. The modifier of\n             * the method, java.lang.reflect.Modifier.STATIC, written as a\n             * 32-bit integer. 3. The descriptor of the method, ()V, in UTF\n             * encoding.\n             */\n            if (hasStaticInitializer) {\n                dos.writeUTF(\"<clinit>\");\n                dos.writeInt(Opcodes.ACC_STATIC);\n                dos.writeUTF(\"()V\");\n            }\n            // if..\n            /*\n             * 6. For each non-private constructor sorted by method name and\n             * signature: 1. The name of the method, <init>, in UTF encoding. 2.\n             * The modifiers of the method written as a 32-bit integer. 3. The\n             * descriptor of the method in UTF encoding.\n             */\n            writeItems(svuidConstructors, dos, true);\n            /*\n             * 7. For each non-private method sorted by method name and\n             * signature: 1. The name of the method in UTF encoding. 2. The\n             * modifiers of the method written as a 32-bit integer. 3. The\n             * descriptor of the method in UTF encoding.\n             */\n            writeItems(svuidMethods, dos, true);\n            dos.flush();\n            /*\n             * 8. The SHA-1 algorithm is executed on the stream of bytes\n             * produced by DataOutputStream and produces five 32-bit values\n             * sha[0..4].\n             */\n            byte[] hashBytes = computeSHAdigest(bos.toByteArray());\n            /*\n             * 9. The hash value is assembled from the first and second 32-bit\n             * values of the SHA-1 message digest. If the result of the message\n             * digest, the five 32-bit words H0 H1 H2 H3 H4, is in an array of\n             * five int values named sha, the hash value would be computed as\n             * follows:\n             * \n             * long hash = ((sha[0] >>> 24) & 0xFF) | ((sha[0] >>> 16) & 0xFF) <<\n             * 8 | ((sha[0] >>> 8) & 0xFF) << 16 | ((sha[0] >>> 0) & 0xFF) <<\n             * 24 | ((sha[1] >>> 24) & 0xFF) << 32 | ((sha[1] >>> 16) & 0xFF) <<\n             * 40 | ((sha[1] >>> 8) & 0xFF) << 48 | ((sha[1] >>> 0) & 0xFF) <<\n             * 56;\n             */\n            for (int i = Math.min(hashBytes.length, 8) - 1; i >= 0; i--) {\n                svuid = (svuid << 8) | (hashBytes[i] & 0xFF);\n            }\n        } finally {\n            // close the stream (if open)\n            if (dos != null) {\n                dos.close();\n            }\n        }\n        return svuid;\n    }\n\n    /**\n     * Returns the SHA-1 message digest of the given value.\n     *\n     * @param value the value whose SHA message digest must be computed.\n     * @return the SHA-1 message digest of the given value.\n     */\n    protected byte[] computeSHAdigest(final byte[] value) {\n        try {\n            return MessageDigest.getInstance(\"SHA\").digest(value);\n        } catch (Exception e) {\n            throw new UnsupportedOperationException(e.toString());\n        }\n    }\n\n    /**\n     * Sorts the items in the collection and writes it to the data output stream\n     *\n     * @param itemCollection collection of items\n     * @param dos a <code>DataOutputStream</code> value\n     * @param dotted a <code>boolean</code> value\n     * @exception IOException if an error occurs\n     */\n    private static void writeItems(final Collection itemCollection, final DataOutput dos, final boolean dotted) throws IOException {\n        int size = itemCollection.size();\n        Item[] items = (Item[]) itemCollection.toArray(new Item[size]);\n        Arrays.sort(items);\n        for (int i = 0; i < size; i++) {\n            dos.writeUTF(items[i].name);\n            dos.writeInt(items[i].access);\n            dos.writeUTF(dotted ? items[i].desc.replace('/', '.') : items[i].desc);\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Inner classes\n    // ------------------------------------------------------------------------\n    static class Item implements Comparable {\n\n        final String name;\n\n        final int access;\n\n        final String desc;\n\n        Item(final String name, final int access, final String desc) {\n            this.name = name;\n            this.access = access;\n            this.desc = desc;\n        }\n\n        public int compareTo(final Object o) {\n            Item other = (Item) o;\n            int retVal = name.compareTo(other.name);\n            if (retVal == 0) {\n                retVal = desc.compareTo(other.desc);\n            }\n            return retVal;\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/commons/SerialVersionUIDAdderTest0.java",
		"test_prompt": "// SerialVersionUIDAdderTest0.java\npackage org.objectweb.asm.jip.commons;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.DataOutput;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.security.MessageDigest;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport org.objectweb.asm.jip.ClassAdapter;\nimport org.objectweb.asm.jip.ClassVisitor;\nimport org.objectweb.asm.jip.FieldVisitor;\nimport org.objectweb.asm.jip.MethodVisitor;\nimport org.objectweb.asm.jip.Opcodes;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SerialVersionUIDAdder}.\n* It contains ten unit test cases for the {@link SerialVersionUIDAdder#visitMethod(int, String, String, String, String[])} method.\n*/\nclass SerialVersionUIDAdderTest0 {"
	},
	{
		"original_code": "// SerialVersionUIDAdder.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip.commons;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.DataOutput;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.security.MessageDigest;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport org.objectweb.asm.jip.ClassAdapter;\nimport org.objectweb.asm.jip.ClassVisitor;\nimport org.objectweb.asm.jip.FieldVisitor;\nimport org.objectweb.asm.jip.MethodVisitor;\nimport org.objectweb.asm.jip.Opcodes;\n\n/**\n * A {@link ClassAdapter} that adds a serial version unique identifier to a\n * class if missing. Here is typical usage of this class:\n *\n * <pre>\n *   ClassWriter cw = new ClassWriter(...);\n *   ClassVisitor sv = new SerialVersionUIDAdder(cw);\n *   ClassVisitor ca = new MyClassAdapter(sv);\n *   new ClassReader(orginalClass).accept(ca, false);\n * </pre>\n *\n * The SVUID algorithm can be found <a href=\n * \"http://java.sun.com/j2se/1.4.2/docs/guide/serialization/spec/class.html\"\n * >http://java.sun.com/j2se/1.4.2/docs/guide/serialization/spec/class.html</a>:\n *\n * <pre>\n * The serialVersionUID is computed using the signature of a stream of bytes\n * that reflect the class definition. The National Institute of Standards and\n * Technology (NIST) Secure Hash Algorithm (SHA-1) is used to compute a\n * signature for the stream. The first two 32-bit quantities are used to form a\n * 64-bit hash. A java.lang.DataOutputStream is used to convert primitive data\n * types to a sequence of bytes. The values input to the stream are defined by\n * the Java Virtual Machine (VM) specification for classes.\n *\n * The sequence of items in the stream is as follows:\n *\n * 1. The class name written using UTF encoding.\n * 2. The class modifiers written as a 32-bit integer.\n * 3. The name of each interface sorted by name written using UTF encoding.\n * 4. For each field of the class sorted by field name (except private static\n * and private transient fields):\n * 1. The name of the field in UTF encoding.\n * 2. The modifiers of the field written as a 32-bit integer.\n * 3. The descriptor of the field in UTF encoding\n * 5. If a class initializer exists, write out the following:\n * 1. The name of the method, &lt;clinit&gt;, in UTF encoding.\n * 2. The modifier of the method, java.lang.reflect.Modifier.STATIC,\n * written as a 32-bit integer.\n * 3. The descriptor of the method, ()V, in UTF encoding.\n * 6. For each non-private constructor sorted by method name and signature:\n * 1. The name of the method, &lt;init&gt;, in UTF encoding.\n * 2. The modifiers of the method written as a 32-bit integer.\n * 3. The descriptor of the method in UTF encoding.\n * 7. For each non-private method sorted by method name and signature:\n * 1. The name of the method in UTF encoding.\n * 2. The modifiers of the method written as a 32-bit integer.\n * 3. The descriptor of the method in UTF encoding.\n * 8. The SHA-1 algorithm is executed on the stream of bytes produced by\n * DataOutputStream and produces five 32-bit values sha[0..4].\n *\n * 9. The hash value is assembled from the first and second 32-bit values of\n * the SHA-1 message digest. If the result of the message digest, the five\n * 32-bit words H0 H1 H2 H3 H4, is in an array of five int values named\n * sha, the hash value would be computed as follows:\n *\n * long hash = ((sha[0] &gt;&gt;&gt; 24) &amp; 0xFF) |\n * ((sha[0] &gt;&gt;&gt; 16) &amp; 0xFF) &lt;&lt; 8 |\n * ((sha[0] &gt;&gt;&gt; 8) &amp; 0xFF) &lt;&lt; 16 |\n * ((sha[0] &gt;&gt;&gt; 0) &amp; 0xFF) &lt;&lt; 24 |\n * ((sha[1] &gt;&gt;&gt; 24) &amp; 0xFF) &lt;&lt; 32 |\n * ((sha[1] &gt;&gt;&gt; 16) &amp; 0xFF) &lt;&lt; 40 |\n * ((sha[1] &gt;&gt;&gt; 8) &amp; 0xFF) &lt;&lt; 48 |\n * ((sha[1] &gt;&gt;&gt; 0) &amp; 0xFF) &lt;&lt; 56;\n * </pre>\n *\n * @author Rajendra Inamdar, Vishal Vishnoi\n */\npublic class SerialVersionUIDAdder extends ClassAdapter {\n\n    /**\n     * Flag that indicates if we need to compute SVUID.\n     */\n    protected boolean computeSVUID;\n\n    /**\n     * Set to true if the class already has SVUID.\n     */\n    protected boolean hasSVUID;\n\n    /**\n     * Classes access flags.\n     */\n    protected int access;\n\n    /**\n     * Internal name of the class\n     */\n    protected String name;\n\n    /**\n     * Interfaces implemented by the class.\n     */\n    protected String[] interfaces;\n\n    /**\n     * Collection of fields. (except private static and private transient\n     * fields)\n     */\n    protected Collection svuidFields;\n\n    /**\n     * Set to true if the class has static initializer.\n     */\n    protected boolean hasStaticInitializer;\n\n    /**\n     * Collection of non-private constructors.\n     */\n    protected Collection svuidConstructors;\n\n    /**\n     * Collection of non-private methods.\n     */\n    protected Collection svuidMethods;\n\n    /**\n     * Creates a new {@link SerialVersionUIDAdder}.\n     *\n     * @param cv a {@link ClassVisitor} to which this visitor will delegate\n     *        calls.\n     */\n    public SerialVersionUIDAdder(final ClassVisitor cv) {\n        super(cv);\n        svuidFields = new ArrayList();\n        svuidConstructors = new ArrayList();\n        svuidMethods = new ArrayList();\n    }\n\n    // ------------------------------------------------------------------------\n    // Overriden methods\n    // ------------------------------------------------------------------------\n    /*\n     * Visit class header and get class name, access , and interfaces\n     * information (step 1,2, and 3) for SVUID computation.\n     */\n    public void visit(final int version, final int access, final String name, final String signature, final String superName, final String[] interfaces) {\n        computeSVUID = (access & Opcodes.ACC_INTERFACE) == 0;\n        if (computeSVUID) {\n            this.name = name;\n            this.access = access;\n            this.interfaces = interfaces;\n        }\n        super.visit(version, access, name, signature, superName, interfaces);\n    }\n\n    /*\n     * Visit the methods and get constructor and method information (step 5 and\n     * 7). Also determine if there is a class initializer (step 6).\n     */\n    public MethodVisitor visitMethod(final int access, final String name, final String desc, final String signature, final String[] exceptions) {\n        if (computeSVUID) {\n            if (\"<clinit>\".equals(name)) {\n                hasStaticInitializer = true;\n            }\n            /*\n             * Remembers non private constructors and methods for SVUID\n             * computation For constructor and method modifiers, only the\n             * ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC, ACC_FINAL,\n             * ACC_SYNCHRONIZED, ACC_NATIVE, ACC_ABSTRACT and ACC_STRICT flags\n             * are used.\n             */\n            int mods = access & (Opcodes.ACC_PUBLIC | Opcodes.ACC_PRIVATE | Opcodes.ACC_PROTECTED | Opcodes.ACC_STATIC | Opcodes.ACC_FINAL | Opcodes.ACC_SYNCHRONIZED | Opcodes.ACC_NATIVE | Opcodes.ACC_ABSTRACT | Opcodes.ACC_STRICT);\n            // all non private methods\n            if ((access & Opcodes.ACC_PRIVATE) == 0) {\n                if (\"<init>\".equals(name)) {\n                    svuidConstructors.add(new Item(name, mods, desc));\n                } else if (!\"<clinit>\".equals(name)) {\n                    svuidMethods.add(new Item(name, mods, desc));\n                }\n            }\n        }\n        return cv.visitMethod(access, name, desc, signature, exceptions);\n    }\n\n    /*\n     * Gets class field information for step 4 of the algorithm. Also determines\n     * if the class already has a SVUID.\n     */\n    public FieldVisitor visitField(final int access, final String name, final String desc, final String signature, final Object value) {\n        if (computeSVUID) {\n            if (\"serialVersionUID\".equals(name)) {\n                // since the class already has SVUID, we won't be computing it.\n                computeSVUID = false;\n                hasSVUID = true;\n            }\n            /*\n             * Remember field for SVUID computation For field modifiers, only\n             * the ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC,\n             * ACC_FINAL, ACC_VOLATILE, and ACC_TRANSIENT flags are used when\n             * computing serialVersionUID values.\n             */\n            if ((access & Opcodes.ACC_PRIVATE) == 0 || (access & (Opcodes.ACC_STATIC | Opcodes.ACC_TRANSIENT)) == 0) {\n                int mods = access & (Opcodes.ACC_PUBLIC | Opcodes.ACC_PRIVATE | Opcodes.ACC_PROTECTED | Opcodes.ACC_STATIC | Opcodes.ACC_FINAL | Opcodes.ACC_VOLATILE | Opcodes.ACC_TRANSIENT);\n                svuidFields.add(new Item(name, mods, desc));\n            }\n        }\n        return super.visitField(access, name, desc, signature, value);\n    }\n\n    /**\n     * Handle a bizarre special case. Nested classes (static classes declared\n     * inside another class) that are protected have their access bit set to\n     * public in their class files to deal with some odd reflection situation.\n     * Our SVUID computation must do as the JVM does and ignore access bits in\n     * the class file in favor of the access bits InnerClass attribute.\n     */\n    public void visitInnerClass(final String aname, final String outerName, final String innerName, final int attr_access) {\n        if ((name != null) && name.equals(aname)) {\n            this.access = attr_access;\n        }\n        super.visitInnerClass(aname, outerName, innerName, attr_access);\n    }\n\n    /*\n     * Add the SVUID if class doesn't have one\n     */\n    public void visitEnd() {\n        // compute SVUID and add it to the class\n        if (computeSVUID && !hasSVUID) {\n            try {\n                cv.visitField(Opcodes.ACC_FINAL + Opcodes.ACC_STATIC, \"serialVersionUID\", \"J\", null, new Long(computeSVUID()));\n            } catch (Throwable e) {\n                throw new RuntimeException(\"Error while computing SVUID for \" + name, e);\n            }\n        }\n        super.visitEnd();\n    }\n\n    // ------------------------------------------------------------------------\n    // Utility methods\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the value of SVUID if the class doesn't have one already. Please\n     * note that 0 is returned if the class already has SVUID, thus use\n     * <code>isHasSVUID</code> to determine if the class already had an SVUID.\n     *\n     * @return Returns the serial version UID\n     */\n    protected long computeSVUID() throws IOException {\n        ByteArrayOutputStream bos;\n        DataOutputStream dos = null;\n        long svuid = 0;\n        try {\n            bos = new ByteArrayOutputStream();\n            dos = new DataOutputStream(bos);\n            /*\n             * 1. The class name written using UTF encoding.\n             */\n            dos.writeUTF(name.replace('/', '.'));\n            /*\n             * 2. The class modifiers written as a 32-bit integer.\n             */\n            dos.writeInt(access & (Opcodes.ACC_PUBLIC | Opcodes.ACC_FINAL | Opcodes.ACC_INTERFACE | Opcodes.ACC_ABSTRACT));\n            /*\n             * 3. The name of each interface sorted by name written using UTF\n             * encoding.\n             */\n            Arrays.sort(interfaces);\n            for (int i = 0; i < interfaces.length; i++) {\n                dos.writeUTF(interfaces[i].replace('/', '.'));\n            }\n            /*\n             * 4. For each field of the class sorted by field name (except\n             * private static and private transient fields):\n             * \n             * 1. The name of the field in UTF encoding. 2. The modifiers of the\n             * field written as a 32-bit integer. 3. The descriptor of the field\n             * in UTF encoding\n             * \n             * Note that field signatures are not dot separated. Method and\n             * constructor signatures are dot separated. Go figure...\n             */\n            writeItems(svuidFields, dos, false);\n            /*\n             * 5. If a class initializer exists, write out the following: 1. The\n             * name of the method, <clinit>, in UTF encoding. 2. The modifier of\n             * the method, java.lang.reflect.Modifier.STATIC, written as a\n             * 32-bit integer. 3. The descriptor of the method, ()V, in UTF\n             * encoding.\n             */\n            if (hasStaticInitializer) {\n                dos.writeUTF(\"<clinit>\");\n                dos.writeInt(Opcodes.ACC_STATIC);\n                dos.writeUTF(\"()V\");\n            }\n            // if..\n            /*\n             * 6. For each non-private constructor sorted by method name and\n             * signature: 1. The name of the method, <init>, in UTF encoding. 2.\n             * The modifiers of the method written as a 32-bit integer. 3. The\n             * descriptor of the method in UTF encoding.\n             */\n            writeItems(svuidConstructors, dos, true);\n            /*\n             * 7. For each non-private method sorted by method name and\n             * signature: 1. The name of the method in UTF encoding. 2. The\n             * modifiers of the method written as a 32-bit integer. 3. The\n             * descriptor of the method in UTF encoding.\n             */\n            writeItems(svuidMethods, dos, true);\n            dos.flush();\n            /*\n             * 8. The SHA-1 algorithm is executed on the stream of bytes\n             * produced by DataOutputStream and produces five 32-bit values\n             * sha[0..4].\n             */\n            byte[] hashBytes = computeSHAdigest(bos.toByteArray());\n            /*\n             * 9. The hash value is assembled from the first and second 32-bit\n             * values of the SHA-1 message digest. If the result of the message\n             * digest, the five 32-bit words H0 H1 H2 H3 H4, is in an array of\n             * five int values named sha, the hash value would be computed as\n             * follows:\n             * \n             * long hash = ((sha[0] >>> 24) & 0xFF) | ((sha[0] >>> 16) & 0xFF) <<\n             * 8 | ((sha[0] >>> 8) & 0xFF) << 16 | ((sha[0] >>> 0) & 0xFF) <<\n             * 24 | ((sha[1] >>> 24) & 0xFF) << 32 | ((sha[1] >>> 16) & 0xFF) <<\n             * 40 | ((sha[1] >>> 8) & 0xFF) << 48 | ((sha[1] >>> 0) & 0xFF) <<\n             * 56;\n             */\n            for (int i = Math.min(hashBytes.length, 8) - 1; i >= 0; i--) {\n                svuid = (svuid << 8) | (hashBytes[i] & 0xFF);\n            }\n        } finally {\n            // close the stream (if open)\n            if (dos != null) {\n                dos.close();\n            }\n        }\n        return svuid;\n    }\n\n    /**\n     * Returns the SHA-1 message digest of the given value.\n     *\n     * @param value the value whose SHA message digest must be computed.\n     * @return the SHA-1 message digest of the given value.\n     */\n    protected byte[] computeSHAdigest(final byte[] value) {\n        try {\n            return MessageDigest.getInstance(\"SHA\").digest(value);\n        } catch (Exception e) {\n            throw new UnsupportedOperationException(e.toString());\n        }\n    }\n\n    /**\n     * Sorts the items in the collection and writes it to the data output stream\n     *\n     * @param itemCollection collection of items\n     * @param dos a <code>DataOutputStream</code> value\n     * @param dotted a <code>boolean</code> value\n     * @exception IOException if an error occurs\n     */\n    private static void writeItems(final Collection itemCollection, final DataOutput dos, final boolean dotted) throws IOException {\n        int size = itemCollection.size();\n        Item[] items = (Item[]) itemCollection.toArray(new Item[size]);\n        Arrays.sort(items);\n        for (int i = 0; i < size; i++) {\n            dos.writeUTF(items[i].name);\n            dos.writeInt(items[i].access);\n            dos.writeUTF(dotted ? items[i].desc.replace('/', '.') : items[i].desc);\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Inner classes\n    // ------------------------------------------------------------------------\n    static class Item implements Comparable {\n\n        final String name;\n\n        final int access;\n\n        final String desc;\n\n        Item(final String name, final int access, final String desc) {\n            this.name = name;\n            this.access = access;\n            this.desc = desc;\n        }\n\n        public int compareTo(final Object o) {\n            Item other = (Item) o;\n            int retVal = name.compareTo(other.name);\n            if (retVal == 0) {\n                retVal = desc.compareTo(other.desc);\n            }\n            return retVal;\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/commons/SerialVersionUIDAdderTest1.java",
		"test_prompt": "// SerialVersionUIDAdderTest1.java\npackage org.objectweb.asm.jip.commons;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.DataOutput;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.security.MessageDigest;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport org.objectweb.asm.jip.ClassAdapter;\nimport org.objectweb.asm.jip.ClassVisitor;\nimport org.objectweb.asm.jip.FieldVisitor;\nimport org.objectweb.asm.jip.MethodVisitor;\nimport org.objectweb.asm.jip.Opcodes;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SerialVersionUIDAdder}.\n* It contains ten unit test cases for the {@link SerialVersionUIDAdder#visitField(int, String, String, String, Object)} method.\n*/\nclass SerialVersionUIDAdderTest1 {"
	},
	{
		"original_code": "// LocalVariablesSorter.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip.commons;\n\nimport org.objectweb.asm.jip.Label;\nimport org.objectweb.asm.jip.MethodAdapter;\nimport org.objectweb.asm.jip.MethodVisitor;\nimport org.objectweb.asm.jip.Opcodes;\nimport org.objectweb.asm.jip.Type;\n\n/**\n * A {@link MethodAdapter} that renumbers local variables in their order of\n * appearance. This adapter allows one to easily add new local variables to a\n * method. It may be used by inheriting from this class, but the preferred way\n * of using it is via delegation: the next visitor in the chain can indeed add\n * new locals when needed by calling {@link #newLocal} on this adapter (this\n * requires a reference back to this {@link LocalVariablesSorter}).\n *\n * @author Chris Nokleberg\n * @author Eugene Kuleshov\n * @author Eric Bruneton\n */\npublic class LocalVariablesSorter extends MethodAdapter {\n\n    private static final Type OBJECT_TYPE = Type.getObjectType(\"java/lang/Object\");\n\n    /**\n     * Mapping from old to new local variable indexes. A local variable at index\n     * i of size 1 is remapped to 'mapping[2*i]', while a local variable at\n     * index i of size 2 is remapped to 'mapping[2*i+1]'.\n     */\n    private int[] mapping = new int[40];\n\n    /**\n     * Array used to store stack map local variable types after remapping.\n     */\n    private Object[] newLocals = new Object[20];\n\n    /**\n     * Index of the first local variable, after formal parameters.\n     */\n    protected final int firstLocal;\n\n    /**\n     * Index of the next local variable to be created by {@link #newLocal}.\n     */\n    protected int nextLocal;\n\n    /**\n     * Indicates if at least one local variable has moved due to remapping.\n     */\n    private boolean changed;\n\n    /**\n     * Creates a new {@link LocalVariablesSorter}.\n     *\n     * @param access access flags of the adapted method.\n     * @param desc the method's descriptor (see {@link Type Type}).\n     * @param mv the method visitor to which this adapter delegates calls.\n     */\n    public LocalVariablesSorter(final int access, final String desc, final MethodVisitor mv) {\n        super(mv);\n        Type[] args = Type.getArgumentTypes(desc);\n        nextLocal = (Opcodes.ACC_STATIC & access) == 0 ? 1 : 0;\n        for (int i = 0; i < args.length; i++) {\n            nextLocal += args[i].getSize();\n        }\n        firstLocal = nextLocal;\n    }\n\n    public void visitVarInsn(final int opcode, final int var) {\n        Type type;\n        switch(opcode) {\n            case Opcodes.LLOAD:\n            case Opcodes.LSTORE:\n                type = Type.LONG_TYPE;\n                break;\n            case Opcodes.DLOAD:\n            case Opcodes.DSTORE:\n                type = Type.DOUBLE_TYPE;\n                break;\n            case Opcodes.FLOAD:\n            case Opcodes.FSTORE:\n                type = Type.FLOAT_TYPE;\n                break;\n            case Opcodes.ILOAD:\n            case Opcodes.ISTORE:\n                type = Type.INT_TYPE;\n                break;\n            default:\n                // case Opcodes.ALOAD:\n                // case Opcodes.ASTORE:\n                // case RET:\n                type = OBJECT_TYPE;\n                break;\n        }\n        mv.visitVarInsn(opcode, remap(var, type));\n    }\n\n    public void visitIincInsn(final int var, final int increment) {\n        mv.visitIincInsn(remap(var, Type.INT_TYPE), increment);\n    }\n\n    public void visitMaxs(final int maxStack, final int maxLocals) {\n        mv.visitMaxs(maxStack, nextLocal);\n    }\n\n    public void visitLocalVariable(final String name, final String desc, final String signature, final Label start, final Label end, final int index) {\n        int newIndex = remap(index, Type.getType(desc));\n        mv.visitLocalVariable(name, desc, signature, start, end, newIndex);\n    }\n\n    public void visitFrame(final int type, final int nLocal, final Object[] local, final int nStack, final Object[] stack) {\n        if (type != Opcodes.F_NEW) {\n            // uncompressed frame\n            throw new IllegalStateException(\"ClassReader.accept() should be called with EXPAND_FRAMES flag\");\n        }\n        if (!changed) {\n            // optimization for the case where mapping = identity\n            mv.visitFrame(type, nLocal, local, nStack, stack);\n            return;\n        }\n        // creates a copy of newLocals\n        Object[] oldLocals = new Object[newLocals.length];\n        System.arraycopy(newLocals, 0, oldLocals, 0, oldLocals.length);\n        // copies types from 'local' to 'newLocals'\n        // 'newLocals' already contains the variables added with 'newLocal'\n        // old local variable index\n        int index = 0;\n        // old local variable number\n        int number = 0;\n        for (; number < nLocal; ++number) {\n            Object t = local[number];\n            int size = t == Opcodes.LONG || t == Opcodes.DOUBLE ? 2 : 1;\n            if (t != Opcodes.TOP) {\n                Type typ;\n                if (t == Opcodes.INTEGER) {\n                    typ = Type.INT_TYPE;\n                } else if (t == Opcodes.FLOAT) {\n                    typ = Type.FLOAT_TYPE;\n                } else if (t == Opcodes.LONG) {\n                    typ = Type.LONG_TYPE;\n                } else if (t == Opcodes.DOUBLE) {\n                    typ = Type.DOUBLE_TYPE;\n                } else {\n                    typ = Type.getObjectType((String) t);\n                }\n                setFrameLocal(remap(index, typ), t);\n            }\n            index += size;\n        }\n        // removes TOP after long and double types as well as trailing TOPs\n        index = 0;\n        number = 0;\n        for (int i = 0; index < newLocals.length; ++i) {\n            Object t = newLocals[index++];\n            if (t != null && t != Opcodes.TOP) {\n                newLocals[i] = t;\n                number = i + 1;\n                if (t == Opcodes.LONG || t == Opcodes.DOUBLE) {\n                    index += 1;\n                }\n            } else {\n                newLocals[i] = Opcodes.TOP;\n            }\n        }\n        // visits remapped frame\n        mv.visitFrame(type, number, newLocals, nStack, stack);\n        // restores original value of 'newLocals'\n        newLocals = oldLocals;\n    }\n\n    // -------------\n    /**\n     * Creates a new local variable of the given type.\n     *\n     * @param type the type of the local variable to be created.\n     * @return the identifier of the newly created local variable.\n     */\n    public int newLocal(final Type type) {\n        Object t;\n        switch(type.getSort()) {\n            case Type.BOOLEAN:\n            case Type.CHAR:\n            case Type.BYTE:\n            case Type.SHORT:\n            case Type.INT:\n                t = Opcodes.INTEGER;\n                break;\n            case Type.FLOAT:\n                t = Opcodes.FLOAT;\n                break;\n            case Type.LONG:\n                t = Opcodes.LONG;\n                break;\n            case Type.DOUBLE:\n                t = Opcodes.DOUBLE;\n                break;\n            case Type.ARRAY:\n                t = type.getDescriptor();\n                break;\n            // case Type.OBJECT:\n            default:\n                t = type.getInternalName();\n                break;\n        }\n        int local = nextLocal;\n        nextLocal += type.getSize();\n        setLocalType(local, type);\n        setFrameLocal(local, t);\n        return local;\n    }\n\n    /**\n     * Sets the current type of the given local variable. The default\n     * implementation of this method does nothing.\n     *\n     * @param local a local variable identifier, as returned by {@link #newLocal\n     *        newLocal()}.\n     * @param type the type of the value being stored in the local variable\n     */\n    protected void setLocalType(final int local, final Type type) {\n    }\n\n    private void setFrameLocal(final int local, final Object type) {\n        int l = newLocals.length;\n        if (local >= l) {\n            Object[] a = new Object[Math.max(2 * l, local + 1)];\n            System.arraycopy(newLocals, 0, a, 0, l);\n            newLocals = a;\n        }\n        newLocals[local] = type;\n    }\n\n    private int remap(final int var, final Type type) {\n        if (var < firstLocal) {\n            return var;\n        }\n        int key = 2 * var + type.getSize() - 1;\n        int size = mapping.length;\n        if (key >= size) {\n            int[] newMapping = new int[Math.max(2 * size, key + 1)];\n            System.arraycopy(mapping, 0, newMapping, 0, size);\n            mapping = newMapping;\n        }\n        int value = mapping[key];\n        if (value == 0) {\n            value = newLocalMapping(type);\n            setLocalType(value, type);\n            mapping[key] = value + 1;\n        } else {\n            value--;\n        }\n        if (value != var) {\n            changed = true;\n        }\n        return value;\n    }\n\n    protected int newLocalMapping(final Type type) {\n        int local = nextLocal;\n        nextLocal += type.getSize();\n        return local;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/commons/LocalVariablesSorterTest.java",
		"test_prompt": "// LocalVariablesSorterTest.java\npackage org.objectweb.asm.jip.commons;\n\nimport org.objectweb.asm.jip.Label;\nimport org.objectweb.asm.jip.MethodAdapter;\nimport org.objectweb.asm.jip.MethodVisitor;\nimport org.objectweb.asm.jip.Opcodes;\nimport org.objectweb.asm.jip.Type;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link LocalVariablesSorter}.\n* It contains ten unit test cases for the {@link LocalVariablesSorter#newLocal(Type)} method.\n*/\nclass LocalVariablesSorterTest {"
	},
	{
		"original_code": "// EmptyVisitor.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip.commons;\n\nimport org.objectweb.asm.jip.AnnotationVisitor;\nimport org.objectweb.asm.jip.Attribute;\nimport org.objectweb.asm.jip.ClassVisitor;\nimport org.objectweb.asm.jip.FieldVisitor;\nimport org.objectweb.asm.jip.Label;\nimport org.objectweb.asm.jip.MethodVisitor;\n\n/**\n * An empty implementation of the ASM visitor interfaces.\n *\n * @author Eric Bruneton\n */\npublic class EmptyVisitor implements ClassVisitor, FieldVisitor, MethodVisitor, AnnotationVisitor {\n\n    public void visit(final int version, final int access, final String name, final String signature, final String superName, final String[] interfaces) {\n    }\n\n    public void visitSource(final String source, final String debug) {\n    }\n\n    public void visitOuterClass(final String owner, final String name, final String desc) {\n    }\n\n    public AnnotationVisitor visitAnnotation(final String desc, final boolean visible) {\n        return this;\n    }\n\n    public void visitAttribute(final Attribute attr) {\n    }\n\n    public void visitInnerClass(final String name, final String outerName, final String innerName, final int access) {\n    }\n\n    public FieldVisitor visitField(final int access, final String name, final String desc, final String signature, final Object value) {\n        return this;\n    }\n\n    public MethodVisitor visitMethod(final int access, final String name, final String desc, final String signature, final String[] exceptions) {\n        return this;\n    }\n\n    public void visitEnd() {\n    }\n\n    public AnnotationVisitor visitAnnotationDefault() {\n        return this;\n    }\n\n    public AnnotationVisitor visitParameterAnnotation(final int parameter, final String desc, final boolean visible) {\n        return this;\n    }\n\n    public void visitCode() {\n    }\n\n    public void visitFrame(final int type, final int nLocal, final Object[] local, final int nStack, final Object[] stack) {\n    }\n\n    public void visitInsn(final int opcode) {\n    }\n\n    public void visitIntInsn(final int opcode, final int operand) {\n    }\n\n    public void visitVarInsn(final int opcode, final int var) {\n    }\n\n    public void visitTypeInsn(final int opcode, final String type) {\n    }\n\n    public void visitFieldInsn(final int opcode, final String owner, final String name, final String desc) {\n    }\n\n    public void visitMethodInsn(final int opcode, final String owner, final String name, final String desc) {\n    }\n\n    public void visitJumpInsn(final int opcode, final Label label) {\n    }\n\n    public void visitLabel(final Label label) {\n    }\n\n    public void visitLdcInsn(final Object cst) {\n    }\n\n    public void visitIincInsn(final int var, final int increment) {\n    }\n\n    public void visitTableSwitchInsn(final int min, final int max, final Label dflt, final Label[] labels) {\n    }\n\n    public void visitLookupSwitchInsn(final Label dflt, final int[] keys, final Label[] labels) {\n    }\n\n    public void visitMultiANewArrayInsn(final String desc, final int dims) {\n    }\n\n    public void visitTryCatchBlock(final Label start, final Label end, final Label handler, final String type) {\n    }\n\n    public void visitLocalVariable(final String name, final String desc, final String signature, final Label start, final Label end, final int index) {\n    }\n\n    public void visitLineNumber(final int line, final Label start) {\n    }\n\n    public void visitMaxs(final int maxStack, final int maxLocals) {\n    }\n\n    public void visit(final String name, final Object value) {\n    }\n\n    public void visitEnum(final String name, final String desc, final String value) {\n    }\n\n    public AnnotationVisitor visitAnnotation(final String name, final String desc) {\n        return this;\n    }\n\n    public AnnotationVisitor visitArray(final String name) {\n        return this;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/commons/EmptyVisitorTest0.java",
		"test_prompt": "// EmptyVisitorTest0.java\npackage org.objectweb.asm.jip.commons;\n\nimport org.objectweb.asm.jip.AnnotationVisitor;\nimport org.objectweb.asm.jip.Attribute;\nimport org.objectweb.asm.jip.ClassVisitor;\nimport org.objectweb.asm.jip.FieldVisitor;\nimport org.objectweb.asm.jip.Label;\nimport org.objectweb.asm.jip.MethodVisitor;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EmptyVisitor}.\n* It contains ten unit test cases for the {@link EmptyVisitor#visitAnnotation(String, boolean)} method.\n*/\nclass EmptyVisitorTest0 {"
	},
	{
		"original_code": "// EmptyVisitor.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip.commons;\n\nimport org.objectweb.asm.jip.AnnotationVisitor;\nimport org.objectweb.asm.jip.Attribute;\nimport org.objectweb.asm.jip.ClassVisitor;\nimport org.objectweb.asm.jip.FieldVisitor;\nimport org.objectweb.asm.jip.Label;\nimport org.objectweb.asm.jip.MethodVisitor;\n\n/**\n * An empty implementation of the ASM visitor interfaces.\n *\n * @author Eric Bruneton\n */\npublic class EmptyVisitor implements ClassVisitor, FieldVisitor, MethodVisitor, AnnotationVisitor {\n\n    public void visit(final int version, final int access, final String name, final String signature, final String superName, final String[] interfaces) {\n    }\n\n    public void visitSource(final String source, final String debug) {\n    }\n\n    public void visitOuterClass(final String owner, final String name, final String desc) {\n    }\n\n    public AnnotationVisitor visitAnnotation(final String desc, final boolean visible) {\n        return this;\n    }\n\n    public void visitAttribute(final Attribute attr) {\n    }\n\n    public void visitInnerClass(final String name, final String outerName, final String innerName, final int access) {\n    }\n\n    public FieldVisitor visitField(final int access, final String name, final String desc, final String signature, final Object value) {\n        return this;\n    }\n\n    public MethodVisitor visitMethod(final int access, final String name, final String desc, final String signature, final String[] exceptions) {\n        return this;\n    }\n\n    public void visitEnd() {\n    }\n\n    public AnnotationVisitor visitAnnotationDefault() {\n        return this;\n    }\n\n    public AnnotationVisitor visitParameterAnnotation(final int parameter, final String desc, final boolean visible) {\n        return this;\n    }\n\n    public void visitCode() {\n    }\n\n    public void visitFrame(final int type, final int nLocal, final Object[] local, final int nStack, final Object[] stack) {\n    }\n\n    public void visitInsn(final int opcode) {\n    }\n\n    public void visitIntInsn(final int opcode, final int operand) {\n    }\n\n    public void visitVarInsn(final int opcode, final int var) {\n    }\n\n    public void visitTypeInsn(final int opcode, final String type) {\n    }\n\n    public void visitFieldInsn(final int opcode, final String owner, final String name, final String desc) {\n    }\n\n    public void visitMethodInsn(final int opcode, final String owner, final String name, final String desc) {\n    }\n\n    public void visitJumpInsn(final int opcode, final Label label) {\n    }\n\n    public void visitLabel(final Label label) {\n    }\n\n    public void visitLdcInsn(final Object cst) {\n    }\n\n    public void visitIincInsn(final int var, final int increment) {\n    }\n\n    public void visitTableSwitchInsn(final int min, final int max, final Label dflt, final Label[] labels) {\n    }\n\n    public void visitLookupSwitchInsn(final Label dflt, final int[] keys, final Label[] labels) {\n    }\n\n    public void visitMultiANewArrayInsn(final String desc, final int dims) {\n    }\n\n    public void visitTryCatchBlock(final Label start, final Label end, final Label handler, final String type) {\n    }\n\n    public void visitLocalVariable(final String name, final String desc, final String signature, final Label start, final Label end, final int index) {\n    }\n\n    public void visitLineNumber(final int line, final Label start) {\n    }\n\n    public void visitMaxs(final int maxStack, final int maxLocals) {\n    }\n\n    public void visit(final String name, final Object value) {\n    }\n\n    public void visitEnum(final String name, final String desc, final String value) {\n    }\n\n    public AnnotationVisitor visitAnnotation(final String name, final String desc) {\n        return this;\n    }\n\n    public AnnotationVisitor visitArray(final String name) {\n        return this;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/commons/EmptyVisitorTest1.java",
		"test_prompt": "// EmptyVisitorTest1.java\npackage org.objectweb.asm.jip.commons;\n\nimport org.objectweb.asm.jip.AnnotationVisitor;\nimport org.objectweb.asm.jip.Attribute;\nimport org.objectweb.asm.jip.ClassVisitor;\nimport org.objectweb.asm.jip.FieldVisitor;\nimport org.objectweb.asm.jip.Label;\nimport org.objectweb.asm.jip.MethodVisitor;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EmptyVisitor}.\n* It contains ten unit test cases for the {@link EmptyVisitor#visitField(int, String, String, String, Object)} method.\n*/\nclass EmptyVisitorTest1 {"
	},
	{
		"original_code": "// EmptyVisitor.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip.commons;\n\nimport org.objectweb.asm.jip.AnnotationVisitor;\nimport org.objectweb.asm.jip.Attribute;\nimport org.objectweb.asm.jip.ClassVisitor;\nimport org.objectweb.asm.jip.FieldVisitor;\nimport org.objectweb.asm.jip.Label;\nimport org.objectweb.asm.jip.MethodVisitor;\n\n/**\n * An empty implementation of the ASM visitor interfaces.\n *\n * @author Eric Bruneton\n */\npublic class EmptyVisitor implements ClassVisitor, FieldVisitor, MethodVisitor, AnnotationVisitor {\n\n    public void visit(final int version, final int access, final String name, final String signature, final String superName, final String[] interfaces) {\n    }\n\n    public void visitSource(final String source, final String debug) {\n    }\n\n    public void visitOuterClass(final String owner, final String name, final String desc) {\n    }\n\n    public AnnotationVisitor visitAnnotation(final String desc, final boolean visible) {\n        return this;\n    }\n\n    public void visitAttribute(final Attribute attr) {\n    }\n\n    public void visitInnerClass(final String name, final String outerName, final String innerName, final int access) {\n    }\n\n    public FieldVisitor visitField(final int access, final String name, final String desc, final String signature, final Object value) {\n        return this;\n    }\n\n    public MethodVisitor visitMethod(final int access, final String name, final String desc, final String signature, final String[] exceptions) {\n        return this;\n    }\n\n    public void visitEnd() {\n    }\n\n    public AnnotationVisitor visitAnnotationDefault() {\n        return this;\n    }\n\n    public AnnotationVisitor visitParameterAnnotation(final int parameter, final String desc, final boolean visible) {\n        return this;\n    }\n\n    public void visitCode() {\n    }\n\n    public void visitFrame(final int type, final int nLocal, final Object[] local, final int nStack, final Object[] stack) {\n    }\n\n    public void visitInsn(final int opcode) {\n    }\n\n    public void visitIntInsn(final int opcode, final int operand) {\n    }\n\n    public void visitVarInsn(final int opcode, final int var) {\n    }\n\n    public void visitTypeInsn(final int opcode, final String type) {\n    }\n\n    public void visitFieldInsn(final int opcode, final String owner, final String name, final String desc) {\n    }\n\n    public void visitMethodInsn(final int opcode, final String owner, final String name, final String desc) {\n    }\n\n    public void visitJumpInsn(final int opcode, final Label label) {\n    }\n\n    public void visitLabel(final Label label) {\n    }\n\n    public void visitLdcInsn(final Object cst) {\n    }\n\n    public void visitIincInsn(final int var, final int increment) {\n    }\n\n    public void visitTableSwitchInsn(final int min, final int max, final Label dflt, final Label[] labels) {\n    }\n\n    public void visitLookupSwitchInsn(final Label dflt, final int[] keys, final Label[] labels) {\n    }\n\n    public void visitMultiANewArrayInsn(final String desc, final int dims) {\n    }\n\n    public void visitTryCatchBlock(final Label start, final Label end, final Label handler, final String type) {\n    }\n\n    public void visitLocalVariable(final String name, final String desc, final String signature, final Label start, final Label end, final int index) {\n    }\n\n    public void visitLineNumber(final int line, final Label start) {\n    }\n\n    public void visitMaxs(final int maxStack, final int maxLocals) {\n    }\n\n    public void visit(final String name, final Object value) {\n    }\n\n    public void visitEnum(final String name, final String desc, final String value) {\n    }\n\n    public AnnotationVisitor visitAnnotation(final String name, final String desc) {\n        return this;\n    }\n\n    public AnnotationVisitor visitArray(final String name) {\n        return this;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/commons/EmptyVisitorTest2.java",
		"test_prompt": "// EmptyVisitorTest2.java\npackage org.objectweb.asm.jip.commons;\n\nimport org.objectweb.asm.jip.AnnotationVisitor;\nimport org.objectweb.asm.jip.Attribute;\nimport org.objectweb.asm.jip.ClassVisitor;\nimport org.objectweb.asm.jip.FieldVisitor;\nimport org.objectweb.asm.jip.Label;\nimport org.objectweb.asm.jip.MethodVisitor;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EmptyVisitor}.\n* It contains ten unit test cases for the {@link EmptyVisitor#visitMethod(int, String, String, String, String[])} method.\n*/\nclass EmptyVisitorTest2 {"
	},
	{
		"original_code": "// EmptyVisitor.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip.commons;\n\nimport org.objectweb.asm.jip.AnnotationVisitor;\nimport org.objectweb.asm.jip.Attribute;\nimport org.objectweb.asm.jip.ClassVisitor;\nimport org.objectweb.asm.jip.FieldVisitor;\nimport org.objectweb.asm.jip.Label;\nimport org.objectweb.asm.jip.MethodVisitor;\n\n/**\n * An empty implementation of the ASM visitor interfaces.\n *\n * @author Eric Bruneton\n */\npublic class EmptyVisitor implements ClassVisitor, FieldVisitor, MethodVisitor, AnnotationVisitor {\n\n    public void visit(final int version, final int access, final String name, final String signature, final String superName, final String[] interfaces) {\n    }\n\n    public void visitSource(final String source, final String debug) {\n    }\n\n    public void visitOuterClass(final String owner, final String name, final String desc) {\n    }\n\n    public AnnotationVisitor visitAnnotation(final String desc, final boolean visible) {\n        return this;\n    }\n\n    public void visitAttribute(final Attribute attr) {\n    }\n\n    public void visitInnerClass(final String name, final String outerName, final String innerName, final int access) {\n    }\n\n    public FieldVisitor visitField(final int access, final String name, final String desc, final String signature, final Object value) {\n        return this;\n    }\n\n    public MethodVisitor visitMethod(final int access, final String name, final String desc, final String signature, final String[] exceptions) {\n        return this;\n    }\n\n    public void visitEnd() {\n    }\n\n    public AnnotationVisitor visitAnnotationDefault() {\n        return this;\n    }\n\n    public AnnotationVisitor visitParameterAnnotation(final int parameter, final String desc, final boolean visible) {\n        return this;\n    }\n\n    public void visitCode() {\n    }\n\n    public void visitFrame(final int type, final int nLocal, final Object[] local, final int nStack, final Object[] stack) {\n    }\n\n    public void visitInsn(final int opcode) {\n    }\n\n    public void visitIntInsn(final int opcode, final int operand) {\n    }\n\n    public void visitVarInsn(final int opcode, final int var) {\n    }\n\n    public void visitTypeInsn(final int opcode, final String type) {\n    }\n\n    public void visitFieldInsn(final int opcode, final String owner, final String name, final String desc) {\n    }\n\n    public void visitMethodInsn(final int opcode, final String owner, final String name, final String desc) {\n    }\n\n    public void visitJumpInsn(final int opcode, final Label label) {\n    }\n\n    public void visitLabel(final Label label) {\n    }\n\n    public void visitLdcInsn(final Object cst) {\n    }\n\n    public void visitIincInsn(final int var, final int increment) {\n    }\n\n    public void visitTableSwitchInsn(final int min, final int max, final Label dflt, final Label[] labels) {\n    }\n\n    public void visitLookupSwitchInsn(final Label dflt, final int[] keys, final Label[] labels) {\n    }\n\n    public void visitMultiANewArrayInsn(final String desc, final int dims) {\n    }\n\n    public void visitTryCatchBlock(final Label start, final Label end, final Label handler, final String type) {\n    }\n\n    public void visitLocalVariable(final String name, final String desc, final String signature, final Label start, final Label end, final int index) {\n    }\n\n    public void visitLineNumber(final int line, final Label start) {\n    }\n\n    public void visitMaxs(final int maxStack, final int maxLocals) {\n    }\n\n    public void visit(final String name, final Object value) {\n    }\n\n    public void visitEnum(final String name, final String desc, final String value) {\n    }\n\n    public AnnotationVisitor visitAnnotation(final String name, final String desc) {\n        return this;\n    }\n\n    public AnnotationVisitor visitArray(final String name) {\n        return this;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/commons/EmptyVisitorTest3.java",
		"test_prompt": "// EmptyVisitorTest3.java\npackage org.objectweb.asm.jip.commons;\n\nimport org.objectweb.asm.jip.AnnotationVisitor;\nimport org.objectweb.asm.jip.Attribute;\nimport org.objectweb.asm.jip.ClassVisitor;\nimport org.objectweb.asm.jip.FieldVisitor;\nimport org.objectweb.asm.jip.Label;\nimport org.objectweb.asm.jip.MethodVisitor;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EmptyVisitor}.\n* It contains ten unit test cases for the {@link EmptyVisitor#visitAnnotationDefault()} method.\n*/\nclass EmptyVisitorTest3 {"
	},
	{
		"original_code": "// EmptyVisitor.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip.commons;\n\nimport org.objectweb.asm.jip.AnnotationVisitor;\nimport org.objectweb.asm.jip.Attribute;\nimport org.objectweb.asm.jip.ClassVisitor;\nimport org.objectweb.asm.jip.FieldVisitor;\nimport org.objectweb.asm.jip.Label;\nimport org.objectweb.asm.jip.MethodVisitor;\n\n/**\n * An empty implementation of the ASM visitor interfaces.\n *\n * @author Eric Bruneton\n */\npublic class EmptyVisitor implements ClassVisitor, FieldVisitor, MethodVisitor, AnnotationVisitor {\n\n    public void visit(final int version, final int access, final String name, final String signature, final String superName, final String[] interfaces) {\n    }\n\n    public void visitSource(final String source, final String debug) {\n    }\n\n    public void visitOuterClass(final String owner, final String name, final String desc) {\n    }\n\n    public AnnotationVisitor visitAnnotation(final String desc, final boolean visible) {\n        return this;\n    }\n\n    public void visitAttribute(final Attribute attr) {\n    }\n\n    public void visitInnerClass(final String name, final String outerName, final String innerName, final int access) {\n    }\n\n    public FieldVisitor visitField(final int access, final String name, final String desc, final String signature, final Object value) {\n        return this;\n    }\n\n    public MethodVisitor visitMethod(final int access, final String name, final String desc, final String signature, final String[] exceptions) {\n        return this;\n    }\n\n    public void visitEnd() {\n    }\n\n    public AnnotationVisitor visitAnnotationDefault() {\n        return this;\n    }\n\n    public AnnotationVisitor visitParameterAnnotation(final int parameter, final String desc, final boolean visible) {\n        return this;\n    }\n\n    public void visitCode() {\n    }\n\n    public void visitFrame(final int type, final int nLocal, final Object[] local, final int nStack, final Object[] stack) {\n    }\n\n    public void visitInsn(final int opcode) {\n    }\n\n    public void visitIntInsn(final int opcode, final int operand) {\n    }\n\n    public void visitVarInsn(final int opcode, final int var) {\n    }\n\n    public void visitTypeInsn(final int opcode, final String type) {\n    }\n\n    public void visitFieldInsn(final int opcode, final String owner, final String name, final String desc) {\n    }\n\n    public void visitMethodInsn(final int opcode, final String owner, final String name, final String desc) {\n    }\n\n    public void visitJumpInsn(final int opcode, final Label label) {\n    }\n\n    public void visitLabel(final Label label) {\n    }\n\n    public void visitLdcInsn(final Object cst) {\n    }\n\n    public void visitIincInsn(final int var, final int increment) {\n    }\n\n    public void visitTableSwitchInsn(final int min, final int max, final Label dflt, final Label[] labels) {\n    }\n\n    public void visitLookupSwitchInsn(final Label dflt, final int[] keys, final Label[] labels) {\n    }\n\n    public void visitMultiANewArrayInsn(final String desc, final int dims) {\n    }\n\n    public void visitTryCatchBlock(final Label start, final Label end, final Label handler, final String type) {\n    }\n\n    public void visitLocalVariable(final String name, final String desc, final String signature, final Label start, final Label end, final int index) {\n    }\n\n    public void visitLineNumber(final int line, final Label start) {\n    }\n\n    public void visitMaxs(final int maxStack, final int maxLocals) {\n    }\n\n    public void visit(final String name, final Object value) {\n    }\n\n    public void visitEnum(final String name, final String desc, final String value) {\n    }\n\n    public AnnotationVisitor visitAnnotation(final String name, final String desc) {\n        return this;\n    }\n\n    public AnnotationVisitor visitArray(final String name) {\n        return this;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/commons/EmptyVisitorTest4.java",
		"test_prompt": "// EmptyVisitorTest4.java\npackage org.objectweb.asm.jip.commons;\n\nimport org.objectweb.asm.jip.AnnotationVisitor;\nimport org.objectweb.asm.jip.Attribute;\nimport org.objectweb.asm.jip.ClassVisitor;\nimport org.objectweb.asm.jip.FieldVisitor;\nimport org.objectweb.asm.jip.Label;\nimport org.objectweb.asm.jip.MethodVisitor;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EmptyVisitor}.\n* It contains ten unit test cases for the {@link EmptyVisitor#visitParameterAnnotation(int, String, boolean)} method.\n*/\nclass EmptyVisitorTest4 {"
	},
	{
		"original_code": "// EmptyVisitor.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip.commons;\n\nimport org.objectweb.asm.jip.AnnotationVisitor;\nimport org.objectweb.asm.jip.Attribute;\nimport org.objectweb.asm.jip.ClassVisitor;\nimport org.objectweb.asm.jip.FieldVisitor;\nimport org.objectweb.asm.jip.Label;\nimport org.objectweb.asm.jip.MethodVisitor;\n\n/**\n * An empty implementation of the ASM visitor interfaces.\n *\n * @author Eric Bruneton\n */\npublic class EmptyVisitor implements ClassVisitor, FieldVisitor, MethodVisitor, AnnotationVisitor {\n\n    public void visit(final int version, final int access, final String name, final String signature, final String superName, final String[] interfaces) {\n    }\n\n    public void visitSource(final String source, final String debug) {\n    }\n\n    public void visitOuterClass(final String owner, final String name, final String desc) {\n    }\n\n    public AnnotationVisitor visitAnnotation(final String desc, final boolean visible) {\n        return this;\n    }\n\n    public void visitAttribute(final Attribute attr) {\n    }\n\n    public void visitInnerClass(final String name, final String outerName, final String innerName, final int access) {\n    }\n\n    public FieldVisitor visitField(final int access, final String name, final String desc, final String signature, final Object value) {\n        return this;\n    }\n\n    public MethodVisitor visitMethod(final int access, final String name, final String desc, final String signature, final String[] exceptions) {\n        return this;\n    }\n\n    public void visitEnd() {\n    }\n\n    public AnnotationVisitor visitAnnotationDefault() {\n        return this;\n    }\n\n    public AnnotationVisitor visitParameterAnnotation(final int parameter, final String desc, final boolean visible) {\n        return this;\n    }\n\n    public void visitCode() {\n    }\n\n    public void visitFrame(final int type, final int nLocal, final Object[] local, final int nStack, final Object[] stack) {\n    }\n\n    public void visitInsn(final int opcode) {\n    }\n\n    public void visitIntInsn(final int opcode, final int operand) {\n    }\n\n    public void visitVarInsn(final int opcode, final int var) {\n    }\n\n    public void visitTypeInsn(final int opcode, final String type) {\n    }\n\n    public void visitFieldInsn(final int opcode, final String owner, final String name, final String desc) {\n    }\n\n    public void visitMethodInsn(final int opcode, final String owner, final String name, final String desc) {\n    }\n\n    public void visitJumpInsn(final int opcode, final Label label) {\n    }\n\n    public void visitLabel(final Label label) {\n    }\n\n    public void visitLdcInsn(final Object cst) {\n    }\n\n    public void visitIincInsn(final int var, final int increment) {\n    }\n\n    public void visitTableSwitchInsn(final int min, final int max, final Label dflt, final Label[] labels) {\n    }\n\n    public void visitLookupSwitchInsn(final Label dflt, final int[] keys, final Label[] labels) {\n    }\n\n    public void visitMultiANewArrayInsn(final String desc, final int dims) {\n    }\n\n    public void visitTryCatchBlock(final Label start, final Label end, final Label handler, final String type) {\n    }\n\n    public void visitLocalVariable(final String name, final String desc, final String signature, final Label start, final Label end, final int index) {\n    }\n\n    public void visitLineNumber(final int line, final Label start) {\n    }\n\n    public void visitMaxs(final int maxStack, final int maxLocals) {\n    }\n\n    public void visit(final String name, final Object value) {\n    }\n\n    public void visitEnum(final String name, final String desc, final String value) {\n    }\n\n    public AnnotationVisitor visitAnnotation(final String name, final String desc) {\n        return this;\n    }\n\n    public AnnotationVisitor visitArray(final String name) {\n        return this;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/commons/EmptyVisitorTest5.java",
		"test_prompt": "// EmptyVisitorTest5.java\npackage org.objectweb.asm.jip.commons;\n\nimport org.objectweb.asm.jip.AnnotationVisitor;\nimport org.objectweb.asm.jip.Attribute;\nimport org.objectweb.asm.jip.ClassVisitor;\nimport org.objectweb.asm.jip.FieldVisitor;\nimport org.objectweb.asm.jip.Label;\nimport org.objectweb.asm.jip.MethodVisitor;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EmptyVisitor}.\n* It contains ten unit test cases for the {@link EmptyVisitor#visitAnnotation(String, String)} method.\n*/\nclass EmptyVisitorTest5 {"
	},
	{
		"original_code": "// EmptyVisitor.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip.commons;\n\nimport org.objectweb.asm.jip.AnnotationVisitor;\nimport org.objectweb.asm.jip.Attribute;\nimport org.objectweb.asm.jip.ClassVisitor;\nimport org.objectweb.asm.jip.FieldVisitor;\nimport org.objectweb.asm.jip.Label;\nimport org.objectweb.asm.jip.MethodVisitor;\n\n/**\n * An empty implementation of the ASM visitor interfaces.\n *\n * @author Eric Bruneton\n */\npublic class EmptyVisitor implements ClassVisitor, FieldVisitor, MethodVisitor, AnnotationVisitor {\n\n    public void visit(final int version, final int access, final String name, final String signature, final String superName, final String[] interfaces) {\n    }\n\n    public void visitSource(final String source, final String debug) {\n    }\n\n    public void visitOuterClass(final String owner, final String name, final String desc) {\n    }\n\n    public AnnotationVisitor visitAnnotation(final String desc, final boolean visible) {\n        return this;\n    }\n\n    public void visitAttribute(final Attribute attr) {\n    }\n\n    public void visitInnerClass(final String name, final String outerName, final String innerName, final int access) {\n    }\n\n    public FieldVisitor visitField(final int access, final String name, final String desc, final String signature, final Object value) {\n        return this;\n    }\n\n    public MethodVisitor visitMethod(final int access, final String name, final String desc, final String signature, final String[] exceptions) {\n        return this;\n    }\n\n    public void visitEnd() {\n    }\n\n    public AnnotationVisitor visitAnnotationDefault() {\n        return this;\n    }\n\n    public AnnotationVisitor visitParameterAnnotation(final int parameter, final String desc, final boolean visible) {\n        return this;\n    }\n\n    public void visitCode() {\n    }\n\n    public void visitFrame(final int type, final int nLocal, final Object[] local, final int nStack, final Object[] stack) {\n    }\n\n    public void visitInsn(final int opcode) {\n    }\n\n    public void visitIntInsn(final int opcode, final int operand) {\n    }\n\n    public void visitVarInsn(final int opcode, final int var) {\n    }\n\n    public void visitTypeInsn(final int opcode, final String type) {\n    }\n\n    public void visitFieldInsn(final int opcode, final String owner, final String name, final String desc) {\n    }\n\n    public void visitMethodInsn(final int opcode, final String owner, final String name, final String desc) {\n    }\n\n    public void visitJumpInsn(final int opcode, final Label label) {\n    }\n\n    public void visitLabel(final Label label) {\n    }\n\n    public void visitLdcInsn(final Object cst) {\n    }\n\n    public void visitIincInsn(final int var, final int increment) {\n    }\n\n    public void visitTableSwitchInsn(final int min, final int max, final Label dflt, final Label[] labels) {\n    }\n\n    public void visitLookupSwitchInsn(final Label dflt, final int[] keys, final Label[] labels) {\n    }\n\n    public void visitMultiANewArrayInsn(final String desc, final int dims) {\n    }\n\n    public void visitTryCatchBlock(final Label start, final Label end, final Label handler, final String type) {\n    }\n\n    public void visitLocalVariable(final String name, final String desc, final String signature, final Label start, final Label end, final int index) {\n    }\n\n    public void visitLineNumber(final int line, final Label start) {\n    }\n\n    public void visitMaxs(final int maxStack, final int maxLocals) {\n    }\n\n    public void visit(final String name, final Object value) {\n    }\n\n    public void visitEnum(final String name, final String desc, final String value) {\n    }\n\n    public AnnotationVisitor visitAnnotation(final String name, final String desc) {\n        return this;\n    }\n\n    public AnnotationVisitor visitArray(final String name) {\n        return this;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/commons/EmptyVisitorTest6.java",
		"test_prompt": "// EmptyVisitorTest6.java\npackage org.objectweb.asm.jip.commons;\n\nimport org.objectweb.asm.jip.AnnotationVisitor;\nimport org.objectweb.asm.jip.Attribute;\nimport org.objectweb.asm.jip.ClassVisitor;\nimport org.objectweb.asm.jip.FieldVisitor;\nimport org.objectweb.asm.jip.Label;\nimport org.objectweb.asm.jip.MethodVisitor;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EmptyVisitor}.\n* It contains ten unit test cases for the {@link EmptyVisitor#visitArray(String)} method.\n*/\nclass EmptyVisitorTest6 {"
	},
	{
		"original_code": "// ClassAdapter.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\n/**\n * An empty {@link ClassVisitor} that delegates to another {@link ClassVisitor}.\n * This class can be used as a super class to quickly implement usefull class\n * adapter classes, just by overriding the necessary methods.\n *\n * @author Eric Bruneton\n */\npublic class ClassAdapter implements ClassVisitor {\n\n    /**\n     * The {@link ClassVisitor} to which this adapter delegates calls.\n     */\n    protected ClassVisitor cv;\n\n    /**\n     * Constructs a new {@link ClassAdapter} object.\n     *\n     * @param cv the class visitor to which this adapter must delegate calls.\n     */\n    public ClassAdapter(final ClassVisitor cv) {\n        this.cv = cv;\n    }\n\n    public void visit(final int version, final int access, final String name, final String signature, final String superName, final String[] interfaces) {\n        cv.visit(version, access, name, signature, superName, interfaces);\n    }\n\n    public void visitSource(final String source, final String debug) {\n        cv.visitSource(source, debug);\n    }\n\n    public void visitOuterClass(final String owner, final String name, final String desc) {\n        cv.visitOuterClass(owner, name, desc);\n    }\n\n    public AnnotationVisitor visitAnnotation(final String desc, final boolean visible) {\n        return cv.visitAnnotation(desc, visible);\n    }\n\n    public void visitAttribute(final Attribute attr) {\n        cv.visitAttribute(attr);\n    }\n\n    public void visitInnerClass(final String name, final String outerName, final String innerName, final int access) {\n        cv.visitInnerClass(name, outerName, innerName, access);\n    }\n\n    public FieldVisitor visitField(final int access, final String name, final String desc, final String signature, final Object value) {\n        return cv.visitField(access, name, desc, signature, value);\n    }\n\n    public MethodVisitor visitMethod(final int access, final String name, final String desc, final String signature, final String[] exceptions) {\n        return cv.visitMethod(access, name, desc, signature, exceptions);\n    }\n\n    public void visitEnd() {\n        cv.visitEnd();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/ClassAdapterTest0.java",
		"test_prompt": "// ClassAdapterTest0.java\npackage org.objectweb.asm.jip;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassAdapter}.\n* It contains ten unit test cases for the {@link ClassAdapter#visitAnnotation(String, boolean)} method.\n*/\nclass ClassAdapterTest0 {"
	},
	{
		"original_code": "// ClassAdapter.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\n/**\n * An empty {@link ClassVisitor} that delegates to another {@link ClassVisitor}.\n * This class can be used as a super class to quickly implement usefull class\n * adapter classes, just by overriding the necessary methods.\n *\n * @author Eric Bruneton\n */\npublic class ClassAdapter implements ClassVisitor {\n\n    /**\n     * The {@link ClassVisitor} to which this adapter delegates calls.\n     */\n    protected ClassVisitor cv;\n\n    /**\n     * Constructs a new {@link ClassAdapter} object.\n     *\n     * @param cv the class visitor to which this adapter must delegate calls.\n     */\n    public ClassAdapter(final ClassVisitor cv) {\n        this.cv = cv;\n    }\n\n    public void visit(final int version, final int access, final String name, final String signature, final String superName, final String[] interfaces) {\n        cv.visit(version, access, name, signature, superName, interfaces);\n    }\n\n    public void visitSource(final String source, final String debug) {\n        cv.visitSource(source, debug);\n    }\n\n    public void visitOuterClass(final String owner, final String name, final String desc) {\n        cv.visitOuterClass(owner, name, desc);\n    }\n\n    public AnnotationVisitor visitAnnotation(final String desc, final boolean visible) {\n        return cv.visitAnnotation(desc, visible);\n    }\n\n    public void visitAttribute(final Attribute attr) {\n        cv.visitAttribute(attr);\n    }\n\n    public void visitInnerClass(final String name, final String outerName, final String innerName, final int access) {\n        cv.visitInnerClass(name, outerName, innerName, access);\n    }\n\n    public FieldVisitor visitField(final int access, final String name, final String desc, final String signature, final Object value) {\n        return cv.visitField(access, name, desc, signature, value);\n    }\n\n    public MethodVisitor visitMethod(final int access, final String name, final String desc, final String signature, final String[] exceptions) {\n        return cv.visitMethod(access, name, desc, signature, exceptions);\n    }\n\n    public void visitEnd() {\n        cv.visitEnd();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/ClassAdapterTest1.java",
		"test_prompt": "// ClassAdapterTest1.java\npackage org.objectweb.asm.jip;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassAdapter}.\n* It contains ten unit test cases for the {@link ClassAdapter#visitField(int, String, String, String, Object)} method.\n*/\nclass ClassAdapterTest1 {"
	},
	{
		"original_code": "// ClassAdapter.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\n/**\n * An empty {@link ClassVisitor} that delegates to another {@link ClassVisitor}.\n * This class can be used as a super class to quickly implement usefull class\n * adapter classes, just by overriding the necessary methods.\n *\n * @author Eric Bruneton\n */\npublic class ClassAdapter implements ClassVisitor {\n\n    /**\n     * The {@link ClassVisitor} to which this adapter delegates calls.\n     */\n    protected ClassVisitor cv;\n\n    /**\n     * Constructs a new {@link ClassAdapter} object.\n     *\n     * @param cv the class visitor to which this adapter must delegate calls.\n     */\n    public ClassAdapter(final ClassVisitor cv) {\n        this.cv = cv;\n    }\n\n    public void visit(final int version, final int access, final String name, final String signature, final String superName, final String[] interfaces) {\n        cv.visit(version, access, name, signature, superName, interfaces);\n    }\n\n    public void visitSource(final String source, final String debug) {\n        cv.visitSource(source, debug);\n    }\n\n    public void visitOuterClass(final String owner, final String name, final String desc) {\n        cv.visitOuterClass(owner, name, desc);\n    }\n\n    public AnnotationVisitor visitAnnotation(final String desc, final boolean visible) {\n        return cv.visitAnnotation(desc, visible);\n    }\n\n    public void visitAttribute(final Attribute attr) {\n        cv.visitAttribute(attr);\n    }\n\n    public void visitInnerClass(final String name, final String outerName, final String innerName, final int access) {\n        cv.visitInnerClass(name, outerName, innerName, access);\n    }\n\n    public FieldVisitor visitField(final int access, final String name, final String desc, final String signature, final Object value) {\n        return cv.visitField(access, name, desc, signature, value);\n    }\n\n    public MethodVisitor visitMethod(final int access, final String name, final String desc, final String signature, final String[] exceptions) {\n        return cv.visitMethod(access, name, desc, signature, exceptions);\n    }\n\n    public void visitEnd() {\n        cv.visitEnd();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/ClassAdapterTest2.java",
		"test_prompt": "// ClassAdapterTest2.java\npackage org.objectweb.asm.jip;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassAdapter}.\n* It contains ten unit test cases for the {@link ClassAdapter#visitMethod(int, String, String, String, String[])} method.\n*/\nclass ClassAdapterTest2 {"
	},
	{
		"original_code": "// AnnotationWriter.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\n/**\n * An {@link AnnotationVisitor} that generates annotations in bytecode form.\n *\n * @author Eric Bruneton\n * @author Eugene Kuleshov\n */\nfinal class AnnotationWriter implements AnnotationVisitor {\n\n    /**\n     * The class writer to which this annotation must be added.\n     */\n    private final ClassWriter cw;\n\n    /**\n     * The number of values in this annotation.\n     */\n    private int size;\n\n    /**\n     * <tt>true<tt> if values are named, <tt>false</tt> otherwise. Annotation\n     * writers used for annotation default and annotation arrays use unnamed\n     * values.\n     */\n    private final boolean named;\n\n    /**\n     * The annotation values in bytecode form. This byte vector only contains\n     * the values themselves, i.e. the number of values must be stored as a\n     * unsigned short just before these bytes.\n     */\n    private final ByteVector bv;\n\n    /**\n     * The byte vector to be used to store the number of values of this\n     * annotation. See {@link #bv}.\n     */\n    private final ByteVector parent;\n\n    /**\n     * Where the number of values of this annotation must be stored in\n     * {@link #parent}.\n     */\n    private final int offset;\n\n    /**\n     * Next annotation writer. This field is used to store annotation lists.\n     */\n    AnnotationWriter next;\n\n    /**\n     * Previous annotation writer. This field is used to store annotation lists.\n     */\n    AnnotationWriter prev;\n\n    // ------------------------------------------------------------------------\n    // Constructor\n    // ------------------------------------------------------------------------\n    /**\n     * Constructs a new {@link AnnotationWriter}.\n     *\n     * @param cw the class writer to which this annotation must be added.\n     * @param named <tt>true<tt> if values are named, <tt>false</tt> otherwise.\n     * @param bv where the annotation values must be stored.\n     * @param parent where the number of annotation values must be stored.\n     * @param offset where in <tt>parent</tt> the number of annotation values must\n     *      be stored.\n     */\n    AnnotationWriter(final ClassWriter cw, final boolean named, final ByteVector bv, final ByteVector parent, final int offset) {\n        this.cw = cw;\n        this.named = named;\n        this.bv = bv;\n        this.parent = parent;\n        this.offset = offset;\n    }\n\n    // ------------------------------------------------------------------------\n    // Implementation of the AnnotationVisitor interface\n    // ------------------------------------------------------------------------\n    public void visit(final String name, final Object value) {\n        ++size;\n        if (named) {\n            bv.putShort(cw.newUTF8(name));\n        }\n        if (value instanceof String) {\n            bv.put12('s', cw.newUTF8((String) value));\n        } else if (value instanceof Byte) {\n            bv.put12('B', cw.newInteger(((Byte) value).byteValue()).index);\n        } else if (value instanceof Boolean) {\n            int v = ((Boolean) value).booleanValue() ? 1 : 0;\n            bv.put12('Z', cw.newInteger(v).index);\n        } else if (value instanceof Character) {\n            bv.put12('C', cw.newInteger(((Character) value).charValue()).index);\n        } else if (value instanceof Short) {\n            bv.put12('S', cw.newInteger(((Short) value).shortValue()).index);\n        } else if (value instanceof Type) {\n            bv.put12('c', cw.newUTF8(((Type) value).getDescriptor()));\n        } else if (value instanceof byte[]) {\n            byte[] v = (byte[]) value;\n            bv.put12('[', v.length);\n            for (int i = 0; i < v.length; i++) {\n                bv.put12('B', cw.newInteger(v[i]).index);\n            }\n        } else if (value instanceof boolean[]) {\n            boolean[] v = (boolean[]) value;\n            bv.put12('[', v.length);\n            for (int i = 0; i < v.length; i++) {\n                bv.put12('Z', cw.newInteger(v[i] ? 1 : 0).index);\n            }\n        } else if (value instanceof short[]) {\n            short[] v = (short[]) value;\n            bv.put12('[', v.length);\n            for (int i = 0; i < v.length; i++) {\n                bv.put12('S', cw.newInteger(v[i]).index);\n            }\n        } else if (value instanceof char[]) {\n            char[] v = (char[]) value;\n            bv.put12('[', v.length);\n            for (int i = 0; i < v.length; i++) {\n                bv.put12('C', cw.newInteger(v[i]).index);\n            }\n        } else if (value instanceof int[]) {\n            int[] v = (int[]) value;\n            bv.put12('[', v.length);\n            for (int i = 0; i < v.length; i++) {\n                bv.put12('I', cw.newInteger(v[i]).index);\n            }\n        } else if (value instanceof long[]) {\n            long[] v = (long[]) value;\n            bv.put12('[', v.length);\n            for (int i = 0; i < v.length; i++) {\n                bv.put12('J', cw.newLong(v[i]).index);\n            }\n        } else if (value instanceof float[]) {\n            float[] v = (float[]) value;\n            bv.put12('[', v.length);\n            for (int i = 0; i < v.length; i++) {\n                bv.put12('F', cw.newFloat(v[i]).index);\n            }\n        } else if (value instanceof double[]) {\n            double[] v = (double[]) value;\n            bv.put12('[', v.length);\n            for (int i = 0; i < v.length; i++) {\n                bv.put12('D', cw.newDouble(v[i]).index);\n            }\n        } else {\n            Item i = cw.newConstItem(value);\n            bv.put12(\".s.IFJDCS\".charAt(i.type), i.index);\n        }\n    }\n\n    public void visitEnum(final String name, final String desc, final String value) {\n        ++size;\n        if (named) {\n            bv.putShort(cw.newUTF8(name));\n        }\n        bv.put12('e', cw.newUTF8(desc)).putShort(cw.newUTF8(value));\n    }\n\n    public AnnotationVisitor visitAnnotation(final String name, final String desc) {\n        ++size;\n        if (named) {\n            bv.putShort(cw.newUTF8(name));\n        }\n        // write tag and type, and reserve space for values count\n        bv.put12('@', cw.newUTF8(desc)).putShort(0);\n        return new AnnotationWriter(cw, true, bv, bv, bv.length - 2);\n    }\n\n    public AnnotationVisitor visitArray(final String name) {\n        ++size;\n        if (named) {\n            bv.putShort(cw.newUTF8(name));\n        }\n        // write tag, and reserve space for array size\n        bv.put12('[', 0);\n        return new AnnotationWriter(cw, false, bv, bv, bv.length - 2);\n    }\n\n    public void visitEnd() {\n        if (parent != null) {\n            byte[] data = parent.data;\n            data[offset] = (byte) (size >>> 8);\n            data[offset + 1] = (byte) size;\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Utility methods\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the size of this annotation writer list.\n     *\n     * @return the size of this annotation writer list.\n     */\n    int getSize() {\n        int size = 0;\n        AnnotationWriter aw = this;\n        while (aw != null) {\n            size += aw.bv.length;\n            aw = aw.next;\n        }\n        return size;\n    }\n\n    /**\n     * Puts the annotations of this annotation writer list into the given byte\n     * vector.\n     *\n     * @param out where the annotations must be put.\n     */\n    void put(final ByteVector out) {\n        int n = 0;\n        int size = 2;\n        AnnotationWriter aw = this;\n        AnnotationWriter last = null;\n        while (aw != null) {\n            ++n;\n            size += aw.bv.length;\n            // in case user forgot to call visitEnd\n            aw.visitEnd();\n            aw.prev = last;\n            last = aw;\n            aw = aw.next;\n        }\n        out.putInt(size);\n        out.putShort(n);\n        aw = last;\n        while (aw != null) {\n            out.putByteArray(aw.bv.data, 0, aw.bv.length);\n            aw = aw.prev;\n        }\n    }\n\n    /**\n     * Puts the given annotation lists into the given byte vector.\n     *\n     * @param panns an array of annotation writer lists.\n     * @param off index of the first annotation to be written.\n     * @param out where the annotations must be put.\n     */\n    static void put(final AnnotationWriter[] panns, final int off, final ByteVector out) {\n        int size = 1 + 2 * (panns.length - off);\n        for (int i = off; i < panns.length; ++i) {\n            size += panns[i] == null ? 0 : panns[i].getSize();\n        }\n        out.putInt(size).putByte(panns.length - off);\n        for (int i = off; i < panns.length; ++i) {\n            AnnotationWriter aw = panns[i];\n            AnnotationWriter last = null;\n            int n = 0;\n            while (aw != null) {\n                ++n;\n                // in case user forgot to call visitEnd\n                aw.visitEnd();\n                aw.prev = last;\n                last = aw;\n                aw = aw.next;\n            }\n            out.putShort(n);\n            aw = last;\n            while (aw != null) {\n                out.putByteArray(aw.bv.data, 0, aw.bv.length);\n                aw = aw.prev;\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/AnnotationWriterTest0.java",
		"test_prompt": "// AnnotationWriterTest0.java\npackage org.objectweb.asm.jip;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AnnotationWriter}.\n* It contains ten unit test cases for the {@link AnnotationWriter#visitAnnotation(String, String)} method.\n*/\nclass AnnotationWriterTest0 {"
	},
	{
		"original_code": "// AnnotationWriter.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\n/**\n * An {@link AnnotationVisitor} that generates annotations in bytecode form.\n *\n * @author Eric Bruneton\n * @author Eugene Kuleshov\n */\nfinal class AnnotationWriter implements AnnotationVisitor {\n\n    /**\n     * The class writer to which this annotation must be added.\n     */\n    private final ClassWriter cw;\n\n    /**\n     * The number of values in this annotation.\n     */\n    private int size;\n\n    /**\n     * <tt>true<tt> if values are named, <tt>false</tt> otherwise. Annotation\n     * writers used for annotation default and annotation arrays use unnamed\n     * values.\n     */\n    private final boolean named;\n\n    /**\n     * The annotation values in bytecode form. This byte vector only contains\n     * the values themselves, i.e. the number of values must be stored as a\n     * unsigned short just before these bytes.\n     */\n    private final ByteVector bv;\n\n    /**\n     * The byte vector to be used to store the number of values of this\n     * annotation. See {@link #bv}.\n     */\n    private final ByteVector parent;\n\n    /**\n     * Where the number of values of this annotation must be stored in\n     * {@link #parent}.\n     */\n    private final int offset;\n\n    /**\n     * Next annotation writer. This field is used to store annotation lists.\n     */\n    AnnotationWriter next;\n\n    /**\n     * Previous annotation writer. This field is used to store annotation lists.\n     */\n    AnnotationWriter prev;\n\n    // ------------------------------------------------------------------------\n    // Constructor\n    // ------------------------------------------------------------------------\n    /**\n     * Constructs a new {@link AnnotationWriter}.\n     *\n     * @param cw the class writer to which this annotation must be added.\n     * @param named <tt>true<tt> if values are named, <tt>false</tt> otherwise.\n     * @param bv where the annotation values must be stored.\n     * @param parent where the number of annotation values must be stored.\n     * @param offset where in <tt>parent</tt> the number of annotation values must\n     *      be stored.\n     */\n    AnnotationWriter(final ClassWriter cw, final boolean named, final ByteVector bv, final ByteVector parent, final int offset) {\n        this.cw = cw;\n        this.named = named;\n        this.bv = bv;\n        this.parent = parent;\n        this.offset = offset;\n    }\n\n    // ------------------------------------------------------------------------\n    // Implementation of the AnnotationVisitor interface\n    // ------------------------------------------------------------------------\n    public void visit(final String name, final Object value) {\n        ++size;\n        if (named) {\n            bv.putShort(cw.newUTF8(name));\n        }\n        if (value instanceof String) {\n            bv.put12('s', cw.newUTF8((String) value));\n        } else if (value instanceof Byte) {\n            bv.put12('B', cw.newInteger(((Byte) value).byteValue()).index);\n        } else if (value instanceof Boolean) {\n            int v = ((Boolean) value).booleanValue() ? 1 : 0;\n            bv.put12('Z', cw.newInteger(v).index);\n        } else if (value instanceof Character) {\n            bv.put12('C', cw.newInteger(((Character) value).charValue()).index);\n        } else if (value instanceof Short) {\n            bv.put12('S', cw.newInteger(((Short) value).shortValue()).index);\n        } else if (value instanceof Type) {\n            bv.put12('c', cw.newUTF8(((Type) value).getDescriptor()));\n        } else if (value instanceof byte[]) {\n            byte[] v = (byte[]) value;\n            bv.put12('[', v.length);\n            for (int i = 0; i < v.length; i++) {\n                bv.put12('B', cw.newInteger(v[i]).index);\n            }\n        } else if (value instanceof boolean[]) {\n            boolean[] v = (boolean[]) value;\n            bv.put12('[', v.length);\n            for (int i = 0; i < v.length; i++) {\n                bv.put12('Z', cw.newInteger(v[i] ? 1 : 0).index);\n            }\n        } else if (value instanceof short[]) {\n            short[] v = (short[]) value;\n            bv.put12('[', v.length);\n            for (int i = 0; i < v.length; i++) {\n                bv.put12('S', cw.newInteger(v[i]).index);\n            }\n        } else if (value instanceof char[]) {\n            char[] v = (char[]) value;\n            bv.put12('[', v.length);\n            for (int i = 0; i < v.length; i++) {\n                bv.put12('C', cw.newInteger(v[i]).index);\n            }\n        } else if (value instanceof int[]) {\n            int[] v = (int[]) value;\n            bv.put12('[', v.length);\n            for (int i = 0; i < v.length; i++) {\n                bv.put12('I', cw.newInteger(v[i]).index);\n            }\n        } else if (value instanceof long[]) {\n            long[] v = (long[]) value;\n            bv.put12('[', v.length);\n            for (int i = 0; i < v.length; i++) {\n                bv.put12('J', cw.newLong(v[i]).index);\n            }\n        } else if (value instanceof float[]) {\n            float[] v = (float[]) value;\n            bv.put12('[', v.length);\n            for (int i = 0; i < v.length; i++) {\n                bv.put12('F', cw.newFloat(v[i]).index);\n            }\n        } else if (value instanceof double[]) {\n            double[] v = (double[]) value;\n            bv.put12('[', v.length);\n            for (int i = 0; i < v.length; i++) {\n                bv.put12('D', cw.newDouble(v[i]).index);\n            }\n        } else {\n            Item i = cw.newConstItem(value);\n            bv.put12(\".s.IFJDCS\".charAt(i.type), i.index);\n        }\n    }\n\n    public void visitEnum(final String name, final String desc, final String value) {\n        ++size;\n        if (named) {\n            bv.putShort(cw.newUTF8(name));\n        }\n        bv.put12('e', cw.newUTF8(desc)).putShort(cw.newUTF8(value));\n    }\n\n    public AnnotationVisitor visitAnnotation(final String name, final String desc) {\n        ++size;\n        if (named) {\n            bv.putShort(cw.newUTF8(name));\n        }\n        // write tag and type, and reserve space for values count\n        bv.put12('@', cw.newUTF8(desc)).putShort(0);\n        return new AnnotationWriter(cw, true, bv, bv, bv.length - 2);\n    }\n\n    public AnnotationVisitor visitArray(final String name) {\n        ++size;\n        if (named) {\n            bv.putShort(cw.newUTF8(name));\n        }\n        // write tag, and reserve space for array size\n        bv.put12('[', 0);\n        return new AnnotationWriter(cw, false, bv, bv, bv.length - 2);\n    }\n\n    public void visitEnd() {\n        if (parent != null) {\n            byte[] data = parent.data;\n            data[offset] = (byte) (size >>> 8);\n            data[offset + 1] = (byte) size;\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Utility methods\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the size of this annotation writer list.\n     *\n     * @return the size of this annotation writer list.\n     */\n    int getSize() {\n        int size = 0;\n        AnnotationWriter aw = this;\n        while (aw != null) {\n            size += aw.bv.length;\n            aw = aw.next;\n        }\n        return size;\n    }\n\n    /**\n     * Puts the annotations of this annotation writer list into the given byte\n     * vector.\n     *\n     * @param out where the annotations must be put.\n     */\n    void put(final ByteVector out) {\n        int n = 0;\n        int size = 2;\n        AnnotationWriter aw = this;\n        AnnotationWriter last = null;\n        while (aw != null) {\n            ++n;\n            size += aw.bv.length;\n            // in case user forgot to call visitEnd\n            aw.visitEnd();\n            aw.prev = last;\n            last = aw;\n            aw = aw.next;\n        }\n        out.putInt(size);\n        out.putShort(n);\n        aw = last;\n        while (aw != null) {\n            out.putByteArray(aw.bv.data, 0, aw.bv.length);\n            aw = aw.prev;\n        }\n    }\n\n    /**\n     * Puts the given annotation lists into the given byte vector.\n     *\n     * @param panns an array of annotation writer lists.\n     * @param off index of the first annotation to be written.\n     * @param out where the annotations must be put.\n     */\n    static void put(final AnnotationWriter[] panns, final int off, final ByteVector out) {\n        int size = 1 + 2 * (panns.length - off);\n        for (int i = off; i < panns.length; ++i) {\n            size += panns[i] == null ? 0 : panns[i].getSize();\n        }\n        out.putInt(size).putByte(panns.length - off);\n        for (int i = off; i < panns.length; ++i) {\n            AnnotationWriter aw = panns[i];\n            AnnotationWriter last = null;\n            int n = 0;\n            while (aw != null) {\n                ++n;\n                // in case user forgot to call visitEnd\n                aw.visitEnd();\n                aw.prev = last;\n                last = aw;\n                aw = aw.next;\n            }\n            out.putShort(n);\n            aw = last;\n            while (aw != null) {\n                out.putByteArray(aw.bv.data, 0, aw.bv.length);\n                aw = aw.prev;\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/AnnotationWriterTest1.java",
		"test_prompt": "// AnnotationWriterTest1.java\npackage org.objectweb.asm.jip;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AnnotationWriter}.\n* It contains ten unit test cases for the {@link AnnotationWriter#visitArray(String)} method.\n*/\nclass AnnotationWriterTest1 {"
	},
	{
		"original_code": "// FieldWriter.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\n/**\n * An {@link FieldVisitor} that generates Java fields in bytecode form.\n *\n * @author Eric Bruneton\n */\nfinal class FieldWriter implements FieldVisitor {\n\n    /**\n     * Next field writer (see {@link ClassWriter#firstField firstField}).\n     */\n    FieldWriter next;\n\n    /**\n     * The class writer to which this field must be added.\n     */\n    private final ClassWriter cw;\n\n    /**\n     * Access flags of this field.\n     */\n    private final int access;\n\n    /**\n     * The index of the constant pool item that contains the name of this\n     * method.\n     */\n    private final int name;\n\n    /**\n     * The index of the constant pool item that contains the descriptor of this\n     * field.\n     */\n    private final int desc;\n\n    /**\n     * The index of the constant pool item that contains the signature of this\n     * field.\n     */\n    private int signature;\n\n    /**\n     * The index of the constant pool item that contains the constant value of\n     * this field.\n     */\n    private int value;\n\n    /**\n     * The runtime visible annotations of this field. May be <tt>null</tt>.\n     */\n    private AnnotationWriter anns;\n\n    /**\n     * The runtime invisible annotations of this field. May be <tt>null</tt>.\n     */\n    private AnnotationWriter ianns;\n\n    /**\n     * The non standard attributes of this field. May be <tt>null</tt>.\n     */\n    private Attribute attrs;\n\n    // ------------------------------------------------------------------------\n    // Constructor\n    // ------------------------------------------------------------------------\n    /**\n     * Constructs a new {@link FieldWriter}.\n     *\n     * @param cw the class writer to which this field must be added.\n     * @param access the field's access flags (see {@link Opcodes}).\n     * @param name the field's name.\n     * @param desc the field's descriptor (see {@link Type}).\n     * @param signature the field's signature. May be <tt>null</tt>.\n     * @param value the field's constant value. May be <tt>null</tt>.\n     */\n    FieldWriter(final ClassWriter cw, final int access, final String name, final String desc, final String signature, final Object value) {\n        if (cw.firstField == null) {\n            cw.firstField = this;\n        } else {\n            cw.lastField.next = this;\n        }\n        cw.lastField = this;\n        this.cw = cw;\n        this.access = access;\n        this.name = cw.newUTF8(name);\n        this.desc = cw.newUTF8(desc);\n        if (ClassReader.SIGNATURES && signature != null) {\n            this.signature = cw.newUTF8(signature);\n        }\n        if (value != null) {\n            this.value = cw.newConstItem(value).index;\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Implementation of the FieldVisitor interface\n    // ------------------------------------------------------------------------\n    public AnnotationVisitor visitAnnotation(final String desc, final boolean visible) {\n        if (!ClassReader.ANNOTATIONS) {\n            return null;\n        }\n        ByteVector bv = new ByteVector();\n        // write type, and reserve space for values count\n        bv.putShort(cw.newUTF8(desc)).putShort(0);\n        AnnotationWriter aw = new AnnotationWriter(cw, true, bv, bv, 2);\n        if (visible) {\n            aw.next = anns;\n            anns = aw;\n        } else {\n            aw.next = ianns;\n            ianns = aw;\n        }\n        return aw;\n    }\n\n    public void visitAttribute(final Attribute attr) {\n        attr.next = attrs;\n        attrs = attr;\n    }\n\n    public void visitEnd() {\n    }\n\n    // ------------------------------------------------------------------------\n    // Utility methods\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the size of this field.\n     *\n     * @return the size of this field.\n     */\n    int getSize() {\n        int size = 8;\n        if (value != 0) {\n            cw.newUTF8(\"ConstantValue\");\n            size += 8;\n        }\n        if ((access & Opcodes.ACC_SYNTHETIC) != 0 && (cw.version & 0xffff) < Opcodes.V1_5) {\n            cw.newUTF8(\"Synthetic\");\n            size += 6;\n        }\n        if ((access & Opcodes.ACC_DEPRECATED) != 0) {\n            cw.newUTF8(\"Deprecated\");\n            size += 6;\n        }\n        if (ClassReader.SIGNATURES && signature != 0) {\n            cw.newUTF8(\"Signature\");\n            size += 8;\n        }\n        if (ClassReader.ANNOTATIONS && anns != null) {\n            cw.newUTF8(\"RuntimeVisibleAnnotations\");\n            size += 8 + anns.getSize();\n        }\n        if (ClassReader.ANNOTATIONS && ianns != null) {\n            cw.newUTF8(\"RuntimeInvisibleAnnotations\");\n            size += 8 + ianns.getSize();\n        }\n        if (attrs != null) {\n            size += attrs.getSize(cw, null, 0, -1, -1);\n        }\n        return size;\n    }\n\n    /**\n     * Puts the content of this field into the given byte vector.\n     *\n     * @param out where the content of this field must be put.\n     */\n    void put(final ByteVector out) {\n        out.putShort(access).putShort(name).putShort(desc);\n        int attributeCount = 0;\n        if (value != 0) {\n            ++attributeCount;\n        }\n        if ((access & Opcodes.ACC_SYNTHETIC) != 0 && (cw.version & 0xffff) < Opcodes.V1_5) {\n            ++attributeCount;\n        }\n        if ((access & Opcodes.ACC_DEPRECATED) != 0) {\n            ++attributeCount;\n        }\n        if (ClassReader.SIGNATURES && signature != 0) {\n            ++attributeCount;\n        }\n        if (ClassReader.ANNOTATIONS && anns != null) {\n            ++attributeCount;\n        }\n        if (ClassReader.ANNOTATIONS && ianns != null) {\n            ++attributeCount;\n        }\n        if (attrs != null) {\n            attributeCount += attrs.getCount();\n        }\n        out.putShort(attributeCount);\n        if (value != 0) {\n            out.putShort(cw.newUTF8(\"ConstantValue\"));\n            out.putInt(2).putShort(value);\n        }\n        if ((access & Opcodes.ACC_SYNTHETIC) != 0 && (cw.version & 0xffff) < Opcodes.V1_5) {\n            out.putShort(cw.newUTF8(\"Synthetic\")).putInt(0);\n        }\n        if ((access & Opcodes.ACC_DEPRECATED) != 0) {\n            out.putShort(cw.newUTF8(\"Deprecated\")).putInt(0);\n        }\n        if (ClassReader.SIGNATURES && signature != 0) {\n            out.putShort(cw.newUTF8(\"Signature\"));\n            out.putInt(2).putShort(signature);\n        }\n        if (ClassReader.ANNOTATIONS && anns != null) {\n            out.putShort(cw.newUTF8(\"RuntimeVisibleAnnotations\"));\n            anns.put(out);\n        }\n        if (ClassReader.ANNOTATIONS && ianns != null) {\n            out.putShort(cw.newUTF8(\"RuntimeInvisibleAnnotations\"));\n            ianns.put(out);\n        }\n        if (attrs != null) {\n            attrs.put(cw, null, 0, -1, -1, out);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/FieldWriterTest.java",
		"test_prompt": "// FieldWriterTest.java\npackage org.objectweb.asm.jip;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FieldWriter}.\n* It contains ten unit test cases for the {@link FieldWriter#visitAnnotation(String, boolean)} method.\n*/\nclass FieldWriterTest {"
	},
	{
		"original_code": "// ByteVector.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\n/**\n * A dynamically extensible vector of bytes. This class is roughly equivalent to\n * a DataOutputStream on top of a ByteArrayOutputStream, but is more efficient.\n *\n * @author Eric Bruneton\n */\npublic class ByteVector {\n\n    /**\n     * The content of this vector.\n     */\n    byte[] data;\n\n    /**\n     * Actual number of bytes in this vector.\n     */\n    int length;\n\n    /**\n     * Constructs a new {@link ByteVector ByteVector} with a default initial\n     * size.\n     */\n    public ByteVector() {\n        data = new byte[64];\n    }\n\n    /**\n     * Constructs a new {@link ByteVector ByteVector} with the given initial\n     * size.\n     *\n     * @param initialSize the initial size of the byte vector to be constructed.\n     */\n    public ByteVector(final int initialSize) {\n        data = new byte[initialSize];\n    }\n\n    /**\n     * Puts a byte into this byte vector. The byte vector is automatically\n     * enlarged if necessary.\n     *\n     * @param b a byte.\n     * @return this byte vector.\n     */\n    public ByteVector putByte(final int b) {\n        int length = this.length;\n        if (length + 1 > data.length) {\n            enlarge(1);\n        }\n        data[length++] = (byte) b;\n        this.length = length;\n        return this;\n    }\n\n    /**\n     * Puts two bytes into this byte vector. The byte vector is automatically\n     * enlarged if necessary.\n     *\n     * @param b1 a byte.\n     * @param b2 another byte.\n     * @return this byte vector.\n     */\n    ByteVector put11(final int b1, final int b2) {\n        int length = this.length;\n        if (length + 2 > data.length) {\n            enlarge(2);\n        }\n        byte[] data = this.data;\n        data[length++] = (byte) b1;\n        data[length++] = (byte) b2;\n        this.length = length;\n        return this;\n    }\n\n    /**\n     * Puts a short into this byte vector. The byte vector is automatically\n     * enlarged if necessary.\n     *\n     * @param s a short.\n     * @return this byte vector.\n     */\n    public ByteVector putShort(final int s) {\n        int length = this.length;\n        if (length + 2 > data.length) {\n            enlarge(2);\n        }\n        byte[] data = this.data;\n        data[length++] = (byte) (s >>> 8);\n        data[length++] = (byte) s;\n        this.length = length;\n        return this;\n    }\n\n    /**\n     * Puts a byte and a short into this byte vector. The byte vector is\n     * automatically enlarged if necessary.\n     *\n     * @param b a byte.\n     * @param s a short.\n     * @return this byte vector.\n     */\n    ByteVector put12(final int b, final int s) {\n        int length = this.length;\n        if (length + 3 > data.length) {\n            enlarge(3);\n        }\n        byte[] data = this.data;\n        data[length++] = (byte) b;\n        data[length++] = (byte) (s >>> 8);\n        data[length++] = (byte) s;\n        this.length = length;\n        return this;\n    }\n\n    /**\n     * Puts an int into this byte vector. The byte vector is automatically\n     * enlarged if necessary.\n     *\n     * @param i an int.\n     * @return this byte vector.\n     */\n    public ByteVector putInt(final int i) {\n        int length = this.length;\n        if (length + 4 > data.length) {\n            enlarge(4);\n        }\n        byte[] data = this.data;\n        data[length++] = (byte) (i >>> 24);\n        data[length++] = (byte) (i >>> 16);\n        data[length++] = (byte) (i >>> 8);\n        data[length++] = (byte) i;\n        this.length = length;\n        return this;\n    }\n\n    /**\n     * Puts a long into this byte vector. The byte vector is automatically\n     * enlarged if necessary.\n     *\n     * @param l a long.\n     * @return this byte vector.\n     */\n    public ByteVector putLong(final long l) {\n        int length = this.length;\n        if (length + 8 > data.length) {\n            enlarge(8);\n        }\n        byte[] data = this.data;\n        int i = (int) (l >>> 32);\n        data[length++] = (byte) (i >>> 24);\n        data[length++] = (byte) (i >>> 16);\n        data[length++] = (byte) (i >>> 8);\n        data[length++] = (byte) i;\n        i = (int) l;\n        data[length++] = (byte) (i >>> 24);\n        data[length++] = (byte) (i >>> 16);\n        data[length++] = (byte) (i >>> 8);\n        data[length++] = (byte) i;\n        this.length = length;\n        return this;\n    }\n\n    /**\n     * Puts an UTF8 string into this byte vector. The byte vector is\n     * automatically enlarged if necessary.\n     *\n     * @param s a String.\n     * @return this byte vector.\n     */\n    public ByteVector putUTF8(final String s) {\n        int charLength = s.length();\n        int len = length;\n        if (len + 2 + charLength > data.length) {\n            enlarge(2 + charLength);\n        }\n        byte[] data = this.data;\n        // optimistic algorithm: instead of computing the byte length and then\n        // serializing the string (which requires two loops), we assume the byte\n        // length is equal to char length (which is the most frequent case), and\n        // we start serializing the string right away. During the serialization,\n        // if we find that this assumption is wrong, we continue with the\n        // general method.\n        data[len++] = (byte) (charLength >>> 8);\n        data[len++] = (byte) charLength;\n        for (int i = 0; i < charLength; ++i) {\n            char c = s.charAt(i);\n            if (c >= '\\001' && c <= '\\177') {\n                data[len++] = (byte) c;\n            } else {\n                int byteLength = i;\n                for (int j = i; j < charLength; ++j) {\n                    c = s.charAt(j);\n                    if (c >= '\\001' && c <= '\\177') {\n                        byteLength++;\n                    } else if (c > '\\u07FF') {\n                        byteLength += 3;\n                    } else {\n                        byteLength += 2;\n                    }\n                }\n                data[length] = (byte) (byteLength >>> 8);\n                data[length + 1] = (byte) byteLength;\n                if (length + 2 + byteLength > data.length) {\n                    length = len;\n                    enlarge(2 + byteLength);\n                    data = this.data;\n                }\n                for (int j = i; j < charLength; ++j) {\n                    c = s.charAt(j);\n                    if (c >= '\\001' && c <= '\\177') {\n                        data[len++] = (byte) c;\n                    } else if (c > '\\u07FF') {\n                        data[len++] = (byte) (0xE0 | c >> 12 & 0xF);\n                        data[len++] = (byte) (0x80 | c >> 6 & 0x3F);\n                        data[len++] = (byte) (0x80 | c & 0x3F);\n                    } else {\n                        data[len++] = (byte) (0xC0 | c >> 6 & 0x1F);\n                        data[len++] = (byte) (0x80 | c & 0x3F);\n                    }\n                }\n                break;\n            }\n        }\n        length = len;\n        return this;\n    }\n\n    /**\n     * Puts an array of bytes into this byte vector. The byte vector is\n     * automatically enlarged if necessary.\n     *\n     * @param b an array of bytes. May be <tt>null</tt> to put <tt>len</tt>\n     *        null bytes into this byte vector.\n     * @param off index of the fist byte of b that must be copied.\n     * @param len number of bytes of b that must be copied.\n     * @return this byte vector.\n     */\n    public ByteVector putByteArray(final byte[] b, final int off, final int len) {\n        if (length + len > data.length) {\n            enlarge(len);\n        }\n        if (b != null) {\n            System.arraycopy(b, off, data, length, len);\n        }\n        length += len;\n        return this;\n    }\n\n    /**\n     * Enlarge this byte vector so that it can receive n more bytes.\n     *\n     * @param size number of additional bytes that this byte vector should be\n     *        able to receive.\n     */\n    private void enlarge(final int size) {\n        int length1 = 2 * data.length;\n        int length2 = length + size;\n        byte[] newData = new byte[length1 > length2 ? length1 : length2];\n        System.arraycopy(data, 0, newData, 0, length);\n        data = newData;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/ByteVectorTest0.java",
		"test_prompt": "// ByteVectorTest0.java\npackage org.objectweb.asm.jip;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ByteVector}.\n* It contains ten unit test cases for the {@link ByteVector#putByte(int)} method.\n*/\nclass ByteVectorTest0 {"
	},
	{
		"original_code": "// ByteVector.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\n/**\n * A dynamically extensible vector of bytes. This class is roughly equivalent to\n * a DataOutputStream on top of a ByteArrayOutputStream, but is more efficient.\n *\n * @author Eric Bruneton\n */\npublic class ByteVector {\n\n    /**\n     * The content of this vector.\n     */\n    byte[] data;\n\n    /**\n     * Actual number of bytes in this vector.\n     */\n    int length;\n\n    /**\n     * Constructs a new {@link ByteVector ByteVector} with a default initial\n     * size.\n     */\n    public ByteVector() {\n        data = new byte[64];\n    }\n\n    /**\n     * Constructs a new {@link ByteVector ByteVector} with the given initial\n     * size.\n     *\n     * @param initialSize the initial size of the byte vector to be constructed.\n     */\n    public ByteVector(final int initialSize) {\n        data = new byte[initialSize];\n    }\n\n    /**\n     * Puts a byte into this byte vector. The byte vector is automatically\n     * enlarged if necessary.\n     *\n     * @param b a byte.\n     * @return this byte vector.\n     */\n    public ByteVector putByte(final int b) {\n        int length = this.length;\n        if (length + 1 > data.length) {\n            enlarge(1);\n        }\n        data[length++] = (byte) b;\n        this.length = length;\n        return this;\n    }\n\n    /**\n     * Puts two bytes into this byte vector. The byte vector is automatically\n     * enlarged if necessary.\n     *\n     * @param b1 a byte.\n     * @param b2 another byte.\n     * @return this byte vector.\n     */\n    ByteVector put11(final int b1, final int b2) {\n        int length = this.length;\n        if (length + 2 > data.length) {\n            enlarge(2);\n        }\n        byte[] data = this.data;\n        data[length++] = (byte) b1;\n        data[length++] = (byte) b2;\n        this.length = length;\n        return this;\n    }\n\n    /**\n     * Puts a short into this byte vector. The byte vector is automatically\n     * enlarged if necessary.\n     *\n     * @param s a short.\n     * @return this byte vector.\n     */\n    public ByteVector putShort(final int s) {\n        int length = this.length;\n        if (length + 2 > data.length) {\n            enlarge(2);\n        }\n        byte[] data = this.data;\n        data[length++] = (byte) (s >>> 8);\n        data[length++] = (byte) s;\n        this.length = length;\n        return this;\n    }\n\n    /**\n     * Puts a byte and a short into this byte vector. The byte vector is\n     * automatically enlarged if necessary.\n     *\n     * @param b a byte.\n     * @param s a short.\n     * @return this byte vector.\n     */\n    ByteVector put12(final int b, final int s) {\n        int length = this.length;\n        if (length + 3 > data.length) {\n            enlarge(3);\n        }\n        byte[] data = this.data;\n        data[length++] = (byte) b;\n        data[length++] = (byte) (s >>> 8);\n        data[length++] = (byte) s;\n        this.length = length;\n        return this;\n    }\n\n    /**\n     * Puts an int into this byte vector. The byte vector is automatically\n     * enlarged if necessary.\n     *\n     * @param i an int.\n     * @return this byte vector.\n     */\n    public ByteVector putInt(final int i) {\n        int length = this.length;\n        if (length + 4 > data.length) {\n            enlarge(4);\n        }\n        byte[] data = this.data;\n        data[length++] = (byte) (i >>> 24);\n        data[length++] = (byte) (i >>> 16);\n        data[length++] = (byte) (i >>> 8);\n        data[length++] = (byte) i;\n        this.length = length;\n        return this;\n    }\n\n    /**\n     * Puts a long into this byte vector. The byte vector is automatically\n     * enlarged if necessary.\n     *\n     * @param l a long.\n     * @return this byte vector.\n     */\n    public ByteVector putLong(final long l) {\n        int length = this.length;\n        if (length + 8 > data.length) {\n            enlarge(8);\n        }\n        byte[] data = this.data;\n        int i = (int) (l >>> 32);\n        data[length++] = (byte) (i >>> 24);\n        data[length++] = (byte) (i >>> 16);\n        data[length++] = (byte) (i >>> 8);\n        data[length++] = (byte) i;\n        i = (int) l;\n        data[length++] = (byte) (i >>> 24);\n        data[length++] = (byte) (i >>> 16);\n        data[length++] = (byte) (i >>> 8);\n        data[length++] = (byte) i;\n        this.length = length;\n        return this;\n    }\n\n    /**\n     * Puts an UTF8 string into this byte vector. The byte vector is\n     * automatically enlarged if necessary.\n     *\n     * @param s a String.\n     * @return this byte vector.\n     */\n    public ByteVector putUTF8(final String s) {\n        int charLength = s.length();\n        int len = length;\n        if (len + 2 + charLength > data.length) {\n            enlarge(2 + charLength);\n        }\n        byte[] data = this.data;\n        // optimistic algorithm: instead of computing the byte length and then\n        // serializing the string (which requires two loops), we assume the byte\n        // length is equal to char length (which is the most frequent case), and\n        // we start serializing the string right away. During the serialization,\n        // if we find that this assumption is wrong, we continue with the\n        // general method.\n        data[len++] = (byte) (charLength >>> 8);\n        data[len++] = (byte) charLength;\n        for (int i = 0; i < charLength; ++i) {\n            char c = s.charAt(i);\n            if (c >= '\\001' && c <= '\\177') {\n                data[len++] = (byte) c;\n            } else {\n                int byteLength = i;\n                for (int j = i; j < charLength; ++j) {\n                    c = s.charAt(j);\n                    if (c >= '\\001' && c <= '\\177') {\n                        byteLength++;\n                    } else if (c > '\\u07FF') {\n                        byteLength += 3;\n                    } else {\n                        byteLength += 2;\n                    }\n                }\n                data[length] = (byte) (byteLength >>> 8);\n                data[length + 1] = (byte) byteLength;\n                if (length + 2 + byteLength > data.length) {\n                    length = len;\n                    enlarge(2 + byteLength);\n                    data = this.data;\n                }\n                for (int j = i; j < charLength; ++j) {\n                    c = s.charAt(j);\n                    if (c >= '\\001' && c <= '\\177') {\n                        data[len++] = (byte) c;\n                    } else if (c > '\\u07FF') {\n                        data[len++] = (byte) (0xE0 | c >> 12 & 0xF);\n                        data[len++] = (byte) (0x80 | c >> 6 & 0x3F);\n                        data[len++] = (byte) (0x80 | c & 0x3F);\n                    } else {\n                        data[len++] = (byte) (0xC0 | c >> 6 & 0x1F);\n                        data[len++] = (byte) (0x80 | c & 0x3F);\n                    }\n                }\n                break;\n            }\n        }\n        length = len;\n        return this;\n    }\n\n    /**\n     * Puts an array of bytes into this byte vector. The byte vector is\n     * automatically enlarged if necessary.\n     *\n     * @param b an array of bytes. May be <tt>null</tt> to put <tt>len</tt>\n     *        null bytes into this byte vector.\n     * @param off index of the fist byte of b that must be copied.\n     * @param len number of bytes of b that must be copied.\n     * @return this byte vector.\n     */\n    public ByteVector putByteArray(final byte[] b, final int off, final int len) {\n        if (length + len > data.length) {\n            enlarge(len);\n        }\n        if (b != null) {\n            System.arraycopy(b, off, data, length, len);\n        }\n        length += len;\n        return this;\n    }\n\n    /**\n     * Enlarge this byte vector so that it can receive n more bytes.\n     *\n     * @param size number of additional bytes that this byte vector should be\n     *        able to receive.\n     */\n    private void enlarge(final int size) {\n        int length1 = 2 * data.length;\n        int length2 = length + size;\n        byte[] newData = new byte[length1 > length2 ? length1 : length2];\n        System.arraycopy(data, 0, newData, 0, length);\n        data = newData;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/ByteVectorTest1.java",
		"test_prompt": "// ByteVectorTest1.java\npackage org.objectweb.asm.jip;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ByteVector}.\n* It contains ten unit test cases for the {@link ByteVector#putShort(int)} method.\n*/\nclass ByteVectorTest1 {"
	},
	{
		"original_code": "// ByteVector.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\n/**\n * A dynamically extensible vector of bytes. This class is roughly equivalent to\n * a DataOutputStream on top of a ByteArrayOutputStream, but is more efficient.\n *\n * @author Eric Bruneton\n */\npublic class ByteVector {\n\n    /**\n     * The content of this vector.\n     */\n    byte[] data;\n\n    /**\n     * Actual number of bytes in this vector.\n     */\n    int length;\n\n    /**\n     * Constructs a new {@link ByteVector ByteVector} with a default initial\n     * size.\n     */\n    public ByteVector() {\n        data = new byte[64];\n    }\n\n    /**\n     * Constructs a new {@link ByteVector ByteVector} with the given initial\n     * size.\n     *\n     * @param initialSize the initial size of the byte vector to be constructed.\n     */\n    public ByteVector(final int initialSize) {\n        data = new byte[initialSize];\n    }\n\n    /**\n     * Puts a byte into this byte vector. The byte vector is automatically\n     * enlarged if necessary.\n     *\n     * @param b a byte.\n     * @return this byte vector.\n     */\n    public ByteVector putByte(final int b) {\n        int length = this.length;\n        if (length + 1 > data.length) {\n            enlarge(1);\n        }\n        data[length++] = (byte) b;\n        this.length = length;\n        return this;\n    }\n\n    /**\n     * Puts two bytes into this byte vector. The byte vector is automatically\n     * enlarged if necessary.\n     *\n     * @param b1 a byte.\n     * @param b2 another byte.\n     * @return this byte vector.\n     */\n    ByteVector put11(final int b1, final int b2) {\n        int length = this.length;\n        if (length + 2 > data.length) {\n            enlarge(2);\n        }\n        byte[] data = this.data;\n        data[length++] = (byte) b1;\n        data[length++] = (byte) b2;\n        this.length = length;\n        return this;\n    }\n\n    /**\n     * Puts a short into this byte vector. The byte vector is automatically\n     * enlarged if necessary.\n     *\n     * @param s a short.\n     * @return this byte vector.\n     */\n    public ByteVector putShort(final int s) {\n        int length = this.length;\n        if (length + 2 > data.length) {\n            enlarge(2);\n        }\n        byte[] data = this.data;\n        data[length++] = (byte) (s >>> 8);\n        data[length++] = (byte) s;\n        this.length = length;\n        return this;\n    }\n\n    /**\n     * Puts a byte and a short into this byte vector. The byte vector is\n     * automatically enlarged if necessary.\n     *\n     * @param b a byte.\n     * @param s a short.\n     * @return this byte vector.\n     */\n    ByteVector put12(final int b, final int s) {\n        int length = this.length;\n        if (length + 3 > data.length) {\n            enlarge(3);\n        }\n        byte[] data = this.data;\n        data[length++] = (byte) b;\n        data[length++] = (byte) (s >>> 8);\n        data[length++] = (byte) s;\n        this.length = length;\n        return this;\n    }\n\n    /**\n     * Puts an int into this byte vector. The byte vector is automatically\n     * enlarged if necessary.\n     *\n     * @param i an int.\n     * @return this byte vector.\n     */\n    public ByteVector putInt(final int i) {\n        int length = this.length;\n        if (length + 4 > data.length) {\n            enlarge(4);\n        }\n        byte[] data = this.data;\n        data[length++] = (byte) (i >>> 24);\n        data[length++] = (byte) (i >>> 16);\n        data[length++] = (byte) (i >>> 8);\n        data[length++] = (byte) i;\n        this.length = length;\n        return this;\n    }\n\n    /**\n     * Puts a long into this byte vector. The byte vector is automatically\n     * enlarged if necessary.\n     *\n     * @param l a long.\n     * @return this byte vector.\n     */\n    public ByteVector putLong(final long l) {\n        int length = this.length;\n        if (length + 8 > data.length) {\n            enlarge(8);\n        }\n        byte[] data = this.data;\n        int i = (int) (l >>> 32);\n        data[length++] = (byte) (i >>> 24);\n        data[length++] = (byte) (i >>> 16);\n        data[length++] = (byte) (i >>> 8);\n        data[length++] = (byte) i;\n        i = (int) l;\n        data[length++] = (byte) (i >>> 24);\n        data[length++] = (byte) (i >>> 16);\n        data[length++] = (byte) (i >>> 8);\n        data[length++] = (byte) i;\n        this.length = length;\n        return this;\n    }\n\n    /**\n     * Puts an UTF8 string into this byte vector. The byte vector is\n     * automatically enlarged if necessary.\n     *\n     * @param s a String.\n     * @return this byte vector.\n     */\n    public ByteVector putUTF8(final String s) {\n        int charLength = s.length();\n        int len = length;\n        if (len + 2 + charLength > data.length) {\n            enlarge(2 + charLength);\n        }\n        byte[] data = this.data;\n        // optimistic algorithm: instead of computing the byte length and then\n        // serializing the string (which requires two loops), we assume the byte\n        // length is equal to char length (which is the most frequent case), and\n        // we start serializing the string right away. During the serialization,\n        // if we find that this assumption is wrong, we continue with the\n        // general method.\n        data[len++] = (byte) (charLength >>> 8);\n        data[len++] = (byte) charLength;\n        for (int i = 0; i < charLength; ++i) {\n            char c = s.charAt(i);\n            if (c >= '\\001' && c <= '\\177') {\n                data[len++] = (byte) c;\n            } else {\n                int byteLength = i;\n                for (int j = i; j < charLength; ++j) {\n                    c = s.charAt(j);\n                    if (c >= '\\001' && c <= '\\177') {\n                        byteLength++;\n                    } else if (c > '\\u07FF') {\n                        byteLength += 3;\n                    } else {\n                        byteLength += 2;\n                    }\n                }\n                data[length] = (byte) (byteLength >>> 8);\n                data[length + 1] = (byte) byteLength;\n                if (length + 2 + byteLength > data.length) {\n                    length = len;\n                    enlarge(2 + byteLength);\n                    data = this.data;\n                }\n                for (int j = i; j < charLength; ++j) {\n                    c = s.charAt(j);\n                    if (c >= '\\001' && c <= '\\177') {\n                        data[len++] = (byte) c;\n                    } else if (c > '\\u07FF') {\n                        data[len++] = (byte) (0xE0 | c >> 12 & 0xF);\n                        data[len++] = (byte) (0x80 | c >> 6 & 0x3F);\n                        data[len++] = (byte) (0x80 | c & 0x3F);\n                    } else {\n                        data[len++] = (byte) (0xC0 | c >> 6 & 0x1F);\n                        data[len++] = (byte) (0x80 | c & 0x3F);\n                    }\n                }\n                break;\n            }\n        }\n        length = len;\n        return this;\n    }\n\n    /**\n     * Puts an array of bytes into this byte vector. The byte vector is\n     * automatically enlarged if necessary.\n     *\n     * @param b an array of bytes. May be <tt>null</tt> to put <tt>len</tt>\n     *        null bytes into this byte vector.\n     * @param off index of the fist byte of b that must be copied.\n     * @param len number of bytes of b that must be copied.\n     * @return this byte vector.\n     */\n    public ByteVector putByteArray(final byte[] b, final int off, final int len) {\n        if (length + len > data.length) {\n            enlarge(len);\n        }\n        if (b != null) {\n            System.arraycopy(b, off, data, length, len);\n        }\n        length += len;\n        return this;\n    }\n\n    /**\n     * Enlarge this byte vector so that it can receive n more bytes.\n     *\n     * @param size number of additional bytes that this byte vector should be\n     *        able to receive.\n     */\n    private void enlarge(final int size) {\n        int length1 = 2 * data.length;\n        int length2 = length + size;\n        byte[] newData = new byte[length1 > length2 ? length1 : length2];\n        System.arraycopy(data, 0, newData, 0, length);\n        data = newData;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/ByteVectorTest2.java",
		"test_prompt": "// ByteVectorTest2.java\npackage org.objectweb.asm.jip;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ByteVector}.\n* It contains ten unit test cases for the {@link ByteVector#putInt(int)} method.\n*/\nclass ByteVectorTest2 {"
	},
	{
		"original_code": "// ByteVector.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\n/**\n * A dynamically extensible vector of bytes. This class is roughly equivalent to\n * a DataOutputStream on top of a ByteArrayOutputStream, but is more efficient.\n *\n * @author Eric Bruneton\n */\npublic class ByteVector {\n\n    /**\n     * The content of this vector.\n     */\n    byte[] data;\n\n    /**\n     * Actual number of bytes in this vector.\n     */\n    int length;\n\n    /**\n     * Constructs a new {@link ByteVector ByteVector} with a default initial\n     * size.\n     */\n    public ByteVector() {\n        data = new byte[64];\n    }\n\n    /**\n     * Constructs a new {@link ByteVector ByteVector} with the given initial\n     * size.\n     *\n     * @param initialSize the initial size of the byte vector to be constructed.\n     */\n    public ByteVector(final int initialSize) {\n        data = new byte[initialSize];\n    }\n\n    /**\n     * Puts a byte into this byte vector. The byte vector is automatically\n     * enlarged if necessary.\n     *\n     * @param b a byte.\n     * @return this byte vector.\n     */\n    public ByteVector putByte(final int b) {\n        int length = this.length;\n        if (length + 1 > data.length) {\n            enlarge(1);\n        }\n        data[length++] = (byte) b;\n        this.length = length;\n        return this;\n    }\n\n    /**\n     * Puts two bytes into this byte vector. The byte vector is automatically\n     * enlarged if necessary.\n     *\n     * @param b1 a byte.\n     * @param b2 another byte.\n     * @return this byte vector.\n     */\n    ByteVector put11(final int b1, final int b2) {\n        int length = this.length;\n        if (length + 2 > data.length) {\n            enlarge(2);\n        }\n        byte[] data = this.data;\n        data[length++] = (byte) b1;\n        data[length++] = (byte) b2;\n        this.length = length;\n        return this;\n    }\n\n    /**\n     * Puts a short into this byte vector. The byte vector is automatically\n     * enlarged if necessary.\n     *\n     * @param s a short.\n     * @return this byte vector.\n     */\n    public ByteVector putShort(final int s) {\n        int length = this.length;\n        if (length + 2 > data.length) {\n            enlarge(2);\n        }\n        byte[] data = this.data;\n        data[length++] = (byte) (s >>> 8);\n        data[length++] = (byte) s;\n        this.length = length;\n        return this;\n    }\n\n    /**\n     * Puts a byte and a short into this byte vector. The byte vector is\n     * automatically enlarged if necessary.\n     *\n     * @param b a byte.\n     * @param s a short.\n     * @return this byte vector.\n     */\n    ByteVector put12(final int b, final int s) {\n        int length = this.length;\n        if (length + 3 > data.length) {\n            enlarge(3);\n        }\n        byte[] data = this.data;\n        data[length++] = (byte) b;\n        data[length++] = (byte) (s >>> 8);\n        data[length++] = (byte) s;\n        this.length = length;\n        return this;\n    }\n\n    /**\n     * Puts an int into this byte vector. The byte vector is automatically\n     * enlarged if necessary.\n     *\n     * @param i an int.\n     * @return this byte vector.\n     */\n    public ByteVector putInt(final int i) {\n        int length = this.length;\n        if (length + 4 > data.length) {\n            enlarge(4);\n        }\n        byte[] data = this.data;\n        data[length++] = (byte) (i >>> 24);\n        data[length++] = (byte) (i >>> 16);\n        data[length++] = (byte) (i >>> 8);\n        data[length++] = (byte) i;\n        this.length = length;\n        return this;\n    }\n\n    /**\n     * Puts a long into this byte vector. The byte vector is automatically\n     * enlarged if necessary.\n     *\n     * @param l a long.\n     * @return this byte vector.\n     */\n    public ByteVector putLong(final long l) {\n        int length = this.length;\n        if (length + 8 > data.length) {\n            enlarge(8);\n        }\n        byte[] data = this.data;\n        int i = (int) (l >>> 32);\n        data[length++] = (byte) (i >>> 24);\n        data[length++] = (byte) (i >>> 16);\n        data[length++] = (byte) (i >>> 8);\n        data[length++] = (byte) i;\n        i = (int) l;\n        data[length++] = (byte) (i >>> 24);\n        data[length++] = (byte) (i >>> 16);\n        data[length++] = (byte) (i >>> 8);\n        data[length++] = (byte) i;\n        this.length = length;\n        return this;\n    }\n\n    /**\n     * Puts an UTF8 string into this byte vector. The byte vector is\n     * automatically enlarged if necessary.\n     *\n     * @param s a String.\n     * @return this byte vector.\n     */\n    public ByteVector putUTF8(final String s) {\n        int charLength = s.length();\n        int len = length;\n        if (len + 2 + charLength > data.length) {\n            enlarge(2 + charLength);\n        }\n        byte[] data = this.data;\n        // optimistic algorithm: instead of computing the byte length and then\n        // serializing the string (which requires two loops), we assume the byte\n        // length is equal to char length (which is the most frequent case), and\n        // we start serializing the string right away. During the serialization,\n        // if we find that this assumption is wrong, we continue with the\n        // general method.\n        data[len++] = (byte) (charLength >>> 8);\n        data[len++] = (byte) charLength;\n        for (int i = 0; i < charLength; ++i) {\n            char c = s.charAt(i);\n            if (c >= '\\001' && c <= '\\177') {\n                data[len++] = (byte) c;\n            } else {\n                int byteLength = i;\n                for (int j = i; j < charLength; ++j) {\n                    c = s.charAt(j);\n                    if (c >= '\\001' && c <= '\\177') {\n                        byteLength++;\n                    } else if (c > '\\u07FF') {\n                        byteLength += 3;\n                    } else {\n                        byteLength += 2;\n                    }\n                }\n                data[length] = (byte) (byteLength >>> 8);\n                data[length + 1] = (byte) byteLength;\n                if (length + 2 + byteLength > data.length) {\n                    length = len;\n                    enlarge(2 + byteLength);\n                    data = this.data;\n                }\n                for (int j = i; j < charLength; ++j) {\n                    c = s.charAt(j);\n                    if (c >= '\\001' && c <= '\\177') {\n                        data[len++] = (byte) c;\n                    } else if (c > '\\u07FF') {\n                        data[len++] = (byte) (0xE0 | c >> 12 & 0xF);\n                        data[len++] = (byte) (0x80 | c >> 6 & 0x3F);\n                        data[len++] = (byte) (0x80 | c & 0x3F);\n                    } else {\n                        data[len++] = (byte) (0xC0 | c >> 6 & 0x1F);\n                        data[len++] = (byte) (0x80 | c & 0x3F);\n                    }\n                }\n                break;\n            }\n        }\n        length = len;\n        return this;\n    }\n\n    /**\n     * Puts an array of bytes into this byte vector. The byte vector is\n     * automatically enlarged if necessary.\n     *\n     * @param b an array of bytes. May be <tt>null</tt> to put <tt>len</tt>\n     *        null bytes into this byte vector.\n     * @param off index of the fist byte of b that must be copied.\n     * @param len number of bytes of b that must be copied.\n     * @return this byte vector.\n     */\n    public ByteVector putByteArray(final byte[] b, final int off, final int len) {\n        if (length + len > data.length) {\n            enlarge(len);\n        }\n        if (b != null) {\n            System.arraycopy(b, off, data, length, len);\n        }\n        length += len;\n        return this;\n    }\n\n    /**\n     * Enlarge this byte vector so that it can receive n more bytes.\n     *\n     * @param size number of additional bytes that this byte vector should be\n     *        able to receive.\n     */\n    private void enlarge(final int size) {\n        int length1 = 2 * data.length;\n        int length2 = length + size;\n        byte[] newData = new byte[length1 > length2 ? length1 : length2];\n        System.arraycopy(data, 0, newData, 0, length);\n        data = newData;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/ByteVectorTest3.java",
		"test_prompt": "// ByteVectorTest3.java\npackage org.objectweb.asm.jip;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ByteVector}.\n* It contains ten unit test cases for the {@link ByteVector#putLong(long)} method.\n*/\nclass ByteVectorTest3 {"
	},
	{
		"original_code": "// ByteVector.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\n/**\n * A dynamically extensible vector of bytes. This class is roughly equivalent to\n * a DataOutputStream on top of a ByteArrayOutputStream, but is more efficient.\n *\n * @author Eric Bruneton\n */\npublic class ByteVector {\n\n    /**\n     * The content of this vector.\n     */\n    byte[] data;\n\n    /**\n     * Actual number of bytes in this vector.\n     */\n    int length;\n\n    /**\n     * Constructs a new {@link ByteVector ByteVector} with a default initial\n     * size.\n     */\n    public ByteVector() {\n        data = new byte[64];\n    }\n\n    /**\n     * Constructs a new {@link ByteVector ByteVector} with the given initial\n     * size.\n     *\n     * @param initialSize the initial size of the byte vector to be constructed.\n     */\n    public ByteVector(final int initialSize) {\n        data = new byte[initialSize];\n    }\n\n    /**\n     * Puts a byte into this byte vector. The byte vector is automatically\n     * enlarged if necessary.\n     *\n     * @param b a byte.\n     * @return this byte vector.\n     */\n    public ByteVector putByte(final int b) {\n        int length = this.length;\n        if (length + 1 > data.length) {\n            enlarge(1);\n        }\n        data[length++] = (byte) b;\n        this.length = length;\n        return this;\n    }\n\n    /**\n     * Puts two bytes into this byte vector. The byte vector is automatically\n     * enlarged if necessary.\n     *\n     * @param b1 a byte.\n     * @param b2 another byte.\n     * @return this byte vector.\n     */\n    ByteVector put11(final int b1, final int b2) {\n        int length = this.length;\n        if (length + 2 > data.length) {\n            enlarge(2);\n        }\n        byte[] data = this.data;\n        data[length++] = (byte) b1;\n        data[length++] = (byte) b2;\n        this.length = length;\n        return this;\n    }\n\n    /**\n     * Puts a short into this byte vector. The byte vector is automatically\n     * enlarged if necessary.\n     *\n     * @param s a short.\n     * @return this byte vector.\n     */\n    public ByteVector putShort(final int s) {\n        int length = this.length;\n        if (length + 2 > data.length) {\n            enlarge(2);\n        }\n        byte[] data = this.data;\n        data[length++] = (byte) (s >>> 8);\n        data[length++] = (byte) s;\n        this.length = length;\n        return this;\n    }\n\n    /**\n     * Puts a byte and a short into this byte vector. The byte vector is\n     * automatically enlarged if necessary.\n     *\n     * @param b a byte.\n     * @param s a short.\n     * @return this byte vector.\n     */\n    ByteVector put12(final int b, final int s) {\n        int length = this.length;\n        if (length + 3 > data.length) {\n            enlarge(3);\n        }\n        byte[] data = this.data;\n        data[length++] = (byte) b;\n        data[length++] = (byte) (s >>> 8);\n        data[length++] = (byte) s;\n        this.length = length;\n        return this;\n    }\n\n    /**\n     * Puts an int into this byte vector. The byte vector is automatically\n     * enlarged if necessary.\n     *\n     * @param i an int.\n     * @return this byte vector.\n     */\n    public ByteVector putInt(final int i) {\n        int length = this.length;\n        if (length + 4 > data.length) {\n            enlarge(4);\n        }\n        byte[] data = this.data;\n        data[length++] = (byte) (i >>> 24);\n        data[length++] = (byte) (i >>> 16);\n        data[length++] = (byte) (i >>> 8);\n        data[length++] = (byte) i;\n        this.length = length;\n        return this;\n    }\n\n    /**\n     * Puts a long into this byte vector. The byte vector is automatically\n     * enlarged if necessary.\n     *\n     * @param l a long.\n     * @return this byte vector.\n     */\n    public ByteVector putLong(final long l) {\n        int length = this.length;\n        if (length + 8 > data.length) {\n            enlarge(8);\n        }\n        byte[] data = this.data;\n        int i = (int) (l >>> 32);\n        data[length++] = (byte) (i >>> 24);\n        data[length++] = (byte) (i >>> 16);\n        data[length++] = (byte) (i >>> 8);\n        data[length++] = (byte) i;\n        i = (int) l;\n        data[length++] = (byte) (i >>> 24);\n        data[length++] = (byte) (i >>> 16);\n        data[length++] = (byte) (i >>> 8);\n        data[length++] = (byte) i;\n        this.length = length;\n        return this;\n    }\n\n    /**\n     * Puts an UTF8 string into this byte vector. The byte vector is\n     * automatically enlarged if necessary.\n     *\n     * @param s a String.\n     * @return this byte vector.\n     */\n    public ByteVector putUTF8(final String s) {\n        int charLength = s.length();\n        int len = length;\n        if (len + 2 + charLength > data.length) {\n            enlarge(2 + charLength);\n        }\n        byte[] data = this.data;\n        // optimistic algorithm: instead of computing the byte length and then\n        // serializing the string (which requires two loops), we assume the byte\n        // length is equal to char length (which is the most frequent case), and\n        // we start serializing the string right away. During the serialization,\n        // if we find that this assumption is wrong, we continue with the\n        // general method.\n        data[len++] = (byte) (charLength >>> 8);\n        data[len++] = (byte) charLength;\n        for (int i = 0; i < charLength; ++i) {\n            char c = s.charAt(i);\n            if (c >= '\\001' && c <= '\\177') {\n                data[len++] = (byte) c;\n            } else {\n                int byteLength = i;\n                for (int j = i; j < charLength; ++j) {\n                    c = s.charAt(j);\n                    if (c >= '\\001' && c <= '\\177') {\n                        byteLength++;\n                    } else if (c > '\\u07FF') {\n                        byteLength += 3;\n                    } else {\n                        byteLength += 2;\n                    }\n                }\n                data[length] = (byte) (byteLength >>> 8);\n                data[length + 1] = (byte) byteLength;\n                if (length + 2 + byteLength > data.length) {\n                    length = len;\n                    enlarge(2 + byteLength);\n                    data = this.data;\n                }\n                for (int j = i; j < charLength; ++j) {\n                    c = s.charAt(j);\n                    if (c >= '\\001' && c <= '\\177') {\n                        data[len++] = (byte) c;\n                    } else if (c > '\\u07FF') {\n                        data[len++] = (byte) (0xE0 | c >> 12 & 0xF);\n                        data[len++] = (byte) (0x80 | c >> 6 & 0x3F);\n                        data[len++] = (byte) (0x80 | c & 0x3F);\n                    } else {\n                        data[len++] = (byte) (0xC0 | c >> 6 & 0x1F);\n                        data[len++] = (byte) (0x80 | c & 0x3F);\n                    }\n                }\n                break;\n            }\n        }\n        length = len;\n        return this;\n    }\n\n    /**\n     * Puts an array of bytes into this byte vector. The byte vector is\n     * automatically enlarged if necessary.\n     *\n     * @param b an array of bytes. May be <tt>null</tt> to put <tt>len</tt>\n     *        null bytes into this byte vector.\n     * @param off index of the fist byte of b that must be copied.\n     * @param len number of bytes of b that must be copied.\n     * @return this byte vector.\n     */\n    public ByteVector putByteArray(final byte[] b, final int off, final int len) {\n        if (length + len > data.length) {\n            enlarge(len);\n        }\n        if (b != null) {\n            System.arraycopy(b, off, data, length, len);\n        }\n        length += len;\n        return this;\n    }\n\n    /**\n     * Enlarge this byte vector so that it can receive n more bytes.\n     *\n     * @param size number of additional bytes that this byte vector should be\n     *        able to receive.\n     */\n    private void enlarge(final int size) {\n        int length1 = 2 * data.length;\n        int length2 = length + size;\n        byte[] newData = new byte[length1 > length2 ? length1 : length2];\n        System.arraycopy(data, 0, newData, 0, length);\n        data = newData;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/ByteVectorTest4.java",
		"test_prompt": "// ByteVectorTest4.java\npackage org.objectweb.asm.jip;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ByteVector}.\n* It contains ten unit test cases for the {@link ByteVector#putUTF8(String)} method.\n*/\nclass ByteVectorTest4 {"
	},
	{
		"original_code": "// ByteVector.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\n/**\n * A dynamically extensible vector of bytes. This class is roughly equivalent to\n * a DataOutputStream on top of a ByteArrayOutputStream, but is more efficient.\n *\n * @author Eric Bruneton\n */\npublic class ByteVector {\n\n    /**\n     * The content of this vector.\n     */\n    byte[] data;\n\n    /**\n     * Actual number of bytes in this vector.\n     */\n    int length;\n\n    /**\n     * Constructs a new {@link ByteVector ByteVector} with a default initial\n     * size.\n     */\n    public ByteVector() {\n        data = new byte[64];\n    }\n\n    /**\n     * Constructs a new {@link ByteVector ByteVector} with the given initial\n     * size.\n     *\n     * @param initialSize the initial size of the byte vector to be constructed.\n     */\n    public ByteVector(final int initialSize) {\n        data = new byte[initialSize];\n    }\n\n    /**\n     * Puts a byte into this byte vector. The byte vector is automatically\n     * enlarged if necessary.\n     *\n     * @param b a byte.\n     * @return this byte vector.\n     */\n    public ByteVector putByte(final int b) {\n        int length = this.length;\n        if (length + 1 > data.length) {\n            enlarge(1);\n        }\n        data[length++] = (byte) b;\n        this.length = length;\n        return this;\n    }\n\n    /**\n     * Puts two bytes into this byte vector. The byte vector is automatically\n     * enlarged if necessary.\n     *\n     * @param b1 a byte.\n     * @param b2 another byte.\n     * @return this byte vector.\n     */\n    ByteVector put11(final int b1, final int b2) {\n        int length = this.length;\n        if (length + 2 > data.length) {\n            enlarge(2);\n        }\n        byte[] data = this.data;\n        data[length++] = (byte) b1;\n        data[length++] = (byte) b2;\n        this.length = length;\n        return this;\n    }\n\n    /**\n     * Puts a short into this byte vector. The byte vector is automatically\n     * enlarged if necessary.\n     *\n     * @param s a short.\n     * @return this byte vector.\n     */\n    public ByteVector putShort(final int s) {\n        int length = this.length;\n        if (length + 2 > data.length) {\n            enlarge(2);\n        }\n        byte[] data = this.data;\n        data[length++] = (byte) (s >>> 8);\n        data[length++] = (byte) s;\n        this.length = length;\n        return this;\n    }\n\n    /**\n     * Puts a byte and a short into this byte vector. The byte vector is\n     * automatically enlarged if necessary.\n     *\n     * @param b a byte.\n     * @param s a short.\n     * @return this byte vector.\n     */\n    ByteVector put12(final int b, final int s) {\n        int length = this.length;\n        if (length + 3 > data.length) {\n            enlarge(3);\n        }\n        byte[] data = this.data;\n        data[length++] = (byte) b;\n        data[length++] = (byte) (s >>> 8);\n        data[length++] = (byte) s;\n        this.length = length;\n        return this;\n    }\n\n    /**\n     * Puts an int into this byte vector. The byte vector is automatically\n     * enlarged if necessary.\n     *\n     * @param i an int.\n     * @return this byte vector.\n     */\n    public ByteVector putInt(final int i) {\n        int length = this.length;\n        if (length + 4 > data.length) {\n            enlarge(4);\n        }\n        byte[] data = this.data;\n        data[length++] = (byte) (i >>> 24);\n        data[length++] = (byte) (i >>> 16);\n        data[length++] = (byte) (i >>> 8);\n        data[length++] = (byte) i;\n        this.length = length;\n        return this;\n    }\n\n    /**\n     * Puts a long into this byte vector. The byte vector is automatically\n     * enlarged if necessary.\n     *\n     * @param l a long.\n     * @return this byte vector.\n     */\n    public ByteVector putLong(final long l) {\n        int length = this.length;\n        if (length + 8 > data.length) {\n            enlarge(8);\n        }\n        byte[] data = this.data;\n        int i = (int) (l >>> 32);\n        data[length++] = (byte) (i >>> 24);\n        data[length++] = (byte) (i >>> 16);\n        data[length++] = (byte) (i >>> 8);\n        data[length++] = (byte) i;\n        i = (int) l;\n        data[length++] = (byte) (i >>> 24);\n        data[length++] = (byte) (i >>> 16);\n        data[length++] = (byte) (i >>> 8);\n        data[length++] = (byte) i;\n        this.length = length;\n        return this;\n    }\n\n    /**\n     * Puts an UTF8 string into this byte vector. The byte vector is\n     * automatically enlarged if necessary.\n     *\n     * @param s a String.\n     * @return this byte vector.\n     */\n    public ByteVector putUTF8(final String s) {\n        int charLength = s.length();\n        int len = length;\n        if (len + 2 + charLength > data.length) {\n            enlarge(2 + charLength);\n        }\n        byte[] data = this.data;\n        // optimistic algorithm: instead of computing the byte length and then\n        // serializing the string (which requires two loops), we assume the byte\n        // length is equal to char length (which is the most frequent case), and\n        // we start serializing the string right away. During the serialization,\n        // if we find that this assumption is wrong, we continue with the\n        // general method.\n        data[len++] = (byte) (charLength >>> 8);\n        data[len++] = (byte) charLength;\n        for (int i = 0; i < charLength; ++i) {\n            char c = s.charAt(i);\n            if (c >= '\\001' && c <= '\\177') {\n                data[len++] = (byte) c;\n            } else {\n                int byteLength = i;\n                for (int j = i; j < charLength; ++j) {\n                    c = s.charAt(j);\n                    if (c >= '\\001' && c <= '\\177') {\n                        byteLength++;\n                    } else if (c > '\\u07FF') {\n                        byteLength += 3;\n                    } else {\n                        byteLength += 2;\n                    }\n                }\n                data[length] = (byte) (byteLength >>> 8);\n                data[length + 1] = (byte) byteLength;\n                if (length + 2 + byteLength > data.length) {\n                    length = len;\n                    enlarge(2 + byteLength);\n                    data = this.data;\n                }\n                for (int j = i; j < charLength; ++j) {\n                    c = s.charAt(j);\n                    if (c >= '\\001' && c <= '\\177') {\n                        data[len++] = (byte) c;\n                    } else if (c > '\\u07FF') {\n                        data[len++] = (byte) (0xE0 | c >> 12 & 0xF);\n                        data[len++] = (byte) (0x80 | c >> 6 & 0x3F);\n                        data[len++] = (byte) (0x80 | c & 0x3F);\n                    } else {\n                        data[len++] = (byte) (0xC0 | c >> 6 & 0x1F);\n                        data[len++] = (byte) (0x80 | c & 0x3F);\n                    }\n                }\n                break;\n            }\n        }\n        length = len;\n        return this;\n    }\n\n    /**\n     * Puts an array of bytes into this byte vector. The byte vector is\n     * automatically enlarged if necessary.\n     *\n     * @param b an array of bytes. May be <tt>null</tt> to put <tt>len</tt>\n     *        null bytes into this byte vector.\n     * @param off index of the fist byte of b that must be copied.\n     * @param len number of bytes of b that must be copied.\n     * @return this byte vector.\n     */\n    public ByteVector putByteArray(final byte[] b, final int off, final int len) {\n        if (length + len > data.length) {\n            enlarge(len);\n        }\n        if (b != null) {\n            System.arraycopy(b, off, data, length, len);\n        }\n        length += len;\n        return this;\n    }\n\n    /**\n     * Enlarge this byte vector so that it can receive n more bytes.\n     *\n     * @param size number of additional bytes that this byte vector should be\n     *        able to receive.\n     */\n    private void enlarge(final int size) {\n        int length1 = 2 * data.length;\n        int length2 = length + size;\n        byte[] newData = new byte[length1 > length2 ? length1 : length2];\n        System.arraycopy(data, 0, newData, 0, length);\n        data = newData;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/ByteVectorTest5.java",
		"test_prompt": "// ByteVectorTest5.java\npackage org.objectweb.asm.jip;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ByteVector}.\n* It contains ten unit test cases for the {@link ByteVector#putByteArray(byte[], int, int)} method.\n*/\nclass ByteVectorTest5 {"
	},
	{
		"original_code": "// ClassWriter.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\n/**\n * A {@link ClassVisitor} that generates classes in bytecode form. More\n * precisely this visitor generates a byte array conforming to the Java class\n * file format. It can be used alone, to generate a Java class \"from scratch\",\n * or with one or more {@link ClassReader ClassReader} and adapter class visitor\n * to generate a modified class from one or more existing Java classes.\n *\n * @author Eric Bruneton\n */\npublic class ClassWriter implements ClassVisitor {\n\n    /**\n     * Flag to automatically compute the maximum stack size and the maximum\n     * number of local variables of methods. If this flag is set, then the\n     * arguments of the {@link MethodVisitor#visitMaxs visitMaxs} method of the\n     * {@link MethodVisitor} returned by the {@link #visitMethod visitMethod}\n     * method will be ignored, and computed automatically from the signature and\n     * the bytecode of each method.\n     *\n     * @see #ClassWriter(int)\n     */\n    public static final int COMPUTE_MAXS = 1;\n\n    /**\n     * Flag to automatically compute the stack map frames of methods from\n     * scratch. If this flag is set, then the calls to the\n     * {@link MethodVisitor#visitFrame} method are ignored, and the stack map\n     * frames are recomputed from the methods bytecode. The arguments of the\n     * {@link MethodVisitor#visitMaxs visitMaxs} method are also ignored and\n     * recomputed from the bytecode. In other words, computeFrames implies\n     * computeMaxs.\n     *\n     * @see #ClassWriter(int)\n     */\n    public static final int COMPUTE_FRAMES = 2;\n\n    /**\n     * The type of instructions without any argument.\n     */\n    static final int NOARG_INSN = 0;\n\n    /**\n     * The type of instructions with an signed byte argument.\n     */\n    static final int SBYTE_INSN = 1;\n\n    /**\n     * The type of instructions with an signed short argument.\n     */\n    static final int SHORT_INSN = 2;\n\n    /**\n     * The type of instructions with a local variable index argument.\n     */\n    static final int VAR_INSN = 3;\n\n    /**\n     * The type of instructions with an implicit local variable index argument.\n     */\n    static final int IMPLVAR_INSN = 4;\n\n    /**\n     * The type of instructions with a type descriptor argument.\n     */\n    static final int TYPE_INSN = 5;\n\n    /**\n     * The type of field and method invocations instructions.\n     */\n    static final int FIELDORMETH_INSN = 6;\n\n    /**\n     * The type of the INVOKEINTERFACE/INVOKEDYNAMIC instruction.\n     */\n    static final int ITFDYNMETH_INSN = 7;\n\n    /**\n     * The type of instructions with a 2 bytes bytecode offset label.\n     */\n    static final int LABEL_INSN = 8;\n\n    /**\n     * The type of instructions with a 4 bytes bytecode offset label.\n     */\n    static final int LABELW_INSN = 9;\n\n    /**\n     * The type of the LDC instruction.\n     */\n    static final int LDC_INSN = 10;\n\n    /**\n     * The type of the LDC_W and LDC2_W instructions.\n     */\n    static final int LDCW_INSN = 11;\n\n    /**\n     * The type of the IINC instruction.\n     */\n    static final int IINC_INSN = 12;\n\n    /**\n     * The type of the TABLESWITCH instruction.\n     */\n    static final int TABL_INSN = 13;\n\n    /**\n     * The type of the LOOKUPSWITCH instruction.\n     */\n    static final int LOOK_INSN = 14;\n\n    /**\n     * The type of the MULTIANEWARRAY instruction.\n     */\n    static final int MANA_INSN = 15;\n\n    /**\n     * The type of the WIDE instruction.\n     */\n    static final int WIDE_INSN = 16;\n\n    /**\n     * The instruction types of all JVM opcodes.\n     */\n    static final byte[] TYPE;\n\n    /**\n     * The type of CONSTANT_Class constant pool items.\n     */\n    static final int CLASS = 7;\n\n    /**\n     * The type of CONSTANT_Fieldref constant pool items.\n     */\n    static final int FIELD = 9;\n\n    /**\n     * The type of CONSTANT_Methodref constant pool items.\n     */\n    static final int METH = 10;\n\n    /**\n     * The type of CONSTANT_InterfaceMethodref constant pool items.\n     */\n    static final int IMETH = 11;\n\n    /**\n     * The type of CONSTANT_String constant pool items.\n     */\n    static final int STR = 8;\n\n    /**\n     * The type of CONSTANT_Integer constant pool items.\n     */\n    static final int INT = 3;\n\n    /**\n     * The type of CONSTANT_Float constant pool items.\n     */\n    static final int FLOAT = 4;\n\n    /**\n     * The type of CONSTANT_Long constant pool items.\n     */\n    static final int LONG = 5;\n\n    /**\n     * The type of CONSTANT_Double constant pool items.\n     */\n    static final int DOUBLE = 6;\n\n    /**\n     * The type of CONSTANT_NameAndType constant pool items.\n     */\n    static final int NAME_TYPE = 12;\n\n    /**\n     * The type of CONSTANT_Utf8 constant pool items.\n     */\n    static final int UTF8 = 1;\n\n    /**\n     * Normal type Item stored in the ClassWriter {@link ClassWriter#typeTable},\n     * instead of the constant pool, in order to avoid clashes with normal\n     * constant pool items in the ClassWriter constant pool's hash table.\n     */\n    static final int TYPE_NORMAL = 13;\n\n    /**\n     * Uninitialized type Item stored in the ClassWriter\n     * {@link ClassWriter#typeTable}, instead of the constant pool, in order to\n     * avoid clashes with normal constant pool items in the ClassWriter constant\n     * pool's hash table.\n     */\n    static final int TYPE_UNINIT = 14;\n\n    /**\n     * Merged type Item stored in the ClassWriter {@link ClassWriter#typeTable},\n     * instead of the constant pool, in order to avoid clashes with normal\n     * constant pool items in the ClassWriter constant pool's hash table.\n     */\n    static final int TYPE_MERGED = 15;\n\n    /**\n     * The class reader from which this class writer was constructed, if any.\n     */\n    ClassReader cr;\n\n    /**\n     * Minor and major version numbers of the class to be generated.\n     */\n    int version;\n\n    /**\n     * Index of the next item to be added in the constant pool.\n     */\n    int index;\n\n    /**\n     * The constant pool of this class.\n     */\n    final ByteVector pool;\n\n    /**\n     * The constant pool's hash table data.\n     */\n    Item[] items;\n\n    /**\n     * The threshold of the constant pool's hash table.\n     */\n    int threshold;\n\n    /**\n     * A reusable key used to look for items in the {@link #items} hash table.\n     */\n    final Item key;\n\n    /**\n     * A reusable key used to look for items in the {@link #items} hash table.\n     */\n    final Item key2;\n\n    /**\n     * A reusable key used to look for items in the {@link #items} hash table.\n     */\n    final Item key3;\n\n    /**\n     * A type table used to temporarily store internal names that will not\n     * necessarily be stored in the constant pool. This type table is used by\n     * the control flow and data flow analysis algorithm used to compute stack\n     * map frames from scratch. This array associates to each index <tt>i</tt>\n     * the Item whose index is <tt>i</tt>. All Item objects stored in this\n     * array are also stored in the {@link #items} hash table. These two arrays\n     * allow to retrieve an Item from its index or, conversely, to get the index\n     * of an Item from its value. Each Item stores an internal name in its\n     * {@link Item#strVal1} field.\n     */\n    Item[] typeTable;\n\n    /**\n     * Number of elements in the {@link #typeTable} array.\n     */\n    private short typeCount;\n\n    /**\n     * The access flags of this class.\n     */\n    private int access;\n\n    /**\n     * The constant pool item that contains the internal name of this class.\n     */\n    private int name;\n\n    /**\n     * The internal name of this class.\n     */\n    String thisName;\n\n    /**\n     * The constant pool item that contains the signature of this class.\n     */\n    private int signature;\n\n    /**\n     * The constant pool item that contains the internal name of the super class\n     * of this class.\n     */\n    private int superName;\n\n    /**\n     * Number of interfaces implemented or extended by this class or interface.\n     */\n    private int interfaceCount;\n\n    /**\n     * The interfaces implemented or extended by this class or interface. More\n     * precisely, this array contains the indexes of the constant pool items\n     * that contain the internal names of these interfaces.\n     */\n    private int[] interfaces;\n\n    /**\n     * The index of the constant pool item that contains the name of the source\n     * file from which this class was compiled.\n     */\n    private int sourceFile;\n\n    /**\n     * The SourceDebug attribute of this class.\n     */\n    private ByteVector sourceDebug;\n\n    /**\n     * The constant pool item that contains the name of the enclosing class of\n     * this class.\n     */\n    private int enclosingMethodOwner;\n\n    /**\n     * The constant pool item that contains the name and descriptor of the\n     * enclosing method of this class.\n     */\n    private int enclosingMethod;\n\n    /**\n     * The runtime visible annotations of this class.\n     */\n    private AnnotationWriter anns;\n\n    /**\n     * The runtime invisible annotations of this class.\n     */\n    private AnnotationWriter ianns;\n\n    /**\n     * The non standard attributes of this class.\n     */\n    private Attribute attrs;\n\n    /**\n     * The number of entries in the InnerClasses attribute.\n     */\n    private int innerClassesCount;\n\n    /**\n     * The InnerClasses attribute.\n     */\n    private ByteVector innerClasses;\n\n    /**\n     * The fields of this class. These fields are stored in a linked list of\n     * {@link FieldWriter} objects, linked to each other by their\n     * {@link FieldWriter#next} field. This field stores the first element of\n     * this list.\n     */\n    FieldWriter firstField;\n\n    /**\n     * The fields of this class. These fields are stored in a linked list of\n     * {@link FieldWriter} objects, linked to each other by their\n     * {@link FieldWriter#next} field. This field stores the last element of\n     * this list.\n     */\n    FieldWriter lastField;\n\n    /**\n     * The methods of this class. These methods are stored in a linked list of\n     * {@link MethodWriter} objects, linked to each other by their\n     * {@link MethodWriter#next} field. This field stores the first element of\n     * this list.\n     */\n    MethodWriter firstMethod;\n\n    /**\n     * The methods of this class. These methods are stored in a linked list of\n     * {@link MethodWriter} objects, linked to each other by their\n     * {@link MethodWriter#next} field. This field stores the last element of\n     * this list.\n     */\n    MethodWriter lastMethod;\n\n    /**\n     * <tt>true</tt> if the maximum stack size and number of local variables\n     * must be automatically computed.\n     */\n    private final boolean computeMaxs;\n\n    /**\n     * <tt>true</tt> if the stack map frames must be recomputed from scratch.\n     */\n    private final boolean computeFrames;\n\n    /**\n     * <tt>true</tt> if the stack map tables of this class are invalid. The\n     * {@link MethodWriter#resizeInstructions} method cannot transform existing\n     * stack map tables, and so produces potentially invalid classes when it is\n     * executed. In this case the class is reread and rewritten with the\n     * {@link #COMPUTE_FRAMES} option (the resizeInstructions method can resize\n     * stack map tables when this option is used).\n     */\n    boolean invalidFrames;\n\n    // ------------------------------------------------------------------------\n    // Static initializer\n    // ------------------------------------------------------------------------\n    /**\n     * Computes the instruction types of JVM opcodes.\n     */\n    static {\n        int i;\n        byte[] b = new byte[220];\n        String s = \"AAAAAAAAAAAAAAAABCKLLDDDDDEEEEEEEEEEEEEEEEEEEEAAAAAAAADD\" + \"DDDEEEEEEEEEEEEEEEEEEEEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAAIIIIIIIIIIIIIIIIDNOAA\" + \"AAAAGGGGGGGHHFBFAAFFAAQPIIJJIIIIIIIIIIIIIIIIII\";\n        for (i = 0; i < b.length; ++i) {\n            b[i] = (byte) (s.charAt(i) - 'A');\n        }\n        TYPE = b;\n        // code to generate the above string\n        //\n        // // SBYTE_INSN instructions\n        // b[Constants.NEWARRAY] = SBYTE_INSN;\n        // b[Constants.BIPUSH] = SBYTE_INSN;\n        //\n        // // SHORT_INSN instructions\n        // b[Constants.SIPUSH] = SHORT_INSN;\n        //\n        // // (IMPL)VAR_INSN instructions\n        // b[Constants.RET] = VAR_INSN;\n        // for (i = Constants.ILOAD; i <= Constants.ALOAD; ++i) {\n        // b[i] = VAR_INSN;\n        // }\n        // for (i = Constants.ISTORE; i <= Constants.ASTORE; ++i) {\n        // b[i] = VAR_INSN;\n        // }\n        // for (i = 26; i <= 45; ++i) { // ILOAD_0 to ALOAD_3\n        // b[i] = IMPLVAR_INSN;\n        // }\n        // for (i = 59; i <= 78; ++i) { // ISTORE_0 to ASTORE_3\n        // b[i] = IMPLVAR_INSN;\n        // }\n        //\n        // // TYPE_INSN instructions\n        // b[Constants.NEW] = TYPE_INSN;\n        // b[Constants.ANEWARRAY] = TYPE_INSN;\n        // b[Constants.CHECKCAST] = TYPE_INSN;\n        // b[Constants.INSTANCEOF] = TYPE_INSN;\n        //\n        // // (Set)FIELDORMETH_INSN instructions\n        // for (i = Constants.GETSTATIC; i <= Constants.INVOKESTATIC; ++i) {\n        // b[i] = FIELDORMETH_INSN;\n        // }\n        // b[Constants.INVOKEINTERFACE] = ITFDYNMETH_INSN;\n        // b[Constants.INVOKEDYNAMIC] = ITFDYNMETH_INSN;\n        //\n        // // LABEL(W)_INSN instructions\n        // for (i = Constants.IFEQ; i <= Constants.JSR; ++i) {\n        // b[i] = LABEL_INSN;\n        // }\n        // b[Constants.IFNULL] = LABEL_INSN;\n        // b[Constants.IFNONNULL] = LABEL_INSN;\n        // b[200] = LABELW_INSN; // GOTO_W\n        // b[201] = LABELW_INSN; // JSR_W\n        // // temporary opcodes used internally by ASM - see Label and\n        // MethodWriter\n        // for (i = 202; i < 220; ++i) {\n        // b[i] = LABEL_INSN;\n        // }\n        //\n        // // LDC(_W) instructions\n        // b[Constants.LDC] = LDC_INSN;\n        // b[19] = LDCW_INSN; // LDC_W\n        // b[20] = LDCW_INSN; // LDC2_W\n        //\n        // // special instructions\n        // b[Constants.IINC] = IINC_INSN;\n        // b[Constants.TABLESWITCH] = TABL_INSN;\n        // b[Constants.LOOKUPSWITCH] = LOOK_INSN;\n        // b[Constants.MULTIANEWARRAY] = MANA_INSN;\n        // b[196] = WIDE_INSN; // WIDE\n        //\n        // for (i = 0; i < b.length; ++i) {\n        // System.err.print((char)('A' + b[i]));\n        // }\n        // System.err.println();\n    }\n\n    // ------------------------------------------------------------------------\n    // Constructor\n    // ------------------------------------------------------------------------\n    /**\n     * Constructs a new {@link ClassWriter} object.\n     *\n     * @param flags option flags that can be used to modify the default behavior\n     *        of this class. See {@link #COMPUTE_MAXS}, {@link #COMPUTE_FRAMES}.\n     */\n    public ClassWriter(final int flags) {\n        index = 1;\n        pool = new ByteVector();\n        items = new Item[256];\n        threshold = (int) (0.75d * items.length);\n        key = new Item();\n        key2 = new Item();\n        key3 = new Item();\n        this.computeMaxs = (flags & COMPUTE_MAXS) != 0;\n        this.computeFrames = (flags & COMPUTE_FRAMES) != 0;\n    }\n\n    /**\n     * Constructs a new {@link ClassWriter} object and enables optimizations for\n     * \"mostly add\" bytecode transformations. These optimizations are the\n     * following:\n     *\n     * <ul> <li>The constant pool from the original class is copied as is in\n     * the new class, which saves time. New constant pool entries will be added\n     * at the end if necessary, but unused constant pool entries <i>won't be\n     * removed</i>.</li> <li>Methods that are not transformed are copied as\n     * is in the new class, directly from the original class bytecode (i.e.\n     * without emitting visit events for all the method instructions), which\n     * saves a <i>lot</i> of time. Untransformed methods are detected by the\n     * fact that the {@link ClassReader} receives {@link MethodVisitor} objects\n     * that come from a {@link ClassWriter} (and not from a custom\n     * {@link ClassAdapter} or any other {@link ClassVisitor} instance).</li>\n     * </ul>\n     *\n     * @param classReader the {@link ClassReader} used to read the original\n     *        class. It will be used to copy the entire constant pool from the\n     *        original class and also to copy other fragments of original\n     *        bytecode where applicable.\n     * @param flags option flags that can be used to modify the default behavior\n     *        of this class. See {@link #COMPUTE_MAXS}, {@link #COMPUTE_FRAMES}.\n     */\n    public ClassWriter(final ClassReader classReader, final int flags) {\n        this(flags);\n        classReader.copyPool(this);\n        this.cr = classReader;\n    }\n\n    // ------------------------------------------------------------------------\n    // Implementation of the ClassVisitor interface\n    // ------------------------------------------------------------------------\n    public void visit(final int version, final int access, final String name, final String signature, final String superName, final String[] interfaces) {\n        this.version = version;\n        this.access = access;\n        this.name = newClass(name);\n        thisName = name;\n        if (ClassReader.SIGNATURES && signature != null) {\n            this.signature = newUTF8(signature);\n        }\n        this.superName = superName == null ? 0 : newClass(superName);\n        if (interfaces != null && interfaces.length > 0) {\n            interfaceCount = interfaces.length;\n            this.interfaces = new int[interfaceCount];\n            for (int i = 0; i < interfaceCount; ++i) {\n                this.interfaces[i] = newClass(interfaces[i]);\n            }\n        }\n    }\n\n    public void visitSource(final String file, final String debug) {\n        if (file != null) {\n            sourceFile = newUTF8(file);\n        }\n        if (debug != null) {\n            sourceDebug = new ByteVector().putUTF8(debug);\n        }\n    }\n\n    public void visitOuterClass(final String owner, final String name, final String desc) {\n        enclosingMethodOwner = newClass(owner);\n        if (name != null && desc != null) {\n            enclosingMethod = newNameType(name, desc);\n        }\n    }\n\n    public AnnotationVisitor visitAnnotation(final String desc, final boolean visible) {\n        if (!ClassReader.ANNOTATIONS) {\n            return null;\n        }\n        ByteVector bv = new ByteVector();\n        // write type, and reserve space for values count\n        bv.putShort(newUTF8(desc)).putShort(0);\n        AnnotationWriter aw = new AnnotationWriter(this, true, bv, bv, 2);\n        if (visible) {\n            aw.next = anns;\n            anns = aw;\n        } else {\n            aw.next = ianns;\n            ianns = aw;\n        }\n        return aw;\n    }\n\n    public void visitAttribute(final Attribute attr) {\n        attr.next = attrs;\n        attrs = attr;\n    }\n\n    public void visitInnerClass(final String name, final String outerName, final String innerName, final int access) {\n        if (innerClasses == null) {\n            innerClasses = new ByteVector();\n        }\n        ++innerClassesCount;\n        innerClasses.putShort(name == null ? 0 : newClass(name));\n        innerClasses.putShort(outerName == null ? 0 : newClass(outerName));\n        innerClasses.putShort(innerName == null ? 0 : newUTF8(innerName));\n        innerClasses.putShort(access);\n    }\n\n    public FieldVisitor visitField(final int access, final String name, final String desc, final String signature, final Object value) {\n        return new FieldWriter(this, access, name, desc, signature, value);\n    }\n\n    public MethodVisitor visitMethod(final int access, final String name, final String desc, final String signature, final String[] exceptions) {\n        return new MethodWriter(this, access, name, desc, signature, exceptions, computeMaxs, computeFrames);\n    }\n\n    public void visitEnd() {\n    }\n\n    // ------------------------------------------------------------------------\n    // Other public methods\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the bytecode of the class that was build with this class writer.\n     *\n     * @return the bytecode of the class that was build with this class writer.\n     */\n    public byte[] toByteArray() {\n        // computes the real size of the bytecode of this class\n        int size = 24 + 2 * interfaceCount;\n        int nbFields = 0;\n        FieldWriter fb = firstField;\n        while (fb != null) {\n            ++nbFields;\n            size += fb.getSize();\n            fb = fb.next;\n        }\n        int nbMethods = 0;\n        MethodWriter mb = firstMethod;\n        while (mb != null) {\n            ++nbMethods;\n            size += mb.getSize();\n            mb = mb.next;\n        }\n        int attributeCount = 0;\n        if (ClassReader.SIGNATURES && signature != 0) {\n            ++attributeCount;\n            size += 8;\n            newUTF8(\"Signature\");\n        }\n        if (sourceFile != 0) {\n            ++attributeCount;\n            size += 8;\n            newUTF8(\"SourceFile\");\n        }\n        if (sourceDebug != null) {\n            ++attributeCount;\n            size += sourceDebug.length + 4;\n            newUTF8(\"SourceDebugExtension\");\n        }\n        if (enclosingMethodOwner != 0) {\n            ++attributeCount;\n            size += 10;\n            newUTF8(\"EnclosingMethod\");\n        }\n        if ((access & Opcodes.ACC_DEPRECATED) != 0) {\n            ++attributeCount;\n            size += 6;\n            newUTF8(\"Deprecated\");\n        }\n        if ((access & Opcodes.ACC_SYNTHETIC) != 0 && (version & 0xffff) < Opcodes.V1_5) {\n            ++attributeCount;\n            size += 6;\n            newUTF8(\"Synthetic\");\n        }\n        if (innerClasses != null) {\n            ++attributeCount;\n            size += 8 + innerClasses.length;\n            newUTF8(\"InnerClasses\");\n        }\n        if (ClassReader.ANNOTATIONS && anns != null) {\n            ++attributeCount;\n            size += 8 + anns.getSize();\n            newUTF8(\"RuntimeVisibleAnnotations\");\n        }\n        if (ClassReader.ANNOTATIONS && ianns != null) {\n            ++attributeCount;\n            size += 8 + ianns.getSize();\n            newUTF8(\"RuntimeInvisibleAnnotations\");\n        }\n        if (attrs != null) {\n            attributeCount += attrs.getCount();\n            size += attrs.getSize(this, null, 0, -1, -1);\n        }\n        size += pool.length;\n        // allocates a byte vector of this size, in order to avoid unnecessary\n        // arraycopy operations in the ByteVector.enlarge() method\n        ByteVector out = new ByteVector(size);\n        out.putInt(0xCAFEBABE).putInt(version);\n        out.putShort(index).putByteArray(pool.data, 0, pool.length);\n        out.putShort(access).putShort(name).putShort(superName);\n        out.putShort(interfaceCount);\n        for (int i = 0; i < interfaceCount; ++i) {\n            out.putShort(interfaces[i]);\n        }\n        out.putShort(nbFields);\n        fb = firstField;\n        while (fb != null) {\n            fb.put(out);\n            fb = fb.next;\n        }\n        out.putShort(nbMethods);\n        mb = firstMethod;\n        while (mb != null) {\n            mb.put(out);\n            mb = mb.next;\n        }\n        out.putShort(attributeCount);\n        if (ClassReader.SIGNATURES && signature != 0) {\n            out.putShort(newUTF8(\"Signature\")).putInt(2).putShort(signature);\n        }\n        if (sourceFile != 0) {\n            out.putShort(newUTF8(\"SourceFile\")).putInt(2).putShort(sourceFile);\n        }\n        if (sourceDebug != null) {\n            int len = sourceDebug.length - 2;\n            out.putShort(newUTF8(\"SourceDebugExtension\")).putInt(len);\n            out.putByteArray(sourceDebug.data, 2, len);\n        }\n        if (enclosingMethodOwner != 0) {\n            out.putShort(newUTF8(\"EnclosingMethod\")).putInt(4);\n            out.putShort(enclosingMethodOwner).putShort(enclosingMethod);\n        }\n        if ((access & Opcodes.ACC_DEPRECATED) != 0) {\n            out.putShort(newUTF8(\"Deprecated\")).putInt(0);\n        }\n        if ((access & Opcodes.ACC_SYNTHETIC) != 0 && (version & 0xffff) < Opcodes.V1_5) {\n            out.putShort(newUTF8(\"Synthetic\")).putInt(0);\n        }\n        if (innerClasses != null) {\n            out.putShort(newUTF8(\"InnerClasses\"));\n            out.putInt(innerClasses.length + 2).putShort(innerClassesCount);\n            out.putByteArray(innerClasses.data, 0, innerClasses.length);\n        }\n        if (ClassReader.ANNOTATIONS && anns != null) {\n            out.putShort(newUTF8(\"RuntimeVisibleAnnotations\"));\n            anns.put(out);\n        }\n        if (ClassReader.ANNOTATIONS && ianns != null) {\n            out.putShort(newUTF8(\"RuntimeInvisibleAnnotations\"));\n            ianns.put(out);\n        }\n        if (attrs != null) {\n            attrs.put(this, null, 0, -1, -1, out);\n        }\n        if (invalidFrames) {\n            ClassWriter cw = new ClassWriter(COMPUTE_FRAMES);\n            new ClassReader(out.data).accept(cw, ClassReader.SKIP_FRAMES);\n            return cw.toByteArray();\n        }\n        return out.data;\n    }\n\n    // ------------------------------------------------------------------------\n    // Utility methods: constant pool management\n    // ------------------------------------------------------------------------\n    /**\n     * Adds a number or string constant to the constant pool of the class being\n     * build. Does nothing if the constant pool already contains a similar item.\n     *\n     * @param cst the value of the constant to be added to the constant pool.\n     *        This parameter must be an {@link Integer}, a {@link Float}, a\n     *        {@link Long}, a {@link Double}, a {@link String} or a\n     *        {@link Type}.\n     * @return a new or already existing constant item with the given value.\n     */\n    Item newConstItem(final Object cst) {\n        if (cst instanceof Integer) {\n            int val = ((Integer) cst).intValue();\n            return newInteger(val);\n        } else if (cst instanceof Byte) {\n            int val = ((Byte) cst).intValue();\n            return newInteger(val);\n        } else if (cst instanceof Character) {\n            int val = ((Character) cst).charValue();\n            return newInteger(val);\n        } else if (cst instanceof Short) {\n            int val = ((Short) cst).intValue();\n            return newInteger(val);\n        } else if (cst instanceof Boolean) {\n            int val = ((Boolean) cst).booleanValue() ? 1 : 0;\n            return newInteger(val);\n        } else if (cst instanceof Float) {\n            float val = ((Float) cst).floatValue();\n            return newFloat(val);\n        } else if (cst instanceof Long) {\n            long val = ((Long) cst).longValue();\n            return newLong(val);\n        } else if (cst instanceof Double) {\n            double val = ((Double) cst).doubleValue();\n            return newDouble(val);\n        } else if (cst instanceof String) {\n            return newString((String) cst);\n        } else if (cst instanceof Type) {\n            Type t = (Type) cst;\n            return newClassItem(t.getSort() == Type.OBJECT ? t.getInternalName() : t.getDescriptor());\n        } else {\n            throw new IllegalArgumentException(\"value \" + cst);\n        }\n    }\n\n    /**\n     * Adds a number or string constant to the constant pool of the class being\n     * build. Does nothing if the constant pool already contains a similar item.\n     * <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param cst the value of the constant to be added to the constant pool.\n     *        This parameter must be an {@link Integer}, a {@link Float}, a\n     *        {@link Long}, a {@link Double} or a {@link String}.\n     * @return the index of a new or already existing constant item with the\n     *         given value.\n     */\n    public int newConst(final Object cst) {\n        return newConstItem(cst).index;\n    }\n\n    /**\n     * Adds an UTF8 string to the constant pool of the class being build. Does\n     * nothing if the constant pool already contains a similar item. <i>This\n     * method is intended for {@link Attribute} sub classes, and is normally not\n     * needed by class generators or adapters.</i>\n     *\n     * @param value the String value.\n     * @return the index of a new or already existing UTF8 item.\n     */\n    public int newUTF8(final String value) {\n        key.set(UTF8, value, null, null);\n        Item result = get(key);\n        if (result == null) {\n            pool.putByte(UTF8).putUTF8(value);\n            result = new Item(index++, key);\n            put(result);\n        }\n        return result.index;\n    }\n\n    /**\n     * Adds a class reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     * <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param value the internal name of the class.\n     * @return a new or already existing class reference item.\n     */\n    Item newClassItem(final String value) {\n        key2.set(CLASS, value, null, null);\n        Item result = get(key2);\n        if (result == null) {\n            pool.put12(CLASS, newUTF8(value));\n            result = new Item(index++, key2);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a class reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     * <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param value the internal name of the class.\n     * @return the index of a new or already existing class reference item.\n     */\n    public int newClass(final String value) {\n        return newClassItem(value).index;\n    }\n\n    /**\n     * Adds a field reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     *\n     * @param owner the internal name of the field's owner class.\n     * @param name the field's name.\n     * @param desc the field's descriptor.\n     * @return a new or already existing field reference item.\n     */\n    Item newFieldItem(final String owner, final String name, final String desc) {\n        key3.set(FIELD, owner, name, desc);\n        Item result = get(key3);\n        if (result == null) {\n            put122(FIELD, newClass(owner), newNameType(name, desc));\n            result = new Item(index++, key3);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a field reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     * <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param owner the internal name of the field's owner class.\n     * @param name the field's name.\n     * @param desc the field's descriptor.\n     * @return the index of a new or already existing field reference item.\n     */\n    public int newField(final String owner, final String name, final String desc) {\n        return newFieldItem(owner, name, desc).index;\n    }\n\n    /**\n     * Adds a method reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     *\n     * @param owner the internal name of the method's owner class.\n     * @param name the method's name.\n     * @param desc the method's descriptor.\n     * @param itf <tt>true</tt> if <tt>owner</tt> is an interface.\n     * @return a new or already existing method reference item.\n     */\n    Item newMethodItem(final String owner, final String name, final String desc, final boolean itf) {\n        int type = itf ? IMETH : METH;\n        key3.set(type, owner, name, desc);\n        Item result = get(key3);\n        if (result == null) {\n            put122(type, newClass(owner), newNameType(name, desc));\n            result = new Item(index++, key3);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a method reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     * <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param owner the internal name of the method's owner class.\n     * @param name the method's name.\n     * @param desc the method's descriptor.\n     * @param itf <tt>true</tt> if <tt>owner</tt> is an interface.\n     * @return the index of a new or already existing method reference item.\n     */\n    public int newMethod(final String owner, final String name, final String desc, final boolean itf) {\n        return newMethodItem(owner, name, desc, itf).index;\n    }\n\n    /**\n     * Adds an integer to the constant pool of the class being build. Does\n     * nothing if the constant pool already contains a similar item.\n     *\n     * @param value the int value.\n     * @return a new or already existing int item.\n     */\n    Item newInteger(final int value) {\n        key.set(value);\n        Item result = get(key);\n        if (result == null) {\n            pool.putByte(INT).putInt(value);\n            result = new Item(index++, key);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a float to the constant pool of the class being build. Does nothing\n     * if the constant pool already contains a similar item.\n     *\n     * @param value the float value.\n     * @return a new or already existing float item.\n     */\n    Item newFloat(final float value) {\n        key.set(value);\n        Item result = get(key);\n        if (result == null) {\n            pool.putByte(FLOAT).putInt(key.intVal);\n            result = new Item(index++, key);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a long to the constant pool of the class being build. Does nothing\n     * if the constant pool already contains a similar item.\n     *\n     * @param value the long value.\n     * @return a new or already existing long item.\n     */\n    Item newLong(final long value) {\n        key.set(value);\n        Item result = get(key);\n        if (result == null) {\n            pool.putByte(LONG).putLong(value);\n            result = new Item(index, key);\n            put(result);\n            index += 2;\n        }\n        return result;\n    }\n\n    /**\n     * Adds a double to the constant pool of the class being build. Does nothing\n     * if the constant pool already contains a similar item.\n     *\n     * @param value the double value.\n     * @return a new or already existing double item.\n     */\n    Item newDouble(final double value) {\n        key.set(value);\n        Item result = get(key);\n        if (result == null) {\n            pool.putByte(DOUBLE).putLong(key.longVal);\n            result = new Item(index, key);\n            put(result);\n            index += 2;\n        }\n        return result;\n    }\n\n    /**\n     * Adds a string to the constant pool of the class being build. Does nothing\n     * if the constant pool already contains a similar item.\n     *\n     * @param value the String value.\n     * @return a new or already existing string item.\n     */\n    private Item newString(final String value) {\n        key2.set(STR, value, null, null);\n        Item result = get(key2);\n        if (result == null) {\n            pool.put12(STR, newUTF8(value));\n            result = new Item(index++, key2);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a name and type to the constant pool of the class being build. Does\n     * nothing if the constant pool already contains a similar item. <i>This\n     * method is intended for {@link Attribute} sub classes, and is normally not\n     * needed by class generators or adapters.</i>\n     *\n     * @param name a name.\n     * @param desc a type descriptor.\n     * @return the index of a new or already existing name and type item.\n     */\n    public int newNameType(final String name, final String desc) {\n        return newNameTypeItem(name, desc).index;\n    }\n\n    /**\n     * Adds a name and type to the constant pool of the class being build. Does\n     * nothing if the constant pool already contains a similar item.\n     *\n     * @param name a name.\n     * @param desc a type descriptor.\n     * @return a new or already existing name and type item.\n     */\n    Item newNameTypeItem(final String name, final String desc) {\n        key2.set(NAME_TYPE, name, desc, null);\n        Item result = get(key2);\n        if (result == null) {\n            put122(NAME_TYPE, newUTF8(name), newUTF8(desc));\n            result = new Item(index++, key2);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds the given internal name to {@link #typeTable} and returns its index.\n     * Does nothing if the type table already contains this internal name.\n     *\n     * @param type the internal name to be added to the type table.\n     * @return the index of this internal name in the type table.\n     */\n    int addType(final String type) {\n        key.set(TYPE_NORMAL, type, null, null);\n        Item result = get(key);\n        if (result == null) {\n            result = addType(key);\n        }\n        return result.index;\n    }\n\n    /**\n     * Adds the given \"uninitialized\" type to {@link #typeTable} and returns its\n     * index. This method is used for UNINITIALIZED types, made of an internal\n     * name and a bytecode offset.\n     *\n     * @param type the internal name to be added to the type table.\n     * @param offset the bytecode offset of the NEW instruction that created\n     *        this UNINITIALIZED type value.\n     * @return the index of this internal name in the type table.\n     */\n    int addUninitializedType(final String type, final int offset) {\n        key.type = TYPE_UNINIT;\n        key.intVal = offset;\n        key.strVal1 = type;\n        key.hashCode = 0x7FFFFFFF & (TYPE_UNINIT + type.hashCode() + offset);\n        Item result = get(key);\n        if (result == null) {\n            result = addType(key);\n        }\n        return result.index;\n    }\n\n    /**\n     * Adds the given Item to {@link #typeTable}.\n     *\n     * @param item the value to be added to the type table.\n     * @return the added Item, which a new Item instance with the same value as\n     *         the given Item.\n     */\n    private Item addType(final Item item) {\n        ++typeCount;\n        Item result = new Item(typeCount, key);\n        put(result);\n        if (typeTable == null) {\n            typeTable = new Item[16];\n        }\n        if (typeCount == typeTable.length) {\n            Item[] newTable = new Item[2 * typeTable.length];\n            System.arraycopy(typeTable, 0, newTable, 0, typeTable.length);\n            typeTable = newTable;\n        }\n        typeTable[typeCount] = result;\n        return result;\n    }\n\n    /**\n     * Returns the index of the common super type of the two given types. This\n     * method calls {@link #getCommonSuperClass} and caches the result in the\n     * {@link #items} hash table to speedup future calls with the same\n     * parameters.\n     *\n     * @param type1 index of an internal name in {@link #typeTable}.\n     * @param type2 index of an internal name in {@link #typeTable}.\n     * @return the index of the common super type of the two given types.\n     */\n    int getMergedType(final int type1, final int type2) {\n        key2.type = TYPE_MERGED;\n        key2.longVal = type1 | (((long) type2) << 32);\n        key2.hashCode = 0x7FFFFFFF & (TYPE_MERGED + type1 + type2);\n        Item result = get(key2);\n        if (result == null) {\n            String t = typeTable[type1].strVal1;\n            String u = typeTable[type2].strVal1;\n            key2.intVal = addType(getCommonSuperClass(t, u));\n            result = new Item((short) 0, key2);\n            put(result);\n        }\n        return result.intVal;\n    }\n\n    /**\n     * Returns the common super type of the two given types. The default\n     * implementation of this method <i>loads<i> the two given classes and uses\n     * the java.lang.Class methods to find the common super class. It can be\n     * overridden to compute this common super type in other ways, in particular\n     * without actually loading any class, or to take into account the class\n     * that is currently being generated by this ClassWriter, which can of\n     * course not be loaded since it is under construction.\n     *\n     * @param type1 the internal name of a class.\n     * @param type2 the internal name of another class.\n     * @return the internal name of the common super class of the two given\n     *         classes.\n     */\n    protected String getCommonSuperClass(final String type1, final String type2) {\n        Class c, d;\n        try {\n            c = Class.forName(type1.replace('/', '.'));\n            d = Class.forName(type2.replace('/', '.'));\n        } catch (Exception e) {\n            throw new RuntimeException(e.toString());\n        }\n        if (c.isAssignableFrom(d)) {\n            return type1;\n        }\n        if (d.isAssignableFrom(c)) {\n            return type2;\n        }\n        if (c.isInterface() || d.isInterface()) {\n            return \"java/lang/Object\";\n        } else {\n            do {\n                c = c.getSuperclass();\n            } while (!c.isAssignableFrom(d));\n            return c.getName().replace('.', '/');\n        }\n    }\n\n    /**\n     * Returns the constant pool's hash table item which is equal to the given\n     * item.\n     *\n     * @param key a constant pool item.\n     * @return the constant pool's hash table item which is equal to the given\n     *         item, or <tt>null</tt> if there is no such item.\n     */\n    private Item get(final Item key) {\n        Item i = items[key.hashCode % items.length];\n        while (i != null && (i.type != key.type || !key.isEqualTo(i))) {\n            i = i.next;\n        }\n        return i;\n    }\n\n    /**\n     * Puts the given item in the constant pool's hash table. The hash table\n     * <i>must</i> not already contains this item.\n     *\n     * @param i the item to be added to the constant pool's hash table.\n     */\n    private void put(final Item i) {\n        if (index > threshold) {\n            int ll = items.length;\n            int nl = ll * 2 + 1;\n            Item[] newItems = new Item[nl];\n            for (int l = ll - 1; l >= 0; --l) {\n                Item j = items[l];\n                while (j != null) {\n                    int index = j.hashCode % newItems.length;\n                    Item k = j.next;\n                    j.next = newItems[index];\n                    newItems[index] = j;\n                    j = k;\n                }\n            }\n            items = newItems;\n            threshold = (int) (nl * 0.75);\n        }\n        int index = i.hashCode % items.length;\n        i.next = items[index];\n        items[index] = i;\n    }\n\n    /**\n     * Puts one byte and two shorts into the constant pool.\n     *\n     * @param b a byte.\n     * @param s1 a short.\n     * @param s2 another short.\n     */\n    private void put122(final int b, final int s1, final int s2) {\n        pool.put12(b, s1).putShort(s2);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/ClassWriterTest0.java",
		"test_prompt": "// ClassWriterTest0.java\npackage org.objectweb.asm.jip;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassWriter}.\n* It contains ten unit test cases for the {@link ClassWriter#visitAnnotation(String, boolean)} method.\n*/\nclass ClassWriterTest0 {"
	},
	{
		"original_code": "// ClassWriter.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\n/**\n * A {@link ClassVisitor} that generates classes in bytecode form. More\n * precisely this visitor generates a byte array conforming to the Java class\n * file format. It can be used alone, to generate a Java class \"from scratch\",\n * or with one or more {@link ClassReader ClassReader} and adapter class visitor\n * to generate a modified class from one or more existing Java classes.\n *\n * @author Eric Bruneton\n */\npublic class ClassWriter implements ClassVisitor {\n\n    /**\n     * Flag to automatically compute the maximum stack size and the maximum\n     * number of local variables of methods. If this flag is set, then the\n     * arguments of the {@link MethodVisitor#visitMaxs visitMaxs} method of the\n     * {@link MethodVisitor} returned by the {@link #visitMethod visitMethod}\n     * method will be ignored, and computed automatically from the signature and\n     * the bytecode of each method.\n     *\n     * @see #ClassWriter(int)\n     */\n    public static final int COMPUTE_MAXS = 1;\n\n    /**\n     * Flag to automatically compute the stack map frames of methods from\n     * scratch. If this flag is set, then the calls to the\n     * {@link MethodVisitor#visitFrame} method are ignored, and the stack map\n     * frames are recomputed from the methods bytecode. The arguments of the\n     * {@link MethodVisitor#visitMaxs visitMaxs} method are also ignored and\n     * recomputed from the bytecode. In other words, computeFrames implies\n     * computeMaxs.\n     *\n     * @see #ClassWriter(int)\n     */\n    public static final int COMPUTE_FRAMES = 2;\n\n    /**\n     * The type of instructions without any argument.\n     */\n    static final int NOARG_INSN = 0;\n\n    /**\n     * The type of instructions with an signed byte argument.\n     */\n    static final int SBYTE_INSN = 1;\n\n    /**\n     * The type of instructions with an signed short argument.\n     */\n    static final int SHORT_INSN = 2;\n\n    /**\n     * The type of instructions with a local variable index argument.\n     */\n    static final int VAR_INSN = 3;\n\n    /**\n     * The type of instructions with an implicit local variable index argument.\n     */\n    static final int IMPLVAR_INSN = 4;\n\n    /**\n     * The type of instructions with a type descriptor argument.\n     */\n    static final int TYPE_INSN = 5;\n\n    /**\n     * The type of field and method invocations instructions.\n     */\n    static final int FIELDORMETH_INSN = 6;\n\n    /**\n     * The type of the INVOKEINTERFACE/INVOKEDYNAMIC instruction.\n     */\n    static final int ITFDYNMETH_INSN = 7;\n\n    /**\n     * The type of instructions with a 2 bytes bytecode offset label.\n     */\n    static final int LABEL_INSN = 8;\n\n    /**\n     * The type of instructions with a 4 bytes bytecode offset label.\n     */\n    static final int LABELW_INSN = 9;\n\n    /**\n     * The type of the LDC instruction.\n     */\n    static final int LDC_INSN = 10;\n\n    /**\n     * The type of the LDC_W and LDC2_W instructions.\n     */\n    static final int LDCW_INSN = 11;\n\n    /**\n     * The type of the IINC instruction.\n     */\n    static final int IINC_INSN = 12;\n\n    /**\n     * The type of the TABLESWITCH instruction.\n     */\n    static final int TABL_INSN = 13;\n\n    /**\n     * The type of the LOOKUPSWITCH instruction.\n     */\n    static final int LOOK_INSN = 14;\n\n    /**\n     * The type of the MULTIANEWARRAY instruction.\n     */\n    static final int MANA_INSN = 15;\n\n    /**\n     * The type of the WIDE instruction.\n     */\n    static final int WIDE_INSN = 16;\n\n    /**\n     * The instruction types of all JVM opcodes.\n     */\n    static final byte[] TYPE;\n\n    /**\n     * The type of CONSTANT_Class constant pool items.\n     */\n    static final int CLASS = 7;\n\n    /**\n     * The type of CONSTANT_Fieldref constant pool items.\n     */\n    static final int FIELD = 9;\n\n    /**\n     * The type of CONSTANT_Methodref constant pool items.\n     */\n    static final int METH = 10;\n\n    /**\n     * The type of CONSTANT_InterfaceMethodref constant pool items.\n     */\n    static final int IMETH = 11;\n\n    /**\n     * The type of CONSTANT_String constant pool items.\n     */\n    static final int STR = 8;\n\n    /**\n     * The type of CONSTANT_Integer constant pool items.\n     */\n    static final int INT = 3;\n\n    /**\n     * The type of CONSTANT_Float constant pool items.\n     */\n    static final int FLOAT = 4;\n\n    /**\n     * The type of CONSTANT_Long constant pool items.\n     */\n    static final int LONG = 5;\n\n    /**\n     * The type of CONSTANT_Double constant pool items.\n     */\n    static final int DOUBLE = 6;\n\n    /**\n     * The type of CONSTANT_NameAndType constant pool items.\n     */\n    static final int NAME_TYPE = 12;\n\n    /**\n     * The type of CONSTANT_Utf8 constant pool items.\n     */\n    static final int UTF8 = 1;\n\n    /**\n     * Normal type Item stored in the ClassWriter {@link ClassWriter#typeTable},\n     * instead of the constant pool, in order to avoid clashes with normal\n     * constant pool items in the ClassWriter constant pool's hash table.\n     */\n    static final int TYPE_NORMAL = 13;\n\n    /**\n     * Uninitialized type Item stored in the ClassWriter\n     * {@link ClassWriter#typeTable}, instead of the constant pool, in order to\n     * avoid clashes with normal constant pool items in the ClassWriter constant\n     * pool's hash table.\n     */\n    static final int TYPE_UNINIT = 14;\n\n    /**\n     * Merged type Item stored in the ClassWriter {@link ClassWriter#typeTable},\n     * instead of the constant pool, in order to avoid clashes with normal\n     * constant pool items in the ClassWriter constant pool's hash table.\n     */\n    static final int TYPE_MERGED = 15;\n\n    /**\n     * The class reader from which this class writer was constructed, if any.\n     */\n    ClassReader cr;\n\n    /**\n     * Minor and major version numbers of the class to be generated.\n     */\n    int version;\n\n    /**\n     * Index of the next item to be added in the constant pool.\n     */\n    int index;\n\n    /**\n     * The constant pool of this class.\n     */\n    final ByteVector pool;\n\n    /**\n     * The constant pool's hash table data.\n     */\n    Item[] items;\n\n    /**\n     * The threshold of the constant pool's hash table.\n     */\n    int threshold;\n\n    /**\n     * A reusable key used to look for items in the {@link #items} hash table.\n     */\n    final Item key;\n\n    /**\n     * A reusable key used to look for items in the {@link #items} hash table.\n     */\n    final Item key2;\n\n    /**\n     * A reusable key used to look for items in the {@link #items} hash table.\n     */\n    final Item key3;\n\n    /**\n     * A type table used to temporarily store internal names that will not\n     * necessarily be stored in the constant pool. This type table is used by\n     * the control flow and data flow analysis algorithm used to compute stack\n     * map frames from scratch. This array associates to each index <tt>i</tt>\n     * the Item whose index is <tt>i</tt>. All Item objects stored in this\n     * array are also stored in the {@link #items} hash table. These two arrays\n     * allow to retrieve an Item from its index or, conversely, to get the index\n     * of an Item from its value. Each Item stores an internal name in its\n     * {@link Item#strVal1} field.\n     */\n    Item[] typeTable;\n\n    /**\n     * Number of elements in the {@link #typeTable} array.\n     */\n    private short typeCount;\n\n    /**\n     * The access flags of this class.\n     */\n    private int access;\n\n    /**\n     * The constant pool item that contains the internal name of this class.\n     */\n    private int name;\n\n    /**\n     * The internal name of this class.\n     */\n    String thisName;\n\n    /**\n     * The constant pool item that contains the signature of this class.\n     */\n    private int signature;\n\n    /**\n     * The constant pool item that contains the internal name of the super class\n     * of this class.\n     */\n    private int superName;\n\n    /**\n     * Number of interfaces implemented or extended by this class or interface.\n     */\n    private int interfaceCount;\n\n    /**\n     * The interfaces implemented or extended by this class or interface. More\n     * precisely, this array contains the indexes of the constant pool items\n     * that contain the internal names of these interfaces.\n     */\n    private int[] interfaces;\n\n    /**\n     * The index of the constant pool item that contains the name of the source\n     * file from which this class was compiled.\n     */\n    private int sourceFile;\n\n    /**\n     * The SourceDebug attribute of this class.\n     */\n    private ByteVector sourceDebug;\n\n    /**\n     * The constant pool item that contains the name of the enclosing class of\n     * this class.\n     */\n    private int enclosingMethodOwner;\n\n    /**\n     * The constant pool item that contains the name and descriptor of the\n     * enclosing method of this class.\n     */\n    private int enclosingMethod;\n\n    /**\n     * The runtime visible annotations of this class.\n     */\n    private AnnotationWriter anns;\n\n    /**\n     * The runtime invisible annotations of this class.\n     */\n    private AnnotationWriter ianns;\n\n    /**\n     * The non standard attributes of this class.\n     */\n    private Attribute attrs;\n\n    /**\n     * The number of entries in the InnerClasses attribute.\n     */\n    private int innerClassesCount;\n\n    /**\n     * The InnerClasses attribute.\n     */\n    private ByteVector innerClasses;\n\n    /**\n     * The fields of this class. These fields are stored in a linked list of\n     * {@link FieldWriter} objects, linked to each other by their\n     * {@link FieldWriter#next} field. This field stores the first element of\n     * this list.\n     */\n    FieldWriter firstField;\n\n    /**\n     * The fields of this class. These fields are stored in a linked list of\n     * {@link FieldWriter} objects, linked to each other by their\n     * {@link FieldWriter#next} field. This field stores the last element of\n     * this list.\n     */\n    FieldWriter lastField;\n\n    /**\n     * The methods of this class. These methods are stored in a linked list of\n     * {@link MethodWriter} objects, linked to each other by their\n     * {@link MethodWriter#next} field. This field stores the first element of\n     * this list.\n     */\n    MethodWriter firstMethod;\n\n    /**\n     * The methods of this class. These methods are stored in a linked list of\n     * {@link MethodWriter} objects, linked to each other by their\n     * {@link MethodWriter#next} field. This field stores the last element of\n     * this list.\n     */\n    MethodWriter lastMethod;\n\n    /**\n     * <tt>true</tt> if the maximum stack size and number of local variables\n     * must be automatically computed.\n     */\n    private final boolean computeMaxs;\n\n    /**\n     * <tt>true</tt> if the stack map frames must be recomputed from scratch.\n     */\n    private final boolean computeFrames;\n\n    /**\n     * <tt>true</tt> if the stack map tables of this class are invalid. The\n     * {@link MethodWriter#resizeInstructions} method cannot transform existing\n     * stack map tables, and so produces potentially invalid classes when it is\n     * executed. In this case the class is reread and rewritten with the\n     * {@link #COMPUTE_FRAMES} option (the resizeInstructions method can resize\n     * stack map tables when this option is used).\n     */\n    boolean invalidFrames;\n\n    // ------------------------------------------------------------------------\n    // Static initializer\n    // ------------------------------------------------------------------------\n    /**\n     * Computes the instruction types of JVM opcodes.\n     */\n    static {\n        int i;\n        byte[] b = new byte[220];\n        String s = \"AAAAAAAAAAAAAAAABCKLLDDDDDEEEEEEEEEEEEEEEEEEEEAAAAAAAADD\" + \"DDDEEEEEEEEEEEEEEEEEEEEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAAIIIIIIIIIIIIIIIIDNOAA\" + \"AAAAGGGGGGGHHFBFAAFFAAQPIIJJIIIIIIIIIIIIIIIIII\";\n        for (i = 0; i < b.length; ++i) {\n            b[i] = (byte) (s.charAt(i) - 'A');\n        }\n        TYPE = b;\n        // code to generate the above string\n        //\n        // // SBYTE_INSN instructions\n        // b[Constants.NEWARRAY] = SBYTE_INSN;\n        // b[Constants.BIPUSH] = SBYTE_INSN;\n        //\n        // // SHORT_INSN instructions\n        // b[Constants.SIPUSH] = SHORT_INSN;\n        //\n        // // (IMPL)VAR_INSN instructions\n        // b[Constants.RET] = VAR_INSN;\n        // for (i = Constants.ILOAD; i <= Constants.ALOAD; ++i) {\n        // b[i] = VAR_INSN;\n        // }\n        // for (i = Constants.ISTORE; i <= Constants.ASTORE; ++i) {\n        // b[i] = VAR_INSN;\n        // }\n        // for (i = 26; i <= 45; ++i) { // ILOAD_0 to ALOAD_3\n        // b[i] = IMPLVAR_INSN;\n        // }\n        // for (i = 59; i <= 78; ++i) { // ISTORE_0 to ASTORE_3\n        // b[i] = IMPLVAR_INSN;\n        // }\n        //\n        // // TYPE_INSN instructions\n        // b[Constants.NEW] = TYPE_INSN;\n        // b[Constants.ANEWARRAY] = TYPE_INSN;\n        // b[Constants.CHECKCAST] = TYPE_INSN;\n        // b[Constants.INSTANCEOF] = TYPE_INSN;\n        //\n        // // (Set)FIELDORMETH_INSN instructions\n        // for (i = Constants.GETSTATIC; i <= Constants.INVOKESTATIC; ++i) {\n        // b[i] = FIELDORMETH_INSN;\n        // }\n        // b[Constants.INVOKEINTERFACE] = ITFDYNMETH_INSN;\n        // b[Constants.INVOKEDYNAMIC] = ITFDYNMETH_INSN;\n        //\n        // // LABEL(W)_INSN instructions\n        // for (i = Constants.IFEQ; i <= Constants.JSR; ++i) {\n        // b[i] = LABEL_INSN;\n        // }\n        // b[Constants.IFNULL] = LABEL_INSN;\n        // b[Constants.IFNONNULL] = LABEL_INSN;\n        // b[200] = LABELW_INSN; // GOTO_W\n        // b[201] = LABELW_INSN; // JSR_W\n        // // temporary opcodes used internally by ASM - see Label and\n        // MethodWriter\n        // for (i = 202; i < 220; ++i) {\n        // b[i] = LABEL_INSN;\n        // }\n        //\n        // // LDC(_W) instructions\n        // b[Constants.LDC] = LDC_INSN;\n        // b[19] = LDCW_INSN; // LDC_W\n        // b[20] = LDCW_INSN; // LDC2_W\n        //\n        // // special instructions\n        // b[Constants.IINC] = IINC_INSN;\n        // b[Constants.TABLESWITCH] = TABL_INSN;\n        // b[Constants.LOOKUPSWITCH] = LOOK_INSN;\n        // b[Constants.MULTIANEWARRAY] = MANA_INSN;\n        // b[196] = WIDE_INSN; // WIDE\n        //\n        // for (i = 0; i < b.length; ++i) {\n        // System.err.print((char)('A' + b[i]));\n        // }\n        // System.err.println();\n    }\n\n    // ------------------------------------------------------------------------\n    // Constructor\n    // ------------------------------------------------------------------------\n    /**\n     * Constructs a new {@link ClassWriter} object.\n     *\n     * @param flags option flags that can be used to modify the default behavior\n     *        of this class. See {@link #COMPUTE_MAXS}, {@link #COMPUTE_FRAMES}.\n     */\n    public ClassWriter(final int flags) {\n        index = 1;\n        pool = new ByteVector();\n        items = new Item[256];\n        threshold = (int) (0.75d * items.length);\n        key = new Item();\n        key2 = new Item();\n        key3 = new Item();\n        this.computeMaxs = (flags & COMPUTE_MAXS) != 0;\n        this.computeFrames = (flags & COMPUTE_FRAMES) != 0;\n    }\n\n    /**\n     * Constructs a new {@link ClassWriter} object and enables optimizations for\n     * \"mostly add\" bytecode transformations. These optimizations are the\n     * following:\n     *\n     * <ul> <li>The constant pool from the original class is copied as is in\n     * the new class, which saves time. New constant pool entries will be added\n     * at the end if necessary, but unused constant pool entries <i>won't be\n     * removed</i>.</li> <li>Methods that are not transformed are copied as\n     * is in the new class, directly from the original class bytecode (i.e.\n     * without emitting visit events for all the method instructions), which\n     * saves a <i>lot</i> of time. Untransformed methods are detected by the\n     * fact that the {@link ClassReader} receives {@link MethodVisitor} objects\n     * that come from a {@link ClassWriter} (and not from a custom\n     * {@link ClassAdapter} or any other {@link ClassVisitor} instance).</li>\n     * </ul>\n     *\n     * @param classReader the {@link ClassReader} used to read the original\n     *        class. It will be used to copy the entire constant pool from the\n     *        original class and also to copy other fragments of original\n     *        bytecode where applicable.\n     * @param flags option flags that can be used to modify the default behavior\n     *        of this class. See {@link #COMPUTE_MAXS}, {@link #COMPUTE_FRAMES}.\n     */\n    public ClassWriter(final ClassReader classReader, final int flags) {\n        this(flags);\n        classReader.copyPool(this);\n        this.cr = classReader;\n    }\n\n    // ------------------------------------------------------------------------\n    // Implementation of the ClassVisitor interface\n    // ------------------------------------------------------------------------\n    public void visit(final int version, final int access, final String name, final String signature, final String superName, final String[] interfaces) {\n        this.version = version;\n        this.access = access;\n        this.name = newClass(name);\n        thisName = name;\n        if (ClassReader.SIGNATURES && signature != null) {\n            this.signature = newUTF8(signature);\n        }\n        this.superName = superName == null ? 0 : newClass(superName);\n        if (interfaces != null && interfaces.length > 0) {\n            interfaceCount = interfaces.length;\n            this.interfaces = new int[interfaceCount];\n            for (int i = 0; i < interfaceCount; ++i) {\n                this.interfaces[i] = newClass(interfaces[i]);\n            }\n        }\n    }\n\n    public void visitSource(final String file, final String debug) {\n        if (file != null) {\n            sourceFile = newUTF8(file);\n        }\n        if (debug != null) {\n            sourceDebug = new ByteVector().putUTF8(debug);\n        }\n    }\n\n    public void visitOuterClass(final String owner, final String name, final String desc) {\n        enclosingMethodOwner = newClass(owner);\n        if (name != null && desc != null) {\n            enclosingMethod = newNameType(name, desc);\n        }\n    }\n\n    public AnnotationVisitor visitAnnotation(final String desc, final boolean visible) {\n        if (!ClassReader.ANNOTATIONS) {\n            return null;\n        }\n        ByteVector bv = new ByteVector();\n        // write type, and reserve space for values count\n        bv.putShort(newUTF8(desc)).putShort(0);\n        AnnotationWriter aw = new AnnotationWriter(this, true, bv, bv, 2);\n        if (visible) {\n            aw.next = anns;\n            anns = aw;\n        } else {\n            aw.next = ianns;\n            ianns = aw;\n        }\n        return aw;\n    }\n\n    public void visitAttribute(final Attribute attr) {\n        attr.next = attrs;\n        attrs = attr;\n    }\n\n    public void visitInnerClass(final String name, final String outerName, final String innerName, final int access) {\n        if (innerClasses == null) {\n            innerClasses = new ByteVector();\n        }\n        ++innerClassesCount;\n        innerClasses.putShort(name == null ? 0 : newClass(name));\n        innerClasses.putShort(outerName == null ? 0 : newClass(outerName));\n        innerClasses.putShort(innerName == null ? 0 : newUTF8(innerName));\n        innerClasses.putShort(access);\n    }\n\n    public FieldVisitor visitField(final int access, final String name, final String desc, final String signature, final Object value) {\n        return new FieldWriter(this, access, name, desc, signature, value);\n    }\n\n    public MethodVisitor visitMethod(final int access, final String name, final String desc, final String signature, final String[] exceptions) {\n        return new MethodWriter(this, access, name, desc, signature, exceptions, computeMaxs, computeFrames);\n    }\n\n    public void visitEnd() {\n    }\n\n    // ------------------------------------------------------------------------\n    // Other public methods\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the bytecode of the class that was build with this class writer.\n     *\n     * @return the bytecode of the class that was build with this class writer.\n     */\n    public byte[] toByteArray() {\n        // computes the real size of the bytecode of this class\n        int size = 24 + 2 * interfaceCount;\n        int nbFields = 0;\n        FieldWriter fb = firstField;\n        while (fb != null) {\n            ++nbFields;\n            size += fb.getSize();\n            fb = fb.next;\n        }\n        int nbMethods = 0;\n        MethodWriter mb = firstMethod;\n        while (mb != null) {\n            ++nbMethods;\n            size += mb.getSize();\n            mb = mb.next;\n        }\n        int attributeCount = 0;\n        if (ClassReader.SIGNATURES && signature != 0) {\n            ++attributeCount;\n            size += 8;\n            newUTF8(\"Signature\");\n        }\n        if (sourceFile != 0) {\n            ++attributeCount;\n            size += 8;\n            newUTF8(\"SourceFile\");\n        }\n        if (sourceDebug != null) {\n            ++attributeCount;\n            size += sourceDebug.length + 4;\n            newUTF8(\"SourceDebugExtension\");\n        }\n        if (enclosingMethodOwner != 0) {\n            ++attributeCount;\n            size += 10;\n            newUTF8(\"EnclosingMethod\");\n        }\n        if ((access & Opcodes.ACC_DEPRECATED) != 0) {\n            ++attributeCount;\n            size += 6;\n            newUTF8(\"Deprecated\");\n        }\n        if ((access & Opcodes.ACC_SYNTHETIC) != 0 && (version & 0xffff) < Opcodes.V1_5) {\n            ++attributeCount;\n            size += 6;\n            newUTF8(\"Synthetic\");\n        }\n        if (innerClasses != null) {\n            ++attributeCount;\n            size += 8 + innerClasses.length;\n            newUTF8(\"InnerClasses\");\n        }\n        if (ClassReader.ANNOTATIONS && anns != null) {\n            ++attributeCount;\n            size += 8 + anns.getSize();\n            newUTF8(\"RuntimeVisibleAnnotations\");\n        }\n        if (ClassReader.ANNOTATIONS && ianns != null) {\n            ++attributeCount;\n            size += 8 + ianns.getSize();\n            newUTF8(\"RuntimeInvisibleAnnotations\");\n        }\n        if (attrs != null) {\n            attributeCount += attrs.getCount();\n            size += attrs.getSize(this, null, 0, -1, -1);\n        }\n        size += pool.length;\n        // allocates a byte vector of this size, in order to avoid unnecessary\n        // arraycopy operations in the ByteVector.enlarge() method\n        ByteVector out = new ByteVector(size);\n        out.putInt(0xCAFEBABE).putInt(version);\n        out.putShort(index).putByteArray(pool.data, 0, pool.length);\n        out.putShort(access).putShort(name).putShort(superName);\n        out.putShort(interfaceCount);\n        for (int i = 0; i < interfaceCount; ++i) {\n            out.putShort(interfaces[i]);\n        }\n        out.putShort(nbFields);\n        fb = firstField;\n        while (fb != null) {\n            fb.put(out);\n            fb = fb.next;\n        }\n        out.putShort(nbMethods);\n        mb = firstMethod;\n        while (mb != null) {\n            mb.put(out);\n            mb = mb.next;\n        }\n        out.putShort(attributeCount);\n        if (ClassReader.SIGNATURES && signature != 0) {\n            out.putShort(newUTF8(\"Signature\")).putInt(2).putShort(signature);\n        }\n        if (sourceFile != 0) {\n            out.putShort(newUTF8(\"SourceFile\")).putInt(2).putShort(sourceFile);\n        }\n        if (sourceDebug != null) {\n            int len = sourceDebug.length - 2;\n            out.putShort(newUTF8(\"SourceDebugExtension\")).putInt(len);\n            out.putByteArray(sourceDebug.data, 2, len);\n        }\n        if (enclosingMethodOwner != 0) {\n            out.putShort(newUTF8(\"EnclosingMethod\")).putInt(4);\n            out.putShort(enclosingMethodOwner).putShort(enclosingMethod);\n        }\n        if ((access & Opcodes.ACC_DEPRECATED) != 0) {\n            out.putShort(newUTF8(\"Deprecated\")).putInt(0);\n        }\n        if ((access & Opcodes.ACC_SYNTHETIC) != 0 && (version & 0xffff) < Opcodes.V1_5) {\n            out.putShort(newUTF8(\"Synthetic\")).putInt(0);\n        }\n        if (innerClasses != null) {\n            out.putShort(newUTF8(\"InnerClasses\"));\n            out.putInt(innerClasses.length + 2).putShort(innerClassesCount);\n            out.putByteArray(innerClasses.data, 0, innerClasses.length);\n        }\n        if (ClassReader.ANNOTATIONS && anns != null) {\n            out.putShort(newUTF8(\"RuntimeVisibleAnnotations\"));\n            anns.put(out);\n        }\n        if (ClassReader.ANNOTATIONS && ianns != null) {\n            out.putShort(newUTF8(\"RuntimeInvisibleAnnotations\"));\n            ianns.put(out);\n        }\n        if (attrs != null) {\n            attrs.put(this, null, 0, -1, -1, out);\n        }\n        if (invalidFrames) {\n            ClassWriter cw = new ClassWriter(COMPUTE_FRAMES);\n            new ClassReader(out.data).accept(cw, ClassReader.SKIP_FRAMES);\n            return cw.toByteArray();\n        }\n        return out.data;\n    }\n\n    // ------------------------------------------------------------------------\n    // Utility methods: constant pool management\n    // ------------------------------------------------------------------------\n    /**\n     * Adds a number or string constant to the constant pool of the class being\n     * build. Does nothing if the constant pool already contains a similar item.\n     *\n     * @param cst the value of the constant to be added to the constant pool.\n     *        This parameter must be an {@link Integer}, a {@link Float}, a\n     *        {@link Long}, a {@link Double}, a {@link String} or a\n     *        {@link Type}.\n     * @return a new or already existing constant item with the given value.\n     */\n    Item newConstItem(final Object cst) {\n        if (cst instanceof Integer) {\n            int val = ((Integer) cst).intValue();\n            return newInteger(val);\n        } else if (cst instanceof Byte) {\n            int val = ((Byte) cst).intValue();\n            return newInteger(val);\n        } else if (cst instanceof Character) {\n            int val = ((Character) cst).charValue();\n            return newInteger(val);\n        } else if (cst instanceof Short) {\n            int val = ((Short) cst).intValue();\n            return newInteger(val);\n        } else if (cst instanceof Boolean) {\n            int val = ((Boolean) cst).booleanValue() ? 1 : 0;\n            return newInteger(val);\n        } else if (cst instanceof Float) {\n            float val = ((Float) cst).floatValue();\n            return newFloat(val);\n        } else if (cst instanceof Long) {\n            long val = ((Long) cst).longValue();\n            return newLong(val);\n        } else if (cst instanceof Double) {\n            double val = ((Double) cst).doubleValue();\n            return newDouble(val);\n        } else if (cst instanceof String) {\n            return newString((String) cst);\n        } else if (cst instanceof Type) {\n            Type t = (Type) cst;\n            return newClassItem(t.getSort() == Type.OBJECT ? t.getInternalName() : t.getDescriptor());\n        } else {\n            throw new IllegalArgumentException(\"value \" + cst);\n        }\n    }\n\n    /**\n     * Adds a number or string constant to the constant pool of the class being\n     * build. Does nothing if the constant pool already contains a similar item.\n     * <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param cst the value of the constant to be added to the constant pool.\n     *        This parameter must be an {@link Integer}, a {@link Float}, a\n     *        {@link Long}, a {@link Double} or a {@link String}.\n     * @return the index of a new or already existing constant item with the\n     *         given value.\n     */\n    public int newConst(final Object cst) {\n        return newConstItem(cst).index;\n    }\n\n    /**\n     * Adds an UTF8 string to the constant pool of the class being build. Does\n     * nothing if the constant pool already contains a similar item. <i>This\n     * method is intended for {@link Attribute} sub classes, and is normally not\n     * needed by class generators or adapters.</i>\n     *\n     * @param value the String value.\n     * @return the index of a new or already existing UTF8 item.\n     */\n    public int newUTF8(final String value) {\n        key.set(UTF8, value, null, null);\n        Item result = get(key);\n        if (result == null) {\n            pool.putByte(UTF8).putUTF8(value);\n            result = new Item(index++, key);\n            put(result);\n        }\n        return result.index;\n    }\n\n    /**\n     * Adds a class reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     * <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param value the internal name of the class.\n     * @return a new or already existing class reference item.\n     */\n    Item newClassItem(final String value) {\n        key2.set(CLASS, value, null, null);\n        Item result = get(key2);\n        if (result == null) {\n            pool.put12(CLASS, newUTF8(value));\n            result = new Item(index++, key2);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a class reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     * <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param value the internal name of the class.\n     * @return the index of a new or already existing class reference item.\n     */\n    public int newClass(final String value) {\n        return newClassItem(value).index;\n    }\n\n    /**\n     * Adds a field reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     *\n     * @param owner the internal name of the field's owner class.\n     * @param name the field's name.\n     * @param desc the field's descriptor.\n     * @return a new or already existing field reference item.\n     */\n    Item newFieldItem(final String owner, final String name, final String desc) {\n        key3.set(FIELD, owner, name, desc);\n        Item result = get(key3);\n        if (result == null) {\n            put122(FIELD, newClass(owner), newNameType(name, desc));\n            result = new Item(index++, key3);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a field reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     * <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param owner the internal name of the field's owner class.\n     * @param name the field's name.\n     * @param desc the field's descriptor.\n     * @return the index of a new or already existing field reference item.\n     */\n    public int newField(final String owner, final String name, final String desc) {\n        return newFieldItem(owner, name, desc).index;\n    }\n\n    /**\n     * Adds a method reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     *\n     * @param owner the internal name of the method's owner class.\n     * @param name the method's name.\n     * @param desc the method's descriptor.\n     * @param itf <tt>true</tt> if <tt>owner</tt> is an interface.\n     * @return a new or already existing method reference item.\n     */\n    Item newMethodItem(final String owner, final String name, final String desc, final boolean itf) {\n        int type = itf ? IMETH : METH;\n        key3.set(type, owner, name, desc);\n        Item result = get(key3);\n        if (result == null) {\n            put122(type, newClass(owner), newNameType(name, desc));\n            result = new Item(index++, key3);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a method reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     * <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param owner the internal name of the method's owner class.\n     * @param name the method's name.\n     * @param desc the method's descriptor.\n     * @param itf <tt>true</tt> if <tt>owner</tt> is an interface.\n     * @return the index of a new or already existing method reference item.\n     */\n    public int newMethod(final String owner, final String name, final String desc, final boolean itf) {\n        return newMethodItem(owner, name, desc, itf).index;\n    }\n\n    /**\n     * Adds an integer to the constant pool of the class being build. Does\n     * nothing if the constant pool already contains a similar item.\n     *\n     * @param value the int value.\n     * @return a new or already existing int item.\n     */\n    Item newInteger(final int value) {\n        key.set(value);\n        Item result = get(key);\n        if (result == null) {\n            pool.putByte(INT).putInt(value);\n            result = new Item(index++, key);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a float to the constant pool of the class being build. Does nothing\n     * if the constant pool already contains a similar item.\n     *\n     * @param value the float value.\n     * @return a new or already existing float item.\n     */\n    Item newFloat(final float value) {\n        key.set(value);\n        Item result = get(key);\n        if (result == null) {\n            pool.putByte(FLOAT).putInt(key.intVal);\n            result = new Item(index++, key);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a long to the constant pool of the class being build. Does nothing\n     * if the constant pool already contains a similar item.\n     *\n     * @param value the long value.\n     * @return a new or already existing long item.\n     */\n    Item newLong(final long value) {\n        key.set(value);\n        Item result = get(key);\n        if (result == null) {\n            pool.putByte(LONG).putLong(value);\n            result = new Item(index, key);\n            put(result);\n            index += 2;\n        }\n        return result;\n    }\n\n    /**\n     * Adds a double to the constant pool of the class being build. Does nothing\n     * if the constant pool already contains a similar item.\n     *\n     * @param value the double value.\n     * @return a new or already existing double item.\n     */\n    Item newDouble(final double value) {\n        key.set(value);\n        Item result = get(key);\n        if (result == null) {\n            pool.putByte(DOUBLE).putLong(key.longVal);\n            result = new Item(index, key);\n            put(result);\n            index += 2;\n        }\n        return result;\n    }\n\n    /**\n     * Adds a string to the constant pool of the class being build. Does nothing\n     * if the constant pool already contains a similar item.\n     *\n     * @param value the String value.\n     * @return a new or already existing string item.\n     */\n    private Item newString(final String value) {\n        key2.set(STR, value, null, null);\n        Item result = get(key2);\n        if (result == null) {\n            pool.put12(STR, newUTF8(value));\n            result = new Item(index++, key2);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a name and type to the constant pool of the class being build. Does\n     * nothing if the constant pool already contains a similar item. <i>This\n     * method is intended for {@link Attribute} sub classes, and is normally not\n     * needed by class generators or adapters.</i>\n     *\n     * @param name a name.\n     * @param desc a type descriptor.\n     * @return the index of a new or already existing name and type item.\n     */\n    public int newNameType(final String name, final String desc) {\n        return newNameTypeItem(name, desc).index;\n    }\n\n    /**\n     * Adds a name and type to the constant pool of the class being build. Does\n     * nothing if the constant pool already contains a similar item.\n     *\n     * @param name a name.\n     * @param desc a type descriptor.\n     * @return a new or already existing name and type item.\n     */\n    Item newNameTypeItem(final String name, final String desc) {\n        key2.set(NAME_TYPE, name, desc, null);\n        Item result = get(key2);\n        if (result == null) {\n            put122(NAME_TYPE, newUTF8(name), newUTF8(desc));\n            result = new Item(index++, key2);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds the given internal name to {@link #typeTable} and returns its index.\n     * Does nothing if the type table already contains this internal name.\n     *\n     * @param type the internal name to be added to the type table.\n     * @return the index of this internal name in the type table.\n     */\n    int addType(final String type) {\n        key.set(TYPE_NORMAL, type, null, null);\n        Item result = get(key);\n        if (result == null) {\n            result = addType(key);\n        }\n        return result.index;\n    }\n\n    /**\n     * Adds the given \"uninitialized\" type to {@link #typeTable} and returns its\n     * index. This method is used for UNINITIALIZED types, made of an internal\n     * name and a bytecode offset.\n     *\n     * @param type the internal name to be added to the type table.\n     * @param offset the bytecode offset of the NEW instruction that created\n     *        this UNINITIALIZED type value.\n     * @return the index of this internal name in the type table.\n     */\n    int addUninitializedType(final String type, final int offset) {\n        key.type = TYPE_UNINIT;\n        key.intVal = offset;\n        key.strVal1 = type;\n        key.hashCode = 0x7FFFFFFF & (TYPE_UNINIT + type.hashCode() + offset);\n        Item result = get(key);\n        if (result == null) {\n            result = addType(key);\n        }\n        return result.index;\n    }\n\n    /**\n     * Adds the given Item to {@link #typeTable}.\n     *\n     * @param item the value to be added to the type table.\n     * @return the added Item, which a new Item instance with the same value as\n     *         the given Item.\n     */\n    private Item addType(final Item item) {\n        ++typeCount;\n        Item result = new Item(typeCount, key);\n        put(result);\n        if (typeTable == null) {\n            typeTable = new Item[16];\n        }\n        if (typeCount == typeTable.length) {\n            Item[] newTable = new Item[2 * typeTable.length];\n            System.arraycopy(typeTable, 0, newTable, 0, typeTable.length);\n            typeTable = newTable;\n        }\n        typeTable[typeCount] = result;\n        return result;\n    }\n\n    /**\n     * Returns the index of the common super type of the two given types. This\n     * method calls {@link #getCommonSuperClass} and caches the result in the\n     * {@link #items} hash table to speedup future calls with the same\n     * parameters.\n     *\n     * @param type1 index of an internal name in {@link #typeTable}.\n     * @param type2 index of an internal name in {@link #typeTable}.\n     * @return the index of the common super type of the two given types.\n     */\n    int getMergedType(final int type1, final int type2) {\n        key2.type = TYPE_MERGED;\n        key2.longVal = type1 | (((long) type2) << 32);\n        key2.hashCode = 0x7FFFFFFF & (TYPE_MERGED + type1 + type2);\n        Item result = get(key2);\n        if (result == null) {\n            String t = typeTable[type1].strVal1;\n            String u = typeTable[type2].strVal1;\n            key2.intVal = addType(getCommonSuperClass(t, u));\n            result = new Item((short) 0, key2);\n            put(result);\n        }\n        return result.intVal;\n    }\n\n    /**\n     * Returns the common super type of the two given types. The default\n     * implementation of this method <i>loads<i> the two given classes and uses\n     * the java.lang.Class methods to find the common super class. It can be\n     * overridden to compute this common super type in other ways, in particular\n     * without actually loading any class, or to take into account the class\n     * that is currently being generated by this ClassWriter, which can of\n     * course not be loaded since it is under construction.\n     *\n     * @param type1 the internal name of a class.\n     * @param type2 the internal name of another class.\n     * @return the internal name of the common super class of the two given\n     *         classes.\n     */\n    protected String getCommonSuperClass(final String type1, final String type2) {\n        Class c, d;\n        try {\n            c = Class.forName(type1.replace('/', '.'));\n            d = Class.forName(type2.replace('/', '.'));\n        } catch (Exception e) {\n            throw new RuntimeException(e.toString());\n        }\n        if (c.isAssignableFrom(d)) {\n            return type1;\n        }\n        if (d.isAssignableFrom(c)) {\n            return type2;\n        }\n        if (c.isInterface() || d.isInterface()) {\n            return \"java/lang/Object\";\n        } else {\n            do {\n                c = c.getSuperclass();\n            } while (!c.isAssignableFrom(d));\n            return c.getName().replace('.', '/');\n        }\n    }\n\n    /**\n     * Returns the constant pool's hash table item which is equal to the given\n     * item.\n     *\n     * @param key a constant pool item.\n     * @return the constant pool's hash table item which is equal to the given\n     *         item, or <tt>null</tt> if there is no such item.\n     */\n    private Item get(final Item key) {\n        Item i = items[key.hashCode % items.length];\n        while (i != null && (i.type != key.type || !key.isEqualTo(i))) {\n            i = i.next;\n        }\n        return i;\n    }\n\n    /**\n     * Puts the given item in the constant pool's hash table. The hash table\n     * <i>must</i> not already contains this item.\n     *\n     * @param i the item to be added to the constant pool's hash table.\n     */\n    private void put(final Item i) {\n        if (index > threshold) {\n            int ll = items.length;\n            int nl = ll * 2 + 1;\n            Item[] newItems = new Item[nl];\n            for (int l = ll - 1; l >= 0; --l) {\n                Item j = items[l];\n                while (j != null) {\n                    int index = j.hashCode % newItems.length;\n                    Item k = j.next;\n                    j.next = newItems[index];\n                    newItems[index] = j;\n                    j = k;\n                }\n            }\n            items = newItems;\n            threshold = (int) (nl * 0.75);\n        }\n        int index = i.hashCode % items.length;\n        i.next = items[index];\n        items[index] = i;\n    }\n\n    /**\n     * Puts one byte and two shorts into the constant pool.\n     *\n     * @param b a byte.\n     * @param s1 a short.\n     * @param s2 another short.\n     */\n    private void put122(final int b, final int s1, final int s2) {\n        pool.put12(b, s1).putShort(s2);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/ClassWriterTest1.java",
		"test_prompt": "// ClassWriterTest1.java\npackage org.objectweb.asm.jip;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassWriter}.\n* It contains ten unit test cases for the {@link ClassWriter#visitField(int, String, String, String, Object)} method.\n*/\nclass ClassWriterTest1 {"
	},
	{
		"original_code": "// ClassWriter.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\n/**\n * A {@link ClassVisitor} that generates classes in bytecode form. More\n * precisely this visitor generates a byte array conforming to the Java class\n * file format. It can be used alone, to generate a Java class \"from scratch\",\n * or with one or more {@link ClassReader ClassReader} and adapter class visitor\n * to generate a modified class from one or more existing Java classes.\n *\n * @author Eric Bruneton\n */\npublic class ClassWriter implements ClassVisitor {\n\n    /**\n     * Flag to automatically compute the maximum stack size and the maximum\n     * number of local variables of methods. If this flag is set, then the\n     * arguments of the {@link MethodVisitor#visitMaxs visitMaxs} method of the\n     * {@link MethodVisitor} returned by the {@link #visitMethod visitMethod}\n     * method will be ignored, and computed automatically from the signature and\n     * the bytecode of each method.\n     *\n     * @see #ClassWriter(int)\n     */\n    public static final int COMPUTE_MAXS = 1;\n\n    /**\n     * Flag to automatically compute the stack map frames of methods from\n     * scratch. If this flag is set, then the calls to the\n     * {@link MethodVisitor#visitFrame} method are ignored, and the stack map\n     * frames are recomputed from the methods bytecode. The arguments of the\n     * {@link MethodVisitor#visitMaxs visitMaxs} method are also ignored and\n     * recomputed from the bytecode. In other words, computeFrames implies\n     * computeMaxs.\n     *\n     * @see #ClassWriter(int)\n     */\n    public static final int COMPUTE_FRAMES = 2;\n\n    /**\n     * The type of instructions without any argument.\n     */\n    static final int NOARG_INSN = 0;\n\n    /**\n     * The type of instructions with an signed byte argument.\n     */\n    static final int SBYTE_INSN = 1;\n\n    /**\n     * The type of instructions with an signed short argument.\n     */\n    static final int SHORT_INSN = 2;\n\n    /**\n     * The type of instructions with a local variable index argument.\n     */\n    static final int VAR_INSN = 3;\n\n    /**\n     * The type of instructions with an implicit local variable index argument.\n     */\n    static final int IMPLVAR_INSN = 4;\n\n    /**\n     * The type of instructions with a type descriptor argument.\n     */\n    static final int TYPE_INSN = 5;\n\n    /**\n     * The type of field and method invocations instructions.\n     */\n    static final int FIELDORMETH_INSN = 6;\n\n    /**\n     * The type of the INVOKEINTERFACE/INVOKEDYNAMIC instruction.\n     */\n    static final int ITFDYNMETH_INSN = 7;\n\n    /**\n     * The type of instructions with a 2 bytes bytecode offset label.\n     */\n    static final int LABEL_INSN = 8;\n\n    /**\n     * The type of instructions with a 4 bytes bytecode offset label.\n     */\n    static final int LABELW_INSN = 9;\n\n    /**\n     * The type of the LDC instruction.\n     */\n    static final int LDC_INSN = 10;\n\n    /**\n     * The type of the LDC_W and LDC2_W instructions.\n     */\n    static final int LDCW_INSN = 11;\n\n    /**\n     * The type of the IINC instruction.\n     */\n    static final int IINC_INSN = 12;\n\n    /**\n     * The type of the TABLESWITCH instruction.\n     */\n    static final int TABL_INSN = 13;\n\n    /**\n     * The type of the LOOKUPSWITCH instruction.\n     */\n    static final int LOOK_INSN = 14;\n\n    /**\n     * The type of the MULTIANEWARRAY instruction.\n     */\n    static final int MANA_INSN = 15;\n\n    /**\n     * The type of the WIDE instruction.\n     */\n    static final int WIDE_INSN = 16;\n\n    /**\n     * The instruction types of all JVM opcodes.\n     */\n    static final byte[] TYPE;\n\n    /**\n     * The type of CONSTANT_Class constant pool items.\n     */\n    static final int CLASS = 7;\n\n    /**\n     * The type of CONSTANT_Fieldref constant pool items.\n     */\n    static final int FIELD = 9;\n\n    /**\n     * The type of CONSTANT_Methodref constant pool items.\n     */\n    static final int METH = 10;\n\n    /**\n     * The type of CONSTANT_InterfaceMethodref constant pool items.\n     */\n    static final int IMETH = 11;\n\n    /**\n     * The type of CONSTANT_String constant pool items.\n     */\n    static final int STR = 8;\n\n    /**\n     * The type of CONSTANT_Integer constant pool items.\n     */\n    static final int INT = 3;\n\n    /**\n     * The type of CONSTANT_Float constant pool items.\n     */\n    static final int FLOAT = 4;\n\n    /**\n     * The type of CONSTANT_Long constant pool items.\n     */\n    static final int LONG = 5;\n\n    /**\n     * The type of CONSTANT_Double constant pool items.\n     */\n    static final int DOUBLE = 6;\n\n    /**\n     * The type of CONSTANT_NameAndType constant pool items.\n     */\n    static final int NAME_TYPE = 12;\n\n    /**\n     * The type of CONSTANT_Utf8 constant pool items.\n     */\n    static final int UTF8 = 1;\n\n    /**\n     * Normal type Item stored in the ClassWriter {@link ClassWriter#typeTable},\n     * instead of the constant pool, in order to avoid clashes with normal\n     * constant pool items in the ClassWriter constant pool's hash table.\n     */\n    static final int TYPE_NORMAL = 13;\n\n    /**\n     * Uninitialized type Item stored in the ClassWriter\n     * {@link ClassWriter#typeTable}, instead of the constant pool, in order to\n     * avoid clashes with normal constant pool items in the ClassWriter constant\n     * pool's hash table.\n     */\n    static final int TYPE_UNINIT = 14;\n\n    /**\n     * Merged type Item stored in the ClassWriter {@link ClassWriter#typeTable},\n     * instead of the constant pool, in order to avoid clashes with normal\n     * constant pool items in the ClassWriter constant pool's hash table.\n     */\n    static final int TYPE_MERGED = 15;\n\n    /**\n     * The class reader from which this class writer was constructed, if any.\n     */\n    ClassReader cr;\n\n    /**\n     * Minor and major version numbers of the class to be generated.\n     */\n    int version;\n\n    /**\n     * Index of the next item to be added in the constant pool.\n     */\n    int index;\n\n    /**\n     * The constant pool of this class.\n     */\n    final ByteVector pool;\n\n    /**\n     * The constant pool's hash table data.\n     */\n    Item[] items;\n\n    /**\n     * The threshold of the constant pool's hash table.\n     */\n    int threshold;\n\n    /**\n     * A reusable key used to look for items in the {@link #items} hash table.\n     */\n    final Item key;\n\n    /**\n     * A reusable key used to look for items in the {@link #items} hash table.\n     */\n    final Item key2;\n\n    /**\n     * A reusable key used to look for items in the {@link #items} hash table.\n     */\n    final Item key3;\n\n    /**\n     * A type table used to temporarily store internal names that will not\n     * necessarily be stored in the constant pool. This type table is used by\n     * the control flow and data flow analysis algorithm used to compute stack\n     * map frames from scratch. This array associates to each index <tt>i</tt>\n     * the Item whose index is <tt>i</tt>. All Item objects stored in this\n     * array are also stored in the {@link #items} hash table. These two arrays\n     * allow to retrieve an Item from its index or, conversely, to get the index\n     * of an Item from its value. Each Item stores an internal name in its\n     * {@link Item#strVal1} field.\n     */\n    Item[] typeTable;\n\n    /**\n     * Number of elements in the {@link #typeTable} array.\n     */\n    private short typeCount;\n\n    /**\n     * The access flags of this class.\n     */\n    private int access;\n\n    /**\n     * The constant pool item that contains the internal name of this class.\n     */\n    private int name;\n\n    /**\n     * The internal name of this class.\n     */\n    String thisName;\n\n    /**\n     * The constant pool item that contains the signature of this class.\n     */\n    private int signature;\n\n    /**\n     * The constant pool item that contains the internal name of the super class\n     * of this class.\n     */\n    private int superName;\n\n    /**\n     * Number of interfaces implemented or extended by this class or interface.\n     */\n    private int interfaceCount;\n\n    /**\n     * The interfaces implemented or extended by this class or interface. More\n     * precisely, this array contains the indexes of the constant pool items\n     * that contain the internal names of these interfaces.\n     */\n    private int[] interfaces;\n\n    /**\n     * The index of the constant pool item that contains the name of the source\n     * file from which this class was compiled.\n     */\n    private int sourceFile;\n\n    /**\n     * The SourceDebug attribute of this class.\n     */\n    private ByteVector sourceDebug;\n\n    /**\n     * The constant pool item that contains the name of the enclosing class of\n     * this class.\n     */\n    private int enclosingMethodOwner;\n\n    /**\n     * The constant pool item that contains the name and descriptor of the\n     * enclosing method of this class.\n     */\n    private int enclosingMethod;\n\n    /**\n     * The runtime visible annotations of this class.\n     */\n    private AnnotationWriter anns;\n\n    /**\n     * The runtime invisible annotations of this class.\n     */\n    private AnnotationWriter ianns;\n\n    /**\n     * The non standard attributes of this class.\n     */\n    private Attribute attrs;\n\n    /**\n     * The number of entries in the InnerClasses attribute.\n     */\n    private int innerClassesCount;\n\n    /**\n     * The InnerClasses attribute.\n     */\n    private ByteVector innerClasses;\n\n    /**\n     * The fields of this class. These fields are stored in a linked list of\n     * {@link FieldWriter} objects, linked to each other by their\n     * {@link FieldWriter#next} field. This field stores the first element of\n     * this list.\n     */\n    FieldWriter firstField;\n\n    /**\n     * The fields of this class. These fields are stored in a linked list of\n     * {@link FieldWriter} objects, linked to each other by their\n     * {@link FieldWriter#next} field. This field stores the last element of\n     * this list.\n     */\n    FieldWriter lastField;\n\n    /**\n     * The methods of this class. These methods are stored in a linked list of\n     * {@link MethodWriter} objects, linked to each other by their\n     * {@link MethodWriter#next} field. This field stores the first element of\n     * this list.\n     */\n    MethodWriter firstMethod;\n\n    /**\n     * The methods of this class. These methods are stored in a linked list of\n     * {@link MethodWriter} objects, linked to each other by their\n     * {@link MethodWriter#next} field. This field stores the last element of\n     * this list.\n     */\n    MethodWriter lastMethod;\n\n    /**\n     * <tt>true</tt> if the maximum stack size and number of local variables\n     * must be automatically computed.\n     */\n    private final boolean computeMaxs;\n\n    /**\n     * <tt>true</tt> if the stack map frames must be recomputed from scratch.\n     */\n    private final boolean computeFrames;\n\n    /**\n     * <tt>true</tt> if the stack map tables of this class are invalid. The\n     * {@link MethodWriter#resizeInstructions} method cannot transform existing\n     * stack map tables, and so produces potentially invalid classes when it is\n     * executed. In this case the class is reread and rewritten with the\n     * {@link #COMPUTE_FRAMES} option (the resizeInstructions method can resize\n     * stack map tables when this option is used).\n     */\n    boolean invalidFrames;\n\n    // ------------------------------------------------------------------------\n    // Static initializer\n    // ------------------------------------------------------------------------\n    /**\n     * Computes the instruction types of JVM opcodes.\n     */\n    static {\n        int i;\n        byte[] b = new byte[220];\n        String s = \"AAAAAAAAAAAAAAAABCKLLDDDDDEEEEEEEEEEEEEEEEEEEEAAAAAAAADD\" + \"DDDEEEEEEEEEEEEEEEEEEEEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAAIIIIIIIIIIIIIIIIDNOAA\" + \"AAAAGGGGGGGHHFBFAAFFAAQPIIJJIIIIIIIIIIIIIIIIII\";\n        for (i = 0; i < b.length; ++i) {\n            b[i] = (byte) (s.charAt(i) - 'A');\n        }\n        TYPE = b;\n        // code to generate the above string\n        //\n        // // SBYTE_INSN instructions\n        // b[Constants.NEWARRAY] = SBYTE_INSN;\n        // b[Constants.BIPUSH] = SBYTE_INSN;\n        //\n        // // SHORT_INSN instructions\n        // b[Constants.SIPUSH] = SHORT_INSN;\n        //\n        // // (IMPL)VAR_INSN instructions\n        // b[Constants.RET] = VAR_INSN;\n        // for (i = Constants.ILOAD; i <= Constants.ALOAD; ++i) {\n        // b[i] = VAR_INSN;\n        // }\n        // for (i = Constants.ISTORE; i <= Constants.ASTORE; ++i) {\n        // b[i] = VAR_INSN;\n        // }\n        // for (i = 26; i <= 45; ++i) { // ILOAD_0 to ALOAD_3\n        // b[i] = IMPLVAR_INSN;\n        // }\n        // for (i = 59; i <= 78; ++i) { // ISTORE_0 to ASTORE_3\n        // b[i] = IMPLVAR_INSN;\n        // }\n        //\n        // // TYPE_INSN instructions\n        // b[Constants.NEW] = TYPE_INSN;\n        // b[Constants.ANEWARRAY] = TYPE_INSN;\n        // b[Constants.CHECKCAST] = TYPE_INSN;\n        // b[Constants.INSTANCEOF] = TYPE_INSN;\n        //\n        // // (Set)FIELDORMETH_INSN instructions\n        // for (i = Constants.GETSTATIC; i <= Constants.INVOKESTATIC; ++i) {\n        // b[i] = FIELDORMETH_INSN;\n        // }\n        // b[Constants.INVOKEINTERFACE] = ITFDYNMETH_INSN;\n        // b[Constants.INVOKEDYNAMIC] = ITFDYNMETH_INSN;\n        //\n        // // LABEL(W)_INSN instructions\n        // for (i = Constants.IFEQ; i <= Constants.JSR; ++i) {\n        // b[i] = LABEL_INSN;\n        // }\n        // b[Constants.IFNULL] = LABEL_INSN;\n        // b[Constants.IFNONNULL] = LABEL_INSN;\n        // b[200] = LABELW_INSN; // GOTO_W\n        // b[201] = LABELW_INSN; // JSR_W\n        // // temporary opcodes used internally by ASM - see Label and\n        // MethodWriter\n        // for (i = 202; i < 220; ++i) {\n        // b[i] = LABEL_INSN;\n        // }\n        //\n        // // LDC(_W) instructions\n        // b[Constants.LDC] = LDC_INSN;\n        // b[19] = LDCW_INSN; // LDC_W\n        // b[20] = LDCW_INSN; // LDC2_W\n        //\n        // // special instructions\n        // b[Constants.IINC] = IINC_INSN;\n        // b[Constants.TABLESWITCH] = TABL_INSN;\n        // b[Constants.LOOKUPSWITCH] = LOOK_INSN;\n        // b[Constants.MULTIANEWARRAY] = MANA_INSN;\n        // b[196] = WIDE_INSN; // WIDE\n        //\n        // for (i = 0; i < b.length; ++i) {\n        // System.err.print((char)('A' + b[i]));\n        // }\n        // System.err.println();\n    }\n\n    // ------------------------------------------------------------------------\n    // Constructor\n    // ------------------------------------------------------------------------\n    /**\n     * Constructs a new {@link ClassWriter} object.\n     *\n     * @param flags option flags that can be used to modify the default behavior\n     *        of this class. See {@link #COMPUTE_MAXS}, {@link #COMPUTE_FRAMES}.\n     */\n    public ClassWriter(final int flags) {\n        index = 1;\n        pool = new ByteVector();\n        items = new Item[256];\n        threshold = (int) (0.75d * items.length);\n        key = new Item();\n        key2 = new Item();\n        key3 = new Item();\n        this.computeMaxs = (flags & COMPUTE_MAXS) != 0;\n        this.computeFrames = (flags & COMPUTE_FRAMES) != 0;\n    }\n\n    /**\n     * Constructs a new {@link ClassWriter} object and enables optimizations for\n     * \"mostly add\" bytecode transformations. These optimizations are the\n     * following:\n     *\n     * <ul> <li>The constant pool from the original class is copied as is in\n     * the new class, which saves time. New constant pool entries will be added\n     * at the end if necessary, but unused constant pool entries <i>won't be\n     * removed</i>.</li> <li>Methods that are not transformed are copied as\n     * is in the new class, directly from the original class bytecode (i.e.\n     * without emitting visit events for all the method instructions), which\n     * saves a <i>lot</i> of time. Untransformed methods are detected by the\n     * fact that the {@link ClassReader} receives {@link MethodVisitor} objects\n     * that come from a {@link ClassWriter} (and not from a custom\n     * {@link ClassAdapter} or any other {@link ClassVisitor} instance).</li>\n     * </ul>\n     *\n     * @param classReader the {@link ClassReader} used to read the original\n     *        class. It will be used to copy the entire constant pool from the\n     *        original class and also to copy other fragments of original\n     *        bytecode where applicable.\n     * @param flags option flags that can be used to modify the default behavior\n     *        of this class. See {@link #COMPUTE_MAXS}, {@link #COMPUTE_FRAMES}.\n     */\n    public ClassWriter(final ClassReader classReader, final int flags) {\n        this(flags);\n        classReader.copyPool(this);\n        this.cr = classReader;\n    }\n\n    // ------------------------------------------------------------------------\n    // Implementation of the ClassVisitor interface\n    // ------------------------------------------------------------------------\n    public void visit(final int version, final int access, final String name, final String signature, final String superName, final String[] interfaces) {\n        this.version = version;\n        this.access = access;\n        this.name = newClass(name);\n        thisName = name;\n        if (ClassReader.SIGNATURES && signature != null) {\n            this.signature = newUTF8(signature);\n        }\n        this.superName = superName == null ? 0 : newClass(superName);\n        if (interfaces != null && interfaces.length > 0) {\n            interfaceCount = interfaces.length;\n            this.interfaces = new int[interfaceCount];\n            for (int i = 0; i < interfaceCount; ++i) {\n                this.interfaces[i] = newClass(interfaces[i]);\n            }\n        }\n    }\n\n    public void visitSource(final String file, final String debug) {\n        if (file != null) {\n            sourceFile = newUTF8(file);\n        }\n        if (debug != null) {\n            sourceDebug = new ByteVector().putUTF8(debug);\n        }\n    }\n\n    public void visitOuterClass(final String owner, final String name, final String desc) {\n        enclosingMethodOwner = newClass(owner);\n        if (name != null && desc != null) {\n            enclosingMethod = newNameType(name, desc);\n        }\n    }\n\n    public AnnotationVisitor visitAnnotation(final String desc, final boolean visible) {\n        if (!ClassReader.ANNOTATIONS) {\n            return null;\n        }\n        ByteVector bv = new ByteVector();\n        // write type, and reserve space for values count\n        bv.putShort(newUTF8(desc)).putShort(0);\n        AnnotationWriter aw = new AnnotationWriter(this, true, bv, bv, 2);\n        if (visible) {\n            aw.next = anns;\n            anns = aw;\n        } else {\n            aw.next = ianns;\n            ianns = aw;\n        }\n        return aw;\n    }\n\n    public void visitAttribute(final Attribute attr) {\n        attr.next = attrs;\n        attrs = attr;\n    }\n\n    public void visitInnerClass(final String name, final String outerName, final String innerName, final int access) {\n        if (innerClasses == null) {\n            innerClasses = new ByteVector();\n        }\n        ++innerClassesCount;\n        innerClasses.putShort(name == null ? 0 : newClass(name));\n        innerClasses.putShort(outerName == null ? 0 : newClass(outerName));\n        innerClasses.putShort(innerName == null ? 0 : newUTF8(innerName));\n        innerClasses.putShort(access);\n    }\n\n    public FieldVisitor visitField(final int access, final String name, final String desc, final String signature, final Object value) {\n        return new FieldWriter(this, access, name, desc, signature, value);\n    }\n\n    public MethodVisitor visitMethod(final int access, final String name, final String desc, final String signature, final String[] exceptions) {\n        return new MethodWriter(this, access, name, desc, signature, exceptions, computeMaxs, computeFrames);\n    }\n\n    public void visitEnd() {\n    }\n\n    // ------------------------------------------------------------------------\n    // Other public methods\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the bytecode of the class that was build with this class writer.\n     *\n     * @return the bytecode of the class that was build with this class writer.\n     */\n    public byte[] toByteArray() {\n        // computes the real size of the bytecode of this class\n        int size = 24 + 2 * interfaceCount;\n        int nbFields = 0;\n        FieldWriter fb = firstField;\n        while (fb != null) {\n            ++nbFields;\n            size += fb.getSize();\n            fb = fb.next;\n        }\n        int nbMethods = 0;\n        MethodWriter mb = firstMethod;\n        while (mb != null) {\n            ++nbMethods;\n            size += mb.getSize();\n            mb = mb.next;\n        }\n        int attributeCount = 0;\n        if (ClassReader.SIGNATURES && signature != 0) {\n            ++attributeCount;\n            size += 8;\n            newUTF8(\"Signature\");\n        }\n        if (sourceFile != 0) {\n            ++attributeCount;\n            size += 8;\n            newUTF8(\"SourceFile\");\n        }\n        if (sourceDebug != null) {\n            ++attributeCount;\n            size += sourceDebug.length + 4;\n            newUTF8(\"SourceDebugExtension\");\n        }\n        if (enclosingMethodOwner != 0) {\n            ++attributeCount;\n            size += 10;\n            newUTF8(\"EnclosingMethod\");\n        }\n        if ((access & Opcodes.ACC_DEPRECATED) != 0) {\n            ++attributeCount;\n            size += 6;\n            newUTF8(\"Deprecated\");\n        }\n        if ((access & Opcodes.ACC_SYNTHETIC) != 0 && (version & 0xffff) < Opcodes.V1_5) {\n            ++attributeCount;\n            size += 6;\n            newUTF8(\"Synthetic\");\n        }\n        if (innerClasses != null) {\n            ++attributeCount;\n            size += 8 + innerClasses.length;\n            newUTF8(\"InnerClasses\");\n        }\n        if (ClassReader.ANNOTATIONS && anns != null) {\n            ++attributeCount;\n            size += 8 + anns.getSize();\n            newUTF8(\"RuntimeVisibleAnnotations\");\n        }\n        if (ClassReader.ANNOTATIONS && ianns != null) {\n            ++attributeCount;\n            size += 8 + ianns.getSize();\n            newUTF8(\"RuntimeInvisibleAnnotations\");\n        }\n        if (attrs != null) {\n            attributeCount += attrs.getCount();\n            size += attrs.getSize(this, null, 0, -1, -1);\n        }\n        size += pool.length;\n        // allocates a byte vector of this size, in order to avoid unnecessary\n        // arraycopy operations in the ByteVector.enlarge() method\n        ByteVector out = new ByteVector(size);\n        out.putInt(0xCAFEBABE).putInt(version);\n        out.putShort(index).putByteArray(pool.data, 0, pool.length);\n        out.putShort(access).putShort(name).putShort(superName);\n        out.putShort(interfaceCount);\n        for (int i = 0; i < interfaceCount; ++i) {\n            out.putShort(interfaces[i]);\n        }\n        out.putShort(nbFields);\n        fb = firstField;\n        while (fb != null) {\n            fb.put(out);\n            fb = fb.next;\n        }\n        out.putShort(nbMethods);\n        mb = firstMethod;\n        while (mb != null) {\n            mb.put(out);\n            mb = mb.next;\n        }\n        out.putShort(attributeCount);\n        if (ClassReader.SIGNATURES && signature != 0) {\n            out.putShort(newUTF8(\"Signature\")).putInt(2).putShort(signature);\n        }\n        if (sourceFile != 0) {\n            out.putShort(newUTF8(\"SourceFile\")).putInt(2).putShort(sourceFile);\n        }\n        if (sourceDebug != null) {\n            int len = sourceDebug.length - 2;\n            out.putShort(newUTF8(\"SourceDebugExtension\")).putInt(len);\n            out.putByteArray(sourceDebug.data, 2, len);\n        }\n        if (enclosingMethodOwner != 0) {\n            out.putShort(newUTF8(\"EnclosingMethod\")).putInt(4);\n            out.putShort(enclosingMethodOwner).putShort(enclosingMethod);\n        }\n        if ((access & Opcodes.ACC_DEPRECATED) != 0) {\n            out.putShort(newUTF8(\"Deprecated\")).putInt(0);\n        }\n        if ((access & Opcodes.ACC_SYNTHETIC) != 0 && (version & 0xffff) < Opcodes.V1_5) {\n            out.putShort(newUTF8(\"Synthetic\")).putInt(0);\n        }\n        if (innerClasses != null) {\n            out.putShort(newUTF8(\"InnerClasses\"));\n            out.putInt(innerClasses.length + 2).putShort(innerClassesCount);\n            out.putByteArray(innerClasses.data, 0, innerClasses.length);\n        }\n        if (ClassReader.ANNOTATIONS && anns != null) {\n            out.putShort(newUTF8(\"RuntimeVisibleAnnotations\"));\n            anns.put(out);\n        }\n        if (ClassReader.ANNOTATIONS && ianns != null) {\n            out.putShort(newUTF8(\"RuntimeInvisibleAnnotations\"));\n            ianns.put(out);\n        }\n        if (attrs != null) {\n            attrs.put(this, null, 0, -1, -1, out);\n        }\n        if (invalidFrames) {\n            ClassWriter cw = new ClassWriter(COMPUTE_FRAMES);\n            new ClassReader(out.data).accept(cw, ClassReader.SKIP_FRAMES);\n            return cw.toByteArray();\n        }\n        return out.data;\n    }\n\n    // ------------------------------------------------------------------------\n    // Utility methods: constant pool management\n    // ------------------------------------------------------------------------\n    /**\n     * Adds a number or string constant to the constant pool of the class being\n     * build. Does nothing if the constant pool already contains a similar item.\n     *\n     * @param cst the value of the constant to be added to the constant pool.\n     *        This parameter must be an {@link Integer}, a {@link Float}, a\n     *        {@link Long}, a {@link Double}, a {@link String} or a\n     *        {@link Type}.\n     * @return a new or already existing constant item with the given value.\n     */\n    Item newConstItem(final Object cst) {\n        if (cst instanceof Integer) {\n            int val = ((Integer) cst).intValue();\n            return newInteger(val);\n        } else if (cst instanceof Byte) {\n            int val = ((Byte) cst).intValue();\n            return newInteger(val);\n        } else if (cst instanceof Character) {\n            int val = ((Character) cst).charValue();\n            return newInteger(val);\n        } else if (cst instanceof Short) {\n            int val = ((Short) cst).intValue();\n            return newInteger(val);\n        } else if (cst instanceof Boolean) {\n            int val = ((Boolean) cst).booleanValue() ? 1 : 0;\n            return newInteger(val);\n        } else if (cst instanceof Float) {\n            float val = ((Float) cst).floatValue();\n            return newFloat(val);\n        } else if (cst instanceof Long) {\n            long val = ((Long) cst).longValue();\n            return newLong(val);\n        } else if (cst instanceof Double) {\n            double val = ((Double) cst).doubleValue();\n            return newDouble(val);\n        } else if (cst instanceof String) {\n            return newString((String) cst);\n        } else if (cst instanceof Type) {\n            Type t = (Type) cst;\n            return newClassItem(t.getSort() == Type.OBJECT ? t.getInternalName() : t.getDescriptor());\n        } else {\n            throw new IllegalArgumentException(\"value \" + cst);\n        }\n    }\n\n    /**\n     * Adds a number or string constant to the constant pool of the class being\n     * build. Does nothing if the constant pool already contains a similar item.\n     * <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param cst the value of the constant to be added to the constant pool.\n     *        This parameter must be an {@link Integer}, a {@link Float}, a\n     *        {@link Long}, a {@link Double} or a {@link String}.\n     * @return the index of a new or already existing constant item with the\n     *         given value.\n     */\n    public int newConst(final Object cst) {\n        return newConstItem(cst).index;\n    }\n\n    /**\n     * Adds an UTF8 string to the constant pool of the class being build. Does\n     * nothing if the constant pool already contains a similar item. <i>This\n     * method is intended for {@link Attribute} sub classes, and is normally not\n     * needed by class generators or adapters.</i>\n     *\n     * @param value the String value.\n     * @return the index of a new or already existing UTF8 item.\n     */\n    public int newUTF8(final String value) {\n        key.set(UTF8, value, null, null);\n        Item result = get(key);\n        if (result == null) {\n            pool.putByte(UTF8).putUTF8(value);\n            result = new Item(index++, key);\n            put(result);\n        }\n        return result.index;\n    }\n\n    /**\n     * Adds a class reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     * <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param value the internal name of the class.\n     * @return a new or already existing class reference item.\n     */\n    Item newClassItem(final String value) {\n        key2.set(CLASS, value, null, null);\n        Item result = get(key2);\n        if (result == null) {\n            pool.put12(CLASS, newUTF8(value));\n            result = new Item(index++, key2);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a class reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     * <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param value the internal name of the class.\n     * @return the index of a new or already existing class reference item.\n     */\n    public int newClass(final String value) {\n        return newClassItem(value).index;\n    }\n\n    /**\n     * Adds a field reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     *\n     * @param owner the internal name of the field's owner class.\n     * @param name the field's name.\n     * @param desc the field's descriptor.\n     * @return a new or already existing field reference item.\n     */\n    Item newFieldItem(final String owner, final String name, final String desc) {\n        key3.set(FIELD, owner, name, desc);\n        Item result = get(key3);\n        if (result == null) {\n            put122(FIELD, newClass(owner), newNameType(name, desc));\n            result = new Item(index++, key3);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a field reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     * <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param owner the internal name of the field's owner class.\n     * @param name the field's name.\n     * @param desc the field's descriptor.\n     * @return the index of a new or already existing field reference item.\n     */\n    public int newField(final String owner, final String name, final String desc) {\n        return newFieldItem(owner, name, desc).index;\n    }\n\n    /**\n     * Adds a method reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     *\n     * @param owner the internal name of the method's owner class.\n     * @param name the method's name.\n     * @param desc the method's descriptor.\n     * @param itf <tt>true</tt> if <tt>owner</tt> is an interface.\n     * @return a new or already existing method reference item.\n     */\n    Item newMethodItem(final String owner, final String name, final String desc, final boolean itf) {\n        int type = itf ? IMETH : METH;\n        key3.set(type, owner, name, desc);\n        Item result = get(key3);\n        if (result == null) {\n            put122(type, newClass(owner), newNameType(name, desc));\n            result = new Item(index++, key3);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a method reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     * <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param owner the internal name of the method's owner class.\n     * @param name the method's name.\n     * @param desc the method's descriptor.\n     * @param itf <tt>true</tt> if <tt>owner</tt> is an interface.\n     * @return the index of a new or already existing method reference item.\n     */\n    public int newMethod(final String owner, final String name, final String desc, final boolean itf) {\n        return newMethodItem(owner, name, desc, itf).index;\n    }\n\n    /**\n     * Adds an integer to the constant pool of the class being build. Does\n     * nothing if the constant pool already contains a similar item.\n     *\n     * @param value the int value.\n     * @return a new or already existing int item.\n     */\n    Item newInteger(final int value) {\n        key.set(value);\n        Item result = get(key);\n        if (result == null) {\n            pool.putByte(INT).putInt(value);\n            result = new Item(index++, key);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a float to the constant pool of the class being build. Does nothing\n     * if the constant pool already contains a similar item.\n     *\n     * @param value the float value.\n     * @return a new or already existing float item.\n     */\n    Item newFloat(final float value) {\n        key.set(value);\n        Item result = get(key);\n        if (result == null) {\n            pool.putByte(FLOAT).putInt(key.intVal);\n            result = new Item(index++, key);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a long to the constant pool of the class being build. Does nothing\n     * if the constant pool already contains a similar item.\n     *\n     * @param value the long value.\n     * @return a new or already existing long item.\n     */\n    Item newLong(final long value) {\n        key.set(value);\n        Item result = get(key);\n        if (result == null) {\n            pool.putByte(LONG).putLong(value);\n            result = new Item(index, key);\n            put(result);\n            index += 2;\n        }\n        return result;\n    }\n\n    /**\n     * Adds a double to the constant pool of the class being build. Does nothing\n     * if the constant pool already contains a similar item.\n     *\n     * @param value the double value.\n     * @return a new or already existing double item.\n     */\n    Item newDouble(final double value) {\n        key.set(value);\n        Item result = get(key);\n        if (result == null) {\n            pool.putByte(DOUBLE).putLong(key.longVal);\n            result = new Item(index, key);\n            put(result);\n            index += 2;\n        }\n        return result;\n    }\n\n    /**\n     * Adds a string to the constant pool of the class being build. Does nothing\n     * if the constant pool already contains a similar item.\n     *\n     * @param value the String value.\n     * @return a new or already existing string item.\n     */\n    private Item newString(final String value) {\n        key2.set(STR, value, null, null);\n        Item result = get(key2);\n        if (result == null) {\n            pool.put12(STR, newUTF8(value));\n            result = new Item(index++, key2);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a name and type to the constant pool of the class being build. Does\n     * nothing if the constant pool already contains a similar item. <i>This\n     * method is intended for {@link Attribute} sub classes, and is normally not\n     * needed by class generators or adapters.</i>\n     *\n     * @param name a name.\n     * @param desc a type descriptor.\n     * @return the index of a new or already existing name and type item.\n     */\n    public int newNameType(final String name, final String desc) {\n        return newNameTypeItem(name, desc).index;\n    }\n\n    /**\n     * Adds a name and type to the constant pool of the class being build. Does\n     * nothing if the constant pool already contains a similar item.\n     *\n     * @param name a name.\n     * @param desc a type descriptor.\n     * @return a new or already existing name and type item.\n     */\n    Item newNameTypeItem(final String name, final String desc) {\n        key2.set(NAME_TYPE, name, desc, null);\n        Item result = get(key2);\n        if (result == null) {\n            put122(NAME_TYPE, newUTF8(name), newUTF8(desc));\n            result = new Item(index++, key2);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds the given internal name to {@link #typeTable} and returns its index.\n     * Does nothing if the type table already contains this internal name.\n     *\n     * @param type the internal name to be added to the type table.\n     * @return the index of this internal name in the type table.\n     */\n    int addType(final String type) {\n        key.set(TYPE_NORMAL, type, null, null);\n        Item result = get(key);\n        if (result == null) {\n            result = addType(key);\n        }\n        return result.index;\n    }\n\n    /**\n     * Adds the given \"uninitialized\" type to {@link #typeTable} and returns its\n     * index. This method is used for UNINITIALIZED types, made of an internal\n     * name and a bytecode offset.\n     *\n     * @param type the internal name to be added to the type table.\n     * @param offset the bytecode offset of the NEW instruction that created\n     *        this UNINITIALIZED type value.\n     * @return the index of this internal name in the type table.\n     */\n    int addUninitializedType(final String type, final int offset) {\n        key.type = TYPE_UNINIT;\n        key.intVal = offset;\n        key.strVal1 = type;\n        key.hashCode = 0x7FFFFFFF & (TYPE_UNINIT + type.hashCode() + offset);\n        Item result = get(key);\n        if (result == null) {\n            result = addType(key);\n        }\n        return result.index;\n    }\n\n    /**\n     * Adds the given Item to {@link #typeTable}.\n     *\n     * @param item the value to be added to the type table.\n     * @return the added Item, which a new Item instance with the same value as\n     *         the given Item.\n     */\n    private Item addType(final Item item) {\n        ++typeCount;\n        Item result = new Item(typeCount, key);\n        put(result);\n        if (typeTable == null) {\n            typeTable = new Item[16];\n        }\n        if (typeCount == typeTable.length) {\n            Item[] newTable = new Item[2 * typeTable.length];\n            System.arraycopy(typeTable, 0, newTable, 0, typeTable.length);\n            typeTable = newTable;\n        }\n        typeTable[typeCount] = result;\n        return result;\n    }\n\n    /**\n     * Returns the index of the common super type of the two given types. This\n     * method calls {@link #getCommonSuperClass} and caches the result in the\n     * {@link #items} hash table to speedup future calls with the same\n     * parameters.\n     *\n     * @param type1 index of an internal name in {@link #typeTable}.\n     * @param type2 index of an internal name in {@link #typeTable}.\n     * @return the index of the common super type of the two given types.\n     */\n    int getMergedType(final int type1, final int type2) {\n        key2.type = TYPE_MERGED;\n        key2.longVal = type1 | (((long) type2) << 32);\n        key2.hashCode = 0x7FFFFFFF & (TYPE_MERGED + type1 + type2);\n        Item result = get(key2);\n        if (result == null) {\n            String t = typeTable[type1].strVal1;\n            String u = typeTable[type2].strVal1;\n            key2.intVal = addType(getCommonSuperClass(t, u));\n            result = new Item((short) 0, key2);\n            put(result);\n        }\n        return result.intVal;\n    }\n\n    /**\n     * Returns the common super type of the two given types. The default\n     * implementation of this method <i>loads<i> the two given classes and uses\n     * the java.lang.Class methods to find the common super class. It can be\n     * overridden to compute this common super type in other ways, in particular\n     * without actually loading any class, or to take into account the class\n     * that is currently being generated by this ClassWriter, which can of\n     * course not be loaded since it is under construction.\n     *\n     * @param type1 the internal name of a class.\n     * @param type2 the internal name of another class.\n     * @return the internal name of the common super class of the two given\n     *         classes.\n     */\n    protected String getCommonSuperClass(final String type1, final String type2) {\n        Class c, d;\n        try {\n            c = Class.forName(type1.replace('/', '.'));\n            d = Class.forName(type2.replace('/', '.'));\n        } catch (Exception e) {\n            throw new RuntimeException(e.toString());\n        }\n        if (c.isAssignableFrom(d)) {\n            return type1;\n        }\n        if (d.isAssignableFrom(c)) {\n            return type2;\n        }\n        if (c.isInterface() || d.isInterface()) {\n            return \"java/lang/Object\";\n        } else {\n            do {\n                c = c.getSuperclass();\n            } while (!c.isAssignableFrom(d));\n            return c.getName().replace('.', '/');\n        }\n    }\n\n    /**\n     * Returns the constant pool's hash table item which is equal to the given\n     * item.\n     *\n     * @param key a constant pool item.\n     * @return the constant pool's hash table item which is equal to the given\n     *         item, or <tt>null</tt> if there is no such item.\n     */\n    private Item get(final Item key) {\n        Item i = items[key.hashCode % items.length];\n        while (i != null && (i.type != key.type || !key.isEqualTo(i))) {\n            i = i.next;\n        }\n        return i;\n    }\n\n    /**\n     * Puts the given item in the constant pool's hash table. The hash table\n     * <i>must</i> not already contains this item.\n     *\n     * @param i the item to be added to the constant pool's hash table.\n     */\n    private void put(final Item i) {\n        if (index > threshold) {\n            int ll = items.length;\n            int nl = ll * 2 + 1;\n            Item[] newItems = new Item[nl];\n            for (int l = ll - 1; l >= 0; --l) {\n                Item j = items[l];\n                while (j != null) {\n                    int index = j.hashCode % newItems.length;\n                    Item k = j.next;\n                    j.next = newItems[index];\n                    newItems[index] = j;\n                    j = k;\n                }\n            }\n            items = newItems;\n            threshold = (int) (nl * 0.75);\n        }\n        int index = i.hashCode % items.length;\n        i.next = items[index];\n        items[index] = i;\n    }\n\n    /**\n     * Puts one byte and two shorts into the constant pool.\n     *\n     * @param b a byte.\n     * @param s1 a short.\n     * @param s2 another short.\n     */\n    private void put122(final int b, final int s1, final int s2) {\n        pool.put12(b, s1).putShort(s2);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/ClassWriterTest2.java",
		"test_prompt": "// ClassWriterTest2.java\npackage org.objectweb.asm.jip;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassWriter}.\n* It contains ten unit test cases for the {@link ClassWriter#visitMethod(int, String, String, String, String[])} method.\n*/\nclass ClassWriterTest2 {"
	},
	{
		"original_code": "// ClassWriter.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\n/**\n * A {@link ClassVisitor} that generates classes in bytecode form. More\n * precisely this visitor generates a byte array conforming to the Java class\n * file format. It can be used alone, to generate a Java class \"from scratch\",\n * or with one or more {@link ClassReader ClassReader} and adapter class visitor\n * to generate a modified class from one or more existing Java classes.\n *\n * @author Eric Bruneton\n */\npublic class ClassWriter implements ClassVisitor {\n\n    /**\n     * Flag to automatically compute the maximum stack size and the maximum\n     * number of local variables of methods. If this flag is set, then the\n     * arguments of the {@link MethodVisitor#visitMaxs visitMaxs} method of the\n     * {@link MethodVisitor} returned by the {@link #visitMethod visitMethod}\n     * method will be ignored, and computed automatically from the signature and\n     * the bytecode of each method.\n     *\n     * @see #ClassWriter(int)\n     */\n    public static final int COMPUTE_MAXS = 1;\n\n    /**\n     * Flag to automatically compute the stack map frames of methods from\n     * scratch. If this flag is set, then the calls to the\n     * {@link MethodVisitor#visitFrame} method are ignored, and the stack map\n     * frames are recomputed from the methods bytecode. The arguments of the\n     * {@link MethodVisitor#visitMaxs visitMaxs} method are also ignored and\n     * recomputed from the bytecode. In other words, computeFrames implies\n     * computeMaxs.\n     *\n     * @see #ClassWriter(int)\n     */\n    public static final int COMPUTE_FRAMES = 2;\n\n    /**\n     * The type of instructions without any argument.\n     */\n    static final int NOARG_INSN = 0;\n\n    /**\n     * The type of instructions with an signed byte argument.\n     */\n    static final int SBYTE_INSN = 1;\n\n    /**\n     * The type of instructions with an signed short argument.\n     */\n    static final int SHORT_INSN = 2;\n\n    /**\n     * The type of instructions with a local variable index argument.\n     */\n    static final int VAR_INSN = 3;\n\n    /**\n     * The type of instructions with an implicit local variable index argument.\n     */\n    static final int IMPLVAR_INSN = 4;\n\n    /**\n     * The type of instructions with a type descriptor argument.\n     */\n    static final int TYPE_INSN = 5;\n\n    /**\n     * The type of field and method invocations instructions.\n     */\n    static final int FIELDORMETH_INSN = 6;\n\n    /**\n     * The type of the INVOKEINTERFACE/INVOKEDYNAMIC instruction.\n     */\n    static final int ITFDYNMETH_INSN = 7;\n\n    /**\n     * The type of instructions with a 2 bytes bytecode offset label.\n     */\n    static final int LABEL_INSN = 8;\n\n    /**\n     * The type of instructions with a 4 bytes bytecode offset label.\n     */\n    static final int LABELW_INSN = 9;\n\n    /**\n     * The type of the LDC instruction.\n     */\n    static final int LDC_INSN = 10;\n\n    /**\n     * The type of the LDC_W and LDC2_W instructions.\n     */\n    static final int LDCW_INSN = 11;\n\n    /**\n     * The type of the IINC instruction.\n     */\n    static final int IINC_INSN = 12;\n\n    /**\n     * The type of the TABLESWITCH instruction.\n     */\n    static final int TABL_INSN = 13;\n\n    /**\n     * The type of the LOOKUPSWITCH instruction.\n     */\n    static final int LOOK_INSN = 14;\n\n    /**\n     * The type of the MULTIANEWARRAY instruction.\n     */\n    static final int MANA_INSN = 15;\n\n    /**\n     * The type of the WIDE instruction.\n     */\n    static final int WIDE_INSN = 16;\n\n    /**\n     * The instruction types of all JVM opcodes.\n     */\n    static final byte[] TYPE;\n\n    /**\n     * The type of CONSTANT_Class constant pool items.\n     */\n    static final int CLASS = 7;\n\n    /**\n     * The type of CONSTANT_Fieldref constant pool items.\n     */\n    static final int FIELD = 9;\n\n    /**\n     * The type of CONSTANT_Methodref constant pool items.\n     */\n    static final int METH = 10;\n\n    /**\n     * The type of CONSTANT_InterfaceMethodref constant pool items.\n     */\n    static final int IMETH = 11;\n\n    /**\n     * The type of CONSTANT_String constant pool items.\n     */\n    static final int STR = 8;\n\n    /**\n     * The type of CONSTANT_Integer constant pool items.\n     */\n    static final int INT = 3;\n\n    /**\n     * The type of CONSTANT_Float constant pool items.\n     */\n    static final int FLOAT = 4;\n\n    /**\n     * The type of CONSTANT_Long constant pool items.\n     */\n    static final int LONG = 5;\n\n    /**\n     * The type of CONSTANT_Double constant pool items.\n     */\n    static final int DOUBLE = 6;\n\n    /**\n     * The type of CONSTANT_NameAndType constant pool items.\n     */\n    static final int NAME_TYPE = 12;\n\n    /**\n     * The type of CONSTANT_Utf8 constant pool items.\n     */\n    static final int UTF8 = 1;\n\n    /**\n     * Normal type Item stored in the ClassWriter {@link ClassWriter#typeTable},\n     * instead of the constant pool, in order to avoid clashes with normal\n     * constant pool items in the ClassWriter constant pool's hash table.\n     */\n    static final int TYPE_NORMAL = 13;\n\n    /**\n     * Uninitialized type Item stored in the ClassWriter\n     * {@link ClassWriter#typeTable}, instead of the constant pool, in order to\n     * avoid clashes with normal constant pool items in the ClassWriter constant\n     * pool's hash table.\n     */\n    static final int TYPE_UNINIT = 14;\n\n    /**\n     * Merged type Item stored in the ClassWriter {@link ClassWriter#typeTable},\n     * instead of the constant pool, in order to avoid clashes with normal\n     * constant pool items in the ClassWriter constant pool's hash table.\n     */\n    static final int TYPE_MERGED = 15;\n\n    /**\n     * The class reader from which this class writer was constructed, if any.\n     */\n    ClassReader cr;\n\n    /**\n     * Minor and major version numbers of the class to be generated.\n     */\n    int version;\n\n    /**\n     * Index of the next item to be added in the constant pool.\n     */\n    int index;\n\n    /**\n     * The constant pool of this class.\n     */\n    final ByteVector pool;\n\n    /**\n     * The constant pool's hash table data.\n     */\n    Item[] items;\n\n    /**\n     * The threshold of the constant pool's hash table.\n     */\n    int threshold;\n\n    /**\n     * A reusable key used to look for items in the {@link #items} hash table.\n     */\n    final Item key;\n\n    /**\n     * A reusable key used to look for items in the {@link #items} hash table.\n     */\n    final Item key2;\n\n    /**\n     * A reusable key used to look for items in the {@link #items} hash table.\n     */\n    final Item key3;\n\n    /**\n     * A type table used to temporarily store internal names that will not\n     * necessarily be stored in the constant pool. This type table is used by\n     * the control flow and data flow analysis algorithm used to compute stack\n     * map frames from scratch. This array associates to each index <tt>i</tt>\n     * the Item whose index is <tt>i</tt>. All Item objects stored in this\n     * array are also stored in the {@link #items} hash table. These two arrays\n     * allow to retrieve an Item from its index or, conversely, to get the index\n     * of an Item from its value. Each Item stores an internal name in its\n     * {@link Item#strVal1} field.\n     */\n    Item[] typeTable;\n\n    /**\n     * Number of elements in the {@link #typeTable} array.\n     */\n    private short typeCount;\n\n    /**\n     * The access flags of this class.\n     */\n    private int access;\n\n    /**\n     * The constant pool item that contains the internal name of this class.\n     */\n    private int name;\n\n    /**\n     * The internal name of this class.\n     */\n    String thisName;\n\n    /**\n     * The constant pool item that contains the signature of this class.\n     */\n    private int signature;\n\n    /**\n     * The constant pool item that contains the internal name of the super class\n     * of this class.\n     */\n    private int superName;\n\n    /**\n     * Number of interfaces implemented or extended by this class or interface.\n     */\n    private int interfaceCount;\n\n    /**\n     * The interfaces implemented or extended by this class or interface. More\n     * precisely, this array contains the indexes of the constant pool items\n     * that contain the internal names of these interfaces.\n     */\n    private int[] interfaces;\n\n    /**\n     * The index of the constant pool item that contains the name of the source\n     * file from which this class was compiled.\n     */\n    private int sourceFile;\n\n    /**\n     * The SourceDebug attribute of this class.\n     */\n    private ByteVector sourceDebug;\n\n    /**\n     * The constant pool item that contains the name of the enclosing class of\n     * this class.\n     */\n    private int enclosingMethodOwner;\n\n    /**\n     * The constant pool item that contains the name and descriptor of the\n     * enclosing method of this class.\n     */\n    private int enclosingMethod;\n\n    /**\n     * The runtime visible annotations of this class.\n     */\n    private AnnotationWriter anns;\n\n    /**\n     * The runtime invisible annotations of this class.\n     */\n    private AnnotationWriter ianns;\n\n    /**\n     * The non standard attributes of this class.\n     */\n    private Attribute attrs;\n\n    /**\n     * The number of entries in the InnerClasses attribute.\n     */\n    private int innerClassesCount;\n\n    /**\n     * The InnerClasses attribute.\n     */\n    private ByteVector innerClasses;\n\n    /**\n     * The fields of this class. These fields are stored in a linked list of\n     * {@link FieldWriter} objects, linked to each other by their\n     * {@link FieldWriter#next} field. This field stores the first element of\n     * this list.\n     */\n    FieldWriter firstField;\n\n    /**\n     * The fields of this class. These fields are stored in a linked list of\n     * {@link FieldWriter} objects, linked to each other by their\n     * {@link FieldWriter#next} field. This field stores the last element of\n     * this list.\n     */\n    FieldWriter lastField;\n\n    /**\n     * The methods of this class. These methods are stored in a linked list of\n     * {@link MethodWriter} objects, linked to each other by their\n     * {@link MethodWriter#next} field. This field stores the first element of\n     * this list.\n     */\n    MethodWriter firstMethod;\n\n    /**\n     * The methods of this class. These methods are stored in a linked list of\n     * {@link MethodWriter} objects, linked to each other by their\n     * {@link MethodWriter#next} field. This field stores the last element of\n     * this list.\n     */\n    MethodWriter lastMethod;\n\n    /**\n     * <tt>true</tt> if the maximum stack size and number of local variables\n     * must be automatically computed.\n     */\n    private final boolean computeMaxs;\n\n    /**\n     * <tt>true</tt> if the stack map frames must be recomputed from scratch.\n     */\n    private final boolean computeFrames;\n\n    /**\n     * <tt>true</tt> if the stack map tables of this class are invalid. The\n     * {@link MethodWriter#resizeInstructions} method cannot transform existing\n     * stack map tables, and so produces potentially invalid classes when it is\n     * executed. In this case the class is reread and rewritten with the\n     * {@link #COMPUTE_FRAMES} option (the resizeInstructions method can resize\n     * stack map tables when this option is used).\n     */\n    boolean invalidFrames;\n\n    // ------------------------------------------------------------------------\n    // Static initializer\n    // ------------------------------------------------------------------------\n    /**\n     * Computes the instruction types of JVM opcodes.\n     */\n    static {\n        int i;\n        byte[] b = new byte[220];\n        String s = \"AAAAAAAAAAAAAAAABCKLLDDDDDEEEEEEEEEEEEEEEEEEEEAAAAAAAADD\" + \"DDDEEEEEEEEEEEEEEEEEEEEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAAIIIIIIIIIIIIIIIIDNOAA\" + \"AAAAGGGGGGGHHFBFAAFFAAQPIIJJIIIIIIIIIIIIIIIIII\";\n        for (i = 0; i < b.length; ++i) {\n            b[i] = (byte) (s.charAt(i) - 'A');\n        }\n        TYPE = b;\n        // code to generate the above string\n        //\n        // // SBYTE_INSN instructions\n        // b[Constants.NEWARRAY] = SBYTE_INSN;\n        // b[Constants.BIPUSH] = SBYTE_INSN;\n        //\n        // // SHORT_INSN instructions\n        // b[Constants.SIPUSH] = SHORT_INSN;\n        //\n        // // (IMPL)VAR_INSN instructions\n        // b[Constants.RET] = VAR_INSN;\n        // for (i = Constants.ILOAD; i <= Constants.ALOAD; ++i) {\n        // b[i] = VAR_INSN;\n        // }\n        // for (i = Constants.ISTORE; i <= Constants.ASTORE; ++i) {\n        // b[i] = VAR_INSN;\n        // }\n        // for (i = 26; i <= 45; ++i) { // ILOAD_0 to ALOAD_3\n        // b[i] = IMPLVAR_INSN;\n        // }\n        // for (i = 59; i <= 78; ++i) { // ISTORE_0 to ASTORE_3\n        // b[i] = IMPLVAR_INSN;\n        // }\n        //\n        // // TYPE_INSN instructions\n        // b[Constants.NEW] = TYPE_INSN;\n        // b[Constants.ANEWARRAY] = TYPE_INSN;\n        // b[Constants.CHECKCAST] = TYPE_INSN;\n        // b[Constants.INSTANCEOF] = TYPE_INSN;\n        //\n        // // (Set)FIELDORMETH_INSN instructions\n        // for (i = Constants.GETSTATIC; i <= Constants.INVOKESTATIC; ++i) {\n        // b[i] = FIELDORMETH_INSN;\n        // }\n        // b[Constants.INVOKEINTERFACE] = ITFDYNMETH_INSN;\n        // b[Constants.INVOKEDYNAMIC] = ITFDYNMETH_INSN;\n        //\n        // // LABEL(W)_INSN instructions\n        // for (i = Constants.IFEQ; i <= Constants.JSR; ++i) {\n        // b[i] = LABEL_INSN;\n        // }\n        // b[Constants.IFNULL] = LABEL_INSN;\n        // b[Constants.IFNONNULL] = LABEL_INSN;\n        // b[200] = LABELW_INSN; // GOTO_W\n        // b[201] = LABELW_INSN; // JSR_W\n        // // temporary opcodes used internally by ASM - see Label and\n        // MethodWriter\n        // for (i = 202; i < 220; ++i) {\n        // b[i] = LABEL_INSN;\n        // }\n        //\n        // // LDC(_W) instructions\n        // b[Constants.LDC] = LDC_INSN;\n        // b[19] = LDCW_INSN; // LDC_W\n        // b[20] = LDCW_INSN; // LDC2_W\n        //\n        // // special instructions\n        // b[Constants.IINC] = IINC_INSN;\n        // b[Constants.TABLESWITCH] = TABL_INSN;\n        // b[Constants.LOOKUPSWITCH] = LOOK_INSN;\n        // b[Constants.MULTIANEWARRAY] = MANA_INSN;\n        // b[196] = WIDE_INSN; // WIDE\n        //\n        // for (i = 0; i < b.length; ++i) {\n        // System.err.print((char)('A' + b[i]));\n        // }\n        // System.err.println();\n    }\n\n    // ------------------------------------------------------------------------\n    // Constructor\n    // ------------------------------------------------------------------------\n    /**\n     * Constructs a new {@link ClassWriter} object.\n     *\n     * @param flags option flags that can be used to modify the default behavior\n     *        of this class. See {@link #COMPUTE_MAXS}, {@link #COMPUTE_FRAMES}.\n     */\n    public ClassWriter(final int flags) {\n        index = 1;\n        pool = new ByteVector();\n        items = new Item[256];\n        threshold = (int) (0.75d * items.length);\n        key = new Item();\n        key2 = new Item();\n        key3 = new Item();\n        this.computeMaxs = (flags & COMPUTE_MAXS) != 0;\n        this.computeFrames = (flags & COMPUTE_FRAMES) != 0;\n    }\n\n    /**\n     * Constructs a new {@link ClassWriter} object and enables optimizations for\n     * \"mostly add\" bytecode transformations. These optimizations are the\n     * following:\n     *\n     * <ul> <li>The constant pool from the original class is copied as is in\n     * the new class, which saves time. New constant pool entries will be added\n     * at the end if necessary, but unused constant pool entries <i>won't be\n     * removed</i>.</li> <li>Methods that are not transformed are copied as\n     * is in the new class, directly from the original class bytecode (i.e.\n     * without emitting visit events for all the method instructions), which\n     * saves a <i>lot</i> of time. Untransformed methods are detected by the\n     * fact that the {@link ClassReader} receives {@link MethodVisitor} objects\n     * that come from a {@link ClassWriter} (and not from a custom\n     * {@link ClassAdapter} or any other {@link ClassVisitor} instance).</li>\n     * </ul>\n     *\n     * @param classReader the {@link ClassReader} used to read the original\n     *        class. It will be used to copy the entire constant pool from the\n     *        original class and also to copy other fragments of original\n     *        bytecode where applicable.\n     * @param flags option flags that can be used to modify the default behavior\n     *        of this class. See {@link #COMPUTE_MAXS}, {@link #COMPUTE_FRAMES}.\n     */\n    public ClassWriter(final ClassReader classReader, final int flags) {\n        this(flags);\n        classReader.copyPool(this);\n        this.cr = classReader;\n    }\n\n    // ------------------------------------------------------------------------\n    // Implementation of the ClassVisitor interface\n    // ------------------------------------------------------------------------\n    public void visit(final int version, final int access, final String name, final String signature, final String superName, final String[] interfaces) {\n        this.version = version;\n        this.access = access;\n        this.name = newClass(name);\n        thisName = name;\n        if (ClassReader.SIGNATURES && signature != null) {\n            this.signature = newUTF8(signature);\n        }\n        this.superName = superName == null ? 0 : newClass(superName);\n        if (interfaces != null && interfaces.length > 0) {\n            interfaceCount = interfaces.length;\n            this.interfaces = new int[interfaceCount];\n            for (int i = 0; i < interfaceCount; ++i) {\n                this.interfaces[i] = newClass(interfaces[i]);\n            }\n        }\n    }\n\n    public void visitSource(final String file, final String debug) {\n        if (file != null) {\n            sourceFile = newUTF8(file);\n        }\n        if (debug != null) {\n            sourceDebug = new ByteVector().putUTF8(debug);\n        }\n    }\n\n    public void visitOuterClass(final String owner, final String name, final String desc) {\n        enclosingMethodOwner = newClass(owner);\n        if (name != null && desc != null) {\n            enclosingMethod = newNameType(name, desc);\n        }\n    }\n\n    public AnnotationVisitor visitAnnotation(final String desc, final boolean visible) {\n        if (!ClassReader.ANNOTATIONS) {\n            return null;\n        }\n        ByteVector bv = new ByteVector();\n        // write type, and reserve space for values count\n        bv.putShort(newUTF8(desc)).putShort(0);\n        AnnotationWriter aw = new AnnotationWriter(this, true, bv, bv, 2);\n        if (visible) {\n            aw.next = anns;\n            anns = aw;\n        } else {\n            aw.next = ianns;\n            ianns = aw;\n        }\n        return aw;\n    }\n\n    public void visitAttribute(final Attribute attr) {\n        attr.next = attrs;\n        attrs = attr;\n    }\n\n    public void visitInnerClass(final String name, final String outerName, final String innerName, final int access) {\n        if (innerClasses == null) {\n            innerClasses = new ByteVector();\n        }\n        ++innerClassesCount;\n        innerClasses.putShort(name == null ? 0 : newClass(name));\n        innerClasses.putShort(outerName == null ? 0 : newClass(outerName));\n        innerClasses.putShort(innerName == null ? 0 : newUTF8(innerName));\n        innerClasses.putShort(access);\n    }\n\n    public FieldVisitor visitField(final int access, final String name, final String desc, final String signature, final Object value) {\n        return new FieldWriter(this, access, name, desc, signature, value);\n    }\n\n    public MethodVisitor visitMethod(final int access, final String name, final String desc, final String signature, final String[] exceptions) {\n        return new MethodWriter(this, access, name, desc, signature, exceptions, computeMaxs, computeFrames);\n    }\n\n    public void visitEnd() {\n    }\n\n    // ------------------------------------------------------------------------\n    // Other public methods\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the bytecode of the class that was build with this class writer.\n     *\n     * @return the bytecode of the class that was build with this class writer.\n     */\n    public byte[] toByteArray() {\n        // computes the real size of the bytecode of this class\n        int size = 24 + 2 * interfaceCount;\n        int nbFields = 0;\n        FieldWriter fb = firstField;\n        while (fb != null) {\n            ++nbFields;\n            size += fb.getSize();\n            fb = fb.next;\n        }\n        int nbMethods = 0;\n        MethodWriter mb = firstMethod;\n        while (mb != null) {\n            ++nbMethods;\n            size += mb.getSize();\n            mb = mb.next;\n        }\n        int attributeCount = 0;\n        if (ClassReader.SIGNATURES && signature != 0) {\n            ++attributeCount;\n            size += 8;\n            newUTF8(\"Signature\");\n        }\n        if (sourceFile != 0) {\n            ++attributeCount;\n            size += 8;\n            newUTF8(\"SourceFile\");\n        }\n        if (sourceDebug != null) {\n            ++attributeCount;\n            size += sourceDebug.length + 4;\n            newUTF8(\"SourceDebugExtension\");\n        }\n        if (enclosingMethodOwner != 0) {\n            ++attributeCount;\n            size += 10;\n            newUTF8(\"EnclosingMethod\");\n        }\n        if ((access & Opcodes.ACC_DEPRECATED) != 0) {\n            ++attributeCount;\n            size += 6;\n            newUTF8(\"Deprecated\");\n        }\n        if ((access & Opcodes.ACC_SYNTHETIC) != 0 && (version & 0xffff) < Opcodes.V1_5) {\n            ++attributeCount;\n            size += 6;\n            newUTF8(\"Synthetic\");\n        }\n        if (innerClasses != null) {\n            ++attributeCount;\n            size += 8 + innerClasses.length;\n            newUTF8(\"InnerClasses\");\n        }\n        if (ClassReader.ANNOTATIONS && anns != null) {\n            ++attributeCount;\n            size += 8 + anns.getSize();\n            newUTF8(\"RuntimeVisibleAnnotations\");\n        }\n        if (ClassReader.ANNOTATIONS && ianns != null) {\n            ++attributeCount;\n            size += 8 + ianns.getSize();\n            newUTF8(\"RuntimeInvisibleAnnotations\");\n        }\n        if (attrs != null) {\n            attributeCount += attrs.getCount();\n            size += attrs.getSize(this, null, 0, -1, -1);\n        }\n        size += pool.length;\n        // allocates a byte vector of this size, in order to avoid unnecessary\n        // arraycopy operations in the ByteVector.enlarge() method\n        ByteVector out = new ByteVector(size);\n        out.putInt(0xCAFEBABE).putInt(version);\n        out.putShort(index).putByteArray(pool.data, 0, pool.length);\n        out.putShort(access).putShort(name).putShort(superName);\n        out.putShort(interfaceCount);\n        for (int i = 0; i < interfaceCount; ++i) {\n            out.putShort(interfaces[i]);\n        }\n        out.putShort(nbFields);\n        fb = firstField;\n        while (fb != null) {\n            fb.put(out);\n            fb = fb.next;\n        }\n        out.putShort(nbMethods);\n        mb = firstMethod;\n        while (mb != null) {\n            mb.put(out);\n            mb = mb.next;\n        }\n        out.putShort(attributeCount);\n        if (ClassReader.SIGNATURES && signature != 0) {\n            out.putShort(newUTF8(\"Signature\")).putInt(2).putShort(signature);\n        }\n        if (sourceFile != 0) {\n            out.putShort(newUTF8(\"SourceFile\")).putInt(2).putShort(sourceFile);\n        }\n        if (sourceDebug != null) {\n            int len = sourceDebug.length - 2;\n            out.putShort(newUTF8(\"SourceDebugExtension\")).putInt(len);\n            out.putByteArray(sourceDebug.data, 2, len);\n        }\n        if (enclosingMethodOwner != 0) {\n            out.putShort(newUTF8(\"EnclosingMethod\")).putInt(4);\n            out.putShort(enclosingMethodOwner).putShort(enclosingMethod);\n        }\n        if ((access & Opcodes.ACC_DEPRECATED) != 0) {\n            out.putShort(newUTF8(\"Deprecated\")).putInt(0);\n        }\n        if ((access & Opcodes.ACC_SYNTHETIC) != 0 && (version & 0xffff) < Opcodes.V1_5) {\n            out.putShort(newUTF8(\"Synthetic\")).putInt(0);\n        }\n        if (innerClasses != null) {\n            out.putShort(newUTF8(\"InnerClasses\"));\n            out.putInt(innerClasses.length + 2).putShort(innerClassesCount);\n            out.putByteArray(innerClasses.data, 0, innerClasses.length);\n        }\n        if (ClassReader.ANNOTATIONS && anns != null) {\n            out.putShort(newUTF8(\"RuntimeVisibleAnnotations\"));\n            anns.put(out);\n        }\n        if (ClassReader.ANNOTATIONS && ianns != null) {\n            out.putShort(newUTF8(\"RuntimeInvisibleAnnotations\"));\n            ianns.put(out);\n        }\n        if (attrs != null) {\n            attrs.put(this, null, 0, -1, -1, out);\n        }\n        if (invalidFrames) {\n            ClassWriter cw = new ClassWriter(COMPUTE_FRAMES);\n            new ClassReader(out.data).accept(cw, ClassReader.SKIP_FRAMES);\n            return cw.toByteArray();\n        }\n        return out.data;\n    }\n\n    // ------------------------------------------------------------------------\n    // Utility methods: constant pool management\n    // ------------------------------------------------------------------------\n    /**\n     * Adds a number or string constant to the constant pool of the class being\n     * build. Does nothing if the constant pool already contains a similar item.\n     *\n     * @param cst the value of the constant to be added to the constant pool.\n     *        This parameter must be an {@link Integer}, a {@link Float}, a\n     *        {@link Long}, a {@link Double}, a {@link String} or a\n     *        {@link Type}.\n     * @return a new or already existing constant item with the given value.\n     */\n    Item newConstItem(final Object cst) {\n        if (cst instanceof Integer) {\n            int val = ((Integer) cst).intValue();\n            return newInteger(val);\n        } else if (cst instanceof Byte) {\n            int val = ((Byte) cst).intValue();\n            return newInteger(val);\n        } else if (cst instanceof Character) {\n            int val = ((Character) cst).charValue();\n            return newInteger(val);\n        } else if (cst instanceof Short) {\n            int val = ((Short) cst).intValue();\n            return newInteger(val);\n        } else if (cst instanceof Boolean) {\n            int val = ((Boolean) cst).booleanValue() ? 1 : 0;\n            return newInteger(val);\n        } else if (cst instanceof Float) {\n            float val = ((Float) cst).floatValue();\n            return newFloat(val);\n        } else if (cst instanceof Long) {\n            long val = ((Long) cst).longValue();\n            return newLong(val);\n        } else if (cst instanceof Double) {\n            double val = ((Double) cst).doubleValue();\n            return newDouble(val);\n        } else if (cst instanceof String) {\n            return newString((String) cst);\n        } else if (cst instanceof Type) {\n            Type t = (Type) cst;\n            return newClassItem(t.getSort() == Type.OBJECT ? t.getInternalName() : t.getDescriptor());\n        } else {\n            throw new IllegalArgumentException(\"value \" + cst);\n        }\n    }\n\n    /**\n     * Adds a number or string constant to the constant pool of the class being\n     * build. Does nothing if the constant pool already contains a similar item.\n     * <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param cst the value of the constant to be added to the constant pool.\n     *        This parameter must be an {@link Integer}, a {@link Float}, a\n     *        {@link Long}, a {@link Double} or a {@link String}.\n     * @return the index of a new or already existing constant item with the\n     *         given value.\n     */\n    public int newConst(final Object cst) {\n        return newConstItem(cst).index;\n    }\n\n    /**\n     * Adds an UTF8 string to the constant pool of the class being build. Does\n     * nothing if the constant pool already contains a similar item. <i>This\n     * method is intended for {@link Attribute} sub classes, and is normally not\n     * needed by class generators or adapters.</i>\n     *\n     * @param value the String value.\n     * @return the index of a new or already existing UTF8 item.\n     */\n    public int newUTF8(final String value) {\n        key.set(UTF8, value, null, null);\n        Item result = get(key);\n        if (result == null) {\n            pool.putByte(UTF8).putUTF8(value);\n            result = new Item(index++, key);\n            put(result);\n        }\n        return result.index;\n    }\n\n    /**\n     * Adds a class reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     * <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param value the internal name of the class.\n     * @return a new or already existing class reference item.\n     */\n    Item newClassItem(final String value) {\n        key2.set(CLASS, value, null, null);\n        Item result = get(key2);\n        if (result == null) {\n            pool.put12(CLASS, newUTF8(value));\n            result = new Item(index++, key2);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a class reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     * <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param value the internal name of the class.\n     * @return the index of a new or already existing class reference item.\n     */\n    public int newClass(final String value) {\n        return newClassItem(value).index;\n    }\n\n    /**\n     * Adds a field reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     *\n     * @param owner the internal name of the field's owner class.\n     * @param name the field's name.\n     * @param desc the field's descriptor.\n     * @return a new or already existing field reference item.\n     */\n    Item newFieldItem(final String owner, final String name, final String desc) {\n        key3.set(FIELD, owner, name, desc);\n        Item result = get(key3);\n        if (result == null) {\n            put122(FIELD, newClass(owner), newNameType(name, desc));\n            result = new Item(index++, key3);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a field reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     * <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param owner the internal name of the field's owner class.\n     * @param name the field's name.\n     * @param desc the field's descriptor.\n     * @return the index of a new or already existing field reference item.\n     */\n    public int newField(final String owner, final String name, final String desc) {\n        return newFieldItem(owner, name, desc).index;\n    }\n\n    /**\n     * Adds a method reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     *\n     * @param owner the internal name of the method's owner class.\n     * @param name the method's name.\n     * @param desc the method's descriptor.\n     * @param itf <tt>true</tt> if <tt>owner</tt> is an interface.\n     * @return a new or already existing method reference item.\n     */\n    Item newMethodItem(final String owner, final String name, final String desc, final boolean itf) {\n        int type = itf ? IMETH : METH;\n        key3.set(type, owner, name, desc);\n        Item result = get(key3);\n        if (result == null) {\n            put122(type, newClass(owner), newNameType(name, desc));\n            result = new Item(index++, key3);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a method reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     * <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param owner the internal name of the method's owner class.\n     * @param name the method's name.\n     * @param desc the method's descriptor.\n     * @param itf <tt>true</tt> if <tt>owner</tt> is an interface.\n     * @return the index of a new or already existing method reference item.\n     */\n    public int newMethod(final String owner, final String name, final String desc, final boolean itf) {\n        return newMethodItem(owner, name, desc, itf).index;\n    }\n\n    /**\n     * Adds an integer to the constant pool of the class being build. Does\n     * nothing if the constant pool already contains a similar item.\n     *\n     * @param value the int value.\n     * @return a new or already existing int item.\n     */\n    Item newInteger(final int value) {\n        key.set(value);\n        Item result = get(key);\n        if (result == null) {\n            pool.putByte(INT).putInt(value);\n            result = new Item(index++, key);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a float to the constant pool of the class being build. Does nothing\n     * if the constant pool already contains a similar item.\n     *\n     * @param value the float value.\n     * @return a new or already existing float item.\n     */\n    Item newFloat(final float value) {\n        key.set(value);\n        Item result = get(key);\n        if (result == null) {\n            pool.putByte(FLOAT).putInt(key.intVal);\n            result = new Item(index++, key);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a long to the constant pool of the class being build. Does nothing\n     * if the constant pool already contains a similar item.\n     *\n     * @param value the long value.\n     * @return a new or already existing long item.\n     */\n    Item newLong(final long value) {\n        key.set(value);\n        Item result = get(key);\n        if (result == null) {\n            pool.putByte(LONG).putLong(value);\n            result = new Item(index, key);\n            put(result);\n            index += 2;\n        }\n        return result;\n    }\n\n    /**\n     * Adds a double to the constant pool of the class being build. Does nothing\n     * if the constant pool already contains a similar item.\n     *\n     * @param value the double value.\n     * @return a new or already existing double item.\n     */\n    Item newDouble(final double value) {\n        key.set(value);\n        Item result = get(key);\n        if (result == null) {\n            pool.putByte(DOUBLE).putLong(key.longVal);\n            result = new Item(index, key);\n            put(result);\n            index += 2;\n        }\n        return result;\n    }\n\n    /**\n     * Adds a string to the constant pool of the class being build. Does nothing\n     * if the constant pool already contains a similar item.\n     *\n     * @param value the String value.\n     * @return a new or already existing string item.\n     */\n    private Item newString(final String value) {\n        key2.set(STR, value, null, null);\n        Item result = get(key2);\n        if (result == null) {\n            pool.put12(STR, newUTF8(value));\n            result = new Item(index++, key2);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a name and type to the constant pool of the class being build. Does\n     * nothing if the constant pool already contains a similar item. <i>This\n     * method is intended for {@link Attribute} sub classes, and is normally not\n     * needed by class generators or adapters.</i>\n     *\n     * @param name a name.\n     * @param desc a type descriptor.\n     * @return the index of a new or already existing name and type item.\n     */\n    public int newNameType(final String name, final String desc) {\n        return newNameTypeItem(name, desc).index;\n    }\n\n    /**\n     * Adds a name and type to the constant pool of the class being build. Does\n     * nothing if the constant pool already contains a similar item.\n     *\n     * @param name a name.\n     * @param desc a type descriptor.\n     * @return a new or already existing name and type item.\n     */\n    Item newNameTypeItem(final String name, final String desc) {\n        key2.set(NAME_TYPE, name, desc, null);\n        Item result = get(key2);\n        if (result == null) {\n            put122(NAME_TYPE, newUTF8(name), newUTF8(desc));\n            result = new Item(index++, key2);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds the given internal name to {@link #typeTable} and returns its index.\n     * Does nothing if the type table already contains this internal name.\n     *\n     * @param type the internal name to be added to the type table.\n     * @return the index of this internal name in the type table.\n     */\n    int addType(final String type) {\n        key.set(TYPE_NORMAL, type, null, null);\n        Item result = get(key);\n        if (result == null) {\n            result = addType(key);\n        }\n        return result.index;\n    }\n\n    /**\n     * Adds the given \"uninitialized\" type to {@link #typeTable} and returns its\n     * index. This method is used for UNINITIALIZED types, made of an internal\n     * name and a bytecode offset.\n     *\n     * @param type the internal name to be added to the type table.\n     * @param offset the bytecode offset of the NEW instruction that created\n     *        this UNINITIALIZED type value.\n     * @return the index of this internal name in the type table.\n     */\n    int addUninitializedType(final String type, final int offset) {\n        key.type = TYPE_UNINIT;\n        key.intVal = offset;\n        key.strVal1 = type;\n        key.hashCode = 0x7FFFFFFF & (TYPE_UNINIT + type.hashCode() + offset);\n        Item result = get(key);\n        if (result == null) {\n            result = addType(key);\n        }\n        return result.index;\n    }\n\n    /**\n     * Adds the given Item to {@link #typeTable}.\n     *\n     * @param item the value to be added to the type table.\n     * @return the added Item, which a new Item instance with the same value as\n     *         the given Item.\n     */\n    private Item addType(final Item item) {\n        ++typeCount;\n        Item result = new Item(typeCount, key);\n        put(result);\n        if (typeTable == null) {\n            typeTable = new Item[16];\n        }\n        if (typeCount == typeTable.length) {\n            Item[] newTable = new Item[2 * typeTable.length];\n            System.arraycopy(typeTable, 0, newTable, 0, typeTable.length);\n            typeTable = newTable;\n        }\n        typeTable[typeCount] = result;\n        return result;\n    }\n\n    /**\n     * Returns the index of the common super type of the two given types. This\n     * method calls {@link #getCommonSuperClass} and caches the result in the\n     * {@link #items} hash table to speedup future calls with the same\n     * parameters.\n     *\n     * @param type1 index of an internal name in {@link #typeTable}.\n     * @param type2 index of an internal name in {@link #typeTable}.\n     * @return the index of the common super type of the two given types.\n     */\n    int getMergedType(final int type1, final int type2) {\n        key2.type = TYPE_MERGED;\n        key2.longVal = type1 | (((long) type2) << 32);\n        key2.hashCode = 0x7FFFFFFF & (TYPE_MERGED + type1 + type2);\n        Item result = get(key2);\n        if (result == null) {\n            String t = typeTable[type1].strVal1;\n            String u = typeTable[type2].strVal1;\n            key2.intVal = addType(getCommonSuperClass(t, u));\n            result = new Item((short) 0, key2);\n            put(result);\n        }\n        return result.intVal;\n    }\n\n    /**\n     * Returns the common super type of the two given types. The default\n     * implementation of this method <i>loads<i> the two given classes and uses\n     * the java.lang.Class methods to find the common super class. It can be\n     * overridden to compute this common super type in other ways, in particular\n     * without actually loading any class, or to take into account the class\n     * that is currently being generated by this ClassWriter, which can of\n     * course not be loaded since it is under construction.\n     *\n     * @param type1 the internal name of a class.\n     * @param type2 the internal name of another class.\n     * @return the internal name of the common super class of the two given\n     *         classes.\n     */\n    protected String getCommonSuperClass(final String type1, final String type2) {\n        Class c, d;\n        try {\n            c = Class.forName(type1.replace('/', '.'));\n            d = Class.forName(type2.replace('/', '.'));\n        } catch (Exception e) {\n            throw new RuntimeException(e.toString());\n        }\n        if (c.isAssignableFrom(d)) {\n            return type1;\n        }\n        if (d.isAssignableFrom(c)) {\n            return type2;\n        }\n        if (c.isInterface() || d.isInterface()) {\n            return \"java/lang/Object\";\n        } else {\n            do {\n                c = c.getSuperclass();\n            } while (!c.isAssignableFrom(d));\n            return c.getName().replace('.', '/');\n        }\n    }\n\n    /**\n     * Returns the constant pool's hash table item which is equal to the given\n     * item.\n     *\n     * @param key a constant pool item.\n     * @return the constant pool's hash table item which is equal to the given\n     *         item, or <tt>null</tt> if there is no such item.\n     */\n    private Item get(final Item key) {\n        Item i = items[key.hashCode % items.length];\n        while (i != null && (i.type != key.type || !key.isEqualTo(i))) {\n            i = i.next;\n        }\n        return i;\n    }\n\n    /**\n     * Puts the given item in the constant pool's hash table. The hash table\n     * <i>must</i> not already contains this item.\n     *\n     * @param i the item to be added to the constant pool's hash table.\n     */\n    private void put(final Item i) {\n        if (index > threshold) {\n            int ll = items.length;\n            int nl = ll * 2 + 1;\n            Item[] newItems = new Item[nl];\n            for (int l = ll - 1; l >= 0; --l) {\n                Item j = items[l];\n                while (j != null) {\n                    int index = j.hashCode % newItems.length;\n                    Item k = j.next;\n                    j.next = newItems[index];\n                    newItems[index] = j;\n                    j = k;\n                }\n            }\n            items = newItems;\n            threshold = (int) (nl * 0.75);\n        }\n        int index = i.hashCode % items.length;\n        i.next = items[index];\n        items[index] = i;\n    }\n\n    /**\n     * Puts one byte and two shorts into the constant pool.\n     *\n     * @param b a byte.\n     * @param s1 a short.\n     * @param s2 another short.\n     */\n    private void put122(final int b, final int s1, final int s2) {\n        pool.put12(b, s1).putShort(s2);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/ClassWriterTest3.java",
		"test_prompt": "// ClassWriterTest3.java\npackage org.objectweb.asm.jip;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassWriter}.\n* It contains ten unit test cases for the {@link ClassWriter#toByteArray()} method.\n*/\nclass ClassWriterTest3 {"
	},
	{
		"original_code": "// ClassWriter.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\n/**\n * A {@link ClassVisitor} that generates classes in bytecode form. More\n * precisely this visitor generates a byte array conforming to the Java class\n * file format. It can be used alone, to generate a Java class \"from scratch\",\n * or with one or more {@link ClassReader ClassReader} and adapter class visitor\n * to generate a modified class from one or more existing Java classes.\n *\n * @author Eric Bruneton\n */\npublic class ClassWriter implements ClassVisitor {\n\n    /**\n     * Flag to automatically compute the maximum stack size and the maximum\n     * number of local variables of methods. If this flag is set, then the\n     * arguments of the {@link MethodVisitor#visitMaxs visitMaxs} method of the\n     * {@link MethodVisitor} returned by the {@link #visitMethod visitMethod}\n     * method will be ignored, and computed automatically from the signature and\n     * the bytecode of each method.\n     *\n     * @see #ClassWriter(int)\n     */\n    public static final int COMPUTE_MAXS = 1;\n\n    /**\n     * Flag to automatically compute the stack map frames of methods from\n     * scratch. If this flag is set, then the calls to the\n     * {@link MethodVisitor#visitFrame} method are ignored, and the stack map\n     * frames are recomputed from the methods bytecode. The arguments of the\n     * {@link MethodVisitor#visitMaxs visitMaxs} method are also ignored and\n     * recomputed from the bytecode. In other words, computeFrames implies\n     * computeMaxs.\n     *\n     * @see #ClassWriter(int)\n     */\n    public static final int COMPUTE_FRAMES = 2;\n\n    /**\n     * The type of instructions without any argument.\n     */\n    static final int NOARG_INSN = 0;\n\n    /**\n     * The type of instructions with an signed byte argument.\n     */\n    static final int SBYTE_INSN = 1;\n\n    /**\n     * The type of instructions with an signed short argument.\n     */\n    static final int SHORT_INSN = 2;\n\n    /**\n     * The type of instructions with a local variable index argument.\n     */\n    static final int VAR_INSN = 3;\n\n    /**\n     * The type of instructions with an implicit local variable index argument.\n     */\n    static final int IMPLVAR_INSN = 4;\n\n    /**\n     * The type of instructions with a type descriptor argument.\n     */\n    static final int TYPE_INSN = 5;\n\n    /**\n     * The type of field and method invocations instructions.\n     */\n    static final int FIELDORMETH_INSN = 6;\n\n    /**\n     * The type of the INVOKEINTERFACE/INVOKEDYNAMIC instruction.\n     */\n    static final int ITFDYNMETH_INSN = 7;\n\n    /**\n     * The type of instructions with a 2 bytes bytecode offset label.\n     */\n    static final int LABEL_INSN = 8;\n\n    /**\n     * The type of instructions with a 4 bytes bytecode offset label.\n     */\n    static final int LABELW_INSN = 9;\n\n    /**\n     * The type of the LDC instruction.\n     */\n    static final int LDC_INSN = 10;\n\n    /**\n     * The type of the LDC_W and LDC2_W instructions.\n     */\n    static final int LDCW_INSN = 11;\n\n    /**\n     * The type of the IINC instruction.\n     */\n    static final int IINC_INSN = 12;\n\n    /**\n     * The type of the TABLESWITCH instruction.\n     */\n    static final int TABL_INSN = 13;\n\n    /**\n     * The type of the LOOKUPSWITCH instruction.\n     */\n    static final int LOOK_INSN = 14;\n\n    /**\n     * The type of the MULTIANEWARRAY instruction.\n     */\n    static final int MANA_INSN = 15;\n\n    /**\n     * The type of the WIDE instruction.\n     */\n    static final int WIDE_INSN = 16;\n\n    /**\n     * The instruction types of all JVM opcodes.\n     */\n    static final byte[] TYPE;\n\n    /**\n     * The type of CONSTANT_Class constant pool items.\n     */\n    static final int CLASS = 7;\n\n    /**\n     * The type of CONSTANT_Fieldref constant pool items.\n     */\n    static final int FIELD = 9;\n\n    /**\n     * The type of CONSTANT_Methodref constant pool items.\n     */\n    static final int METH = 10;\n\n    /**\n     * The type of CONSTANT_InterfaceMethodref constant pool items.\n     */\n    static final int IMETH = 11;\n\n    /**\n     * The type of CONSTANT_String constant pool items.\n     */\n    static final int STR = 8;\n\n    /**\n     * The type of CONSTANT_Integer constant pool items.\n     */\n    static final int INT = 3;\n\n    /**\n     * The type of CONSTANT_Float constant pool items.\n     */\n    static final int FLOAT = 4;\n\n    /**\n     * The type of CONSTANT_Long constant pool items.\n     */\n    static final int LONG = 5;\n\n    /**\n     * The type of CONSTANT_Double constant pool items.\n     */\n    static final int DOUBLE = 6;\n\n    /**\n     * The type of CONSTANT_NameAndType constant pool items.\n     */\n    static final int NAME_TYPE = 12;\n\n    /**\n     * The type of CONSTANT_Utf8 constant pool items.\n     */\n    static final int UTF8 = 1;\n\n    /**\n     * Normal type Item stored in the ClassWriter {@link ClassWriter#typeTable},\n     * instead of the constant pool, in order to avoid clashes with normal\n     * constant pool items in the ClassWriter constant pool's hash table.\n     */\n    static final int TYPE_NORMAL = 13;\n\n    /**\n     * Uninitialized type Item stored in the ClassWriter\n     * {@link ClassWriter#typeTable}, instead of the constant pool, in order to\n     * avoid clashes with normal constant pool items in the ClassWriter constant\n     * pool's hash table.\n     */\n    static final int TYPE_UNINIT = 14;\n\n    /**\n     * Merged type Item stored in the ClassWriter {@link ClassWriter#typeTable},\n     * instead of the constant pool, in order to avoid clashes with normal\n     * constant pool items in the ClassWriter constant pool's hash table.\n     */\n    static final int TYPE_MERGED = 15;\n\n    /**\n     * The class reader from which this class writer was constructed, if any.\n     */\n    ClassReader cr;\n\n    /**\n     * Minor and major version numbers of the class to be generated.\n     */\n    int version;\n\n    /**\n     * Index of the next item to be added in the constant pool.\n     */\n    int index;\n\n    /**\n     * The constant pool of this class.\n     */\n    final ByteVector pool;\n\n    /**\n     * The constant pool's hash table data.\n     */\n    Item[] items;\n\n    /**\n     * The threshold of the constant pool's hash table.\n     */\n    int threshold;\n\n    /**\n     * A reusable key used to look for items in the {@link #items} hash table.\n     */\n    final Item key;\n\n    /**\n     * A reusable key used to look for items in the {@link #items} hash table.\n     */\n    final Item key2;\n\n    /**\n     * A reusable key used to look for items in the {@link #items} hash table.\n     */\n    final Item key3;\n\n    /**\n     * A type table used to temporarily store internal names that will not\n     * necessarily be stored in the constant pool. This type table is used by\n     * the control flow and data flow analysis algorithm used to compute stack\n     * map frames from scratch. This array associates to each index <tt>i</tt>\n     * the Item whose index is <tt>i</tt>. All Item objects stored in this\n     * array are also stored in the {@link #items} hash table. These two arrays\n     * allow to retrieve an Item from its index or, conversely, to get the index\n     * of an Item from its value. Each Item stores an internal name in its\n     * {@link Item#strVal1} field.\n     */\n    Item[] typeTable;\n\n    /**\n     * Number of elements in the {@link #typeTable} array.\n     */\n    private short typeCount;\n\n    /**\n     * The access flags of this class.\n     */\n    private int access;\n\n    /**\n     * The constant pool item that contains the internal name of this class.\n     */\n    private int name;\n\n    /**\n     * The internal name of this class.\n     */\n    String thisName;\n\n    /**\n     * The constant pool item that contains the signature of this class.\n     */\n    private int signature;\n\n    /**\n     * The constant pool item that contains the internal name of the super class\n     * of this class.\n     */\n    private int superName;\n\n    /**\n     * Number of interfaces implemented or extended by this class or interface.\n     */\n    private int interfaceCount;\n\n    /**\n     * The interfaces implemented or extended by this class or interface. More\n     * precisely, this array contains the indexes of the constant pool items\n     * that contain the internal names of these interfaces.\n     */\n    private int[] interfaces;\n\n    /**\n     * The index of the constant pool item that contains the name of the source\n     * file from which this class was compiled.\n     */\n    private int sourceFile;\n\n    /**\n     * The SourceDebug attribute of this class.\n     */\n    private ByteVector sourceDebug;\n\n    /**\n     * The constant pool item that contains the name of the enclosing class of\n     * this class.\n     */\n    private int enclosingMethodOwner;\n\n    /**\n     * The constant pool item that contains the name and descriptor of the\n     * enclosing method of this class.\n     */\n    private int enclosingMethod;\n\n    /**\n     * The runtime visible annotations of this class.\n     */\n    private AnnotationWriter anns;\n\n    /**\n     * The runtime invisible annotations of this class.\n     */\n    private AnnotationWriter ianns;\n\n    /**\n     * The non standard attributes of this class.\n     */\n    private Attribute attrs;\n\n    /**\n     * The number of entries in the InnerClasses attribute.\n     */\n    private int innerClassesCount;\n\n    /**\n     * The InnerClasses attribute.\n     */\n    private ByteVector innerClasses;\n\n    /**\n     * The fields of this class. These fields are stored in a linked list of\n     * {@link FieldWriter} objects, linked to each other by their\n     * {@link FieldWriter#next} field. This field stores the first element of\n     * this list.\n     */\n    FieldWriter firstField;\n\n    /**\n     * The fields of this class. These fields are stored in a linked list of\n     * {@link FieldWriter} objects, linked to each other by their\n     * {@link FieldWriter#next} field. This field stores the last element of\n     * this list.\n     */\n    FieldWriter lastField;\n\n    /**\n     * The methods of this class. These methods are stored in a linked list of\n     * {@link MethodWriter} objects, linked to each other by their\n     * {@link MethodWriter#next} field. This field stores the first element of\n     * this list.\n     */\n    MethodWriter firstMethod;\n\n    /**\n     * The methods of this class. These methods are stored in a linked list of\n     * {@link MethodWriter} objects, linked to each other by their\n     * {@link MethodWriter#next} field. This field stores the last element of\n     * this list.\n     */\n    MethodWriter lastMethod;\n\n    /**\n     * <tt>true</tt> if the maximum stack size and number of local variables\n     * must be automatically computed.\n     */\n    private final boolean computeMaxs;\n\n    /**\n     * <tt>true</tt> if the stack map frames must be recomputed from scratch.\n     */\n    private final boolean computeFrames;\n\n    /**\n     * <tt>true</tt> if the stack map tables of this class are invalid. The\n     * {@link MethodWriter#resizeInstructions} method cannot transform existing\n     * stack map tables, and so produces potentially invalid classes when it is\n     * executed. In this case the class is reread and rewritten with the\n     * {@link #COMPUTE_FRAMES} option (the resizeInstructions method can resize\n     * stack map tables when this option is used).\n     */\n    boolean invalidFrames;\n\n    // ------------------------------------------------------------------------\n    // Static initializer\n    // ------------------------------------------------------------------------\n    /**\n     * Computes the instruction types of JVM opcodes.\n     */\n    static {\n        int i;\n        byte[] b = new byte[220];\n        String s = \"AAAAAAAAAAAAAAAABCKLLDDDDDEEEEEEEEEEEEEEEEEEEEAAAAAAAADD\" + \"DDDEEEEEEEEEEEEEEEEEEEEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAAIIIIIIIIIIIIIIIIDNOAA\" + \"AAAAGGGGGGGHHFBFAAFFAAQPIIJJIIIIIIIIIIIIIIIIII\";\n        for (i = 0; i < b.length; ++i) {\n            b[i] = (byte) (s.charAt(i) - 'A');\n        }\n        TYPE = b;\n        // code to generate the above string\n        //\n        // // SBYTE_INSN instructions\n        // b[Constants.NEWARRAY] = SBYTE_INSN;\n        // b[Constants.BIPUSH] = SBYTE_INSN;\n        //\n        // // SHORT_INSN instructions\n        // b[Constants.SIPUSH] = SHORT_INSN;\n        //\n        // // (IMPL)VAR_INSN instructions\n        // b[Constants.RET] = VAR_INSN;\n        // for (i = Constants.ILOAD; i <= Constants.ALOAD; ++i) {\n        // b[i] = VAR_INSN;\n        // }\n        // for (i = Constants.ISTORE; i <= Constants.ASTORE; ++i) {\n        // b[i] = VAR_INSN;\n        // }\n        // for (i = 26; i <= 45; ++i) { // ILOAD_0 to ALOAD_3\n        // b[i] = IMPLVAR_INSN;\n        // }\n        // for (i = 59; i <= 78; ++i) { // ISTORE_0 to ASTORE_3\n        // b[i] = IMPLVAR_INSN;\n        // }\n        //\n        // // TYPE_INSN instructions\n        // b[Constants.NEW] = TYPE_INSN;\n        // b[Constants.ANEWARRAY] = TYPE_INSN;\n        // b[Constants.CHECKCAST] = TYPE_INSN;\n        // b[Constants.INSTANCEOF] = TYPE_INSN;\n        //\n        // // (Set)FIELDORMETH_INSN instructions\n        // for (i = Constants.GETSTATIC; i <= Constants.INVOKESTATIC; ++i) {\n        // b[i] = FIELDORMETH_INSN;\n        // }\n        // b[Constants.INVOKEINTERFACE] = ITFDYNMETH_INSN;\n        // b[Constants.INVOKEDYNAMIC] = ITFDYNMETH_INSN;\n        //\n        // // LABEL(W)_INSN instructions\n        // for (i = Constants.IFEQ; i <= Constants.JSR; ++i) {\n        // b[i] = LABEL_INSN;\n        // }\n        // b[Constants.IFNULL] = LABEL_INSN;\n        // b[Constants.IFNONNULL] = LABEL_INSN;\n        // b[200] = LABELW_INSN; // GOTO_W\n        // b[201] = LABELW_INSN; // JSR_W\n        // // temporary opcodes used internally by ASM - see Label and\n        // MethodWriter\n        // for (i = 202; i < 220; ++i) {\n        // b[i] = LABEL_INSN;\n        // }\n        //\n        // // LDC(_W) instructions\n        // b[Constants.LDC] = LDC_INSN;\n        // b[19] = LDCW_INSN; // LDC_W\n        // b[20] = LDCW_INSN; // LDC2_W\n        //\n        // // special instructions\n        // b[Constants.IINC] = IINC_INSN;\n        // b[Constants.TABLESWITCH] = TABL_INSN;\n        // b[Constants.LOOKUPSWITCH] = LOOK_INSN;\n        // b[Constants.MULTIANEWARRAY] = MANA_INSN;\n        // b[196] = WIDE_INSN; // WIDE\n        //\n        // for (i = 0; i < b.length; ++i) {\n        // System.err.print((char)('A' + b[i]));\n        // }\n        // System.err.println();\n    }\n\n    // ------------------------------------------------------------------------\n    // Constructor\n    // ------------------------------------------------------------------------\n    /**\n     * Constructs a new {@link ClassWriter} object.\n     *\n     * @param flags option flags that can be used to modify the default behavior\n     *        of this class. See {@link #COMPUTE_MAXS}, {@link #COMPUTE_FRAMES}.\n     */\n    public ClassWriter(final int flags) {\n        index = 1;\n        pool = new ByteVector();\n        items = new Item[256];\n        threshold = (int) (0.75d * items.length);\n        key = new Item();\n        key2 = new Item();\n        key3 = new Item();\n        this.computeMaxs = (flags & COMPUTE_MAXS) != 0;\n        this.computeFrames = (flags & COMPUTE_FRAMES) != 0;\n    }\n\n    /**\n     * Constructs a new {@link ClassWriter} object and enables optimizations for\n     * \"mostly add\" bytecode transformations. These optimizations are the\n     * following:\n     *\n     * <ul> <li>The constant pool from the original class is copied as is in\n     * the new class, which saves time. New constant pool entries will be added\n     * at the end if necessary, but unused constant pool entries <i>won't be\n     * removed</i>.</li> <li>Methods that are not transformed are copied as\n     * is in the new class, directly from the original class bytecode (i.e.\n     * without emitting visit events for all the method instructions), which\n     * saves a <i>lot</i> of time. Untransformed methods are detected by the\n     * fact that the {@link ClassReader} receives {@link MethodVisitor} objects\n     * that come from a {@link ClassWriter} (and not from a custom\n     * {@link ClassAdapter} or any other {@link ClassVisitor} instance).</li>\n     * </ul>\n     *\n     * @param classReader the {@link ClassReader} used to read the original\n     *        class. It will be used to copy the entire constant pool from the\n     *        original class and also to copy other fragments of original\n     *        bytecode where applicable.\n     * @param flags option flags that can be used to modify the default behavior\n     *        of this class. See {@link #COMPUTE_MAXS}, {@link #COMPUTE_FRAMES}.\n     */\n    public ClassWriter(final ClassReader classReader, final int flags) {\n        this(flags);\n        classReader.copyPool(this);\n        this.cr = classReader;\n    }\n\n    // ------------------------------------------------------------------------\n    // Implementation of the ClassVisitor interface\n    // ------------------------------------------------------------------------\n    public void visit(final int version, final int access, final String name, final String signature, final String superName, final String[] interfaces) {\n        this.version = version;\n        this.access = access;\n        this.name = newClass(name);\n        thisName = name;\n        if (ClassReader.SIGNATURES && signature != null) {\n            this.signature = newUTF8(signature);\n        }\n        this.superName = superName == null ? 0 : newClass(superName);\n        if (interfaces != null && interfaces.length > 0) {\n            interfaceCount = interfaces.length;\n            this.interfaces = new int[interfaceCount];\n            for (int i = 0; i < interfaceCount; ++i) {\n                this.interfaces[i] = newClass(interfaces[i]);\n            }\n        }\n    }\n\n    public void visitSource(final String file, final String debug) {\n        if (file != null) {\n            sourceFile = newUTF8(file);\n        }\n        if (debug != null) {\n            sourceDebug = new ByteVector().putUTF8(debug);\n        }\n    }\n\n    public void visitOuterClass(final String owner, final String name, final String desc) {\n        enclosingMethodOwner = newClass(owner);\n        if (name != null && desc != null) {\n            enclosingMethod = newNameType(name, desc);\n        }\n    }\n\n    public AnnotationVisitor visitAnnotation(final String desc, final boolean visible) {\n        if (!ClassReader.ANNOTATIONS) {\n            return null;\n        }\n        ByteVector bv = new ByteVector();\n        // write type, and reserve space for values count\n        bv.putShort(newUTF8(desc)).putShort(0);\n        AnnotationWriter aw = new AnnotationWriter(this, true, bv, bv, 2);\n        if (visible) {\n            aw.next = anns;\n            anns = aw;\n        } else {\n            aw.next = ianns;\n            ianns = aw;\n        }\n        return aw;\n    }\n\n    public void visitAttribute(final Attribute attr) {\n        attr.next = attrs;\n        attrs = attr;\n    }\n\n    public void visitInnerClass(final String name, final String outerName, final String innerName, final int access) {\n        if (innerClasses == null) {\n            innerClasses = new ByteVector();\n        }\n        ++innerClassesCount;\n        innerClasses.putShort(name == null ? 0 : newClass(name));\n        innerClasses.putShort(outerName == null ? 0 : newClass(outerName));\n        innerClasses.putShort(innerName == null ? 0 : newUTF8(innerName));\n        innerClasses.putShort(access);\n    }\n\n    public FieldVisitor visitField(final int access, final String name, final String desc, final String signature, final Object value) {\n        return new FieldWriter(this, access, name, desc, signature, value);\n    }\n\n    public MethodVisitor visitMethod(final int access, final String name, final String desc, final String signature, final String[] exceptions) {\n        return new MethodWriter(this, access, name, desc, signature, exceptions, computeMaxs, computeFrames);\n    }\n\n    public void visitEnd() {\n    }\n\n    // ------------------------------------------------------------------------\n    // Other public methods\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the bytecode of the class that was build with this class writer.\n     *\n     * @return the bytecode of the class that was build with this class writer.\n     */\n    public byte[] toByteArray() {\n        // computes the real size of the bytecode of this class\n        int size = 24 + 2 * interfaceCount;\n        int nbFields = 0;\n        FieldWriter fb = firstField;\n        while (fb != null) {\n            ++nbFields;\n            size += fb.getSize();\n            fb = fb.next;\n        }\n        int nbMethods = 0;\n        MethodWriter mb = firstMethod;\n        while (mb != null) {\n            ++nbMethods;\n            size += mb.getSize();\n            mb = mb.next;\n        }\n        int attributeCount = 0;\n        if (ClassReader.SIGNATURES && signature != 0) {\n            ++attributeCount;\n            size += 8;\n            newUTF8(\"Signature\");\n        }\n        if (sourceFile != 0) {\n            ++attributeCount;\n            size += 8;\n            newUTF8(\"SourceFile\");\n        }\n        if (sourceDebug != null) {\n            ++attributeCount;\n            size += sourceDebug.length + 4;\n            newUTF8(\"SourceDebugExtension\");\n        }\n        if (enclosingMethodOwner != 0) {\n            ++attributeCount;\n            size += 10;\n            newUTF8(\"EnclosingMethod\");\n        }\n        if ((access & Opcodes.ACC_DEPRECATED) != 0) {\n            ++attributeCount;\n            size += 6;\n            newUTF8(\"Deprecated\");\n        }\n        if ((access & Opcodes.ACC_SYNTHETIC) != 0 && (version & 0xffff) < Opcodes.V1_5) {\n            ++attributeCount;\n            size += 6;\n            newUTF8(\"Synthetic\");\n        }\n        if (innerClasses != null) {\n            ++attributeCount;\n            size += 8 + innerClasses.length;\n            newUTF8(\"InnerClasses\");\n        }\n        if (ClassReader.ANNOTATIONS && anns != null) {\n            ++attributeCount;\n            size += 8 + anns.getSize();\n            newUTF8(\"RuntimeVisibleAnnotations\");\n        }\n        if (ClassReader.ANNOTATIONS && ianns != null) {\n            ++attributeCount;\n            size += 8 + ianns.getSize();\n            newUTF8(\"RuntimeInvisibleAnnotations\");\n        }\n        if (attrs != null) {\n            attributeCount += attrs.getCount();\n            size += attrs.getSize(this, null, 0, -1, -1);\n        }\n        size += pool.length;\n        // allocates a byte vector of this size, in order to avoid unnecessary\n        // arraycopy operations in the ByteVector.enlarge() method\n        ByteVector out = new ByteVector(size);\n        out.putInt(0xCAFEBABE).putInt(version);\n        out.putShort(index).putByteArray(pool.data, 0, pool.length);\n        out.putShort(access).putShort(name).putShort(superName);\n        out.putShort(interfaceCount);\n        for (int i = 0; i < interfaceCount; ++i) {\n            out.putShort(interfaces[i]);\n        }\n        out.putShort(nbFields);\n        fb = firstField;\n        while (fb != null) {\n            fb.put(out);\n            fb = fb.next;\n        }\n        out.putShort(nbMethods);\n        mb = firstMethod;\n        while (mb != null) {\n            mb.put(out);\n            mb = mb.next;\n        }\n        out.putShort(attributeCount);\n        if (ClassReader.SIGNATURES && signature != 0) {\n            out.putShort(newUTF8(\"Signature\")).putInt(2).putShort(signature);\n        }\n        if (sourceFile != 0) {\n            out.putShort(newUTF8(\"SourceFile\")).putInt(2).putShort(sourceFile);\n        }\n        if (sourceDebug != null) {\n            int len = sourceDebug.length - 2;\n            out.putShort(newUTF8(\"SourceDebugExtension\")).putInt(len);\n            out.putByteArray(sourceDebug.data, 2, len);\n        }\n        if (enclosingMethodOwner != 0) {\n            out.putShort(newUTF8(\"EnclosingMethod\")).putInt(4);\n            out.putShort(enclosingMethodOwner).putShort(enclosingMethod);\n        }\n        if ((access & Opcodes.ACC_DEPRECATED) != 0) {\n            out.putShort(newUTF8(\"Deprecated\")).putInt(0);\n        }\n        if ((access & Opcodes.ACC_SYNTHETIC) != 0 && (version & 0xffff) < Opcodes.V1_5) {\n            out.putShort(newUTF8(\"Synthetic\")).putInt(0);\n        }\n        if (innerClasses != null) {\n            out.putShort(newUTF8(\"InnerClasses\"));\n            out.putInt(innerClasses.length + 2).putShort(innerClassesCount);\n            out.putByteArray(innerClasses.data, 0, innerClasses.length);\n        }\n        if (ClassReader.ANNOTATIONS && anns != null) {\n            out.putShort(newUTF8(\"RuntimeVisibleAnnotations\"));\n            anns.put(out);\n        }\n        if (ClassReader.ANNOTATIONS && ianns != null) {\n            out.putShort(newUTF8(\"RuntimeInvisibleAnnotations\"));\n            ianns.put(out);\n        }\n        if (attrs != null) {\n            attrs.put(this, null, 0, -1, -1, out);\n        }\n        if (invalidFrames) {\n            ClassWriter cw = new ClassWriter(COMPUTE_FRAMES);\n            new ClassReader(out.data).accept(cw, ClassReader.SKIP_FRAMES);\n            return cw.toByteArray();\n        }\n        return out.data;\n    }\n\n    // ------------------------------------------------------------------------\n    // Utility methods: constant pool management\n    // ------------------------------------------------------------------------\n    /**\n     * Adds a number or string constant to the constant pool of the class being\n     * build. Does nothing if the constant pool already contains a similar item.\n     *\n     * @param cst the value of the constant to be added to the constant pool.\n     *        This parameter must be an {@link Integer}, a {@link Float}, a\n     *        {@link Long}, a {@link Double}, a {@link String} or a\n     *        {@link Type}.\n     * @return a new or already existing constant item with the given value.\n     */\n    Item newConstItem(final Object cst) {\n        if (cst instanceof Integer) {\n            int val = ((Integer) cst).intValue();\n            return newInteger(val);\n        } else if (cst instanceof Byte) {\n            int val = ((Byte) cst).intValue();\n            return newInteger(val);\n        } else if (cst instanceof Character) {\n            int val = ((Character) cst).charValue();\n            return newInteger(val);\n        } else if (cst instanceof Short) {\n            int val = ((Short) cst).intValue();\n            return newInteger(val);\n        } else if (cst instanceof Boolean) {\n            int val = ((Boolean) cst).booleanValue() ? 1 : 0;\n            return newInteger(val);\n        } else if (cst instanceof Float) {\n            float val = ((Float) cst).floatValue();\n            return newFloat(val);\n        } else if (cst instanceof Long) {\n            long val = ((Long) cst).longValue();\n            return newLong(val);\n        } else if (cst instanceof Double) {\n            double val = ((Double) cst).doubleValue();\n            return newDouble(val);\n        } else if (cst instanceof String) {\n            return newString((String) cst);\n        } else if (cst instanceof Type) {\n            Type t = (Type) cst;\n            return newClassItem(t.getSort() == Type.OBJECT ? t.getInternalName() : t.getDescriptor());\n        } else {\n            throw new IllegalArgumentException(\"value \" + cst);\n        }\n    }\n\n    /**\n     * Adds a number or string constant to the constant pool of the class being\n     * build. Does nothing if the constant pool already contains a similar item.\n     * <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param cst the value of the constant to be added to the constant pool.\n     *        This parameter must be an {@link Integer}, a {@link Float}, a\n     *        {@link Long}, a {@link Double} or a {@link String}.\n     * @return the index of a new or already existing constant item with the\n     *         given value.\n     */\n    public int newConst(final Object cst) {\n        return newConstItem(cst).index;\n    }\n\n    /**\n     * Adds an UTF8 string to the constant pool of the class being build. Does\n     * nothing if the constant pool already contains a similar item. <i>This\n     * method is intended for {@link Attribute} sub classes, and is normally not\n     * needed by class generators or adapters.</i>\n     *\n     * @param value the String value.\n     * @return the index of a new or already existing UTF8 item.\n     */\n    public int newUTF8(final String value) {\n        key.set(UTF8, value, null, null);\n        Item result = get(key);\n        if (result == null) {\n            pool.putByte(UTF8).putUTF8(value);\n            result = new Item(index++, key);\n            put(result);\n        }\n        return result.index;\n    }\n\n    /**\n     * Adds a class reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     * <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param value the internal name of the class.\n     * @return a new or already existing class reference item.\n     */\n    Item newClassItem(final String value) {\n        key2.set(CLASS, value, null, null);\n        Item result = get(key2);\n        if (result == null) {\n            pool.put12(CLASS, newUTF8(value));\n            result = new Item(index++, key2);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a class reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     * <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param value the internal name of the class.\n     * @return the index of a new or already existing class reference item.\n     */\n    public int newClass(final String value) {\n        return newClassItem(value).index;\n    }\n\n    /**\n     * Adds a field reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     *\n     * @param owner the internal name of the field's owner class.\n     * @param name the field's name.\n     * @param desc the field's descriptor.\n     * @return a new or already existing field reference item.\n     */\n    Item newFieldItem(final String owner, final String name, final String desc) {\n        key3.set(FIELD, owner, name, desc);\n        Item result = get(key3);\n        if (result == null) {\n            put122(FIELD, newClass(owner), newNameType(name, desc));\n            result = new Item(index++, key3);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a field reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     * <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param owner the internal name of the field's owner class.\n     * @param name the field's name.\n     * @param desc the field's descriptor.\n     * @return the index of a new or already existing field reference item.\n     */\n    public int newField(final String owner, final String name, final String desc) {\n        return newFieldItem(owner, name, desc).index;\n    }\n\n    /**\n     * Adds a method reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     *\n     * @param owner the internal name of the method's owner class.\n     * @param name the method's name.\n     * @param desc the method's descriptor.\n     * @param itf <tt>true</tt> if <tt>owner</tt> is an interface.\n     * @return a new or already existing method reference item.\n     */\n    Item newMethodItem(final String owner, final String name, final String desc, final boolean itf) {\n        int type = itf ? IMETH : METH;\n        key3.set(type, owner, name, desc);\n        Item result = get(key3);\n        if (result == null) {\n            put122(type, newClass(owner), newNameType(name, desc));\n            result = new Item(index++, key3);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a method reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     * <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param owner the internal name of the method's owner class.\n     * @param name the method's name.\n     * @param desc the method's descriptor.\n     * @param itf <tt>true</tt> if <tt>owner</tt> is an interface.\n     * @return the index of a new or already existing method reference item.\n     */\n    public int newMethod(final String owner, final String name, final String desc, final boolean itf) {\n        return newMethodItem(owner, name, desc, itf).index;\n    }\n\n    /**\n     * Adds an integer to the constant pool of the class being build. Does\n     * nothing if the constant pool already contains a similar item.\n     *\n     * @param value the int value.\n     * @return a new or already existing int item.\n     */\n    Item newInteger(final int value) {\n        key.set(value);\n        Item result = get(key);\n        if (result == null) {\n            pool.putByte(INT).putInt(value);\n            result = new Item(index++, key);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a float to the constant pool of the class being build. Does nothing\n     * if the constant pool already contains a similar item.\n     *\n     * @param value the float value.\n     * @return a new or already existing float item.\n     */\n    Item newFloat(final float value) {\n        key.set(value);\n        Item result = get(key);\n        if (result == null) {\n            pool.putByte(FLOAT).putInt(key.intVal);\n            result = new Item(index++, key);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a long to the constant pool of the class being build. Does nothing\n     * if the constant pool already contains a similar item.\n     *\n     * @param value the long value.\n     * @return a new or already existing long item.\n     */\n    Item newLong(final long value) {\n        key.set(value);\n        Item result = get(key);\n        if (result == null) {\n            pool.putByte(LONG).putLong(value);\n            result = new Item(index, key);\n            put(result);\n            index += 2;\n        }\n        return result;\n    }\n\n    /**\n     * Adds a double to the constant pool of the class being build. Does nothing\n     * if the constant pool already contains a similar item.\n     *\n     * @param value the double value.\n     * @return a new or already existing double item.\n     */\n    Item newDouble(final double value) {\n        key.set(value);\n        Item result = get(key);\n        if (result == null) {\n            pool.putByte(DOUBLE).putLong(key.longVal);\n            result = new Item(index, key);\n            put(result);\n            index += 2;\n        }\n        return result;\n    }\n\n    /**\n     * Adds a string to the constant pool of the class being build. Does nothing\n     * if the constant pool already contains a similar item.\n     *\n     * @param value the String value.\n     * @return a new or already existing string item.\n     */\n    private Item newString(final String value) {\n        key2.set(STR, value, null, null);\n        Item result = get(key2);\n        if (result == null) {\n            pool.put12(STR, newUTF8(value));\n            result = new Item(index++, key2);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a name and type to the constant pool of the class being build. Does\n     * nothing if the constant pool already contains a similar item. <i>This\n     * method is intended for {@link Attribute} sub classes, and is normally not\n     * needed by class generators or adapters.</i>\n     *\n     * @param name a name.\n     * @param desc a type descriptor.\n     * @return the index of a new or already existing name and type item.\n     */\n    public int newNameType(final String name, final String desc) {\n        return newNameTypeItem(name, desc).index;\n    }\n\n    /**\n     * Adds a name and type to the constant pool of the class being build. Does\n     * nothing if the constant pool already contains a similar item.\n     *\n     * @param name a name.\n     * @param desc a type descriptor.\n     * @return a new or already existing name and type item.\n     */\n    Item newNameTypeItem(final String name, final String desc) {\n        key2.set(NAME_TYPE, name, desc, null);\n        Item result = get(key2);\n        if (result == null) {\n            put122(NAME_TYPE, newUTF8(name), newUTF8(desc));\n            result = new Item(index++, key2);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds the given internal name to {@link #typeTable} and returns its index.\n     * Does nothing if the type table already contains this internal name.\n     *\n     * @param type the internal name to be added to the type table.\n     * @return the index of this internal name in the type table.\n     */\n    int addType(final String type) {\n        key.set(TYPE_NORMAL, type, null, null);\n        Item result = get(key);\n        if (result == null) {\n            result = addType(key);\n        }\n        return result.index;\n    }\n\n    /**\n     * Adds the given \"uninitialized\" type to {@link #typeTable} and returns its\n     * index. This method is used for UNINITIALIZED types, made of an internal\n     * name and a bytecode offset.\n     *\n     * @param type the internal name to be added to the type table.\n     * @param offset the bytecode offset of the NEW instruction that created\n     *        this UNINITIALIZED type value.\n     * @return the index of this internal name in the type table.\n     */\n    int addUninitializedType(final String type, final int offset) {\n        key.type = TYPE_UNINIT;\n        key.intVal = offset;\n        key.strVal1 = type;\n        key.hashCode = 0x7FFFFFFF & (TYPE_UNINIT + type.hashCode() + offset);\n        Item result = get(key);\n        if (result == null) {\n            result = addType(key);\n        }\n        return result.index;\n    }\n\n    /**\n     * Adds the given Item to {@link #typeTable}.\n     *\n     * @param item the value to be added to the type table.\n     * @return the added Item, which a new Item instance with the same value as\n     *         the given Item.\n     */\n    private Item addType(final Item item) {\n        ++typeCount;\n        Item result = new Item(typeCount, key);\n        put(result);\n        if (typeTable == null) {\n            typeTable = new Item[16];\n        }\n        if (typeCount == typeTable.length) {\n            Item[] newTable = new Item[2 * typeTable.length];\n            System.arraycopy(typeTable, 0, newTable, 0, typeTable.length);\n            typeTable = newTable;\n        }\n        typeTable[typeCount] = result;\n        return result;\n    }\n\n    /**\n     * Returns the index of the common super type of the two given types. This\n     * method calls {@link #getCommonSuperClass} and caches the result in the\n     * {@link #items} hash table to speedup future calls with the same\n     * parameters.\n     *\n     * @param type1 index of an internal name in {@link #typeTable}.\n     * @param type2 index of an internal name in {@link #typeTable}.\n     * @return the index of the common super type of the two given types.\n     */\n    int getMergedType(final int type1, final int type2) {\n        key2.type = TYPE_MERGED;\n        key2.longVal = type1 | (((long) type2) << 32);\n        key2.hashCode = 0x7FFFFFFF & (TYPE_MERGED + type1 + type2);\n        Item result = get(key2);\n        if (result == null) {\n            String t = typeTable[type1].strVal1;\n            String u = typeTable[type2].strVal1;\n            key2.intVal = addType(getCommonSuperClass(t, u));\n            result = new Item((short) 0, key2);\n            put(result);\n        }\n        return result.intVal;\n    }\n\n    /**\n     * Returns the common super type of the two given types. The default\n     * implementation of this method <i>loads<i> the two given classes and uses\n     * the java.lang.Class methods to find the common super class. It can be\n     * overridden to compute this common super type in other ways, in particular\n     * without actually loading any class, or to take into account the class\n     * that is currently being generated by this ClassWriter, which can of\n     * course not be loaded since it is under construction.\n     *\n     * @param type1 the internal name of a class.\n     * @param type2 the internal name of another class.\n     * @return the internal name of the common super class of the two given\n     *         classes.\n     */\n    protected String getCommonSuperClass(final String type1, final String type2) {\n        Class c, d;\n        try {\n            c = Class.forName(type1.replace('/', '.'));\n            d = Class.forName(type2.replace('/', '.'));\n        } catch (Exception e) {\n            throw new RuntimeException(e.toString());\n        }\n        if (c.isAssignableFrom(d)) {\n            return type1;\n        }\n        if (d.isAssignableFrom(c)) {\n            return type2;\n        }\n        if (c.isInterface() || d.isInterface()) {\n            return \"java/lang/Object\";\n        } else {\n            do {\n                c = c.getSuperclass();\n            } while (!c.isAssignableFrom(d));\n            return c.getName().replace('.', '/');\n        }\n    }\n\n    /**\n     * Returns the constant pool's hash table item which is equal to the given\n     * item.\n     *\n     * @param key a constant pool item.\n     * @return the constant pool's hash table item which is equal to the given\n     *         item, or <tt>null</tt> if there is no such item.\n     */\n    private Item get(final Item key) {\n        Item i = items[key.hashCode % items.length];\n        while (i != null && (i.type != key.type || !key.isEqualTo(i))) {\n            i = i.next;\n        }\n        return i;\n    }\n\n    /**\n     * Puts the given item in the constant pool's hash table. The hash table\n     * <i>must</i> not already contains this item.\n     *\n     * @param i the item to be added to the constant pool's hash table.\n     */\n    private void put(final Item i) {\n        if (index > threshold) {\n            int ll = items.length;\n            int nl = ll * 2 + 1;\n            Item[] newItems = new Item[nl];\n            for (int l = ll - 1; l >= 0; --l) {\n                Item j = items[l];\n                while (j != null) {\n                    int index = j.hashCode % newItems.length;\n                    Item k = j.next;\n                    j.next = newItems[index];\n                    newItems[index] = j;\n                    j = k;\n                }\n            }\n            items = newItems;\n            threshold = (int) (nl * 0.75);\n        }\n        int index = i.hashCode % items.length;\n        i.next = items[index];\n        items[index] = i;\n    }\n\n    /**\n     * Puts one byte and two shorts into the constant pool.\n     *\n     * @param b a byte.\n     * @param s1 a short.\n     * @param s2 another short.\n     */\n    private void put122(final int b, final int s1, final int s2) {\n        pool.put12(b, s1).putShort(s2);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/ClassWriterTest4.java",
		"test_prompt": "// ClassWriterTest4.java\npackage org.objectweb.asm.jip;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassWriter}.\n* It contains ten unit test cases for the {@link ClassWriter#newConst(Object)} method.\n*/\nclass ClassWriterTest4 {"
	},
	{
		"original_code": "// ClassWriter.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\n/**\n * A {@link ClassVisitor} that generates classes in bytecode form. More\n * precisely this visitor generates a byte array conforming to the Java class\n * file format. It can be used alone, to generate a Java class \"from scratch\",\n * or with one or more {@link ClassReader ClassReader} and adapter class visitor\n * to generate a modified class from one or more existing Java classes.\n *\n * @author Eric Bruneton\n */\npublic class ClassWriter implements ClassVisitor {\n\n    /**\n     * Flag to automatically compute the maximum stack size and the maximum\n     * number of local variables of methods. If this flag is set, then the\n     * arguments of the {@link MethodVisitor#visitMaxs visitMaxs} method of the\n     * {@link MethodVisitor} returned by the {@link #visitMethod visitMethod}\n     * method will be ignored, and computed automatically from the signature and\n     * the bytecode of each method.\n     *\n     * @see #ClassWriter(int)\n     */\n    public static final int COMPUTE_MAXS = 1;\n\n    /**\n     * Flag to automatically compute the stack map frames of methods from\n     * scratch. If this flag is set, then the calls to the\n     * {@link MethodVisitor#visitFrame} method are ignored, and the stack map\n     * frames are recomputed from the methods bytecode. The arguments of the\n     * {@link MethodVisitor#visitMaxs visitMaxs} method are also ignored and\n     * recomputed from the bytecode. In other words, computeFrames implies\n     * computeMaxs.\n     *\n     * @see #ClassWriter(int)\n     */\n    public static final int COMPUTE_FRAMES = 2;\n\n    /**\n     * The type of instructions without any argument.\n     */\n    static final int NOARG_INSN = 0;\n\n    /**\n     * The type of instructions with an signed byte argument.\n     */\n    static final int SBYTE_INSN = 1;\n\n    /**\n     * The type of instructions with an signed short argument.\n     */\n    static final int SHORT_INSN = 2;\n\n    /**\n     * The type of instructions with a local variable index argument.\n     */\n    static final int VAR_INSN = 3;\n\n    /**\n     * The type of instructions with an implicit local variable index argument.\n     */\n    static final int IMPLVAR_INSN = 4;\n\n    /**\n     * The type of instructions with a type descriptor argument.\n     */\n    static final int TYPE_INSN = 5;\n\n    /**\n     * The type of field and method invocations instructions.\n     */\n    static final int FIELDORMETH_INSN = 6;\n\n    /**\n     * The type of the INVOKEINTERFACE/INVOKEDYNAMIC instruction.\n     */\n    static final int ITFDYNMETH_INSN = 7;\n\n    /**\n     * The type of instructions with a 2 bytes bytecode offset label.\n     */\n    static final int LABEL_INSN = 8;\n\n    /**\n     * The type of instructions with a 4 bytes bytecode offset label.\n     */\n    static final int LABELW_INSN = 9;\n\n    /**\n     * The type of the LDC instruction.\n     */\n    static final int LDC_INSN = 10;\n\n    /**\n     * The type of the LDC_W and LDC2_W instructions.\n     */\n    static final int LDCW_INSN = 11;\n\n    /**\n     * The type of the IINC instruction.\n     */\n    static final int IINC_INSN = 12;\n\n    /**\n     * The type of the TABLESWITCH instruction.\n     */\n    static final int TABL_INSN = 13;\n\n    /**\n     * The type of the LOOKUPSWITCH instruction.\n     */\n    static final int LOOK_INSN = 14;\n\n    /**\n     * The type of the MULTIANEWARRAY instruction.\n     */\n    static final int MANA_INSN = 15;\n\n    /**\n     * The type of the WIDE instruction.\n     */\n    static final int WIDE_INSN = 16;\n\n    /**\n     * The instruction types of all JVM opcodes.\n     */\n    static final byte[] TYPE;\n\n    /**\n     * The type of CONSTANT_Class constant pool items.\n     */\n    static final int CLASS = 7;\n\n    /**\n     * The type of CONSTANT_Fieldref constant pool items.\n     */\n    static final int FIELD = 9;\n\n    /**\n     * The type of CONSTANT_Methodref constant pool items.\n     */\n    static final int METH = 10;\n\n    /**\n     * The type of CONSTANT_InterfaceMethodref constant pool items.\n     */\n    static final int IMETH = 11;\n\n    /**\n     * The type of CONSTANT_String constant pool items.\n     */\n    static final int STR = 8;\n\n    /**\n     * The type of CONSTANT_Integer constant pool items.\n     */\n    static final int INT = 3;\n\n    /**\n     * The type of CONSTANT_Float constant pool items.\n     */\n    static final int FLOAT = 4;\n\n    /**\n     * The type of CONSTANT_Long constant pool items.\n     */\n    static final int LONG = 5;\n\n    /**\n     * The type of CONSTANT_Double constant pool items.\n     */\n    static final int DOUBLE = 6;\n\n    /**\n     * The type of CONSTANT_NameAndType constant pool items.\n     */\n    static final int NAME_TYPE = 12;\n\n    /**\n     * The type of CONSTANT_Utf8 constant pool items.\n     */\n    static final int UTF8 = 1;\n\n    /**\n     * Normal type Item stored in the ClassWriter {@link ClassWriter#typeTable},\n     * instead of the constant pool, in order to avoid clashes with normal\n     * constant pool items in the ClassWriter constant pool's hash table.\n     */\n    static final int TYPE_NORMAL = 13;\n\n    /**\n     * Uninitialized type Item stored in the ClassWriter\n     * {@link ClassWriter#typeTable}, instead of the constant pool, in order to\n     * avoid clashes with normal constant pool items in the ClassWriter constant\n     * pool's hash table.\n     */\n    static final int TYPE_UNINIT = 14;\n\n    /**\n     * Merged type Item stored in the ClassWriter {@link ClassWriter#typeTable},\n     * instead of the constant pool, in order to avoid clashes with normal\n     * constant pool items in the ClassWriter constant pool's hash table.\n     */\n    static final int TYPE_MERGED = 15;\n\n    /**\n     * The class reader from which this class writer was constructed, if any.\n     */\n    ClassReader cr;\n\n    /**\n     * Minor and major version numbers of the class to be generated.\n     */\n    int version;\n\n    /**\n     * Index of the next item to be added in the constant pool.\n     */\n    int index;\n\n    /**\n     * The constant pool of this class.\n     */\n    final ByteVector pool;\n\n    /**\n     * The constant pool's hash table data.\n     */\n    Item[] items;\n\n    /**\n     * The threshold of the constant pool's hash table.\n     */\n    int threshold;\n\n    /**\n     * A reusable key used to look for items in the {@link #items} hash table.\n     */\n    final Item key;\n\n    /**\n     * A reusable key used to look for items in the {@link #items} hash table.\n     */\n    final Item key2;\n\n    /**\n     * A reusable key used to look for items in the {@link #items} hash table.\n     */\n    final Item key3;\n\n    /**\n     * A type table used to temporarily store internal names that will not\n     * necessarily be stored in the constant pool. This type table is used by\n     * the control flow and data flow analysis algorithm used to compute stack\n     * map frames from scratch. This array associates to each index <tt>i</tt>\n     * the Item whose index is <tt>i</tt>. All Item objects stored in this\n     * array are also stored in the {@link #items} hash table. These two arrays\n     * allow to retrieve an Item from its index or, conversely, to get the index\n     * of an Item from its value. Each Item stores an internal name in its\n     * {@link Item#strVal1} field.\n     */\n    Item[] typeTable;\n\n    /**\n     * Number of elements in the {@link #typeTable} array.\n     */\n    private short typeCount;\n\n    /**\n     * The access flags of this class.\n     */\n    private int access;\n\n    /**\n     * The constant pool item that contains the internal name of this class.\n     */\n    private int name;\n\n    /**\n     * The internal name of this class.\n     */\n    String thisName;\n\n    /**\n     * The constant pool item that contains the signature of this class.\n     */\n    private int signature;\n\n    /**\n     * The constant pool item that contains the internal name of the super class\n     * of this class.\n     */\n    private int superName;\n\n    /**\n     * Number of interfaces implemented or extended by this class or interface.\n     */\n    private int interfaceCount;\n\n    /**\n     * The interfaces implemented or extended by this class or interface. More\n     * precisely, this array contains the indexes of the constant pool items\n     * that contain the internal names of these interfaces.\n     */\n    private int[] interfaces;\n\n    /**\n     * The index of the constant pool item that contains the name of the source\n     * file from which this class was compiled.\n     */\n    private int sourceFile;\n\n    /**\n     * The SourceDebug attribute of this class.\n     */\n    private ByteVector sourceDebug;\n\n    /**\n     * The constant pool item that contains the name of the enclosing class of\n     * this class.\n     */\n    private int enclosingMethodOwner;\n\n    /**\n     * The constant pool item that contains the name and descriptor of the\n     * enclosing method of this class.\n     */\n    private int enclosingMethod;\n\n    /**\n     * The runtime visible annotations of this class.\n     */\n    private AnnotationWriter anns;\n\n    /**\n     * The runtime invisible annotations of this class.\n     */\n    private AnnotationWriter ianns;\n\n    /**\n     * The non standard attributes of this class.\n     */\n    private Attribute attrs;\n\n    /**\n     * The number of entries in the InnerClasses attribute.\n     */\n    private int innerClassesCount;\n\n    /**\n     * The InnerClasses attribute.\n     */\n    private ByteVector innerClasses;\n\n    /**\n     * The fields of this class. These fields are stored in a linked list of\n     * {@link FieldWriter} objects, linked to each other by their\n     * {@link FieldWriter#next} field. This field stores the first element of\n     * this list.\n     */\n    FieldWriter firstField;\n\n    /**\n     * The fields of this class. These fields are stored in a linked list of\n     * {@link FieldWriter} objects, linked to each other by their\n     * {@link FieldWriter#next} field. This field stores the last element of\n     * this list.\n     */\n    FieldWriter lastField;\n\n    /**\n     * The methods of this class. These methods are stored in a linked list of\n     * {@link MethodWriter} objects, linked to each other by their\n     * {@link MethodWriter#next} field. This field stores the first element of\n     * this list.\n     */\n    MethodWriter firstMethod;\n\n    /**\n     * The methods of this class. These methods are stored in a linked list of\n     * {@link MethodWriter} objects, linked to each other by their\n     * {@link MethodWriter#next} field. This field stores the last element of\n     * this list.\n     */\n    MethodWriter lastMethod;\n\n    /**\n     * <tt>true</tt> if the maximum stack size and number of local variables\n     * must be automatically computed.\n     */\n    private final boolean computeMaxs;\n\n    /**\n     * <tt>true</tt> if the stack map frames must be recomputed from scratch.\n     */\n    private final boolean computeFrames;\n\n    /**\n     * <tt>true</tt> if the stack map tables of this class are invalid. The\n     * {@link MethodWriter#resizeInstructions} method cannot transform existing\n     * stack map tables, and so produces potentially invalid classes when it is\n     * executed. In this case the class is reread and rewritten with the\n     * {@link #COMPUTE_FRAMES} option (the resizeInstructions method can resize\n     * stack map tables when this option is used).\n     */\n    boolean invalidFrames;\n\n    // ------------------------------------------------------------------------\n    // Static initializer\n    // ------------------------------------------------------------------------\n    /**\n     * Computes the instruction types of JVM opcodes.\n     */\n    static {\n        int i;\n        byte[] b = new byte[220];\n        String s = \"AAAAAAAAAAAAAAAABCKLLDDDDDEEEEEEEEEEEEEEEEEEEEAAAAAAAADD\" + \"DDDEEEEEEEEEEEEEEEEEEEEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAAIIIIIIIIIIIIIIIIDNOAA\" + \"AAAAGGGGGGGHHFBFAAFFAAQPIIJJIIIIIIIIIIIIIIIIII\";\n        for (i = 0; i < b.length; ++i) {\n            b[i] = (byte) (s.charAt(i) - 'A');\n        }\n        TYPE = b;\n        // code to generate the above string\n        //\n        // // SBYTE_INSN instructions\n        // b[Constants.NEWARRAY] = SBYTE_INSN;\n        // b[Constants.BIPUSH] = SBYTE_INSN;\n        //\n        // // SHORT_INSN instructions\n        // b[Constants.SIPUSH] = SHORT_INSN;\n        //\n        // // (IMPL)VAR_INSN instructions\n        // b[Constants.RET] = VAR_INSN;\n        // for (i = Constants.ILOAD; i <= Constants.ALOAD; ++i) {\n        // b[i] = VAR_INSN;\n        // }\n        // for (i = Constants.ISTORE; i <= Constants.ASTORE; ++i) {\n        // b[i] = VAR_INSN;\n        // }\n        // for (i = 26; i <= 45; ++i) { // ILOAD_0 to ALOAD_3\n        // b[i] = IMPLVAR_INSN;\n        // }\n        // for (i = 59; i <= 78; ++i) { // ISTORE_0 to ASTORE_3\n        // b[i] = IMPLVAR_INSN;\n        // }\n        //\n        // // TYPE_INSN instructions\n        // b[Constants.NEW] = TYPE_INSN;\n        // b[Constants.ANEWARRAY] = TYPE_INSN;\n        // b[Constants.CHECKCAST] = TYPE_INSN;\n        // b[Constants.INSTANCEOF] = TYPE_INSN;\n        //\n        // // (Set)FIELDORMETH_INSN instructions\n        // for (i = Constants.GETSTATIC; i <= Constants.INVOKESTATIC; ++i) {\n        // b[i] = FIELDORMETH_INSN;\n        // }\n        // b[Constants.INVOKEINTERFACE] = ITFDYNMETH_INSN;\n        // b[Constants.INVOKEDYNAMIC] = ITFDYNMETH_INSN;\n        //\n        // // LABEL(W)_INSN instructions\n        // for (i = Constants.IFEQ; i <= Constants.JSR; ++i) {\n        // b[i] = LABEL_INSN;\n        // }\n        // b[Constants.IFNULL] = LABEL_INSN;\n        // b[Constants.IFNONNULL] = LABEL_INSN;\n        // b[200] = LABELW_INSN; // GOTO_W\n        // b[201] = LABELW_INSN; // JSR_W\n        // // temporary opcodes used internally by ASM - see Label and\n        // MethodWriter\n        // for (i = 202; i < 220; ++i) {\n        // b[i] = LABEL_INSN;\n        // }\n        //\n        // // LDC(_W) instructions\n        // b[Constants.LDC] = LDC_INSN;\n        // b[19] = LDCW_INSN; // LDC_W\n        // b[20] = LDCW_INSN; // LDC2_W\n        //\n        // // special instructions\n        // b[Constants.IINC] = IINC_INSN;\n        // b[Constants.TABLESWITCH] = TABL_INSN;\n        // b[Constants.LOOKUPSWITCH] = LOOK_INSN;\n        // b[Constants.MULTIANEWARRAY] = MANA_INSN;\n        // b[196] = WIDE_INSN; // WIDE\n        //\n        // for (i = 0; i < b.length; ++i) {\n        // System.err.print((char)('A' + b[i]));\n        // }\n        // System.err.println();\n    }\n\n    // ------------------------------------------------------------------------\n    // Constructor\n    // ------------------------------------------------------------------------\n    /**\n     * Constructs a new {@link ClassWriter} object.\n     *\n     * @param flags option flags that can be used to modify the default behavior\n     *        of this class. See {@link #COMPUTE_MAXS}, {@link #COMPUTE_FRAMES}.\n     */\n    public ClassWriter(final int flags) {\n        index = 1;\n        pool = new ByteVector();\n        items = new Item[256];\n        threshold = (int) (0.75d * items.length);\n        key = new Item();\n        key2 = new Item();\n        key3 = new Item();\n        this.computeMaxs = (flags & COMPUTE_MAXS) != 0;\n        this.computeFrames = (flags & COMPUTE_FRAMES) != 0;\n    }\n\n    /**\n     * Constructs a new {@link ClassWriter} object and enables optimizations for\n     * \"mostly add\" bytecode transformations. These optimizations are the\n     * following:\n     *\n     * <ul> <li>The constant pool from the original class is copied as is in\n     * the new class, which saves time. New constant pool entries will be added\n     * at the end if necessary, but unused constant pool entries <i>won't be\n     * removed</i>.</li> <li>Methods that are not transformed are copied as\n     * is in the new class, directly from the original class bytecode (i.e.\n     * without emitting visit events for all the method instructions), which\n     * saves a <i>lot</i> of time. Untransformed methods are detected by the\n     * fact that the {@link ClassReader} receives {@link MethodVisitor} objects\n     * that come from a {@link ClassWriter} (and not from a custom\n     * {@link ClassAdapter} or any other {@link ClassVisitor} instance).</li>\n     * </ul>\n     *\n     * @param classReader the {@link ClassReader} used to read the original\n     *        class. It will be used to copy the entire constant pool from the\n     *        original class and also to copy other fragments of original\n     *        bytecode where applicable.\n     * @param flags option flags that can be used to modify the default behavior\n     *        of this class. See {@link #COMPUTE_MAXS}, {@link #COMPUTE_FRAMES}.\n     */\n    public ClassWriter(final ClassReader classReader, final int flags) {\n        this(flags);\n        classReader.copyPool(this);\n        this.cr = classReader;\n    }\n\n    // ------------------------------------------------------------------------\n    // Implementation of the ClassVisitor interface\n    // ------------------------------------------------------------------------\n    public void visit(final int version, final int access, final String name, final String signature, final String superName, final String[] interfaces) {\n        this.version = version;\n        this.access = access;\n        this.name = newClass(name);\n        thisName = name;\n        if (ClassReader.SIGNATURES && signature != null) {\n            this.signature = newUTF8(signature);\n        }\n        this.superName = superName == null ? 0 : newClass(superName);\n        if (interfaces != null && interfaces.length > 0) {\n            interfaceCount = interfaces.length;\n            this.interfaces = new int[interfaceCount];\n            for (int i = 0; i < interfaceCount; ++i) {\n                this.interfaces[i] = newClass(interfaces[i]);\n            }\n        }\n    }\n\n    public void visitSource(final String file, final String debug) {\n        if (file != null) {\n            sourceFile = newUTF8(file);\n        }\n        if (debug != null) {\n            sourceDebug = new ByteVector().putUTF8(debug);\n        }\n    }\n\n    public void visitOuterClass(final String owner, final String name, final String desc) {\n        enclosingMethodOwner = newClass(owner);\n        if (name != null && desc != null) {\n            enclosingMethod = newNameType(name, desc);\n        }\n    }\n\n    public AnnotationVisitor visitAnnotation(final String desc, final boolean visible) {\n        if (!ClassReader.ANNOTATIONS) {\n            return null;\n        }\n        ByteVector bv = new ByteVector();\n        // write type, and reserve space for values count\n        bv.putShort(newUTF8(desc)).putShort(0);\n        AnnotationWriter aw = new AnnotationWriter(this, true, bv, bv, 2);\n        if (visible) {\n            aw.next = anns;\n            anns = aw;\n        } else {\n            aw.next = ianns;\n            ianns = aw;\n        }\n        return aw;\n    }\n\n    public void visitAttribute(final Attribute attr) {\n        attr.next = attrs;\n        attrs = attr;\n    }\n\n    public void visitInnerClass(final String name, final String outerName, final String innerName, final int access) {\n        if (innerClasses == null) {\n            innerClasses = new ByteVector();\n        }\n        ++innerClassesCount;\n        innerClasses.putShort(name == null ? 0 : newClass(name));\n        innerClasses.putShort(outerName == null ? 0 : newClass(outerName));\n        innerClasses.putShort(innerName == null ? 0 : newUTF8(innerName));\n        innerClasses.putShort(access);\n    }\n\n    public FieldVisitor visitField(final int access, final String name, final String desc, final String signature, final Object value) {\n        return new FieldWriter(this, access, name, desc, signature, value);\n    }\n\n    public MethodVisitor visitMethod(final int access, final String name, final String desc, final String signature, final String[] exceptions) {\n        return new MethodWriter(this, access, name, desc, signature, exceptions, computeMaxs, computeFrames);\n    }\n\n    public void visitEnd() {\n    }\n\n    // ------------------------------------------------------------------------\n    // Other public methods\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the bytecode of the class that was build with this class writer.\n     *\n     * @return the bytecode of the class that was build with this class writer.\n     */\n    public byte[] toByteArray() {\n        // computes the real size of the bytecode of this class\n        int size = 24 + 2 * interfaceCount;\n        int nbFields = 0;\n        FieldWriter fb = firstField;\n        while (fb != null) {\n            ++nbFields;\n            size += fb.getSize();\n            fb = fb.next;\n        }\n        int nbMethods = 0;\n        MethodWriter mb = firstMethod;\n        while (mb != null) {\n            ++nbMethods;\n            size += mb.getSize();\n            mb = mb.next;\n        }\n        int attributeCount = 0;\n        if (ClassReader.SIGNATURES && signature != 0) {\n            ++attributeCount;\n            size += 8;\n            newUTF8(\"Signature\");\n        }\n        if (sourceFile != 0) {\n            ++attributeCount;\n            size += 8;\n            newUTF8(\"SourceFile\");\n        }\n        if (sourceDebug != null) {\n            ++attributeCount;\n            size += sourceDebug.length + 4;\n            newUTF8(\"SourceDebugExtension\");\n        }\n        if (enclosingMethodOwner != 0) {\n            ++attributeCount;\n            size += 10;\n            newUTF8(\"EnclosingMethod\");\n        }\n        if ((access & Opcodes.ACC_DEPRECATED) != 0) {\n            ++attributeCount;\n            size += 6;\n            newUTF8(\"Deprecated\");\n        }\n        if ((access & Opcodes.ACC_SYNTHETIC) != 0 && (version & 0xffff) < Opcodes.V1_5) {\n            ++attributeCount;\n            size += 6;\n            newUTF8(\"Synthetic\");\n        }\n        if (innerClasses != null) {\n            ++attributeCount;\n            size += 8 + innerClasses.length;\n            newUTF8(\"InnerClasses\");\n        }\n        if (ClassReader.ANNOTATIONS && anns != null) {\n            ++attributeCount;\n            size += 8 + anns.getSize();\n            newUTF8(\"RuntimeVisibleAnnotations\");\n        }\n        if (ClassReader.ANNOTATIONS && ianns != null) {\n            ++attributeCount;\n            size += 8 + ianns.getSize();\n            newUTF8(\"RuntimeInvisibleAnnotations\");\n        }\n        if (attrs != null) {\n            attributeCount += attrs.getCount();\n            size += attrs.getSize(this, null, 0, -1, -1);\n        }\n        size += pool.length;\n        // allocates a byte vector of this size, in order to avoid unnecessary\n        // arraycopy operations in the ByteVector.enlarge() method\n        ByteVector out = new ByteVector(size);\n        out.putInt(0xCAFEBABE).putInt(version);\n        out.putShort(index).putByteArray(pool.data, 0, pool.length);\n        out.putShort(access).putShort(name).putShort(superName);\n        out.putShort(interfaceCount);\n        for (int i = 0; i < interfaceCount; ++i) {\n            out.putShort(interfaces[i]);\n        }\n        out.putShort(nbFields);\n        fb = firstField;\n        while (fb != null) {\n            fb.put(out);\n            fb = fb.next;\n        }\n        out.putShort(nbMethods);\n        mb = firstMethod;\n        while (mb != null) {\n            mb.put(out);\n            mb = mb.next;\n        }\n        out.putShort(attributeCount);\n        if (ClassReader.SIGNATURES && signature != 0) {\n            out.putShort(newUTF8(\"Signature\")).putInt(2).putShort(signature);\n        }\n        if (sourceFile != 0) {\n            out.putShort(newUTF8(\"SourceFile\")).putInt(2).putShort(sourceFile);\n        }\n        if (sourceDebug != null) {\n            int len = sourceDebug.length - 2;\n            out.putShort(newUTF8(\"SourceDebugExtension\")).putInt(len);\n            out.putByteArray(sourceDebug.data, 2, len);\n        }\n        if (enclosingMethodOwner != 0) {\n            out.putShort(newUTF8(\"EnclosingMethod\")).putInt(4);\n            out.putShort(enclosingMethodOwner).putShort(enclosingMethod);\n        }\n        if ((access & Opcodes.ACC_DEPRECATED) != 0) {\n            out.putShort(newUTF8(\"Deprecated\")).putInt(0);\n        }\n        if ((access & Opcodes.ACC_SYNTHETIC) != 0 && (version & 0xffff) < Opcodes.V1_5) {\n            out.putShort(newUTF8(\"Synthetic\")).putInt(0);\n        }\n        if (innerClasses != null) {\n            out.putShort(newUTF8(\"InnerClasses\"));\n            out.putInt(innerClasses.length + 2).putShort(innerClassesCount);\n            out.putByteArray(innerClasses.data, 0, innerClasses.length);\n        }\n        if (ClassReader.ANNOTATIONS && anns != null) {\n            out.putShort(newUTF8(\"RuntimeVisibleAnnotations\"));\n            anns.put(out);\n        }\n        if (ClassReader.ANNOTATIONS && ianns != null) {\n            out.putShort(newUTF8(\"RuntimeInvisibleAnnotations\"));\n            ianns.put(out);\n        }\n        if (attrs != null) {\n            attrs.put(this, null, 0, -1, -1, out);\n        }\n        if (invalidFrames) {\n            ClassWriter cw = new ClassWriter(COMPUTE_FRAMES);\n            new ClassReader(out.data).accept(cw, ClassReader.SKIP_FRAMES);\n            return cw.toByteArray();\n        }\n        return out.data;\n    }\n\n    // ------------------------------------------------------------------------\n    // Utility methods: constant pool management\n    // ------------------------------------------------------------------------\n    /**\n     * Adds a number or string constant to the constant pool of the class being\n     * build. Does nothing if the constant pool already contains a similar item.\n     *\n     * @param cst the value of the constant to be added to the constant pool.\n     *        This parameter must be an {@link Integer}, a {@link Float}, a\n     *        {@link Long}, a {@link Double}, a {@link String} or a\n     *        {@link Type}.\n     * @return a new or already existing constant item with the given value.\n     */\n    Item newConstItem(final Object cst) {\n        if (cst instanceof Integer) {\n            int val = ((Integer) cst).intValue();\n            return newInteger(val);\n        } else if (cst instanceof Byte) {\n            int val = ((Byte) cst).intValue();\n            return newInteger(val);\n        } else if (cst instanceof Character) {\n            int val = ((Character) cst).charValue();\n            return newInteger(val);\n        } else if (cst instanceof Short) {\n            int val = ((Short) cst).intValue();\n            return newInteger(val);\n        } else if (cst instanceof Boolean) {\n            int val = ((Boolean) cst).booleanValue() ? 1 : 0;\n            return newInteger(val);\n        } else if (cst instanceof Float) {\n            float val = ((Float) cst).floatValue();\n            return newFloat(val);\n        } else if (cst instanceof Long) {\n            long val = ((Long) cst).longValue();\n            return newLong(val);\n        } else if (cst instanceof Double) {\n            double val = ((Double) cst).doubleValue();\n            return newDouble(val);\n        } else if (cst instanceof String) {\n            return newString((String) cst);\n        } else if (cst instanceof Type) {\n            Type t = (Type) cst;\n            return newClassItem(t.getSort() == Type.OBJECT ? t.getInternalName() : t.getDescriptor());\n        } else {\n            throw new IllegalArgumentException(\"value \" + cst);\n        }\n    }\n\n    /**\n     * Adds a number or string constant to the constant pool of the class being\n     * build. Does nothing if the constant pool already contains a similar item.\n     * <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param cst the value of the constant to be added to the constant pool.\n     *        This parameter must be an {@link Integer}, a {@link Float}, a\n     *        {@link Long}, a {@link Double} or a {@link String}.\n     * @return the index of a new or already existing constant item with the\n     *         given value.\n     */\n    public int newConst(final Object cst) {\n        return newConstItem(cst).index;\n    }\n\n    /**\n     * Adds an UTF8 string to the constant pool of the class being build. Does\n     * nothing if the constant pool already contains a similar item. <i>This\n     * method is intended for {@link Attribute} sub classes, and is normally not\n     * needed by class generators or adapters.</i>\n     *\n     * @param value the String value.\n     * @return the index of a new or already existing UTF8 item.\n     */\n    public int newUTF8(final String value) {\n        key.set(UTF8, value, null, null);\n        Item result = get(key);\n        if (result == null) {\n            pool.putByte(UTF8).putUTF8(value);\n            result = new Item(index++, key);\n            put(result);\n        }\n        return result.index;\n    }\n\n    /**\n     * Adds a class reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     * <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param value the internal name of the class.\n     * @return a new or already existing class reference item.\n     */\n    Item newClassItem(final String value) {\n        key2.set(CLASS, value, null, null);\n        Item result = get(key2);\n        if (result == null) {\n            pool.put12(CLASS, newUTF8(value));\n            result = new Item(index++, key2);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a class reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     * <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param value the internal name of the class.\n     * @return the index of a new or already existing class reference item.\n     */\n    public int newClass(final String value) {\n        return newClassItem(value).index;\n    }\n\n    /**\n     * Adds a field reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     *\n     * @param owner the internal name of the field's owner class.\n     * @param name the field's name.\n     * @param desc the field's descriptor.\n     * @return a new or already existing field reference item.\n     */\n    Item newFieldItem(final String owner, final String name, final String desc) {\n        key3.set(FIELD, owner, name, desc);\n        Item result = get(key3);\n        if (result == null) {\n            put122(FIELD, newClass(owner), newNameType(name, desc));\n            result = new Item(index++, key3);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a field reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     * <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param owner the internal name of the field's owner class.\n     * @param name the field's name.\n     * @param desc the field's descriptor.\n     * @return the index of a new or already existing field reference item.\n     */\n    public int newField(final String owner, final String name, final String desc) {\n        return newFieldItem(owner, name, desc).index;\n    }\n\n    /**\n     * Adds a method reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     *\n     * @param owner the internal name of the method's owner class.\n     * @param name the method's name.\n     * @param desc the method's descriptor.\n     * @param itf <tt>true</tt> if <tt>owner</tt> is an interface.\n     * @return a new or already existing method reference item.\n     */\n    Item newMethodItem(final String owner, final String name, final String desc, final boolean itf) {\n        int type = itf ? IMETH : METH;\n        key3.set(type, owner, name, desc);\n        Item result = get(key3);\n        if (result == null) {\n            put122(type, newClass(owner), newNameType(name, desc));\n            result = new Item(index++, key3);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a method reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     * <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param owner the internal name of the method's owner class.\n     * @param name the method's name.\n     * @param desc the method's descriptor.\n     * @param itf <tt>true</tt> if <tt>owner</tt> is an interface.\n     * @return the index of a new or already existing method reference item.\n     */\n    public int newMethod(final String owner, final String name, final String desc, final boolean itf) {\n        return newMethodItem(owner, name, desc, itf).index;\n    }\n\n    /**\n     * Adds an integer to the constant pool of the class being build. Does\n     * nothing if the constant pool already contains a similar item.\n     *\n     * @param value the int value.\n     * @return a new or already existing int item.\n     */\n    Item newInteger(final int value) {\n        key.set(value);\n        Item result = get(key);\n        if (result == null) {\n            pool.putByte(INT).putInt(value);\n            result = new Item(index++, key);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a float to the constant pool of the class being build. Does nothing\n     * if the constant pool already contains a similar item.\n     *\n     * @param value the float value.\n     * @return a new or already existing float item.\n     */\n    Item newFloat(final float value) {\n        key.set(value);\n        Item result = get(key);\n        if (result == null) {\n            pool.putByte(FLOAT).putInt(key.intVal);\n            result = new Item(index++, key);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a long to the constant pool of the class being build. Does nothing\n     * if the constant pool already contains a similar item.\n     *\n     * @param value the long value.\n     * @return a new or already existing long item.\n     */\n    Item newLong(final long value) {\n        key.set(value);\n        Item result = get(key);\n        if (result == null) {\n            pool.putByte(LONG).putLong(value);\n            result = new Item(index, key);\n            put(result);\n            index += 2;\n        }\n        return result;\n    }\n\n    /**\n     * Adds a double to the constant pool of the class being build. Does nothing\n     * if the constant pool already contains a similar item.\n     *\n     * @param value the double value.\n     * @return a new or already existing double item.\n     */\n    Item newDouble(final double value) {\n        key.set(value);\n        Item result = get(key);\n        if (result == null) {\n            pool.putByte(DOUBLE).putLong(key.longVal);\n            result = new Item(index, key);\n            put(result);\n            index += 2;\n        }\n        return result;\n    }\n\n    /**\n     * Adds a string to the constant pool of the class being build. Does nothing\n     * if the constant pool already contains a similar item.\n     *\n     * @param value the String value.\n     * @return a new or already existing string item.\n     */\n    private Item newString(final String value) {\n        key2.set(STR, value, null, null);\n        Item result = get(key2);\n        if (result == null) {\n            pool.put12(STR, newUTF8(value));\n            result = new Item(index++, key2);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a name and type to the constant pool of the class being build. Does\n     * nothing if the constant pool already contains a similar item. <i>This\n     * method is intended for {@link Attribute} sub classes, and is normally not\n     * needed by class generators or adapters.</i>\n     *\n     * @param name a name.\n     * @param desc a type descriptor.\n     * @return the index of a new or already existing name and type item.\n     */\n    public int newNameType(final String name, final String desc) {\n        return newNameTypeItem(name, desc).index;\n    }\n\n    /**\n     * Adds a name and type to the constant pool of the class being build. Does\n     * nothing if the constant pool already contains a similar item.\n     *\n     * @param name a name.\n     * @param desc a type descriptor.\n     * @return a new or already existing name and type item.\n     */\n    Item newNameTypeItem(final String name, final String desc) {\n        key2.set(NAME_TYPE, name, desc, null);\n        Item result = get(key2);\n        if (result == null) {\n            put122(NAME_TYPE, newUTF8(name), newUTF8(desc));\n            result = new Item(index++, key2);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds the given internal name to {@link #typeTable} and returns its index.\n     * Does nothing if the type table already contains this internal name.\n     *\n     * @param type the internal name to be added to the type table.\n     * @return the index of this internal name in the type table.\n     */\n    int addType(final String type) {\n        key.set(TYPE_NORMAL, type, null, null);\n        Item result = get(key);\n        if (result == null) {\n            result = addType(key);\n        }\n        return result.index;\n    }\n\n    /**\n     * Adds the given \"uninitialized\" type to {@link #typeTable} and returns its\n     * index. This method is used for UNINITIALIZED types, made of an internal\n     * name and a bytecode offset.\n     *\n     * @param type the internal name to be added to the type table.\n     * @param offset the bytecode offset of the NEW instruction that created\n     *        this UNINITIALIZED type value.\n     * @return the index of this internal name in the type table.\n     */\n    int addUninitializedType(final String type, final int offset) {\n        key.type = TYPE_UNINIT;\n        key.intVal = offset;\n        key.strVal1 = type;\n        key.hashCode = 0x7FFFFFFF & (TYPE_UNINIT + type.hashCode() + offset);\n        Item result = get(key);\n        if (result == null) {\n            result = addType(key);\n        }\n        return result.index;\n    }\n\n    /**\n     * Adds the given Item to {@link #typeTable}.\n     *\n     * @param item the value to be added to the type table.\n     * @return the added Item, which a new Item instance with the same value as\n     *         the given Item.\n     */\n    private Item addType(final Item item) {\n        ++typeCount;\n        Item result = new Item(typeCount, key);\n        put(result);\n        if (typeTable == null) {\n            typeTable = new Item[16];\n        }\n        if (typeCount == typeTable.length) {\n            Item[] newTable = new Item[2 * typeTable.length];\n            System.arraycopy(typeTable, 0, newTable, 0, typeTable.length);\n            typeTable = newTable;\n        }\n        typeTable[typeCount] = result;\n        return result;\n    }\n\n    /**\n     * Returns the index of the common super type of the two given types. This\n     * method calls {@link #getCommonSuperClass} and caches the result in the\n     * {@link #items} hash table to speedup future calls with the same\n     * parameters.\n     *\n     * @param type1 index of an internal name in {@link #typeTable}.\n     * @param type2 index of an internal name in {@link #typeTable}.\n     * @return the index of the common super type of the two given types.\n     */\n    int getMergedType(final int type1, final int type2) {\n        key2.type = TYPE_MERGED;\n        key2.longVal = type1 | (((long) type2) << 32);\n        key2.hashCode = 0x7FFFFFFF & (TYPE_MERGED + type1 + type2);\n        Item result = get(key2);\n        if (result == null) {\n            String t = typeTable[type1].strVal1;\n            String u = typeTable[type2].strVal1;\n            key2.intVal = addType(getCommonSuperClass(t, u));\n            result = new Item((short) 0, key2);\n            put(result);\n        }\n        return result.intVal;\n    }\n\n    /**\n     * Returns the common super type of the two given types. The default\n     * implementation of this method <i>loads<i> the two given classes and uses\n     * the java.lang.Class methods to find the common super class. It can be\n     * overridden to compute this common super type in other ways, in particular\n     * without actually loading any class, or to take into account the class\n     * that is currently being generated by this ClassWriter, which can of\n     * course not be loaded since it is under construction.\n     *\n     * @param type1 the internal name of a class.\n     * @param type2 the internal name of another class.\n     * @return the internal name of the common super class of the two given\n     *         classes.\n     */\n    protected String getCommonSuperClass(final String type1, final String type2) {\n        Class c, d;\n        try {\n            c = Class.forName(type1.replace('/', '.'));\n            d = Class.forName(type2.replace('/', '.'));\n        } catch (Exception e) {\n            throw new RuntimeException(e.toString());\n        }\n        if (c.isAssignableFrom(d)) {\n            return type1;\n        }\n        if (d.isAssignableFrom(c)) {\n            return type2;\n        }\n        if (c.isInterface() || d.isInterface()) {\n            return \"java/lang/Object\";\n        } else {\n            do {\n                c = c.getSuperclass();\n            } while (!c.isAssignableFrom(d));\n            return c.getName().replace('.', '/');\n        }\n    }\n\n    /**\n     * Returns the constant pool's hash table item which is equal to the given\n     * item.\n     *\n     * @param key a constant pool item.\n     * @return the constant pool's hash table item which is equal to the given\n     *         item, or <tt>null</tt> if there is no such item.\n     */\n    private Item get(final Item key) {\n        Item i = items[key.hashCode % items.length];\n        while (i != null && (i.type != key.type || !key.isEqualTo(i))) {\n            i = i.next;\n        }\n        return i;\n    }\n\n    /**\n     * Puts the given item in the constant pool's hash table. The hash table\n     * <i>must</i> not already contains this item.\n     *\n     * @param i the item to be added to the constant pool's hash table.\n     */\n    private void put(final Item i) {\n        if (index > threshold) {\n            int ll = items.length;\n            int nl = ll * 2 + 1;\n            Item[] newItems = new Item[nl];\n            for (int l = ll - 1; l >= 0; --l) {\n                Item j = items[l];\n                while (j != null) {\n                    int index = j.hashCode % newItems.length;\n                    Item k = j.next;\n                    j.next = newItems[index];\n                    newItems[index] = j;\n                    j = k;\n                }\n            }\n            items = newItems;\n            threshold = (int) (nl * 0.75);\n        }\n        int index = i.hashCode % items.length;\n        i.next = items[index];\n        items[index] = i;\n    }\n\n    /**\n     * Puts one byte and two shorts into the constant pool.\n     *\n     * @param b a byte.\n     * @param s1 a short.\n     * @param s2 another short.\n     */\n    private void put122(final int b, final int s1, final int s2) {\n        pool.put12(b, s1).putShort(s2);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/ClassWriterTest5.java",
		"test_prompt": "// ClassWriterTest5.java\npackage org.objectweb.asm.jip;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassWriter}.\n* It contains ten unit test cases for the {@link ClassWriter#newUTF8(String)} method.\n*/\nclass ClassWriterTest5 {"
	},
	{
		"original_code": "// ClassWriter.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\n/**\n * A {@link ClassVisitor} that generates classes in bytecode form. More\n * precisely this visitor generates a byte array conforming to the Java class\n * file format. It can be used alone, to generate a Java class \"from scratch\",\n * or with one or more {@link ClassReader ClassReader} and adapter class visitor\n * to generate a modified class from one or more existing Java classes.\n *\n * @author Eric Bruneton\n */\npublic class ClassWriter implements ClassVisitor {\n\n    /**\n     * Flag to automatically compute the maximum stack size and the maximum\n     * number of local variables of methods. If this flag is set, then the\n     * arguments of the {@link MethodVisitor#visitMaxs visitMaxs} method of the\n     * {@link MethodVisitor} returned by the {@link #visitMethod visitMethod}\n     * method will be ignored, and computed automatically from the signature and\n     * the bytecode of each method.\n     *\n     * @see #ClassWriter(int)\n     */\n    public static final int COMPUTE_MAXS = 1;\n\n    /**\n     * Flag to automatically compute the stack map frames of methods from\n     * scratch. If this flag is set, then the calls to the\n     * {@link MethodVisitor#visitFrame} method are ignored, and the stack map\n     * frames are recomputed from the methods bytecode. The arguments of the\n     * {@link MethodVisitor#visitMaxs visitMaxs} method are also ignored and\n     * recomputed from the bytecode. In other words, computeFrames implies\n     * computeMaxs.\n     *\n     * @see #ClassWriter(int)\n     */\n    public static final int COMPUTE_FRAMES = 2;\n\n    /**\n     * The type of instructions without any argument.\n     */\n    static final int NOARG_INSN = 0;\n\n    /**\n     * The type of instructions with an signed byte argument.\n     */\n    static final int SBYTE_INSN = 1;\n\n    /**\n     * The type of instructions with an signed short argument.\n     */\n    static final int SHORT_INSN = 2;\n\n    /**\n     * The type of instructions with a local variable index argument.\n     */\n    static final int VAR_INSN = 3;\n\n    /**\n     * The type of instructions with an implicit local variable index argument.\n     */\n    static final int IMPLVAR_INSN = 4;\n\n    /**\n     * The type of instructions with a type descriptor argument.\n     */\n    static final int TYPE_INSN = 5;\n\n    /**\n     * The type of field and method invocations instructions.\n     */\n    static final int FIELDORMETH_INSN = 6;\n\n    /**\n     * The type of the INVOKEINTERFACE/INVOKEDYNAMIC instruction.\n     */\n    static final int ITFDYNMETH_INSN = 7;\n\n    /**\n     * The type of instructions with a 2 bytes bytecode offset label.\n     */\n    static final int LABEL_INSN = 8;\n\n    /**\n     * The type of instructions with a 4 bytes bytecode offset label.\n     */\n    static final int LABELW_INSN = 9;\n\n    /**\n     * The type of the LDC instruction.\n     */\n    static final int LDC_INSN = 10;\n\n    /**\n     * The type of the LDC_W and LDC2_W instructions.\n     */\n    static final int LDCW_INSN = 11;\n\n    /**\n     * The type of the IINC instruction.\n     */\n    static final int IINC_INSN = 12;\n\n    /**\n     * The type of the TABLESWITCH instruction.\n     */\n    static final int TABL_INSN = 13;\n\n    /**\n     * The type of the LOOKUPSWITCH instruction.\n     */\n    static final int LOOK_INSN = 14;\n\n    /**\n     * The type of the MULTIANEWARRAY instruction.\n     */\n    static final int MANA_INSN = 15;\n\n    /**\n     * The type of the WIDE instruction.\n     */\n    static final int WIDE_INSN = 16;\n\n    /**\n     * The instruction types of all JVM opcodes.\n     */\n    static final byte[] TYPE;\n\n    /**\n     * The type of CONSTANT_Class constant pool items.\n     */\n    static final int CLASS = 7;\n\n    /**\n     * The type of CONSTANT_Fieldref constant pool items.\n     */\n    static final int FIELD = 9;\n\n    /**\n     * The type of CONSTANT_Methodref constant pool items.\n     */\n    static final int METH = 10;\n\n    /**\n     * The type of CONSTANT_InterfaceMethodref constant pool items.\n     */\n    static final int IMETH = 11;\n\n    /**\n     * The type of CONSTANT_String constant pool items.\n     */\n    static final int STR = 8;\n\n    /**\n     * The type of CONSTANT_Integer constant pool items.\n     */\n    static final int INT = 3;\n\n    /**\n     * The type of CONSTANT_Float constant pool items.\n     */\n    static final int FLOAT = 4;\n\n    /**\n     * The type of CONSTANT_Long constant pool items.\n     */\n    static final int LONG = 5;\n\n    /**\n     * The type of CONSTANT_Double constant pool items.\n     */\n    static final int DOUBLE = 6;\n\n    /**\n     * The type of CONSTANT_NameAndType constant pool items.\n     */\n    static final int NAME_TYPE = 12;\n\n    /**\n     * The type of CONSTANT_Utf8 constant pool items.\n     */\n    static final int UTF8 = 1;\n\n    /**\n     * Normal type Item stored in the ClassWriter {@link ClassWriter#typeTable},\n     * instead of the constant pool, in order to avoid clashes with normal\n     * constant pool items in the ClassWriter constant pool's hash table.\n     */\n    static final int TYPE_NORMAL = 13;\n\n    /**\n     * Uninitialized type Item stored in the ClassWriter\n     * {@link ClassWriter#typeTable}, instead of the constant pool, in order to\n     * avoid clashes with normal constant pool items in the ClassWriter constant\n     * pool's hash table.\n     */\n    static final int TYPE_UNINIT = 14;\n\n    /**\n     * Merged type Item stored in the ClassWriter {@link ClassWriter#typeTable},\n     * instead of the constant pool, in order to avoid clashes with normal\n     * constant pool items in the ClassWriter constant pool's hash table.\n     */\n    static final int TYPE_MERGED = 15;\n\n    /**\n     * The class reader from which this class writer was constructed, if any.\n     */\n    ClassReader cr;\n\n    /**\n     * Minor and major version numbers of the class to be generated.\n     */\n    int version;\n\n    /**\n     * Index of the next item to be added in the constant pool.\n     */\n    int index;\n\n    /**\n     * The constant pool of this class.\n     */\n    final ByteVector pool;\n\n    /**\n     * The constant pool's hash table data.\n     */\n    Item[] items;\n\n    /**\n     * The threshold of the constant pool's hash table.\n     */\n    int threshold;\n\n    /**\n     * A reusable key used to look for items in the {@link #items} hash table.\n     */\n    final Item key;\n\n    /**\n     * A reusable key used to look for items in the {@link #items} hash table.\n     */\n    final Item key2;\n\n    /**\n     * A reusable key used to look for items in the {@link #items} hash table.\n     */\n    final Item key3;\n\n    /**\n     * A type table used to temporarily store internal names that will not\n     * necessarily be stored in the constant pool. This type table is used by\n     * the control flow and data flow analysis algorithm used to compute stack\n     * map frames from scratch. This array associates to each index <tt>i</tt>\n     * the Item whose index is <tt>i</tt>. All Item objects stored in this\n     * array are also stored in the {@link #items} hash table. These two arrays\n     * allow to retrieve an Item from its index or, conversely, to get the index\n     * of an Item from its value. Each Item stores an internal name in its\n     * {@link Item#strVal1} field.\n     */\n    Item[] typeTable;\n\n    /**\n     * Number of elements in the {@link #typeTable} array.\n     */\n    private short typeCount;\n\n    /**\n     * The access flags of this class.\n     */\n    private int access;\n\n    /**\n     * The constant pool item that contains the internal name of this class.\n     */\n    private int name;\n\n    /**\n     * The internal name of this class.\n     */\n    String thisName;\n\n    /**\n     * The constant pool item that contains the signature of this class.\n     */\n    private int signature;\n\n    /**\n     * The constant pool item that contains the internal name of the super class\n     * of this class.\n     */\n    private int superName;\n\n    /**\n     * Number of interfaces implemented or extended by this class or interface.\n     */\n    private int interfaceCount;\n\n    /**\n     * The interfaces implemented or extended by this class or interface. More\n     * precisely, this array contains the indexes of the constant pool items\n     * that contain the internal names of these interfaces.\n     */\n    private int[] interfaces;\n\n    /**\n     * The index of the constant pool item that contains the name of the source\n     * file from which this class was compiled.\n     */\n    private int sourceFile;\n\n    /**\n     * The SourceDebug attribute of this class.\n     */\n    private ByteVector sourceDebug;\n\n    /**\n     * The constant pool item that contains the name of the enclosing class of\n     * this class.\n     */\n    private int enclosingMethodOwner;\n\n    /**\n     * The constant pool item that contains the name and descriptor of the\n     * enclosing method of this class.\n     */\n    private int enclosingMethod;\n\n    /**\n     * The runtime visible annotations of this class.\n     */\n    private AnnotationWriter anns;\n\n    /**\n     * The runtime invisible annotations of this class.\n     */\n    private AnnotationWriter ianns;\n\n    /**\n     * The non standard attributes of this class.\n     */\n    private Attribute attrs;\n\n    /**\n     * The number of entries in the InnerClasses attribute.\n     */\n    private int innerClassesCount;\n\n    /**\n     * The InnerClasses attribute.\n     */\n    private ByteVector innerClasses;\n\n    /**\n     * The fields of this class. These fields are stored in a linked list of\n     * {@link FieldWriter} objects, linked to each other by their\n     * {@link FieldWriter#next} field. This field stores the first element of\n     * this list.\n     */\n    FieldWriter firstField;\n\n    /**\n     * The fields of this class. These fields are stored in a linked list of\n     * {@link FieldWriter} objects, linked to each other by their\n     * {@link FieldWriter#next} field. This field stores the last element of\n     * this list.\n     */\n    FieldWriter lastField;\n\n    /**\n     * The methods of this class. These methods are stored in a linked list of\n     * {@link MethodWriter} objects, linked to each other by their\n     * {@link MethodWriter#next} field. This field stores the first element of\n     * this list.\n     */\n    MethodWriter firstMethod;\n\n    /**\n     * The methods of this class. These methods are stored in a linked list of\n     * {@link MethodWriter} objects, linked to each other by their\n     * {@link MethodWriter#next} field. This field stores the last element of\n     * this list.\n     */\n    MethodWriter lastMethod;\n\n    /**\n     * <tt>true</tt> if the maximum stack size and number of local variables\n     * must be automatically computed.\n     */\n    private final boolean computeMaxs;\n\n    /**\n     * <tt>true</tt> if the stack map frames must be recomputed from scratch.\n     */\n    private final boolean computeFrames;\n\n    /**\n     * <tt>true</tt> if the stack map tables of this class are invalid. The\n     * {@link MethodWriter#resizeInstructions} method cannot transform existing\n     * stack map tables, and so produces potentially invalid classes when it is\n     * executed. In this case the class is reread and rewritten with the\n     * {@link #COMPUTE_FRAMES} option (the resizeInstructions method can resize\n     * stack map tables when this option is used).\n     */\n    boolean invalidFrames;\n\n    // ------------------------------------------------------------------------\n    // Static initializer\n    // ------------------------------------------------------------------------\n    /**\n     * Computes the instruction types of JVM opcodes.\n     */\n    static {\n        int i;\n        byte[] b = new byte[220];\n        String s = \"AAAAAAAAAAAAAAAABCKLLDDDDDEEEEEEEEEEEEEEEEEEEEAAAAAAAADD\" + \"DDDEEEEEEEEEEEEEEEEEEEEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAAIIIIIIIIIIIIIIIIDNOAA\" + \"AAAAGGGGGGGHHFBFAAFFAAQPIIJJIIIIIIIIIIIIIIIIII\";\n        for (i = 0; i < b.length; ++i) {\n            b[i] = (byte) (s.charAt(i) - 'A');\n        }\n        TYPE = b;\n        // code to generate the above string\n        //\n        // // SBYTE_INSN instructions\n        // b[Constants.NEWARRAY] = SBYTE_INSN;\n        // b[Constants.BIPUSH] = SBYTE_INSN;\n        //\n        // // SHORT_INSN instructions\n        // b[Constants.SIPUSH] = SHORT_INSN;\n        //\n        // // (IMPL)VAR_INSN instructions\n        // b[Constants.RET] = VAR_INSN;\n        // for (i = Constants.ILOAD; i <= Constants.ALOAD; ++i) {\n        // b[i] = VAR_INSN;\n        // }\n        // for (i = Constants.ISTORE; i <= Constants.ASTORE; ++i) {\n        // b[i] = VAR_INSN;\n        // }\n        // for (i = 26; i <= 45; ++i) { // ILOAD_0 to ALOAD_3\n        // b[i] = IMPLVAR_INSN;\n        // }\n        // for (i = 59; i <= 78; ++i) { // ISTORE_0 to ASTORE_3\n        // b[i] = IMPLVAR_INSN;\n        // }\n        //\n        // // TYPE_INSN instructions\n        // b[Constants.NEW] = TYPE_INSN;\n        // b[Constants.ANEWARRAY] = TYPE_INSN;\n        // b[Constants.CHECKCAST] = TYPE_INSN;\n        // b[Constants.INSTANCEOF] = TYPE_INSN;\n        //\n        // // (Set)FIELDORMETH_INSN instructions\n        // for (i = Constants.GETSTATIC; i <= Constants.INVOKESTATIC; ++i) {\n        // b[i] = FIELDORMETH_INSN;\n        // }\n        // b[Constants.INVOKEINTERFACE] = ITFDYNMETH_INSN;\n        // b[Constants.INVOKEDYNAMIC] = ITFDYNMETH_INSN;\n        //\n        // // LABEL(W)_INSN instructions\n        // for (i = Constants.IFEQ; i <= Constants.JSR; ++i) {\n        // b[i] = LABEL_INSN;\n        // }\n        // b[Constants.IFNULL] = LABEL_INSN;\n        // b[Constants.IFNONNULL] = LABEL_INSN;\n        // b[200] = LABELW_INSN; // GOTO_W\n        // b[201] = LABELW_INSN; // JSR_W\n        // // temporary opcodes used internally by ASM - see Label and\n        // MethodWriter\n        // for (i = 202; i < 220; ++i) {\n        // b[i] = LABEL_INSN;\n        // }\n        //\n        // // LDC(_W) instructions\n        // b[Constants.LDC] = LDC_INSN;\n        // b[19] = LDCW_INSN; // LDC_W\n        // b[20] = LDCW_INSN; // LDC2_W\n        //\n        // // special instructions\n        // b[Constants.IINC] = IINC_INSN;\n        // b[Constants.TABLESWITCH] = TABL_INSN;\n        // b[Constants.LOOKUPSWITCH] = LOOK_INSN;\n        // b[Constants.MULTIANEWARRAY] = MANA_INSN;\n        // b[196] = WIDE_INSN; // WIDE\n        //\n        // for (i = 0; i < b.length; ++i) {\n        // System.err.print((char)('A' + b[i]));\n        // }\n        // System.err.println();\n    }\n\n    // ------------------------------------------------------------------------\n    // Constructor\n    // ------------------------------------------------------------------------\n    /**\n     * Constructs a new {@link ClassWriter} object.\n     *\n     * @param flags option flags that can be used to modify the default behavior\n     *        of this class. See {@link #COMPUTE_MAXS}, {@link #COMPUTE_FRAMES}.\n     */\n    public ClassWriter(final int flags) {\n        index = 1;\n        pool = new ByteVector();\n        items = new Item[256];\n        threshold = (int) (0.75d * items.length);\n        key = new Item();\n        key2 = new Item();\n        key3 = new Item();\n        this.computeMaxs = (flags & COMPUTE_MAXS) != 0;\n        this.computeFrames = (flags & COMPUTE_FRAMES) != 0;\n    }\n\n    /**\n     * Constructs a new {@link ClassWriter} object and enables optimizations for\n     * \"mostly add\" bytecode transformations. These optimizations are the\n     * following:\n     *\n     * <ul> <li>The constant pool from the original class is copied as is in\n     * the new class, which saves time. New constant pool entries will be added\n     * at the end if necessary, but unused constant pool entries <i>won't be\n     * removed</i>.</li> <li>Methods that are not transformed are copied as\n     * is in the new class, directly from the original class bytecode (i.e.\n     * without emitting visit events for all the method instructions), which\n     * saves a <i>lot</i> of time. Untransformed methods are detected by the\n     * fact that the {@link ClassReader} receives {@link MethodVisitor} objects\n     * that come from a {@link ClassWriter} (and not from a custom\n     * {@link ClassAdapter} or any other {@link ClassVisitor} instance).</li>\n     * </ul>\n     *\n     * @param classReader the {@link ClassReader} used to read the original\n     *        class. It will be used to copy the entire constant pool from the\n     *        original class and also to copy other fragments of original\n     *        bytecode where applicable.\n     * @param flags option flags that can be used to modify the default behavior\n     *        of this class. See {@link #COMPUTE_MAXS}, {@link #COMPUTE_FRAMES}.\n     */\n    public ClassWriter(final ClassReader classReader, final int flags) {\n        this(flags);\n        classReader.copyPool(this);\n        this.cr = classReader;\n    }\n\n    // ------------------------------------------------------------------------\n    // Implementation of the ClassVisitor interface\n    // ------------------------------------------------------------------------\n    public void visit(final int version, final int access, final String name, final String signature, final String superName, final String[] interfaces) {\n        this.version = version;\n        this.access = access;\n        this.name = newClass(name);\n        thisName = name;\n        if (ClassReader.SIGNATURES && signature != null) {\n            this.signature = newUTF8(signature);\n        }\n        this.superName = superName == null ? 0 : newClass(superName);\n        if (interfaces != null && interfaces.length > 0) {\n            interfaceCount = interfaces.length;\n            this.interfaces = new int[interfaceCount];\n            for (int i = 0; i < interfaceCount; ++i) {\n                this.interfaces[i] = newClass(interfaces[i]);\n            }\n        }\n    }\n\n    public void visitSource(final String file, final String debug) {\n        if (file != null) {\n            sourceFile = newUTF8(file);\n        }\n        if (debug != null) {\n            sourceDebug = new ByteVector().putUTF8(debug);\n        }\n    }\n\n    public void visitOuterClass(final String owner, final String name, final String desc) {\n        enclosingMethodOwner = newClass(owner);\n        if (name != null && desc != null) {\n            enclosingMethod = newNameType(name, desc);\n        }\n    }\n\n    public AnnotationVisitor visitAnnotation(final String desc, final boolean visible) {\n        if (!ClassReader.ANNOTATIONS) {\n            return null;\n        }\n        ByteVector bv = new ByteVector();\n        // write type, and reserve space for values count\n        bv.putShort(newUTF8(desc)).putShort(0);\n        AnnotationWriter aw = new AnnotationWriter(this, true, bv, bv, 2);\n        if (visible) {\n            aw.next = anns;\n            anns = aw;\n        } else {\n            aw.next = ianns;\n            ianns = aw;\n        }\n        return aw;\n    }\n\n    public void visitAttribute(final Attribute attr) {\n        attr.next = attrs;\n        attrs = attr;\n    }\n\n    public void visitInnerClass(final String name, final String outerName, final String innerName, final int access) {\n        if (innerClasses == null) {\n            innerClasses = new ByteVector();\n        }\n        ++innerClassesCount;\n        innerClasses.putShort(name == null ? 0 : newClass(name));\n        innerClasses.putShort(outerName == null ? 0 : newClass(outerName));\n        innerClasses.putShort(innerName == null ? 0 : newUTF8(innerName));\n        innerClasses.putShort(access);\n    }\n\n    public FieldVisitor visitField(final int access, final String name, final String desc, final String signature, final Object value) {\n        return new FieldWriter(this, access, name, desc, signature, value);\n    }\n\n    public MethodVisitor visitMethod(final int access, final String name, final String desc, final String signature, final String[] exceptions) {\n        return new MethodWriter(this, access, name, desc, signature, exceptions, computeMaxs, computeFrames);\n    }\n\n    public void visitEnd() {\n    }\n\n    // ------------------------------------------------------------------------\n    // Other public methods\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the bytecode of the class that was build with this class writer.\n     *\n     * @return the bytecode of the class that was build with this class writer.\n     */\n    public byte[] toByteArray() {\n        // computes the real size of the bytecode of this class\n        int size = 24 + 2 * interfaceCount;\n        int nbFields = 0;\n        FieldWriter fb = firstField;\n        while (fb != null) {\n            ++nbFields;\n            size += fb.getSize();\n            fb = fb.next;\n        }\n        int nbMethods = 0;\n        MethodWriter mb = firstMethod;\n        while (mb != null) {\n            ++nbMethods;\n            size += mb.getSize();\n            mb = mb.next;\n        }\n        int attributeCount = 0;\n        if (ClassReader.SIGNATURES && signature != 0) {\n            ++attributeCount;\n            size += 8;\n            newUTF8(\"Signature\");\n        }\n        if (sourceFile != 0) {\n            ++attributeCount;\n            size += 8;\n            newUTF8(\"SourceFile\");\n        }\n        if (sourceDebug != null) {\n            ++attributeCount;\n            size += sourceDebug.length + 4;\n            newUTF8(\"SourceDebugExtension\");\n        }\n        if (enclosingMethodOwner != 0) {\n            ++attributeCount;\n            size += 10;\n            newUTF8(\"EnclosingMethod\");\n        }\n        if ((access & Opcodes.ACC_DEPRECATED) != 0) {\n            ++attributeCount;\n            size += 6;\n            newUTF8(\"Deprecated\");\n        }\n        if ((access & Opcodes.ACC_SYNTHETIC) != 0 && (version & 0xffff) < Opcodes.V1_5) {\n            ++attributeCount;\n            size += 6;\n            newUTF8(\"Synthetic\");\n        }\n        if (innerClasses != null) {\n            ++attributeCount;\n            size += 8 + innerClasses.length;\n            newUTF8(\"InnerClasses\");\n        }\n        if (ClassReader.ANNOTATIONS && anns != null) {\n            ++attributeCount;\n            size += 8 + anns.getSize();\n            newUTF8(\"RuntimeVisibleAnnotations\");\n        }\n        if (ClassReader.ANNOTATIONS && ianns != null) {\n            ++attributeCount;\n            size += 8 + ianns.getSize();\n            newUTF8(\"RuntimeInvisibleAnnotations\");\n        }\n        if (attrs != null) {\n            attributeCount += attrs.getCount();\n            size += attrs.getSize(this, null, 0, -1, -1);\n        }\n        size += pool.length;\n        // allocates a byte vector of this size, in order to avoid unnecessary\n        // arraycopy operations in the ByteVector.enlarge() method\n        ByteVector out = new ByteVector(size);\n        out.putInt(0xCAFEBABE).putInt(version);\n        out.putShort(index).putByteArray(pool.data, 0, pool.length);\n        out.putShort(access).putShort(name).putShort(superName);\n        out.putShort(interfaceCount);\n        for (int i = 0; i < interfaceCount; ++i) {\n            out.putShort(interfaces[i]);\n        }\n        out.putShort(nbFields);\n        fb = firstField;\n        while (fb != null) {\n            fb.put(out);\n            fb = fb.next;\n        }\n        out.putShort(nbMethods);\n        mb = firstMethod;\n        while (mb != null) {\n            mb.put(out);\n            mb = mb.next;\n        }\n        out.putShort(attributeCount);\n        if (ClassReader.SIGNATURES && signature != 0) {\n            out.putShort(newUTF8(\"Signature\")).putInt(2).putShort(signature);\n        }\n        if (sourceFile != 0) {\n            out.putShort(newUTF8(\"SourceFile\")).putInt(2).putShort(sourceFile);\n        }\n        if (sourceDebug != null) {\n            int len = sourceDebug.length - 2;\n            out.putShort(newUTF8(\"SourceDebugExtension\")).putInt(len);\n            out.putByteArray(sourceDebug.data, 2, len);\n        }\n        if (enclosingMethodOwner != 0) {\n            out.putShort(newUTF8(\"EnclosingMethod\")).putInt(4);\n            out.putShort(enclosingMethodOwner).putShort(enclosingMethod);\n        }\n        if ((access & Opcodes.ACC_DEPRECATED) != 0) {\n            out.putShort(newUTF8(\"Deprecated\")).putInt(0);\n        }\n        if ((access & Opcodes.ACC_SYNTHETIC) != 0 && (version & 0xffff) < Opcodes.V1_5) {\n            out.putShort(newUTF8(\"Synthetic\")).putInt(0);\n        }\n        if (innerClasses != null) {\n            out.putShort(newUTF8(\"InnerClasses\"));\n            out.putInt(innerClasses.length + 2).putShort(innerClassesCount);\n            out.putByteArray(innerClasses.data, 0, innerClasses.length);\n        }\n        if (ClassReader.ANNOTATIONS && anns != null) {\n            out.putShort(newUTF8(\"RuntimeVisibleAnnotations\"));\n            anns.put(out);\n        }\n        if (ClassReader.ANNOTATIONS && ianns != null) {\n            out.putShort(newUTF8(\"RuntimeInvisibleAnnotations\"));\n            ianns.put(out);\n        }\n        if (attrs != null) {\n            attrs.put(this, null, 0, -1, -1, out);\n        }\n        if (invalidFrames) {\n            ClassWriter cw = new ClassWriter(COMPUTE_FRAMES);\n            new ClassReader(out.data).accept(cw, ClassReader.SKIP_FRAMES);\n            return cw.toByteArray();\n        }\n        return out.data;\n    }\n\n    // ------------------------------------------------------------------------\n    // Utility methods: constant pool management\n    // ------------------------------------------------------------------------\n    /**\n     * Adds a number or string constant to the constant pool of the class being\n     * build. Does nothing if the constant pool already contains a similar item.\n     *\n     * @param cst the value of the constant to be added to the constant pool.\n     *        This parameter must be an {@link Integer}, a {@link Float}, a\n     *        {@link Long}, a {@link Double}, a {@link String} or a\n     *        {@link Type}.\n     * @return a new or already existing constant item with the given value.\n     */\n    Item newConstItem(final Object cst) {\n        if (cst instanceof Integer) {\n            int val = ((Integer) cst).intValue();\n            return newInteger(val);\n        } else if (cst instanceof Byte) {\n            int val = ((Byte) cst).intValue();\n            return newInteger(val);\n        } else if (cst instanceof Character) {\n            int val = ((Character) cst).charValue();\n            return newInteger(val);\n        } else if (cst instanceof Short) {\n            int val = ((Short) cst).intValue();\n            return newInteger(val);\n        } else if (cst instanceof Boolean) {\n            int val = ((Boolean) cst).booleanValue() ? 1 : 0;\n            return newInteger(val);\n        } else if (cst instanceof Float) {\n            float val = ((Float) cst).floatValue();\n            return newFloat(val);\n        } else if (cst instanceof Long) {\n            long val = ((Long) cst).longValue();\n            return newLong(val);\n        } else if (cst instanceof Double) {\n            double val = ((Double) cst).doubleValue();\n            return newDouble(val);\n        } else if (cst instanceof String) {\n            return newString((String) cst);\n        } else if (cst instanceof Type) {\n            Type t = (Type) cst;\n            return newClassItem(t.getSort() == Type.OBJECT ? t.getInternalName() : t.getDescriptor());\n        } else {\n            throw new IllegalArgumentException(\"value \" + cst);\n        }\n    }\n\n    /**\n     * Adds a number or string constant to the constant pool of the class being\n     * build. Does nothing if the constant pool already contains a similar item.\n     * <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param cst the value of the constant to be added to the constant pool.\n     *        This parameter must be an {@link Integer}, a {@link Float}, a\n     *        {@link Long}, a {@link Double} or a {@link String}.\n     * @return the index of a new or already existing constant item with the\n     *         given value.\n     */\n    public int newConst(final Object cst) {\n        return newConstItem(cst).index;\n    }\n\n    /**\n     * Adds an UTF8 string to the constant pool of the class being build. Does\n     * nothing if the constant pool already contains a similar item. <i>This\n     * method is intended for {@link Attribute} sub classes, and is normally not\n     * needed by class generators or adapters.</i>\n     *\n     * @param value the String value.\n     * @return the index of a new or already existing UTF8 item.\n     */\n    public int newUTF8(final String value) {\n        key.set(UTF8, value, null, null);\n        Item result = get(key);\n        if (result == null) {\n            pool.putByte(UTF8).putUTF8(value);\n            result = new Item(index++, key);\n            put(result);\n        }\n        return result.index;\n    }\n\n    /**\n     * Adds a class reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     * <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param value the internal name of the class.\n     * @return a new or already existing class reference item.\n     */\n    Item newClassItem(final String value) {\n        key2.set(CLASS, value, null, null);\n        Item result = get(key2);\n        if (result == null) {\n            pool.put12(CLASS, newUTF8(value));\n            result = new Item(index++, key2);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a class reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     * <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param value the internal name of the class.\n     * @return the index of a new or already existing class reference item.\n     */\n    public int newClass(final String value) {\n        return newClassItem(value).index;\n    }\n\n    /**\n     * Adds a field reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     *\n     * @param owner the internal name of the field's owner class.\n     * @param name the field's name.\n     * @param desc the field's descriptor.\n     * @return a new or already existing field reference item.\n     */\n    Item newFieldItem(final String owner, final String name, final String desc) {\n        key3.set(FIELD, owner, name, desc);\n        Item result = get(key3);\n        if (result == null) {\n            put122(FIELD, newClass(owner), newNameType(name, desc));\n            result = new Item(index++, key3);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a field reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     * <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param owner the internal name of the field's owner class.\n     * @param name the field's name.\n     * @param desc the field's descriptor.\n     * @return the index of a new or already existing field reference item.\n     */\n    public int newField(final String owner, final String name, final String desc) {\n        return newFieldItem(owner, name, desc).index;\n    }\n\n    /**\n     * Adds a method reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     *\n     * @param owner the internal name of the method's owner class.\n     * @param name the method's name.\n     * @param desc the method's descriptor.\n     * @param itf <tt>true</tt> if <tt>owner</tt> is an interface.\n     * @return a new or already existing method reference item.\n     */\n    Item newMethodItem(final String owner, final String name, final String desc, final boolean itf) {\n        int type = itf ? IMETH : METH;\n        key3.set(type, owner, name, desc);\n        Item result = get(key3);\n        if (result == null) {\n            put122(type, newClass(owner), newNameType(name, desc));\n            result = new Item(index++, key3);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a method reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     * <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param owner the internal name of the method's owner class.\n     * @param name the method's name.\n     * @param desc the method's descriptor.\n     * @param itf <tt>true</tt> if <tt>owner</tt> is an interface.\n     * @return the index of a new or already existing method reference item.\n     */\n    public int newMethod(final String owner, final String name, final String desc, final boolean itf) {\n        return newMethodItem(owner, name, desc, itf).index;\n    }\n\n    /**\n     * Adds an integer to the constant pool of the class being build. Does\n     * nothing if the constant pool already contains a similar item.\n     *\n     * @param value the int value.\n     * @return a new or already existing int item.\n     */\n    Item newInteger(final int value) {\n        key.set(value);\n        Item result = get(key);\n        if (result == null) {\n            pool.putByte(INT).putInt(value);\n            result = new Item(index++, key);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a float to the constant pool of the class being build. Does nothing\n     * if the constant pool already contains a similar item.\n     *\n     * @param value the float value.\n     * @return a new or already existing float item.\n     */\n    Item newFloat(final float value) {\n        key.set(value);\n        Item result = get(key);\n        if (result == null) {\n            pool.putByte(FLOAT).putInt(key.intVal);\n            result = new Item(index++, key);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a long to the constant pool of the class being build. Does nothing\n     * if the constant pool already contains a similar item.\n     *\n     * @param value the long value.\n     * @return a new or already existing long item.\n     */\n    Item newLong(final long value) {\n        key.set(value);\n        Item result = get(key);\n        if (result == null) {\n            pool.putByte(LONG).putLong(value);\n            result = new Item(index, key);\n            put(result);\n            index += 2;\n        }\n        return result;\n    }\n\n    /**\n     * Adds a double to the constant pool of the class being build. Does nothing\n     * if the constant pool already contains a similar item.\n     *\n     * @param value the double value.\n     * @return a new or already existing double item.\n     */\n    Item newDouble(final double value) {\n        key.set(value);\n        Item result = get(key);\n        if (result == null) {\n            pool.putByte(DOUBLE).putLong(key.longVal);\n            result = new Item(index, key);\n            put(result);\n            index += 2;\n        }\n        return result;\n    }\n\n    /**\n     * Adds a string to the constant pool of the class being build. Does nothing\n     * if the constant pool already contains a similar item.\n     *\n     * @param value the String value.\n     * @return a new or already existing string item.\n     */\n    private Item newString(final String value) {\n        key2.set(STR, value, null, null);\n        Item result = get(key2);\n        if (result == null) {\n            pool.put12(STR, newUTF8(value));\n            result = new Item(index++, key2);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a name and type to the constant pool of the class being build. Does\n     * nothing if the constant pool already contains a similar item. <i>This\n     * method is intended for {@link Attribute} sub classes, and is normally not\n     * needed by class generators or adapters.</i>\n     *\n     * @param name a name.\n     * @param desc a type descriptor.\n     * @return the index of a new or already existing name and type item.\n     */\n    public int newNameType(final String name, final String desc) {\n        return newNameTypeItem(name, desc).index;\n    }\n\n    /**\n     * Adds a name and type to the constant pool of the class being build. Does\n     * nothing if the constant pool already contains a similar item.\n     *\n     * @param name a name.\n     * @param desc a type descriptor.\n     * @return a new or already existing name and type item.\n     */\n    Item newNameTypeItem(final String name, final String desc) {\n        key2.set(NAME_TYPE, name, desc, null);\n        Item result = get(key2);\n        if (result == null) {\n            put122(NAME_TYPE, newUTF8(name), newUTF8(desc));\n            result = new Item(index++, key2);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds the given internal name to {@link #typeTable} and returns its index.\n     * Does nothing if the type table already contains this internal name.\n     *\n     * @param type the internal name to be added to the type table.\n     * @return the index of this internal name in the type table.\n     */\n    int addType(final String type) {\n        key.set(TYPE_NORMAL, type, null, null);\n        Item result = get(key);\n        if (result == null) {\n            result = addType(key);\n        }\n        return result.index;\n    }\n\n    /**\n     * Adds the given \"uninitialized\" type to {@link #typeTable} and returns its\n     * index. This method is used for UNINITIALIZED types, made of an internal\n     * name and a bytecode offset.\n     *\n     * @param type the internal name to be added to the type table.\n     * @param offset the bytecode offset of the NEW instruction that created\n     *        this UNINITIALIZED type value.\n     * @return the index of this internal name in the type table.\n     */\n    int addUninitializedType(final String type, final int offset) {\n        key.type = TYPE_UNINIT;\n        key.intVal = offset;\n        key.strVal1 = type;\n        key.hashCode = 0x7FFFFFFF & (TYPE_UNINIT + type.hashCode() + offset);\n        Item result = get(key);\n        if (result == null) {\n            result = addType(key);\n        }\n        return result.index;\n    }\n\n    /**\n     * Adds the given Item to {@link #typeTable}.\n     *\n     * @param item the value to be added to the type table.\n     * @return the added Item, which a new Item instance with the same value as\n     *         the given Item.\n     */\n    private Item addType(final Item item) {\n        ++typeCount;\n        Item result = new Item(typeCount, key);\n        put(result);\n        if (typeTable == null) {\n            typeTable = new Item[16];\n        }\n        if (typeCount == typeTable.length) {\n            Item[] newTable = new Item[2 * typeTable.length];\n            System.arraycopy(typeTable, 0, newTable, 0, typeTable.length);\n            typeTable = newTable;\n        }\n        typeTable[typeCount] = result;\n        return result;\n    }\n\n    /**\n     * Returns the index of the common super type of the two given types. This\n     * method calls {@link #getCommonSuperClass} and caches the result in the\n     * {@link #items} hash table to speedup future calls with the same\n     * parameters.\n     *\n     * @param type1 index of an internal name in {@link #typeTable}.\n     * @param type2 index of an internal name in {@link #typeTable}.\n     * @return the index of the common super type of the two given types.\n     */\n    int getMergedType(final int type1, final int type2) {\n        key2.type = TYPE_MERGED;\n        key2.longVal = type1 | (((long) type2) << 32);\n        key2.hashCode = 0x7FFFFFFF & (TYPE_MERGED + type1 + type2);\n        Item result = get(key2);\n        if (result == null) {\n            String t = typeTable[type1].strVal1;\n            String u = typeTable[type2].strVal1;\n            key2.intVal = addType(getCommonSuperClass(t, u));\n            result = new Item((short) 0, key2);\n            put(result);\n        }\n        return result.intVal;\n    }\n\n    /**\n     * Returns the common super type of the two given types. The default\n     * implementation of this method <i>loads<i> the two given classes and uses\n     * the java.lang.Class methods to find the common super class. It can be\n     * overridden to compute this common super type in other ways, in particular\n     * without actually loading any class, or to take into account the class\n     * that is currently being generated by this ClassWriter, which can of\n     * course not be loaded since it is under construction.\n     *\n     * @param type1 the internal name of a class.\n     * @param type2 the internal name of another class.\n     * @return the internal name of the common super class of the two given\n     *         classes.\n     */\n    protected String getCommonSuperClass(final String type1, final String type2) {\n        Class c, d;\n        try {\n            c = Class.forName(type1.replace('/', '.'));\n            d = Class.forName(type2.replace('/', '.'));\n        } catch (Exception e) {\n            throw new RuntimeException(e.toString());\n        }\n        if (c.isAssignableFrom(d)) {\n            return type1;\n        }\n        if (d.isAssignableFrom(c)) {\n            return type2;\n        }\n        if (c.isInterface() || d.isInterface()) {\n            return \"java/lang/Object\";\n        } else {\n            do {\n                c = c.getSuperclass();\n            } while (!c.isAssignableFrom(d));\n            return c.getName().replace('.', '/');\n        }\n    }\n\n    /**\n     * Returns the constant pool's hash table item which is equal to the given\n     * item.\n     *\n     * @param key a constant pool item.\n     * @return the constant pool's hash table item which is equal to the given\n     *         item, or <tt>null</tt> if there is no such item.\n     */\n    private Item get(final Item key) {\n        Item i = items[key.hashCode % items.length];\n        while (i != null && (i.type != key.type || !key.isEqualTo(i))) {\n            i = i.next;\n        }\n        return i;\n    }\n\n    /**\n     * Puts the given item in the constant pool's hash table. The hash table\n     * <i>must</i> not already contains this item.\n     *\n     * @param i the item to be added to the constant pool's hash table.\n     */\n    private void put(final Item i) {\n        if (index > threshold) {\n            int ll = items.length;\n            int nl = ll * 2 + 1;\n            Item[] newItems = new Item[nl];\n            for (int l = ll - 1; l >= 0; --l) {\n                Item j = items[l];\n                while (j != null) {\n                    int index = j.hashCode % newItems.length;\n                    Item k = j.next;\n                    j.next = newItems[index];\n                    newItems[index] = j;\n                    j = k;\n                }\n            }\n            items = newItems;\n            threshold = (int) (nl * 0.75);\n        }\n        int index = i.hashCode % items.length;\n        i.next = items[index];\n        items[index] = i;\n    }\n\n    /**\n     * Puts one byte and two shorts into the constant pool.\n     *\n     * @param b a byte.\n     * @param s1 a short.\n     * @param s2 another short.\n     */\n    private void put122(final int b, final int s1, final int s2) {\n        pool.put12(b, s1).putShort(s2);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/ClassWriterTest6.java",
		"test_prompt": "// ClassWriterTest6.java\npackage org.objectweb.asm.jip;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassWriter}.\n* It contains ten unit test cases for the {@link ClassWriter#newClass(String)} method.\n*/\nclass ClassWriterTest6 {"
	},
	{
		"original_code": "// ClassWriter.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\n/**\n * A {@link ClassVisitor} that generates classes in bytecode form. More\n * precisely this visitor generates a byte array conforming to the Java class\n * file format. It can be used alone, to generate a Java class \"from scratch\",\n * or with one or more {@link ClassReader ClassReader} and adapter class visitor\n * to generate a modified class from one or more existing Java classes.\n *\n * @author Eric Bruneton\n */\npublic class ClassWriter implements ClassVisitor {\n\n    /**\n     * Flag to automatically compute the maximum stack size and the maximum\n     * number of local variables of methods. If this flag is set, then the\n     * arguments of the {@link MethodVisitor#visitMaxs visitMaxs} method of the\n     * {@link MethodVisitor} returned by the {@link #visitMethod visitMethod}\n     * method will be ignored, and computed automatically from the signature and\n     * the bytecode of each method.\n     *\n     * @see #ClassWriter(int)\n     */\n    public static final int COMPUTE_MAXS = 1;\n\n    /**\n     * Flag to automatically compute the stack map frames of methods from\n     * scratch. If this flag is set, then the calls to the\n     * {@link MethodVisitor#visitFrame} method are ignored, and the stack map\n     * frames are recomputed from the methods bytecode. The arguments of the\n     * {@link MethodVisitor#visitMaxs visitMaxs} method are also ignored and\n     * recomputed from the bytecode. In other words, computeFrames implies\n     * computeMaxs.\n     *\n     * @see #ClassWriter(int)\n     */\n    public static final int COMPUTE_FRAMES = 2;\n\n    /**\n     * The type of instructions without any argument.\n     */\n    static final int NOARG_INSN = 0;\n\n    /**\n     * The type of instructions with an signed byte argument.\n     */\n    static final int SBYTE_INSN = 1;\n\n    /**\n     * The type of instructions with an signed short argument.\n     */\n    static final int SHORT_INSN = 2;\n\n    /**\n     * The type of instructions with a local variable index argument.\n     */\n    static final int VAR_INSN = 3;\n\n    /**\n     * The type of instructions with an implicit local variable index argument.\n     */\n    static final int IMPLVAR_INSN = 4;\n\n    /**\n     * The type of instructions with a type descriptor argument.\n     */\n    static final int TYPE_INSN = 5;\n\n    /**\n     * The type of field and method invocations instructions.\n     */\n    static final int FIELDORMETH_INSN = 6;\n\n    /**\n     * The type of the INVOKEINTERFACE/INVOKEDYNAMIC instruction.\n     */\n    static final int ITFDYNMETH_INSN = 7;\n\n    /**\n     * The type of instructions with a 2 bytes bytecode offset label.\n     */\n    static final int LABEL_INSN = 8;\n\n    /**\n     * The type of instructions with a 4 bytes bytecode offset label.\n     */\n    static final int LABELW_INSN = 9;\n\n    /**\n     * The type of the LDC instruction.\n     */\n    static final int LDC_INSN = 10;\n\n    /**\n     * The type of the LDC_W and LDC2_W instructions.\n     */\n    static final int LDCW_INSN = 11;\n\n    /**\n     * The type of the IINC instruction.\n     */\n    static final int IINC_INSN = 12;\n\n    /**\n     * The type of the TABLESWITCH instruction.\n     */\n    static final int TABL_INSN = 13;\n\n    /**\n     * The type of the LOOKUPSWITCH instruction.\n     */\n    static final int LOOK_INSN = 14;\n\n    /**\n     * The type of the MULTIANEWARRAY instruction.\n     */\n    static final int MANA_INSN = 15;\n\n    /**\n     * The type of the WIDE instruction.\n     */\n    static final int WIDE_INSN = 16;\n\n    /**\n     * The instruction types of all JVM opcodes.\n     */\n    static final byte[] TYPE;\n\n    /**\n     * The type of CONSTANT_Class constant pool items.\n     */\n    static final int CLASS = 7;\n\n    /**\n     * The type of CONSTANT_Fieldref constant pool items.\n     */\n    static final int FIELD = 9;\n\n    /**\n     * The type of CONSTANT_Methodref constant pool items.\n     */\n    static final int METH = 10;\n\n    /**\n     * The type of CONSTANT_InterfaceMethodref constant pool items.\n     */\n    static final int IMETH = 11;\n\n    /**\n     * The type of CONSTANT_String constant pool items.\n     */\n    static final int STR = 8;\n\n    /**\n     * The type of CONSTANT_Integer constant pool items.\n     */\n    static final int INT = 3;\n\n    /**\n     * The type of CONSTANT_Float constant pool items.\n     */\n    static final int FLOAT = 4;\n\n    /**\n     * The type of CONSTANT_Long constant pool items.\n     */\n    static final int LONG = 5;\n\n    /**\n     * The type of CONSTANT_Double constant pool items.\n     */\n    static final int DOUBLE = 6;\n\n    /**\n     * The type of CONSTANT_NameAndType constant pool items.\n     */\n    static final int NAME_TYPE = 12;\n\n    /**\n     * The type of CONSTANT_Utf8 constant pool items.\n     */\n    static final int UTF8 = 1;\n\n    /**\n     * Normal type Item stored in the ClassWriter {@link ClassWriter#typeTable},\n     * instead of the constant pool, in order to avoid clashes with normal\n     * constant pool items in the ClassWriter constant pool's hash table.\n     */\n    static final int TYPE_NORMAL = 13;\n\n    /**\n     * Uninitialized type Item stored in the ClassWriter\n     * {@link ClassWriter#typeTable}, instead of the constant pool, in order to\n     * avoid clashes with normal constant pool items in the ClassWriter constant\n     * pool's hash table.\n     */\n    static final int TYPE_UNINIT = 14;\n\n    /**\n     * Merged type Item stored in the ClassWriter {@link ClassWriter#typeTable},\n     * instead of the constant pool, in order to avoid clashes with normal\n     * constant pool items in the ClassWriter constant pool's hash table.\n     */\n    static final int TYPE_MERGED = 15;\n\n    /**\n     * The class reader from which this class writer was constructed, if any.\n     */\n    ClassReader cr;\n\n    /**\n     * Minor and major version numbers of the class to be generated.\n     */\n    int version;\n\n    /**\n     * Index of the next item to be added in the constant pool.\n     */\n    int index;\n\n    /**\n     * The constant pool of this class.\n     */\n    final ByteVector pool;\n\n    /**\n     * The constant pool's hash table data.\n     */\n    Item[] items;\n\n    /**\n     * The threshold of the constant pool's hash table.\n     */\n    int threshold;\n\n    /**\n     * A reusable key used to look for items in the {@link #items} hash table.\n     */\n    final Item key;\n\n    /**\n     * A reusable key used to look for items in the {@link #items} hash table.\n     */\n    final Item key2;\n\n    /**\n     * A reusable key used to look for items in the {@link #items} hash table.\n     */\n    final Item key3;\n\n    /**\n     * A type table used to temporarily store internal names that will not\n     * necessarily be stored in the constant pool. This type table is used by\n     * the control flow and data flow analysis algorithm used to compute stack\n     * map frames from scratch. This array associates to each index <tt>i</tt>\n     * the Item whose index is <tt>i</tt>. All Item objects stored in this\n     * array are also stored in the {@link #items} hash table. These two arrays\n     * allow to retrieve an Item from its index or, conversely, to get the index\n     * of an Item from its value. Each Item stores an internal name in its\n     * {@link Item#strVal1} field.\n     */\n    Item[] typeTable;\n\n    /**\n     * Number of elements in the {@link #typeTable} array.\n     */\n    private short typeCount;\n\n    /**\n     * The access flags of this class.\n     */\n    private int access;\n\n    /**\n     * The constant pool item that contains the internal name of this class.\n     */\n    private int name;\n\n    /**\n     * The internal name of this class.\n     */\n    String thisName;\n\n    /**\n     * The constant pool item that contains the signature of this class.\n     */\n    private int signature;\n\n    /**\n     * The constant pool item that contains the internal name of the super class\n     * of this class.\n     */\n    private int superName;\n\n    /**\n     * Number of interfaces implemented or extended by this class or interface.\n     */\n    private int interfaceCount;\n\n    /**\n     * The interfaces implemented or extended by this class or interface. More\n     * precisely, this array contains the indexes of the constant pool items\n     * that contain the internal names of these interfaces.\n     */\n    private int[] interfaces;\n\n    /**\n     * The index of the constant pool item that contains the name of the source\n     * file from which this class was compiled.\n     */\n    private int sourceFile;\n\n    /**\n     * The SourceDebug attribute of this class.\n     */\n    private ByteVector sourceDebug;\n\n    /**\n     * The constant pool item that contains the name of the enclosing class of\n     * this class.\n     */\n    private int enclosingMethodOwner;\n\n    /**\n     * The constant pool item that contains the name and descriptor of the\n     * enclosing method of this class.\n     */\n    private int enclosingMethod;\n\n    /**\n     * The runtime visible annotations of this class.\n     */\n    private AnnotationWriter anns;\n\n    /**\n     * The runtime invisible annotations of this class.\n     */\n    private AnnotationWriter ianns;\n\n    /**\n     * The non standard attributes of this class.\n     */\n    private Attribute attrs;\n\n    /**\n     * The number of entries in the InnerClasses attribute.\n     */\n    private int innerClassesCount;\n\n    /**\n     * The InnerClasses attribute.\n     */\n    private ByteVector innerClasses;\n\n    /**\n     * The fields of this class. These fields are stored in a linked list of\n     * {@link FieldWriter} objects, linked to each other by their\n     * {@link FieldWriter#next} field. This field stores the first element of\n     * this list.\n     */\n    FieldWriter firstField;\n\n    /**\n     * The fields of this class. These fields are stored in a linked list of\n     * {@link FieldWriter} objects, linked to each other by their\n     * {@link FieldWriter#next} field. This field stores the last element of\n     * this list.\n     */\n    FieldWriter lastField;\n\n    /**\n     * The methods of this class. These methods are stored in a linked list of\n     * {@link MethodWriter} objects, linked to each other by their\n     * {@link MethodWriter#next} field. This field stores the first element of\n     * this list.\n     */\n    MethodWriter firstMethod;\n\n    /**\n     * The methods of this class. These methods are stored in a linked list of\n     * {@link MethodWriter} objects, linked to each other by their\n     * {@link MethodWriter#next} field. This field stores the last element of\n     * this list.\n     */\n    MethodWriter lastMethod;\n\n    /**\n     * <tt>true</tt> if the maximum stack size and number of local variables\n     * must be automatically computed.\n     */\n    private final boolean computeMaxs;\n\n    /**\n     * <tt>true</tt> if the stack map frames must be recomputed from scratch.\n     */\n    private final boolean computeFrames;\n\n    /**\n     * <tt>true</tt> if the stack map tables of this class are invalid. The\n     * {@link MethodWriter#resizeInstructions} method cannot transform existing\n     * stack map tables, and so produces potentially invalid classes when it is\n     * executed. In this case the class is reread and rewritten with the\n     * {@link #COMPUTE_FRAMES} option (the resizeInstructions method can resize\n     * stack map tables when this option is used).\n     */\n    boolean invalidFrames;\n\n    // ------------------------------------------------------------------------\n    // Static initializer\n    // ------------------------------------------------------------------------\n    /**\n     * Computes the instruction types of JVM opcodes.\n     */\n    static {\n        int i;\n        byte[] b = new byte[220];\n        String s = \"AAAAAAAAAAAAAAAABCKLLDDDDDEEEEEEEEEEEEEEEEEEEEAAAAAAAADD\" + \"DDDEEEEEEEEEEEEEEEEEEEEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAAIIIIIIIIIIIIIIIIDNOAA\" + \"AAAAGGGGGGGHHFBFAAFFAAQPIIJJIIIIIIIIIIIIIIIIII\";\n        for (i = 0; i < b.length; ++i) {\n            b[i] = (byte) (s.charAt(i) - 'A');\n        }\n        TYPE = b;\n        // code to generate the above string\n        //\n        // // SBYTE_INSN instructions\n        // b[Constants.NEWARRAY] = SBYTE_INSN;\n        // b[Constants.BIPUSH] = SBYTE_INSN;\n        //\n        // // SHORT_INSN instructions\n        // b[Constants.SIPUSH] = SHORT_INSN;\n        //\n        // // (IMPL)VAR_INSN instructions\n        // b[Constants.RET] = VAR_INSN;\n        // for (i = Constants.ILOAD; i <= Constants.ALOAD; ++i) {\n        // b[i] = VAR_INSN;\n        // }\n        // for (i = Constants.ISTORE; i <= Constants.ASTORE; ++i) {\n        // b[i] = VAR_INSN;\n        // }\n        // for (i = 26; i <= 45; ++i) { // ILOAD_0 to ALOAD_3\n        // b[i] = IMPLVAR_INSN;\n        // }\n        // for (i = 59; i <= 78; ++i) { // ISTORE_0 to ASTORE_3\n        // b[i] = IMPLVAR_INSN;\n        // }\n        //\n        // // TYPE_INSN instructions\n        // b[Constants.NEW] = TYPE_INSN;\n        // b[Constants.ANEWARRAY] = TYPE_INSN;\n        // b[Constants.CHECKCAST] = TYPE_INSN;\n        // b[Constants.INSTANCEOF] = TYPE_INSN;\n        //\n        // // (Set)FIELDORMETH_INSN instructions\n        // for (i = Constants.GETSTATIC; i <= Constants.INVOKESTATIC; ++i) {\n        // b[i] = FIELDORMETH_INSN;\n        // }\n        // b[Constants.INVOKEINTERFACE] = ITFDYNMETH_INSN;\n        // b[Constants.INVOKEDYNAMIC] = ITFDYNMETH_INSN;\n        //\n        // // LABEL(W)_INSN instructions\n        // for (i = Constants.IFEQ; i <= Constants.JSR; ++i) {\n        // b[i] = LABEL_INSN;\n        // }\n        // b[Constants.IFNULL] = LABEL_INSN;\n        // b[Constants.IFNONNULL] = LABEL_INSN;\n        // b[200] = LABELW_INSN; // GOTO_W\n        // b[201] = LABELW_INSN; // JSR_W\n        // // temporary opcodes used internally by ASM - see Label and\n        // MethodWriter\n        // for (i = 202; i < 220; ++i) {\n        // b[i] = LABEL_INSN;\n        // }\n        //\n        // // LDC(_W) instructions\n        // b[Constants.LDC] = LDC_INSN;\n        // b[19] = LDCW_INSN; // LDC_W\n        // b[20] = LDCW_INSN; // LDC2_W\n        //\n        // // special instructions\n        // b[Constants.IINC] = IINC_INSN;\n        // b[Constants.TABLESWITCH] = TABL_INSN;\n        // b[Constants.LOOKUPSWITCH] = LOOK_INSN;\n        // b[Constants.MULTIANEWARRAY] = MANA_INSN;\n        // b[196] = WIDE_INSN; // WIDE\n        //\n        // for (i = 0; i < b.length; ++i) {\n        // System.err.print((char)('A' + b[i]));\n        // }\n        // System.err.println();\n    }\n\n    // ------------------------------------------------------------------------\n    // Constructor\n    // ------------------------------------------------------------------------\n    /**\n     * Constructs a new {@link ClassWriter} object.\n     *\n     * @param flags option flags that can be used to modify the default behavior\n     *        of this class. See {@link #COMPUTE_MAXS}, {@link #COMPUTE_FRAMES}.\n     */\n    public ClassWriter(final int flags) {\n        index = 1;\n        pool = new ByteVector();\n        items = new Item[256];\n        threshold = (int) (0.75d * items.length);\n        key = new Item();\n        key2 = new Item();\n        key3 = new Item();\n        this.computeMaxs = (flags & COMPUTE_MAXS) != 0;\n        this.computeFrames = (flags & COMPUTE_FRAMES) != 0;\n    }\n\n    /**\n     * Constructs a new {@link ClassWriter} object and enables optimizations for\n     * \"mostly add\" bytecode transformations. These optimizations are the\n     * following:\n     *\n     * <ul> <li>The constant pool from the original class is copied as is in\n     * the new class, which saves time. New constant pool entries will be added\n     * at the end if necessary, but unused constant pool entries <i>won't be\n     * removed</i>.</li> <li>Methods that are not transformed are copied as\n     * is in the new class, directly from the original class bytecode (i.e.\n     * without emitting visit events for all the method instructions), which\n     * saves a <i>lot</i> of time. Untransformed methods are detected by the\n     * fact that the {@link ClassReader} receives {@link MethodVisitor} objects\n     * that come from a {@link ClassWriter} (and not from a custom\n     * {@link ClassAdapter} or any other {@link ClassVisitor} instance).</li>\n     * </ul>\n     *\n     * @param classReader the {@link ClassReader} used to read the original\n     *        class. It will be used to copy the entire constant pool from the\n     *        original class and also to copy other fragments of original\n     *        bytecode where applicable.\n     * @param flags option flags that can be used to modify the default behavior\n     *        of this class. See {@link #COMPUTE_MAXS}, {@link #COMPUTE_FRAMES}.\n     */\n    public ClassWriter(final ClassReader classReader, final int flags) {\n        this(flags);\n        classReader.copyPool(this);\n        this.cr = classReader;\n    }\n\n    // ------------------------------------------------------------------------\n    // Implementation of the ClassVisitor interface\n    // ------------------------------------------------------------------------\n    public void visit(final int version, final int access, final String name, final String signature, final String superName, final String[] interfaces) {\n        this.version = version;\n        this.access = access;\n        this.name = newClass(name);\n        thisName = name;\n        if (ClassReader.SIGNATURES && signature != null) {\n            this.signature = newUTF8(signature);\n        }\n        this.superName = superName == null ? 0 : newClass(superName);\n        if (interfaces != null && interfaces.length > 0) {\n            interfaceCount = interfaces.length;\n            this.interfaces = new int[interfaceCount];\n            for (int i = 0; i < interfaceCount; ++i) {\n                this.interfaces[i] = newClass(interfaces[i]);\n            }\n        }\n    }\n\n    public void visitSource(final String file, final String debug) {\n        if (file != null) {\n            sourceFile = newUTF8(file);\n        }\n        if (debug != null) {\n            sourceDebug = new ByteVector().putUTF8(debug);\n        }\n    }\n\n    public void visitOuterClass(final String owner, final String name, final String desc) {\n        enclosingMethodOwner = newClass(owner);\n        if (name != null && desc != null) {\n            enclosingMethod = newNameType(name, desc);\n        }\n    }\n\n    public AnnotationVisitor visitAnnotation(final String desc, final boolean visible) {\n        if (!ClassReader.ANNOTATIONS) {\n            return null;\n        }\n        ByteVector bv = new ByteVector();\n        // write type, and reserve space for values count\n        bv.putShort(newUTF8(desc)).putShort(0);\n        AnnotationWriter aw = new AnnotationWriter(this, true, bv, bv, 2);\n        if (visible) {\n            aw.next = anns;\n            anns = aw;\n        } else {\n            aw.next = ianns;\n            ianns = aw;\n        }\n        return aw;\n    }\n\n    public void visitAttribute(final Attribute attr) {\n        attr.next = attrs;\n        attrs = attr;\n    }\n\n    public void visitInnerClass(final String name, final String outerName, final String innerName, final int access) {\n        if (innerClasses == null) {\n            innerClasses = new ByteVector();\n        }\n        ++innerClassesCount;\n        innerClasses.putShort(name == null ? 0 : newClass(name));\n        innerClasses.putShort(outerName == null ? 0 : newClass(outerName));\n        innerClasses.putShort(innerName == null ? 0 : newUTF8(innerName));\n        innerClasses.putShort(access);\n    }\n\n    public FieldVisitor visitField(final int access, final String name, final String desc, final String signature, final Object value) {\n        return new FieldWriter(this, access, name, desc, signature, value);\n    }\n\n    public MethodVisitor visitMethod(final int access, final String name, final String desc, final String signature, final String[] exceptions) {\n        return new MethodWriter(this, access, name, desc, signature, exceptions, computeMaxs, computeFrames);\n    }\n\n    public void visitEnd() {\n    }\n\n    // ------------------------------------------------------------------------\n    // Other public methods\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the bytecode of the class that was build with this class writer.\n     *\n     * @return the bytecode of the class that was build with this class writer.\n     */\n    public byte[] toByteArray() {\n        // computes the real size of the bytecode of this class\n        int size = 24 + 2 * interfaceCount;\n        int nbFields = 0;\n        FieldWriter fb = firstField;\n        while (fb != null) {\n            ++nbFields;\n            size += fb.getSize();\n            fb = fb.next;\n        }\n        int nbMethods = 0;\n        MethodWriter mb = firstMethod;\n        while (mb != null) {\n            ++nbMethods;\n            size += mb.getSize();\n            mb = mb.next;\n        }\n        int attributeCount = 0;\n        if (ClassReader.SIGNATURES && signature != 0) {\n            ++attributeCount;\n            size += 8;\n            newUTF8(\"Signature\");\n        }\n        if (sourceFile != 0) {\n            ++attributeCount;\n            size += 8;\n            newUTF8(\"SourceFile\");\n        }\n        if (sourceDebug != null) {\n            ++attributeCount;\n            size += sourceDebug.length + 4;\n            newUTF8(\"SourceDebugExtension\");\n        }\n        if (enclosingMethodOwner != 0) {\n            ++attributeCount;\n            size += 10;\n            newUTF8(\"EnclosingMethod\");\n        }\n        if ((access & Opcodes.ACC_DEPRECATED) != 0) {\n            ++attributeCount;\n            size += 6;\n            newUTF8(\"Deprecated\");\n        }\n        if ((access & Opcodes.ACC_SYNTHETIC) != 0 && (version & 0xffff) < Opcodes.V1_5) {\n            ++attributeCount;\n            size += 6;\n            newUTF8(\"Synthetic\");\n        }\n        if (innerClasses != null) {\n            ++attributeCount;\n            size += 8 + innerClasses.length;\n            newUTF8(\"InnerClasses\");\n        }\n        if (ClassReader.ANNOTATIONS && anns != null) {\n            ++attributeCount;\n            size += 8 + anns.getSize();\n            newUTF8(\"RuntimeVisibleAnnotations\");\n        }\n        if (ClassReader.ANNOTATIONS && ianns != null) {\n            ++attributeCount;\n            size += 8 + ianns.getSize();\n            newUTF8(\"RuntimeInvisibleAnnotations\");\n        }\n        if (attrs != null) {\n            attributeCount += attrs.getCount();\n            size += attrs.getSize(this, null, 0, -1, -1);\n        }\n        size += pool.length;\n        // allocates a byte vector of this size, in order to avoid unnecessary\n        // arraycopy operations in the ByteVector.enlarge() method\n        ByteVector out = new ByteVector(size);\n        out.putInt(0xCAFEBABE).putInt(version);\n        out.putShort(index).putByteArray(pool.data, 0, pool.length);\n        out.putShort(access).putShort(name).putShort(superName);\n        out.putShort(interfaceCount);\n        for (int i = 0; i < interfaceCount; ++i) {\n            out.putShort(interfaces[i]);\n        }\n        out.putShort(nbFields);\n        fb = firstField;\n        while (fb != null) {\n            fb.put(out);\n            fb = fb.next;\n        }\n        out.putShort(nbMethods);\n        mb = firstMethod;\n        while (mb != null) {\n            mb.put(out);\n            mb = mb.next;\n        }\n        out.putShort(attributeCount);\n        if (ClassReader.SIGNATURES && signature != 0) {\n            out.putShort(newUTF8(\"Signature\")).putInt(2).putShort(signature);\n        }\n        if (sourceFile != 0) {\n            out.putShort(newUTF8(\"SourceFile\")).putInt(2).putShort(sourceFile);\n        }\n        if (sourceDebug != null) {\n            int len = sourceDebug.length - 2;\n            out.putShort(newUTF8(\"SourceDebugExtension\")).putInt(len);\n            out.putByteArray(sourceDebug.data, 2, len);\n        }\n        if (enclosingMethodOwner != 0) {\n            out.putShort(newUTF8(\"EnclosingMethod\")).putInt(4);\n            out.putShort(enclosingMethodOwner).putShort(enclosingMethod);\n        }\n        if ((access & Opcodes.ACC_DEPRECATED) != 0) {\n            out.putShort(newUTF8(\"Deprecated\")).putInt(0);\n        }\n        if ((access & Opcodes.ACC_SYNTHETIC) != 0 && (version & 0xffff) < Opcodes.V1_5) {\n            out.putShort(newUTF8(\"Synthetic\")).putInt(0);\n        }\n        if (innerClasses != null) {\n            out.putShort(newUTF8(\"InnerClasses\"));\n            out.putInt(innerClasses.length + 2).putShort(innerClassesCount);\n            out.putByteArray(innerClasses.data, 0, innerClasses.length);\n        }\n        if (ClassReader.ANNOTATIONS && anns != null) {\n            out.putShort(newUTF8(\"RuntimeVisibleAnnotations\"));\n            anns.put(out);\n        }\n        if (ClassReader.ANNOTATIONS && ianns != null) {\n            out.putShort(newUTF8(\"RuntimeInvisibleAnnotations\"));\n            ianns.put(out);\n        }\n        if (attrs != null) {\n            attrs.put(this, null, 0, -1, -1, out);\n        }\n        if (invalidFrames) {\n            ClassWriter cw = new ClassWriter(COMPUTE_FRAMES);\n            new ClassReader(out.data).accept(cw, ClassReader.SKIP_FRAMES);\n            return cw.toByteArray();\n        }\n        return out.data;\n    }\n\n    // ------------------------------------------------------------------------\n    // Utility methods: constant pool management\n    // ------------------------------------------------------------------------\n    /**\n     * Adds a number or string constant to the constant pool of the class being\n     * build. Does nothing if the constant pool already contains a similar item.\n     *\n     * @param cst the value of the constant to be added to the constant pool.\n     *        This parameter must be an {@link Integer}, a {@link Float}, a\n     *        {@link Long}, a {@link Double}, a {@link String} or a\n     *        {@link Type}.\n     * @return a new or already existing constant item with the given value.\n     */\n    Item newConstItem(final Object cst) {\n        if (cst instanceof Integer) {\n            int val = ((Integer) cst).intValue();\n            return newInteger(val);\n        } else if (cst instanceof Byte) {\n            int val = ((Byte) cst).intValue();\n            return newInteger(val);\n        } else if (cst instanceof Character) {\n            int val = ((Character) cst).charValue();\n            return newInteger(val);\n        } else if (cst instanceof Short) {\n            int val = ((Short) cst).intValue();\n            return newInteger(val);\n        } else if (cst instanceof Boolean) {\n            int val = ((Boolean) cst).booleanValue() ? 1 : 0;\n            return newInteger(val);\n        } else if (cst instanceof Float) {\n            float val = ((Float) cst).floatValue();\n            return newFloat(val);\n        } else if (cst instanceof Long) {\n            long val = ((Long) cst).longValue();\n            return newLong(val);\n        } else if (cst instanceof Double) {\n            double val = ((Double) cst).doubleValue();\n            return newDouble(val);\n        } else if (cst instanceof String) {\n            return newString((String) cst);\n        } else if (cst instanceof Type) {\n            Type t = (Type) cst;\n            return newClassItem(t.getSort() == Type.OBJECT ? t.getInternalName() : t.getDescriptor());\n        } else {\n            throw new IllegalArgumentException(\"value \" + cst);\n        }\n    }\n\n    /**\n     * Adds a number or string constant to the constant pool of the class being\n     * build. Does nothing if the constant pool already contains a similar item.\n     * <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param cst the value of the constant to be added to the constant pool.\n     *        This parameter must be an {@link Integer}, a {@link Float}, a\n     *        {@link Long}, a {@link Double} or a {@link String}.\n     * @return the index of a new or already existing constant item with the\n     *         given value.\n     */\n    public int newConst(final Object cst) {\n        return newConstItem(cst).index;\n    }\n\n    /**\n     * Adds an UTF8 string to the constant pool of the class being build. Does\n     * nothing if the constant pool already contains a similar item. <i>This\n     * method is intended for {@link Attribute} sub classes, and is normally not\n     * needed by class generators or adapters.</i>\n     *\n     * @param value the String value.\n     * @return the index of a new or already existing UTF8 item.\n     */\n    public int newUTF8(final String value) {\n        key.set(UTF8, value, null, null);\n        Item result = get(key);\n        if (result == null) {\n            pool.putByte(UTF8).putUTF8(value);\n            result = new Item(index++, key);\n            put(result);\n        }\n        return result.index;\n    }\n\n    /**\n     * Adds a class reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     * <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param value the internal name of the class.\n     * @return a new or already existing class reference item.\n     */\n    Item newClassItem(final String value) {\n        key2.set(CLASS, value, null, null);\n        Item result = get(key2);\n        if (result == null) {\n            pool.put12(CLASS, newUTF8(value));\n            result = new Item(index++, key2);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a class reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     * <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param value the internal name of the class.\n     * @return the index of a new or already existing class reference item.\n     */\n    public int newClass(final String value) {\n        return newClassItem(value).index;\n    }\n\n    /**\n     * Adds a field reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     *\n     * @param owner the internal name of the field's owner class.\n     * @param name the field's name.\n     * @param desc the field's descriptor.\n     * @return a new or already existing field reference item.\n     */\n    Item newFieldItem(final String owner, final String name, final String desc) {\n        key3.set(FIELD, owner, name, desc);\n        Item result = get(key3);\n        if (result == null) {\n            put122(FIELD, newClass(owner), newNameType(name, desc));\n            result = new Item(index++, key3);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a field reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     * <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param owner the internal name of the field's owner class.\n     * @param name the field's name.\n     * @param desc the field's descriptor.\n     * @return the index of a new or already existing field reference item.\n     */\n    public int newField(final String owner, final String name, final String desc) {\n        return newFieldItem(owner, name, desc).index;\n    }\n\n    /**\n     * Adds a method reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     *\n     * @param owner the internal name of the method's owner class.\n     * @param name the method's name.\n     * @param desc the method's descriptor.\n     * @param itf <tt>true</tt> if <tt>owner</tt> is an interface.\n     * @return a new or already existing method reference item.\n     */\n    Item newMethodItem(final String owner, final String name, final String desc, final boolean itf) {\n        int type = itf ? IMETH : METH;\n        key3.set(type, owner, name, desc);\n        Item result = get(key3);\n        if (result == null) {\n            put122(type, newClass(owner), newNameType(name, desc));\n            result = new Item(index++, key3);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a method reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     * <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param owner the internal name of the method's owner class.\n     * @param name the method's name.\n     * @param desc the method's descriptor.\n     * @param itf <tt>true</tt> if <tt>owner</tt> is an interface.\n     * @return the index of a new or already existing method reference item.\n     */\n    public int newMethod(final String owner, final String name, final String desc, final boolean itf) {\n        return newMethodItem(owner, name, desc, itf).index;\n    }\n\n    /**\n     * Adds an integer to the constant pool of the class being build. Does\n     * nothing if the constant pool already contains a similar item.\n     *\n     * @param value the int value.\n     * @return a new or already existing int item.\n     */\n    Item newInteger(final int value) {\n        key.set(value);\n        Item result = get(key);\n        if (result == null) {\n            pool.putByte(INT).putInt(value);\n            result = new Item(index++, key);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a float to the constant pool of the class being build. Does nothing\n     * if the constant pool already contains a similar item.\n     *\n     * @param value the float value.\n     * @return a new or already existing float item.\n     */\n    Item newFloat(final float value) {\n        key.set(value);\n        Item result = get(key);\n        if (result == null) {\n            pool.putByte(FLOAT).putInt(key.intVal);\n            result = new Item(index++, key);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a long to the constant pool of the class being build. Does nothing\n     * if the constant pool already contains a similar item.\n     *\n     * @param value the long value.\n     * @return a new or already existing long item.\n     */\n    Item newLong(final long value) {\n        key.set(value);\n        Item result = get(key);\n        if (result == null) {\n            pool.putByte(LONG).putLong(value);\n            result = new Item(index, key);\n            put(result);\n            index += 2;\n        }\n        return result;\n    }\n\n    /**\n     * Adds a double to the constant pool of the class being build. Does nothing\n     * if the constant pool already contains a similar item.\n     *\n     * @param value the double value.\n     * @return a new or already existing double item.\n     */\n    Item newDouble(final double value) {\n        key.set(value);\n        Item result = get(key);\n        if (result == null) {\n            pool.putByte(DOUBLE).putLong(key.longVal);\n            result = new Item(index, key);\n            put(result);\n            index += 2;\n        }\n        return result;\n    }\n\n    /**\n     * Adds a string to the constant pool of the class being build. Does nothing\n     * if the constant pool already contains a similar item.\n     *\n     * @param value the String value.\n     * @return a new or already existing string item.\n     */\n    private Item newString(final String value) {\n        key2.set(STR, value, null, null);\n        Item result = get(key2);\n        if (result == null) {\n            pool.put12(STR, newUTF8(value));\n            result = new Item(index++, key2);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a name and type to the constant pool of the class being build. Does\n     * nothing if the constant pool already contains a similar item. <i>This\n     * method is intended for {@link Attribute} sub classes, and is normally not\n     * needed by class generators or adapters.</i>\n     *\n     * @param name a name.\n     * @param desc a type descriptor.\n     * @return the index of a new or already existing name and type item.\n     */\n    public int newNameType(final String name, final String desc) {\n        return newNameTypeItem(name, desc).index;\n    }\n\n    /**\n     * Adds a name and type to the constant pool of the class being build. Does\n     * nothing if the constant pool already contains a similar item.\n     *\n     * @param name a name.\n     * @param desc a type descriptor.\n     * @return a new or already existing name and type item.\n     */\n    Item newNameTypeItem(final String name, final String desc) {\n        key2.set(NAME_TYPE, name, desc, null);\n        Item result = get(key2);\n        if (result == null) {\n            put122(NAME_TYPE, newUTF8(name), newUTF8(desc));\n            result = new Item(index++, key2);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds the given internal name to {@link #typeTable} and returns its index.\n     * Does nothing if the type table already contains this internal name.\n     *\n     * @param type the internal name to be added to the type table.\n     * @return the index of this internal name in the type table.\n     */\n    int addType(final String type) {\n        key.set(TYPE_NORMAL, type, null, null);\n        Item result = get(key);\n        if (result == null) {\n            result = addType(key);\n        }\n        return result.index;\n    }\n\n    /**\n     * Adds the given \"uninitialized\" type to {@link #typeTable} and returns its\n     * index. This method is used for UNINITIALIZED types, made of an internal\n     * name and a bytecode offset.\n     *\n     * @param type the internal name to be added to the type table.\n     * @param offset the bytecode offset of the NEW instruction that created\n     *        this UNINITIALIZED type value.\n     * @return the index of this internal name in the type table.\n     */\n    int addUninitializedType(final String type, final int offset) {\n        key.type = TYPE_UNINIT;\n        key.intVal = offset;\n        key.strVal1 = type;\n        key.hashCode = 0x7FFFFFFF & (TYPE_UNINIT + type.hashCode() + offset);\n        Item result = get(key);\n        if (result == null) {\n            result = addType(key);\n        }\n        return result.index;\n    }\n\n    /**\n     * Adds the given Item to {@link #typeTable}.\n     *\n     * @param item the value to be added to the type table.\n     * @return the added Item, which a new Item instance with the same value as\n     *         the given Item.\n     */\n    private Item addType(final Item item) {\n        ++typeCount;\n        Item result = new Item(typeCount, key);\n        put(result);\n        if (typeTable == null) {\n            typeTable = new Item[16];\n        }\n        if (typeCount == typeTable.length) {\n            Item[] newTable = new Item[2 * typeTable.length];\n            System.arraycopy(typeTable, 0, newTable, 0, typeTable.length);\n            typeTable = newTable;\n        }\n        typeTable[typeCount] = result;\n        return result;\n    }\n\n    /**\n     * Returns the index of the common super type of the two given types. This\n     * method calls {@link #getCommonSuperClass} and caches the result in the\n     * {@link #items} hash table to speedup future calls with the same\n     * parameters.\n     *\n     * @param type1 index of an internal name in {@link #typeTable}.\n     * @param type2 index of an internal name in {@link #typeTable}.\n     * @return the index of the common super type of the two given types.\n     */\n    int getMergedType(final int type1, final int type2) {\n        key2.type = TYPE_MERGED;\n        key2.longVal = type1 | (((long) type2) << 32);\n        key2.hashCode = 0x7FFFFFFF & (TYPE_MERGED + type1 + type2);\n        Item result = get(key2);\n        if (result == null) {\n            String t = typeTable[type1].strVal1;\n            String u = typeTable[type2].strVal1;\n            key2.intVal = addType(getCommonSuperClass(t, u));\n            result = new Item((short) 0, key2);\n            put(result);\n        }\n        return result.intVal;\n    }\n\n    /**\n     * Returns the common super type of the two given types. The default\n     * implementation of this method <i>loads<i> the two given classes and uses\n     * the java.lang.Class methods to find the common super class. It can be\n     * overridden to compute this common super type in other ways, in particular\n     * without actually loading any class, or to take into account the class\n     * that is currently being generated by this ClassWriter, which can of\n     * course not be loaded since it is under construction.\n     *\n     * @param type1 the internal name of a class.\n     * @param type2 the internal name of another class.\n     * @return the internal name of the common super class of the two given\n     *         classes.\n     */\n    protected String getCommonSuperClass(final String type1, final String type2) {\n        Class c, d;\n        try {\n            c = Class.forName(type1.replace('/', '.'));\n            d = Class.forName(type2.replace('/', '.'));\n        } catch (Exception e) {\n            throw new RuntimeException(e.toString());\n        }\n        if (c.isAssignableFrom(d)) {\n            return type1;\n        }\n        if (d.isAssignableFrom(c)) {\n            return type2;\n        }\n        if (c.isInterface() || d.isInterface()) {\n            return \"java/lang/Object\";\n        } else {\n            do {\n                c = c.getSuperclass();\n            } while (!c.isAssignableFrom(d));\n            return c.getName().replace('.', '/');\n        }\n    }\n\n    /**\n     * Returns the constant pool's hash table item which is equal to the given\n     * item.\n     *\n     * @param key a constant pool item.\n     * @return the constant pool's hash table item which is equal to the given\n     *         item, or <tt>null</tt> if there is no such item.\n     */\n    private Item get(final Item key) {\n        Item i = items[key.hashCode % items.length];\n        while (i != null && (i.type != key.type || !key.isEqualTo(i))) {\n            i = i.next;\n        }\n        return i;\n    }\n\n    /**\n     * Puts the given item in the constant pool's hash table. The hash table\n     * <i>must</i> not already contains this item.\n     *\n     * @param i the item to be added to the constant pool's hash table.\n     */\n    private void put(final Item i) {\n        if (index > threshold) {\n            int ll = items.length;\n            int nl = ll * 2 + 1;\n            Item[] newItems = new Item[nl];\n            for (int l = ll - 1; l >= 0; --l) {\n                Item j = items[l];\n                while (j != null) {\n                    int index = j.hashCode % newItems.length;\n                    Item k = j.next;\n                    j.next = newItems[index];\n                    newItems[index] = j;\n                    j = k;\n                }\n            }\n            items = newItems;\n            threshold = (int) (nl * 0.75);\n        }\n        int index = i.hashCode % items.length;\n        i.next = items[index];\n        items[index] = i;\n    }\n\n    /**\n     * Puts one byte and two shorts into the constant pool.\n     *\n     * @param b a byte.\n     * @param s1 a short.\n     * @param s2 another short.\n     */\n    private void put122(final int b, final int s1, final int s2) {\n        pool.put12(b, s1).putShort(s2);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/ClassWriterTest7.java",
		"test_prompt": "// ClassWriterTest7.java\npackage org.objectweb.asm.jip;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassWriter}.\n* It contains ten unit test cases for the {@link ClassWriter#newField(String, String, String)} method.\n*/\nclass ClassWriterTest7 {"
	},
	{
		"original_code": "// ClassWriter.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\n/**\n * A {@link ClassVisitor} that generates classes in bytecode form. More\n * precisely this visitor generates a byte array conforming to the Java class\n * file format. It can be used alone, to generate a Java class \"from scratch\",\n * or with one or more {@link ClassReader ClassReader} and adapter class visitor\n * to generate a modified class from one or more existing Java classes.\n *\n * @author Eric Bruneton\n */\npublic class ClassWriter implements ClassVisitor {\n\n    /**\n     * Flag to automatically compute the maximum stack size and the maximum\n     * number of local variables of methods. If this flag is set, then the\n     * arguments of the {@link MethodVisitor#visitMaxs visitMaxs} method of the\n     * {@link MethodVisitor} returned by the {@link #visitMethod visitMethod}\n     * method will be ignored, and computed automatically from the signature and\n     * the bytecode of each method.\n     *\n     * @see #ClassWriter(int)\n     */\n    public static final int COMPUTE_MAXS = 1;\n\n    /**\n     * Flag to automatically compute the stack map frames of methods from\n     * scratch. If this flag is set, then the calls to the\n     * {@link MethodVisitor#visitFrame} method are ignored, and the stack map\n     * frames are recomputed from the methods bytecode. The arguments of the\n     * {@link MethodVisitor#visitMaxs visitMaxs} method are also ignored and\n     * recomputed from the bytecode. In other words, computeFrames implies\n     * computeMaxs.\n     *\n     * @see #ClassWriter(int)\n     */\n    public static final int COMPUTE_FRAMES = 2;\n\n    /**\n     * The type of instructions without any argument.\n     */\n    static final int NOARG_INSN = 0;\n\n    /**\n     * The type of instructions with an signed byte argument.\n     */\n    static final int SBYTE_INSN = 1;\n\n    /**\n     * The type of instructions with an signed short argument.\n     */\n    static final int SHORT_INSN = 2;\n\n    /**\n     * The type of instructions with a local variable index argument.\n     */\n    static final int VAR_INSN = 3;\n\n    /**\n     * The type of instructions with an implicit local variable index argument.\n     */\n    static final int IMPLVAR_INSN = 4;\n\n    /**\n     * The type of instructions with a type descriptor argument.\n     */\n    static final int TYPE_INSN = 5;\n\n    /**\n     * The type of field and method invocations instructions.\n     */\n    static final int FIELDORMETH_INSN = 6;\n\n    /**\n     * The type of the INVOKEINTERFACE/INVOKEDYNAMIC instruction.\n     */\n    static final int ITFDYNMETH_INSN = 7;\n\n    /**\n     * The type of instructions with a 2 bytes bytecode offset label.\n     */\n    static final int LABEL_INSN = 8;\n\n    /**\n     * The type of instructions with a 4 bytes bytecode offset label.\n     */\n    static final int LABELW_INSN = 9;\n\n    /**\n     * The type of the LDC instruction.\n     */\n    static final int LDC_INSN = 10;\n\n    /**\n     * The type of the LDC_W and LDC2_W instructions.\n     */\n    static final int LDCW_INSN = 11;\n\n    /**\n     * The type of the IINC instruction.\n     */\n    static final int IINC_INSN = 12;\n\n    /**\n     * The type of the TABLESWITCH instruction.\n     */\n    static final int TABL_INSN = 13;\n\n    /**\n     * The type of the LOOKUPSWITCH instruction.\n     */\n    static final int LOOK_INSN = 14;\n\n    /**\n     * The type of the MULTIANEWARRAY instruction.\n     */\n    static final int MANA_INSN = 15;\n\n    /**\n     * The type of the WIDE instruction.\n     */\n    static final int WIDE_INSN = 16;\n\n    /**\n     * The instruction types of all JVM opcodes.\n     */\n    static final byte[] TYPE;\n\n    /**\n     * The type of CONSTANT_Class constant pool items.\n     */\n    static final int CLASS = 7;\n\n    /**\n     * The type of CONSTANT_Fieldref constant pool items.\n     */\n    static final int FIELD = 9;\n\n    /**\n     * The type of CONSTANT_Methodref constant pool items.\n     */\n    static final int METH = 10;\n\n    /**\n     * The type of CONSTANT_InterfaceMethodref constant pool items.\n     */\n    static final int IMETH = 11;\n\n    /**\n     * The type of CONSTANT_String constant pool items.\n     */\n    static final int STR = 8;\n\n    /**\n     * The type of CONSTANT_Integer constant pool items.\n     */\n    static final int INT = 3;\n\n    /**\n     * The type of CONSTANT_Float constant pool items.\n     */\n    static final int FLOAT = 4;\n\n    /**\n     * The type of CONSTANT_Long constant pool items.\n     */\n    static final int LONG = 5;\n\n    /**\n     * The type of CONSTANT_Double constant pool items.\n     */\n    static final int DOUBLE = 6;\n\n    /**\n     * The type of CONSTANT_NameAndType constant pool items.\n     */\n    static final int NAME_TYPE = 12;\n\n    /**\n     * The type of CONSTANT_Utf8 constant pool items.\n     */\n    static final int UTF8 = 1;\n\n    /**\n     * Normal type Item stored in the ClassWriter {@link ClassWriter#typeTable},\n     * instead of the constant pool, in order to avoid clashes with normal\n     * constant pool items in the ClassWriter constant pool's hash table.\n     */\n    static final int TYPE_NORMAL = 13;\n\n    /**\n     * Uninitialized type Item stored in the ClassWriter\n     * {@link ClassWriter#typeTable}, instead of the constant pool, in order to\n     * avoid clashes with normal constant pool items in the ClassWriter constant\n     * pool's hash table.\n     */\n    static final int TYPE_UNINIT = 14;\n\n    /**\n     * Merged type Item stored in the ClassWriter {@link ClassWriter#typeTable},\n     * instead of the constant pool, in order to avoid clashes with normal\n     * constant pool items in the ClassWriter constant pool's hash table.\n     */\n    static final int TYPE_MERGED = 15;\n\n    /**\n     * The class reader from which this class writer was constructed, if any.\n     */\n    ClassReader cr;\n\n    /**\n     * Minor and major version numbers of the class to be generated.\n     */\n    int version;\n\n    /**\n     * Index of the next item to be added in the constant pool.\n     */\n    int index;\n\n    /**\n     * The constant pool of this class.\n     */\n    final ByteVector pool;\n\n    /**\n     * The constant pool's hash table data.\n     */\n    Item[] items;\n\n    /**\n     * The threshold of the constant pool's hash table.\n     */\n    int threshold;\n\n    /**\n     * A reusable key used to look for items in the {@link #items} hash table.\n     */\n    final Item key;\n\n    /**\n     * A reusable key used to look for items in the {@link #items} hash table.\n     */\n    final Item key2;\n\n    /**\n     * A reusable key used to look for items in the {@link #items} hash table.\n     */\n    final Item key3;\n\n    /**\n     * A type table used to temporarily store internal names that will not\n     * necessarily be stored in the constant pool. This type table is used by\n     * the control flow and data flow analysis algorithm used to compute stack\n     * map frames from scratch. This array associates to each index <tt>i</tt>\n     * the Item whose index is <tt>i</tt>. All Item objects stored in this\n     * array are also stored in the {@link #items} hash table. These two arrays\n     * allow to retrieve an Item from its index or, conversely, to get the index\n     * of an Item from its value. Each Item stores an internal name in its\n     * {@link Item#strVal1} field.\n     */\n    Item[] typeTable;\n\n    /**\n     * Number of elements in the {@link #typeTable} array.\n     */\n    private short typeCount;\n\n    /**\n     * The access flags of this class.\n     */\n    private int access;\n\n    /**\n     * The constant pool item that contains the internal name of this class.\n     */\n    private int name;\n\n    /**\n     * The internal name of this class.\n     */\n    String thisName;\n\n    /**\n     * The constant pool item that contains the signature of this class.\n     */\n    private int signature;\n\n    /**\n     * The constant pool item that contains the internal name of the super class\n     * of this class.\n     */\n    private int superName;\n\n    /**\n     * Number of interfaces implemented or extended by this class or interface.\n     */\n    private int interfaceCount;\n\n    /**\n     * The interfaces implemented or extended by this class or interface. More\n     * precisely, this array contains the indexes of the constant pool items\n     * that contain the internal names of these interfaces.\n     */\n    private int[] interfaces;\n\n    /**\n     * The index of the constant pool item that contains the name of the source\n     * file from which this class was compiled.\n     */\n    private int sourceFile;\n\n    /**\n     * The SourceDebug attribute of this class.\n     */\n    private ByteVector sourceDebug;\n\n    /**\n     * The constant pool item that contains the name of the enclosing class of\n     * this class.\n     */\n    private int enclosingMethodOwner;\n\n    /**\n     * The constant pool item that contains the name and descriptor of the\n     * enclosing method of this class.\n     */\n    private int enclosingMethod;\n\n    /**\n     * The runtime visible annotations of this class.\n     */\n    private AnnotationWriter anns;\n\n    /**\n     * The runtime invisible annotations of this class.\n     */\n    private AnnotationWriter ianns;\n\n    /**\n     * The non standard attributes of this class.\n     */\n    private Attribute attrs;\n\n    /**\n     * The number of entries in the InnerClasses attribute.\n     */\n    private int innerClassesCount;\n\n    /**\n     * The InnerClasses attribute.\n     */\n    private ByteVector innerClasses;\n\n    /**\n     * The fields of this class. These fields are stored in a linked list of\n     * {@link FieldWriter} objects, linked to each other by their\n     * {@link FieldWriter#next} field. This field stores the first element of\n     * this list.\n     */\n    FieldWriter firstField;\n\n    /**\n     * The fields of this class. These fields are stored in a linked list of\n     * {@link FieldWriter} objects, linked to each other by their\n     * {@link FieldWriter#next} field. This field stores the last element of\n     * this list.\n     */\n    FieldWriter lastField;\n\n    /**\n     * The methods of this class. These methods are stored in a linked list of\n     * {@link MethodWriter} objects, linked to each other by their\n     * {@link MethodWriter#next} field. This field stores the first element of\n     * this list.\n     */\n    MethodWriter firstMethod;\n\n    /**\n     * The methods of this class. These methods are stored in a linked list of\n     * {@link MethodWriter} objects, linked to each other by their\n     * {@link MethodWriter#next} field. This field stores the last element of\n     * this list.\n     */\n    MethodWriter lastMethod;\n\n    /**\n     * <tt>true</tt> if the maximum stack size and number of local variables\n     * must be automatically computed.\n     */\n    private final boolean computeMaxs;\n\n    /**\n     * <tt>true</tt> if the stack map frames must be recomputed from scratch.\n     */\n    private final boolean computeFrames;\n\n    /**\n     * <tt>true</tt> if the stack map tables of this class are invalid. The\n     * {@link MethodWriter#resizeInstructions} method cannot transform existing\n     * stack map tables, and so produces potentially invalid classes when it is\n     * executed. In this case the class is reread and rewritten with the\n     * {@link #COMPUTE_FRAMES} option (the resizeInstructions method can resize\n     * stack map tables when this option is used).\n     */\n    boolean invalidFrames;\n\n    // ------------------------------------------------------------------------\n    // Static initializer\n    // ------------------------------------------------------------------------\n    /**\n     * Computes the instruction types of JVM opcodes.\n     */\n    static {\n        int i;\n        byte[] b = new byte[220];\n        String s = \"AAAAAAAAAAAAAAAABCKLLDDDDDEEEEEEEEEEEEEEEEEEEEAAAAAAAADD\" + \"DDDEEEEEEEEEEEEEEEEEEEEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAAIIIIIIIIIIIIIIIIDNOAA\" + \"AAAAGGGGGGGHHFBFAAFFAAQPIIJJIIIIIIIIIIIIIIIIII\";\n        for (i = 0; i < b.length; ++i) {\n            b[i] = (byte) (s.charAt(i) - 'A');\n        }\n        TYPE = b;\n        // code to generate the above string\n        //\n        // // SBYTE_INSN instructions\n        // b[Constants.NEWARRAY] = SBYTE_INSN;\n        // b[Constants.BIPUSH] = SBYTE_INSN;\n        //\n        // // SHORT_INSN instructions\n        // b[Constants.SIPUSH] = SHORT_INSN;\n        //\n        // // (IMPL)VAR_INSN instructions\n        // b[Constants.RET] = VAR_INSN;\n        // for (i = Constants.ILOAD; i <= Constants.ALOAD; ++i) {\n        // b[i] = VAR_INSN;\n        // }\n        // for (i = Constants.ISTORE; i <= Constants.ASTORE; ++i) {\n        // b[i] = VAR_INSN;\n        // }\n        // for (i = 26; i <= 45; ++i) { // ILOAD_0 to ALOAD_3\n        // b[i] = IMPLVAR_INSN;\n        // }\n        // for (i = 59; i <= 78; ++i) { // ISTORE_0 to ASTORE_3\n        // b[i] = IMPLVAR_INSN;\n        // }\n        //\n        // // TYPE_INSN instructions\n        // b[Constants.NEW] = TYPE_INSN;\n        // b[Constants.ANEWARRAY] = TYPE_INSN;\n        // b[Constants.CHECKCAST] = TYPE_INSN;\n        // b[Constants.INSTANCEOF] = TYPE_INSN;\n        //\n        // // (Set)FIELDORMETH_INSN instructions\n        // for (i = Constants.GETSTATIC; i <= Constants.INVOKESTATIC; ++i) {\n        // b[i] = FIELDORMETH_INSN;\n        // }\n        // b[Constants.INVOKEINTERFACE] = ITFDYNMETH_INSN;\n        // b[Constants.INVOKEDYNAMIC] = ITFDYNMETH_INSN;\n        //\n        // // LABEL(W)_INSN instructions\n        // for (i = Constants.IFEQ; i <= Constants.JSR; ++i) {\n        // b[i] = LABEL_INSN;\n        // }\n        // b[Constants.IFNULL] = LABEL_INSN;\n        // b[Constants.IFNONNULL] = LABEL_INSN;\n        // b[200] = LABELW_INSN; // GOTO_W\n        // b[201] = LABELW_INSN; // JSR_W\n        // // temporary opcodes used internally by ASM - see Label and\n        // MethodWriter\n        // for (i = 202; i < 220; ++i) {\n        // b[i] = LABEL_INSN;\n        // }\n        //\n        // // LDC(_W) instructions\n        // b[Constants.LDC] = LDC_INSN;\n        // b[19] = LDCW_INSN; // LDC_W\n        // b[20] = LDCW_INSN; // LDC2_W\n        //\n        // // special instructions\n        // b[Constants.IINC] = IINC_INSN;\n        // b[Constants.TABLESWITCH] = TABL_INSN;\n        // b[Constants.LOOKUPSWITCH] = LOOK_INSN;\n        // b[Constants.MULTIANEWARRAY] = MANA_INSN;\n        // b[196] = WIDE_INSN; // WIDE\n        //\n        // for (i = 0; i < b.length; ++i) {\n        // System.err.print((char)('A' + b[i]));\n        // }\n        // System.err.println();\n    }\n\n    // ------------------------------------------------------------------------\n    // Constructor\n    // ------------------------------------------------------------------------\n    /**\n     * Constructs a new {@link ClassWriter} object.\n     *\n     * @param flags option flags that can be used to modify the default behavior\n     *        of this class. See {@link #COMPUTE_MAXS}, {@link #COMPUTE_FRAMES}.\n     */\n    public ClassWriter(final int flags) {\n        index = 1;\n        pool = new ByteVector();\n        items = new Item[256];\n        threshold = (int) (0.75d * items.length);\n        key = new Item();\n        key2 = new Item();\n        key3 = new Item();\n        this.computeMaxs = (flags & COMPUTE_MAXS) != 0;\n        this.computeFrames = (flags & COMPUTE_FRAMES) != 0;\n    }\n\n    /**\n     * Constructs a new {@link ClassWriter} object and enables optimizations for\n     * \"mostly add\" bytecode transformations. These optimizations are the\n     * following:\n     *\n     * <ul> <li>The constant pool from the original class is copied as is in\n     * the new class, which saves time. New constant pool entries will be added\n     * at the end if necessary, but unused constant pool entries <i>won't be\n     * removed</i>.</li> <li>Methods that are not transformed are copied as\n     * is in the new class, directly from the original class bytecode (i.e.\n     * without emitting visit events for all the method instructions), which\n     * saves a <i>lot</i> of time. Untransformed methods are detected by the\n     * fact that the {@link ClassReader} receives {@link MethodVisitor} objects\n     * that come from a {@link ClassWriter} (and not from a custom\n     * {@link ClassAdapter} or any other {@link ClassVisitor} instance).</li>\n     * </ul>\n     *\n     * @param classReader the {@link ClassReader} used to read the original\n     *        class. It will be used to copy the entire constant pool from the\n     *        original class and also to copy other fragments of original\n     *        bytecode where applicable.\n     * @param flags option flags that can be used to modify the default behavior\n     *        of this class. See {@link #COMPUTE_MAXS}, {@link #COMPUTE_FRAMES}.\n     */\n    public ClassWriter(final ClassReader classReader, final int flags) {\n        this(flags);\n        classReader.copyPool(this);\n        this.cr = classReader;\n    }\n\n    // ------------------------------------------------------------------------\n    // Implementation of the ClassVisitor interface\n    // ------------------------------------------------------------------------\n    public void visit(final int version, final int access, final String name, final String signature, final String superName, final String[] interfaces) {\n        this.version = version;\n        this.access = access;\n        this.name = newClass(name);\n        thisName = name;\n        if (ClassReader.SIGNATURES && signature != null) {\n            this.signature = newUTF8(signature);\n        }\n        this.superName = superName == null ? 0 : newClass(superName);\n        if (interfaces != null && interfaces.length > 0) {\n            interfaceCount = interfaces.length;\n            this.interfaces = new int[interfaceCount];\n            for (int i = 0; i < interfaceCount; ++i) {\n                this.interfaces[i] = newClass(interfaces[i]);\n            }\n        }\n    }\n\n    public void visitSource(final String file, final String debug) {\n        if (file != null) {\n            sourceFile = newUTF8(file);\n        }\n        if (debug != null) {\n            sourceDebug = new ByteVector().putUTF8(debug);\n        }\n    }\n\n    public void visitOuterClass(final String owner, final String name, final String desc) {\n        enclosingMethodOwner = newClass(owner);\n        if (name != null && desc != null) {\n            enclosingMethod = newNameType(name, desc);\n        }\n    }\n\n    public AnnotationVisitor visitAnnotation(final String desc, final boolean visible) {\n        if (!ClassReader.ANNOTATIONS) {\n            return null;\n        }\n        ByteVector bv = new ByteVector();\n        // write type, and reserve space for values count\n        bv.putShort(newUTF8(desc)).putShort(0);\n        AnnotationWriter aw = new AnnotationWriter(this, true, bv, bv, 2);\n        if (visible) {\n            aw.next = anns;\n            anns = aw;\n        } else {\n            aw.next = ianns;\n            ianns = aw;\n        }\n        return aw;\n    }\n\n    public void visitAttribute(final Attribute attr) {\n        attr.next = attrs;\n        attrs = attr;\n    }\n\n    public void visitInnerClass(final String name, final String outerName, final String innerName, final int access) {\n        if (innerClasses == null) {\n            innerClasses = new ByteVector();\n        }\n        ++innerClassesCount;\n        innerClasses.putShort(name == null ? 0 : newClass(name));\n        innerClasses.putShort(outerName == null ? 0 : newClass(outerName));\n        innerClasses.putShort(innerName == null ? 0 : newUTF8(innerName));\n        innerClasses.putShort(access);\n    }\n\n    public FieldVisitor visitField(final int access, final String name, final String desc, final String signature, final Object value) {\n        return new FieldWriter(this, access, name, desc, signature, value);\n    }\n\n    public MethodVisitor visitMethod(final int access, final String name, final String desc, final String signature, final String[] exceptions) {\n        return new MethodWriter(this, access, name, desc, signature, exceptions, computeMaxs, computeFrames);\n    }\n\n    public void visitEnd() {\n    }\n\n    // ------------------------------------------------------------------------\n    // Other public methods\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the bytecode of the class that was build with this class writer.\n     *\n     * @return the bytecode of the class that was build with this class writer.\n     */\n    public byte[] toByteArray() {\n        // computes the real size of the bytecode of this class\n        int size = 24 + 2 * interfaceCount;\n        int nbFields = 0;\n        FieldWriter fb = firstField;\n        while (fb != null) {\n            ++nbFields;\n            size += fb.getSize();\n            fb = fb.next;\n        }\n        int nbMethods = 0;\n        MethodWriter mb = firstMethod;\n        while (mb != null) {\n            ++nbMethods;\n            size += mb.getSize();\n            mb = mb.next;\n        }\n        int attributeCount = 0;\n        if (ClassReader.SIGNATURES && signature != 0) {\n            ++attributeCount;\n            size += 8;\n            newUTF8(\"Signature\");\n        }\n        if (sourceFile != 0) {\n            ++attributeCount;\n            size += 8;\n            newUTF8(\"SourceFile\");\n        }\n        if (sourceDebug != null) {\n            ++attributeCount;\n            size += sourceDebug.length + 4;\n            newUTF8(\"SourceDebugExtension\");\n        }\n        if (enclosingMethodOwner != 0) {\n            ++attributeCount;\n            size += 10;\n            newUTF8(\"EnclosingMethod\");\n        }\n        if ((access & Opcodes.ACC_DEPRECATED) != 0) {\n            ++attributeCount;\n            size += 6;\n            newUTF8(\"Deprecated\");\n        }\n        if ((access & Opcodes.ACC_SYNTHETIC) != 0 && (version & 0xffff) < Opcodes.V1_5) {\n            ++attributeCount;\n            size += 6;\n            newUTF8(\"Synthetic\");\n        }\n        if (innerClasses != null) {\n            ++attributeCount;\n            size += 8 + innerClasses.length;\n            newUTF8(\"InnerClasses\");\n        }\n        if (ClassReader.ANNOTATIONS && anns != null) {\n            ++attributeCount;\n            size += 8 + anns.getSize();\n            newUTF8(\"RuntimeVisibleAnnotations\");\n        }\n        if (ClassReader.ANNOTATIONS && ianns != null) {\n            ++attributeCount;\n            size += 8 + ianns.getSize();\n            newUTF8(\"RuntimeInvisibleAnnotations\");\n        }\n        if (attrs != null) {\n            attributeCount += attrs.getCount();\n            size += attrs.getSize(this, null, 0, -1, -1);\n        }\n        size += pool.length;\n        // allocates a byte vector of this size, in order to avoid unnecessary\n        // arraycopy operations in the ByteVector.enlarge() method\n        ByteVector out = new ByteVector(size);\n        out.putInt(0xCAFEBABE).putInt(version);\n        out.putShort(index).putByteArray(pool.data, 0, pool.length);\n        out.putShort(access).putShort(name).putShort(superName);\n        out.putShort(interfaceCount);\n        for (int i = 0; i < interfaceCount; ++i) {\n            out.putShort(interfaces[i]);\n        }\n        out.putShort(nbFields);\n        fb = firstField;\n        while (fb != null) {\n            fb.put(out);\n            fb = fb.next;\n        }\n        out.putShort(nbMethods);\n        mb = firstMethod;\n        while (mb != null) {\n            mb.put(out);\n            mb = mb.next;\n        }\n        out.putShort(attributeCount);\n        if (ClassReader.SIGNATURES && signature != 0) {\n            out.putShort(newUTF8(\"Signature\")).putInt(2).putShort(signature);\n        }\n        if (sourceFile != 0) {\n            out.putShort(newUTF8(\"SourceFile\")).putInt(2).putShort(sourceFile);\n        }\n        if (sourceDebug != null) {\n            int len = sourceDebug.length - 2;\n            out.putShort(newUTF8(\"SourceDebugExtension\")).putInt(len);\n            out.putByteArray(sourceDebug.data, 2, len);\n        }\n        if (enclosingMethodOwner != 0) {\n            out.putShort(newUTF8(\"EnclosingMethod\")).putInt(4);\n            out.putShort(enclosingMethodOwner).putShort(enclosingMethod);\n        }\n        if ((access & Opcodes.ACC_DEPRECATED) != 0) {\n            out.putShort(newUTF8(\"Deprecated\")).putInt(0);\n        }\n        if ((access & Opcodes.ACC_SYNTHETIC) != 0 && (version & 0xffff) < Opcodes.V1_5) {\n            out.putShort(newUTF8(\"Synthetic\")).putInt(0);\n        }\n        if (innerClasses != null) {\n            out.putShort(newUTF8(\"InnerClasses\"));\n            out.putInt(innerClasses.length + 2).putShort(innerClassesCount);\n            out.putByteArray(innerClasses.data, 0, innerClasses.length);\n        }\n        if (ClassReader.ANNOTATIONS && anns != null) {\n            out.putShort(newUTF8(\"RuntimeVisibleAnnotations\"));\n            anns.put(out);\n        }\n        if (ClassReader.ANNOTATIONS && ianns != null) {\n            out.putShort(newUTF8(\"RuntimeInvisibleAnnotations\"));\n            ianns.put(out);\n        }\n        if (attrs != null) {\n            attrs.put(this, null, 0, -1, -1, out);\n        }\n        if (invalidFrames) {\n            ClassWriter cw = new ClassWriter(COMPUTE_FRAMES);\n            new ClassReader(out.data).accept(cw, ClassReader.SKIP_FRAMES);\n            return cw.toByteArray();\n        }\n        return out.data;\n    }\n\n    // ------------------------------------------------------------------------\n    // Utility methods: constant pool management\n    // ------------------------------------------------------------------------\n    /**\n     * Adds a number or string constant to the constant pool of the class being\n     * build. Does nothing if the constant pool already contains a similar item.\n     *\n     * @param cst the value of the constant to be added to the constant pool.\n     *        This parameter must be an {@link Integer}, a {@link Float}, a\n     *        {@link Long}, a {@link Double}, a {@link String} or a\n     *        {@link Type}.\n     * @return a new or already existing constant item with the given value.\n     */\n    Item newConstItem(final Object cst) {\n        if (cst instanceof Integer) {\n            int val = ((Integer) cst).intValue();\n            return newInteger(val);\n        } else if (cst instanceof Byte) {\n            int val = ((Byte) cst).intValue();\n            return newInteger(val);\n        } else if (cst instanceof Character) {\n            int val = ((Character) cst).charValue();\n            return newInteger(val);\n        } else if (cst instanceof Short) {\n            int val = ((Short) cst).intValue();\n            return newInteger(val);\n        } else if (cst instanceof Boolean) {\n            int val = ((Boolean) cst).booleanValue() ? 1 : 0;\n            return newInteger(val);\n        } else if (cst instanceof Float) {\n            float val = ((Float) cst).floatValue();\n            return newFloat(val);\n        } else if (cst instanceof Long) {\n            long val = ((Long) cst).longValue();\n            return newLong(val);\n        } else if (cst instanceof Double) {\n            double val = ((Double) cst).doubleValue();\n            return newDouble(val);\n        } else if (cst instanceof String) {\n            return newString((String) cst);\n        } else if (cst instanceof Type) {\n            Type t = (Type) cst;\n            return newClassItem(t.getSort() == Type.OBJECT ? t.getInternalName() : t.getDescriptor());\n        } else {\n            throw new IllegalArgumentException(\"value \" + cst);\n        }\n    }\n\n    /**\n     * Adds a number or string constant to the constant pool of the class being\n     * build. Does nothing if the constant pool already contains a similar item.\n     * <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param cst the value of the constant to be added to the constant pool.\n     *        This parameter must be an {@link Integer}, a {@link Float}, a\n     *        {@link Long}, a {@link Double} or a {@link String}.\n     * @return the index of a new or already existing constant item with the\n     *         given value.\n     */\n    public int newConst(final Object cst) {\n        return newConstItem(cst).index;\n    }\n\n    /**\n     * Adds an UTF8 string to the constant pool of the class being build. Does\n     * nothing if the constant pool already contains a similar item. <i>This\n     * method is intended for {@link Attribute} sub classes, and is normally not\n     * needed by class generators or adapters.</i>\n     *\n     * @param value the String value.\n     * @return the index of a new or already existing UTF8 item.\n     */\n    public int newUTF8(final String value) {\n        key.set(UTF8, value, null, null);\n        Item result = get(key);\n        if (result == null) {\n            pool.putByte(UTF8).putUTF8(value);\n            result = new Item(index++, key);\n            put(result);\n        }\n        return result.index;\n    }\n\n    /**\n     * Adds a class reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     * <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param value the internal name of the class.\n     * @return a new or already existing class reference item.\n     */\n    Item newClassItem(final String value) {\n        key2.set(CLASS, value, null, null);\n        Item result = get(key2);\n        if (result == null) {\n            pool.put12(CLASS, newUTF8(value));\n            result = new Item(index++, key2);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a class reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     * <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param value the internal name of the class.\n     * @return the index of a new or already existing class reference item.\n     */\n    public int newClass(final String value) {\n        return newClassItem(value).index;\n    }\n\n    /**\n     * Adds a field reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     *\n     * @param owner the internal name of the field's owner class.\n     * @param name the field's name.\n     * @param desc the field's descriptor.\n     * @return a new or already existing field reference item.\n     */\n    Item newFieldItem(final String owner, final String name, final String desc) {\n        key3.set(FIELD, owner, name, desc);\n        Item result = get(key3);\n        if (result == null) {\n            put122(FIELD, newClass(owner), newNameType(name, desc));\n            result = new Item(index++, key3);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a field reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     * <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param owner the internal name of the field's owner class.\n     * @param name the field's name.\n     * @param desc the field's descriptor.\n     * @return the index of a new or already existing field reference item.\n     */\n    public int newField(final String owner, final String name, final String desc) {\n        return newFieldItem(owner, name, desc).index;\n    }\n\n    /**\n     * Adds a method reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     *\n     * @param owner the internal name of the method's owner class.\n     * @param name the method's name.\n     * @param desc the method's descriptor.\n     * @param itf <tt>true</tt> if <tt>owner</tt> is an interface.\n     * @return a new or already existing method reference item.\n     */\n    Item newMethodItem(final String owner, final String name, final String desc, final boolean itf) {\n        int type = itf ? IMETH : METH;\n        key3.set(type, owner, name, desc);\n        Item result = get(key3);\n        if (result == null) {\n            put122(type, newClass(owner), newNameType(name, desc));\n            result = new Item(index++, key3);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a method reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     * <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param owner the internal name of the method's owner class.\n     * @param name the method's name.\n     * @param desc the method's descriptor.\n     * @param itf <tt>true</tt> if <tt>owner</tt> is an interface.\n     * @return the index of a new or already existing method reference item.\n     */\n    public int newMethod(final String owner, final String name, final String desc, final boolean itf) {\n        return newMethodItem(owner, name, desc, itf).index;\n    }\n\n    /**\n     * Adds an integer to the constant pool of the class being build. Does\n     * nothing if the constant pool already contains a similar item.\n     *\n     * @param value the int value.\n     * @return a new or already existing int item.\n     */\n    Item newInteger(final int value) {\n        key.set(value);\n        Item result = get(key);\n        if (result == null) {\n            pool.putByte(INT).putInt(value);\n            result = new Item(index++, key);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a float to the constant pool of the class being build. Does nothing\n     * if the constant pool already contains a similar item.\n     *\n     * @param value the float value.\n     * @return a new or already existing float item.\n     */\n    Item newFloat(final float value) {\n        key.set(value);\n        Item result = get(key);\n        if (result == null) {\n            pool.putByte(FLOAT).putInt(key.intVal);\n            result = new Item(index++, key);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a long to the constant pool of the class being build. Does nothing\n     * if the constant pool already contains a similar item.\n     *\n     * @param value the long value.\n     * @return a new or already existing long item.\n     */\n    Item newLong(final long value) {\n        key.set(value);\n        Item result = get(key);\n        if (result == null) {\n            pool.putByte(LONG).putLong(value);\n            result = new Item(index, key);\n            put(result);\n            index += 2;\n        }\n        return result;\n    }\n\n    /**\n     * Adds a double to the constant pool of the class being build. Does nothing\n     * if the constant pool already contains a similar item.\n     *\n     * @param value the double value.\n     * @return a new or already existing double item.\n     */\n    Item newDouble(final double value) {\n        key.set(value);\n        Item result = get(key);\n        if (result == null) {\n            pool.putByte(DOUBLE).putLong(key.longVal);\n            result = new Item(index, key);\n            put(result);\n            index += 2;\n        }\n        return result;\n    }\n\n    /**\n     * Adds a string to the constant pool of the class being build. Does nothing\n     * if the constant pool already contains a similar item.\n     *\n     * @param value the String value.\n     * @return a new or already existing string item.\n     */\n    private Item newString(final String value) {\n        key2.set(STR, value, null, null);\n        Item result = get(key2);\n        if (result == null) {\n            pool.put12(STR, newUTF8(value));\n            result = new Item(index++, key2);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a name and type to the constant pool of the class being build. Does\n     * nothing if the constant pool already contains a similar item. <i>This\n     * method is intended for {@link Attribute} sub classes, and is normally not\n     * needed by class generators or adapters.</i>\n     *\n     * @param name a name.\n     * @param desc a type descriptor.\n     * @return the index of a new or already existing name and type item.\n     */\n    public int newNameType(final String name, final String desc) {\n        return newNameTypeItem(name, desc).index;\n    }\n\n    /**\n     * Adds a name and type to the constant pool of the class being build. Does\n     * nothing if the constant pool already contains a similar item.\n     *\n     * @param name a name.\n     * @param desc a type descriptor.\n     * @return a new or already existing name and type item.\n     */\n    Item newNameTypeItem(final String name, final String desc) {\n        key2.set(NAME_TYPE, name, desc, null);\n        Item result = get(key2);\n        if (result == null) {\n            put122(NAME_TYPE, newUTF8(name), newUTF8(desc));\n            result = new Item(index++, key2);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds the given internal name to {@link #typeTable} and returns its index.\n     * Does nothing if the type table already contains this internal name.\n     *\n     * @param type the internal name to be added to the type table.\n     * @return the index of this internal name in the type table.\n     */\n    int addType(final String type) {\n        key.set(TYPE_NORMAL, type, null, null);\n        Item result = get(key);\n        if (result == null) {\n            result = addType(key);\n        }\n        return result.index;\n    }\n\n    /**\n     * Adds the given \"uninitialized\" type to {@link #typeTable} and returns its\n     * index. This method is used for UNINITIALIZED types, made of an internal\n     * name and a bytecode offset.\n     *\n     * @param type the internal name to be added to the type table.\n     * @param offset the bytecode offset of the NEW instruction that created\n     *        this UNINITIALIZED type value.\n     * @return the index of this internal name in the type table.\n     */\n    int addUninitializedType(final String type, final int offset) {\n        key.type = TYPE_UNINIT;\n        key.intVal = offset;\n        key.strVal1 = type;\n        key.hashCode = 0x7FFFFFFF & (TYPE_UNINIT + type.hashCode() + offset);\n        Item result = get(key);\n        if (result == null) {\n            result = addType(key);\n        }\n        return result.index;\n    }\n\n    /**\n     * Adds the given Item to {@link #typeTable}.\n     *\n     * @param item the value to be added to the type table.\n     * @return the added Item, which a new Item instance with the same value as\n     *         the given Item.\n     */\n    private Item addType(final Item item) {\n        ++typeCount;\n        Item result = new Item(typeCount, key);\n        put(result);\n        if (typeTable == null) {\n            typeTable = new Item[16];\n        }\n        if (typeCount == typeTable.length) {\n            Item[] newTable = new Item[2 * typeTable.length];\n            System.arraycopy(typeTable, 0, newTable, 0, typeTable.length);\n            typeTable = newTable;\n        }\n        typeTable[typeCount] = result;\n        return result;\n    }\n\n    /**\n     * Returns the index of the common super type of the two given types. This\n     * method calls {@link #getCommonSuperClass} and caches the result in the\n     * {@link #items} hash table to speedup future calls with the same\n     * parameters.\n     *\n     * @param type1 index of an internal name in {@link #typeTable}.\n     * @param type2 index of an internal name in {@link #typeTable}.\n     * @return the index of the common super type of the two given types.\n     */\n    int getMergedType(final int type1, final int type2) {\n        key2.type = TYPE_MERGED;\n        key2.longVal = type1 | (((long) type2) << 32);\n        key2.hashCode = 0x7FFFFFFF & (TYPE_MERGED + type1 + type2);\n        Item result = get(key2);\n        if (result == null) {\n            String t = typeTable[type1].strVal1;\n            String u = typeTable[type2].strVal1;\n            key2.intVal = addType(getCommonSuperClass(t, u));\n            result = new Item((short) 0, key2);\n            put(result);\n        }\n        return result.intVal;\n    }\n\n    /**\n     * Returns the common super type of the two given types. The default\n     * implementation of this method <i>loads<i> the two given classes and uses\n     * the java.lang.Class methods to find the common super class. It can be\n     * overridden to compute this common super type in other ways, in particular\n     * without actually loading any class, or to take into account the class\n     * that is currently being generated by this ClassWriter, which can of\n     * course not be loaded since it is under construction.\n     *\n     * @param type1 the internal name of a class.\n     * @param type2 the internal name of another class.\n     * @return the internal name of the common super class of the two given\n     *         classes.\n     */\n    protected String getCommonSuperClass(final String type1, final String type2) {\n        Class c, d;\n        try {\n            c = Class.forName(type1.replace('/', '.'));\n            d = Class.forName(type2.replace('/', '.'));\n        } catch (Exception e) {\n            throw new RuntimeException(e.toString());\n        }\n        if (c.isAssignableFrom(d)) {\n            return type1;\n        }\n        if (d.isAssignableFrom(c)) {\n            return type2;\n        }\n        if (c.isInterface() || d.isInterface()) {\n            return \"java/lang/Object\";\n        } else {\n            do {\n                c = c.getSuperclass();\n            } while (!c.isAssignableFrom(d));\n            return c.getName().replace('.', '/');\n        }\n    }\n\n    /**\n     * Returns the constant pool's hash table item which is equal to the given\n     * item.\n     *\n     * @param key a constant pool item.\n     * @return the constant pool's hash table item which is equal to the given\n     *         item, or <tt>null</tt> if there is no such item.\n     */\n    private Item get(final Item key) {\n        Item i = items[key.hashCode % items.length];\n        while (i != null && (i.type != key.type || !key.isEqualTo(i))) {\n            i = i.next;\n        }\n        return i;\n    }\n\n    /**\n     * Puts the given item in the constant pool's hash table. The hash table\n     * <i>must</i> not already contains this item.\n     *\n     * @param i the item to be added to the constant pool's hash table.\n     */\n    private void put(final Item i) {\n        if (index > threshold) {\n            int ll = items.length;\n            int nl = ll * 2 + 1;\n            Item[] newItems = new Item[nl];\n            for (int l = ll - 1; l >= 0; --l) {\n                Item j = items[l];\n                while (j != null) {\n                    int index = j.hashCode % newItems.length;\n                    Item k = j.next;\n                    j.next = newItems[index];\n                    newItems[index] = j;\n                    j = k;\n                }\n            }\n            items = newItems;\n            threshold = (int) (nl * 0.75);\n        }\n        int index = i.hashCode % items.length;\n        i.next = items[index];\n        items[index] = i;\n    }\n\n    /**\n     * Puts one byte and two shorts into the constant pool.\n     *\n     * @param b a byte.\n     * @param s1 a short.\n     * @param s2 another short.\n     */\n    private void put122(final int b, final int s1, final int s2) {\n        pool.put12(b, s1).putShort(s2);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/ClassWriterTest8.java",
		"test_prompt": "// ClassWriterTest8.java\npackage org.objectweb.asm.jip;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassWriter}.\n* It contains ten unit test cases for the {@link ClassWriter#newMethod(String, String, String, boolean)} method.\n*/\nclass ClassWriterTest8 {"
	},
	{
		"original_code": "// ClassWriter.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\n/**\n * A {@link ClassVisitor} that generates classes in bytecode form. More\n * precisely this visitor generates a byte array conforming to the Java class\n * file format. It can be used alone, to generate a Java class \"from scratch\",\n * or with one or more {@link ClassReader ClassReader} and adapter class visitor\n * to generate a modified class from one or more existing Java classes.\n *\n * @author Eric Bruneton\n */\npublic class ClassWriter implements ClassVisitor {\n\n    /**\n     * Flag to automatically compute the maximum stack size and the maximum\n     * number of local variables of methods. If this flag is set, then the\n     * arguments of the {@link MethodVisitor#visitMaxs visitMaxs} method of the\n     * {@link MethodVisitor} returned by the {@link #visitMethod visitMethod}\n     * method will be ignored, and computed automatically from the signature and\n     * the bytecode of each method.\n     *\n     * @see #ClassWriter(int)\n     */\n    public static final int COMPUTE_MAXS = 1;\n\n    /**\n     * Flag to automatically compute the stack map frames of methods from\n     * scratch. If this flag is set, then the calls to the\n     * {@link MethodVisitor#visitFrame} method are ignored, and the stack map\n     * frames are recomputed from the methods bytecode. The arguments of the\n     * {@link MethodVisitor#visitMaxs visitMaxs} method are also ignored and\n     * recomputed from the bytecode. In other words, computeFrames implies\n     * computeMaxs.\n     *\n     * @see #ClassWriter(int)\n     */\n    public static final int COMPUTE_FRAMES = 2;\n\n    /**\n     * The type of instructions without any argument.\n     */\n    static final int NOARG_INSN = 0;\n\n    /**\n     * The type of instructions with an signed byte argument.\n     */\n    static final int SBYTE_INSN = 1;\n\n    /**\n     * The type of instructions with an signed short argument.\n     */\n    static final int SHORT_INSN = 2;\n\n    /**\n     * The type of instructions with a local variable index argument.\n     */\n    static final int VAR_INSN = 3;\n\n    /**\n     * The type of instructions with an implicit local variable index argument.\n     */\n    static final int IMPLVAR_INSN = 4;\n\n    /**\n     * The type of instructions with a type descriptor argument.\n     */\n    static final int TYPE_INSN = 5;\n\n    /**\n     * The type of field and method invocations instructions.\n     */\n    static final int FIELDORMETH_INSN = 6;\n\n    /**\n     * The type of the INVOKEINTERFACE/INVOKEDYNAMIC instruction.\n     */\n    static final int ITFDYNMETH_INSN = 7;\n\n    /**\n     * The type of instructions with a 2 bytes bytecode offset label.\n     */\n    static final int LABEL_INSN = 8;\n\n    /**\n     * The type of instructions with a 4 bytes bytecode offset label.\n     */\n    static final int LABELW_INSN = 9;\n\n    /**\n     * The type of the LDC instruction.\n     */\n    static final int LDC_INSN = 10;\n\n    /**\n     * The type of the LDC_W and LDC2_W instructions.\n     */\n    static final int LDCW_INSN = 11;\n\n    /**\n     * The type of the IINC instruction.\n     */\n    static final int IINC_INSN = 12;\n\n    /**\n     * The type of the TABLESWITCH instruction.\n     */\n    static final int TABL_INSN = 13;\n\n    /**\n     * The type of the LOOKUPSWITCH instruction.\n     */\n    static final int LOOK_INSN = 14;\n\n    /**\n     * The type of the MULTIANEWARRAY instruction.\n     */\n    static final int MANA_INSN = 15;\n\n    /**\n     * The type of the WIDE instruction.\n     */\n    static final int WIDE_INSN = 16;\n\n    /**\n     * The instruction types of all JVM opcodes.\n     */\n    static final byte[] TYPE;\n\n    /**\n     * The type of CONSTANT_Class constant pool items.\n     */\n    static final int CLASS = 7;\n\n    /**\n     * The type of CONSTANT_Fieldref constant pool items.\n     */\n    static final int FIELD = 9;\n\n    /**\n     * The type of CONSTANT_Methodref constant pool items.\n     */\n    static final int METH = 10;\n\n    /**\n     * The type of CONSTANT_InterfaceMethodref constant pool items.\n     */\n    static final int IMETH = 11;\n\n    /**\n     * The type of CONSTANT_String constant pool items.\n     */\n    static final int STR = 8;\n\n    /**\n     * The type of CONSTANT_Integer constant pool items.\n     */\n    static final int INT = 3;\n\n    /**\n     * The type of CONSTANT_Float constant pool items.\n     */\n    static final int FLOAT = 4;\n\n    /**\n     * The type of CONSTANT_Long constant pool items.\n     */\n    static final int LONG = 5;\n\n    /**\n     * The type of CONSTANT_Double constant pool items.\n     */\n    static final int DOUBLE = 6;\n\n    /**\n     * The type of CONSTANT_NameAndType constant pool items.\n     */\n    static final int NAME_TYPE = 12;\n\n    /**\n     * The type of CONSTANT_Utf8 constant pool items.\n     */\n    static final int UTF8 = 1;\n\n    /**\n     * Normal type Item stored in the ClassWriter {@link ClassWriter#typeTable},\n     * instead of the constant pool, in order to avoid clashes with normal\n     * constant pool items in the ClassWriter constant pool's hash table.\n     */\n    static final int TYPE_NORMAL = 13;\n\n    /**\n     * Uninitialized type Item stored in the ClassWriter\n     * {@link ClassWriter#typeTable}, instead of the constant pool, in order to\n     * avoid clashes with normal constant pool items in the ClassWriter constant\n     * pool's hash table.\n     */\n    static final int TYPE_UNINIT = 14;\n\n    /**\n     * Merged type Item stored in the ClassWriter {@link ClassWriter#typeTable},\n     * instead of the constant pool, in order to avoid clashes with normal\n     * constant pool items in the ClassWriter constant pool's hash table.\n     */\n    static final int TYPE_MERGED = 15;\n\n    /**\n     * The class reader from which this class writer was constructed, if any.\n     */\n    ClassReader cr;\n\n    /**\n     * Minor and major version numbers of the class to be generated.\n     */\n    int version;\n\n    /**\n     * Index of the next item to be added in the constant pool.\n     */\n    int index;\n\n    /**\n     * The constant pool of this class.\n     */\n    final ByteVector pool;\n\n    /**\n     * The constant pool's hash table data.\n     */\n    Item[] items;\n\n    /**\n     * The threshold of the constant pool's hash table.\n     */\n    int threshold;\n\n    /**\n     * A reusable key used to look for items in the {@link #items} hash table.\n     */\n    final Item key;\n\n    /**\n     * A reusable key used to look for items in the {@link #items} hash table.\n     */\n    final Item key2;\n\n    /**\n     * A reusable key used to look for items in the {@link #items} hash table.\n     */\n    final Item key3;\n\n    /**\n     * A type table used to temporarily store internal names that will not\n     * necessarily be stored in the constant pool. This type table is used by\n     * the control flow and data flow analysis algorithm used to compute stack\n     * map frames from scratch. This array associates to each index <tt>i</tt>\n     * the Item whose index is <tt>i</tt>. All Item objects stored in this\n     * array are also stored in the {@link #items} hash table. These two arrays\n     * allow to retrieve an Item from its index or, conversely, to get the index\n     * of an Item from its value. Each Item stores an internal name in its\n     * {@link Item#strVal1} field.\n     */\n    Item[] typeTable;\n\n    /**\n     * Number of elements in the {@link #typeTable} array.\n     */\n    private short typeCount;\n\n    /**\n     * The access flags of this class.\n     */\n    private int access;\n\n    /**\n     * The constant pool item that contains the internal name of this class.\n     */\n    private int name;\n\n    /**\n     * The internal name of this class.\n     */\n    String thisName;\n\n    /**\n     * The constant pool item that contains the signature of this class.\n     */\n    private int signature;\n\n    /**\n     * The constant pool item that contains the internal name of the super class\n     * of this class.\n     */\n    private int superName;\n\n    /**\n     * Number of interfaces implemented or extended by this class or interface.\n     */\n    private int interfaceCount;\n\n    /**\n     * The interfaces implemented or extended by this class or interface. More\n     * precisely, this array contains the indexes of the constant pool items\n     * that contain the internal names of these interfaces.\n     */\n    private int[] interfaces;\n\n    /**\n     * The index of the constant pool item that contains the name of the source\n     * file from which this class was compiled.\n     */\n    private int sourceFile;\n\n    /**\n     * The SourceDebug attribute of this class.\n     */\n    private ByteVector sourceDebug;\n\n    /**\n     * The constant pool item that contains the name of the enclosing class of\n     * this class.\n     */\n    private int enclosingMethodOwner;\n\n    /**\n     * The constant pool item that contains the name and descriptor of the\n     * enclosing method of this class.\n     */\n    private int enclosingMethod;\n\n    /**\n     * The runtime visible annotations of this class.\n     */\n    private AnnotationWriter anns;\n\n    /**\n     * The runtime invisible annotations of this class.\n     */\n    private AnnotationWriter ianns;\n\n    /**\n     * The non standard attributes of this class.\n     */\n    private Attribute attrs;\n\n    /**\n     * The number of entries in the InnerClasses attribute.\n     */\n    private int innerClassesCount;\n\n    /**\n     * The InnerClasses attribute.\n     */\n    private ByteVector innerClasses;\n\n    /**\n     * The fields of this class. These fields are stored in a linked list of\n     * {@link FieldWriter} objects, linked to each other by their\n     * {@link FieldWriter#next} field. This field stores the first element of\n     * this list.\n     */\n    FieldWriter firstField;\n\n    /**\n     * The fields of this class. These fields are stored in a linked list of\n     * {@link FieldWriter} objects, linked to each other by their\n     * {@link FieldWriter#next} field. This field stores the last element of\n     * this list.\n     */\n    FieldWriter lastField;\n\n    /**\n     * The methods of this class. These methods are stored in a linked list of\n     * {@link MethodWriter} objects, linked to each other by their\n     * {@link MethodWriter#next} field. This field stores the first element of\n     * this list.\n     */\n    MethodWriter firstMethod;\n\n    /**\n     * The methods of this class. These methods are stored in a linked list of\n     * {@link MethodWriter} objects, linked to each other by their\n     * {@link MethodWriter#next} field. This field stores the last element of\n     * this list.\n     */\n    MethodWriter lastMethod;\n\n    /**\n     * <tt>true</tt> if the maximum stack size and number of local variables\n     * must be automatically computed.\n     */\n    private final boolean computeMaxs;\n\n    /**\n     * <tt>true</tt> if the stack map frames must be recomputed from scratch.\n     */\n    private final boolean computeFrames;\n\n    /**\n     * <tt>true</tt> if the stack map tables of this class are invalid. The\n     * {@link MethodWriter#resizeInstructions} method cannot transform existing\n     * stack map tables, and so produces potentially invalid classes when it is\n     * executed. In this case the class is reread and rewritten with the\n     * {@link #COMPUTE_FRAMES} option (the resizeInstructions method can resize\n     * stack map tables when this option is used).\n     */\n    boolean invalidFrames;\n\n    // ------------------------------------------------------------------------\n    // Static initializer\n    // ------------------------------------------------------------------------\n    /**\n     * Computes the instruction types of JVM opcodes.\n     */\n    static {\n        int i;\n        byte[] b = new byte[220];\n        String s = \"AAAAAAAAAAAAAAAABCKLLDDDDDEEEEEEEEEEEEEEEEEEEEAAAAAAAADD\" + \"DDDEEEEEEEEEEEEEEEEEEEEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAAIIIIIIIIIIIIIIIIDNOAA\" + \"AAAAGGGGGGGHHFBFAAFFAAQPIIJJIIIIIIIIIIIIIIIIII\";\n        for (i = 0; i < b.length; ++i) {\n            b[i] = (byte) (s.charAt(i) - 'A');\n        }\n        TYPE = b;\n        // code to generate the above string\n        //\n        // // SBYTE_INSN instructions\n        // b[Constants.NEWARRAY] = SBYTE_INSN;\n        // b[Constants.BIPUSH] = SBYTE_INSN;\n        //\n        // // SHORT_INSN instructions\n        // b[Constants.SIPUSH] = SHORT_INSN;\n        //\n        // // (IMPL)VAR_INSN instructions\n        // b[Constants.RET] = VAR_INSN;\n        // for (i = Constants.ILOAD; i <= Constants.ALOAD; ++i) {\n        // b[i] = VAR_INSN;\n        // }\n        // for (i = Constants.ISTORE; i <= Constants.ASTORE; ++i) {\n        // b[i] = VAR_INSN;\n        // }\n        // for (i = 26; i <= 45; ++i) { // ILOAD_0 to ALOAD_3\n        // b[i] = IMPLVAR_INSN;\n        // }\n        // for (i = 59; i <= 78; ++i) { // ISTORE_0 to ASTORE_3\n        // b[i] = IMPLVAR_INSN;\n        // }\n        //\n        // // TYPE_INSN instructions\n        // b[Constants.NEW] = TYPE_INSN;\n        // b[Constants.ANEWARRAY] = TYPE_INSN;\n        // b[Constants.CHECKCAST] = TYPE_INSN;\n        // b[Constants.INSTANCEOF] = TYPE_INSN;\n        //\n        // // (Set)FIELDORMETH_INSN instructions\n        // for (i = Constants.GETSTATIC; i <= Constants.INVOKESTATIC; ++i) {\n        // b[i] = FIELDORMETH_INSN;\n        // }\n        // b[Constants.INVOKEINTERFACE] = ITFDYNMETH_INSN;\n        // b[Constants.INVOKEDYNAMIC] = ITFDYNMETH_INSN;\n        //\n        // // LABEL(W)_INSN instructions\n        // for (i = Constants.IFEQ; i <= Constants.JSR; ++i) {\n        // b[i] = LABEL_INSN;\n        // }\n        // b[Constants.IFNULL] = LABEL_INSN;\n        // b[Constants.IFNONNULL] = LABEL_INSN;\n        // b[200] = LABELW_INSN; // GOTO_W\n        // b[201] = LABELW_INSN; // JSR_W\n        // // temporary opcodes used internally by ASM - see Label and\n        // MethodWriter\n        // for (i = 202; i < 220; ++i) {\n        // b[i] = LABEL_INSN;\n        // }\n        //\n        // // LDC(_W) instructions\n        // b[Constants.LDC] = LDC_INSN;\n        // b[19] = LDCW_INSN; // LDC_W\n        // b[20] = LDCW_INSN; // LDC2_W\n        //\n        // // special instructions\n        // b[Constants.IINC] = IINC_INSN;\n        // b[Constants.TABLESWITCH] = TABL_INSN;\n        // b[Constants.LOOKUPSWITCH] = LOOK_INSN;\n        // b[Constants.MULTIANEWARRAY] = MANA_INSN;\n        // b[196] = WIDE_INSN; // WIDE\n        //\n        // for (i = 0; i < b.length; ++i) {\n        // System.err.print((char)('A' + b[i]));\n        // }\n        // System.err.println();\n    }\n\n    // ------------------------------------------------------------------------\n    // Constructor\n    // ------------------------------------------------------------------------\n    /**\n     * Constructs a new {@link ClassWriter} object.\n     *\n     * @param flags option flags that can be used to modify the default behavior\n     *        of this class. See {@link #COMPUTE_MAXS}, {@link #COMPUTE_FRAMES}.\n     */\n    public ClassWriter(final int flags) {\n        index = 1;\n        pool = new ByteVector();\n        items = new Item[256];\n        threshold = (int) (0.75d * items.length);\n        key = new Item();\n        key2 = new Item();\n        key3 = new Item();\n        this.computeMaxs = (flags & COMPUTE_MAXS) != 0;\n        this.computeFrames = (flags & COMPUTE_FRAMES) != 0;\n    }\n\n    /**\n     * Constructs a new {@link ClassWriter} object and enables optimizations for\n     * \"mostly add\" bytecode transformations. These optimizations are the\n     * following:\n     *\n     * <ul> <li>The constant pool from the original class is copied as is in\n     * the new class, which saves time. New constant pool entries will be added\n     * at the end if necessary, but unused constant pool entries <i>won't be\n     * removed</i>.</li> <li>Methods that are not transformed are copied as\n     * is in the new class, directly from the original class bytecode (i.e.\n     * without emitting visit events for all the method instructions), which\n     * saves a <i>lot</i> of time. Untransformed methods are detected by the\n     * fact that the {@link ClassReader} receives {@link MethodVisitor} objects\n     * that come from a {@link ClassWriter} (and not from a custom\n     * {@link ClassAdapter} or any other {@link ClassVisitor} instance).</li>\n     * </ul>\n     *\n     * @param classReader the {@link ClassReader} used to read the original\n     *        class. It will be used to copy the entire constant pool from the\n     *        original class and also to copy other fragments of original\n     *        bytecode where applicable.\n     * @param flags option flags that can be used to modify the default behavior\n     *        of this class. See {@link #COMPUTE_MAXS}, {@link #COMPUTE_FRAMES}.\n     */\n    public ClassWriter(final ClassReader classReader, final int flags) {\n        this(flags);\n        classReader.copyPool(this);\n        this.cr = classReader;\n    }\n\n    // ------------------------------------------------------------------------\n    // Implementation of the ClassVisitor interface\n    // ------------------------------------------------------------------------\n    public void visit(final int version, final int access, final String name, final String signature, final String superName, final String[] interfaces) {\n        this.version = version;\n        this.access = access;\n        this.name = newClass(name);\n        thisName = name;\n        if (ClassReader.SIGNATURES && signature != null) {\n            this.signature = newUTF8(signature);\n        }\n        this.superName = superName == null ? 0 : newClass(superName);\n        if (interfaces != null && interfaces.length > 0) {\n            interfaceCount = interfaces.length;\n            this.interfaces = new int[interfaceCount];\n            for (int i = 0; i < interfaceCount; ++i) {\n                this.interfaces[i] = newClass(interfaces[i]);\n            }\n        }\n    }\n\n    public void visitSource(final String file, final String debug) {\n        if (file != null) {\n            sourceFile = newUTF8(file);\n        }\n        if (debug != null) {\n            sourceDebug = new ByteVector().putUTF8(debug);\n        }\n    }\n\n    public void visitOuterClass(final String owner, final String name, final String desc) {\n        enclosingMethodOwner = newClass(owner);\n        if (name != null && desc != null) {\n            enclosingMethod = newNameType(name, desc);\n        }\n    }\n\n    public AnnotationVisitor visitAnnotation(final String desc, final boolean visible) {\n        if (!ClassReader.ANNOTATIONS) {\n            return null;\n        }\n        ByteVector bv = new ByteVector();\n        // write type, and reserve space for values count\n        bv.putShort(newUTF8(desc)).putShort(0);\n        AnnotationWriter aw = new AnnotationWriter(this, true, bv, bv, 2);\n        if (visible) {\n            aw.next = anns;\n            anns = aw;\n        } else {\n            aw.next = ianns;\n            ianns = aw;\n        }\n        return aw;\n    }\n\n    public void visitAttribute(final Attribute attr) {\n        attr.next = attrs;\n        attrs = attr;\n    }\n\n    public void visitInnerClass(final String name, final String outerName, final String innerName, final int access) {\n        if (innerClasses == null) {\n            innerClasses = new ByteVector();\n        }\n        ++innerClassesCount;\n        innerClasses.putShort(name == null ? 0 : newClass(name));\n        innerClasses.putShort(outerName == null ? 0 : newClass(outerName));\n        innerClasses.putShort(innerName == null ? 0 : newUTF8(innerName));\n        innerClasses.putShort(access);\n    }\n\n    public FieldVisitor visitField(final int access, final String name, final String desc, final String signature, final Object value) {\n        return new FieldWriter(this, access, name, desc, signature, value);\n    }\n\n    public MethodVisitor visitMethod(final int access, final String name, final String desc, final String signature, final String[] exceptions) {\n        return new MethodWriter(this, access, name, desc, signature, exceptions, computeMaxs, computeFrames);\n    }\n\n    public void visitEnd() {\n    }\n\n    // ------------------------------------------------------------------------\n    // Other public methods\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the bytecode of the class that was build with this class writer.\n     *\n     * @return the bytecode of the class that was build with this class writer.\n     */\n    public byte[] toByteArray() {\n        // computes the real size of the bytecode of this class\n        int size = 24 + 2 * interfaceCount;\n        int nbFields = 0;\n        FieldWriter fb = firstField;\n        while (fb != null) {\n            ++nbFields;\n            size += fb.getSize();\n            fb = fb.next;\n        }\n        int nbMethods = 0;\n        MethodWriter mb = firstMethod;\n        while (mb != null) {\n            ++nbMethods;\n            size += mb.getSize();\n            mb = mb.next;\n        }\n        int attributeCount = 0;\n        if (ClassReader.SIGNATURES && signature != 0) {\n            ++attributeCount;\n            size += 8;\n            newUTF8(\"Signature\");\n        }\n        if (sourceFile != 0) {\n            ++attributeCount;\n            size += 8;\n            newUTF8(\"SourceFile\");\n        }\n        if (sourceDebug != null) {\n            ++attributeCount;\n            size += sourceDebug.length + 4;\n            newUTF8(\"SourceDebugExtension\");\n        }\n        if (enclosingMethodOwner != 0) {\n            ++attributeCount;\n            size += 10;\n            newUTF8(\"EnclosingMethod\");\n        }\n        if ((access & Opcodes.ACC_DEPRECATED) != 0) {\n            ++attributeCount;\n            size += 6;\n            newUTF8(\"Deprecated\");\n        }\n        if ((access & Opcodes.ACC_SYNTHETIC) != 0 && (version & 0xffff) < Opcodes.V1_5) {\n            ++attributeCount;\n            size += 6;\n            newUTF8(\"Synthetic\");\n        }\n        if (innerClasses != null) {\n            ++attributeCount;\n            size += 8 + innerClasses.length;\n            newUTF8(\"InnerClasses\");\n        }\n        if (ClassReader.ANNOTATIONS && anns != null) {\n            ++attributeCount;\n            size += 8 + anns.getSize();\n            newUTF8(\"RuntimeVisibleAnnotations\");\n        }\n        if (ClassReader.ANNOTATIONS && ianns != null) {\n            ++attributeCount;\n            size += 8 + ianns.getSize();\n            newUTF8(\"RuntimeInvisibleAnnotations\");\n        }\n        if (attrs != null) {\n            attributeCount += attrs.getCount();\n            size += attrs.getSize(this, null, 0, -1, -1);\n        }\n        size += pool.length;\n        // allocates a byte vector of this size, in order to avoid unnecessary\n        // arraycopy operations in the ByteVector.enlarge() method\n        ByteVector out = new ByteVector(size);\n        out.putInt(0xCAFEBABE).putInt(version);\n        out.putShort(index).putByteArray(pool.data, 0, pool.length);\n        out.putShort(access).putShort(name).putShort(superName);\n        out.putShort(interfaceCount);\n        for (int i = 0; i < interfaceCount; ++i) {\n            out.putShort(interfaces[i]);\n        }\n        out.putShort(nbFields);\n        fb = firstField;\n        while (fb != null) {\n            fb.put(out);\n            fb = fb.next;\n        }\n        out.putShort(nbMethods);\n        mb = firstMethod;\n        while (mb != null) {\n            mb.put(out);\n            mb = mb.next;\n        }\n        out.putShort(attributeCount);\n        if (ClassReader.SIGNATURES && signature != 0) {\n            out.putShort(newUTF8(\"Signature\")).putInt(2).putShort(signature);\n        }\n        if (sourceFile != 0) {\n            out.putShort(newUTF8(\"SourceFile\")).putInt(2).putShort(sourceFile);\n        }\n        if (sourceDebug != null) {\n            int len = sourceDebug.length - 2;\n            out.putShort(newUTF8(\"SourceDebugExtension\")).putInt(len);\n            out.putByteArray(sourceDebug.data, 2, len);\n        }\n        if (enclosingMethodOwner != 0) {\n            out.putShort(newUTF8(\"EnclosingMethod\")).putInt(4);\n            out.putShort(enclosingMethodOwner).putShort(enclosingMethod);\n        }\n        if ((access & Opcodes.ACC_DEPRECATED) != 0) {\n            out.putShort(newUTF8(\"Deprecated\")).putInt(0);\n        }\n        if ((access & Opcodes.ACC_SYNTHETIC) != 0 && (version & 0xffff) < Opcodes.V1_5) {\n            out.putShort(newUTF8(\"Synthetic\")).putInt(0);\n        }\n        if (innerClasses != null) {\n            out.putShort(newUTF8(\"InnerClasses\"));\n            out.putInt(innerClasses.length + 2).putShort(innerClassesCount);\n            out.putByteArray(innerClasses.data, 0, innerClasses.length);\n        }\n        if (ClassReader.ANNOTATIONS && anns != null) {\n            out.putShort(newUTF8(\"RuntimeVisibleAnnotations\"));\n            anns.put(out);\n        }\n        if (ClassReader.ANNOTATIONS && ianns != null) {\n            out.putShort(newUTF8(\"RuntimeInvisibleAnnotations\"));\n            ianns.put(out);\n        }\n        if (attrs != null) {\n            attrs.put(this, null, 0, -1, -1, out);\n        }\n        if (invalidFrames) {\n            ClassWriter cw = new ClassWriter(COMPUTE_FRAMES);\n            new ClassReader(out.data).accept(cw, ClassReader.SKIP_FRAMES);\n            return cw.toByteArray();\n        }\n        return out.data;\n    }\n\n    // ------------------------------------------------------------------------\n    // Utility methods: constant pool management\n    // ------------------------------------------------------------------------\n    /**\n     * Adds a number or string constant to the constant pool of the class being\n     * build. Does nothing if the constant pool already contains a similar item.\n     *\n     * @param cst the value of the constant to be added to the constant pool.\n     *        This parameter must be an {@link Integer}, a {@link Float}, a\n     *        {@link Long}, a {@link Double}, a {@link String} or a\n     *        {@link Type}.\n     * @return a new or already existing constant item with the given value.\n     */\n    Item newConstItem(final Object cst) {\n        if (cst instanceof Integer) {\n            int val = ((Integer) cst).intValue();\n            return newInteger(val);\n        } else if (cst instanceof Byte) {\n            int val = ((Byte) cst).intValue();\n            return newInteger(val);\n        } else if (cst instanceof Character) {\n            int val = ((Character) cst).charValue();\n            return newInteger(val);\n        } else if (cst instanceof Short) {\n            int val = ((Short) cst).intValue();\n            return newInteger(val);\n        } else if (cst instanceof Boolean) {\n            int val = ((Boolean) cst).booleanValue() ? 1 : 0;\n            return newInteger(val);\n        } else if (cst instanceof Float) {\n            float val = ((Float) cst).floatValue();\n            return newFloat(val);\n        } else if (cst instanceof Long) {\n            long val = ((Long) cst).longValue();\n            return newLong(val);\n        } else if (cst instanceof Double) {\n            double val = ((Double) cst).doubleValue();\n            return newDouble(val);\n        } else if (cst instanceof String) {\n            return newString((String) cst);\n        } else if (cst instanceof Type) {\n            Type t = (Type) cst;\n            return newClassItem(t.getSort() == Type.OBJECT ? t.getInternalName() : t.getDescriptor());\n        } else {\n            throw new IllegalArgumentException(\"value \" + cst);\n        }\n    }\n\n    /**\n     * Adds a number or string constant to the constant pool of the class being\n     * build. Does nothing if the constant pool already contains a similar item.\n     * <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param cst the value of the constant to be added to the constant pool.\n     *        This parameter must be an {@link Integer}, a {@link Float}, a\n     *        {@link Long}, a {@link Double} or a {@link String}.\n     * @return the index of a new or already existing constant item with the\n     *         given value.\n     */\n    public int newConst(final Object cst) {\n        return newConstItem(cst).index;\n    }\n\n    /**\n     * Adds an UTF8 string to the constant pool of the class being build. Does\n     * nothing if the constant pool already contains a similar item. <i>This\n     * method is intended for {@link Attribute} sub classes, and is normally not\n     * needed by class generators or adapters.</i>\n     *\n     * @param value the String value.\n     * @return the index of a new or already existing UTF8 item.\n     */\n    public int newUTF8(final String value) {\n        key.set(UTF8, value, null, null);\n        Item result = get(key);\n        if (result == null) {\n            pool.putByte(UTF8).putUTF8(value);\n            result = new Item(index++, key);\n            put(result);\n        }\n        return result.index;\n    }\n\n    /**\n     * Adds a class reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     * <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param value the internal name of the class.\n     * @return a new or already existing class reference item.\n     */\n    Item newClassItem(final String value) {\n        key2.set(CLASS, value, null, null);\n        Item result = get(key2);\n        if (result == null) {\n            pool.put12(CLASS, newUTF8(value));\n            result = new Item(index++, key2);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a class reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     * <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param value the internal name of the class.\n     * @return the index of a new or already existing class reference item.\n     */\n    public int newClass(final String value) {\n        return newClassItem(value).index;\n    }\n\n    /**\n     * Adds a field reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     *\n     * @param owner the internal name of the field's owner class.\n     * @param name the field's name.\n     * @param desc the field's descriptor.\n     * @return a new or already existing field reference item.\n     */\n    Item newFieldItem(final String owner, final String name, final String desc) {\n        key3.set(FIELD, owner, name, desc);\n        Item result = get(key3);\n        if (result == null) {\n            put122(FIELD, newClass(owner), newNameType(name, desc));\n            result = new Item(index++, key3);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a field reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     * <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param owner the internal name of the field's owner class.\n     * @param name the field's name.\n     * @param desc the field's descriptor.\n     * @return the index of a new or already existing field reference item.\n     */\n    public int newField(final String owner, final String name, final String desc) {\n        return newFieldItem(owner, name, desc).index;\n    }\n\n    /**\n     * Adds a method reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     *\n     * @param owner the internal name of the method's owner class.\n     * @param name the method's name.\n     * @param desc the method's descriptor.\n     * @param itf <tt>true</tt> if <tt>owner</tt> is an interface.\n     * @return a new or already existing method reference item.\n     */\n    Item newMethodItem(final String owner, final String name, final String desc, final boolean itf) {\n        int type = itf ? IMETH : METH;\n        key3.set(type, owner, name, desc);\n        Item result = get(key3);\n        if (result == null) {\n            put122(type, newClass(owner), newNameType(name, desc));\n            result = new Item(index++, key3);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a method reference to the constant pool of the class being build.\n     * Does nothing if the constant pool already contains a similar item.\n     * <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param owner the internal name of the method's owner class.\n     * @param name the method's name.\n     * @param desc the method's descriptor.\n     * @param itf <tt>true</tt> if <tt>owner</tt> is an interface.\n     * @return the index of a new or already existing method reference item.\n     */\n    public int newMethod(final String owner, final String name, final String desc, final boolean itf) {\n        return newMethodItem(owner, name, desc, itf).index;\n    }\n\n    /**\n     * Adds an integer to the constant pool of the class being build. Does\n     * nothing if the constant pool already contains a similar item.\n     *\n     * @param value the int value.\n     * @return a new or already existing int item.\n     */\n    Item newInteger(final int value) {\n        key.set(value);\n        Item result = get(key);\n        if (result == null) {\n            pool.putByte(INT).putInt(value);\n            result = new Item(index++, key);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a float to the constant pool of the class being build. Does nothing\n     * if the constant pool already contains a similar item.\n     *\n     * @param value the float value.\n     * @return a new or already existing float item.\n     */\n    Item newFloat(final float value) {\n        key.set(value);\n        Item result = get(key);\n        if (result == null) {\n            pool.putByte(FLOAT).putInt(key.intVal);\n            result = new Item(index++, key);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a long to the constant pool of the class being build. Does nothing\n     * if the constant pool already contains a similar item.\n     *\n     * @param value the long value.\n     * @return a new or already existing long item.\n     */\n    Item newLong(final long value) {\n        key.set(value);\n        Item result = get(key);\n        if (result == null) {\n            pool.putByte(LONG).putLong(value);\n            result = new Item(index, key);\n            put(result);\n            index += 2;\n        }\n        return result;\n    }\n\n    /**\n     * Adds a double to the constant pool of the class being build. Does nothing\n     * if the constant pool already contains a similar item.\n     *\n     * @param value the double value.\n     * @return a new or already existing double item.\n     */\n    Item newDouble(final double value) {\n        key.set(value);\n        Item result = get(key);\n        if (result == null) {\n            pool.putByte(DOUBLE).putLong(key.longVal);\n            result = new Item(index, key);\n            put(result);\n            index += 2;\n        }\n        return result;\n    }\n\n    /**\n     * Adds a string to the constant pool of the class being build. Does nothing\n     * if the constant pool already contains a similar item.\n     *\n     * @param value the String value.\n     * @return a new or already existing string item.\n     */\n    private Item newString(final String value) {\n        key2.set(STR, value, null, null);\n        Item result = get(key2);\n        if (result == null) {\n            pool.put12(STR, newUTF8(value));\n            result = new Item(index++, key2);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a name and type to the constant pool of the class being build. Does\n     * nothing if the constant pool already contains a similar item. <i>This\n     * method is intended for {@link Attribute} sub classes, and is normally not\n     * needed by class generators or adapters.</i>\n     *\n     * @param name a name.\n     * @param desc a type descriptor.\n     * @return the index of a new or already existing name and type item.\n     */\n    public int newNameType(final String name, final String desc) {\n        return newNameTypeItem(name, desc).index;\n    }\n\n    /**\n     * Adds a name and type to the constant pool of the class being build. Does\n     * nothing if the constant pool already contains a similar item.\n     *\n     * @param name a name.\n     * @param desc a type descriptor.\n     * @return a new or already existing name and type item.\n     */\n    Item newNameTypeItem(final String name, final String desc) {\n        key2.set(NAME_TYPE, name, desc, null);\n        Item result = get(key2);\n        if (result == null) {\n            put122(NAME_TYPE, newUTF8(name), newUTF8(desc));\n            result = new Item(index++, key2);\n            put(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds the given internal name to {@link #typeTable} and returns its index.\n     * Does nothing if the type table already contains this internal name.\n     *\n     * @param type the internal name to be added to the type table.\n     * @return the index of this internal name in the type table.\n     */\n    int addType(final String type) {\n        key.set(TYPE_NORMAL, type, null, null);\n        Item result = get(key);\n        if (result == null) {\n            result = addType(key);\n        }\n        return result.index;\n    }\n\n    /**\n     * Adds the given \"uninitialized\" type to {@link #typeTable} and returns its\n     * index. This method is used for UNINITIALIZED types, made of an internal\n     * name and a bytecode offset.\n     *\n     * @param type the internal name to be added to the type table.\n     * @param offset the bytecode offset of the NEW instruction that created\n     *        this UNINITIALIZED type value.\n     * @return the index of this internal name in the type table.\n     */\n    int addUninitializedType(final String type, final int offset) {\n        key.type = TYPE_UNINIT;\n        key.intVal = offset;\n        key.strVal1 = type;\n        key.hashCode = 0x7FFFFFFF & (TYPE_UNINIT + type.hashCode() + offset);\n        Item result = get(key);\n        if (result == null) {\n            result = addType(key);\n        }\n        return result.index;\n    }\n\n    /**\n     * Adds the given Item to {@link #typeTable}.\n     *\n     * @param item the value to be added to the type table.\n     * @return the added Item, which a new Item instance with the same value as\n     *         the given Item.\n     */\n    private Item addType(final Item item) {\n        ++typeCount;\n        Item result = new Item(typeCount, key);\n        put(result);\n        if (typeTable == null) {\n            typeTable = new Item[16];\n        }\n        if (typeCount == typeTable.length) {\n            Item[] newTable = new Item[2 * typeTable.length];\n            System.arraycopy(typeTable, 0, newTable, 0, typeTable.length);\n            typeTable = newTable;\n        }\n        typeTable[typeCount] = result;\n        return result;\n    }\n\n    /**\n     * Returns the index of the common super type of the two given types. This\n     * method calls {@link #getCommonSuperClass} and caches the result in the\n     * {@link #items} hash table to speedup future calls with the same\n     * parameters.\n     *\n     * @param type1 index of an internal name in {@link #typeTable}.\n     * @param type2 index of an internal name in {@link #typeTable}.\n     * @return the index of the common super type of the two given types.\n     */\n    int getMergedType(final int type1, final int type2) {\n        key2.type = TYPE_MERGED;\n        key2.longVal = type1 | (((long) type2) << 32);\n        key2.hashCode = 0x7FFFFFFF & (TYPE_MERGED + type1 + type2);\n        Item result = get(key2);\n        if (result == null) {\n            String t = typeTable[type1].strVal1;\n            String u = typeTable[type2].strVal1;\n            key2.intVal = addType(getCommonSuperClass(t, u));\n            result = new Item((short) 0, key2);\n            put(result);\n        }\n        return result.intVal;\n    }\n\n    /**\n     * Returns the common super type of the two given types. The default\n     * implementation of this method <i>loads<i> the two given classes and uses\n     * the java.lang.Class methods to find the common super class. It can be\n     * overridden to compute this common super type in other ways, in particular\n     * without actually loading any class, or to take into account the class\n     * that is currently being generated by this ClassWriter, which can of\n     * course not be loaded since it is under construction.\n     *\n     * @param type1 the internal name of a class.\n     * @param type2 the internal name of another class.\n     * @return the internal name of the common super class of the two given\n     *         classes.\n     */\n    protected String getCommonSuperClass(final String type1, final String type2) {\n        Class c, d;\n        try {\n            c = Class.forName(type1.replace('/', '.'));\n            d = Class.forName(type2.replace('/', '.'));\n        } catch (Exception e) {\n            throw new RuntimeException(e.toString());\n        }\n        if (c.isAssignableFrom(d)) {\n            return type1;\n        }\n        if (d.isAssignableFrom(c)) {\n            return type2;\n        }\n        if (c.isInterface() || d.isInterface()) {\n            return \"java/lang/Object\";\n        } else {\n            do {\n                c = c.getSuperclass();\n            } while (!c.isAssignableFrom(d));\n            return c.getName().replace('.', '/');\n        }\n    }\n\n    /**\n     * Returns the constant pool's hash table item which is equal to the given\n     * item.\n     *\n     * @param key a constant pool item.\n     * @return the constant pool's hash table item which is equal to the given\n     *         item, or <tt>null</tt> if there is no such item.\n     */\n    private Item get(final Item key) {\n        Item i = items[key.hashCode % items.length];\n        while (i != null && (i.type != key.type || !key.isEqualTo(i))) {\n            i = i.next;\n        }\n        return i;\n    }\n\n    /**\n     * Puts the given item in the constant pool's hash table. The hash table\n     * <i>must</i> not already contains this item.\n     *\n     * @param i the item to be added to the constant pool's hash table.\n     */\n    private void put(final Item i) {\n        if (index > threshold) {\n            int ll = items.length;\n            int nl = ll * 2 + 1;\n            Item[] newItems = new Item[nl];\n            for (int l = ll - 1; l >= 0; --l) {\n                Item j = items[l];\n                while (j != null) {\n                    int index = j.hashCode % newItems.length;\n                    Item k = j.next;\n                    j.next = newItems[index];\n                    newItems[index] = j;\n                    j = k;\n                }\n            }\n            items = newItems;\n            threshold = (int) (nl * 0.75);\n        }\n        int index = i.hashCode % items.length;\n        i.next = items[index];\n        items[index] = i;\n    }\n\n    /**\n     * Puts one byte and two shorts into the constant pool.\n     *\n     * @param b a byte.\n     * @param s1 a short.\n     * @param s2 another short.\n     */\n    private void put122(final int b, final int s1, final int s2) {\n        pool.put12(b, s1).putShort(s2);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/ClassWriterTest9.java",
		"test_prompt": "// ClassWriterTest9.java\npackage org.objectweb.asm.jip;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassWriter}.\n* It contains ten unit test cases for the {@link ClassWriter#newNameType(String, String)} method.\n*/\nclass ClassWriterTest9 {"
	},
	{
		"original_code": "// ClassReader.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\nimport java.io.InputStream;\nimport java.io.IOException;\n\n/**\n * A Java class parser to make a {@link ClassVisitor} visit an existing class.\n * This class parses a byte array conforming to the Java class file format and\n * calls the appropriate visit methods of a given class visitor for each field,\n * method and bytecode instruction encountered.\n *\n * @author Eric Bruneton\n * @author Eugene Kuleshov\n */\npublic class ClassReader {\n\n    /**\n     * True to enable signatures support.\n     */\n    static final boolean SIGNATURES = true;\n\n    /**\n     * True to enable annotations support.\n     */\n    static final boolean ANNOTATIONS = true;\n\n    /**\n     * True to enable stack map frames support.\n     */\n    static final boolean FRAMES = true;\n\n    /**\n     * True to enable bytecode writing support.\n     */\n    static final boolean WRITER = true;\n\n    /**\n     * True to enable JSR_W and GOTO_W support.\n     */\n    static final boolean RESIZE = true;\n\n    /**\n     * Flag to skip method code. If this class is set <code>CODE</code>\n     * attribute won't be visited. This can be used, for example, to retrieve\n     * annotations for methods and method parameters.\n     */\n    public static final int SKIP_CODE = 1;\n\n    /**\n     * Flag to skip the debug information in the class. If this flag is set the\n     * debug information of the class is not visited, i.e. the\n     * {@link MethodVisitor#visitLocalVariable visitLocalVariable} and\n     * {@link MethodVisitor#visitLineNumber visitLineNumber} methods will not be\n     * called.\n     */\n    public static final int SKIP_DEBUG = 2;\n\n    /**\n     * Flag to skip the stack map frames in the class. If this flag is set the\n     * stack map frames of the class is not visited, i.e. the\n     * {@link MethodVisitor#visitFrame visitFrame} method will not be called.\n     * This flag is useful when the {@link ClassWriter#COMPUTE_FRAMES} option is\n     * used: it avoids visiting frames that will be ignored and recomputed from\n     * scratch in the class writer.\n     */\n    public static final int SKIP_FRAMES = 4;\n\n    /**\n     * Flag to expand the stack map frames. By default stack map frames are\n     * visited in their original format (i.e. \"expanded\" for classes whose\n     * version is less than V1_6, and \"compressed\" for the other classes). If\n     * this flag is set, stack map frames are always visited in expanded format\n     * (this option adds a decompression/recompression step in ClassReader and\n     * ClassWriter which degrades performances quite a lot).\n     */\n    public static final int EXPAND_FRAMES = 8;\n\n    /**\n     * The class to be parsed. <i>The content of this array must not be\n     * modified. This field is intended for {@link Attribute} sub classes, and\n     * is normally not needed by class generators or adapters.</i>\n     */\n    public final byte[] b;\n\n    /**\n     * The start index of each constant pool item in {@link #b b}, plus one.\n     * The one byte offset skips the constant pool item tag that indicates its\n     * type.\n     */\n    private final int[] items;\n\n    /**\n     * The String objects corresponding to the CONSTANT_Utf8 items. This cache\n     * avoids multiple parsing of a given CONSTANT_Utf8 constant pool item,\n     * which GREATLY improves performances (by a factor 2 to 3). This caching\n     * strategy could be extended to all constant pool items, but its benefit\n     * would not be so great for these items (because they are much less\n     * expensive to parse than CONSTANT_Utf8 items).\n     */\n    private final String[] strings;\n\n    /**\n     * Maximum length of the strings contained in the constant pool of the\n     * class.\n     */\n    private final int maxStringLength;\n\n    /**\n     * Start index of the class header information (access, name...) in\n     * {@link #b b}.\n     */\n    public final int header;\n\n    // ------------------------------------------------------------------------\n    // Constructors\n    // ------------------------------------------------------------------------\n    /**\n     * Constructs a new {@link ClassReader} object.\n     *\n     * @param b the bytecode of the class to be read.\n     */\n    public ClassReader(final byte[] b) {\n        this(b, 0, b.length);\n    }\n\n    /**\n     * Constructs a new {@link ClassReader} object.\n     *\n     * @param b the bytecode of the class to be read.\n     * @param off the start offset of the class data.\n     * @param len the length of the class data.\n     */\n    public ClassReader(final byte[] b, final int off, final int len) {\n        this.b = b;\n        // parses the constant pool\n        items = new int[readUnsignedShort(off + 8)];\n        int n = items.length;\n        strings = new String[n];\n        int max = 0;\n        int index = off + 10;\n        for (int i = 1; i < n; ++i) {\n            items[i] = index + 1;\n            int size;\n            switch(b[index]) {\n                case ClassWriter.FIELD:\n                case ClassWriter.METH:\n                case ClassWriter.IMETH:\n                case ClassWriter.INT:\n                case ClassWriter.FLOAT:\n                case ClassWriter.NAME_TYPE:\n                    size = 5;\n                    break;\n                case ClassWriter.LONG:\n                case ClassWriter.DOUBLE:\n                    size = 9;\n                    ++i;\n                    break;\n                case ClassWriter.UTF8:\n                    size = 3 + readUnsignedShort(index + 1);\n                    if (size > max) {\n                        max = size;\n                    }\n                    break;\n                // case ClassWriter.CLASS:\n                // case ClassWriter.STR:\n                default:\n                    size = 3;\n                    break;\n            }\n            index += size;\n        }\n        maxStringLength = max;\n        // the class header information starts just after the constant pool\n        header = index;\n    }\n\n    /**\n     * Returns the class's access flags (see {@link Opcodes}). This value may\n     * not reflect Deprecated and Synthetic flags when bytecode is before 1.5\n     * and those flags are represented by attributes.\n     *\n     * @return the class access flags\n     *\n     * @see ClassVisitor#visit(int, int, String, String, String, String[])\n     */\n    public int getAccess() {\n        return readUnsignedShort(header);\n    }\n\n    /**\n     * Returns the internal name of the class (see\n     * {@link Type#getInternalName() getInternalName}).\n     *\n     * @return the internal class name\n     *\n     * @see ClassVisitor#visit(int, int, String, String, String, String[])\n     */\n    public String getClassName() {\n        return readClass(header + 2, new char[maxStringLength]);\n    }\n\n    /**\n     * Returns the internal of name of the super class (see\n     * {@link Type#getInternalName() getInternalName}). For interfaces, the\n     * super class is {@link Object}.\n     *\n     * @return the internal name of super class, or <tt>null</tt> for\n     *         {@link Object} class.\n     *\n     * @see ClassVisitor#visit(int, int, String, String, String, String[])\n     */\n    public String getSuperName() {\n        int n = items[readUnsignedShort(header + 4)];\n        return n == 0 ? null : readUTF8(n, new char[maxStringLength]);\n    }\n\n    /**\n     * Returns the internal names of the class's interfaces (see\n     * {@link Type#getInternalName() getInternalName}).\n     *\n     * @return the array of internal names for all implemented interfaces or\n     *         <tt>null</tt>.\n     *\n     * @see ClassVisitor#visit(int, int, String, String, String, String[])\n     */\n    public String[] getInterfaces() {\n        int index = header + 6;\n        int n = readUnsignedShort(index);\n        String[] interfaces = new String[n];\n        if (n > 0) {\n            char[] buf = new char[maxStringLength];\n            for (int i = 0; i < n; ++i) {\n                index += 2;\n                interfaces[i] = readClass(index, buf);\n            }\n        }\n        return interfaces;\n    }\n\n    /**\n     * Copies the constant pool data into the given {@link ClassWriter}. Should\n     * be called before the {@link #accept(ClassVisitor,int)} method.\n     *\n     * @param classWriter the {@link ClassWriter} to copy constant pool into.\n     */\n    void copyPool(final ClassWriter classWriter) {\n        char[] buf = new char[maxStringLength];\n        int ll = items.length;\n        Item[] items2 = new Item[ll];\n        for (int i = 1; i < ll; i++) {\n            int index = items[i];\n            int tag = b[index - 1];\n            Item item = new Item(i);\n            int nameType;\n            switch(tag) {\n                case ClassWriter.FIELD:\n                case ClassWriter.METH:\n                case ClassWriter.IMETH:\n                    nameType = items[readUnsignedShort(index + 2)];\n                    item.set(tag, readClass(index, buf), readUTF8(nameType, buf), readUTF8(nameType + 2, buf));\n                    break;\n                case ClassWriter.INT:\n                    item.set(readInt(index));\n                    break;\n                case ClassWriter.FLOAT:\n                    item.set(Float.intBitsToFloat(readInt(index)));\n                    break;\n                case ClassWriter.NAME_TYPE:\n                    item.set(tag, readUTF8(index, buf), readUTF8(index + 2, buf), null);\n                    break;\n                case ClassWriter.LONG:\n                    item.set(readLong(index));\n                    ++i;\n                    break;\n                case ClassWriter.DOUBLE:\n                    item.set(Double.longBitsToDouble(readLong(index)));\n                    ++i;\n                    break;\n                case ClassWriter.UTF8:\n                    {\n                        String s = strings[i];\n                        if (s == null) {\n                            index = items[i];\n                            s = strings[i] = readUTF(index + 2, readUnsignedShort(index), buf);\n                        }\n                        item.set(tag, s, null, null);\n                    }\n                    break;\n                // case ClassWriter.STR:\n                // case ClassWriter.CLASS:\n                default:\n                    item.set(tag, readUTF8(index, buf), null, null);\n                    break;\n            }\n            int index2 = item.hashCode % items2.length;\n            item.next = items2[index2];\n            items2[index2] = item;\n        }\n        int off = items[1] - 1;\n        classWriter.pool.putByteArray(b, off, header - off);\n        classWriter.items = items2;\n        classWriter.threshold = (int) (0.75d * ll);\n        classWriter.index = ll;\n    }\n\n    /**\n     * Constructs a new {@link ClassReader} object.\n     *\n     * @param is an input stream from which to read the class.\n     * @throws IOException if a problem occurs during reading.\n     */\n    public ClassReader(final InputStream is) throws IOException {\n        this(readClass(is));\n    }\n\n    /**\n     * Constructs a new {@link ClassReader} object.\n     *\n     * @param name the fully qualified name of the class to be read.\n     * @throws IOException if an exception occurs during reading.\n     */\n    public ClassReader(final String name) throws IOException {\n        this(ClassLoader.getSystemResourceAsStream(name.replace('.', '/') + \".class\"));\n    }\n\n    /**\n     * Reads the bytecode of a class.\n     *\n     * @param is an input stream from which to read the class.\n     * @return the bytecode read from the given input stream.\n     * @throws IOException if a problem occurs during reading.\n     */\n    private static byte[] readClass(final InputStream is) throws IOException {\n        if (is == null) {\n            throw new IOException(\"Class not found\");\n        }\n        byte[] b = new byte[is.available()];\n        int len = 0;\n        while (true) {\n            int n = is.read(b, len, b.length - len);\n            if (n == -1) {\n                if (len < b.length) {\n                    byte[] c = new byte[len];\n                    System.arraycopy(b, 0, c, 0, len);\n                    b = c;\n                }\n                return b;\n            }\n            len += n;\n            if (len == b.length) {\n                int last = is.read();\n                if (last < 0) {\n                    return b;\n                }\n                byte[] c = new byte[b.length + 1000];\n                System.arraycopy(b, 0, c, 0, len);\n                c[len++] = (byte) last;\n                b = c;\n            }\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Public methods\n    // ------------------------------------------------------------------------\n    /**\n     * Makes the given visitor visit the Java class of this {@link ClassReader}.\n     * This class is the one specified in the constructor (see\n     * {@link #ClassReader(byte[]) ClassReader}).\n     *\n     * @param classVisitor the visitor that must visit this class.\n     * @param flags option flags that can be used to modify the default behavior\n     *        of this class. See {@link #SKIP_DEBUG}, {@link #EXPAND_FRAMES},\n     *        {@link #SKIP_FRAMES}, {@link #SKIP_CODE}.\n     */\n    public void accept(final ClassVisitor classVisitor, final int flags) {\n        accept(classVisitor, new Attribute[0], flags);\n    }\n\n    /**\n     * Makes the given visitor visit the Java class of this {@link ClassReader}.\n     * This class is the one specified in the constructor (see\n     * {@link #ClassReader(byte[]) ClassReader}).\n     *\n     * @param classVisitor the visitor that must visit this class.\n     * @param attrs prototypes of the attributes that must be parsed during the\n     *        visit of the class. Any attribute whose type is not equal to the\n     *        type of one the prototypes will not be parsed: its byte array\n     *        value will be passed unchanged to the ClassWriter. <i>This may\n     *        corrupt it if this value contains references to the constant pool,\n     *        or has syntactic or semantic links with a class element that has\n     *        been transformed by a class adapter between the reader and the\n     *        writer</i>.\n     * @param flags option flags that can be used to modify the default behavior\n     *        of this class. See {@link #SKIP_DEBUG}, {@link #EXPAND_FRAMES},\n     *        {@link #SKIP_FRAMES}, {@link #SKIP_CODE}.\n     */\n    public void accept(final ClassVisitor classVisitor, final Attribute[] attrs, final int flags) {\n        // the bytecode array\n        byte[] b = this.b;\n        // buffer used to read strings\n        char[] c = new char[maxStringLength];\n        // loop variables\n        int i, j, k;\n        // indexes in b\n        int u, v, w;\n        Attribute attr;\n        int access;\n        String name;\n        String desc;\n        String attrName;\n        String signature;\n        int anns = 0;\n        int ianns = 0;\n        Attribute cattrs = null;\n        // visits the header\n        u = header;\n        access = readUnsignedShort(u);\n        name = readClass(u + 2, c);\n        v = items[readUnsignedShort(u + 4)];\n        String superClassName = v == 0 ? null : readUTF8(v, c);\n        String[] implementedItfs = new String[readUnsignedShort(u + 6)];\n        w = 0;\n        u += 8;\n        for (i = 0; i < implementedItfs.length; ++i) {\n            implementedItfs[i] = readClass(u, c);\n            u += 2;\n        }\n        boolean skipCode = (flags & SKIP_CODE) != 0;\n        boolean skipDebug = (flags & SKIP_DEBUG) != 0;\n        boolean unzip = (flags & EXPAND_FRAMES) != 0;\n        // skips fields and methods\n        v = u;\n        i = readUnsignedShort(v);\n        v += 2;\n        for (; i > 0; --i) {\n            j = readUnsignedShort(v + 6);\n            v += 8;\n            for (; j > 0; --j) {\n                v += 6 + readInt(v + 2);\n            }\n        }\n        i = readUnsignedShort(v);\n        v += 2;\n        for (; i > 0; --i) {\n            j = readUnsignedShort(v + 6);\n            v += 8;\n            for (; j > 0; --j) {\n                v += 6 + readInt(v + 2);\n            }\n        }\n        // reads the class's attributes\n        signature = null;\n        String sourceFile = null;\n        String sourceDebug = null;\n        String enclosingOwner = null;\n        String enclosingName = null;\n        String enclosingDesc = null;\n        i = readUnsignedShort(v);\n        v += 2;\n        for (; i > 0; --i) {\n            attrName = readUTF8(v, c);\n            // tests are sorted in decreasing frequency order\n            // (based on frequencies observed on typical classes)\n            if (\"SourceFile\".equals(attrName)) {\n                sourceFile = readUTF8(v + 6, c);\n            } else if (\"InnerClasses\".equals(attrName)) {\n                w = v + 6;\n            } else if (\"EnclosingMethod\".equals(attrName)) {\n                enclosingOwner = readClass(v + 6, c);\n                int item = readUnsignedShort(v + 8);\n                if (item != 0) {\n                    enclosingName = readUTF8(items[item], c);\n                    enclosingDesc = readUTF8(items[item] + 2, c);\n                }\n            } else if (SIGNATURES && \"Signature\".equals(attrName)) {\n                signature = readUTF8(v + 6, c);\n            } else if (ANNOTATIONS && \"RuntimeVisibleAnnotations\".equals(attrName)) {\n                anns = v + 6;\n            } else if (\"Deprecated\".equals(attrName)) {\n                access |= Opcodes.ACC_DEPRECATED;\n            } else if (\"Synthetic\".equals(attrName)) {\n                access |= Opcodes.ACC_SYNTHETIC;\n            } else if (\"SourceDebugExtension\".equals(attrName)) {\n                int len = readInt(v + 2);\n                sourceDebug = readUTF(v + 6, len, new char[len]);\n            } else if (ANNOTATIONS && \"RuntimeInvisibleAnnotations\".equals(attrName)) {\n                ianns = v + 6;\n            } else {\n                attr = readAttribute(attrs, attrName, v + 6, readInt(v + 2), c, -1, null);\n                if (attr != null) {\n                    attr.next = cattrs;\n                    cattrs = attr;\n                }\n            }\n            v += 6 + readInt(v + 2);\n        }\n        // calls the visit method\n        classVisitor.visit(readInt(4), access, name, signature, superClassName, implementedItfs);\n        // calls the visitSource method\n        if (!skipDebug && (sourceFile != null || sourceDebug != null)) {\n            classVisitor.visitSource(sourceFile, sourceDebug);\n        }\n        // calls the visitOuterClass method\n        if (enclosingOwner != null) {\n            classVisitor.visitOuterClass(enclosingOwner, enclosingName, enclosingDesc);\n        }\n        // visits the class annotations\n        if (ANNOTATIONS) {\n            for (i = 1; i >= 0; --i) {\n                v = i == 0 ? ianns : anns;\n                if (v != 0) {\n                    j = readUnsignedShort(v);\n                    v += 2;\n                    for (; j > 0; --j) {\n                        v = readAnnotationValues(v + 2, c, true, classVisitor.visitAnnotation(readUTF8(v, c), i != 0));\n                    }\n                }\n            }\n        }\n        // visits the class attributes\n        while (cattrs != null) {\n            attr = cattrs.next;\n            cattrs.next = null;\n            classVisitor.visitAttribute(cattrs);\n            cattrs = attr;\n        }\n        // calls the visitInnerClass method\n        if (w != 0) {\n            i = readUnsignedShort(w);\n            w += 2;\n            for (; i > 0; --i) {\n                classVisitor.visitInnerClass(readUnsignedShort(w) == 0 ? null : readClass(w, c), readUnsignedShort(w + 2) == 0 ? null : readClass(w + 2, c), readUnsignedShort(w + 4) == 0 ? null : readUTF8(w + 4, c), readUnsignedShort(w + 6));\n                w += 8;\n            }\n        }\n        // visits the fields\n        i = readUnsignedShort(u);\n        u += 2;\n        for (; i > 0; --i) {\n            access = readUnsignedShort(u);\n            name = readUTF8(u + 2, c);\n            desc = readUTF8(u + 4, c);\n            // visits the field's attributes and looks for a ConstantValue\n            // attribute\n            int fieldValueItem = 0;\n            signature = null;\n            anns = 0;\n            ianns = 0;\n            cattrs = null;\n            j = readUnsignedShort(u + 6);\n            u += 8;\n            for (; j > 0; --j) {\n                attrName = readUTF8(u, c);\n                // tests are sorted in decreasing frequency order\n                // (based on frequencies observed on typical classes)\n                if (\"ConstantValue\".equals(attrName)) {\n                    fieldValueItem = readUnsignedShort(u + 6);\n                } else if (SIGNATURES && \"Signature\".equals(attrName)) {\n                    signature = readUTF8(u + 6, c);\n                } else if (\"Deprecated\".equals(attrName)) {\n                    access |= Opcodes.ACC_DEPRECATED;\n                } else if (\"Synthetic\".equals(attrName)) {\n                    access |= Opcodes.ACC_SYNTHETIC;\n                } else if (ANNOTATIONS && \"RuntimeVisibleAnnotations\".equals(attrName)) {\n                    anns = u + 6;\n                } else if (ANNOTATIONS && \"RuntimeInvisibleAnnotations\".equals(attrName)) {\n                    ianns = u + 6;\n                } else {\n                    attr = readAttribute(attrs, attrName, u + 6, readInt(u + 2), c, -1, null);\n                    if (attr != null) {\n                        attr.next = cattrs;\n                        cattrs = attr;\n                    }\n                }\n                u += 6 + readInt(u + 2);\n            }\n            // visits the field\n            FieldVisitor fv = classVisitor.visitField(access, name, desc, signature, fieldValueItem == 0 ? null : readConst(fieldValueItem, c));\n            // visits the field annotations and attributes\n            if (fv != null) {\n                if (ANNOTATIONS) {\n                    for (j = 1; j >= 0; --j) {\n                        v = j == 0 ? ianns : anns;\n                        if (v != 0) {\n                            k = readUnsignedShort(v);\n                            v += 2;\n                            for (; k > 0; --k) {\n                                v = readAnnotationValues(v + 2, c, true, fv.visitAnnotation(readUTF8(v, c), j != 0));\n                            }\n                        }\n                    }\n                }\n                while (cattrs != null) {\n                    attr = cattrs.next;\n                    cattrs.next = null;\n                    fv.visitAttribute(cattrs);\n                    cattrs = attr;\n                }\n                fv.visitEnd();\n            }\n        }\n        // visits the methods\n        i = readUnsignedShort(u);\n        u += 2;\n        for (; i > 0; --i) {\n            int u0 = u + 6;\n            access = readUnsignedShort(u);\n            name = readUTF8(u + 2, c);\n            desc = readUTF8(u + 4, c);\n            signature = null;\n            anns = 0;\n            ianns = 0;\n            int dann = 0;\n            int mpanns = 0;\n            int impanns = 0;\n            cattrs = null;\n            v = 0;\n            w = 0;\n            // looks for Code and Exceptions attributes\n            j = readUnsignedShort(u + 6);\n            u += 8;\n            for (; j > 0; --j) {\n                attrName = readUTF8(u, c);\n                int attrSize = readInt(u + 2);\n                u += 6;\n                // tests are sorted in decreasing frequency order\n                // (based on frequencies observed on typical classes)\n                if (\"Code\".equals(attrName)) {\n                    if (!skipCode) {\n                        v = u;\n                    }\n                } else if (\"Exceptions\".equals(attrName)) {\n                    w = u;\n                } else if (SIGNATURES && \"Signature\".equals(attrName)) {\n                    signature = readUTF8(u, c);\n                } else if (\"Deprecated\".equals(attrName)) {\n                    access |= Opcodes.ACC_DEPRECATED;\n                } else if (ANNOTATIONS && \"RuntimeVisibleAnnotations\".equals(attrName)) {\n                    anns = u;\n                } else if (ANNOTATIONS && \"AnnotationDefault\".equals(attrName)) {\n                    dann = u;\n                } else if (\"Synthetic\".equals(attrName)) {\n                    access |= Opcodes.ACC_SYNTHETIC;\n                } else if (ANNOTATIONS && \"RuntimeInvisibleAnnotations\".equals(attrName)) {\n                    ianns = u;\n                } else if (ANNOTATIONS && \"RuntimeVisibleParameterAnnotations\".equals(attrName)) {\n                    mpanns = u;\n                } else if (ANNOTATIONS && \"RuntimeInvisibleParameterAnnotations\".equals(attrName)) {\n                    impanns = u;\n                } else {\n                    attr = readAttribute(attrs, attrName, u, attrSize, c, -1, null);\n                    if (attr != null) {\n                        attr.next = cattrs;\n                        cattrs = attr;\n                    }\n                }\n                u += attrSize;\n            }\n            // reads declared exceptions\n            String[] exceptions;\n            if (w == 0) {\n                exceptions = null;\n            } else {\n                exceptions = new String[readUnsignedShort(w)];\n                w += 2;\n                for (j = 0; j < exceptions.length; ++j) {\n                    exceptions[j] = readClass(w, c);\n                    w += 2;\n                }\n            }\n            // visits the method's code, if any\n            MethodVisitor mv = classVisitor.visitMethod(access, name, desc, signature, exceptions);\n            if (mv != null) {\n                /*\n                 * if the returned MethodVisitor is in fact a MethodWriter, it\n                 * means there is no method adapter between the reader and the\n                 * writer. If, in addition, the writer's constant pool was\n                 * copied from this reader (mw.cw.cr == this), and the signature\n                 * and exceptions of the method have not been changed, then it\n                 * is possible to skip all visit events and just copy the\n                 * original code of the method to the writer (the access, name\n                 * and descriptor can have been changed, this is not important\n                 * since they are not copied as is from the reader).\n                 */\n                if (WRITER && mv instanceof MethodWriter) {\n                    MethodWriter mw = (MethodWriter) mv;\n                    if (mw.cw.cr == this) {\n                        if (signature == mw.signature) {\n                            boolean sameExceptions = false;\n                            if (exceptions == null) {\n                                sameExceptions = mw.exceptionCount == 0;\n                            } else {\n                                if (exceptions.length == mw.exceptionCount) {\n                                    sameExceptions = true;\n                                    for (j = exceptions.length - 1; j >= 0; --j) {\n                                        w -= 2;\n                                        if (mw.exceptions[j] != readUnsignedShort(w)) {\n                                            sameExceptions = false;\n                                            break;\n                                        }\n                                    }\n                                }\n                            }\n                            if (sameExceptions) {\n                                /*\n                                 * we do not copy directly the code into\n                                 * MethodWriter to save a byte array copy\n                                 * operation. The real copy will be done in\n                                 * ClassWriter.toByteArray().\n                                 */\n                                mw.classReaderOffset = u0;\n                                mw.classReaderLength = u - u0;\n                                continue;\n                            }\n                        }\n                    }\n                }\n                if (ANNOTATIONS && dann != 0) {\n                    AnnotationVisitor dv = mv.visitAnnotationDefault();\n                    readAnnotationValue(dann, c, null, dv);\n                    if (dv != null) {\n                        dv.visitEnd();\n                    }\n                }\n                if (ANNOTATIONS) {\n                    for (j = 1; j >= 0; --j) {\n                        w = j == 0 ? ianns : anns;\n                        if (w != 0) {\n                            k = readUnsignedShort(w);\n                            w += 2;\n                            for (; k > 0; --k) {\n                                w = readAnnotationValues(w + 2, c, true, mv.visitAnnotation(readUTF8(w, c), j != 0));\n                            }\n                        }\n                    }\n                }\n                if (ANNOTATIONS && mpanns != 0) {\n                    readParameterAnnotations(mpanns, desc, c, true, mv);\n                }\n                if (ANNOTATIONS && impanns != 0) {\n                    readParameterAnnotations(impanns, desc, c, false, mv);\n                }\n                while (cattrs != null) {\n                    attr = cattrs.next;\n                    cattrs.next = null;\n                    mv.visitAttribute(cattrs);\n                    cattrs = attr;\n                }\n            }\n            if (mv != null && v != 0) {\n                int maxStack = readUnsignedShort(v);\n                int maxLocals = readUnsignedShort(v + 2);\n                int codeLength = readInt(v + 4);\n                v += 8;\n                int codeStart = v;\n                int codeEnd = v + codeLength;\n                mv.visitCode();\n                // 1st phase: finds the labels\n                int label;\n                Label[] labels = new Label[codeLength + 2];\n                readLabel(codeLength + 1, labels);\n                while (v < codeEnd) {\n                    w = v - codeStart;\n                    int opcode = b[v] & 0xFF;\n                    switch(ClassWriter.TYPE[opcode]) {\n                        case ClassWriter.NOARG_INSN:\n                        case ClassWriter.IMPLVAR_INSN:\n                            v += 1;\n                            break;\n                        case ClassWriter.LABEL_INSN:\n                            readLabel(w + readShort(v + 1), labels);\n                            v += 3;\n                            break;\n                        case ClassWriter.LABELW_INSN:\n                            readLabel(w + readInt(v + 1), labels);\n                            v += 5;\n                            break;\n                        case ClassWriter.WIDE_INSN:\n                            opcode = b[v + 1] & 0xFF;\n                            if (opcode == Opcodes.IINC) {\n                                v += 6;\n                            } else {\n                                v += 4;\n                            }\n                            break;\n                        case ClassWriter.TABL_INSN:\n                            // skips 0 to 3 padding bytes*\n                            v = v + 4 - (w & 3);\n                            // reads instruction\n                            readLabel(w + readInt(v), labels);\n                            j = readInt(v + 8) - readInt(v + 4) + 1;\n                            v += 12;\n                            for (; j > 0; --j) {\n                                readLabel(w + readInt(v), labels);\n                                v += 4;\n                            }\n                            break;\n                        case ClassWriter.LOOK_INSN:\n                            // skips 0 to 3 padding bytes*\n                            v = v + 4 - (w & 3);\n                            // reads instruction\n                            readLabel(w + readInt(v), labels);\n                            j = readInt(v + 4);\n                            v += 8;\n                            for (; j > 0; --j) {\n                                readLabel(w + readInt(v + 4), labels);\n                                v += 8;\n                            }\n                            break;\n                        case ClassWriter.VAR_INSN:\n                        case ClassWriter.SBYTE_INSN:\n                        case ClassWriter.LDC_INSN:\n                            v += 2;\n                            break;\n                        case ClassWriter.SHORT_INSN:\n                        case ClassWriter.LDCW_INSN:\n                        case ClassWriter.FIELDORMETH_INSN:\n                        case ClassWriter.TYPE_INSN:\n                        case ClassWriter.IINC_INSN:\n                            v += 3;\n                            break;\n                        case ClassWriter.ITFDYNMETH_INSN:\n                            v += 5;\n                            break;\n                        // case MANA_INSN:\n                        default:\n                            v += 4;\n                            break;\n                    }\n                }\n                // parses the try catch entries\n                j = readUnsignedShort(v);\n                v += 2;\n                for (; j > 0; --j) {\n                    Label start = readLabel(readUnsignedShort(v), labels);\n                    Label end = readLabel(readUnsignedShort(v + 2), labels);\n                    Label handler = readLabel(readUnsignedShort(v + 4), labels);\n                    int type = readUnsignedShort(v + 6);\n                    if (type == 0) {\n                        mv.visitTryCatchBlock(start, end, handler, null);\n                    } else {\n                        mv.visitTryCatchBlock(start, end, handler, readUTF8(items[type], c));\n                    }\n                    v += 8;\n                }\n                // parses the local variable, line number tables, and code\n                // attributes\n                int varTable = 0;\n                int varTypeTable = 0;\n                int stackMap = 0;\n                int stackMapSize = 0;\n                int frameCount = 0;\n                int frameMode = 0;\n                int frameOffset = 0;\n                int frameLocalCount = 0;\n                int frameLocalDiff = 0;\n                int frameStackCount = 0;\n                Object[] frameLocal = null;\n                Object[] frameStack = null;\n                boolean zip = true;\n                cattrs = null;\n                j = readUnsignedShort(v);\n                v += 2;\n                for (; j > 0; --j) {\n                    attrName = readUTF8(v, c);\n                    if (\"LocalVariableTable\".equals(attrName)) {\n                        if (!skipDebug) {\n                            varTable = v + 6;\n                            k = readUnsignedShort(v + 6);\n                            w = v + 8;\n                            for (; k > 0; --k) {\n                                label = readUnsignedShort(w);\n                                if (labels[label] == null) {\n                                    readLabel(label, labels).status |= Label.DEBUG;\n                                }\n                                label += readUnsignedShort(w + 2);\n                                if (labels[label] == null) {\n                                    readLabel(label, labels).status |= Label.DEBUG;\n                                }\n                                w += 10;\n                            }\n                        }\n                    } else if (\"LocalVariableTypeTable\".equals(attrName)) {\n                        varTypeTable = v + 6;\n                    } else if (\"LineNumberTable\".equals(attrName)) {\n                        if (!skipDebug) {\n                            k = readUnsignedShort(v + 6);\n                            w = v + 8;\n                            for (; k > 0; --k) {\n                                label = readUnsignedShort(w);\n                                if (labels[label] == null) {\n                                    readLabel(label, labels).status |= Label.DEBUG;\n                                }\n                                labels[label].line = readUnsignedShort(w + 2);\n                                w += 4;\n                            }\n                        }\n                    } else if (FRAMES && \"StackMapTable\".equals(attrName)) {\n                        if ((flags & SKIP_FRAMES) == 0) {\n                            stackMap = v + 8;\n                            stackMapSize = readInt(v + 2);\n                            frameCount = readUnsignedShort(v + 6);\n                        }\n                        /*\n                         * here we do not extract the labels corresponding to\n                         * the attribute content. This would require a full\n                         * parsing of the attribute, which would need to be\n                         * repeated in the second phase (see below). Instead the\n                         * content of the attribute is read one frame at a time\n                         * (i.e. after a frame has been visited, the next frame\n                         * is read), and the labels it contains are also\n                         * extracted one frame at a time. Thanks to the ordering\n                         * of frames, having only a \"one frame lookahead\" is not\n                         * a problem, i.e. it is not possible to see an offset\n                         * smaller than the offset of the current insn and for\n                         * which no Label exist.\n                         */\n                        /*\n                         * This is not true for UNINITIALIZED type offsets. We\n                         * solve this by parsing the stack map table without a\n                         * full decoding (see below).\n                         */\n                    } else if (FRAMES && \"StackMap\".equals(attrName)) {\n                        if ((flags & SKIP_FRAMES) == 0) {\n                            stackMap = v + 8;\n                            stackMapSize = readInt(v + 2);\n                            frameCount = readUnsignedShort(v + 6);\n                            zip = false;\n                        }\n                        /*\n                         * IMPORTANT! here we assume that the frames are\n                         * ordered, as in the StackMapTable attribute, although\n                         * this is not guaranteed by the attribute format.\n                         */\n                    } else {\n                        for (k = 0; k < attrs.length; ++k) {\n                            if (attrs[k].type.equals(attrName)) {\n                                attr = attrs[k].read(this, v + 6, readInt(v + 2), c, codeStart - 8, labels);\n                                if (attr != null) {\n                                    attr.next = cattrs;\n                                    cattrs = attr;\n                                }\n                            }\n                        }\n                    }\n                    v += 6 + readInt(v + 2);\n                }\n                // 2nd phase: visits each instruction\n                if (FRAMES && stackMap != 0) {\n                    // creates the very first (implicit) frame from the method\n                    // descriptor\n                    frameLocal = new Object[maxLocals];\n                    frameStack = new Object[maxStack];\n                    if (unzip) {\n                        int local = 0;\n                        if ((access & Opcodes.ACC_STATIC) == 0) {\n                            if (\"<init>\".equals(name)) {\n                                frameLocal[local++] = Opcodes.UNINITIALIZED_THIS;\n                            } else {\n                                frameLocal[local++] = readClass(header + 2, c);\n                            }\n                        }\n                        j = 1;\n                        loop: while (true) {\n                            k = j;\n                            switch(desc.charAt(j++)) {\n                                case 'Z':\n                                case 'C':\n                                case 'B':\n                                case 'S':\n                                case 'I':\n                                    frameLocal[local++] = Opcodes.INTEGER;\n                                    break;\n                                case 'F':\n                                    frameLocal[local++] = Opcodes.FLOAT;\n                                    break;\n                                case 'J':\n                                    frameLocal[local++] = Opcodes.LONG;\n                                    break;\n                                case 'D':\n                                    frameLocal[local++] = Opcodes.DOUBLE;\n                                    break;\n                                case '[':\n                                    while (desc.charAt(j) == '[') {\n                                        ++j;\n                                    }\n                                    if (desc.charAt(j) == 'L') {\n                                        ++j;\n                                        while (desc.charAt(j) != ';') {\n                                            ++j;\n                                        }\n                                    }\n                                    frameLocal[local++] = desc.substring(k, ++j);\n                                    break;\n                                case 'L':\n                                    while (desc.charAt(j) != ';') {\n                                        ++j;\n                                    }\n                                    frameLocal[local++] = desc.substring(k + 1, j++);\n                                    break;\n                                default:\n                                    break loop;\n                            }\n                        }\n                        frameLocalCount = local;\n                    }\n                    /*\n                     * for the first explicit frame the offset is not\n                     * offset_delta + 1 but only offset_delta; setting the\n                     * implicit frame offset to -1 allow the use of the\n                     * \"offset_delta + 1\" rule in all cases\n                     */\n                    frameOffset = -1;\n                    /*\n                     * Finds labels for UNINITIALIZED frame types. Instead of\n                     * decoding each element of the stack map table, we look\n                     * for 3 consecutive bytes that \"look like\" an UNINITIALIZED\n                     * type (tag 8, offset within code bounds, NEW instruction\n                     * at this offset). We may find false positives (i.e. not \n                     * real UNINITIALIZED types), but this should be rare, and \n                     * the only consequence will be the creation of an unneeded \n                     * label. This is better than creating a label for each NEW\n                     * instruction, and faster than fully decoding the whole \n                     * stack map table.\n                     */\n                    for (j = stackMap; j < stackMap + stackMapSize - 2; ++j) {\n                        if (b[j] == 8) {\n                            // UNINITIALIZED FRAME TYPE\n                            k = readUnsignedShort(j + 1);\n                            if (k >= 0 && k < codeLength) {\n                                // potential offset\n                                if ((b[codeStart + k] & 0xFF) == Opcodes.NEW) {\n                                    // NEW at this offset\n                                    readLabel(k, labels);\n                                }\n                            }\n                        }\n                    }\n                }\n                v = codeStart;\n                Label l;\n                while (v < codeEnd) {\n                    w = v - codeStart;\n                    l = labels[w];\n                    if (l != null) {\n                        mv.visitLabel(l);\n                        if (!skipDebug && l.line > 0) {\n                            mv.visitLineNumber(l.line, l);\n                        }\n                    }\n                    while (FRAMES && frameLocal != null && (frameOffset == w || frameOffset == -1)) {\n                        // if there is a frame for this offset,\n                        // makes the visitor visit it,\n                        // and reads the next frame if there is one.\n                        if (!zip || unzip) {\n                            mv.visitFrame(Opcodes.F_NEW, frameLocalCount, frameLocal, frameStackCount, frameStack);\n                        } else if (frameOffset != -1) {\n                            mv.visitFrame(frameMode, frameLocalDiff, frameLocal, frameStackCount, frameStack);\n                        }\n                        if (frameCount > 0) {\n                            int tag, delta, n;\n                            if (zip) {\n                                tag = b[stackMap++] & 0xFF;\n                            } else {\n                                tag = MethodWriter.FULL_FRAME;\n                                frameOffset = -1;\n                            }\n                            frameLocalDiff = 0;\n                            if (tag < MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME) {\n                                delta = tag;\n                                frameMode = Opcodes.F_SAME;\n                                frameStackCount = 0;\n                            } else if (tag < MethodWriter.RESERVED) {\n                                delta = tag - MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME;\n                                stackMap = readFrameType(frameStack, 0, stackMap, c, labels);\n                                frameMode = Opcodes.F_SAME1;\n                                frameStackCount = 1;\n                            } else {\n                                delta = readUnsignedShort(stackMap);\n                                stackMap += 2;\n                                if (tag == MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {\n                                    stackMap = readFrameType(frameStack, 0, stackMap, c, labels);\n                                    frameMode = Opcodes.F_SAME1;\n                                    frameStackCount = 1;\n                                } else if (tag >= MethodWriter.CHOP_FRAME && tag < MethodWriter.SAME_FRAME_EXTENDED) {\n                                    frameMode = Opcodes.F_CHOP;\n                                    frameLocalDiff = MethodWriter.SAME_FRAME_EXTENDED - tag;\n                                    frameLocalCount -= frameLocalDiff;\n                                    frameStackCount = 0;\n                                } else if (tag == MethodWriter.SAME_FRAME_EXTENDED) {\n                                    frameMode = Opcodes.F_SAME;\n                                    frameStackCount = 0;\n                                } else if (tag < MethodWriter.FULL_FRAME) {\n                                    j = unzip ? frameLocalCount : 0;\n                                    for (k = tag - MethodWriter.SAME_FRAME_EXTENDED; k > 0; k--) {\n                                        stackMap = readFrameType(frameLocal, j++, stackMap, c, labels);\n                                    }\n                                    frameMode = Opcodes.F_APPEND;\n                                    frameLocalDiff = tag - MethodWriter.SAME_FRAME_EXTENDED;\n                                    frameLocalCount += frameLocalDiff;\n                                    frameStackCount = 0;\n                                } else {\n                                    // if (tag == FULL_FRAME) {\n                                    frameMode = Opcodes.F_FULL;\n                                    n = frameLocalDiff = frameLocalCount = readUnsignedShort(stackMap);\n                                    stackMap += 2;\n                                    for (j = 0; n > 0; n--) {\n                                        stackMap = readFrameType(frameLocal, j++, stackMap, c, labels);\n                                    }\n                                    n = frameStackCount = readUnsignedShort(stackMap);\n                                    stackMap += 2;\n                                    for (j = 0; n > 0; n--) {\n                                        stackMap = readFrameType(frameStack, j++, stackMap, c, labels);\n                                    }\n                                }\n                            }\n                            frameOffset += delta + 1;\n                            readLabel(frameOffset, labels);\n                            --frameCount;\n                        } else {\n                            frameLocal = null;\n                        }\n                    }\n                    int opcode = b[v] & 0xFF;\n                    switch(ClassWriter.TYPE[opcode]) {\n                        case ClassWriter.NOARG_INSN:\n                            mv.visitInsn(opcode);\n                            v += 1;\n                            break;\n                        case ClassWriter.IMPLVAR_INSN:\n                            if (opcode > Opcodes.ISTORE) {\n                                // ISTORE_0\n                                opcode -= 59;\n                                mv.visitVarInsn(Opcodes.ISTORE + (opcode >> 2), opcode & 0x3);\n                            } else {\n                                // ILOAD_0\n                                opcode -= 26;\n                                mv.visitVarInsn(Opcodes.ILOAD + (opcode >> 2), opcode & 0x3);\n                            }\n                            v += 1;\n                            break;\n                        case ClassWriter.LABEL_INSN:\n                            mv.visitJumpInsn(opcode, labels[w + readShort(v + 1)]);\n                            v += 3;\n                            break;\n                        case ClassWriter.LABELW_INSN:\n                            mv.visitJumpInsn(opcode - 33, labels[w + readInt(v + 1)]);\n                            v += 5;\n                            break;\n                        case ClassWriter.WIDE_INSN:\n                            opcode = b[v + 1] & 0xFF;\n                            if (opcode == Opcodes.IINC) {\n                                mv.visitIincInsn(readUnsignedShort(v + 2), readShort(v + 4));\n                                v += 6;\n                            } else {\n                                mv.visitVarInsn(opcode, readUnsignedShort(v + 2));\n                                v += 4;\n                            }\n                            break;\n                        case ClassWriter.TABL_INSN:\n                            // skips 0 to 3 padding bytes\n                            v = v + 4 - (w & 3);\n                            // reads instruction\n                            label = w + readInt(v);\n                            int min = readInt(v + 4);\n                            int max = readInt(v + 8);\n                            v += 12;\n                            Label[] table = new Label[max - min + 1];\n                            for (j = 0; j < table.length; ++j) {\n                                table[j] = labels[w + readInt(v)];\n                                v += 4;\n                            }\n                            mv.visitTableSwitchInsn(min, max, labels[label], table);\n                            break;\n                        case ClassWriter.LOOK_INSN:\n                            // skips 0 to 3 padding bytes\n                            v = v + 4 - (w & 3);\n                            // reads instruction\n                            label = w + readInt(v);\n                            j = readInt(v + 4);\n                            v += 8;\n                            int[] keys = new int[j];\n                            Label[] values = new Label[j];\n                            for (j = 0; j < keys.length; ++j) {\n                                keys[j] = readInt(v);\n                                values[j] = labels[w + readInt(v + 4)];\n                                v += 8;\n                            }\n                            mv.visitLookupSwitchInsn(labels[label], keys, values);\n                            break;\n                        case ClassWriter.VAR_INSN:\n                            mv.visitVarInsn(opcode, b[v + 1] & 0xFF);\n                            v += 2;\n                            break;\n                        case ClassWriter.SBYTE_INSN:\n                            mv.visitIntInsn(opcode, b[v + 1]);\n                            v += 2;\n                            break;\n                        case ClassWriter.SHORT_INSN:\n                            mv.visitIntInsn(opcode, readShort(v + 1));\n                            v += 3;\n                            break;\n                        case ClassWriter.LDC_INSN:\n                            mv.visitLdcInsn(readConst(b[v + 1] & 0xFF, c));\n                            v += 2;\n                            break;\n                        case ClassWriter.LDCW_INSN:\n                            mv.visitLdcInsn(readConst(readUnsignedShort(v + 1), c));\n                            v += 3;\n                            break;\n                        case ClassWriter.FIELDORMETH_INSN:\n                        case ClassWriter.ITFDYNMETH_INSN:\n                            int cpIndex = items[readUnsignedShort(v + 1)];\n                            String iowner;\n                            // INVOKEDYNAMIC is receiverless\n                            if (opcode == Opcodes.INVOKEDYNAMIC) {\n                                iowner = Opcodes.INVOKEDYNAMIC_OWNER;\n                            } else {\n                                iowner = readClass(cpIndex, c);\n                                cpIndex = items[readUnsignedShort(cpIndex + 2)];\n                            }\n                            String iname = readUTF8(cpIndex, c);\n                            String idesc = readUTF8(cpIndex + 2, c);\n                            if (opcode < Opcodes.INVOKEVIRTUAL) {\n                                mv.visitFieldInsn(opcode, iowner, iname, idesc);\n                            } else {\n                                mv.visitMethodInsn(opcode, iowner, iname, idesc);\n                            }\n                            if (opcode == Opcodes.INVOKEINTERFACE || opcode == Opcodes.INVOKEDYNAMIC) {\n                                v += 5;\n                            } else {\n                                v += 3;\n                            }\n                            break;\n                        case ClassWriter.TYPE_INSN:\n                            mv.visitTypeInsn(opcode, readClass(v + 1, c));\n                            v += 3;\n                            break;\n                        case ClassWriter.IINC_INSN:\n                            mv.visitIincInsn(b[v + 1] & 0xFF, b[v + 2]);\n                            v += 3;\n                            break;\n                        // case MANA_INSN:\n                        default:\n                            mv.visitMultiANewArrayInsn(readClass(v + 1, c), b[v + 3] & 0xFF);\n                            v += 4;\n                            break;\n                    }\n                }\n                l = labels[codeEnd - codeStart];\n                if (l != null) {\n                    mv.visitLabel(l);\n                }\n                // visits the local variable tables\n                if (!skipDebug && varTable != 0) {\n                    int[] typeTable = null;\n                    if (varTypeTable != 0) {\n                        k = readUnsignedShort(varTypeTable) * 3;\n                        w = varTypeTable + 2;\n                        typeTable = new int[k];\n                        while (k > 0) {\n                            // signature\n                            typeTable[--k] = w + 6;\n                            // index\n                            typeTable[--k] = readUnsignedShort(w + 8);\n                            // start\n                            typeTable[--k] = readUnsignedShort(w);\n                            w += 10;\n                        }\n                    }\n                    k = readUnsignedShort(varTable);\n                    w = varTable + 2;\n                    for (; k > 0; --k) {\n                        int start = readUnsignedShort(w);\n                        int length = readUnsignedShort(w + 2);\n                        int index = readUnsignedShort(w + 8);\n                        String vsignature = null;\n                        if (typeTable != null) {\n                            for (int a = 0; a < typeTable.length; a += 3) {\n                                if (typeTable[a] == start && typeTable[a + 1] == index) {\n                                    vsignature = readUTF8(typeTable[a + 2], c);\n                                    break;\n                                }\n                            }\n                        }\n                        mv.visitLocalVariable(readUTF8(w + 4, c), readUTF8(w + 6, c), vsignature, labels[start], labels[start + length], index);\n                        w += 10;\n                    }\n                }\n                // visits the other attributes\n                while (cattrs != null) {\n                    attr = cattrs.next;\n                    cattrs.next = null;\n                    mv.visitAttribute(cattrs);\n                    cattrs = attr;\n                }\n                // visits the max stack and max locals values\n                mv.visitMaxs(maxStack, maxLocals);\n            }\n            if (mv != null) {\n                mv.visitEnd();\n            }\n        }\n        // visits the end of the class\n        classVisitor.visitEnd();\n    }\n\n    /**\n     * Reads parameter annotations and makes the given visitor visit them.\n     *\n     * @param v start offset in {@link #b b} of the annotations to be read.\n     * @param desc the method descriptor.\n     * @param buf buffer to be used to call {@link #readUTF8 readUTF8},\n     *        {@link #readClass(int,char[]) readClass} or\n     *        {@link #readConst readConst}.\n     * @param visible <tt>true</tt> if the annotations to be read are visible\n     *        at runtime.\n     * @param mv the visitor that must visit the annotations.\n     */\n    private void readParameterAnnotations(int v, final String desc, final char[] buf, final boolean visible, final MethodVisitor mv) {\n        int i;\n        int n = b[v++] & 0xFF;\n        // workaround for a bug in javac (javac compiler generates a parameter\n        // annotation array whose size is equal to the number of parameters in\n        // the Java source file, while it should generate an array whose size is\n        // equal to the number of parameters in the method descriptor - which\n        // includes the synthetic parameters added by the compiler). This work-\n        // around supposes that the synthetic parameters are the first ones.\n        int synthetics = Type.getArgumentTypes(desc).length - n;\n        AnnotationVisitor av;\n        for (i = 0; i < synthetics; ++i) {\n            // virtual annotation to detect synthetic parameters in MethodWriter\n            av = mv.visitParameterAnnotation(i, \"Ljava/lang/Synthetic;\", false);\n            if (av != null) {\n                av.visitEnd();\n            }\n        }\n        for (; i < n + synthetics; ++i) {\n            int j = readUnsignedShort(v);\n            v += 2;\n            for (; j > 0; --j) {\n                av = mv.visitParameterAnnotation(i, readUTF8(v, buf), visible);\n                v = readAnnotationValues(v + 2, buf, true, av);\n            }\n        }\n    }\n\n    /**\n     * Reads the values of an annotation and makes the given visitor visit them.\n     *\n     * @param v the start offset in {@link #b b} of the values to be read\n     *        (including the unsigned short that gives the number of values).\n     * @param buf buffer to be used to call {@link #readUTF8 readUTF8},\n     *        {@link #readClass(int,char[]) readClass} or\n     *        {@link #readConst readConst}.\n     * @param named if the annotation values are named or not.\n     * @param av the visitor that must visit the values.\n     * @return the end offset of the annotation values.\n     */\n    private int readAnnotationValues(int v, final char[] buf, final boolean named, final AnnotationVisitor av) {\n        int i = readUnsignedShort(v);\n        v += 2;\n        if (named) {\n            for (; i > 0; --i) {\n                v = readAnnotationValue(v + 2, buf, readUTF8(v, buf), av);\n            }\n        } else {\n            for (; i > 0; --i) {\n                v = readAnnotationValue(v, buf, null, av);\n            }\n        }\n        if (av != null) {\n            av.visitEnd();\n        }\n        return v;\n    }\n\n    /**\n     * Reads a value of an annotation and makes the given visitor visit it.\n     *\n     * @param v the start offset in {@link #b b} of the value to be read (<i>not\n     *        including the value name constant pool index</i>).\n     * @param buf buffer to be used to call {@link #readUTF8 readUTF8},\n     *        {@link #readClass(int,char[]) readClass} or\n     *        {@link #readConst readConst}.\n     * @param name the name of the value to be read.\n     * @param av the visitor that must visit the value.\n     * @return the end offset of the annotation value.\n     */\n    private int readAnnotationValue(int v, final char[] buf, final String name, final AnnotationVisitor av) {\n        int i;\n        if (av == null) {\n            switch(b[v] & 0xFF) {\n                case // enum_const_value\n                'e':\n                    return v + 5;\n                case // annotation_value\n                '@':\n                    return readAnnotationValues(v + 3, buf, true, null);\n                case // array_value\n                '[':\n                    return readAnnotationValues(v + 1, buf, false, null);\n                default:\n                    return v + 3;\n            }\n        }\n        switch(b[v++] & 0xFF) {\n            // pointer to CONSTANT_Integer\n            case 'I':\n            // pointer to CONSTANT_Long\n            case 'J':\n            // pointer to CONSTANT_Float\n            case 'F':\n            case // pointer to CONSTANT_Double\n            'D':\n                av.visit(name, readConst(readUnsignedShort(v), buf));\n                v += 2;\n                break;\n            case // pointer to CONSTANT_Byte\n            'B':\n                av.visit(name, new Byte((byte) readInt(items[readUnsignedShort(v)])));\n                v += 2;\n                break;\n            case // pointer to CONSTANT_Boolean\n            'Z':\n                av.visit(name, readInt(items[readUnsignedShort(v)]) == 0 ? Boolean.FALSE : Boolean.TRUE);\n                v += 2;\n                break;\n            case // pointer to CONSTANT_Short\n            'S':\n                av.visit(name, new Short((short) readInt(items[readUnsignedShort(v)])));\n                v += 2;\n                break;\n            case // pointer to CONSTANT_Char\n            'C':\n                av.visit(name, new Character((char) readInt(items[readUnsignedShort(v)])));\n                v += 2;\n                break;\n            case // pointer to CONSTANT_Utf8\n            's':\n                av.visit(name, readUTF8(v, buf));\n                v += 2;\n                break;\n            case // enum_const_value\n            'e':\n                av.visitEnum(name, readUTF8(v, buf), readUTF8(v + 2, buf));\n                v += 4;\n                break;\n            case // class_info\n            'c':\n                av.visit(name, Type.getType(readUTF8(v, buf)));\n                v += 2;\n                break;\n            case // annotation_value\n            '@':\n                v = readAnnotationValues(v + 2, buf, true, av.visitAnnotation(name, readUTF8(v, buf)));\n                break;\n            case // array_value\n            '[':\n                int size = readUnsignedShort(v);\n                v += 2;\n                if (size == 0) {\n                    return readAnnotationValues(v - 2, buf, false, av.visitArray(name));\n                }\n                switch(this.b[v++] & 0xFF) {\n                    case 'B':\n                        byte[] bv = new byte[size];\n                        for (i = 0; i < size; i++) {\n                            bv[i] = (byte) readInt(items[readUnsignedShort(v)]);\n                            v += 3;\n                        }\n                        av.visit(name, bv);\n                        --v;\n                        break;\n                    case 'Z':\n                        boolean[] zv = new boolean[size];\n                        for (i = 0; i < size; i++) {\n                            zv[i] = readInt(items[readUnsignedShort(v)]) != 0;\n                            v += 3;\n                        }\n                        av.visit(name, zv);\n                        --v;\n                        break;\n                    case 'S':\n                        short[] sv = new short[size];\n                        for (i = 0; i < size; i++) {\n                            sv[i] = (short) readInt(items[readUnsignedShort(v)]);\n                            v += 3;\n                        }\n                        av.visit(name, sv);\n                        --v;\n                        break;\n                    case 'C':\n                        char[] cv = new char[size];\n                        for (i = 0; i < size; i++) {\n                            cv[i] = (char) readInt(items[readUnsignedShort(v)]);\n                            v += 3;\n                        }\n                        av.visit(name, cv);\n                        --v;\n                        break;\n                    case 'I':\n                        int[] iv = new int[size];\n                        for (i = 0; i < size; i++) {\n                            iv[i] = readInt(items[readUnsignedShort(v)]);\n                            v += 3;\n                        }\n                        av.visit(name, iv);\n                        --v;\n                        break;\n                    case 'J':\n                        long[] lv = new long[size];\n                        for (i = 0; i < size; i++) {\n                            lv[i] = readLong(items[readUnsignedShort(v)]);\n                            v += 3;\n                        }\n                        av.visit(name, lv);\n                        --v;\n                        break;\n                    case 'F':\n                        float[] fv = new float[size];\n                        for (i = 0; i < size; i++) {\n                            fv[i] = Float.intBitsToFloat(readInt(items[readUnsignedShort(v)]));\n                            v += 3;\n                        }\n                        av.visit(name, fv);\n                        --v;\n                        break;\n                    case 'D':\n                        double[] dv = new double[size];\n                        for (i = 0; i < size; i++) {\n                            dv[i] = Double.longBitsToDouble(readLong(items[readUnsignedShort(v)]));\n                            v += 3;\n                        }\n                        av.visit(name, dv);\n                        --v;\n                        break;\n                    default:\n                        v = readAnnotationValues(v - 3, buf, false, av.visitArray(name));\n                }\n        }\n        return v;\n    }\n\n    private int readFrameType(final Object[] frame, final int index, int v, final char[] buf, final Label[] labels) {\n        int type = b[v++] & 0xFF;\n        switch(type) {\n            case 0:\n                frame[index] = Opcodes.TOP;\n                break;\n            case 1:\n                frame[index] = Opcodes.INTEGER;\n                break;\n            case 2:\n                frame[index] = Opcodes.FLOAT;\n                break;\n            case 3:\n                frame[index] = Opcodes.DOUBLE;\n                break;\n            case 4:\n                frame[index] = Opcodes.LONG;\n                break;\n            case 5:\n                frame[index] = Opcodes.NULL;\n                break;\n            case 6:\n                frame[index] = Opcodes.UNINITIALIZED_THIS;\n                break;\n            case // Object\n            7:\n                frame[index] = readClass(v, buf);\n                v += 2;\n                break;\n            default:\n                // Uninitialized\n                frame[index] = readLabel(readUnsignedShort(v), labels);\n                v += 2;\n        }\n        return v;\n    }\n\n    /**\n     * Returns the label corresponding to the given offset. The default\n     * implementation of this method creates a label for the given offset if it\n     * has not been already created.\n     *\n     * @param offset a bytecode offset in a method.\n     * @param labels the already created labels, indexed by their offset. If a\n     *        label already exists for offset this method must not create a new\n     *        one. Otherwise it must store the new label in this array.\n     * @return a non null Label, which must be equal to labels[offset].\n     */\n    protected Label readLabel(int offset, Label[] labels) {\n        if (labels[offset] == null) {\n            labels[offset] = new Label();\n        }\n        return labels[offset];\n    }\n\n    /**\n     * Reads an attribute in {@link #b b}.\n     *\n     * @param attrs prototypes of the attributes that must be parsed during the\n     *        visit of the class. Any attribute whose type is not equal to the\n     *        type of one the prototypes is ignored (i.e. an empty\n     *        {@link Attribute} instance is returned).\n     * @param type the type of the attribute.\n     * @param off index of the first byte of the attribute's content in\n     *        {@link #b b}. The 6 attribute header bytes, containing the type\n     *        and the length of the attribute, are not taken into account here\n     *        (they have already been read).\n     * @param len the length of the attribute's content.\n     * @param buf buffer to be used to call {@link #readUTF8 readUTF8},\n     *        {@link #readClass(int,char[]) readClass} or\n     *        {@link #readConst readConst}.\n     * @param codeOff index of the first byte of code's attribute content in\n     *        {@link #b b}, or -1 if the attribute to be read is not a code\n     *        attribute. The 6 attribute header bytes, containing the type and\n     *        the length of the attribute, are not taken into account here.\n     * @param labels the labels of the method's code, or <tt>null</tt> if the\n     *        attribute to be read is not a code attribute.\n     * @return the attribute that has been read, or <tt>null</tt> to skip this\n     *         attribute.\n     */\n    private Attribute readAttribute(final Attribute[] attrs, final String type, final int off, final int len, final char[] buf, final int codeOff, final Label[] labels) {\n        for (int i = 0; i < attrs.length; ++i) {\n            if (attrs[i].type.equals(type)) {\n                return attrs[i].read(this, off, len, buf, codeOff, labels);\n            }\n        }\n        return new Attribute(type).read(this, off, len, null, -1, null);\n    }\n\n    // ------------------------------------------------------------------------\n    // Utility methods: low level parsing\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the start index of the constant pool item in {@link #b b}, plus\n     * one. <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param item the index a constant pool item.\n     * @return the start index of the constant pool item in {@link #b b}, plus\n     *         one.\n     */\n    public int getItem(final int item) {\n        return items[item];\n    }\n\n    /**\n     * Reads a byte value in {@link #b b}. <i>This method is intended for\n     * {@link Attribute} sub classes, and is normally not needed by class\n     * generators or adapters.</i>\n     *\n     * @param index the start index of the value to be read in {@link #b b}.\n     * @return the read value.\n     */\n    public int readByte(final int index) {\n        return b[index] & 0xFF;\n    }\n\n    /**\n     * Reads an unsigned short value in {@link #b b}. <i>This method is\n     * intended for {@link Attribute} sub classes, and is normally not needed by\n     * class generators or adapters.</i>\n     *\n     * @param index the start index of the value to be read in {@link #b b}.\n     * @return the read value.\n     */\n    public int readUnsignedShort(final int index) {\n        byte[] b = this.b;\n        return ((b[index] & 0xFF) << 8) | (b[index + 1] & 0xFF);\n    }\n\n    /**\n     * Reads a signed short value in {@link #b b}. <i>This method is intended\n     * for {@link Attribute} sub classes, and is normally not needed by class\n     * generators or adapters.</i>\n     *\n     * @param index the start index of the value to be read in {@link #b b}.\n     * @return the read value.\n     */\n    public short readShort(final int index) {\n        byte[] b = this.b;\n        return (short) (((b[index] & 0xFF) << 8) | (b[index + 1] & 0xFF));\n    }\n\n    /**\n     * Reads a signed int value in {@link #b b}. <i>This method is intended for\n     * {@link Attribute} sub classes, and is normally not needed by class\n     * generators or adapters.</i>\n     *\n     * @param index the start index of the value to be read in {@link #b b}.\n     * @return the read value.\n     */\n    public int readInt(final int index) {\n        byte[] b = this.b;\n        return ((b[index] & 0xFF) << 24) | ((b[index + 1] & 0xFF) << 16) | ((b[index + 2] & 0xFF) << 8) | (b[index + 3] & 0xFF);\n    }\n\n    /**\n     * Reads a signed long value in {@link #b b}. <i>This method is intended\n     * for {@link Attribute} sub classes, and is normally not needed by class\n     * generators or adapters.</i>\n     *\n     * @param index the start index of the value to be read in {@link #b b}.\n     * @return the read value.\n     */\n    public long readLong(final int index) {\n        long l1 = readInt(index);\n        long l0 = readInt(index + 4) & 0xFFFFFFFFL;\n        return (l1 << 32) | l0;\n    }\n\n    /**\n     * Reads an UTF8 string constant pool item in {@link #b b}. <i>This method\n     * is intended for {@link Attribute} sub classes, and is normally not needed\n     * by class generators or adapters.</i>\n     *\n     * @param index the start index of an unsigned short value in {@link #b b},\n     *        whose value is the index of an UTF8 constant pool item.\n     * @param buf buffer to be used to read the item. This buffer must be\n     *        sufficiently large. It is not automatically resized.\n     * @return the String corresponding to the specified UTF8 item.\n     */\n    public String readUTF8(int index, final char[] buf) {\n        int item = readUnsignedShort(index);\n        String s = strings[item];\n        if (s != null) {\n            return s;\n        }\n        index = items[item];\n        return strings[item] = readUTF(index + 2, readUnsignedShort(index), buf);\n    }\n\n    /**\n     * Reads UTF8 string in {@link #b b}.\n     *\n     * @param index start offset of the UTF8 string to be read.\n     * @param utfLen length of the UTF8 string to be read.\n     * @param buf buffer to be used to read the string. This buffer must be\n     *        sufficiently large. It is not automatically resized.\n     * @return the String corresponding to the specified UTF8 string.\n     */\n    private String readUTF(int index, final int utfLen, final char[] buf) {\n        int endIndex = index + utfLen;\n        byte[] b = this.b;\n        int strLen = 0;\n        int c;\n        int st = 0;\n        char cc = 0;\n        while (index < endIndex) {\n            c = b[index++];\n            switch(st) {\n                case 0:\n                    c = c & 0xFF;\n                    if (c < 0x80) {\n                        // 0xxxxxxx\n                        buf[strLen++] = (char) c;\n                    } else if (c < 0xE0 && c > 0xBF) {\n                        // 110x xxxx 10xx xxxx\n                        cc = (char) (c & 0x1F);\n                        st = 1;\n                    } else {\n                        // 1110 xxxx 10xx xxxx 10xx xxxx\n                        cc = (char) (c & 0x0F);\n                        st = 2;\n                    }\n                    break;\n                case // byte 2 of 2-byte char or byte 3 of 3-byte char\n                1:\n                    buf[strLen++] = (char) ((cc << 6) | (c & 0x3F));\n                    st = 0;\n                    break;\n                case // byte 2 of 3-byte char\n                2:\n                    cc = (char) ((cc << 6) | (c & 0x3F));\n                    st = 1;\n                    break;\n            }\n        }\n        return new String(buf, 0, strLen);\n    }\n\n    /**\n     * Reads a class constant pool item in {@link #b b}. <i>This method is\n     * intended for {@link Attribute} sub classes, and is normally not needed by\n     * class generators or adapters.</i>\n     *\n     * @param index the start index of an unsigned short value in {@link #b b},\n     *        whose value is the index of a class constant pool item.\n     * @param buf buffer to be used to read the item. This buffer must be\n     *        sufficiently large. It is not automatically resized.\n     * @return the String corresponding to the specified class item.\n     */\n    public String readClass(final int index, final char[] buf) {\n        // computes the start index of the CONSTANT_Class item in b\n        // and reads the CONSTANT_Utf8 item designated by\n        // the first two bytes of this CONSTANT_Class item\n        return readUTF8(items[readUnsignedShort(index)], buf);\n    }\n\n    /**\n     * Reads a numeric or string constant pool item in {@link #b b}. <i>This\n     * method is intended for {@link Attribute} sub classes, and is normally not\n     * needed by class generators or adapters.</i>\n     *\n     * @param item the index of a constant pool item.\n     * @param buf buffer to be used to read the item. This buffer must be\n     *        sufficiently large. It is not automatically resized.\n     * @return the {@link Integer}, {@link Float}, {@link Long},\n     *         {@link Double}, {@link String} or {@link Type} corresponding to\n     *         the given constant pool item.\n     */\n    public Object readConst(final int item, final char[] buf) {\n        int index = items[item];\n        switch(b[index - 1]) {\n            case ClassWriter.INT:\n                return new Integer(readInt(index));\n            case ClassWriter.FLOAT:\n                return new Float(Float.intBitsToFloat(readInt(index)));\n            case ClassWriter.LONG:\n                return new Long(readLong(index));\n            case ClassWriter.DOUBLE:\n                return new Double(Double.longBitsToDouble(readLong(index)));\n            case ClassWriter.CLASS:\n                return Type.getObjectType(readUTF8(index, buf));\n            // case ClassWriter.STR:\n            default:\n                return readUTF8(index, buf);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/ClassReaderTest0.java",
		"test_prompt": "// ClassReaderTest0.java\npackage org.objectweb.asm.jip;\n\nimport java.io.InputStream;\nimport java.io.IOException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassReader}.\n* It contains ten unit test cases for the {@link ClassReader#readByte(int)} method.\n*/\nclass ClassReaderTest0 {"
	},
	{
		"original_code": "// ClassReader.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\nimport java.io.InputStream;\nimport java.io.IOException;\n\n/**\n * A Java class parser to make a {@link ClassVisitor} visit an existing class.\n * This class parses a byte array conforming to the Java class file format and\n * calls the appropriate visit methods of a given class visitor for each field,\n * method and bytecode instruction encountered.\n *\n * @author Eric Bruneton\n * @author Eugene Kuleshov\n */\npublic class ClassReader {\n\n    /**\n     * True to enable signatures support.\n     */\n    static final boolean SIGNATURES = true;\n\n    /**\n     * True to enable annotations support.\n     */\n    static final boolean ANNOTATIONS = true;\n\n    /**\n     * True to enable stack map frames support.\n     */\n    static final boolean FRAMES = true;\n\n    /**\n     * True to enable bytecode writing support.\n     */\n    static final boolean WRITER = true;\n\n    /**\n     * True to enable JSR_W and GOTO_W support.\n     */\n    static final boolean RESIZE = true;\n\n    /**\n     * Flag to skip method code. If this class is set <code>CODE</code>\n     * attribute won't be visited. This can be used, for example, to retrieve\n     * annotations for methods and method parameters.\n     */\n    public static final int SKIP_CODE = 1;\n\n    /**\n     * Flag to skip the debug information in the class. If this flag is set the\n     * debug information of the class is not visited, i.e. the\n     * {@link MethodVisitor#visitLocalVariable visitLocalVariable} and\n     * {@link MethodVisitor#visitLineNumber visitLineNumber} methods will not be\n     * called.\n     */\n    public static final int SKIP_DEBUG = 2;\n\n    /**\n     * Flag to skip the stack map frames in the class. If this flag is set the\n     * stack map frames of the class is not visited, i.e. the\n     * {@link MethodVisitor#visitFrame visitFrame} method will not be called.\n     * This flag is useful when the {@link ClassWriter#COMPUTE_FRAMES} option is\n     * used: it avoids visiting frames that will be ignored and recomputed from\n     * scratch in the class writer.\n     */\n    public static final int SKIP_FRAMES = 4;\n\n    /**\n     * Flag to expand the stack map frames. By default stack map frames are\n     * visited in their original format (i.e. \"expanded\" for classes whose\n     * version is less than V1_6, and \"compressed\" for the other classes). If\n     * this flag is set, stack map frames are always visited in expanded format\n     * (this option adds a decompression/recompression step in ClassReader and\n     * ClassWriter which degrades performances quite a lot).\n     */\n    public static final int EXPAND_FRAMES = 8;\n\n    /**\n     * The class to be parsed. <i>The content of this array must not be\n     * modified. This field is intended for {@link Attribute} sub classes, and\n     * is normally not needed by class generators or adapters.</i>\n     */\n    public final byte[] b;\n\n    /**\n     * The start index of each constant pool item in {@link #b b}, plus one.\n     * The one byte offset skips the constant pool item tag that indicates its\n     * type.\n     */\n    private final int[] items;\n\n    /**\n     * The String objects corresponding to the CONSTANT_Utf8 items. This cache\n     * avoids multiple parsing of a given CONSTANT_Utf8 constant pool item,\n     * which GREATLY improves performances (by a factor 2 to 3). This caching\n     * strategy could be extended to all constant pool items, but its benefit\n     * would not be so great for these items (because they are much less\n     * expensive to parse than CONSTANT_Utf8 items).\n     */\n    private final String[] strings;\n\n    /**\n     * Maximum length of the strings contained in the constant pool of the\n     * class.\n     */\n    private final int maxStringLength;\n\n    /**\n     * Start index of the class header information (access, name...) in\n     * {@link #b b}.\n     */\n    public final int header;\n\n    // ------------------------------------------------------------------------\n    // Constructors\n    // ------------------------------------------------------------------------\n    /**\n     * Constructs a new {@link ClassReader} object.\n     *\n     * @param b the bytecode of the class to be read.\n     */\n    public ClassReader(final byte[] b) {\n        this(b, 0, b.length);\n    }\n\n    /**\n     * Constructs a new {@link ClassReader} object.\n     *\n     * @param b the bytecode of the class to be read.\n     * @param off the start offset of the class data.\n     * @param len the length of the class data.\n     */\n    public ClassReader(final byte[] b, final int off, final int len) {\n        this.b = b;\n        // parses the constant pool\n        items = new int[readUnsignedShort(off + 8)];\n        int n = items.length;\n        strings = new String[n];\n        int max = 0;\n        int index = off + 10;\n        for (int i = 1; i < n; ++i) {\n            items[i] = index + 1;\n            int size;\n            switch(b[index]) {\n                case ClassWriter.FIELD:\n                case ClassWriter.METH:\n                case ClassWriter.IMETH:\n                case ClassWriter.INT:\n                case ClassWriter.FLOAT:\n                case ClassWriter.NAME_TYPE:\n                    size = 5;\n                    break;\n                case ClassWriter.LONG:\n                case ClassWriter.DOUBLE:\n                    size = 9;\n                    ++i;\n                    break;\n                case ClassWriter.UTF8:\n                    size = 3 + readUnsignedShort(index + 1);\n                    if (size > max) {\n                        max = size;\n                    }\n                    break;\n                // case ClassWriter.CLASS:\n                // case ClassWriter.STR:\n                default:\n                    size = 3;\n                    break;\n            }\n            index += size;\n        }\n        maxStringLength = max;\n        // the class header information starts just after the constant pool\n        header = index;\n    }\n\n    /**\n     * Returns the class's access flags (see {@link Opcodes}). This value may\n     * not reflect Deprecated and Synthetic flags when bytecode is before 1.5\n     * and those flags are represented by attributes.\n     *\n     * @return the class access flags\n     *\n     * @see ClassVisitor#visit(int, int, String, String, String, String[])\n     */\n    public int getAccess() {\n        return readUnsignedShort(header);\n    }\n\n    /**\n     * Returns the internal name of the class (see\n     * {@link Type#getInternalName() getInternalName}).\n     *\n     * @return the internal class name\n     *\n     * @see ClassVisitor#visit(int, int, String, String, String, String[])\n     */\n    public String getClassName() {\n        return readClass(header + 2, new char[maxStringLength]);\n    }\n\n    /**\n     * Returns the internal of name of the super class (see\n     * {@link Type#getInternalName() getInternalName}). For interfaces, the\n     * super class is {@link Object}.\n     *\n     * @return the internal name of super class, or <tt>null</tt> for\n     *         {@link Object} class.\n     *\n     * @see ClassVisitor#visit(int, int, String, String, String, String[])\n     */\n    public String getSuperName() {\n        int n = items[readUnsignedShort(header + 4)];\n        return n == 0 ? null : readUTF8(n, new char[maxStringLength]);\n    }\n\n    /**\n     * Returns the internal names of the class's interfaces (see\n     * {@link Type#getInternalName() getInternalName}).\n     *\n     * @return the array of internal names for all implemented interfaces or\n     *         <tt>null</tt>.\n     *\n     * @see ClassVisitor#visit(int, int, String, String, String, String[])\n     */\n    public String[] getInterfaces() {\n        int index = header + 6;\n        int n = readUnsignedShort(index);\n        String[] interfaces = new String[n];\n        if (n > 0) {\n            char[] buf = new char[maxStringLength];\n            for (int i = 0; i < n; ++i) {\n                index += 2;\n                interfaces[i] = readClass(index, buf);\n            }\n        }\n        return interfaces;\n    }\n\n    /**\n     * Copies the constant pool data into the given {@link ClassWriter}. Should\n     * be called before the {@link #accept(ClassVisitor,int)} method.\n     *\n     * @param classWriter the {@link ClassWriter} to copy constant pool into.\n     */\n    void copyPool(final ClassWriter classWriter) {\n        char[] buf = new char[maxStringLength];\n        int ll = items.length;\n        Item[] items2 = new Item[ll];\n        for (int i = 1; i < ll; i++) {\n            int index = items[i];\n            int tag = b[index - 1];\n            Item item = new Item(i);\n            int nameType;\n            switch(tag) {\n                case ClassWriter.FIELD:\n                case ClassWriter.METH:\n                case ClassWriter.IMETH:\n                    nameType = items[readUnsignedShort(index + 2)];\n                    item.set(tag, readClass(index, buf), readUTF8(nameType, buf), readUTF8(nameType + 2, buf));\n                    break;\n                case ClassWriter.INT:\n                    item.set(readInt(index));\n                    break;\n                case ClassWriter.FLOAT:\n                    item.set(Float.intBitsToFloat(readInt(index)));\n                    break;\n                case ClassWriter.NAME_TYPE:\n                    item.set(tag, readUTF8(index, buf), readUTF8(index + 2, buf), null);\n                    break;\n                case ClassWriter.LONG:\n                    item.set(readLong(index));\n                    ++i;\n                    break;\n                case ClassWriter.DOUBLE:\n                    item.set(Double.longBitsToDouble(readLong(index)));\n                    ++i;\n                    break;\n                case ClassWriter.UTF8:\n                    {\n                        String s = strings[i];\n                        if (s == null) {\n                            index = items[i];\n                            s = strings[i] = readUTF(index + 2, readUnsignedShort(index), buf);\n                        }\n                        item.set(tag, s, null, null);\n                    }\n                    break;\n                // case ClassWriter.STR:\n                // case ClassWriter.CLASS:\n                default:\n                    item.set(tag, readUTF8(index, buf), null, null);\n                    break;\n            }\n            int index2 = item.hashCode % items2.length;\n            item.next = items2[index2];\n            items2[index2] = item;\n        }\n        int off = items[1] - 1;\n        classWriter.pool.putByteArray(b, off, header - off);\n        classWriter.items = items2;\n        classWriter.threshold = (int) (0.75d * ll);\n        classWriter.index = ll;\n    }\n\n    /**\n     * Constructs a new {@link ClassReader} object.\n     *\n     * @param is an input stream from which to read the class.\n     * @throws IOException if a problem occurs during reading.\n     */\n    public ClassReader(final InputStream is) throws IOException {\n        this(readClass(is));\n    }\n\n    /**\n     * Constructs a new {@link ClassReader} object.\n     *\n     * @param name the fully qualified name of the class to be read.\n     * @throws IOException if an exception occurs during reading.\n     */\n    public ClassReader(final String name) throws IOException {\n        this(ClassLoader.getSystemResourceAsStream(name.replace('.', '/') + \".class\"));\n    }\n\n    /**\n     * Reads the bytecode of a class.\n     *\n     * @param is an input stream from which to read the class.\n     * @return the bytecode read from the given input stream.\n     * @throws IOException if a problem occurs during reading.\n     */\n    private static byte[] readClass(final InputStream is) throws IOException {\n        if (is == null) {\n            throw new IOException(\"Class not found\");\n        }\n        byte[] b = new byte[is.available()];\n        int len = 0;\n        while (true) {\n            int n = is.read(b, len, b.length - len);\n            if (n == -1) {\n                if (len < b.length) {\n                    byte[] c = new byte[len];\n                    System.arraycopy(b, 0, c, 0, len);\n                    b = c;\n                }\n                return b;\n            }\n            len += n;\n            if (len == b.length) {\n                int last = is.read();\n                if (last < 0) {\n                    return b;\n                }\n                byte[] c = new byte[b.length + 1000];\n                System.arraycopy(b, 0, c, 0, len);\n                c[len++] = (byte) last;\n                b = c;\n            }\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Public methods\n    // ------------------------------------------------------------------------\n    /**\n     * Makes the given visitor visit the Java class of this {@link ClassReader}.\n     * This class is the one specified in the constructor (see\n     * {@link #ClassReader(byte[]) ClassReader}).\n     *\n     * @param classVisitor the visitor that must visit this class.\n     * @param flags option flags that can be used to modify the default behavior\n     *        of this class. See {@link #SKIP_DEBUG}, {@link #EXPAND_FRAMES},\n     *        {@link #SKIP_FRAMES}, {@link #SKIP_CODE}.\n     */\n    public void accept(final ClassVisitor classVisitor, final int flags) {\n        accept(classVisitor, new Attribute[0], flags);\n    }\n\n    /**\n     * Makes the given visitor visit the Java class of this {@link ClassReader}.\n     * This class is the one specified in the constructor (see\n     * {@link #ClassReader(byte[]) ClassReader}).\n     *\n     * @param classVisitor the visitor that must visit this class.\n     * @param attrs prototypes of the attributes that must be parsed during the\n     *        visit of the class. Any attribute whose type is not equal to the\n     *        type of one the prototypes will not be parsed: its byte array\n     *        value will be passed unchanged to the ClassWriter. <i>This may\n     *        corrupt it if this value contains references to the constant pool,\n     *        or has syntactic or semantic links with a class element that has\n     *        been transformed by a class adapter between the reader and the\n     *        writer</i>.\n     * @param flags option flags that can be used to modify the default behavior\n     *        of this class. See {@link #SKIP_DEBUG}, {@link #EXPAND_FRAMES},\n     *        {@link #SKIP_FRAMES}, {@link #SKIP_CODE}.\n     */\n    public void accept(final ClassVisitor classVisitor, final Attribute[] attrs, final int flags) {\n        // the bytecode array\n        byte[] b = this.b;\n        // buffer used to read strings\n        char[] c = new char[maxStringLength];\n        // loop variables\n        int i, j, k;\n        // indexes in b\n        int u, v, w;\n        Attribute attr;\n        int access;\n        String name;\n        String desc;\n        String attrName;\n        String signature;\n        int anns = 0;\n        int ianns = 0;\n        Attribute cattrs = null;\n        // visits the header\n        u = header;\n        access = readUnsignedShort(u);\n        name = readClass(u + 2, c);\n        v = items[readUnsignedShort(u + 4)];\n        String superClassName = v == 0 ? null : readUTF8(v, c);\n        String[] implementedItfs = new String[readUnsignedShort(u + 6)];\n        w = 0;\n        u += 8;\n        for (i = 0; i < implementedItfs.length; ++i) {\n            implementedItfs[i] = readClass(u, c);\n            u += 2;\n        }\n        boolean skipCode = (flags & SKIP_CODE) != 0;\n        boolean skipDebug = (flags & SKIP_DEBUG) != 0;\n        boolean unzip = (flags & EXPAND_FRAMES) != 0;\n        // skips fields and methods\n        v = u;\n        i = readUnsignedShort(v);\n        v += 2;\n        for (; i > 0; --i) {\n            j = readUnsignedShort(v + 6);\n            v += 8;\n            for (; j > 0; --j) {\n                v += 6 + readInt(v + 2);\n            }\n        }\n        i = readUnsignedShort(v);\n        v += 2;\n        for (; i > 0; --i) {\n            j = readUnsignedShort(v + 6);\n            v += 8;\n            for (; j > 0; --j) {\n                v += 6 + readInt(v + 2);\n            }\n        }\n        // reads the class's attributes\n        signature = null;\n        String sourceFile = null;\n        String sourceDebug = null;\n        String enclosingOwner = null;\n        String enclosingName = null;\n        String enclosingDesc = null;\n        i = readUnsignedShort(v);\n        v += 2;\n        for (; i > 0; --i) {\n            attrName = readUTF8(v, c);\n            // tests are sorted in decreasing frequency order\n            // (based on frequencies observed on typical classes)\n            if (\"SourceFile\".equals(attrName)) {\n                sourceFile = readUTF8(v + 6, c);\n            } else if (\"InnerClasses\".equals(attrName)) {\n                w = v + 6;\n            } else if (\"EnclosingMethod\".equals(attrName)) {\n                enclosingOwner = readClass(v + 6, c);\n                int item = readUnsignedShort(v + 8);\n                if (item != 0) {\n                    enclosingName = readUTF8(items[item], c);\n                    enclosingDesc = readUTF8(items[item] + 2, c);\n                }\n            } else if (SIGNATURES && \"Signature\".equals(attrName)) {\n                signature = readUTF8(v + 6, c);\n            } else if (ANNOTATIONS && \"RuntimeVisibleAnnotations\".equals(attrName)) {\n                anns = v + 6;\n            } else if (\"Deprecated\".equals(attrName)) {\n                access |= Opcodes.ACC_DEPRECATED;\n            } else if (\"Synthetic\".equals(attrName)) {\n                access |= Opcodes.ACC_SYNTHETIC;\n            } else if (\"SourceDebugExtension\".equals(attrName)) {\n                int len = readInt(v + 2);\n                sourceDebug = readUTF(v + 6, len, new char[len]);\n            } else if (ANNOTATIONS && \"RuntimeInvisibleAnnotations\".equals(attrName)) {\n                ianns = v + 6;\n            } else {\n                attr = readAttribute(attrs, attrName, v + 6, readInt(v + 2), c, -1, null);\n                if (attr != null) {\n                    attr.next = cattrs;\n                    cattrs = attr;\n                }\n            }\n            v += 6 + readInt(v + 2);\n        }\n        // calls the visit method\n        classVisitor.visit(readInt(4), access, name, signature, superClassName, implementedItfs);\n        // calls the visitSource method\n        if (!skipDebug && (sourceFile != null || sourceDebug != null)) {\n            classVisitor.visitSource(sourceFile, sourceDebug);\n        }\n        // calls the visitOuterClass method\n        if (enclosingOwner != null) {\n            classVisitor.visitOuterClass(enclosingOwner, enclosingName, enclosingDesc);\n        }\n        // visits the class annotations\n        if (ANNOTATIONS) {\n            for (i = 1; i >= 0; --i) {\n                v = i == 0 ? ianns : anns;\n                if (v != 0) {\n                    j = readUnsignedShort(v);\n                    v += 2;\n                    for (; j > 0; --j) {\n                        v = readAnnotationValues(v + 2, c, true, classVisitor.visitAnnotation(readUTF8(v, c), i != 0));\n                    }\n                }\n            }\n        }\n        // visits the class attributes\n        while (cattrs != null) {\n            attr = cattrs.next;\n            cattrs.next = null;\n            classVisitor.visitAttribute(cattrs);\n            cattrs = attr;\n        }\n        // calls the visitInnerClass method\n        if (w != 0) {\n            i = readUnsignedShort(w);\n            w += 2;\n            for (; i > 0; --i) {\n                classVisitor.visitInnerClass(readUnsignedShort(w) == 0 ? null : readClass(w, c), readUnsignedShort(w + 2) == 0 ? null : readClass(w + 2, c), readUnsignedShort(w + 4) == 0 ? null : readUTF8(w + 4, c), readUnsignedShort(w + 6));\n                w += 8;\n            }\n        }\n        // visits the fields\n        i = readUnsignedShort(u);\n        u += 2;\n        for (; i > 0; --i) {\n            access = readUnsignedShort(u);\n            name = readUTF8(u + 2, c);\n            desc = readUTF8(u + 4, c);\n            // visits the field's attributes and looks for a ConstantValue\n            // attribute\n            int fieldValueItem = 0;\n            signature = null;\n            anns = 0;\n            ianns = 0;\n            cattrs = null;\n            j = readUnsignedShort(u + 6);\n            u += 8;\n            for (; j > 0; --j) {\n                attrName = readUTF8(u, c);\n                // tests are sorted in decreasing frequency order\n                // (based on frequencies observed on typical classes)\n                if (\"ConstantValue\".equals(attrName)) {\n                    fieldValueItem = readUnsignedShort(u + 6);\n                } else if (SIGNATURES && \"Signature\".equals(attrName)) {\n                    signature = readUTF8(u + 6, c);\n                } else if (\"Deprecated\".equals(attrName)) {\n                    access |= Opcodes.ACC_DEPRECATED;\n                } else if (\"Synthetic\".equals(attrName)) {\n                    access |= Opcodes.ACC_SYNTHETIC;\n                } else if (ANNOTATIONS && \"RuntimeVisibleAnnotations\".equals(attrName)) {\n                    anns = u + 6;\n                } else if (ANNOTATIONS && \"RuntimeInvisibleAnnotations\".equals(attrName)) {\n                    ianns = u + 6;\n                } else {\n                    attr = readAttribute(attrs, attrName, u + 6, readInt(u + 2), c, -1, null);\n                    if (attr != null) {\n                        attr.next = cattrs;\n                        cattrs = attr;\n                    }\n                }\n                u += 6 + readInt(u + 2);\n            }\n            // visits the field\n            FieldVisitor fv = classVisitor.visitField(access, name, desc, signature, fieldValueItem == 0 ? null : readConst(fieldValueItem, c));\n            // visits the field annotations and attributes\n            if (fv != null) {\n                if (ANNOTATIONS) {\n                    for (j = 1; j >= 0; --j) {\n                        v = j == 0 ? ianns : anns;\n                        if (v != 0) {\n                            k = readUnsignedShort(v);\n                            v += 2;\n                            for (; k > 0; --k) {\n                                v = readAnnotationValues(v + 2, c, true, fv.visitAnnotation(readUTF8(v, c), j != 0));\n                            }\n                        }\n                    }\n                }\n                while (cattrs != null) {\n                    attr = cattrs.next;\n                    cattrs.next = null;\n                    fv.visitAttribute(cattrs);\n                    cattrs = attr;\n                }\n                fv.visitEnd();\n            }\n        }\n        // visits the methods\n        i = readUnsignedShort(u);\n        u += 2;\n        for (; i > 0; --i) {\n            int u0 = u + 6;\n            access = readUnsignedShort(u);\n            name = readUTF8(u + 2, c);\n            desc = readUTF8(u + 4, c);\n            signature = null;\n            anns = 0;\n            ianns = 0;\n            int dann = 0;\n            int mpanns = 0;\n            int impanns = 0;\n            cattrs = null;\n            v = 0;\n            w = 0;\n            // looks for Code and Exceptions attributes\n            j = readUnsignedShort(u + 6);\n            u += 8;\n            for (; j > 0; --j) {\n                attrName = readUTF8(u, c);\n                int attrSize = readInt(u + 2);\n                u += 6;\n                // tests are sorted in decreasing frequency order\n                // (based on frequencies observed on typical classes)\n                if (\"Code\".equals(attrName)) {\n                    if (!skipCode) {\n                        v = u;\n                    }\n                } else if (\"Exceptions\".equals(attrName)) {\n                    w = u;\n                } else if (SIGNATURES && \"Signature\".equals(attrName)) {\n                    signature = readUTF8(u, c);\n                } else if (\"Deprecated\".equals(attrName)) {\n                    access |= Opcodes.ACC_DEPRECATED;\n                } else if (ANNOTATIONS && \"RuntimeVisibleAnnotations\".equals(attrName)) {\n                    anns = u;\n                } else if (ANNOTATIONS && \"AnnotationDefault\".equals(attrName)) {\n                    dann = u;\n                } else if (\"Synthetic\".equals(attrName)) {\n                    access |= Opcodes.ACC_SYNTHETIC;\n                } else if (ANNOTATIONS && \"RuntimeInvisibleAnnotations\".equals(attrName)) {\n                    ianns = u;\n                } else if (ANNOTATIONS && \"RuntimeVisibleParameterAnnotations\".equals(attrName)) {\n                    mpanns = u;\n                } else if (ANNOTATIONS && \"RuntimeInvisibleParameterAnnotations\".equals(attrName)) {\n                    impanns = u;\n                } else {\n                    attr = readAttribute(attrs, attrName, u, attrSize, c, -1, null);\n                    if (attr != null) {\n                        attr.next = cattrs;\n                        cattrs = attr;\n                    }\n                }\n                u += attrSize;\n            }\n            // reads declared exceptions\n            String[] exceptions;\n            if (w == 0) {\n                exceptions = null;\n            } else {\n                exceptions = new String[readUnsignedShort(w)];\n                w += 2;\n                for (j = 0; j < exceptions.length; ++j) {\n                    exceptions[j] = readClass(w, c);\n                    w += 2;\n                }\n            }\n            // visits the method's code, if any\n            MethodVisitor mv = classVisitor.visitMethod(access, name, desc, signature, exceptions);\n            if (mv != null) {\n                /*\n                 * if the returned MethodVisitor is in fact a MethodWriter, it\n                 * means there is no method adapter between the reader and the\n                 * writer. If, in addition, the writer's constant pool was\n                 * copied from this reader (mw.cw.cr == this), and the signature\n                 * and exceptions of the method have not been changed, then it\n                 * is possible to skip all visit events and just copy the\n                 * original code of the method to the writer (the access, name\n                 * and descriptor can have been changed, this is not important\n                 * since they are not copied as is from the reader).\n                 */\n                if (WRITER && mv instanceof MethodWriter) {\n                    MethodWriter mw = (MethodWriter) mv;\n                    if (mw.cw.cr == this) {\n                        if (signature == mw.signature) {\n                            boolean sameExceptions = false;\n                            if (exceptions == null) {\n                                sameExceptions = mw.exceptionCount == 0;\n                            } else {\n                                if (exceptions.length == mw.exceptionCount) {\n                                    sameExceptions = true;\n                                    for (j = exceptions.length - 1; j >= 0; --j) {\n                                        w -= 2;\n                                        if (mw.exceptions[j] != readUnsignedShort(w)) {\n                                            sameExceptions = false;\n                                            break;\n                                        }\n                                    }\n                                }\n                            }\n                            if (sameExceptions) {\n                                /*\n                                 * we do not copy directly the code into\n                                 * MethodWriter to save a byte array copy\n                                 * operation. The real copy will be done in\n                                 * ClassWriter.toByteArray().\n                                 */\n                                mw.classReaderOffset = u0;\n                                mw.classReaderLength = u - u0;\n                                continue;\n                            }\n                        }\n                    }\n                }\n                if (ANNOTATIONS && dann != 0) {\n                    AnnotationVisitor dv = mv.visitAnnotationDefault();\n                    readAnnotationValue(dann, c, null, dv);\n                    if (dv != null) {\n                        dv.visitEnd();\n                    }\n                }\n                if (ANNOTATIONS) {\n                    for (j = 1; j >= 0; --j) {\n                        w = j == 0 ? ianns : anns;\n                        if (w != 0) {\n                            k = readUnsignedShort(w);\n                            w += 2;\n                            for (; k > 0; --k) {\n                                w = readAnnotationValues(w + 2, c, true, mv.visitAnnotation(readUTF8(w, c), j != 0));\n                            }\n                        }\n                    }\n                }\n                if (ANNOTATIONS && mpanns != 0) {\n                    readParameterAnnotations(mpanns, desc, c, true, mv);\n                }\n                if (ANNOTATIONS && impanns != 0) {\n                    readParameterAnnotations(impanns, desc, c, false, mv);\n                }\n                while (cattrs != null) {\n                    attr = cattrs.next;\n                    cattrs.next = null;\n                    mv.visitAttribute(cattrs);\n                    cattrs = attr;\n                }\n            }\n            if (mv != null && v != 0) {\n                int maxStack = readUnsignedShort(v);\n                int maxLocals = readUnsignedShort(v + 2);\n                int codeLength = readInt(v + 4);\n                v += 8;\n                int codeStart = v;\n                int codeEnd = v + codeLength;\n                mv.visitCode();\n                // 1st phase: finds the labels\n                int label;\n                Label[] labels = new Label[codeLength + 2];\n                readLabel(codeLength + 1, labels);\n                while (v < codeEnd) {\n                    w = v - codeStart;\n                    int opcode = b[v] & 0xFF;\n                    switch(ClassWriter.TYPE[opcode]) {\n                        case ClassWriter.NOARG_INSN:\n                        case ClassWriter.IMPLVAR_INSN:\n                            v += 1;\n                            break;\n                        case ClassWriter.LABEL_INSN:\n                            readLabel(w + readShort(v + 1), labels);\n                            v += 3;\n                            break;\n                        case ClassWriter.LABELW_INSN:\n                            readLabel(w + readInt(v + 1), labels);\n                            v += 5;\n                            break;\n                        case ClassWriter.WIDE_INSN:\n                            opcode = b[v + 1] & 0xFF;\n                            if (opcode == Opcodes.IINC) {\n                                v += 6;\n                            } else {\n                                v += 4;\n                            }\n                            break;\n                        case ClassWriter.TABL_INSN:\n                            // skips 0 to 3 padding bytes*\n                            v = v + 4 - (w & 3);\n                            // reads instruction\n                            readLabel(w + readInt(v), labels);\n                            j = readInt(v + 8) - readInt(v + 4) + 1;\n                            v += 12;\n                            for (; j > 0; --j) {\n                                readLabel(w + readInt(v), labels);\n                                v += 4;\n                            }\n                            break;\n                        case ClassWriter.LOOK_INSN:\n                            // skips 0 to 3 padding bytes*\n                            v = v + 4 - (w & 3);\n                            // reads instruction\n                            readLabel(w + readInt(v), labels);\n                            j = readInt(v + 4);\n                            v += 8;\n                            for (; j > 0; --j) {\n                                readLabel(w + readInt(v + 4), labels);\n                                v += 8;\n                            }\n                            break;\n                        case ClassWriter.VAR_INSN:\n                        case ClassWriter.SBYTE_INSN:\n                        case ClassWriter.LDC_INSN:\n                            v += 2;\n                            break;\n                        case ClassWriter.SHORT_INSN:\n                        case ClassWriter.LDCW_INSN:\n                        case ClassWriter.FIELDORMETH_INSN:\n                        case ClassWriter.TYPE_INSN:\n                        case ClassWriter.IINC_INSN:\n                            v += 3;\n                            break;\n                        case ClassWriter.ITFDYNMETH_INSN:\n                            v += 5;\n                            break;\n                        // case MANA_INSN:\n                        default:\n                            v += 4;\n                            break;\n                    }\n                }\n                // parses the try catch entries\n                j = readUnsignedShort(v);\n                v += 2;\n                for (; j > 0; --j) {\n                    Label start = readLabel(readUnsignedShort(v), labels);\n                    Label end = readLabel(readUnsignedShort(v + 2), labels);\n                    Label handler = readLabel(readUnsignedShort(v + 4), labels);\n                    int type = readUnsignedShort(v + 6);\n                    if (type == 0) {\n                        mv.visitTryCatchBlock(start, end, handler, null);\n                    } else {\n                        mv.visitTryCatchBlock(start, end, handler, readUTF8(items[type], c));\n                    }\n                    v += 8;\n                }\n                // parses the local variable, line number tables, and code\n                // attributes\n                int varTable = 0;\n                int varTypeTable = 0;\n                int stackMap = 0;\n                int stackMapSize = 0;\n                int frameCount = 0;\n                int frameMode = 0;\n                int frameOffset = 0;\n                int frameLocalCount = 0;\n                int frameLocalDiff = 0;\n                int frameStackCount = 0;\n                Object[] frameLocal = null;\n                Object[] frameStack = null;\n                boolean zip = true;\n                cattrs = null;\n                j = readUnsignedShort(v);\n                v += 2;\n                for (; j > 0; --j) {\n                    attrName = readUTF8(v, c);\n                    if (\"LocalVariableTable\".equals(attrName)) {\n                        if (!skipDebug) {\n                            varTable = v + 6;\n                            k = readUnsignedShort(v + 6);\n                            w = v + 8;\n                            for (; k > 0; --k) {\n                                label = readUnsignedShort(w);\n                                if (labels[label] == null) {\n                                    readLabel(label, labels).status |= Label.DEBUG;\n                                }\n                                label += readUnsignedShort(w + 2);\n                                if (labels[label] == null) {\n                                    readLabel(label, labels).status |= Label.DEBUG;\n                                }\n                                w += 10;\n                            }\n                        }\n                    } else if (\"LocalVariableTypeTable\".equals(attrName)) {\n                        varTypeTable = v + 6;\n                    } else if (\"LineNumberTable\".equals(attrName)) {\n                        if (!skipDebug) {\n                            k = readUnsignedShort(v + 6);\n                            w = v + 8;\n                            for (; k > 0; --k) {\n                                label = readUnsignedShort(w);\n                                if (labels[label] == null) {\n                                    readLabel(label, labels).status |= Label.DEBUG;\n                                }\n                                labels[label].line = readUnsignedShort(w + 2);\n                                w += 4;\n                            }\n                        }\n                    } else if (FRAMES && \"StackMapTable\".equals(attrName)) {\n                        if ((flags & SKIP_FRAMES) == 0) {\n                            stackMap = v + 8;\n                            stackMapSize = readInt(v + 2);\n                            frameCount = readUnsignedShort(v + 6);\n                        }\n                        /*\n                         * here we do not extract the labels corresponding to\n                         * the attribute content. This would require a full\n                         * parsing of the attribute, which would need to be\n                         * repeated in the second phase (see below). Instead the\n                         * content of the attribute is read one frame at a time\n                         * (i.e. after a frame has been visited, the next frame\n                         * is read), and the labels it contains are also\n                         * extracted one frame at a time. Thanks to the ordering\n                         * of frames, having only a \"one frame lookahead\" is not\n                         * a problem, i.e. it is not possible to see an offset\n                         * smaller than the offset of the current insn and for\n                         * which no Label exist.\n                         */\n                        /*\n                         * This is not true for UNINITIALIZED type offsets. We\n                         * solve this by parsing the stack map table without a\n                         * full decoding (see below).\n                         */\n                    } else if (FRAMES && \"StackMap\".equals(attrName)) {\n                        if ((flags & SKIP_FRAMES) == 0) {\n                            stackMap = v + 8;\n                            stackMapSize = readInt(v + 2);\n                            frameCount = readUnsignedShort(v + 6);\n                            zip = false;\n                        }\n                        /*\n                         * IMPORTANT! here we assume that the frames are\n                         * ordered, as in the StackMapTable attribute, although\n                         * this is not guaranteed by the attribute format.\n                         */\n                    } else {\n                        for (k = 0; k < attrs.length; ++k) {\n                            if (attrs[k].type.equals(attrName)) {\n                                attr = attrs[k].read(this, v + 6, readInt(v + 2), c, codeStart - 8, labels);\n                                if (attr != null) {\n                                    attr.next = cattrs;\n                                    cattrs = attr;\n                                }\n                            }\n                        }\n                    }\n                    v += 6 + readInt(v + 2);\n                }\n                // 2nd phase: visits each instruction\n                if (FRAMES && stackMap != 0) {\n                    // creates the very first (implicit) frame from the method\n                    // descriptor\n                    frameLocal = new Object[maxLocals];\n                    frameStack = new Object[maxStack];\n                    if (unzip) {\n                        int local = 0;\n                        if ((access & Opcodes.ACC_STATIC) == 0) {\n                            if (\"<init>\".equals(name)) {\n                                frameLocal[local++] = Opcodes.UNINITIALIZED_THIS;\n                            } else {\n                                frameLocal[local++] = readClass(header + 2, c);\n                            }\n                        }\n                        j = 1;\n                        loop: while (true) {\n                            k = j;\n                            switch(desc.charAt(j++)) {\n                                case 'Z':\n                                case 'C':\n                                case 'B':\n                                case 'S':\n                                case 'I':\n                                    frameLocal[local++] = Opcodes.INTEGER;\n                                    break;\n                                case 'F':\n                                    frameLocal[local++] = Opcodes.FLOAT;\n                                    break;\n                                case 'J':\n                                    frameLocal[local++] = Opcodes.LONG;\n                                    break;\n                                case 'D':\n                                    frameLocal[local++] = Opcodes.DOUBLE;\n                                    break;\n                                case '[':\n                                    while (desc.charAt(j) == '[') {\n                                        ++j;\n                                    }\n                                    if (desc.charAt(j) == 'L') {\n                                        ++j;\n                                        while (desc.charAt(j) != ';') {\n                                            ++j;\n                                        }\n                                    }\n                                    frameLocal[local++] = desc.substring(k, ++j);\n                                    break;\n                                case 'L':\n                                    while (desc.charAt(j) != ';') {\n                                        ++j;\n                                    }\n                                    frameLocal[local++] = desc.substring(k + 1, j++);\n                                    break;\n                                default:\n                                    break loop;\n                            }\n                        }\n                        frameLocalCount = local;\n                    }\n                    /*\n                     * for the first explicit frame the offset is not\n                     * offset_delta + 1 but only offset_delta; setting the\n                     * implicit frame offset to -1 allow the use of the\n                     * \"offset_delta + 1\" rule in all cases\n                     */\n                    frameOffset = -1;\n                    /*\n                     * Finds labels for UNINITIALIZED frame types. Instead of\n                     * decoding each element of the stack map table, we look\n                     * for 3 consecutive bytes that \"look like\" an UNINITIALIZED\n                     * type (tag 8, offset within code bounds, NEW instruction\n                     * at this offset). We may find false positives (i.e. not \n                     * real UNINITIALIZED types), but this should be rare, and \n                     * the only consequence will be the creation of an unneeded \n                     * label. This is better than creating a label for each NEW\n                     * instruction, and faster than fully decoding the whole \n                     * stack map table.\n                     */\n                    for (j = stackMap; j < stackMap + stackMapSize - 2; ++j) {\n                        if (b[j] == 8) {\n                            // UNINITIALIZED FRAME TYPE\n                            k = readUnsignedShort(j + 1);\n                            if (k >= 0 && k < codeLength) {\n                                // potential offset\n                                if ((b[codeStart + k] & 0xFF) == Opcodes.NEW) {\n                                    // NEW at this offset\n                                    readLabel(k, labels);\n                                }\n                            }\n                        }\n                    }\n                }\n                v = codeStart;\n                Label l;\n                while (v < codeEnd) {\n                    w = v - codeStart;\n                    l = labels[w];\n                    if (l != null) {\n                        mv.visitLabel(l);\n                        if (!skipDebug && l.line > 0) {\n                            mv.visitLineNumber(l.line, l);\n                        }\n                    }\n                    while (FRAMES && frameLocal != null && (frameOffset == w || frameOffset == -1)) {\n                        // if there is a frame for this offset,\n                        // makes the visitor visit it,\n                        // and reads the next frame if there is one.\n                        if (!zip || unzip) {\n                            mv.visitFrame(Opcodes.F_NEW, frameLocalCount, frameLocal, frameStackCount, frameStack);\n                        } else if (frameOffset != -1) {\n                            mv.visitFrame(frameMode, frameLocalDiff, frameLocal, frameStackCount, frameStack);\n                        }\n                        if (frameCount > 0) {\n                            int tag, delta, n;\n                            if (zip) {\n                                tag = b[stackMap++] & 0xFF;\n                            } else {\n                                tag = MethodWriter.FULL_FRAME;\n                                frameOffset = -1;\n                            }\n                            frameLocalDiff = 0;\n                            if (tag < MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME) {\n                                delta = tag;\n                                frameMode = Opcodes.F_SAME;\n                                frameStackCount = 0;\n                            } else if (tag < MethodWriter.RESERVED) {\n                                delta = tag - MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME;\n                                stackMap = readFrameType(frameStack, 0, stackMap, c, labels);\n                                frameMode = Opcodes.F_SAME1;\n                                frameStackCount = 1;\n                            } else {\n                                delta = readUnsignedShort(stackMap);\n                                stackMap += 2;\n                                if (tag == MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {\n                                    stackMap = readFrameType(frameStack, 0, stackMap, c, labels);\n                                    frameMode = Opcodes.F_SAME1;\n                                    frameStackCount = 1;\n                                } else if (tag >= MethodWriter.CHOP_FRAME && tag < MethodWriter.SAME_FRAME_EXTENDED) {\n                                    frameMode = Opcodes.F_CHOP;\n                                    frameLocalDiff = MethodWriter.SAME_FRAME_EXTENDED - tag;\n                                    frameLocalCount -= frameLocalDiff;\n                                    frameStackCount = 0;\n                                } else if (tag == MethodWriter.SAME_FRAME_EXTENDED) {\n                                    frameMode = Opcodes.F_SAME;\n                                    frameStackCount = 0;\n                                } else if (tag < MethodWriter.FULL_FRAME) {\n                                    j = unzip ? frameLocalCount : 0;\n                                    for (k = tag - MethodWriter.SAME_FRAME_EXTENDED; k > 0; k--) {\n                                        stackMap = readFrameType(frameLocal, j++, stackMap, c, labels);\n                                    }\n                                    frameMode = Opcodes.F_APPEND;\n                                    frameLocalDiff = tag - MethodWriter.SAME_FRAME_EXTENDED;\n                                    frameLocalCount += frameLocalDiff;\n                                    frameStackCount = 0;\n                                } else {\n                                    // if (tag == FULL_FRAME) {\n                                    frameMode = Opcodes.F_FULL;\n                                    n = frameLocalDiff = frameLocalCount = readUnsignedShort(stackMap);\n                                    stackMap += 2;\n                                    for (j = 0; n > 0; n--) {\n                                        stackMap = readFrameType(frameLocal, j++, stackMap, c, labels);\n                                    }\n                                    n = frameStackCount = readUnsignedShort(stackMap);\n                                    stackMap += 2;\n                                    for (j = 0; n > 0; n--) {\n                                        stackMap = readFrameType(frameStack, j++, stackMap, c, labels);\n                                    }\n                                }\n                            }\n                            frameOffset += delta + 1;\n                            readLabel(frameOffset, labels);\n                            --frameCount;\n                        } else {\n                            frameLocal = null;\n                        }\n                    }\n                    int opcode = b[v] & 0xFF;\n                    switch(ClassWriter.TYPE[opcode]) {\n                        case ClassWriter.NOARG_INSN:\n                            mv.visitInsn(opcode);\n                            v += 1;\n                            break;\n                        case ClassWriter.IMPLVAR_INSN:\n                            if (opcode > Opcodes.ISTORE) {\n                                // ISTORE_0\n                                opcode -= 59;\n                                mv.visitVarInsn(Opcodes.ISTORE + (opcode >> 2), opcode & 0x3);\n                            } else {\n                                // ILOAD_0\n                                opcode -= 26;\n                                mv.visitVarInsn(Opcodes.ILOAD + (opcode >> 2), opcode & 0x3);\n                            }\n                            v += 1;\n                            break;\n                        case ClassWriter.LABEL_INSN:\n                            mv.visitJumpInsn(opcode, labels[w + readShort(v + 1)]);\n                            v += 3;\n                            break;\n                        case ClassWriter.LABELW_INSN:\n                            mv.visitJumpInsn(opcode - 33, labels[w + readInt(v + 1)]);\n                            v += 5;\n                            break;\n                        case ClassWriter.WIDE_INSN:\n                            opcode = b[v + 1] & 0xFF;\n                            if (opcode == Opcodes.IINC) {\n                                mv.visitIincInsn(readUnsignedShort(v + 2), readShort(v + 4));\n                                v += 6;\n                            } else {\n                                mv.visitVarInsn(opcode, readUnsignedShort(v + 2));\n                                v += 4;\n                            }\n                            break;\n                        case ClassWriter.TABL_INSN:\n                            // skips 0 to 3 padding bytes\n                            v = v + 4 - (w & 3);\n                            // reads instruction\n                            label = w + readInt(v);\n                            int min = readInt(v + 4);\n                            int max = readInt(v + 8);\n                            v += 12;\n                            Label[] table = new Label[max - min + 1];\n                            for (j = 0; j < table.length; ++j) {\n                                table[j] = labels[w + readInt(v)];\n                                v += 4;\n                            }\n                            mv.visitTableSwitchInsn(min, max, labels[label], table);\n                            break;\n                        case ClassWriter.LOOK_INSN:\n                            // skips 0 to 3 padding bytes\n                            v = v + 4 - (w & 3);\n                            // reads instruction\n                            label = w + readInt(v);\n                            j = readInt(v + 4);\n                            v += 8;\n                            int[] keys = new int[j];\n                            Label[] values = new Label[j];\n                            for (j = 0; j < keys.length; ++j) {\n                                keys[j] = readInt(v);\n                                values[j] = labels[w + readInt(v + 4)];\n                                v += 8;\n                            }\n                            mv.visitLookupSwitchInsn(labels[label], keys, values);\n                            break;\n                        case ClassWriter.VAR_INSN:\n                            mv.visitVarInsn(opcode, b[v + 1] & 0xFF);\n                            v += 2;\n                            break;\n                        case ClassWriter.SBYTE_INSN:\n                            mv.visitIntInsn(opcode, b[v + 1]);\n                            v += 2;\n                            break;\n                        case ClassWriter.SHORT_INSN:\n                            mv.visitIntInsn(opcode, readShort(v + 1));\n                            v += 3;\n                            break;\n                        case ClassWriter.LDC_INSN:\n                            mv.visitLdcInsn(readConst(b[v + 1] & 0xFF, c));\n                            v += 2;\n                            break;\n                        case ClassWriter.LDCW_INSN:\n                            mv.visitLdcInsn(readConst(readUnsignedShort(v + 1), c));\n                            v += 3;\n                            break;\n                        case ClassWriter.FIELDORMETH_INSN:\n                        case ClassWriter.ITFDYNMETH_INSN:\n                            int cpIndex = items[readUnsignedShort(v + 1)];\n                            String iowner;\n                            // INVOKEDYNAMIC is receiverless\n                            if (opcode == Opcodes.INVOKEDYNAMIC) {\n                                iowner = Opcodes.INVOKEDYNAMIC_OWNER;\n                            } else {\n                                iowner = readClass(cpIndex, c);\n                                cpIndex = items[readUnsignedShort(cpIndex + 2)];\n                            }\n                            String iname = readUTF8(cpIndex, c);\n                            String idesc = readUTF8(cpIndex + 2, c);\n                            if (opcode < Opcodes.INVOKEVIRTUAL) {\n                                mv.visitFieldInsn(opcode, iowner, iname, idesc);\n                            } else {\n                                mv.visitMethodInsn(opcode, iowner, iname, idesc);\n                            }\n                            if (opcode == Opcodes.INVOKEINTERFACE || opcode == Opcodes.INVOKEDYNAMIC) {\n                                v += 5;\n                            } else {\n                                v += 3;\n                            }\n                            break;\n                        case ClassWriter.TYPE_INSN:\n                            mv.visitTypeInsn(opcode, readClass(v + 1, c));\n                            v += 3;\n                            break;\n                        case ClassWriter.IINC_INSN:\n                            mv.visitIincInsn(b[v + 1] & 0xFF, b[v + 2]);\n                            v += 3;\n                            break;\n                        // case MANA_INSN:\n                        default:\n                            mv.visitMultiANewArrayInsn(readClass(v + 1, c), b[v + 3] & 0xFF);\n                            v += 4;\n                            break;\n                    }\n                }\n                l = labels[codeEnd - codeStart];\n                if (l != null) {\n                    mv.visitLabel(l);\n                }\n                // visits the local variable tables\n                if (!skipDebug && varTable != 0) {\n                    int[] typeTable = null;\n                    if (varTypeTable != 0) {\n                        k = readUnsignedShort(varTypeTable) * 3;\n                        w = varTypeTable + 2;\n                        typeTable = new int[k];\n                        while (k > 0) {\n                            // signature\n                            typeTable[--k] = w + 6;\n                            // index\n                            typeTable[--k] = readUnsignedShort(w + 8);\n                            // start\n                            typeTable[--k] = readUnsignedShort(w);\n                            w += 10;\n                        }\n                    }\n                    k = readUnsignedShort(varTable);\n                    w = varTable + 2;\n                    for (; k > 0; --k) {\n                        int start = readUnsignedShort(w);\n                        int length = readUnsignedShort(w + 2);\n                        int index = readUnsignedShort(w + 8);\n                        String vsignature = null;\n                        if (typeTable != null) {\n                            for (int a = 0; a < typeTable.length; a += 3) {\n                                if (typeTable[a] == start && typeTable[a + 1] == index) {\n                                    vsignature = readUTF8(typeTable[a + 2], c);\n                                    break;\n                                }\n                            }\n                        }\n                        mv.visitLocalVariable(readUTF8(w + 4, c), readUTF8(w + 6, c), vsignature, labels[start], labels[start + length], index);\n                        w += 10;\n                    }\n                }\n                // visits the other attributes\n                while (cattrs != null) {\n                    attr = cattrs.next;\n                    cattrs.next = null;\n                    mv.visitAttribute(cattrs);\n                    cattrs = attr;\n                }\n                // visits the max stack and max locals values\n                mv.visitMaxs(maxStack, maxLocals);\n            }\n            if (mv != null) {\n                mv.visitEnd();\n            }\n        }\n        // visits the end of the class\n        classVisitor.visitEnd();\n    }\n\n    /**\n     * Reads parameter annotations and makes the given visitor visit them.\n     *\n     * @param v start offset in {@link #b b} of the annotations to be read.\n     * @param desc the method descriptor.\n     * @param buf buffer to be used to call {@link #readUTF8 readUTF8},\n     *        {@link #readClass(int,char[]) readClass} or\n     *        {@link #readConst readConst}.\n     * @param visible <tt>true</tt> if the annotations to be read are visible\n     *        at runtime.\n     * @param mv the visitor that must visit the annotations.\n     */\n    private void readParameterAnnotations(int v, final String desc, final char[] buf, final boolean visible, final MethodVisitor mv) {\n        int i;\n        int n = b[v++] & 0xFF;\n        // workaround for a bug in javac (javac compiler generates a parameter\n        // annotation array whose size is equal to the number of parameters in\n        // the Java source file, while it should generate an array whose size is\n        // equal to the number of parameters in the method descriptor - which\n        // includes the synthetic parameters added by the compiler). This work-\n        // around supposes that the synthetic parameters are the first ones.\n        int synthetics = Type.getArgumentTypes(desc).length - n;\n        AnnotationVisitor av;\n        for (i = 0; i < synthetics; ++i) {\n            // virtual annotation to detect synthetic parameters in MethodWriter\n            av = mv.visitParameterAnnotation(i, \"Ljava/lang/Synthetic;\", false);\n            if (av != null) {\n                av.visitEnd();\n            }\n        }\n        for (; i < n + synthetics; ++i) {\n            int j = readUnsignedShort(v);\n            v += 2;\n            for (; j > 0; --j) {\n                av = mv.visitParameterAnnotation(i, readUTF8(v, buf), visible);\n                v = readAnnotationValues(v + 2, buf, true, av);\n            }\n        }\n    }\n\n    /**\n     * Reads the values of an annotation and makes the given visitor visit them.\n     *\n     * @param v the start offset in {@link #b b} of the values to be read\n     *        (including the unsigned short that gives the number of values).\n     * @param buf buffer to be used to call {@link #readUTF8 readUTF8},\n     *        {@link #readClass(int,char[]) readClass} or\n     *        {@link #readConst readConst}.\n     * @param named if the annotation values are named or not.\n     * @param av the visitor that must visit the values.\n     * @return the end offset of the annotation values.\n     */\n    private int readAnnotationValues(int v, final char[] buf, final boolean named, final AnnotationVisitor av) {\n        int i = readUnsignedShort(v);\n        v += 2;\n        if (named) {\n            for (; i > 0; --i) {\n                v = readAnnotationValue(v + 2, buf, readUTF8(v, buf), av);\n            }\n        } else {\n            for (; i > 0; --i) {\n                v = readAnnotationValue(v, buf, null, av);\n            }\n        }\n        if (av != null) {\n            av.visitEnd();\n        }\n        return v;\n    }\n\n    /**\n     * Reads a value of an annotation and makes the given visitor visit it.\n     *\n     * @param v the start offset in {@link #b b} of the value to be read (<i>not\n     *        including the value name constant pool index</i>).\n     * @param buf buffer to be used to call {@link #readUTF8 readUTF8},\n     *        {@link #readClass(int,char[]) readClass} or\n     *        {@link #readConst readConst}.\n     * @param name the name of the value to be read.\n     * @param av the visitor that must visit the value.\n     * @return the end offset of the annotation value.\n     */\n    private int readAnnotationValue(int v, final char[] buf, final String name, final AnnotationVisitor av) {\n        int i;\n        if (av == null) {\n            switch(b[v] & 0xFF) {\n                case // enum_const_value\n                'e':\n                    return v + 5;\n                case // annotation_value\n                '@':\n                    return readAnnotationValues(v + 3, buf, true, null);\n                case // array_value\n                '[':\n                    return readAnnotationValues(v + 1, buf, false, null);\n                default:\n                    return v + 3;\n            }\n        }\n        switch(b[v++] & 0xFF) {\n            // pointer to CONSTANT_Integer\n            case 'I':\n            // pointer to CONSTANT_Long\n            case 'J':\n            // pointer to CONSTANT_Float\n            case 'F':\n            case // pointer to CONSTANT_Double\n            'D':\n                av.visit(name, readConst(readUnsignedShort(v), buf));\n                v += 2;\n                break;\n            case // pointer to CONSTANT_Byte\n            'B':\n                av.visit(name, new Byte((byte) readInt(items[readUnsignedShort(v)])));\n                v += 2;\n                break;\n            case // pointer to CONSTANT_Boolean\n            'Z':\n                av.visit(name, readInt(items[readUnsignedShort(v)]) == 0 ? Boolean.FALSE : Boolean.TRUE);\n                v += 2;\n                break;\n            case // pointer to CONSTANT_Short\n            'S':\n                av.visit(name, new Short((short) readInt(items[readUnsignedShort(v)])));\n                v += 2;\n                break;\n            case // pointer to CONSTANT_Char\n            'C':\n                av.visit(name, new Character((char) readInt(items[readUnsignedShort(v)])));\n                v += 2;\n                break;\n            case // pointer to CONSTANT_Utf8\n            's':\n                av.visit(name, readUTF8(v, buf));\n                v += 2;\n                break;\n            case // enum_const_value\n            'e':\n                av.visitEnum(name, readUTF8(v, buf), readUTF8(v + 2, buf));\n                v += 4;\n                break;\n            case // class_info\n            'c':\n                av.visit(name, Type.getType(readUTF8(v, buf)));\n                v += 2;\n                break;\n            case // annotation_value\n            '@':\n                v = readAnnotationValues(v + 2, buf, true, av.visitAnnotation(name, readUTF8(v, buf)));\n                break;\n            case // array_value\n            '[':\n                int size = readUnsignedShort(v);\n                v += 2;\n                if (size == 0) {\n                    return readAnnotationValues(v - 2, buf, false, av.visitArray(name));\n                }\n                switch(this.b[v++] & 0xFF) {\n                    case 'B':\n                        byte[] bv = new byte[size];\n                        for (i = 0; i < size; i++) {\n                            bv[i] = (byte) readInt(items[readUnsignedShort(v)]);\n                            v += 3;\n                        }\n                        av.visit(name, bv);\n                        --v;\n                        break;\n                    case 'Z':\n                        boolean[] zv = new boolean[size];\n                        for (i = 0; i < size; i++) {\n                            zv[i] = readInt(items[readUnsignedShort(v)]) != 0;\n                            v += 3;\n                        }\n                        av.visit(name, zv);\n                        --v;\n                        break;\n                    case 'S':\n                        short[] sv = new short[size];\n                        for (i = 0; i < size; i++) {\n                            sv[i] = (short) readInt(items[readUnsignedShort(v)]);\n                            v += 3;\n                        }\n                        av.visit(name, sv);\n                        --v;\n                        break;\n                    case 'C':\n                        char[] cv = new char[size];\n                        for (i = 0; i < size; i++) {\n                            cv[i] = (char) readInt(items[readUnsignedShort(v)]);\n                            v += 3;\n                        }\n                        av.visit(name, cv);\n                        --v;\n                        break;\n                    case 'I':\n                        int[] iv = new int[size];\n                        for (i = 0; i < size; i++) {\n                            iv[i] = readInt(items[readUnsignedShort(v)]);\n                            v += 3;\n                        }\n                        av.visit(name, iv);\n                        --v;\n                        break;\n                    case 'J':\n                        long[] lv = new long[size];\n                        for (i = 0; i < size; i++) {\n                            lv[i] = readLong(items[readUnsignedShort(v)]);\n                            v += 3;\n                        }\n                        av.visit(name, lv);\n                        --v;\n                        break;\n                    case 'F':\n                        float[] fv = new float[size];\n                        for (i = 0; i < size; i++) {\n                            fv[i] = Float.intBitsToFloat(readInt(items[readUnsignedShort(v)]));\n                            v += 3;\n                        }\n                        av.visit(name, fv);\n                        --v;\n                        break;\n                    case 'D':\n                        double[] dv = new double[size];\n                        for (i = 0; i < size; i++) {\n                            dv[i] = Double.longBitsToDouble(readLong(items[readUnsignedShort(v)]));\n                            v += 3;\n                        }\n                        av.visit(name, dv);\n                        --v;\n                        break;\n                    default:\n                        v = readAnnotationValues(v - 3, buf, false, av.visitArray(name));\n                }\n        }\n        return v;\n    }\n\n    private int readFrameType(final Object[] frame, final int index, int v, final char[] buf, final Label[] labels) {\n        int type = b[v++] & 0xFF;\n        switch(type) {\n            case 0:\n                frame[index] = Opcodes.TOP;\n                break;\n            case 1:\n                frame[index] = Opcodes.INTEGER;\n                break;\n            case 2:\n                frame[index] = Opcodes.FLOAT;\n                break;\n            case 3:\n                frame[index] = Opcodes.DOUBLE;\n                break;\n            case 4:\n                frame[index] = Opcodes.LONG;\n                break;\n            case 5:\n                frame[index] = Opcodes.NULL;\n                break;\n            case 6:\n                frame[index] = Opcodes.UNINITIALIZED_THIS;\n                break;\n            case // Object\n            7:\n                frame[index] = readClass(v, buf);\n                v += 2;\n                break;\n            default:\n                // Uninitialized\n                frame[index] = readLabel(readUnsignedShort(v), labels);\n                v += 2;\n        }\n        return v;\n    }\n\n    /**\n     * Returns the label corresponding to the given offset. The default\n     * implementation of this method creates a label for the given offset if it\n     * has not been already created.\n     *\n     * @param offset a bytecode offset in a method.\n     * @param labels the already created labels, indexed by their offset. If a\n     *        label already exists for offset this method must not create a new\n     *        one. Otherwise it must store the new label in this array.\n     * @return a non null Label, which must be equal to labels[offset].\n     */\n    protected Label readLabel(int offset, Label[] labels) {\n        if (labels[offset] == null) {\n            labels[offset] = new Label();\n        }\n        return labels[offset];\n    }\n\n    /**\n     * Reads an attribute in {@link #b b}.\n     *\n     * @param attrs prototypes of the attributes that must be parsed during the\n     *        visit of the class. Any attribute whose type is not equal to the\n     *        type of one the prototypes is ignored (i.e. an empty\n     *        {@link Attribute} instance is returned).\n     * @param type the type of the attribute.\n     * @param off index of the first byte of the attribute's content in\n     *        {@link #b b}. The 6 attribute header bytes, containing the type\n     *        and the length of the attribute, are not taken into account here\n     *        (they have already been read).\n     * @param len the length of the attribute's content.\n     * @param buf buffer to be used to call {@link #readUTF8 readUTF8},\n     *        {@link #readClass(int,char[]) readClass} or\n     *        {@link #readConst readConst}.\n     * @param codeOff index of the first byte of code's attribute content in\n     *        {@link #b b}, or -1 if the attribute to be read is not a code\n     *        attribute. The 6 attribute header bytes, containing the type and\n     *        the length of the attribute, are not taken into account here.\n     * @param labels the labels of the method's code, or <tt>null</tt> if the\n     *        attribute to be read is not a code attribute.\n     * @return the attribute that has been read, or <tt>null</tt> to skip this\n     *         attribute.\n     */\n    private Attribute readAttribute(final Attribute[] attrs, final String type, final int off, final int len, final char[] buf, final int codeOff, final Label[] labels) {\n        for (int i = 0; i < attrs.length; ++i) {\n            if (attrs[i].type.equals(type)) {\n                return attrs[i].read(this, off, len, buf, codeOff, labels);\n            }\n        }\n        return new Attribute(type).read(this, off, len, null, -1, null);\n    }\n\n    // ------------------------------------------------------------------------\n    // Utility methods: low level parsing\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the start index of the constant pool item in {@link #b b}, plus\n     * one. <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param item the index a constant pool item.\n     * @return the start index of the constant pool item in {@link #b b}, plus\n     *         one.\n     */\n    public int getItem(final int item) {\n        return items[item];\n    }\n\n    /**\n     * Reads a byte value in {@link #b b}. <i>This method is intended for\n     * {@link Attribute} sub classes, and is normally not needed by class\n     * generators or adapters.</i>\n     *\n     * @param index the start index of the value to be read in {@link #b b}.\n     * @return the read value.\n     */\n    public int readByte(final int index) {\n        return b[index] & 0xFF;\n    }\n\n    /**\n     * Reads an unsigned short value in {@link #b b}. <i>This method is\n     * intended for {@link Attribute} sub classes, and is normally not needed by\n     * class generators or adapters.</i>\n     *\n     * @param index the start index of the value to be read in {@link #b b}.\n     * @return the read value.\n     */\n    public int readUnsignedShort(final int index) {\n        byte[] b = this.b;\n        return ((b[index] & 0xFF) << 8) | (b[index + 1] & 0xFF);\n    }\n\n    /**\n     * Reads a signed short value in {@link #b b}. <i>This method is intended\n     * for {@link Attribute} sub classes, and is normally not needed by class\n     * generators or adapters.</i>\n     *\n     * @param index the start index of the value to be read in {@link #b b}.\n     * @return the read value.\n     */\n    public short readShort(final int index) {\n        byte[] b = this.b;\n        return (short) (((b[index] & 0xFF) << 8) | (b[index + 1] & 0xFF));\n    }\n\n    /**\n     * Reads a signed int value in {@link #b b}. <i>This method is intended for\n     * {@link Attribute} sub classes, and is normally not needed by class\n     * generators or adapters.</i>\n     *\n     * @param index the start index of the value to be read in {@link #b b}.\n     * @return the read value.\n     */\n    public int readInt(final int index) {\n        byte[] b = this.b;\n        return ((b[index] & 0xFF) << 24) | ((b[index + 1] & 0xFF) << 16) | ((b[index + 2] & 0xFF) << 8) | (b[index + 3] & 0xFF);\n    }\n\n    /**\n     * Reads a signed long value in {@link #b b}. <i>This method is intended\n     * for {@link Attribute} sub classes, and is normally not needed by class\n     * generators or adapters.</i>\n     *\n     * @param index the start index of the value to be read in {@link #b b}.\n     * @return the read value.\n     */\n    public long readLong(final int index) {\n        long l1 = readInt(index);\n        long l0 = readInt(index + 4) & 0xFFFFFFFFL;\n        return (l1 << 32) | l0;\n    }\n\n    /**\n     * Reads an UTF8 string constant pool item in {@link #b b}. <i>This method\n     * is intended for {@link Attribute} sub classes, and is normally not needed\n     * by class generators or adapters.</i>\n     *\n     * @param index the start index of an unsigned short value in {@link #b b},\n     *        whose value is the index of an UTF8 constant pool item.\n     * @param buf buffer to be used to read the item. This buffer must be\n     *        sufficiently large. It is not automatically resized.\n     * @return the String corresponding to the specified UTF8 item.\n     */\n    public String readUTF8(int index, final char[] buf) {\n        int item = readUnsignedShort(index);\n        String s = strings[item];\n        if (s != null) {\n            return s;\n        }\n        index = items[item];\n        return strings[item] = readUTF(index + 2, readUnsignedShort(index), buf);\n    }\n\n    /**\n     * Reads UTF8 string in {@link #b b}.\n     *\n     * @param index start offset of the UTF8 string to be read.\n     * @param utfLen length of the UTF8 string to be read.\n     * @param buf buffer to be used to read the string. This buffer must be\n     *        sufficiently large. It is not automatically resized.\n     * @return the String corresponding to the specified UTF8 string.\n     */\n    private String readUTF(int index, final int utfLen, final char[] buf) {\n        int endIndex = index + utfLen;\n        byte[] b = this.b;\n        int strLen = 0;\n        int c;\n        int st = 0;\n        char cc = 0;\n        while (index < endIndex) {\n            c = b[index++];\n            switch(st) {\n                case 0:\n                    c = c & 0xFF;\n                    if (c < 0x80) {\n                        // 0xxxxxxx\n                        buf[strLen++] = (char) c;\n                    } else if (c < 0xE0 && c > 0xBF) {\n                        // 110x xxxx 10xx xxxx\n                        cc = (char) (c & 0x1F);\n                        st = 1;\n                    } else {\n                        // 1110 xxxx 10xx xxxx 10xx xxxx\n                        cc = (char) (c & 0x0F);\n                        st = 2;\n                    }\n                    break;\n                case // byte 2 of 2-byte char or byte 3 of 3-byte char\n                1:\n                    buf[strLen++] = (char) ((cc << 6) | (c & 0x3F));\n                    st = 0;\n                    break;\n                case // byte 2 of 3-byte char\n                2:\n                    cc = (char) ((cc << 6) | (c & 0x3F));\n                    st = 1;\n                    break;\n            }\n        }\n        return new String(buf, 0, strLen);\n    }\n\n    /**\n     * Reads a class constant pool item in {@link #b b}. <i>This method is\n     * intended for {@link Attribute} sub classes, and is normally not needed by\n     * class generators or adapters.</i>\n     *\n     * @param index the start index of an unsigned short value in {@link #b b},\n     *        whose value is the index of a class constant pool item.\n     * @param buf buffer to be used to read the item. This buffer must be\n     *        sufficiently large. It is not automatically resized.\n     * @return the String corresponding to the specified class item.\n     */\n    public String readClass(final int index, final char[] buf) {\n        // computes the start index of the CONSTANT_Class item in b\n        // and reads the CONSTANT_Utf8 item designated by\n        // the first two bytes of this CONSTANT_Class item\n        return readUTF8(items[readUnsignedShort(index)], buf);\n    }\n\n    /**\n     * Reads a numeric or string constant pool item in {@link #b b}. <i>This\n     * method is intended for {@link Attribute} sub classes, and is normally not\n     * needed by class generators or adapters.</i>\n     *\n     * @param item the index of a constant pool item.\n     * @param buf buffer to be used to read the item. This buffer must be\n     *        sufficiently large. It is not automatically resized.\n     * @return the {@link Integer}, {@link Float}, {@link Long},\n     *         {@link Double}, {@link String} or {@link Type} corresponding to\n     *         the given constant pool item.\n     */\n    public Object readConst(final int item, final char[] buf) {\n        int index = items[item];\n        switch(b[index - 1]) {\n            case ClassWriter.INT:\n                return new Integer(readInt(index));\n            case ClassWriter.FLOAT:\n                return new Float(Float.intBitsToFloat(readInt(index)));\n            case ClassWriter.LONG:\n                return new Long(readLong(index));\n            case ClassWriter.DOUBLE:\n                return new Double(Double.longBitsToDouble(readLong(index)));\n            case ClassWriter.CLASS:\n                return Type.getObjectType(readUTF8(index, buf));\n            // case ClassWriter.STR:\n            default:\n                return readUTF8(index, buf);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/ClassReaderTest1.java",
		"test_prompt": "// ClassReaderTest1.java\npackage org.objectweb.asm.jip;\n\nimport java.io.InputStream;\nimport java.io.IOException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassReader}.\n* It contains ten unit test cases for the {@link ClassReader#readUnsignedShort(int)} method.\n*/\nclass ClassReaderTest1 {"
	},
	{
		"original_code": "// ClassReader.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\nimport java.io.InputStream;\nimport java.io.IOException;\n\n/**\n * A Java class parser to make a {@link ClassVisitor} visit an existing class.\n * This class parses a byte array conforming to the Java class file format and\n * calls the appropriate visit methods of a given class visitor for each field,\n * method and bytecode instruction encountered.\n *\n * @author Eric Bruneton\n * @author Eugene Kuleshov\n */\npublic class ClassReader {\n\n    /**\n     * True to enable signatures support.\n     */\n    static final boolean SIGNATURES = true;\n\n    /**\n     * True to enable annotations support.\n     */\n    static final boolean ANNOTATIONS = true;\n\n    /**\n     * True to enable stack map frames support.\n     */\n    static final boolean FRAMES = true;\n\n    /**\n     * True to enable bytecode writing support.\n     */\n    static final boolean WRITER = true;\n\n    /**\n     * True to enable JSR_W and GOTO_W support.\n     */\n    static final boolean RESIZE = true;\n\n    /**\n     * Flag to skip method code. If this class is set <code>CODE</code>\n     * attribute won't be visited. This can be used, for example, to retrieve\n     * annotations for methods and method parameters.\n     */\n    public static final int SKIP_CODE = 1;\n\n    /**\n     * Flag to skip the debug information in the class. If this flag is set the\n     * debug information of the class is not visited, i.e. the\n     * {@link MethodVisitor#visitLocalVariable visitLocalVariable} and\n     * {@link MethodVisitor#visitLineNumber visitLineNumber} methods will not be\n     * called.\n     */\n    public static final int SKIP_DEBUG = 2;\n\n    /**\n     * Flag to skip the stack map frames in the class. If this flag is set the\n     * stack map frames of the class is not visited, i.e. the\n     * {@link MethodVisitor#visitFrame visitFrame} method will not be called.\n     * This flag is useful when the {@link ClassWriter#COMPUTE_FRAMES} option is\n     * used: it avoids visiting frames that will be ignored and recomputed from\n     * scratch in the class writer.\n     */\n    public static final int SKIP_FRAMES = 4;\n\n    /**\n     * Flag to expand the stack map frames. By default stack map frames are\n     * visited in their original format (i.e. \"expanded\" for classes whose\n     * version is less than V1_6, and \"compressed\" for the other classes). If\n     * this flag is set, stack map frames are always visited in expanded format\n     * (this option adds a decompression/recompression step in ClassReader and\n     * ClassWriter which degrades performances quite a lot).\n     */\n    public static final int EXPAND_FRAMES = 8;\n\n    /**\n     * The class to be parsed. <i>The content of this array must not be\n     * modified. This field is intended for {@link Attribute} sub classes, and\n     * is normally not needed by class generators or adapters.</i>\n     */\n    public final byte[] b;\n\n    /**\n     * The start index of each constant pool item in {@link #b b}, plus one.\n     * The one byte offset skips the constant pool item tag that indicates its\n     * type.\n     */\n    private final int[] items;\n\n    /**\n     * The String objects corresponding to the CONSTANT_Utf8 items. This cache\n     * avoids multiple parsing of a given CONSTANT_Utf8 constant pool item,\n     * which GREATLY improves performances (by a factor 2 to 3). This caching\n     * strategy could be extended to all constant pool items, but its benefit\n     * would not be so great for these items (because they are much less\n     * expensive to parse than CONSTANT_Utf8 items).\n     */\n    private final String[] strings;\n\n    /**\n     * Maximum length of the strings contained in the constant pool of the\n     * class.\n     */\n    private final int maxStringLength;\n\n    /**\n     * Start index of the class header information (access, name...) in\n     * {@link #b b}.\n     */\n    public final int header;\n\n    // ------------------------------------------------------------------------\n    // Constructors\n    // ------------------------------------------------------------------------\n    /**\n     * Constructs a new {@link ClassReader} object.\n     *\n     * @param b the bytecode of the class to be read.\n     */\n    public ClassReader(final byte[] b) {\n        this(b, 0, b.length);\n    }\n\n    /**\n     * Constructs a new {@link ClassReader} object.\n     *\n     * @param b the bytecode of the class to be read.\n     * @param off the start offset of the class data.\n     * @param len the length of the class data.\n     */\n    public ClassReader(final byte[] b, final int off, final int len) {\n        this.b = b;\n        // parses the constant pool\n        items = new int[readUnsignedShort(off + 8)];\n        int n = items.length;\n        strings = new String[n];\n        int max = 0;\n        int index = off + 10;\n        for (int i = 1; i < n; ++i) {\n            items[i] = index + 1;\n            int size;\n            switch(b[index]) {\n                case ClassWriter.FIELD:\n                case ClassWriter.METH:\n                case ClassWriter.IMETH:\n                case ClassWriter.INT:\n                case ClassWriter.FLOAT:\n                case ClassWriter.NAME_TYPE:\n                    size = 5;\n                    break;\n                case ClassWriter.LONG:\n                case ClassWriter.DOUBLE:\n                    size = 9;\n                    ++i;\n                    break;\n                case ClassWriter.UTF8:\n                    size = 3 + readUnsignedShort(index + 1);\n                    if (size > max) {\n                        max = size;\n                    }\n                    break;\n                // case ClassWriter.CLASS:\n                // case ClassWriter.STR:\n                default:\n                    size = 3;\n                    break;\n            }\n            index += size;\n        }\n        maxStringLength = max;\n        // the class header information starts just after the constant pool\n        header = index;\n    }\n\n    /**\n     * Returns the class's access flags (see {@link Opcodes}). This value may\n     * not reflect Deprecated and Synthetic flags when bytecode is before 1.5\n     * and those flags are represented by attributes.\n     *\n     * @return the class access flags\n     *\n     * @see ClassVisitor#visit(int, int, String, String, String, String[])\n     */\n    public int getAccess() {\n        return readUnsignedShort(header);\n    }\n\n    /**\n     * Returns the internal name of the class (see\n     * {@link Type#getInternalName() getInternalName}).\n     *\n     * @return the internal class name\n     *\n     * @see ClassVisitor#visit(int, int, String, String, String, String[])\n     */\n    public String getClassName() {\n        return readClass(header + 2, new char[maxStringLength]);\n    }\n\n    /**\n     * Returns the internal of name of the super class (see\n     * {@link Type#getInternalName() getInternalName}). For interfaces, the\n     * super class is {@link Object}.\n     *\n     * @return the internal name of super class, or <tt>null</tt> for\n     *         {@link Object} class.\n     *\n     * @see ClassVisitor#visit(int, int, String, String, String, String[])\n     */\n    public String getSuperName() {\n        int n = items[readUnsignedShort(header + 4)];\n        return n == 0 ? null : readUTF8(n, new char[maxStringLength]);\n    }\n\n    /**\n     * Returns the internal names of the class's interfaces (see\n     * {@link Type#getInternalName() getInternalName}).\n     *\n     * @return the array of internal names for all implemented interfaces or\n     *         <tt>null</tt>.\n     *\n     * @see ClassVisitor#visit(int, int, String, String, String, String[])\n     */\n    public String[] getInterfaces() {\n        int index = header + 6;\n        int n = readUnsignedShort(index);\n        String[] interfaces = new String[n];\n        if (n > 0) {\n            char[] buf = new char[maxStringLength];\n            for (int i = 0; i < n; ++i) {\n                index += 2;\n                interfaces[i] = readClass(index, buf);\n            }\n        }\n        return interfaces;\n    }\n\n    /**\n     * Copies the constant pool data into the given {@link ClassWriter}. Should\n     * be called before the {@link #accept(ClassVisitor,int)} method.\n     *\n     * @param classWriter the {@link ClassWriter} to copy constant pool into.\n     */\n    void copyPool(final ClassWriter classWriter) {\n        char[] buf = new char[maxStringLength];\n        int ll = items.length;\n        Item[] items2 = new Item[ll];\n        for (int i = 1; i < ll; i++) {\n            int index = items[i];\n            int tag = b[index - 1];\n            Item item = new Item(i);\n            int nameType;\n            switch(tag) {\n                case ClassWriter.FIELD:\n                case ClassWriter.METH:\n                case ClassWriter.IMETH:\n                    nameType = items[readUnsignedShort(index + 2)];\n                    item.set(tag, readClass(index, buf), readUTF8(nameType, buf), readUTF8(nameType + 2, buf));\n                    break;\n                case ClassWriter.INT:\n                    item.set(readInt(index));\n                    break;\n                case ClassWriter.FLOAT:\n                    item.set(Float.intBitsToFloat(readInt(index)));\n                    break;\n                case ClassWriter.NAME_TYPE:\n                    item.set(tag, readUTF8(index, buf), readUTF8(index + 2, buf), null);\n                    break;\n                case ClassWriter.LONG:\n                    item.set(readLong(index));\n                    ++i;\n                    break;\n                case ClassWriter.DOUBLE:\n                    item.set(Double.longBitsToDouble(readLong(index)));\n                    ++i;\n                    break;\n                case ClassWriter.UTF8:\n                    {\n                        String s = strings[i];\n                        if (s == null) {\n                            index = items[i];\n                            s = strings[i] = readUTF(index + 2, readUnsignedShort(index), buf);\n                        }\n                        item.set(tag, s, null, null);\n                    }\n                    break;\n                // case ClassWriter.STR:\n                // case ClassWriter.CLASS:\n                default:\n                    item.set(tag, readUTF8(index, buf), null, null);\n                    break;\n            }\n            int index2 = item.hashCode % items2.length;\n            item.next = items2[index2];\n            items2[index2] = item;\n        }\n        int off = items[1] - 1;\n        classWriter.pool.putByteArray(b, off, header - off);\n        classWriter.items = items2;\n        classWriter.threshold = (int) (0.75d * ll);\n        classWriter.index = ll;\n    }\n\n    /**\n     * Constructs a new {@link ClassReader} object.\n     *\n     * @param is an input stream from which to read the class.\n     * @throws IOException if a problem occurs during reading.\n     */\n    public ClassReader(final InputStream is) throws IOException {\n        this(readClass(is));\n    }\n\n    /**\n     * Constructs a new {@link ClassReader} object.\n     *\n     * @param name the fully qualified name of the class to be read.\n     * @throws IOException if an exception occurs during reading.\n     */\n    public ClassReader(final String name) throws IOException {\n        this(ClassLoader.getSystemResourceAsStream(name.replace('.', '/') + \".class\"));\n    }\n\n    /**\n     * Reads the bytecode of a class.\n     *\n     * @param is an input stream from which to read the class.\n     * @return the bytecode read from the given input stream.\n     * @throws IOException if a problem occurs during reading.\n     */\n    private static byte[] readClass(final InputStream is) throws IOException {\n        if (is == null) {\n            throw new IOException(\"Class not found\");\n        }\n        byte[] b = new byte[is.available()];\n        int len = 0;\n        while (true) {\n            int n = is.read(b, len, b.length - len);\n            if (n == -1) {\n                if (len < b.length) {\n                    byte[] c = new byte[len];\n                    System.arraycopy(b, 0, c, 0, len);\n                    b = c;\n                }\n                return b;\n            }\n            len += n;\n            if (len == b.length) {\n                int last = is.read();\n                if (last < 0) {\n                    return b;\n                }\n                byte[] c = new byte[b.length + 1000];\n                System.arraycopy(b, 0, c, 0, len);\n                c[len++] = (byte) last;\n                b = c;\n            }\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Public methods\n    // ------------------------------------------------------------------------\n    /**\n     * Makes the given visitor visit the Java class of this {@link ClassReader}.\n     * This class is the one specified in the constructor (see\n     * {@link #ClassReader(byte[]) ClassReader}).\n     *\n     * @param classVisitor the visitor that must visit this class.\n     * @param flags option flags that can be used to modify the default behavior\n     *        of this class. See {@link #SKIP_DEBUG}, {@link #EXPAND_FRAMES},\n     *        {@link #SKIP_FRAMES}, {@link #SKIP_CODE}.\n     */\n    public void accept(final ClassVisitor classVisitor, final int flags) {\n        accept(classVisitor, new Attribute[0], flags);\n    }\n\n    /**\n     * Makes the given visitor visit the Java class of this {@link ClassReader}.\n     * This class is the one specified in the constructor (see\n     * {@link #ClassReader(byte[]) ClassReader}).\n     *\n     * @param classVisitor the visitor that must visit this class.\n     * @param attrs prototypes of the attributes that must be parsed during the\n     *        visit of the class. Any attribute whose type is not equal to the\n     *        type of one the prototypes will not be parsed: its byte array\n     *        value will be passed unchanged to the ClassWriter. <i>This may\n     *        corrupt it if this value contains references to the constant pool,\n     *        or has syntactic or semantic links with a class element that has\n     *        been transformed by a class adapter between the reader and the\n     *        writer</i>.\n     * @param flags option flags that can be used to modify the default behavior\n     *        of this class. See {@link #SKIP_DEBUG}, {@link #EXPAND_FRAMES},\n     *        {@link #SKIP_FRAMES}, {@link #SKIP_CODE}.\n     */\n    public void accept(final ClassVisitor classVisitor, final Attribute[] attrs, final int flags) {\n        // the bytecode array\n        byte[] b = this.b;\n        // buffer used to read strings\n        char[] c = new char[maxStringLength];\n        // loop variables\n        int i, j, k;\n        // indexes in b\n        int u, v, w;\n        Attribute attr;\n        int access;\n        String name;\n        String desc;\n        String attrName;\n        String signature;\n        int anns = 0;\n        int ianns = 0;\n        Attribute cattrs = null;\n        // visits the header\n        u = header;\n        access = readUnsignedShort(u);\n        name = readClass(u + 2, c);\n        v = items[readUnsignedShort(u + 4)];\n        String superClassName = v == 0 ? null : readUTF8(v, c);\n        String[] implementedItfs = new String[readUnsignedShort(u + 6)];\n        w = 0;\n        u += 8;\n        for (i = 0; i < implementedItfs.length; ++i) {\n            implementedItfs[i] = readClass(u, c);\n            u += 2;\n        }\n        boolean skipCode = (flags & SKIP_CODE) != 0;\n        boolean skipDebug = (flags & SKIP_DEBUG) != 0;\n        boolean unzip = (flags & EXPAND_FRAMES) != 0;\n        // skips fields and methods\n        v = u;\n        i = readUnsignedShort(v);\n        v += 2;\n        for (; i > 0; --i) {\n            j = readUnsignedShort(v + 6);\n            v += 8;\n            for (; j > 0; --j) {\n                v += 6 + readInt(v + 2);\n            }\n        }\n        i = readUnsignedShort(v);\n        v += 2;\n        for (; i > 0; --i) {\n            j = readUnsignedShort(v + 6);\n            v += 8;\n            for (; j > 0; --j) {\n                v += 6 + readInt(v + 2);\n            }\n        }\n        // reads the class's attributes\n        signature = null;\n        String sourceFile = null;\n        String sourceDebug = null;\n        String enclosingOwner = null;\n        String enclosingName = null;\n        String enclosingDesc = null;\n        i = readUnsignedShort(v);\n        v += 2;\n        for (; i > 0; --i) {\n            attrName = readUTF8(v, c);\n            // tests are sorted in decreasing frequency order\n            // (based on frequencies observed on typical classes)\n            if (\"SourceFile\".equals(attrName)) {\n                sourceFile = readUTF8(v + 6, c);\n            } else if (\"InnerClasses\".equals(attrName)) {\n                w = v + 6;\n            } else if (\"EnclosingMethod\".equals(attrName)) {\n                enclosingOwner = readClass(v + 6, c);\n                int item = readUnsignedShort(v + 8);\n                if (item != 0) {\n                    enclosingName = readUTF8(items[item], c);\n                    enclosingDesc = readUTF8(items[item] + 2, c);\n                }\n            } else if (SIGNATURES && \"Signature\".equals(attrName)) {\n                signature = readUTF8(v + 6, c);\n            } else if (ANNOTATIONS && \"RuntimeVisibleAnnotations\".equals(attrName)) {\n                anns = v + 6;\n            } else if (\"Deprecated\".equals(attrName)) {\n                access |= Opcodes.ACC_DEPRECATED;\n            } else if (\"Synthetic\".equals(attrName)) {\n                access |= Opcodes.ACC_SYNTHETIC;\n            } else if (\"SourceDebugExtension\".equals(attrName)) {\n                int len = readInt(v + 2);\n                sourceDebug = readUTF(v + 6, len, new char[len]);\n            } else if (ANNOTATIONS && \"RuntimeInvisibleAnnotations\".equals(attrName)) {\n                ianns = v + 6;\n            } else {\n                attr = readAttribute(attrs, attrName, v + 6, readInt(v + 2), c, -1, null);\n                if (attr != null) {\n                    attr.next = cattrs;\n                    cattrs = attr;\n                }\n            }\n            v += 6 + readInt(v + 2);\n        }\n        // calls the visit method\n        classVisitor.visit(readInt(4), access, name, signature, superClassName, implementedItfs);\n        // calls the visitSource method\n        if (!skipDebug && (sourceFile != null || sourceDebug != null)) {\n            classVisitor.visitSource(sourceFile, sourceDebug);\n        }\n        // calls the visitOuterClass method\n        if (enclosingOwner != null) {\n            classVisitor.visitOuterClass(enclosingOwner, enclosingName, enclosingDesc);\n        }\n        // visits the class annotations\n        if (ANNOTATIONS) {\n            for (i = 1; i >= 0; --i) {\n                v = i == 0 ? ianns : anns;\n                if (v != 0) {\n                    j = readUnsignedShort(v);\n                    v += 2;\n                    for (; j > 0; --j) {\n                        v = readAnnotationValues(v + 2, c, true, classVisitor.visitAnnotation(readUTF8(v, c), i != 0));\n                    }\n                }\n            }\n        }\n        // visits the class attributes\n        while (cattrs != null) {\n            attr = cattrs.next;\n            cattrs.next = null;\n            classVisitor.visitAttribute(cattrs);\n            cattrs = attr;\n        }\n        // calls the visitInnerClass method\n        if (w != 0) {\n            i = readUnsignedShort(w);\n            w += 2;\n            for (; i > 0; --i) {\n                classVisitor.visitInnerClass(readUnsignedShort(w) == 0 ? null : readClass(w, c), readUnsignedShort(w + 2) == 0 ? null : readClass(w + 2, c), readUnsignedShort(w + 4) == 0 ? null : readUTF8(w + 4, c), readUnsignedShort(w + 6));\n                w += 8;\n            }\n        }\n        // visits the fields\n        i = readUnsignedShort(u);\n        u += 2;\n        for (; i > 0; --i) {\n            access = readUnsignedShort(u);\n            name = readUTF8(u + 2, c);\n            desc = readUTF8(u + 4, c);\n            // visits the field's attributes and looks for a ConstantValue\n            // attribute\n            int fieldValueItem = 0;\n            signature = null;\n            anns = 0;\n            ianns = 0;\n            cattrs = null;\n            j = readUnsignedShort(u + 6);\n            u += 8;\n            for (; j > 0; --j) {\n                attrName = readUTF8(u, c);\n                // tests are sorted in decreasing frequency order\n                // (based on frequencies observed on typical classes)\n                if (\"ConstantValue\".equals(attrName)) {\n                    fieldValueItem = readUnsignedShort(u + 6);\n                } else if (SIGNATURES && \"Signature\".equals(attrName)) {\n                    signature = readUTF8(u + 6, c);\n                } else if (\"Deprecated\".equals(attrName)) {\n                    access |= Opcodes.ACC_DEPRECATED;\n                } else if (\"Synthetic\".equals(attrName)) {\n                    access |= Opcodes.ACC_SYNTHETIC;\n                } else if (ANNOTATIONS && \"RuntimeVisibleAnnotations\".equals(attrName)) {\n                    anns = u + 6;\n                } else if (ANNOTATIONS && \"RuntimeInvisibleAnnotations\".equals(attrName)) {\n                    ianns = u + 6;\n                } else {\n                    attr = readAttribute(attrs, attrName, u + 6, readInt(u + 2), c, -1, null);\n                    if (attr != null) {\n                        attr.next = cattrs;\n                        cattrs = attr;\n                    }\n                }\n                u += 6 + readInt(u + 2);\n            }\n            // visits the field\n            FieldVisitor fv = classVisitor.visitField(access, name, desc, signature, fieldValueItem == 0 ? null : readConst(fieldValueItem, c));\n            // visits the field annotations and attributes\n            if (fv != null) {\n                if (ANNOTATIONS) {\n                    for (j = 1; j >= 0; --j) {\n                        v = j == 0 ? ianns : anns;\n                        if (v != 0) {\n                            k = readUnsignedShort(v);\n                            v += 2;\n                            for (; k > 0; --k) {\n                                v = readAnnotationValues(v + 2, c, true, fv.visitAnnotation(readUTF8(v, c), j != 0));\n                            }\n                        }\n                    }\n                }\n                while (cattrs != null) {\n                    attr = cattrs.next;\n                    cattrs.next = null;\n                    fv.visitAttribute(cattrs);\n                    cattrs = attr;\n                }\n                fv.visitEnd();\n            }\n        }\n        // visits the methods\n        i = readUnsignedShort(u);\n        u += 2;\n        for (; i > 0; --i) {\n            int u0 = u + 6;\n            access = readUnsignedShort(u);\n            name = readUTF8(u + 2, c);\n            desc = readUTF8(u + 4, c);\n            signature = null;\n            anns = 0;\n            ianns = 0;\n            int dann = 0;\n            int mpanns = 0;\n            int impanns = 0;\n            cattrs = null;\n            v = 0;\n            w = 0;\n            // looks for Code and Exceptions attributes\n            j = readUnsignedShort(u + 6);\n            u += 8;\n            for (; j > 0; --j) {\n                attrName = readUTF8(u, c);\n                int attrSize = readInt(u + 2);\n                u += 6;\n                // tests are sorted in decreasing frequency order\n                // (based on frequencies observed on typical classes)\n                if (\"Code\".equals(attrName)) {\n                    if (!skipCode) {\n                        v = u;\n                    }\n                } else if (\"Exceptions\".equals(attrName)) {\n                    w = u;\n                } else if (SIGNATURES && \"Signature\".equals(attrName)) {\n                    signature = readUTF8(u, c);\n                } else if (\"Deprecated\".equals(attrName)) {\n                    access |= Opcodes.ACC_DEPRECATED;\n                } else if (ANNOTATIONS && \"RuntimeVisibleAnnotations\".equals(attrName)) {\n                    anns = u;\n                } else if (ANNOTATIONS && \"AnnotationDefault\".equals(attrName)) {\n                    dann = u;\n                } else if (\"Synthetic\".equals(attrName)) {\n                    access |= Opcodes.ACC_SYNTHETIC;\n                } else if (ANNOTATIONS && \"RuntimeInvisibleAnnotations\".equals(attrName)) {\n                    ianns = u;\n                } else if (ANNOTATIONS && \"RuntimeVisibleParameterAnnotations\".equals(attrName)) {\n                    mpanns = u;\n                } else if (ANNOTATIONS && \"RuntimeInvisibleParameterAnnotations\".equals(attrName)) {\n                    impanns = u;\n                } else {\n                    attr = readAttribute(attrs, attrName, u, attrSize, c, -1, null);\n                    if (attr != null) {\n                        attr.next = cattrs;\n                        cattrs = attr;\n                    }\n                }\n                u += attrSize;\n            }\n            // reads declared exceptions\n            String[] exceptions;\n            if (w == 0) {\n                exceptions = null;\n            } else {\n                exceptions = new String[readUnsignedShort(w)];\n                w += 2;\n                for (j = 0; j < exceptions.length; ++j) {\n                    exceptions[j] = readClass(w, c);\n                    w += 2;\n                }\n            }\n            // visits the method's code, if any\n            MethodVisitor mv = classVisitor.visitMethod(access, name, desc, signature, exceptions);\n            if (mv != null) {\n                /*\n                 * if the returned MethodVisitor is in fact a MethodWriter, it\n                 * means there is no method adapter between the reader and the\n                 * writer. If, in addition, the writer's constant pool was\n                 * copied from this reader (mw.cw.cr == this), and the signature\n                 * and exceptions of the method have not been changed, then it\n                 * is possible to skip all visit events and just copy the\n                 * original code of the method to the writer (the access, name\n                 * and descriptor can have been changed, this is not important\n                 * since they are not copied as is from the reader).\n                 */\n                if (WRITER && mv instanceof MethodWriter) {\n                    MethodWriter mw = (MethodWriter) mv;\n                    if (mw.cw.cr == this) {\n                        if (signature == mw.signature) {\n                            boolean sameExceptions = false;\n                            if (exceptions == null) {\n                                sameExceptions = mw.exceptionCount == 0;\n                            } else {\n                                if (exceptions.length == mw.exceptionCount) {\n                                    sameExceptions = true;\n                                    for (j = exceptions.length - 1; j >= 0; --j) {\n                                        w -= 2;\n                                        if (mw.exceptions[j] != readUnsignedShort(w)) {\n                                            sameExceptions = false;\n                                            break;\n                                        }\n                                    }\n                                }\n                            }\n                            if (sameExceptions) {\n                                /*\n                                 * we do not copy directly the code into\n                                 * MethodWriter to save a byte array copy\n                                 * operation. The real copy will be done in\n                                 * ClassWriter.toByteArray().\n                                 */\n                                mw.classReaderOffset = u0;\n                                mw.classReaderLength = u - u0;\n                                continue;\n                            }\n                        }\n                    }\n                }\n                if (ANNOTATIONS && dann != 0) {\n                    AnnotationVisitor dv = mv.visitAnnotationDefault();\n                    readAnnotationValue(dann, c, null, dv);\n                    if (dv != null) {\n                        dv.visitEnd();\n                    }\n                }\n                if (ANNOTATIONS) {\n                    for (j = 1; j >= 0; --j) {\n                        w = j == 0 ? ianns : anns;\n                        if (w != 0) {\n                            k = readUnsignedShort(w);\n                            w += 2;\n                            for (; k > 0; --k) {\n                                w = readAnnotationValues(w + 2, c, true, mv.visitAnnotation(readUTF8(w, c), j != 0));\n                            }\n                        }\n                    }\n                }\n                if (ANNOTATIONS && mpanns != 0) {\n                    readParameterAnnotations(mpanns, desc, c, true, mv);\n                }\n                if (ANNOTATIONS && impanns != 0) {\n                    readParameterAnnotations(impanns, desc, c, false, mv);\n                }\n                while (cattrs != null) {\n                    attr = cattrs.next;\n                    cattrs.next = null;\n                    mv.visitAttribute(cattrs);\n                    cattrs = attr;\n                }\n            }\n            if (mv != null && v != 0) {\n                int maxStack = readUnsignedShort(v);\n                int maxLocals = readUnsignedShort(v + 2);\n                int codeLength = readInt(v + 4);\n                v += 8;\n                int codeStart = v;\n                int codeEnd = v + codeLength;\n                mv.visitCode();\n                // 1st phase: finds the labels\n                int label;\n                Label[] labels = new Label[codeLength + 2];\n                readLabel(codeLength + 1, labels);\n                while (v < codeEnd) {\n                    w = v - codeStart;\n                    int opcode = b[v] & 0xFF;\n                    switch(ClassWriter.TYPE[opcode]) {\n                        case ClassWriter.NOARG_INSN:\n                        case ClassWriter.IMPLVAR_INSN:\n                            v += 1;\n                            break;\n                        case ClassWriter.LABEL_INSN:\n                            readLabel(w + readShort(v + 1), labels);\n                            v += 3;\n                            break;\n                        case ClassWriter.LABELW_INSN:\n                            readLabel(w + readInt(v + 1), labels);\n                            v += 5;\n                            break;\n                        case ClassWriter.WIDE_INSN:\n                            opcode = b[v + 1] & 0xFF;\n                            if (opcode == Opcodes.IINC) {\n                                v += 6;\n                            } else {\n                                v += 4;\n                            }\n                            break;\n                        case ClassWriter.TABL_INSN:\n                            // skips 0 to 3 padding bytes*\n                            v = v + 4 - (w & 3);\n                            // reads instruction\n                            readLabel(w + readInt(v), labels);\n                            j = readInt(v + 8) - readInt(v + 4) + 1;\n                            v += 12;\n                            for (; j > 0; --j) {\n                                readLabel(w + readInt(v), labels);\n                                v += 4;\n                            }\n                            break;\n                        case ClassWriter.LOOK_INSN:\n                            // skips 0 to 3 padding bytes*\n                            v = v + 4 - (w & 3);\n                            // reads instruction\n                            readLabel(w + readInt(v), labels);\n                            j = readInt(v + 4);\n                            v += 8;\n                            for (; j > 0; --j) {\n                                readLabel(w + readInt(v + 4), labels);\n                                v += 8;\n                            }\n                            break;\n                        case ClassWriter.VAR_INSN:\n                        case ClassWriter.SBYTE_INSN:\n                        case ClassWriter.LDC_INSN:\n                            v += 2;\n                            break;\n                        case ClassWriter.SHORT_INSN:\n                        case ClassWriter.LDCW_INSN:\n                        case ClassWriter.FIELDORMETH_INSN:\n                        case ClassWriter.TYPE_INSN:\n                        case ClassWriter.IINC_INSN:\n                            v += 3;\n                            break;\n                        case ClassWriter.ITFDYNMETH_INSN:\n                            v += 5;\n                            break;\n                        // case MANA_INSN:\n                        default:\n                            v += 4;\n                            break;\n                    }\n                }\n                // parses the try catch entries\n                j = readUnsignedShort(v);\n                v += 2;\n                for (; j > 0; --j) {\n                    Label start = readLabel(readUnsignedShort(v), labels);\n                    Label end = readLabel(readUnsignedShort(v + 2), labels);\n                    Label handler = readLabel(readUnsignedShort(v + 4), labels);\n                    int type = readUnsignedShort(v + 6);\n                    if (type == 0) {\n                        mv.visitTryCatchBlock(start, end, handler, null);\n                    } else {\n                        mv.visitTryCatchBlock(start, end, handler, readUTF8(items[type], c));\n                    }\n                    v += 8;\n                }\n                // parses the local variable, line number tables, and code\n                // attributes\n                int varTable = 0;\n                int varTypeTable = 0;\n                int stackMap = 0;\n                int stackMapSize = 0;\n                int frameCount = 0;\n                int frameMode = 0;\n                int frameOffset = 0;\n                int frameLocalCount = 0;\n                int frameLocalDiff = 0;\n                int frameStackCount = 0;\n                Object[] frameLocal = null;\n                Object[] frameStack = null;\n                boolean zip = true;\n                cattrs = null;\n                j = readUnsignedShort(v);\n                v += 2;\n                for (; j > 0; --j) {\n                    attrName = readUTF8(v, c);\n                    if (\"LocalVariableTable\".equals(attrName)) {\n                        if (!skipDebug) {\n                            varTable = v + 6;\n                            k = readUnsignedShort(v + 6);\n                            w = v + 8;\n                            for (; k > 0; --k) {\n                                label = readUnsignedShort(w);\n                                if (labels[label] == null) {\n                                    readLabel(label, labels).status |= Label.DEBUG;\n                                }\n                                label += readUnsignedShort(w + 2);\n                                if (labels[label] == null) {\n                                    readLabel(label, labels).status |= Label.DEBUG;\n                                }\n                                w += 10;\n                            }\n                        }\n                    } else if (\"LocalVariableTypeTable\".equals(attrName)) {\n                        varTypeTable = v + 6;\n                    } else if (\"LineNumberTable\".equals(attrName)) {\n                        if (!skipDebug) {\n                            k = readUnsignedShort(v + 6);\n                            w = v + 8;\n                            for (; k > 0; --k) {\n                                label = readUnsignedShort(w);\n                                if (labels[label] == null) {\n                                    readLabel(label, labels).status |= Label.DEBUG;\n                                }\n                                labels[label].line = readUnsignedShort(w + 2);\n                                w += 4;\n                            }\n                        }\n                    } else if (FRAMES && \"StackMapTable\".equals(attrName)) {\n                        if ((flags & SKIP_FRAMES) == 0) {\n                            stackMap = v + 8;\n                            stackMapSize = readInt(v + 2);\n                            frameCount = readUnsignedShort(v + 6);\n                        }\n                        /*\n                         * here we do not extract the labels corresponding to\n                         * the attribute content. This would require a full\n                         * parsing of the attribute, which would need to be\n                         * repeated in the second phase (see below). Instead the\n                         * content of the attribute is read one frame at a time\n                         * (i.e. after a frame has been visited, the next frame\n                         * is read), and the labels it contains are also\n                         * extracted one frame at a time. Thanks to the ordering\n                         * of frames, having only a \"one frame lookahead\" is not\n                         * a problem, i.e. it is not possible to see an offset\n                         * smaller than the offset of the current insn and for\n                         * which no Label exist.\n                         */\n                        /*\n                         * This is not true for UNINITIALIZED type offsets. We\n                         * solve this by parsing the stack map table without a\n                         * full decoding (see below).\n                         */\n                    } else if (FRAMES && \"StackMap\".equals(attrName)) {\n                        if ((flags & SKIP_FRAMES) == 0) {\n                            stackMap = v + 8;\n                            stackMapSize = readInt(v + 2);\n                            frameCount = readUnsignedShort(v + 6);\n                            zip = false;\n                        }\n                        /*\n                         * IMPORTANT! here we assume that the frames are\n                         * ordered, as in the StackMapTable attribute, although\n                         * this is not guaranteed by the attribute format.\n                         */\n                    } else {\n                        for (k = 0; k < attrs.length; ++k) {\n                            if (attrs[k].type.equals(attrName)) {\n                                attr = attrs[k].read(this, v + 6, readInt(v + 2), c, codeStart - 8, labels);\n                                if (attr != null) {\n                                    attr.next = cattrs;\n                                    cattrs = attr;\n                                }\n                            }\n                        }\n                    }\n                    v += 6 + readInt(v + 2);\n                }\n                // 2nd phase: visits each instruction\n                if (FRAMES && stackMap != 0) {\n                    // creates the very first (implicit) frame from the method\n                    // descriptor\n                    frameLocal = new Object[maxLocals];\n                    frameStack = new Object[maxStack];\n                    if (unzip) {\n                        int local = 0;\n                        if ((access & Opcodes.ACC_STATIC) == 0) {\n                            if (\"<init>\".equals(name)) {\n                                frameLocal[local++] = Opcodes.UNINITIALIZED_THIS;\n                            } else {\n                                frameLocal[local++] = readClass(header + 2, c);\n                            }\n                        }\n                        j = 1;\n                        loop: while (true) {\n                            k = j;\n                            switch(desc.charAt(j++)) {\n                                case 'Z':\n                                case 'C':\n                                case 'B':\n                                case 'S':\n                                case 'I':\n                                    frameLocal[local++] = Opcodes.INTEGER;\n                                    break;\n                                case 'F':\n                                    frameLocal[local++] = Opcodes.FLOAT;\n                                    break;\n                                case 'J':\n                                    frameLocal[local++] = Opcodes.LONG;\n                                    break;\n                                case 'D':\n                                    frameLocal[local++] = Opcodes.DOUBLE;\n                                    break;\n                                case '[':\n                                    while (desc.charAt(j) == '[') {\n                                        ++j;\n                                    }\n                                    if (desc.charAt(j) == 'L') {\n                                        ++j;\n                                        while (desc.charAt(j) != ';') {\n                                            ++j;\n                                        }\n                                    }\n                                    frameLocal[local++] = desc.substring(k, ++j);\n                                    break;\n                                case 'L':\n                                    while (desc.charAt(j) != ';') {\n                                        ++j;\n                                    }\n                                    frameLocal[local++] = desc.substring(k + 1, j++);\n                                    break;\n                                default:\n                                    break loop;\n                            }\n                        }\n                        frameLocalCount = local;\n                    }\n                    /*\n                     * for the first explicit frame the offset is not\n                     * offset_delta + 1 but only offset_delta; setting the\n                     * implicit frame offset to -1 allow the use of the\n                     * \"offset_delta + 1\" rule in all cases\n                     */\n                    frameOffset = -1;\n                    /*\n                     * Finds labels for UNINITIALIZED frame types. Instead of\n                     * decoding each element of the stack map table, we look\n                     * for 3 consecutive bytes that \"look like\" an UNINITIALIZED\n                     * type (tag 8, offset within code bounds, NEW instruction\n                     * at this offset). We may find false positives (i.e. not \n                     * real UNINITIALIZED types), but this should be rare, and \n                     * the only consequence will be the creation of an unneeded \n                     * label. This is better than creating a label for each NEW\n                     * instruction, and faster than fully decoding the whole \n                     * stack map table.\n                     */\n                    for (j = stackMap; j < stackMap + stackMapSize - 2; ++j) {\n                        if (b[j] == 8) {\n                            // UNINITIALIZED FRAME TYPE\n                            k = readUnsignedShort(j + 1);\n                            if (k >= 0 && k < codeLength) {\n                                // potential offset\n                                if ((b[codeStart + k] & 0xFF) == Opcodes.NEW) {\n                                    // NEW at this offset\n                                    readLabel(k, labels);\n                                }\n                            }\n                        }\n                    }\n                }\n                v = codeStart;\n                Label l;\n                while (v < codeEnd) {\n                    w = v - codeStart;\n                    l = labels[w];\n                    if (l != null) {\n                        mv.visitLabel(l);\n                        if (!skipDebug && l.line > 0) {\n                            mv.visitLineNumber(l.line, l);\n                        }\n                    }\n                    while (FRAMES && frameLocal != null && (frameOffset == w || frameOffset == -1)) {\n                        // if there is a frame for this offset,\n                        // makes the visitor visit it,\n                        // and reads the next frame if there is one.\n                        if (!zip || unzip) {\n                            mv.visitFrame(Opcodes.F_NEW, frameLocalCount, frameLocal, frameStackCount, frameStack);\n                        } else if (frameOffset != -1) {\n                            mv.visitFrame(frameMode, frameLocalDiff, frameLocal, frameStackCount, frameStack);\n                        }\n                        if (frameCount > 0) {\n                            int tag, delta, n;\n                            if (zip) {\n                                tag = b[stackMap++] & 0xFF;\n                            } else {\n                                tag = MethodWriter.FULL_FRAME;\n                                frameOffset = -1;\n                            }\n                            frameLocalDiff = 0;\n                            if (tag < MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME) {\n                                delta = tag;\n                                frameMode = Opcodes.F_SAME;\n                                frameStackCount = 0;\n                            } else if (tag < MethodWriter.RESERVED) {\n                                delta = tag - MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME;\n                                stackMap = readFrameType(frameStack, 0, stackMap, c, labels);\n                                frameMode = Opcodes.F_SAME1;\n                                frameStackCount = 1;\n                            } else {\n                                delta = readUnsignedShort(stackMap);\n                                stackMap += 2;\n                                if (tag == MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {\n                                    stackMap = readFrameType(frameStack, 0, stackMap, c, labels);\n                                    frameMode = Opcodes.F_SAME1;\n                                    frameStackCount = 1;\n                                } else if (tag >= MethodWriter.CHOP_FRAME && tag < MethodWriter.SAME_FRAME_EXTENDED) {\n                                    frameMode = Opcodes.F_CHOP;\n                                    frameLocalDiff = MethodWriter.SAME_FRAME_EXTENDED - tag;\n                                    frameLocalCount -= frameLocalDiff;\n                                    frameStackCount = 0;\n                                } else if (tag == MethodWriter.SAME_FRAME_EXTENDED) {\n                                    frameMode = Opcodes.F_SAME;\n                                    frameStackCount = 0;\n                                } else if (tag < MethodWriter.FULL_FRAME) {\n                                    j = unzip ? frameLocalCount : 0;\n                                    for (k = tag - MethodWriter.SAME_FRAME_EXTENDED; k > 0; k--) {\n                                        stackMap = readFrameType(frameLocal, j++, stackMap, c, labels);\n                                    }\n                                    frameMode = Opcodes.F_APPEND;\n                                    frameLocalDiff = tag - MethodWriter.SAME_FRAME_EXTENDED;\n                                    frameLocalCount += frameLocalDiff;\n                                    frameStackCount = 0;\n                                } else {\n                                    // if (tag == FULL_FRAME) {\n                                    frameMode = Opcodes.F_FULL;\n                                    n = frameLocalDiff = frameLocalCount = readUnsignedShort(stackMap);\n                                    stackMap += 2;\n                                    for (j = 0; n > 0; n--) {\n                                        stackMap = readFrameType(frameLocal, j++, stackMap, c, labels);\n                                    }\n                                    n = frameStackCount = readUnsignedShort(stackMap);\n                                    stackMap += 2;\n                                    for (j = 0; n > 0; n--) {\n                                        stackMap = readFrameType(frameStack, j++, stackMap, c, labels);\n                                    }\n                                }\n                            }\n                            frameOffset += delta + 1;\n                            readLabel(frameOffset, labels);\n                            --frameCount;\n                        } else {\n                            frameLocal = null;\n                        }\n                    }\n                    int opcode = b[v] & 0xFF;\n                    switch(ClassWriter.TYPE[opcode]) {\n                        case ClassWriter.NOARG_INSN:\n                            mv.visitInsn(opcode);\n                            v += 1;\n                            break;\n                        case ClassWriter.IMPLVAR_INSN:\n                            if (opcode > Opcodes.ISTORE) {\n                                // ISTORE_0\n                                opcode -= 59;\n                                mv.visitVarInsn(Opcodes.ISTORE + (opcode >> 2), opcode & 0x3);\n                            } else {\n                                // ILOAD_0\n                                opcode -= 26;\n                                mv.visitVarInsn(Opcodes.ILOAD + (opcode >> 2), opcode & 0x3);\n                            }\n                            v += 1;\n                            break;\n                        case ClassWriter.LABEL_INSN:\n                            mv.visitJumpInsn(opcode, labels[w + readShort(v + 1)]);\n                            v += 3;\n                            break;\n                        case ClassWriter.LABELW_INSN:\n                            mv.visitJumpInsn(opcode - 33, labels[w + readInt(v + 1)]);\n                            v += 5;\n                            break;\n                        case ClassWriter.WIDE_INSN:\n                            opcode = b[v + 1] & 0xFF;\n                            if (opcode == Opcodes.IINC) {\n                                mv.visitIincInsn(readUnsignedShort(v + 2), readShort(v + 4));\n                                v += 6;\n                            } else {\n                                mv.visitVarInsn(opcode, readUnsignedShort(v + 2));\n                                v += 4;\n                            }\n                            break;\n                        case ClassWriter.TABL_INSN:\n                            // skips 0 to 3 padding bytes\n                            v = v + 4 - (w & 3);\n                            // reads instruction\n                            label = w + readInt(v);\n                            int min = readInt(v + 4);\n                            int max = readInt(v + 8);\n                            v += 12;\n                            Label[] table = new Label[max - min + 1];\n                            for (j = 0; j < table.length; ++j) {\n                                table[j] = labels[w + readInt(v)];\n                                v += 4;\n                            }\n                            mv.visitTableSwitchInsn(min, max, labels[label], table);\n                            break;\n                        case ClassWriter.LOOK_INSN:\n                            // skips 0 to 3 padding bytes\n                            v = v + 4 - (w & 3);\n                            // reads instruction\n                            label = w + readInt(v);\n                            j = readInt(v + 4);\n                            v += 8;\n                            int[] keys = new int[j];\n                            Label[] values = new Label[j];\n                            for (j = 0; j < keys.length; ++j) {\n                                keys[j] = readInt(v);\n                                values[j] = labels[w + readInt(v + 4)];\n                                v += 8;\n                            }\n                            mv.visitLookupSwitchInsn(labels[label], keys, values);\n                            break;\n                        case ClassWriter.VAR_INSN:\n                            mv.visitVarInsn(opcode, b[v + 1] & 0xFF);\n                            v += 2;\n                            break;\n                        case ClassWriter.SBYTE_INSN:\n                            mv.visitIntInsn(opcode, b[v + 1]);\n                            v += 2;\n                            break;\n                        case ClassWriter.SHORT_INSN:\n                            mv.visitIntInsn(opcode, readShort(v + 1));\n                            v += 3;\n                            break;\n                        case ClassWriter.LDC_INSN:\n                            mv.visitLdcInsn(readConst(b[v + 1] & 0xFF, c));\n                            v += 2;\n                            break;\n                        case ClassWriter.LDCW_INSN:\n                            mv.visitLdcInsn(readConst(readUnsignedShort(v + 1), c));\n                            v += 3;\n                            break;\n                        case ClassWriter.FIELDORMETH_INSN:\n                        case ClassWriter.ITFDYNMETH_INSN:\n                            int cpIndex = items[readUnsignedShort(v + 1)];\n                            String iowner;\n                            // INVOKEDYNAMIC is receiverless\n                            if (opcode == Opcodes.INVOKEDYNAMIC) {\n                                iowner = Opcodes.INVOKEDYNAMIC_OWNER;\n                            } else {\n                                iowner = readClass(cpIndex, c);\n                                cpIndex = items[readUnsignedShort(cpIndex + 2)];\n                            }\n                            String iname = readUTF8(cpIndex, c);\n                            String idesc = readUTF8(cpIndex + 2, c);\n                            if (opcode < Opcodes.INVOKEVIRTUAL) {\n                                mv.visitFieldInsn(opcode, iowner, iname, idesc);\n                            } else {\n                                mv.visitMethodInsn(opcode, iowner, iname, idesc);\n                            }\n                            if (opcode == Opcodes.INVOKEINTERFACE || opcode == Opcodes.INVOKEDYNAMIC) {\n                                v += 5;\n                            } else {\n                                v += 3;\n                            }\n                            break;\n                        case ClassWriter.TYPE_INSN:\n                            mv.visitTypeInsn(opcode, readClass(v + 1, c));\n                            v += 3;\n                            break;\n                        case ClassWriter.IINC_INSN:\n                            mv.visitIincInsn(b[v + 1] & 0xFF, b[v + 2]);\n                            v += 3;\n                            break;\n                        // case MANA_INSN:\n                        default:\n                            mv.visitMultiANewArrayInsn(readClass(v + 1, c), b[v + 3] & 0xFF);\n                            v += 4;\n                            break;\n                    }\n                }\n                l = labels[codeEnd - codeStart];\n                if (l != null) {\n                    mv.visitLabel(l);\n                }\n                // visits the local variable tables\n                if (!skipDebug && varTable != 0) {\n                    int[] typeTable = null;\n                    if (varTypeTable != 0) {\n                        k = readUnsignedShort(varTypeTable) * 3;\n                        w = varTypeTable + 2;\n                        typeTable = new int[k];\n                        while (k > 0) {\n                            // signature\n                            typeTable[--k] = w + 6;\n                            // index\n                            typeTable[--k] = readUnsignedShort(w + 8);\n                            // start\n                            typeTable[--k] = readUnsignedShort(w);\n                            w += 10;\n                        }\n                    }\n                    k = readUnsignedShort(varTable);\n                    w = varTable + 2;\n                    for (; k > 0; --k) {\n                        int start = readUnsignedShort(w);\n                        int length = readUnsignedShort(w + 2);\n                        int index = readUnsignedShort(w + 8);\n                        String vsignature = null;\n                        if (typeTable != null) {\n                            for (int a = 0; a < typeTable.length; a += 3) {\n                                if (typeTable[a] == start && typeTable[a + 1] == index) {\n                                    vsignature = readUTF8(typeTable[a + 2], c);\n                                    break;\n                                }\n                            }\n                        }\n                        mv.visitLocalVariable(readUTF8(w + 4, c), readUTF8(w + 6, c), vsignature, labels[start], labels[start + length], index);\n                        w += 10;\n                    }\n                }\n                // visits the other attributes\n                while (cattrs != null) {\n                    attr = cattrs.next;\n                    cattrs.next = null;\n                    mv.visitAttribute(cattrs);\n                    cattrs = attr;\n                }\n                // visits the max stack and max locals values\n                mv.visitMaxs(maxStack, maxLocals);\n            }\n            if (mv != null) {\n                mv.visitEnd();\n            }\n        }\n        // visits the end of the class\n        classVisitor.visitEnd();\n    }\n\n    /**\n     * Reads parameter annotations and makes the given visitor visit them.\n     *\n     * @param v start offset in {@link #b b} of the annotations to be read.\n     * @param desc the method descriptor.\n     * @param buf buffer to be used to call {@link #readUTF8 readUTF8},\n     *        {@link #readClass(int,char[]) readClass} or\n     *        {@link #readConst readConst}.\n     * @param visible <tt>true</tt> if the annotations to be read are visible\n     *        at runtime.\n     * @param mv the visitor that must visit the annotations.\n     */\n    private void readParameterAnnotations(int v, final String desc, final char[] buf, final boolean visible, final MethodVisitor mv) {\n        int i;\n        int n = b[v++] & 0xFF;\n        // workaround for a bug in javac (javac compiler generates a parameter\n        // annotation array whose size is equal to the number of parameters in\n        // the Java source file, while it should generate an array whose size is\n        // equal to the number of parameters in the method descriptor - which\n        // includes the synthetic parameters added by the compiler). This work-\n        // around supposes that the synthetic parameters are the first ones.\n        int synthetics = Type.getArgumentTypes(desc).length - n;\n        AnnotationVisitor av;\n        for (i = 0; i < synthetics; ++i) {\n            // virtual annotation to detect synthetic parameters in MethodWriter\n            av = mv.visitParameterAnnotation(i, \"Ljava/lang/Synthetic;\", false);\n            if (av != null) {\n                av.visitEnd();\n            }\n        }\n        for (; i < n + synthetics; ++i) {\n            int j = readUnsignedShort(v);\n            v += 2;\n            for (; j > 0; --j) {\n                av = mv.visitParameterAnnotation(i, readUTF8(v, buf), visible);\n                v = readAnnotationValues(v + 2, buf, true, av);\n            }\n        }\n    }\n\n    /**\n     * Reads the values of an annotation and makes the given visitor visit them.\n     *\n     * @param v the start offset in {@link #b b} of the values to be read\n     *        (including the unsigned short that gives the number of values).\n     * @param buf buffer to be used to call {@link #readUTF8 readUTF8},\n     *        {@link #readClass(int,char[]) readClass} or\n     *        {@link #readConst readConst}.\n     * @param named if the annotation values are named or not.\n     * @param av the visitor that must visit the values.\n     * @return the end offset of the annotation values.\n     */\n    private int readAnnotationValues(int v, final char[] buf, final boolean named, final AnnotationVisitor av) {\n        int i = readUnsignedShort(v);\n        v += 2;\n        if (named) {\n            for (; i > 0; --i) {\n                v = readAnnotationValue(v + 2, buf, readUTF8(v, buf), av);\n            }\n        } else {\n            for (; i > 0; --i) {\n                v = readAnnotationValue(v, buf, null, av);\n            }\n        }\n        if (av != null) {\n            av.visitEnd();\n        }\n        return v;\n    }\n\n    /**\n     * Reads a value of an annotation and makes the given visitor visit it.\n     *\n     * @param v the start offset in {@link #b b} of the value to be read (<i>not\n     *        including the value name constant pool index</i>).\n     * @param buf buffer to be used to call {@link #readUTF8 readUTF8},\n     *        {@link #readClass(int,char[]) readClass} or\n     *        {@link #readConst readConst}.\n     * @param name the name of the value to be read.\n     * @param av the visitor that must visit the value.\n     * @return the end offset of the annotation value.\n     */\n    private int readAnnotationValue(int v, final char[] buf, final String name, final AnnotationVisitor av) {\n        int i;\n        if (av == null) {\n            switch(b[v] & 0xFF) {\n                case // enum_const_value\n                'e':\n                    return v + 5;\n                case // annotation_value\n                '@':\n                    return readAnnotationValues(v + 3, buf, true, null);\n                case // array_value\n                '[':\n                    return readAnnotationValues(v + 1, buf, false, null);\n                default:\n                    return v + 3;\n            }\n        }\n        switch(b[v++] & 0xFF) {\n            // pointer to CONSTANT_Integer\n            case 'I':\n            // pointer to CONSTANT_Long\n            case 'J':\n            // pointer to CONSTANT_Float\n            case 'F':\n            case // pointer to CONSTANT_Double\n            'D':\n                av.visit(name, readConst(readUnsignedShort(v), buf));\n                v += 2;\n                break;\n            case // pointer to CONSTANT_Byte\n            'B':\n                av.visit(name, new Byte((byte) readInt(items[readUnsignedShort(v)])));\n                v += 2;\n                break;\n            case // pointer to CONSTANT_Boolean\n            'Z':\n                av.visit(name, readInt(items[readUnsignedShort(v)]) == 0 ? Boolean.FALSE : Boolean.TRUE);\n                v += 2;\n                break;\n            case // pointer to CONSTANT_Short\n            'S':\n                av.visit(name, new Short((short) readInt(items[readUnsignedShort(v)])));\n                v += 2;\n                break;\n            case // pointer to CONSTANT_Char\n            'C':\n                av.visit(name, new Character((char) readInt(items[readUnsignedShort(v)])));\n                v += 2;\n                break;\n            case // pointer to CONSTANT_Utf8\n            's':\n                av.visit(name, readUTF8(v, buf));\n                v += 2;\n                break;\n            case // enum_const_value\n            'e':\n                av.visitEnum(name, readUTF8(v, buf), readUTF8(v + 2, buf));\n                v += 4;\n                break;\n            case // class_info\n            'c':\n                av.visit(name, Type.getType(readUTF8(v, buf)));\n                v += 2;\n                break;\n            case // annotation_value\n            '@':\n                v = readAnnotationValues(v + 2, buf, true, av.visitAnnotation(name, readUTF8(v, buf)));\n                break;\n            case // array_value\n            '[':\n                int size = readUnsignedShort(v);\n                v += 2;\n                if (size == 0) {\n                    return readAnnotationValues(v - 2, buf, false, av.visitArray(name));\n                }\n                switch(this.b[v++] & 0xFF) {\n                    case 'B':\n                        byte[] bv = new byte[size];\n                        for (i = 0; i < size; i++) {\n                            bv[i] = (byte) readInt(items[readUnsignedShort(v)]);\n                            v += 3;\n                        }\n                        av.visit(name, bv);\n                        --v;\n                        break;\n                    case 'Z':\n                        boolean[] zv = new boolean[size];\n                        for (i = 0; i < size; i++) {\n                            zv[i] = readInt(items[readUnsignedShort(v)]) != 0;\n                            v += 3;\n                        }\n                        av.visit(name, zv);\n                        --v;\n                        break;\n                    case 'S':\n                        short[] sv = new short[size];\n                        for (i = 0; i < size; i++) {\n                            sv[i] = (short) readInt(items[readUnsignedShort(v)]);\n                            v += 3;\n                        }\n                        av.visit(name, sv);\n                        --v;\n                        break;\n                    case 'C':\n                        char[] cv = new char[size];\n                        for (i = 0; i < size; i++) {\n                            cv[i] = (char) readInt(items[readUnsignedShort(v)]);\n                            v += 3;\n                        }\n                        av.visit(name, cv);\n                        --v;\n                        break;\n                    case 'I':\n                        int[] iv = new int[size];\n                        for (i = 0; i < size; i++) {\n                            iv[i] = readInt(items[readUnsignedShort(v)]);\n                            v += 3;\n                        }\n                        av.visit(name, iv);\n                        --v;\n                        break;\n                    case 'J':\n                        long[] lv = new long[size];\n                        for (i = 0; i < size; i++) {\n                            lv[i] = readLong(items[readUnsignedShort(v)]);\n                            v += 3;\n                        }\n                        av.visit(name, lv);\n                        --v;\n                        break;\n                    case 'F':\n                        float[] fv = new float[size];\n                        for (i = 0; i < size; i++) {\n                            fv[i] = Float.intBitsToFloat(readInt(items[readUnsignedShort(v)]));\n                            v += 3;\n                        }\n                        av.visit(name, fv);\n                        --v;\n                        break;\n                    case 'D':\n                        double[] dv = new double[size];\n                        for (i = 0; i < size; i++) {\n                            dv[i] = Double.longBitsToDouble(readLong(items[readUnsignedShort(v)]));\n                            v += 3;\n                        }\n                        av.visit(name, dv);\n                        --v;\n                        break;\n                    default:\n                        v = readAnnotationValues(v - 3, buf, false, av.visitArray(name));\n                }\n        }\n        return v;\n    }\n\n    private int readFrameType(final Object[] frame, final int index, int v, final char[] buf, final Label[] labels) {\n        int type = b[v++] & 0xFF;\n        switch(type) {\n            case 0:\n                frame[index] = Opcodes.TOP;\n                break;\n            case 1:\n                frame[index] = Opcodes.INTEGER;\n                break;\n            case 2:\n                frame[index] = Opcodes.FLOAT;\n                break;\n            case 3:\n                frame[index] = Opcodes.DOUBLE;\n                break;\n            case 4:\n                frame[index] = Opcodes.LONG;\n                break;\n            case 5:\n                frame[index] = Opcodes.NULL;\n                break;\n            case 6:\n                frame[index] = Opcodes.UNINITIALIZED_THIS;\n                break;\n            case // Object\n            7:\n                frame[index] = readClass(v, buf);\n                v += 2;\n                break;\n            default:\n                // Uninitialized\n                frame[index] = readLabel(readUnsignedShort(v), labels);\n                v += 2;\n        }\n        return v;\n    }\n\n    /**\n     * Returns the label corresponding to the given offset. The default\n     * implementation of this method creates a label for the given offset if it\n     * has not been already created.\n     *\n     * @param offset a bytecode offset in a method.\n     * @param labels the already created labels, indexed by their offset. If a\n     *        label already exists for offset this method must not create a new\n     *        one. Otherwise it must store the new label in this array.\n     * @return a non null Label, which must be equal to labels[offset].\n     */\n    protected Label readLabel(int offset, Label[] labels) {\n        if (labels[offset] == null) {\n            labels[offset] = new Label();\n        }\n        return labels[offset];\n    }\n\n    /**\n     * Reads an attribute in {@link #b b}.\n     *\n     * @param attrs prototypes of the attributes that must be parsed during the\n     *        visit of the class. Any attribute whose type is not equal to the\n     *        type of one the prototypes is ignored (i.e. an empty\n     *        {@link Attribute} instance is returned).\n     * @param type the type of the attribute.\n     * @param off index of the first byte of the attribute's content in\n     *        {@link #b b}. The 6 attribute header bytes, containing the type\n     *        and the length of the attribute, are not taken into account here\n     *        (they have already been read).\n     * @param len the length of the attribute's content.\n     * @param buf buffer to be used to call {@link #readUTF8 readUTF8},\n     *        {@link #readClass(int,char[]) readClass} or\n     *        {@link #readConst readConst}.\n     * @param codeOff index of the first byte of code's attribute content in\n     *        {@link #b b}, or -1 if the attribute to be read is not a code\n     *        attribute. The 6 attribute header bytes, containing the type and\n     *        the length of the attribute, are not taken into account here.\n     * @param labels the labels of the method's code, or <tt>null</tt> if the\n     *        attribute to be read is not a code attribute.\n     * @return the attribute that has been read, or <tt>null</tt> to skip this\n     *         attribute.\n     */\n    private Attribute readAttribute(final Attribute[] attrs, final String type, final int off, final int len, final char[] buf, final int codeOff, final Label[] labels) {\n        for (int i = 0; i < attrs.length; ++i) {\n            if (attrs[i].type.equals(type)) {\n                return attrs[i].read(this, off, len, buf, codeOff, labels);\n            }\n        }\n        return new Attribute(type).read(this, off, len, null, -1, null);\n    }\n\n    // ------------------------------------------------------------------------\n    // Utility methods: low level parsing\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the start index of the constant pool item in {@link #b b}, plus\n     * one. <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param item the index a constant pool item.\n     * @return the start index of the constant pool item in {@link #b b}, plus\n     *         one.\n     */\n    public int getItem(final int item) {\n        return items[item];\n    }\n\n    /**\n     * Reads a byte value in {@link #b b}. <i>This method is intended for\n     * {@link Attribute} sub classes, and is normally not needed by class\n     * generators or adapters.</i>\n     *\n     * @param index the start index of the value to be read in {@link #b b}.\n     * @return the read value.\n     */\n    public int readByte(final int index) {\n        return b[index] & 0xFF;\n    }\n\n    /**\n     * Reads an unsigned short value in {@link #b b}. <i>This method is\n     * intended for {@link Attribute} sub classes, and is normally not needed by\n     * class generators or adapters.</i>\n     *\n     * @param index the start index of the value to be read in {@link #b b}.\n     * @return the read value.\n     */\n    public int readUnsignedShort(final int index) {\n        byte[] b = this.b;\n        return ((b[index] & 0xFF) << 8) | (b[index + 1] & 0xFF);\n    }\n\n    /**\n     * Reads a signed short value in {@link #b b}. <i>This method is intended\n     * for {@link Attribute} sub classes, and is normally not needed by class\n     * generators or adapters.</i>\n     *\n     * @param index the start index of the value to be read in {@link #b b}.\n     * @return the read value.\n     */\n    public short readShort(final int index) {\n        byte[] b = this.b;\n        return (short) (((b[index] & 0xFF) << 8) | (b[index + 1] & 0xFF));\n    }\n\n    /**\n     * Reads a signed int value in {@link #b b}. <i>This method is intended for\n     * {@link Attribute} sub classes, and is normally not needed by class\n     * generators or adapters.</i>\n     *\n     * @param index the start index of the value to be read in {@link #b b}.\n     * @return the read value.\n     */\n    public int readInt(final int index) {\n        byte[] b = this.b;\n        return ((b[index] & 0xFF) << 24) | ((b[index + 1] & 0xFF) << 16) | ((b[index + 2] & 0xFF) << 8) | (b[index + 3] & 0xFF);\n    }\n\n    /**\n     * Reads a signed long value in {@link #b b}. <i>This method is intended\n     * for {@link Attribute} sub classes, and is normally not needed by class\n     * generators or adapters.</i>\n     *\n     * @param index the start index of the value to be read in {@link #b b}.\n     * @return the read value.\n     */\n    public long readLong(final int index) {\n        long l1 = readInt(index);\n        long l0 = readInt(index + 4) & 0xFFFFFFFFL;\n        return (l1 << 32) | l0;\n    }\n\n    /**\n     * Reads an UTF8 string constant pool item in {@link #b b}. <i>This method\n     * is intended for {@link Attribute} sub classes, and is normally not needed\n     * by class generators or adapters.</i>\n     *\n     * @param index the start index of an unsigned short value in {@link #b b},\n     *        whose value is the index of an UTF8 constant pool item.\n     * @param buf buffer to be used to read the item. This buffer must be\n     *        sufficiently large. It is not automatically resized.\n     * @return the String corresponding to the specified UTF8 item.\n     */\n    public String readUTF8(int index, final char[] buf) {\n        int item = readUnsignedShort(index);\n        String s = strings[item];\n        if (s != null) {\n            return s;\n        }\n        index = items[item];\n        return strings[item] = readUTF(index + 2, readUnsignedShort(index), buf);\n    }\n\n    /**\n     * Reads UTF8 string in {@link #b b}.\n     *\n     * @param index start offset of the UTF8 string to be read.\n     * @param utfLen length of the UTF8 string to be read.\n     * @param buf buffer to be used to read the string. This buffer must be\n     *        sufficiently large. It is not automatically resized.\n     * @return the String corresponding to the specified UTF8 string.\n     */\n    private String readUTF(int index, final int utfLen, final char[] buf) {\n        int endIndex = index + utfLen;\n        byte[] b = this.b;\n        int strLen = 0;\n        int c;\n        int st = 0;\n        char cc = 0;\n        while (index < endIndex) {\n            c = b[index++];\n            switch(st) {\n                case 0:\n                    c = c & 0xFF;\n                    if (c < 0x80) {\n                        // 0xxxxxxx\n                        buf[strLen++] = (char) c;\n                    } else if (c < 0xE0 && c > 0xBF) {\n                        // 110x xxxx 10xx xxxx\n                        cc = (char) (c & 0x1F);\n                        st = 1;\n                    } else {\n                        // 1110 xxxx 10xx xxxx 10xx xxxx\n                        cc = (char) (c & 0x0F);\n                        st = 2;\n                    }\n                    break;\n                case // byte 2 of 2-byte char or byte 3 of 3-byte char\n                1:\n                    buf[strLen++] = (char) ((cc << 6) | (c & 0x3F));\n                    st = 0;\n                    break;\n                case // byte 2 of 3-byte char\n                2:\n                    cc = (char) ((cc << 6) | (c & 0x3F));\n                    st = 1;\n                    break;\n            }\n        }\n        return new String(buf, 0, strLen);\n    }\n\n    /**\n     * Reads a class constant pool item in {@link #b b}. <i>This method is\n     * intended for {@link Attribute} sub classes, and is normally not needed by\n     * class generators or adapters.</i>\n     *\n     * @param index the start index of an unsigned short value in {@link #b b},\n     *        whose value is the index of a class constant pool item.\n     * @param buf buffer to be used to read the item. This buffer must be\n     *        sufficiently large. It is not automatically resized.\n     * @return the String corresponding to the specified class item.\n     */\n    public String readClass(final int index, final char[] buf) {\n        // computes the start index of the CONSTANT_Class item in b\n        // and reads the CONSTANT_Utf8 item designated by\n        // the first two bytes of this CONSTANT_Class item\n        return readUTF8(items[readUnsignedShort(index)], buf);\n    }\n\n    /**\n     * Reads a numeric or string constant pool item in {@link #b b}. <i>This\n     * method is intended for {@link Attribute} sub classes, and is normally not\n     * needed by class generators or adapters.</i>\n     *\n     * @param item the index of a constant pool item.\n     * @param buf buffer to be used to read the item. This buffer must be\n     *        sufficiently large. It is not automatically resized.\n     * @return the {@link Integer}, {@link Float}, {@link Long},\n     *         {@link Double}, {@link String} or {@link Type} corresponding to\n     *         the given constant pool item.\n     */\n    public Object readConst(final int item, final char[] buf) {\n        int index = items[item];\n        switch(b[index - 1]) {\n            case ClassWriter.INT:\n                return new Integer(readInt(index));\n            case ClassWriter.FLOAT:\n                return new Float(Float.intBitsToFloat(readInt(index)));\n            case ClassWriter.LONG:\n                return new Long(readLong(index));\n            case ClassWriter.DOUBLE:\n                return new Double(Double.longBitsToDouble(readLong(index)));\n            case ClassWriter.CLASS:\n                return Type.getObjectType(readUTF8(index, buf));\n            // case ClassWriter.STR:\n            default:\n                return readUTF8(index, buf);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/ClassReaderTest2.java",
		"test_prompt": "// ClassReaderTest2.java\npackage org.objectweb.asm.jip;\n\nimport java.io.InputStream;\nimport java.io.IOException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassReader}.\n* It contains ten unit test cases for the {@link ClassReader#readShort(int)} method.\n*/\nclass ClassReaderTest2 {"
	},
	{
		"original_code": "// ClassReader.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\nimport java.io.InputStream;\nimport java.io.IOException;\n\n/**\n * A Java class parser to make a {@link ClassVisitor} visit an existing class.\n * This class parses a byte array conforming to the Java class file format and\n * calls the appropriate visit methods of a given class visitor for each field,\n * method and bytecode instruction encountered.\n *\n * @author Eric Bruneton\n * @author Eugene Kuleshov\n */\npublic class ClassReader {\n\n    /**\n     * True to enable signatures support.\n     */\n    static final boolean SIGNATURES = true;\n\n    /**\n     * True to enable annotations support.\n     */\n    static final boolean ANNOTATIONS = true;\n\n    /**\n     * True to enable stack map frames support.\n     */\n    static final boolean FRAMES = true;\n\n    /**\n     * True to enable bytecode writing support.\n     */\n    static final boolean WRITER = true;\n\n    /**\n     * True to enable JSR_W and GOTO_W support.\n     */\n    static final boolean RESIZE = true;\n\n    /**\n     * Flag to skip method code. If this class is set <code>CODE</code>\n     * attribute won't be visited. This can be used, for example, to retrieve\n     * annotations for methods and method parameters.\n     */\n    public static final int SKIP_CODE = 1;\n\n    /**\n     * Flag to skip the debug information in the class. If this flag is set the\n     * debug information of the class is not visited, i.e. the\n     * {@link MethodVisitor#visitLocalVariable visitLocalVariable} and\n     * {@link MethodVisitor#visitLineNumber visitLineNumber} methods will not be\n     * called.\n     */\n    public static final int SKIP_DEBUG = 2;\n\n    /**\n     * Flag to skip the stack map frames in the class. If this flag is set the\n     * stack map frames of the class is not visited, i.e. the\n     * {@link MethodVisitor#visitFrame visitFrame} method will not be called.\n     * This flag is useful when the {@link ClassWriter#COMPUTE_FRAMES} option is\n     * used: it avoids visiting frames that will be ignored and recomputed from\n     * scratch in the class writer.\n     */\n    public static final int SKIP_FRAMES = 4;\n\n    /**\n     * Flag to expand the stack map frames. By default stack map frames are\n     * visited in their original format (i.e. \"expanded\" for classes whose\n     * version is less than V1_6, and \"compressed\" for the other classes). If\n     * this flag is set, stack map frames are always visited in expanded format\n     * (this option adds a decompression/recompression step in ClassReader and\n     * ClassWriter which degrades performances quite a lot).\n     */\n    public static final int EXPAND_FRAMES = 8;\n\n    /**\n     * The class to be parsed. <i>The content of this array must not be\n     * modified. This field is intended for {@link Attribute} sub classes, and\n     * is normally not needed by class generators or adapters.</i>\n     */\n    public final byte[] b;\n\n    /**\n     * The start index of each constant pool item in {@link #b b}, plus one.\n     * The one byte offset skips the constant pool item tag that indicates its\n     * type.\n     */\n    private final int[] items;\n\n    /**\n     * The String objects corresponding to the CONSTANT_Utf8 items. This cache\n     * avoids multiple parsing of a given CONSTANT_Utf8 constant pool item,\n     * which GREATLY improves performances (by a factor 2 to 3). This caching\n     * strategy could be extended to all constant pool items, but its benefit\n     * would not be so great for these items (because they are much less\n     * expensive to parse than CONSTANT_Utf8 items).\n     */\n    private final String[] strings;\n\n    /**\n     * Maximum length of the strings contained in the constant pool of the\n     * class.\n     */\n    private final int maxStringLength;\n\n    /**\n     * Start index of the class header information (access, name...) in\n     * {@link #b b}.\n     */\n    public final int header;\n\n    // ------------------------------------------------------------------------\n    // Constructors\n    // ------------------------------------------------------------------------\n    /**\n     * Constructs a new {@link ClassReader} object.\n     *\n     * @param b the bytecode of the class to be read.\n     */\n    public ClassReader(final byte[] b) {\n        this(b, 0, b.length);\n    }\n\n    /**\n     * Constructs a new {@link ClassReader} object.\n     *\n     * @param b the bytecode of the class to be read.\n     * @param off the start offset of the class data.\n     * @param len the length of the class data.\n     */\n    public ClassReader(final byte[] b, final int off, final int len) {\n        this.b = b;\n        // parses the constant pool\n        items = new int[readUnsignedShort(off + 8)];\n        int n = items.length;\n        strings = new String[n];\n        int max = 0;\n        int index = off + 10;\n        for (int i = 1; i < n; ++i) {\n            items[i] = index + 1;\n            int size;\n            switch(b[index]) {\n                case ClassWriter.FIELD:\n                case ClassWriter.METH:\n                case ClassWriter.IMETH:\n                case ClassWriter.INT:\n                case ClassWriter.FLOAT:\n                case ClassWriter.NAME_TYPE:\n                    size = 5;\n                    break;\n                case ClassWriter.LONG:\n                case ClassWriter.DOUBLE:\n                    size = 9;\n                    ++i;\n                    break;\n                case ClassWriter.UTF8:\n                    size = 3 + readUnsignedShort(index + 1);\n                    if (size > max) {\n                        max = size;\n                    }\n                    break;\n                // case ClassWriter.CLASS:\n                // case ClassWriter.STR:\n                default:\n                    size = 3;\n                    break;\n            }\n            index += size;\n        }\n        maxStringLength = max;\n        // the class header information starts just after the constant pool\n        header = index;\n    }\n\n    /**\n     * Returns the class's access flags (see {@link Opcodes}). This value may\n     * not reflect Deprecated and Synthetic flags when bytecode is before 1.5\n     * and those flags are represented by attributes.\n     *\n     * @return the class access flags\n     *\n     * @see ClassVisitor#visit(int, int, String, String, String, String[])\n     */\n    public int getAccess() {\n        return readUnsignedShort(header);\n    }\n\n    /**\n     * Returns the internal name of the class (see\n     * {@link Type#getInternalName() getInternalName}).\n     *\n     * @return the internal class name\n     *\n     * @see ClassVisitor#visit(int, int, String, String, String, String[])\n     */\n    public String getClassName() {\n        return readClass(header + 2, new char[maxStringLength]);\n    }\n\n    /**\n     * Returns the internal of name of the super class (see\n     * {@link Type#getInternalName() getInternalName}). For interfaces, the\n     * super class is {@link Object}.\n     *\n     * @return the internal name of super class, or <tt>null</tt> for\n     *         {@link Object} class.\n     *\n     * @see ClassVisitor#visit(int, int, String, String, String, String[])\n     */\n    public String getSuperName() {\n        int n = items[readUnsignedShort(header + 4)];\n        return n == 0 ? null : readUTF8(n, new char[maxStringLength]);\n    }\n\n    /**\n     * Returns the internal names of the class's interfaces (see\n     * {@link Type#getInternalName() getInternalName}).\n     *\n     * @return the array of internal names for all implemented interfaces or\n     *         <tt>null</tt>.\n     *\n     * @see ClassVisitor#visit(int, int, String, String, String, String[])\n     */\n    public String[] getInterfaces() {\n        int index = header + 6;\n        int n = readUnsignedShort(index);\n        String[] interfaces = new String[n];\n        if (n > 0) {\n            char[] buf = new char[maxStringLength];\n            for (int i = 0; i < n; ++i) {\n                index += 2;\n                interfaces[i] = readClass(index, buf);\n            }\n        }\n        return interfaces;\n    }\n\n    /**\n     * Copies the constant pool data into the given {@link ClassWriter}. Should\n     * be called before the {@link #accept(ClassVisitor,int)} method.\n     *\n     * @param classWriter the {@link ClassWriter} to copy constant pool into.\n     */\n    void copyPool(final ClassWriter classWriter) {\n        char[] buf = new char[maxStringLength];\n        int ll = items.length;\n        Item[] items2 = new Item[ll];\n        for (int i = 1; i < ll; i++) {\n            int index = items[i];\n            int tag = b[index - 1];\n            Item item = new Item(i);\n            int nameType;\n            switch(tag) {\n                case ClassWriter.FIELD:\n                case ClassWriter.METH:\n                case ClassWriter.IMETH:\n                    nameType = items[readUnsignedShort(index + 2)];\n                    item.set(tag, readClass(index, buf), readUTF8(nameType, buf), readUTF8(nameType + 2, buf));\n                    break;\n                case ClassWriter.INT:\n                    item.set(readInt(index));\n                    break;\n                case ClassWriter.FLOAT:\n                    item.set(Float.intBitsToFloat(readInt(index)));\n                    break;\n                case ClassWriter.NAME_TYPE:\n                    item.set(tag, readUTF8(index, buf), readUTF8(index + 2, buf), null);\n                    break;\n                case ClassWriter.LONG:\n                    item.set(readLong(index));\n                    ++i;\n                    break;\n                case ClassWriter.DOUBLE:\n                    item.set(Double.longBitsToDouble(readLong(index)));\n                    ++i;\n                    break;\n                case ClassWriter.UTF8:\n                    {\n                        String s = strings[i];\n                        if (s == null) {\n                            index = items[i];\n                            s = strings[i] = readUTF(index + 2, readUnsignedShort(index), buf);\n                        }\n                        item.set(tag, s, null, null);\n                    }\n                    break;\n                // case ClassWriter.STR:\n                // case ClassWriter.CLASS:\n                default:\n                    item.set(tag, readUTF8(index, buf), null, null);\n                    break;\n            }\n            int index2 = item.hashCode % items2.length;\n            item.next = items2[index2];\n            items2[index2] = item;\n        }\n        int off = items[1] - 1;\n        classWriter.pool.putByteArray(b, off, header - off);\n        classWriter.items = items2;\n        classWriter.threshold = (int) (0.75d * ll);\n        classWriter.index = ll;\n    }\n\n    /**\n     * Constructs a new {@link ClassReader} object.\n     *\n     * @param is an input stream from which to read the class.\n     * @throws IOException if a problem occurs during reading.\n     */\n    public ClassReader(final InputStream is) throws IOException {\n        this(readClass(is));\n    }\n\n    /**\n     * Constructs a new {@link ClassReader} object.\n     *\n     * @param name the fully qualified name of the class to be read.\n     * @throws IOException if an exception occurs during reading.\n     */\n    public ClassReader(final String name) throws IOException {\n        this(ClassLoader.getSystemResourceAsStream(name.replace('.', '/') + \".class\"));\n    }\n\n    /**\n     * Reads the bytecode of a class.\n     *\n     * @param is an input stream from which to read the class.\n     * @return the bytecode read from the given input stream.\n     * @throws IOException if a problem occurs during reading.\n     */\n    private static byte[] readClass(final InputStream is) throws IOException {\n        if (is == null) {\n            throw new IOException(\"Class not found\");\n        }\n        byte[] b = new byte[is.available()];\n        int len = 0;\n        while (true) {\n            int n = is.read(b, len, b.length - len);\n            if (n == -1) {\n                if (len < b.length) {\n                    byte[] c = new byte[len];\n                    System.arraycopy(b, 0, c, 0, len);\n                    b = c;\n                }\n                return b;\n            }\n            len += n;\n            if (len == b.length) {\n                int last = is.read();\n                if (last < 0) {\n                    return b;\n                }\n                byte[] c = new byte[b.length + 1000];\n                System.arraycopy(b, 0, c, 0, len);\n                c[len++] = (byte) last;\n                b = c;\n            }\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Public methods\n    // ------------------------------------------------------------------------\n    /**\n     * Makes the given visitor visit the Java class of this {@link ClassReader}.\n     * This class is the one specified in the constructor (see\n     * {@link #ClassReader(byte[]) ClassReader}).\n     *\n     * @param classVisitor the visitor that must visit this class.\n     * @param flags option flags that can be used to modify the default behavior\n     *        of this class. See {@link #SKIP_DEBUG}, {@link #EXPAND_FRAMES},\n     *        {@link #SKIP_FRAMES}, {@link #SKIP_CODE}.\n     */\n    public void accept(final ClassVisitor classVisitor, final int flags) {\n        accept(classVisitor, new Attribute[0], flags);\n    }\n\n    /**\n     * Makes the given visitor visit the Java class of this {@link ClassReader}.\n     * This class is the one specified in the constructor (see\n     * {@link #ClassReader(byte[]) ClassReader}).\n     *\n     * @param classVisitor the visitor that must visit this class.\n     * @param attrs prototypes of the attributes that must be parsed during the\n     *        visit of the class. Any attribute whose type is not equal to the\n     *        type of one the prototypes will not be parsed: its byte array\n     *        value will be passed unchanged to the ClassWriter. <i>This may\n     *        corrupt it if this value contains references to the constant pool,\n     *        or has syntactic or semantic links with a class element that has\n     *        been transformed by a class adapter between the reader and the\n     *        writer</i>.\n     * @param flags option flags that can be used to modify the default behavior\n     *        of this class. See {@link #SKIP_DEBUG}, {@link #EXPAND_FRAMES},\n     *        {@link #SKIP_FRAMES}, {@link #SKIP_CODE}.\n     */\n    public void accept(final ClassVisitor classVisitor, final Attribute[] attrs, final int flags) {\n        // the bytecode array\n        byte[] b = this.b;\n        // buffer used to read strings\n        char[] c = new char[maxStringLength];\n        // loop variables\n        int i, j, k;\n        // indexes in b\n        int u, v, w;\n        Attribute attr;\n        int access;\n        String name;\n        String desc;\n        String attrName;\n        String signature;\n        int anns = 0;\n        int ianns = 0;\n        Attribute cattrs = null;\n        // visits the header\n        u = header;\n        access = readUnsignedShort(u);\n        name = readClass(u + 2, c);\n        v = items[readUnsignedShort(u + 4)];\n        String superClassName = v == 0 ? null : readUTF8(v, c);\n        String[] implementedItfs = new String[readUnsignedShort(u + 6)];\n        w = 0;\n        u += 8;\n        for (i = 0; i < implementedItfs.length; ++i) {\n            implementedItfs[i] = readClass(u, c);\n            u += 2;\n        }\n        boolean skipCode = (flags & SKIP_CODE) != 0;\n        boolean skipDebug = (flags & SKIP_DEBUG) != 0;\n        boolean unzip = (flags & EXPAND_FRAMES) != 0;\n        // skips fields and methods\n        v = u;\n        i = readUnsignedShort(v);\n        v += 2;\n        for (; i > 0; --i) {\n            j = readUnsignedShort(v + 6);\n            v += 8;\n            for (; j > 0; --j) {\n                v += 6 + readInt(v + 2);\n            }\n        }\n        i = readUnsignedShort(v);\n        v += 2;\n        for (; i > 0; --i) {\n            j = readUnsignedShort(v + 6);\n            v += 8;\n            for (; j > 0; --j) {\n                v += 6 + readInt(v + 2);\n            }\n        }\n        // reads the class's attributes\n        signature = null;\n        String sourceFile = null;\n        String sourceDebug = null;\n        String enclosingOwner = null;\n        String enclosingName = null;\n        String enclosingDesc = null;\n        i = readUnsignedShort(v);\n        v += 2;\n        for (; i > 0; --i) {\n            attrName = readUTF8(v, c);\n            // tests are sorted in decreasing frequency order\n            // (based on frequencies observed on typical classes)\n            if (\"SourceFile\".equals(attrName)) {\n                sourceFile = readUTF8(v + 6, c);\n            } else if (\"InnerClasses\".equals(attrName)) {\n                w = v + 6;\n            } else if (\"EnclosingMethod\".equals(attrName)) {\n                enclosingOwner = readClass(v + 6, c);\n                int item = readUnsignedShort(v + 8);\n                if (item != 0) {\n                    enclosingName = readUTF8(items[item], c);\n                    enclosingDesc = readUTF8(items[item] + 2, c);\n                }\n            } else if (SIGNATURES && \"Signature\".equals(attrName)) {\n                signature = readUTF8(v + 6, c);\n            } else if (ANNOTATIONS && \"RuntimeVisibleAnnotations\".equals(attrName)) {\n                anns = v + 6;\n            } else if (\"Deprecated\".equals(attrName)) {\n                access |= Opcodes.ACC_DEPRECATED;\n            } else if (\"Synthetic\".equals(attrName)) {\n                access |= Opcodes.ACC_SYNTHETIC;\n            } else if (\"SourceDebugExtension\".equals(attrName)) {\n                int len = readInt(v + 2);\n                sourceDebug = readUTF(v + 6, len, new char[len]);\n            } else if (ANNOTATIONS && \"RuntimeInvisibleAnnotations\".equals(attrName)) {\n                ianns = v + 6;\n            } else {\n                attr = readAttribute(attrs, attrName, v + 6, readInt(v + 2), c, -1, null);\n                if (attr != null) {\n                    attr.next = cattrs;\n                    cattrs = attr;\n                }\n            }\n            v += 6 + readInt(v + 2);\n        }\n        // calls the visit method\n        classVisitor.visit(readInt(4), access, name, signature, superClassName, implementedItfs);\n        // calls the visitSource method\n        if (!skipDebug && (sourceFile != null || sourceDebug != null)) {\n            classVisitor.visitSource(sourceFile, sourceDebug);\n        }\n        // calls the visitOuterClass method\n        if (enclosingOwner != null) {\n            classVisitor.visitOuterClass(enclosingOwner, enclosingName, enclosingDesc);\n        }\n        // visits the class annotations\n        if (ANNOTATIONS) {\n            for (i = 1; i >= 0; --i) {\n                v = i == 0 ? ianns : anns;\n                if (v != 0) {\n                    j = readUnsignedShort(v);\n                    v += 2;\n                    for (; j > 0; --j) {\n                        v = readAnnotationValues(v + 2, c, true, classVisitor.visitAnnotation(readUTF8(v, c), i != 0));\n                    }\n                }\n            }\n        }\n        // visits the class attributes\n        while (cattrs != null) {\n            attr = cattrs.next;\n            cattrs.next = null;\n            classVisitor.visitAttribute(cattrs);\n            cattrs = attr;\n        }\n        // calls the visitInnerClass method\n        if (w != 0) {\n            i = readUnsignedShort(w);\n            w += 2;\n            for (; i > 0; --i) {\n                classVisitor.visitInnerClass(readUnsignedShort(w) == 0 ? null : readClass(w, c), readUnsignedShort(w + 2) == 0 ? null : readClass(w + 2, c), readUnsignedShort(w + 4) == 0 ? null : readUTF8(w + 4, c), readUnsignedShort(w + 6));\n                w += 8;\n            }\n        }\n        // visits the fields\n        i = readUnsignedShort(u);\n        u += 2;\n        for (; i > 0; --i) {\n            access = readUnsignedShort(u);\n            name = readUTF8(u + 2, c);\n            desc = readUTF8(u + 4, c);\n            // visits the field's attributes and looks for a ConstantValue\n            // attribute\n            int fieldValueItem = 0;\n            signature = null;\n            anns = 0;\n            ianns = 0;\n            cattrs = null;\n            j = readUnsignedShort(u + 6);\n            u += 8;\n            for (; j > 0; --j) {\n                attrName = readUTF8(u, c);\n                // tests are sorted in decreasing frequency order\n                // (based on frequencies observed on typical classes)\n                if (\"ConstantValue\".equals(attrName)) {\n                    fieldValueItem = readUnsignedShort(u + 6);\n                } else if (SIGNATURES && \"Signature\".equals(attrName)) {\n                    signature = readUTF8(u + 6, c);\n                } else if (\"Deprecated\".equals(attrName)) {\n                    access |= Opcodes.ACC_DEPRECATED;\n                } else if (\"Synthetic\".equals(attrName)) {\n                    access |= Opcodes.ACC_SYNTHETIC;\n                } else if (ANNOTATIONS && \"RuntimeVisibleAnnotations\".equals(attrName)) {\n                    anns = u + 6;\n                } else if (ANNOTATIONS && \"RuntimeInvisibleAnnotations\".equals(attrName)) {\n                    ianns = u + 6;\n                } else {\n                    attr = readAttribute(attrs, attrName, u + 6, readInt(u + 2), c, -1, null);\n                    if (attr != null) {\n                        attr.next = cattrs;\n                        cattrs = attr;\n                    }\n                }\n                u += 6 + readInt(u + 2);\n            }\n            // visits the field\n            FieldVisitor fv = classVisitor.visitField(access, name, desc, signature, fieldValueItem == 0 ? null : readConst(fieldValueItem, c));\n            // visits the field annotations and attributes\n            if (fv != null) {\n                if (ANNOTATIONS) {\n                    for (j = 1; j >= 0; --j) {\n                        v = j == 0 ? ianns : anns;\n                        if (v != 0) {\n                            k = readUnsignedShort(v);\n                            v += 2;\n                            for (; k > 0; --k) {\n                                v = readAnnotationValues(v + 2, c, true, fv.visitAnnotation(readUTF8(v, c), j != 0));\n                            }\n                        }\n                    }\n                }\n                while (cattrs != null) {\n                    attr = cattrs.next;\n                    cattrs.next = null;\n                    fv.visitAttribute(cattrs);\n                    cattrs = attr;\n                }\n                fv.visitEnd();\n            }\n        }\n        // visits the methods\n        i = readUnsignedShort(u);\n        u += 2;\n        for (; i > 0; --i) {\n            int u0 = u + 6;\n            access = readUnsignedShort(u);\n            name = readUTF8(u + 2, c);\n            desc = readUTF8(u + 4, c);\n            signature = null;\n            anns = 0;\n            ianns = 0;\n            int dann = 0;\n            int mpanns = 0;\n            int impanns = 0;\n            cattrs = null;\n            v = 0;\n            w = 0;\n            // looks for Code and Exceptions attributes\n            j = readUnsignedShort(u + 6);\n            u += 8;\n            for (; j > 0; --j) {\n                attrName = readUTF8(u, c);\n                int attrSize = readInt(u + 2);\n                u += 6;\n                // tests are sorted in decreasing frequency order\n                // (based on frequencies observed on typical classes)\n                if (\"Code\".equals(attrName)) {\n                    if (!skipCode) {\n                        v = u;\n                    }\n                } else if (\"Exceptions\".equals(attrName)) {\n                    w = u;\n                } else if (SIGNATURES && \"Signature\".equals(attrName)) {\n                    signature = readUTF8(u, c);\n                } else if (\"Deprecated\".equals(attrName)) {\n                    access |= Opcodes.ACC_DEPRECATED;\n                } else if (ANNOTATIONS && \"RuntimeVisibleAnnotations\".equals(attrName)) {\n                    anns = u;\n                } else if (ANNOTATIONS && \"AnnotationDefault\".equals(attrName)) {\n                    dann = u;\n                } else if (\"Synthetic\".equals(attrName)) {\n                    access |= Opcodes.ACC_SYNTHETIC;\n                } else if (ANNOTATIONS && \"RuntimeInvisibleAnnotations\".equals(attrName)) {\n                    ianns = u;\n                } else if (ANNOTATIONS && \"RuntimeVisibleParameterAnnotations\".equals(attrName)) {\n                    mpanns = u;\n                } else if (ANNOTATIONS && \"RuntimeInvisibleParameterAnnotations\".equals(attrName)) {\n                    impanns = u;\n                } else {\n                    attr = readAttribute(attrs, attrName, u, attrSize, c, -1, null);\n                    if (attr != null) {\n                        attr.next = cattrs;\n                        cattrs = attr;\n                    }\n                }\n                u += attrSize;\n            }\n            // reads declared exceptions\n            String[] exceptions;\n            if (w == 0) {\n                exceptions = null;\n            } else {\n                exceptions = new String[readUnsignedShort(w)];\n                w += 2;\n                for (j = 0; j < exceptions.length; ++j) {\n                    exceptions[j] = readClass(w, c);\n                    w += 2;\n                }\n            }\n            // visits the method's code, if any\n            MethodVisitor mv = classVisitor.visitMethod(access, name, desc, signature, exceptions);\n            if (mv != null) {\n                /*\n                 * if the returned MethodVisitor is in fact a MethodWriter, it\n                 * means there is no method adapter between the reader and the\n                 * writer. If, in addition, the writer's constant pool was\n                 * copied from this reader (mw.cw.cr == this), and the signature\n                 * and exceptions of the method have not been changed, then it\n                 * is possible to skip all visit events and just copy the\n                 * original code of the method to the writer (the access, name\n                 * and descriptor can have been changed, this is not important\n                 * since they are not copied as is from the reader).\n                 */\n                if (WRITER && mv instanceof MethodWriter) {\n                    MethodWriter mw = (MethodWriter) mv;\n                    if (mw.cw.cr == this) {\n                        if (signature == mw.signature) {\n                            boolean sameExceptions = false;\n                            if (exceptions == null) {\n                                sameExceptions = mw.exceptionCount == 0;\n                            } else {\n                                if (exceptions.length == mw.exceptionCount) {\n                                    sameExceptions = true;\n                                    for (j = exceptions.length - 1; j >= 0; --j) {\n                                        w -= 2;\n                                        if (mw.exceptions[j] != readUnsignedShort(w)) {\n                                            sameExceptions = false;\n                                            break;\n                                        }\n                                    }\n                                }\n                            }\n                            if (sameExceptions) {\n                                /*\n                                 * we do not copy directly the code into\n                                 * MethodWriter to save a byte array copy\n                                 * operation. The real copy will be done in\n                                 * ClassWriter.toByteArray().\n                                 */\n                                mw.classReaderOffset = u0;\n                                mw.classReaderLength = u - u0;\n                                continue;\n                            }\n                        }\n                    }\n                }\n                if (ANNOTATIONS && dann != 0) {\n                    AnnotationVisitor dv = mv.visitAnnotationDefault();\n                    readAnnotationValue(dann, c, null, dv);\n                    if (dv != null) {\n                        dv.visitEnd();\n                    }\n                }\n                if (ANNOTATIONS) {\n                    for (j = 1; j >= 0; --j) {\n                        w = j == 0 ? ianns : anns;\n                        if (w != 0) {\n                            k = readUnsignedShort(w);\n                            w += 2;\n                            for (; k > 0; --k) {\n                                w = readAnnotationValues(w + 2, c, true, mv.visitAnnotation(readUTF8(w, c), j != 0));\n                            }\n                        }\n                    }\n                }\n                if (ANNOTATIONS && mpanns != 0) {\n                    readParameterAnnotations(mpanns, desc, c, true, mv);\n                }\n                if (ANNOTATIONS && impanns != 0) {\n                    readParameterAnnotations(impanns, desc, c, false, mv);\n                }\n                while (cattrs != null) {\n                    attr = cattrs.next;\n                    cattrs.next = null;\n                    mv.visitAttribute(cattrs);\n                    cattrs = attr;\n                }\n            }\n            if (mv != null && v != 0) {\n                int maxStack = readUnsignedShort(v);\n                int maxLocals = readUnsignedShort(v + 2);\n                int codeLength = readInt(v + 4);\n                v += 8;\n                int codeStart = v;\n                int codeEnd = v + codeLength;\n                mv.visitCode();\n                // 1st phase: finds the labels\n                int label;\n                Label[] labels = new Label[codeLength + 2];\n                readLabel(codeLength + 1, labels);\n                while (v < codeEnd) {\n                    w = v - codeStart;\n                    int opcode = b[v] & 0xFF;\n                    switch(ClassWriter.TYPE[opcode]) {\n                        case ClassWriter.NOARG_INSN:\n                        case ClassWriter.IMPLVAR_INSN:\n                            v += 1;\n                            break;\n                        case ClassWriter.LABEL_INSN:\n                            readLabel(w + readShort(v + 1), labels);\n                            v += 3;\n                            break;\n                        case ClassWriter.LABELW_INSN:\n                            readLabel(w + readInt(v + 1), labels);\n                            v += 5;\n                            break;\n                        case ClassWriter.WIDE_INSN:\n                            opcode = b[v + 1] & 0xFF;\n                            if (opcode == Opcodes.IINC) {\n                                v += 6;\n                            } else {\n                                v += 4;\n                            }\n                            break;\n                        case ClassWriter.TABL_INSN:\n                            // skips 0 to 3 padding bytes*\n                            v = v + 4 - (w & 3);\n                            // reads instruction\n                            readLabel(w + readInt(v), labels);\n                            j = readInt(v + 8) - readInt(v + 4) + 1;\n                            v += 12;\n                            for (; j > 0; --j) {\n                                readLabel(w + readInt(v), labels);\n                                v += 4;\n                            }\n                            break;\n                        case ClassWriter.LOOK_INSN:\n                            // skips 0 to 3 padding bytes*\n                            v = v + 4 - (w & 3);\n                            // reads instruction\n                            readLabel(w + readInt(v), labels);\n                            j = readInt(v + 4);\n                            v += 8;\n                            for (; j > 0; --j) {\n                                readLabel(w + readInt(v + 4), labels);\n                                v += 8;\n                            }\n                            break;\n                        case ClassWriter.VAR_INSN:\n                        case ClassWriter.SBYTE_INSN:\n                        case ClassWriter.LDC_INSN:\n                            v += 2;\n                            break;\n                        case ClassWriter.SHORT_INSN:\n                        case ClassWriter.LDCW_INSN:\n                        case ClassWriter.FIELDORMETH_INSN:\n                        case ClassWriter.TYPE_INSN:\n                        case ClassWriter.IINC_INSN:\n                            v += 3;\n                            break;\n                        case ClassWriter.ITFDYNMETH_INSN:\n                            v += 5;\n                            break;\n                        // case MANA_INSN:\n                        default:\n                            v += 4;\n                            break;\n                    }\n                }\n                // parses the try catch entries\n                j = readUnsignedShort(v);\n                v += 2;\n                for (; j > 0; --j) {\n                    Label start = readLabel(readUnsignedShort(v), labels);\n                    Label end = readLabel(readUnsignedShort(v + 2), labels);\n                    Label handler = readLabel(readUnsignedShort(v + 4), labels);\n                    int type = readUnsignedShort(v + 6);\n                    if (type == 0) {\n                        mv.visitTryCatchBlock(start, end, handler, null);\n                    } else {\n                        mv.visitTryCatchBlock(start, end, handler, readUTF8(items[type], c));\n                    }\n                    v += 8;\n                }\n                // parses the local variable, line number tables, and code\n                // attributes\n                int varTable = 0;\n                int varTypeTable = 0;\n                int stackMap = 0;\n                int stackMapSize = 0;\n                int frameCount = 0;\n                int frameMode = 0;\n                int frameOffset = 0;\n                int frameLocalCount = 0;\n                int frameLocalDiff = 0;\n                int frameStackCount = 0;\n                Object[] frameLocal = null;\n                Object[] frameStack = null;\n                boolean zip = true;\n                cattrs = null;\n                j = readUnsignedShort(v);\n                v += 2;\n                for (; j > 0; --j) {\n                    attrName = readUTF8(v, c);\n                    if (\"LocalVariableTable\".equals(attrName)) {\n                        if (!skipDebug) {\n                            varTable = v + 6;\n                            k = readUnsignedShort(v + 6);\n                            w = v + 8;\n                            for (; k > 0; --k) {\n                                label = readUnsignedShort(w);\n                                if (labels[label] == null) {\n                                    readLabel(label, labels).status |= Label.DEBUG;\n                                }\n                                label += readUnsignedShort(w + 2);\n                                if (labels[label] == null) {\n                                    readLabel(label, labels).status |= Label.DEBUG;\n                                }\n                                w += 10;\n                            }\n                        }\n                    } else if (\"LocalVariableTypeTable\".equals(attrName)) {\n                        varTypeTable = v + 6;\n                    } else if (\"LineNumberTable\".equals(attrName)) {\n                        if (!skipDebug) {\n                            k = readUnsignedShort(v + 6);\n                            w = v + 8;\n                            for (; k > 0; --k) {\n                                label = readUnsignedShort(w);\n                                if (labels[label] == null) {\n                                    readLabel(label, labels).status |= Label.DEBUG;\n                                }\n                                labels[label].line = readUnsignedShort(w + 2);\n                                w += 4;\n                            }\n                        }\n                    } else if (FRAMES && \"StackMapTable\".equals(attrName)) {\n                        if ((flags & SKIP_FRAMES) == 0) {\n                            stackMap = v + 8;\n                            stackMapSize = readInt(v + 2);\n                            frameCount = readUnsignedShort(v + 6);\n                        }\n                        /*\n                         * here we do not extract the labels corresponding to\n                         * the attribute content. This would require a full\n                         * parsing of the attribute, which would need to be\n                         * repeated in the second phase (see below). Instead the\n                         * content of the attribute is read one frame at a time\n                         * (i.e. after a frame has been visited, the next frame\n                         * is read), and the labels it contains are also\n                         * extracted one frame at a time. Thanks to the ordering\n                         * of frames, having only a \"one frame lookahead\" is not\n                         * a problem, i.e. it is not possible to see an offset\n                         * smaller than the offset of the current insn and for\n                         * which no Label exist.\n                         */\n                        /*\n                         * This is not true for UNINITIALIZED type offsets. We\n                         * solve this by parsing the stack map table without a\n                         * full decoding (see below).\n                         */\n                    } else if (FRAMES && \"StackMap\".equals(attrName)) {\n                        if ((flags & SKIP_FRAMES) == 0) {\n                            stackMap = v + 8;\n                            stackMapSize = readInt(v + 2);\n                            frameCount = readUnsignedShort(v + 6);\n                            zip = false;\n                        }\n                        /*\n                         * IMPORTANT! here we assume that the frames are\n                         * ordered, as in the StackMapTable attribute, although\n                         * this is not guaranteed by the attribute format.\n                         */\n                    } else {\n                        for (k = 0; k < attrs.length; ++k) {\n                            if (attrs[k].type.equals(attrName)) {\n                                attr = attrs[k].read(this, v + 6, readInt(v + 2), c, codeStart - 8, labels);\n                                if (attr != null) {\n                                    attr.next = cattrs;\n                                    cattrs = attr;\n                                }\n                            }\n                        }\n                    }\n                    v += 6 + readInt(v + 2);\n                }\n                // 2nd phase: visits each instruction\n                if (FRAMES && stackMap != 0) {\n                    // creates the very first (implicit) frame from the method\n                    // descriptor\n                    frameLocal = new Object[maxLocals];\n                    frameStack = new Object[maxStack];\n                    if (unzip) {\n                        int local = 0;\n                        if ((access & Opcodes.ACC_STATIC) == 0) {\n                            if (\"<init>\".equals(name)) {\n                                frameLocal[local++] = Opcodes.UNINITIALIZED_THIS;\n                            } else {\n                                frameLocal[local++] = readClass(header + 2, c);\n                            }\n                        }\n                        j = 1;\n                        loop: while (true) {\n                            k = j;\n                            switch(desc.charAt(j++)) {\n                                case 'Z':\n                                case 'C':\n                                case 'B':\n                                case 'S':\n                                case 'I':\n                                    frameLocal[local++] = Opcodes.INTEGER;\n                                    break;\n                                case 'F':\n                                    frameLocal[local++] = Opcodes.FLOAT;\n                                    break;\n                                case 'J':\n                                    frameLocal[local++] = Opcodes.LONG;\n                                    break;\n                                case 'D':\n                                    frameLocal[local++] = Opcodes.DOUBLE;\n                                    break;\n                                case '[':\n                                    while (desc.charAt(j) == '[') {\n                                        ++j;\n                                    }\n                                    if (desc.charAt(j) == 'L') {\n                                        ++j;\n                                        while (desc.charAt(j) != ';') {\n                                            ++j;\n                                        }\n                                    }\n                                    frameLocal[local++] = desc.substring(k, ++j);\n                                    break;\n                                case 'L':\n                                    while (desc.charAt(j) != ';') {\n                                        ++j;\n                                    }\n                                    frameLocal[local++] = desc.substring(k + 1, j++);\n                                    break;\n                                default:\n                                    break loop;\n                            }\n                        }\n                        frameLocalCount = local;\n                    }\n                    /*\n                     * for the first explicit frame the offset is not\n                     * offset_delta + 1 but only offset_delta; setting the\n                     * implicit frame offset to -1 allow the use of the\n                     * \"offset_delta + 1\" rule in all cases\n                     */\n                    frameOffset = -1;\n                    /*\n                     * Finds labels for UNINITIALIZED frame types. Instead of\n                     * decoding each element of the stack map table, we look\n                     * for 3 consecutive bytes that \"look like\" an UNINITIALIZED\n                     * type (tag 8, offset within code bounds, NEW instruction\n                     * at this offset). We may find false positives (i.e. not \n                     * real UNINITIALIZED types), but this should be rare, and \n                     * the only consequence will be the creation of an unneeded \n                     * label. This is better than creating a label for each NEW\n                     * instruction, and faster than fully decoding the whole \n                     * stack map table.\n                     */\n                    for (j = stackMap; j < stackMap + stackMapSize - 2; ++j) {\n                        if (b[j] == 8) {\n                            // UNINITIALIZED FRAME TYPE\n                            k = readUnsignedShort(j + 1);\n                            if (k >= 0 && k < codeLength) {\n                                // potential offset\n                                if ((b[codeStart + k] & 0xFF) == Opcodes.NEW) {\n                                    // NEW at this offset\n                                    readLabel(k, labels);\n                                }\n                            }\n                        }\n                    }\n                }\n                v = codeStart;\n                Label l;\n                while (v < codeEnd) {\n                    w = v - codeStart;\n                    l = labels[w];\n                    if (l != null) {\n                        mv.visitLabel(l);\n                        if (!skipDebug && l.line > 0) {\n                            mv.visitLineNumber(l.line, l);\n                        }\n                    }\n                    while (FRAMES && frameLocal != null && (frameOffset == w || frameOffset == -1)) {\n                        // if there is a frame for this offset,\n                        // makes the visitor visit it,\n                        // and reads the next frame if there is one.\n                        if (!zip || unzip) {\n                            mv.visitFrame(Opcodes.F_NEW, frameLocalCount, frameLocal, frameStackCount, frameStack);\n                        } else if (frameOffset != -1) {\n                            mv.visitFrame(frameMode, frameLocalDiff, frameLocal, frameStackCount, frameStack);\n                        }\n                        if (frameCount > 0) {\n                            int tag, delta, n;\n                            if (zip) {\n                                tag = b[stackMap++] & 0xFF;\n                            } else {\n                                tag = MethodWriter.FULL_FRAME;\n                                frameOffset = -1;\n                            }\n                            frameLocalDiff = 0;\n                            if (tag < MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME) {\n                                delta = tag;\n                                frameMode = Opcodes.F_SAME;\n                                frameStackCount = 0;\n                            } else if (tag < MethodWriter.RESERVED) {\n                                delta = tag - MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME;\n                                stackMap = readFrameType(frameStack, 0, stackMap, c, labels);\n                                frameMode = Opcodes.F_SAME1;\n                                frameStackCount = 1;\n                            } else {\n                                delta = readUnsignedShort(stackMap);\n                                stackMap += 2;\n                                if (tag == MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {\n                                    stackMap = readFrameType(frameStack, 0, stackMap, c, labels);\n                                    frameMode = Opcodes.F_SAME1;\n                                    frameStackCount = 1;\n                                } else if (tag >= MethodWriter.CHOP_FRAME && tag < MethodWriter.SAME_FRAME_EXTENDED) {\n                                    frameMode = Opcodes.F_CHOP;\n                                    frameLocalDiff = MethodWriter.SAME_FRAME_EXTENDED - tag;\n                                    frameLocalCount -= frameLocalDiff;\n                                    frameStackCount = 0;\n                                } else if (tag == MethodWriter.SAME_FRAME_EXTENDED) {\n                                    frameMode = Opcodes.F_SAME;\n                                    frameStackCount = 0;\n                                } else if (tag < MethodWriter.FULL_FRAME) {\n                                    j = unzip ? frameLocalCount : 0;\n                                    for (k = tag - MethodWriter.SAME_FRAME_EXTENDED; k > 0; k--) {\n                                        stackMap = readFrameType(frameLocal, j++, stackMap, c, labels);\n                                    }\n                                    frameMode = Opcodes.F_APPEND;\n                                    frameLocalDiff = tag - MethodWriter.SAME_FRAME_EXTENDED;\n                                    frameLocalCount += frameLocalDiff;\n                                    frameStackCount = 0;\n                                } else {\n                                    // if (tag == FULL_FRAME) {\n                                    frameMode = Opcodes.F_FULL;\n                                    n = frameLocalDiff = frameLocalCount = readUnsignedShort(stackMap);\n                                    stackMap += 2;\n                                    for (j = 0; n > 0; n--) {\n                                        stackMap = readFrameType(frameLocal, j++, stackMap, c, labels);\n                                    }\n                                    n = frameStackCount = readUnsignedShort(stackMap);\n                                    stackMap += 2;\n                                    for (j = 0; n > 0; n--) {\n                                        stackMap = readFrameType(frameStack, j++, stackMap, c, labels);\n                                    }\n                                }\n                            }\n                            frameOffset += delta + 1;\n                            readLabel(frameOffset, labels);\n                            --frameCount;\n                        } else {\n                            frameLocal = null;\n                        }\n                    }\n                    int opcode = b[v] & 0xFF;\n                    switch(ClassWriter.TYPE[opcode]) {\n                        case ClassWriter.NOARG_INSN:\n                            mv.visitInsn(opcode);\n                            v += 1;\n                            break;\n                        case ClassWriter.IMPLVAR_INSN:\n                            if (opcode > Opcodes.ISTORE) {\n                                // ISTORE_0\n                                opcode -= 59;\n                                mv.visitVarInsn(Opcodes.ISTORE + (opcode >> 2), opcode & 0x3);\n                            } else {\n                                // ILOAD_0\n                                opcode -= 26;\n                                mv.visitVarInsn(Opcodes.ILOAD + (opcode >> 2), opcode & 0x3);\n                            }\n                            v += 1;\n                            break;\n                        case ClassWriter.LABEL_INSN:\n                            mv.visitJumpInsn(opcode, labels[w + readShort(v + 1)]);\n                            v += 3;\n                            break;\n                        case ClassWriter.LABELW_INSN:\n                            mv.visitJumpInsn(opcode - 33, labels[w + readInt(v + 1)]);\n                            v += 5;\n                            break;\n                        case ClassWriter.WIDE_INSN:\n                            opcode = b[v + 1] & 0xFF;\n                            if (opcode == Opcodes.IINC) {\n                                mv.visitIincInsn(readUnsignedShort(v + 2), readShort(v + 4));\n                                v += 6;\n                            } else {\n                                mv.visitVarInsn(opcode, readUnsignedShort(v + 2));\n                                v += 4;\n                            }\n                            break;\n                        case ClassWriter.TABL_INSN:\n                            // skips 0 to 3 padding bytes\n                            v = v + 4 - (w & 3);\n                            // reads instruction\n                            label = w + readInt(v);\n                            int min = readInt(v + 4);\n                            int max = readInt(v + 8);\n                            v += 12;\n                            Label[] table = new Label[max - min + 1];\n                            for (j = 0; j < table.length; ++j) {\n                                table[j] = labels[w + readInt(v)];\n                                v += 4;\n                            }\n                            mv.visitTableSwitchInsn(min, max, labels[label], table);\n                            break;\n                        case ClassWriter.LOOK_INSN:\n                            // skips 0 to 3 padding bytes\n                            v = v + 4 - (w & 3);\n                            // reads instruction\n                            label = w + readInt(v);\n                            j = readInt(v + 4);\n                            v += 8;\n                            int[] keys = new int[j];\n                            Label[] values = new Label[j];\n                            for (j = 0; j < keys.length; ++j) {\n                                keys[j] = readInt(v);\n                                values[j] = labels[w + readInt(v + 4)];\n                                v += 8;\n                            }\n                            mv.visitLookupSwitchInsn(labels[label], keys, values);\n                            break;\n                        case ClassWriter.VAR_INSN:\n                            mv.visitVarInsn(opcode, b[v + 1] & 0xFF);\n                            v += 2;\n                            break;\n                        case ClassWriter.SBYTE_INSN:\n                            mv.visitIntInsn(opcode, b[v + 1]);\n                            v += 2;\n                            break;\n                        case ClassWriter.SHORT_INSN:\n                            mv.visitIntInsn(opcode, readShort(v + 1));\n                            v += 3;\n                            break;\n                        case ClassWriter.LDC_INSN:\n                            mv.visitLdcInsn(readConst(b[v + 1] & 0xFF, c));\n                            v += 2;\n                            break;\n                        case ClassWriter.LDCW_INSN:\n                            mv.visitLdcInsn(readConst(readUnsignedShort(v + 1), c));\n                            v += 3;\n                            break;\n                        case ClassWriter.FIELDORMETH_INSN:\n                        case ClassWriter.ITFDYNMETH_INSN:\n                            int cpIndex = items[readUnsignedShort(v + 1)];\n                            String iowner;\n                            // INVOKEDYNAMIC is receiverless\n                            if (opcode == Opcodes.INVOKEDYNAMIC) {\n                                iowner = Opcodes.INVOKEDYNAMIC_OWNER;\n                            } else {\n                                iowner = readClass(cpIndex, c);\n                                cpIndex = items[readUnsignedShort(cpIndex + 2)];\n                            }\n                            String iname = readUTF8(cpIndex, c);\n                            String idesc = readUTF8(cpIndex + 2, c);\n                            if (opcode < Opcodes.INVOKEVIRTUAL) {\n                                mv.visitFieldInsn(opcode, iowner, iname, idesc);\n                            } else {\n                                mv.visitMethodInsn(opcode, iowner, iname, idesc);\n                            }\n                            if (opcode == Opcodes.INVOKEINTERFACE || opcode == Opcodes.INVOKEDYNAMIC) {\n                                v += 5;\n                            } else {\n                                v += 3;\n                            }\n                            break;\n                        case ClassWriter.TYPE_INSN:\n                            mv.visitTypeInsn(opcode, readClass(v + 1, c));\n                            v += 3;\n                            break;\n                        case ClassWriter.IINC_INSN:\n                            mv.visitIincInsn(b[v + 1] & 0xFF, b[v + 2]);\n                            v += 3;\n                            break;\n                        // case MANA_INSN:\n                        default:\n                            mv.visitMultiANewArrayInsn(readClass(v + 1, c), b[v + 3] & 0xFF);\n                            v += 4;\n                            break;\n                    }\n                }\n                l = labels[codeEnd - codeStart];\n                if (l != null) {\n                    mv.visitLabel(l);\n                }\n                // visits the local variable tables\n                if (!skipDebug && varTable != 0) {\n                    int[] typeTable = null;\n                    if (varTypeTable != 0) {\n                        k = readUnsignedShort(varTypeTable) * 3;\n                        w = varTypeTable + 2;\n                        typeTable = new int[k];\n                        while (k > 0) {\n                            // signature\n                            typeTable[--k] = w + 6;\n                            // index\n                            typeTable[--k] = readUnsignedShort(w + 8);\n                            // start\n                            typeTable[--k] = readUnsignedShort(w);\n                            w += 10;\n                        }\n                    }\n                    k = readUnsignedShort(varTable);\n                    w = varTable + 2;\n                    for (; k > 0; --k) {\n                        int start = readUnsignedShort(w);\n                        int length = readUnsignedShort(w + 2);\n                        int index = readUnsignedShort(w + 8);\n                        String vsignature = null;\n                        if (typeTable != null) {\n                            for (int a = 0; a < typeTable.length; a += 3) {\n                                if (typeTable[a] == start && typeTable[a + 1] == index) {\n                                    vsignature = readUTF8(typeTable[a + 2], c);\n                                    break;\n                                }\n                            }\n                        }\n                        mv.visitLocalVariable(readUTF8(w + 4, c), readUTF8(w + 6, c), vsignature, labels[start], labels[start + length], index);\n                        w += 10;\n                    }\n                }\n                // visits the other attributes\n                while (cattrs != null) {\n                    attr = cattrs.next;\n                    cattrs.next = null;\n                    mv.visitAttribute(cattrs);\n                    cattrs = attr;\n                }\n                // visits the max stack and max locals values\n                mv.visitMaxs(maxStack, maxLocals);\n            }\n            if (mv != null) {\n                mv.visitEnd();\n            }\n        }\n        // visits the end of the class\n        classVisitor.visitEnd();\n    }\n\n    /**\n     * Reads parameter annotations and makes the given visitor visit them.\n     *\n     * @param v start offset in {@link #b b} of the annotations to be read.\n     * @param desc the method descriptor.\n     * @param buf buffer to be used to call {@link #readUTF8 readUTF8},\n     *        {@link #readClass(int,char[]) readClass} or\n     *        {@link #readConst readConst}.\n     * @param visible <tt>true</tt> if the annotations to be read are visible\n     *        at runtime.\n     * @param mv the visitor that must visit the annotations.\n     */\n    private void readParameterAnnotations(int v, final String desc, final char[] buf, final boolean visible, final MethodVisitor mv) {\n        int i;\n        int n = b[v++] & 0xFF;\n        // workaround for a bug in javac (javac compiler generates a parameter\n        // annotation array whose size is equal to the number of parameters in\n        // the Java source file, while it should generate an array whose size is\n        // equal to the number of parameters in the method descriptor - which\n        // includes the synthetic parameters added by the compiler). This work-\n        // around supposes that the synthetic parameters are the first ones.\n        int synthetics = Type.getArgumentTypes(desc).length - n;\n        AnnotationVisitor av;\n        for (i = 0; i < synthetics; ++i) {\n            // virtual annotation to detect synthetic parameters in MethodWriter\n            av = mv.visitParameterAnnotation(i, \"Ljava/lang/Synthetic;\", false);\n            if (av != null) {\n                av.visitEnd();\n            }\n        }\n        for (; i < n + synthetics; ++i) {\n            int j = readUnsignedShort(v);\n            v += 2;\n            for (; j > 0; --j) {\n                av = mv.visitParameterAnnotation(i, readUTF8(v, buf), visible);\n                v = readAnnotationValues(v + 2, buf, true, av);\n            }\n        }\n    }\n\n    /**\n     * Reads the values of an annotation and makes the given visitor visit them.\n     *\n     * @param v the start offset in {@link #b b} of the values to be read\n     *        (including the unsigned short that gives the number of values).\n     * @param buf buffer to be used to call {@link #readUTF8 readUTF8},\n     *        {@link #readClass(int,char[]) readClass} or\n     *        {@link #readConst readConst}.\n     * @param named if the annotation values are named or not.\n     * @param av the visitor that must visit the values.\n     * @return the end offset of the annotation values.\n     */\n    private int readAnnotationValues(int v, final char[] buf, final boolean named, final AnnotationVisitor av) {\n        int i = readUnsignedShort(v);\n        v += 2;\n        if (named) {\n            for (; i > 0; --i) {\n                v = readAnnotationValue(v + 2, buf, readUTF8(v, buf), av);\n            }\n        } else {\n            for (; i > 0; --i) {\n                v = readAnnotationValue(v, buf, null, av);\n            }\n        }\n        if (av != null) {\n            av.visitEnd();\n        }\n        return v;\n    }\n\n    /**\n     * Reads a value of an annotation and makes the given visitor visit it.\n     *\n     * @param v the start offset in {@link #b b} of the value to be read (<i>not\n     *        including the value name constant pool index</i>).\n     * @param buf buffer to be used to call {@link #readUTF8 readUTF8},\n     *        {@link #readClass(int,char[]) readClass} or\n     *        {@link #readConst readConst}.\n     * @param name the name of the value to be read.\n     * @param av the visitor that must visit the value.\n     * @return the end offset of the annotation value.\n     */\n    private int readAnnotationValue(int v, final char[] buf, final String name, final AnnotationVisitor av) {\n        int i;\n        if (av == null) {\n            switch(b[v] & 0xFF) {\n                case // enum_const_value\n                'e':\n                    return v + 5;\n                case // annotation_value\n                '@':\n                    return readAnnotationValues(v + 3, buf, true, null);\n                case // array_value\n                '[':\n                    return readAnnotationValues(v + 1, buf, false, null);\n                default:\n                    return v + 3;\n            }\n        }\n        switch(b[v++] & 0xFF) {\n            // pointer to CONSTANT_Integer\n            case 'I':\n            // pointer to CONSTANT_Long\n            case 'J':\n            // pointer to CONSTANT_Float\n            case 'F':\n            case // pointer to CONSTANT_Double\n            'D':\n                av.visit(name, readConst(readUnsignedShort(v), buf));\n                v += 2;\n                break;\n            case // pointer to CONSTANT_Byte\n            'B':\n                av.visit(name, new Byte((byte) readInt(items[readUnsignedShort(v)])));\n                v += 2;\n                break;\n            case // pointer to CONSTANT_Boolean\n            'Z':\n                av.visit(name, readInt(items[readUnsignedShort(v)]) == 0 ? Boolean.FALSE : Boolean.TRUE);\n                v += 2;\n                break;\n            case // pointer to CONSTANT_Short\n            'S':\n                av.visit(name, new Short((short) readInt(items[readUnsignedShort(v)])));\n                v += 2;\n                break;\n            case // pointer to CONSTANT_Char\n            'C':\n                av.visit(name, new Character((char) readInt(items[readUnsignedShort(v)])));\n                v += 2;\n                break;\n            case // pointer to CONSTANT_Utf8\n            's':\n                av.visit(name, readUTF8(v, buf));\n                v += 2;\n                break;\n            case // enum_const_value\n            'e':\n                av.visitEnum(name, readUTF8(v, buf), readUTF8(v + 2, buf));\n                v += 4;\n                break;\n            case // class_info\n            'c':\n                av.visit(name, Type.getType(readUTF8(v, buf)));\n                v += 2;\n                break;\n            case // annotation_value\n            '@':\n                v = readAnnotationValues(v + 2, buf, true, av.visitAnnotation(name, readUTF8(v, buf)));\n                break;\n            case // array_value\n            '[':\n                int size = readUnsignedShort(v);\n                v += 2;\n                if (size == 0) {\n                    return readAnnotationValues(v - 2, buf, false, av.visitArray(name));\n                }\n                switch(this.b[v++] & 0xFF) {\n                    case 'B':\n                        byte[] bv = new byte[size];\n                        for (i = 0; i < size; i++) {\n                            bv[i] = (byte) readInt(items[readUnsignedShort(v)]);\n                            v += 3;\n                        }\n                        av.visit(name, bv);\n                        --v;\n                        break;\n                    case 'Z':\n                        boolean[] zv = new boolean[size];\n                        for (i = 0; i < size; i++) {\n                            zv[i] = readInt(items[readUnsignedShort(v)]) != 0;\n                            v += 3;\n                        }\n                        av.visit(name, zv);\n                        --v;\n                        break;\n                    case 'S':\n                        short[] sv = new short[size];\n                        for (i = 0; i < size; i++) {\n                            sv[i] = (short) readInt(items[readUnsignedShort(v)]);\n                            v += 3;\n                        }\n                        av.visit(name, sv);\n                        --v;\n                        break;\n                    case 'C':\n                        char[] cv = new char[size];\n                        for (i = 0; i < size; i++) {\n                            cv[i] = (char) readInt(items[readUnsignedShort(v)]);\n                            v += 3;\n                        }\n                        av.visit(name, cv);\n                        --v;\n                        break;\n                    case 'I':\n                        int[] iv = new int[size];\n                        for (i = 0; i < size; i++) {\n                            iv[i] = readInt(items[readUnsignedShort(v)]);\n                            v += 3;\n                        }\n                        av.visit(name, iv);\n                        --v;\n                        break;\n                    case 'J':\n                        long[] lv = new long[size];\n                        for (i = 0; i < size; i++) {\n                            lv[i] = readLong(items[readUnsignedShort(v)]);\n                            v += 3;\n                        }\n                        av.visit(name, lv);\n                        --v;\n                        break;\n                    case 'F':\n                        float[] fv = new float[size];\n                        for (i = 0; i < size; i++) {\n                            fv[i] = Float.intBitsToFloat(readInt(items[readUnsignedShort(v)]));\n                            v += 3;\n                        }\n                        av.visit(name, fv);\n                        --v;\n                        break;\n                    case 'D':\n                        double[] dv = new double[size];\n                        for (i = 0; i < size; i++) {\n                            dv[i] = Double.longBitsToDouble(readLong(items[readUnsignedShort(v)]));\n                            v += 3;\n                        }\n                        av.visit(name, dv);\n                        --v;\n                        break;\n                    default:\n                        v = readAnnotationValues(v - 3, buf, false, av.visitArray(name));\n                }\n        }\n        return v;\n    }\n\n    private int readFrameType(final Object[] frame, final int index, int v, final char[] buf, final Label[] labels) {\n        int type = b[v++] & 0xFF;\n        switch(type) {\n            case 0:\n                frame[index] = Opcodes.TOP;\n                break;\n            case 1:\n                frame[index] = Opcodes.INTEGER;\n                break;\n            case 2:\n                frame[index] = Opcodes.FLOAT;\n                break;\n            case 3:\n                frame[index] = Opcodes.DOUBLE;\n                break;\n            case 4:\n                frame[index] = Opcodes.LONG;\n                break;\n            case 5:\n                frame[index] = Opcodes.NULL;\n                break;\n            case 6:\n                frame[index] = Opcodes.UNINITIALIZED_THIS;\n                break;\n            case // Object\n            7:\n                frame[index] = readClass(v, buf);\n                v += 2;\n                break;\n            default:\n                // Uninitialized\n                frame[index] = readLabel(readUnsignedShort(v), labels);\n                v += 2;\n        }\n        return v;\n    }\n\n    /**\n     * Returns the label corresponding to the given offset. The default\n     * implementation of this method creates a label for the given offset if it\n     * has not been already created.\n     *\n     * @param offset a bytecode offset in a method.\n     * @param labels the already created labels, indexed by their offset. If a\n     *        label already exists for offset this method must not create a new\n     *        one. Otherwise it must store the new label in this array.\n     * @return a non null Label, which must be equal to labels[offset].\n     */\n    protected Label readLabel(int offset, Label[] labels) {\n        if (labels[offset] == null) {\n            labels[offset] = new Label();\n        }\n        return labels[offset];\n    }\n\n    /**\n     * Reads an attribute in {@link #b b}.\n     *\n     * @param attrs prototypes of the attributes that must be parsed during the\n     *        visit of the class. Any attribute whose type is not equal to the\n     *        type of one the prototypes is ignored (i.e. an empty\n     *        {@link Attribute} instance is returned).\n     * @param type the type of the attribute.\n     * @param off index of the first byte of the attribute's content in\n     *        {@link #b b}. The 6 attribute header bytes, containing the type\n     *        and the length of the attribute, are not taken into account here\n     *        (they have already been read).\n     * @param len the length of the attribute's content.\n     * @param buf buffer to be used to call {@link #readUTF8 readUTF8},\n     *        {@link #readClass(int,char[]) readClass} or\n     *        {@link #readConst readConst}.\n     * @param codeOff index of the first byte of code's attribute content in\n     *        {@link #b b}, or -1 if the attribute to be read is not a code\n     *        attribute. The 6 attribute header bytes, containing the type and\n     *        the length of the attribute, are not taken into account here.\n     * @param labels the labels of the method's code, or <tt>null</tt> if the\n     *        attribute to be read is not a code attribute.\n     * @return the attribute that has been read, or <tt>null</tt> to skip this\n     *         attribute.\n     */\n    private Attribute readAttribute(final Attribute[] attrs, final String type, final int off, final int len, final char[] buf, final int codeOff, final Label[] labels) {\n        for (int i = 0; i < attrs.length; ++i) {\n            if (attrs[i].type.equals(type)) {\n                return attrs[i].read(this, off, len, buf, codeOff, labels);\n            }\n        }\n        return new Attribute(type).read(this, off, len, null, -1, null);\n    }\n\n    // ------------------------------------------------------------------------\n    // Utility methods: low level parsing\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the start index of the constant pool item in {@link #b b}, plus\n     * one. <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param item the index a constant pool item.\n     * @return the start index of the constant pool item in {@link #b b}, plus\n     *         one.\n     */\n    public int getItem(final int item) {\n        return items[item];\n    }\n\n    /**\n     * Reads a byte value in {@link #b b}. <i>This method is intended for\n     * {@link Attribute} sub classes, and is normally not needed by class\n     * generators or adapters.</i>\n     *\n     * @param index the start index of the value to be read in {@link #b b}.\n     * @return the read value.\n     */\n    public int readByte(final int index) {\n        return b[index] & 0xFF;\n    }\n\n    /**\n     * Reads an unsigned short value in {@link #b b}. <i>This method is\n     * intended for {@link Attribute} sub classes, and is normally not needed by\n     * class generators or adapters.</i>\n     *\n     * @param index the start index of the value to be read in {@link #b b}.\n     * @return the read value.\n     */\n    public int readUnsignedShort(final int index) {\n        byte[] b = this.b;\n        return ((b[index] & 0xFF) << 8) | (b[index + 1] & 0xFF);\n    }\n\n    /**\n     * Reads a signed short value in {@link #b b}. <i>This method is intended\n     * for {@link Attribute} sub classes, and is normally not needed by class\n     * generators or adapters.</i>\n     *\n     * @param index the start index of the value to be read in {@link #b b}.\n     * @return the read value.\n     */\n    public short readShort(final int index) {\n        byte[] b = this.b;\n        return (short) (((b[index] & 0xFF) << 8) | (b[index + 1] & 0xFF));\n    }\n\n    /**\n     * Reads a signed int value in {@link #b b}. <i>This method is intended for\n     * {@link Attribute} sub classes, and is normally not needed by class\n     * generators or adapters.</i>\n     *\n     * @param index the start index of the value to be read in {@link #b b}.\n     * @return the read value.\n     */\n    public int readInt(final int index) {\n        byte[] b = this.b;\n        return ((b[index] & 0xFF) << 24) | ((b[index + 1] & 0xFF) << 16) | ((b[index + 2] & 0xFF) << 8) | (b[index + 3] & 0xFF);\n    }\n\n    /**\n     * Reads a signed long value in {@link #b b}. <i>This method is intended\n     * for {@link Attribute} sub classes, and is normally not needed by class\n     * generators or adapters.</i>\n     *\n     * @param index the start index of the value to be read in {@link #b b}.\n     * @return the read value.\n     */\n    public long readLong(final int index) {\n        long l1 = readInt(index);\n        long l0 = readInt(index + 4) & 0xFFFFFFFFL;\n        return (l1 << 32) | l0;\n    }\n\n    /**\n     * Reads an UTF8 string constant pool item in {@link #b b}. <i>This method\n     * is intended for {@link Attribute} sub classes, and is normally not needed\n     * by class generators or adapters.</i>\n     *\n     * @param index the start index of an unsigned short value in {@link #b b},\n     *        whose value is the index of an UTF8 constant pool item.\n     * @param buf buffer to be used to read the item. This buffer must be\n     *        sufficiently large. It is not automatically resized.\n     * @return the String corresponding to the specified UTF8 item.\n     */\n    public String readUTF8(int index, final char[] buf) {\n        int item = readUnsignedShort(index);\n        String s = strings[item];\n        if (s != null) {\n            return s;\n        }\n        index = items[item];\n        return strings[item] = readUTF(index + 2, readUnsignedShort(index), buf);\n    }\n\n    /**\n     * Reads UTF8 string in {@link #b b}.\n     *\n     * @param index start offset of the UTF8 string to be read.\n     * @param utfLen length of the UTF8 string to be read.\n     * @param buf buffer to be used to read the string. This buffer must be\n     *        sufficiently large. It is not automatically resized.\n     * @return the String corresponding to the specified UTF8 string.\n     */\n    private String readUTF(int index, final int utfLen, final char[] buf) {\n        int endIndex = index + utfLen;\n        byte[] b = this.b;\n        int strLen = 0;\n        int c;\n        int st = 0;\n        char cc = 0;\n        while (index < endIndex) {\n            c = b[index++];\n            switch(st) {\n                case 0:\n                    c = c & 0xFF;\n                    if (c < 0x80) {\n                        // 0xxxxxxx\n                        buf[strLen++] = (char) c;\n                    } else if (c < 0xE0 && c > 0xBF) {\n                        // 110x xxxx 10xx xxxx\n                        cc = (char) (c & 0x1F);\n                        st = 1;\n                    } else {\n                        // 1110 xxxx 10xx xxxx 10xx xxxx\n                        cc = (char) (c & 0x0F);\n                        st = 2;\n                    }\n                    break;\n                case // byte 2 of 2-byte char or byte 3 of 3-byte char\n                1:\n                    buf[strLen++] = (char) ((cc << 6) | (c & 0x3F));\n                    st = 0;\n                    break;\n                case // byte 2 of 3-byte char\n                2:\n                    cc = (char) ((cc << 6) | (c & 0x3F));\n                    st = 1;\n                    break;\n            }\n        }\n        return new String(buf, 0, strLen);\n    }\n\n    /**\n     * Reads a class constant pool item in {@link #b b}. <i>This method is\n     * intended for {@link Attribute} sub classes, and is normally not needed by\n     * class generators or adapters.</i>\n     *\n     * @param index the start index of an unsigned short value in {@link #b b},\n     *        whose value is the index of a class constant pool item.\n     * @param buf buffer to be used to read the item. This buffer must be\n     *        sufficiently large. It is not automatically resized.\n     * @return the String corresponding to the specified class item.\n     */\n    public String readClass(final int index, final char[] buf) {\n        // computes the start index of the CONSTANT_Class item in b\n        // and reads the CONSTANT_Utf8 item designated by\n        // the first two bytes of this CONSTANT_Class item\n        return readUTF8(items[readUnsignedShort(index)], buf);\n    }\n\n    /**\n     * Reads a numeric or string constant pool item in {@link #b b}. <i>This\n     * method is intended for {@link Attribute} sub classes, and is normally not\n     * needed by class generators or adapters.</i>\n     *\n     * @param item the index of a constant pool item.\n     * @param buf buffer to be used to read the item. This buffer must be\n     *        sufficiently large. It is not automatically resized.\n     * @return the {@link Integer}, {@link Float}, {@link Long},\n     *         {@link Double}, {@link String} or {@link Type} corresponding to\n     *         the given constant pool item.\n     */\n    public Object readConst(final int item, final char[] buf) {\n        int index = items[item];\n        switch(b[index - 1]) {\n            case ClassWriter.INT:\n                return new Integer(readInt(index));\n            case ClassWriter.FLOAT:\n                return new Float(Float.intBitsToFloat(readInt(index)));\n            case ClassWriter.LONG:\n                return new Long(readLong(index));\n            case ClassWriter.DOUBLE:\n                return new Double(Double.longBitsToDouble(readLong(index)));\n            case ClassWriter.CLASS:\n                return Type.getObjectType(readUTF8(index, buf));\n            // case ClassWriter.STR:\n            default:\n                return readUTF8(index, buf);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/ClassReaderTest3.java",
		"test_prompt": "// ClassReaderTest3.java\npackage org.objectweb.asm.jip;\n\nimport java.io.InputStream;\nimport java.io.IOException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassReader}.\n* It contains ten unit test cases for the {@link ClassReader#readInt(int)} method.\n*/\nclass ClassReaderTest3 {"
	},
	{
		"original_code": "// ClassReader.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\nimport java.io.InputStream;\nimport java.io.IOException;\n\n/**\n * A Java class parser to make a {@link ClassVisitor} visit an existing class.\n * This class parses a byte array conforming to the Java class file format and\n * calls the appropriate visit methods of a given class visitor for each field,\n * method and bytecode instruction encountered.\n *\n * @author Eric Bruneton\n * @author Eugene Kuleshov\n */\npublic class ClassReader {\n\n    /**\n     * True to enable signatures support.\n     */\n    static final boolean SIGNATURES = true;\n\n    /**\n     * True to enable annotations support.\n     */\n    static final boolean ANNOTATIONS = true;\n\n    /**\n     * True to enable stack map frames support.\n     */\n    static final boolean FRAMES = true;\n\n    /**\n     * True to enable bytecode writing support.\n     */\n    static final boolean WRITER = true;\n\n    /**\n     * True to enable JSR_W and GOTO_W support.\n     */\n    static final boolean RESIZE = true;\n\n    /**\n     * Flag to skip method code. If this class is set <code>CODE</code>\n     * attribute won't be visited. This can be used, for example, to retrieve\n     * annotations for methods and method parameters.\n     */\n    public static final int SKIP_CODE = 1;\n\n    /**\n     * Flag to skip the debug information in the class. If this flag is set the\n     * debug information of the class is not visited, i.e. the\n     * {@link MethodVisitor#visitLocalVariable visitLocalVariable} and\n     * {@link MethodVisitor#visitLineNumber visitLineNumber} methods will not be\n     * called.\n     */\n    public static final int SKIP_DEBUG = 2;\n\n    /**\n     * Flag to skip the stack map frames in the class. If this flag is set the\n     * stack map frames of the class is not visited, i.e. the\n     * {@link MethodVisitor#visitFrame visitFrame} method will not be called.\n     * This flag is useful when the {@link ClassWriter#COMPUTE_FRAMES} option is\n     * used: it avoids visiting frames that will be ignored and recomputed from\n     * scratch in the class writer.\n     */\n    public static final int SKIP_FRAMES = 4;\n\n    /**\n     * Flag to expand the stack map frames. By default stack map frames are\n     * visited in their original format (i.e. \"expanded\" for classes whose\n     * version is less than V1_6, and \"compressed\" for the other classes). If\n     * this flag is set, stack map frames are always visited in expanded format\n     * (this option adds a decompression/recompression step in ClassReader and\n     * ClassWriter which degrades performances quite a lot).\n     */\n    public static final int EXPAND_FRAMES = 8;\n\n    /**\n     * The class to be parsed. <i>The content of this array must not be\n     * modified. This field is intended for {@link Attribute} sub classes, and\n     * is normally not needed by class generators or adapters.</i>\n     */\n    public final byte[] b;\n\n    /**\n     * The start index of each constant pool item in {@link #b b}, plus one.\n     * The one byte offset skips the constant pool item tag that indicates its\n     * type.\n     */\n    private final int[] items;\n\n    /**\n     * The String objects corresponding to the CONSTANT_Utf8 items. This cache\n     * avoids multiple parsing of a given CONSTANT_Utf8 constant pool item,\n     * which GREATLY improves performances (by a factor 2 to 3). This caching\n     * strategy could be extended to all constant pool items, but its benefit\n     * would not be so great for these items (because they are much less\n     * expensive to parse than CONSTANT_Utf8 items).\n     */\n    private final String[] strings;\n\n    /**\n     * Maximum length of the strings contained in the constant pool of the\n     * class.\n     */\n    private final int maxStringLength;\n\n    /**\n     * Start index of the class header information (access, name...) in\n     * {@link #b b}.\n     */\n    public final int header;\n\n    // ------------------------------------------------------------------------\n    // Constructors\n    // ------------------------------------------------------------------------\n    /**\n     * Constructs a new {@link ClassReader} object.\n     *\n     * @param b the bytecode of the class to be read.\n     */\n    public ClassReader(final byte[] b) {\n        this(b, 0, b.length);\n    }\n\n    /**\n     * Constructs a new {@link ClassReader} object.\n     *\n     * @param b the bytecode of the class to be read.\n     * @param off the start offset of the class data.\n     * @param len the length of the class data.\n     */\n    public ClassReader(final byte[] b, final int off, final int len) {\n        this.b = b;\n        // parses the constant pool\n        items = new int[readUnsignedShort(off + 8)];\n        int n = items.length;\n        strings = new String[n];\n        int max = 0;\n        int index = off + 10;\n        for (int i = 1; i < n; ++i) {\n            items[i] = index + 1;\n            int size;\n            switch(b[index]) {\n                case ClassWriter.FIELD:\n                case ClassWriter.METH:\n                case ClassWriter.IMETH:\n                case ClassWriter.INT:\n                case ClassWriter.FLOAT:\n                case ClassWriter.NAME_TYPE:\n                    size = 5;\n                    break;\n                case ClassWriter.LONG:\n                case ClassWriter.DOUBLE:\n                    size = 9;\n                    ++i;\n                    break;\n                case ClassWriter.UTF8:\n                    size = 3 + readUnsignedShort(index + 1);\n                    if (size > max) {\n                        max = size;\n                    }\n                    break;\n                // case ClassWriter.CLASS:\n                // case ClassWriter.STR:\n                default:\n                    size = 3;\n                    break;\n            }\n            index += size;\n        }\n        maxStringLength = max;\n        // the class header information starts just after the constant pool\n        header = index;\n    }\n\n    /**\n     * Returns the class's access flags (see {@link Opcodes}). This value may\n     * not reflect Deprecated and Synthetic flags when bytecode is before 1.5\n     * and those flags are represented by attributes.\n     *\n     * @return the class access flags\n     *\n     * @see ClassVisitor#visit(int, int, String, String, String, String[])\n     */\n    public int getAccess() {\n        return readUnsignedShort(header);\n    }\n\n    /**\n     * Returns the internal name of the class (see\n     * {@link Type#getInternalName() getInternalName}).\n     *\n     * @return the internal class name\n     *\n     * @see ClassVisitor#visit(int, int, String, String, String, String[])\n     */\n    public String getClassName() {\n        return readClass(header + 2, new char[maxStringLength]);\n    }\n\n    /**\n     * Returns the internal of name of the super class (see\n     * {@link Type#getInternalName() getInternalName}). For interfaces, the\n     * super class is {@link Object}.\n     *\n     * @return the internal name of super class, or <tt>null</tt> for\n     *         {@link Object} class.\n     *\n     * @see ClassVisitor#visit(int, int, String, String, String, String[])\n     */\n    public String getSuperName() {\n        int n = items[readUnsignedShort(header + 4)];\n        return n == 0 ? null : readUTF8(n, new char[maxStringLength]);\n    }\n\n    /**\n     * Returns the internal names of the class's interfaces (see\n     * {@link Type#getInternalName() getInternalName}).\n     *\n     * @return the array of internal names for all implemented interfaces or\n     *         <tt>null</tt>.\n     *\n     * @see ClassVisitor#visit(int, int, String, String, String, String[])\n     */\n    public String[] getInterfaces() {\n        int index = header + 6;\n        int n = readUnsignedShort(index);\n        String[] interfaces = new String[n];\n        if (n > 0) {\n            char[] buf = new char[maxStringLength];\n            for (int i = 0; i < n; ++i) {\n                index += 2;\n                interfaces[i] = readClass(index, buf);\n            }\n        }\n        return interfaces;\n    }\n\n    /**\n     * Copies the constant pool data into the given {@link ClassWriter}. Should\n     * be called before the {@link #accept(ClassVisitor,int)} method.\n     *\n     * @param classWriter the {@link ClassWriter} to copy constant pool into.\n     */\n    void copyPool(final ClassWriter classWriter) {\n        char[] buf = new char[maxStringLength];\n        int ll = items.length;\n        Item[] items2 = new Item[ll];\n        for (int i = 1; i < ll; i++) {\n            int index = items[i];\n            int tag = b[index - 1];\n            Item item = new Item(i);\n            int nameType;\n            switch(tag) {\n                case ClassWriter.FIELD:\n                case ClassWriter.METH:\n                case ClassWriter.IMETH:\n                    nameType = items[readUnsignedShort(index + 2)];\n                    item.set(tag, readClass(index, buf), readUTF8(nameType, buf), readUTF8(nameType + 2, buf));\n                    break;\n                case ClassWriter.INT:\n                    item.set(readInt(index));\n                    break;\n                case ClassWriter.FLOAT:\n                    item.set(Float.intBitsToFloat(readInt(index)));\n                    break;\n                case ClassWriter.NAME_TYPE:\n                    item.set(tag, readUTF8(index, buf), readUTF8(index + 2, buf), null);\n                    break;\n                case ClassWriter.LONG:\n                    item.set(readLong(index));\n                    ++i;\n                    break;\n                case ClassWriter.DOUBLE:\n                    item.set(Double.longBitsToDouble(readLong(index)));\n                    ++i;\n                    break;\n                case ClassWriter.UTF8:\n                    {\n                        String s = strings[i];\n                        if (s == null) {\n                            index = items[i];\n                            s = strings[i] = readUTF(index + 2, readUnsignedShort(index), buf);\n                        }\n                        item.set(tag, s, null, null);\n                    }\n                    break;\n                // case ClassWriter.STR:\n                // case ClassWriter.CLASS:\n                default:\n                    item.set(tag, readUTF8(index, buf), null, null);\n                    break;\n            }\n            int index2 = item.hashCode % items2.length;\n            item.next = items2[index2];\n            items2[index2] = item;\n        }\n        int off = items[1] - 1;\n        classWriter.pool.putByteArray(b, off, header - off);\n        classWriter.items = items2;\n        classWriter.threshold = (int) (0.75d * ll);\n        classWriter.index = ll;\n    }\n\n    /**\n     * Constructs a new {@link ClassReader} object.\n     *\n     * @param is an input stream from which to read the class.\n     * @throws IOException if a problem occurs during reading.\n     */\n    public ClassReader(final InputStream is) throws IOException {\n        this(readClass(is));\n    }\n\n    /**\n     * Constructs a new {@link ClassReader} object.\n     *\n     * @param name the fully qualified name of the class to be read.\n     * @throws IOException if an exception occurs during reading.\n     */\n    public ClassReader(final String name) throws IOException {\n        this(ClassLoader.getSystemResourceAsStream(name.replace('.', '/') + \".class\"));\n    }\n\n    /**\n     * Reads the bytecode of a class.\n     *\n     * @param is an input stream from which to read the class.\n     * @return the bytecode read from the given input stream.\n     * @throws IOException if a problem occurs during reading.\n     */\n    private static byte[] readClass(final InputStream is) throws IOException {\n        if (is == null) {\n            throw new IOException(\"Class not found\");\n        }\n        byte[] b = new byte[is.available()];\n        int len = 0;\n        while (true) {\n            int n = is.read(b, len, b.length - len);\n            if (n == -1) {\n                if (len < b.length) {\n                    byte[] c = new byte[len];\n                    System.arraycopy(b, 0, c, 0, len);\n                    b = c;\n                }\n                return b;\n            }\n            len += n;\n            if (len == b.length) {\n                int last = is.read();\n                if (last < 0) {\n                    return b;\n                }\n                byte[] c = new byte[b.length + 1000];\n                System.arraycopy(b, 0, c, 0, len);\n                c[len++] = (byte) last;\n                b = c;\n            }\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Public methods\n    // ------------------------------------------------------------------------\n    /**\n     * Makes the given visitor visit the Java class of this {@link ClassReader}.\n     * This class is the one specified in the constructor (see\n     * {@link #ClassReader(byte[]) ClassReader}).\n     *\n     * @param classVisitor the visitor that must visit this class.\n     * @param flags option flags that can be used to modify the default behavior\n     *        of this class. See {@link #SKIP_DEBUG}, {@link #EXPAND_FRAMES},\n     *        {@link #SKIP_FRAMES}, {@link #SKIP_CODE}.\n     */\n    public void accept(final ClassVisitor classVisitor, final int flags) {\n        accept(classVisitor, new Attribute[0], flags);\n    }\n\n    /**\n     * Makes the given visitor visit the Java class of this {@link ClassReader}.\n     * This class is the one specified in the constructor (see\n     * {@link #ClassReader(byte[]) ClassReader}).\n     *\n     * @param classVisitor the visitor that must visit this class.\n     * @param attrs prototypes of the attributes that must be parsed during the\n     *        visit of the class. Any attribute whose type is not equal to the\n     *        type of one the prototypes will not be parsed: its byte array\n     *        value will be passed unchanged to the ClassWriter. <i>This may\n     *        corrupt it if this value contains references to the constant pool,\n     *        or has syntactic or semantic links with a class element that has\n     *        been transformed by a class adapter between the reader and the\n     *        writer</i>.\n     * @param flags option flags that can be used to modify the default behavior\n     *        of this class. See {@link #SKIP_DEBUG}, {@link #EXPAND_FRAMES},\n     *        {@link #SKIP_FRAMES}, {@link #SKIP_CODE}.\n     */\n    public void accept(final ClassVisitor classVisitor, final Attribute[] attrs, final int flags) {\n        // the bytecode array\n        byte[] b = this.b;\n        // buffer used to read strings\n        char[] c = new char[maxStringLength];\n        // loop variables\n        int i, j, k;\n        // indexes in b\n        int u, v, w;\n        Attribute attr;\n        int access;\n        String name;\n        String desc;\n        String attrName;\n        String signature;\n        int anns = 0;\n        int ianns = 0;\n        Attribute cattrs = null;\n        // visits the header\n        u = header;\n        access = readUnsignedShort(u);\n        name = readClass(u + 2, c);\n        v = items[readUnsignedShort(u + 4)];\n        String superClassName = v == 0 ? null : readUTF8(v, c);\n        String[] implementedItfs = new String[readUnsignedShort(u + 6)];\n        w = 0;\n        u += 8;\n        for (i = 0; i < implementedItfs.length; ++i) {\n            implementedItfs[i] = readClass(u, c);\n            u += 2;\n        }\n        boolean skipCode = (flags & SKIP_CODE) != 0;\n        boolean skipDebug = (flags & SKIP_DEBUG) != 0;\n        boolean unzip = (flags & EXPAND_FRAMES) != 0;\n        // skips fields and methods\n        v = u;\n        i = readUnsignedShort(v);\n        v += 2;\n        for (; i > 0; --i) {\n            j = readUnsignedShort(v + 6);\n            v += 8;\n            for (; j > 0; --j) {\n                v += 6 + readInt(v + 2);\n            }\n        }\n        i = readUnsignedShort(v);\n        v += 2;\n        for (; i > 0; --i) {\n            j = readUnsignedShort(v + 6);\n            v += 8;\n            for (; j > 0; --j) {\n                v += 6 + readInt(v + 2);\n            }\n        }\n        // reads the class's attributes\n        signature = null;\n        String sourceFile = null;\n        String sourceDebug = null;\n        String enclosingOwner = null;\n        String enclosingName = null;\n        String enclosingDesc = null;\n        i = readUnsignedShort(v);\n        v += 2;\n        for (; i > 0; --i) {\n            attrName = readUTF8(v, c);\n            // tests are sorted in decreasing frequency order\n            // (based on frequencies observed on typical classes)\n            if (\"SourceFile\".equals(attrName)) {\n                sourceFile = readUTF8(v + 6, c);\n            } else if (\"InnerClasses\".equals(attrName)) {\n                w = v + 6;\n            } else if (\"EnclosingMethod\".equals(attrName)) {\n                enclosingOwner = readClass(v + 6, c);\n                int item = readUnsignedShort(v + 8);\n                if (item != 0) {\n                    enclosingName = readUTF8(items[item], c);\n                    enclosingDesc = readUTF8(items[item] + 2, c);\n                }\n            } else if (SIGNATURES && \"Signature\".equals(attrName)) {\n                signature = readUTF8(v + 6, c);\n            } else if (ANNOTATIONS && \"RuntimeVisibleAnnotations\".equals(attrName)) {\n                anns = v + 6;\n            } else if (\"Deprecated\".equals(attrName)) {\n                access |= Opcodes.ACC_DEPRECATED;\n            } else if (\"Synthetic\".equals(attrName)) {\n                access |= Opcodes.ACC_SYNTHETIC;\n            } else if (\"SourceDebugExtension\".equals(attrName)) {\n                int len = readInt(v + 2);\n                sourceDebug = readUTF(v + 6, len, new char[len]);\n            } else if (ANNOTATIONS && \"RuntimeInvisibleAnnotations\".equals(attrName)) {\n                ianns = v + 6;\n            } else {\n                attr = readAttribute(attrs, attrName, v + 6, readInt(v + 2), c, -1, null);\n                if (attr != null) {\n                    attr.next = cattrs;\n                    cattrs = attr;\n                }\n            }\n            v += 6 + readInt(v + 2);\n        }\n        // calls the visit method\n        classVisitor.visit(readInt(4), access, name, signature, superClassName, implementedItfs);\n        // calls the visitSource method\n        if (!skipDebug && (sourceFile != null || sourceDebug != null)) {\n            classVisitor.visitSource(sourceFile, sourceDebug);\n        }\n        // calls the visitOuterClass method\n        if (enclosingOwner != null) {\n            classVisitor.visitOuterClass(enclosingOwner, enclosingName, enclosingDesc);\n        }\n        // visits the class annotations\n        if (ANNOTATIONS) {\n            for (i = 1; i >= 0; --i) {\n                v = i == 0 ? ianns : anns;\n                if (v != 0) {\n                    j = readUnsignedShort(v);\n                    v += 2;\n                    for (; j > 0; --j) {\n                        v = readAnnotationValues(v + 2, c, true, classVisitor.visitAnnotation(readUTF8(v, c), i != 0));\n                    }\n                }\n            }\n        }\n        // visits the class attributes\n        while (cattrs != null) {\n            attr = cattrs.next;\n            cattrs.next = null;\n            classVisitor.visitAttribute(cattrs);\n            cattrs = attr;\n        }\n        // calls the visitInnerClass method\n        if (w != 0) {\n            i = readUnsignedShort(w);\n            w += 2;\n            for (; i > 0; --i) {\n                classVisitor.visitInnerClass(readUnsignedShort(w) == 0 ? null : readClass(w, c), readUnsignedShort(w + 2) == 0 ? null : readClass(w + 2, c), readUnsignedShort(w + 4) == 0 ? null : readUTF8(w + 4, c), readUnsignedShort(w + 6));\n                w += 8;\n            }\n        }\n        // visits the fields\n        i = readUnsignedShort(u);\n        u += 2;\n        for (; i > 0; --i) {\n            access = readUnsignedShort(u);\n            name = readUTF8(u + 2, c);\n            desc = readUTF8(u + 4, c);\n            // visits the field's attributes and looks for a ConstantValue\n            // attribute\n            int fieldValueItem = 0;\n            signature = null;\n            anns = 0;\n            ianns = 0;\n            cattrs = null;\n            j = readUnsignedShort(u + 6);\n            u += 8;\n            for (; j > 0; --j) {\n                attrName = readUTF8(u, c);\n                // tests are sorted in decreasing frequency order\n                // (based on frequencies observed on typical classes)\n                if (\"ConstantValue\".equals(attrName)) {\n                    fieldValueItem = readUnsignedShort(u + 6);\n                } else if (SIGNATURES && \"Signature\".equals(attrName)) {\n                    signature = readUTF8(u + 6, c);\n                } else if (\"Deprecated\".equals(attrName)) {\n                    access |= Opcodes.ACC_DEPRECATED;\n                } else if (\"Synthetic\".equals(attrName)) {\n                    access |= Opcodes.ACC_SYNTHETIC;\n                } else if (ANNOTATIONS && \"RuntimeVisibleAnnotations\".equals(attrName)) {\n                    anns = u + 6;\n                } else if (ANNOTATIONS && \"RuntimeInvisibleAnnotations\".equals(attrName)) {\n                    ianns = u + 6;\n                } else {\n                    attr = readAttribute(attrs, attrName, u + 6, readInt(u + 2), c, -1, null);\n                    if (attr != null) {\n                        attr.next = cattrs;\n                        cattrs = attr;\n                    }\n                }\n                u += 6 + readInt(u + 2);\n            }\n            // visits the field\n            FieldVisitor fv = classVisitor.visitField(access, name, desc, signature, fieldValueItem == 0 ? null : readConst(fieldValueItem, c));\n            // visits the field annotations and attributes\n            if (fv != null) {\n                if (ANNOTATIONS) {\n                    for (j = 1; j >= 0; --j) {\n                        v = j == 0 ? ianns : anns;\n                        if (v != 0) {\n                            k = readUnsignedShort(v);\n                            v += 2;\n                            for (; k > 0; --k) {\n                                v = readAnnotationValues(v + 2, c, true, fv.visitAnnotation(readUTF8(v, c), j != 0));\n                            }\n                        }\n                    }\n                }\n                while (cattrs != null) {\n                    attr = cattrs.next;\n                    cattrs.next = null;\n                    fv.visitAttribute(cattrs);\n                    cattrs = attr;\n                }\n                fv.visitEnd();\n            }\n        }\n        // visits the methods\n        i = readUnsignedShort(u);\n        u += 2;\n        for (; i > 0; --i) {\n            int u0 = u + 6;\n            access = readUnsignedShort(u);\n            name = readUTF8(u + 2, c);\n            desc = readUTF8(u + 4, c);\n            signature = null;\n            anns = 0;\n            ianns = 0;\n            int dann = 0;\n            int mpanns = 0;\n            int impanns = 0;\n            cattrs = null;\n            v = 0;\n            w = 0;\n            // looks for Code and Exceptions attributes\n            j = readUnsignedShort(u + 6);\n            u += 8;\n            for (; j > 0; --j) {\n                attrName = readUTF8(u, c);\n                int attrSize = readInt(u + 2);\n                u += 6;\n                // tests are sorted in decreasing frequency order\n                // (based on frequencies observed on typical classes)\n                if (\"Code\".equals(attrName)) {\n                    if (!skipCode) {\n                        v = u;\n                    }\n                } else if (\"Exceptions\".equals(attrName)) {\n                    w = u;\n                } else if (SIGNATURES && \"Signature\".equals(attrName)) {\n                    signature = readUTF8(u, c);\n                } else if (\"Deprecated\".equals(attrName)) {\n                    access |= Opcodes.ACC_DEPRECATED;\n                } else if (ANNOTATIONS && \"RuntimeVisibleAnnotations\".equals(attrName)) {\n                    anns = u;\n                } else if (ANNOTATIONS && \"AnnotationDefault\".equals(attrName)) {\n                    dann = u;\n                } else if (\"Synthetic\".equals(attrName)) {\n                    access |= Opcodes.ACC_SYNTHETIC;\n                } else if (ANNOTATIONS && \"RuntimeInvisibleAnnotations\".equals(attrName)) {\n                    ianns = u;\n                } else if (ANNOTATIONS && \"RuntimeVisibleParameterAnnotations\".equals(attrName)) {\n                    mpanns = u;\n                } else if (ANNOTATIONS && \"RuntimeInvisibleParameterAnnotations\".equals(attrName)) {\n                    impanns = u;\n                } else {\n                    attr = readAttribute(attrs, attrName, u, attrSize, c, -1, null);\n                    if (attr != null) {\n                        attr.next = cattrs;\n                        cattrs = attr;\n                    }\n                }\n                u += attrSize;\n            }\n            // reads declared exceptions\n            String[] exceptions;\n            if (w == 0) {\n                exceptions = null;\n            } else {\n                exceptions = new String[readUnsignedShort(w)];\n                w += 2;\n                for (j = 0; j < exceptions.length; ++j) {\n                    exceptions[j] = readClass(w, c);\n                    w += 2;\n                }\n            }\n            // visits the method's code, if any\n            MethodVisitor mv = classVisitor.visitMethod(access, name, desc, signature, exceptions);\n            if (mv != null) {\n                /*\n                 * if the returned MethodVisitor is in fact a MethodWriter, it\n                 * means there is no method adapter between the reader and the\n                 * writer. If, in addition, the writer's constant pool was\n                 * copied from this reader (mw.cw.cr == this), and the signature\n                 * and exceptions of the method have not been changed, then it\n                 * is possible to skip all visit events and just copy the\n                 * original code of the method to the writer (the access, name\n                 * and descriptor can have been changed, this is not important\n                 * since they are not copied as is from the reader).\n                 */\n                if (WRITER && mv instanceof MethodWriter) {\n                    MethodWriter mw = (MethodWriter) mv;\n                    if (mw.cw.cr == this) {\n                        if (signature == mw.signature) {\n                            boolean sameExceptions = false;\n                            if (exceptions == null) {\n                                sameExceptions = mw.exceptionCount == 0;\n                            } else {\n                                if (exceptions.length == mw.exceptionCount) {\n                                    sameExceptions = true;\n                                    for (j = exceptions.length - 1; j >= 0; --j) {\n                                        w -= 2;\n                                        if (mw.exceptions[j] != readUnsignedShort(w)) {\n                                            sameExceptions = false;\n                                            break;\n                                        }\n                                    }\n                                }\n                            }\n                            if (sameExceptions) {\n                                /*\n                                 * we do not copy directly the code into\n                                 * MethodWriter to save a byte array copy\n                                 * operation. The real copy will be done in\n                                 * ClassWriter.toByteArray().\n                                 */\n                                mw.classReaderOffset = u0;\n                                mw.classReaderLength = u - u0;\n                                continue;\n                            }\n                        }\n                    }\n                }\n                if (ANNOTATIONS && dann != 0) {\n                    AnnotationVisitor dv = mv.visitAnnotationDefault();\n                    readAnnotationValue(dann, c, null, dv);\n                    if (dv != null) {\n                        dv.visitEnd();\n                    }\n                }\n                if (ANNOTATIONS) {\n                    for (j = 1; j >= 0; --j) {\n                        w = j == 0 ? ianns : anns;\n                        if (w != 0) {\n                            k = readUnsignedShort(w);\n                            w += 2;\n                            for (; k > 0; --k) {\n                                w = readAnnotationValues(w + 2, c, true, mv.visitAnnotation(readUTF8(w, c), j != 0));\n                            }\n                        }\n                    }\n                }\n                if (ANNOTATIONS && mpanns != 0) {\n                    readParameterAnnotations(mpanns, desc, c, true, mv);\n                }\n                if (ANNOTATIONS && impanns != 0) {\n                    readParameterAnnotations(impanns, desc, c, false, mv);\n                }\n                while (cattrs != null) {\n                    attr = cattrs.next;\n                    cattrs.next = null;\n                    mv.visitAttribute(cattrs);\n                    cattrs = attr;\n                }\n            }\n            if (mv != null && v != 0) {\n                int maxStack = readUnsignedShort(v);\n                int maxLocals = readUnsignedShort(v + 2);\n                int codeLength = readInt(v + 4);\n                v += 8;\n                int codeStart = v;\n                int codeEnd = v + codeLength;\n                mv.visitCode();\n                // 1st phase: finds the labels\n                int label;\n                Label[] labels = new Label[codeLength + 2];\n                readLabel(codeLength + 1, labels);\n                while (v < codeEnd) {\n                    w = v - codeStart;\n                    int opcode = b[v] & 0xFF;\n                    switch(ClassWriter.TYPE[opcode]) {\n                        case ClassWriter.NOARG_INSN:\n                        case ClassWriter.IMPLVAR_INSN:\n                            v += 1;\n                            break;\n                        case ClassWriter.LABEL_INSN:\n                            readLabel(w + readShort(v + 1), labels);\n                            v += 3;\n                            break;\n                        case ClassWriter.LABELW_INSN:\n                            readLabel(w + readInt(v + 1), labels);\n                            v += 5;\n                            break;\n                        case ClassWriter.WIDE_INSN:\n                            opcode = b[v + 1] & 0xFF;\n                            if (opcode == Opcodes.IINC) {\n                                v += 6;\n                            } else {\n                                v += 4;\n                            }\n                            break;\n                        case ClassWriter.TABL_INSN:\n                            // skips 0 to 3 padding bytes*\n                            v = v + 4 - (w & 3);\n                            // reads instruction\n                            readLabel(w + readInt(v), labels);\n                            j = readInt(v + 8) - readInt(v + 4) + 1;\n                            v += 12;\n                            for (; j > 0; --j) {\n                                readLabel(w + readInt(v), labels);\n                                v += 4;\n                            }\n                            break;\n                        case ClassWriter.LOOK_INSN:\n                            // skips 0 to 3 padding bytes*\n                            v = v + 4 - (w & 3);\n                            // reads instruction\n                            readLabel(w + readInt(v), labels);\n                            j = readInt(v + 4);\n                            v += 8;\n                            for (; j > 0; --j) {\n                                readLabel(w + readInt(v + 4), labels);\n                                v += 8;\n                            }\n                            break;\n                        case ClassWriter.VAR_INSN:\n                        case ClassWriter.SBYTE_INSN:\n                        case ClassWriter.LDC_INSN:\n                            v += 2;\n                            break;\n                        case ClassWriter.SHORT_INSN:\n                        case ClassWriter.LDCW_INSN:\n                        case ClassWriter.FIELDORMETH_INSN:\n                        case ClassWriter.TYPE_INSN:\n                        case ClassWriter.IINC_INSN:\n                            v += 3;\n                            break;\n                        case ClassWriter.ITFDYNMETH_INSN:\n                            v += 5;\n                            break;\n                        // case MANA_INSN:\n                        default:\n                            v += 4;\n                            break;\n                    }\n                }\n                // parses the try catch entries\n                j = readUnsignedShort(v);\n                v += 2;\n                for (; j > 0; --j) {\n                    Label start = readLabel(readUnsignedShort(v), labels);\n                    Label end = readLabel(readUnsignedShort(v + 2), labels);\n                    Label handler = readLabel(readUnsignedShort(v + 4), labels);\n                    int type = readUnsignedShort(v + 6);\n                    if (type == 0) {\n                        mv.visitTryCatchBlock(start, end, handler, null);\n                    } else {\n                        mv.visitTryCatchBlock(start, end, handler, readUTF8(items[type], c));\n                    }\n                    v += 8;\n                }\n                // parses the local variable, line number tables, and code\n                // attributes\n                int varTable = 0;\n                int varTypeTable = 0;\n                int stackMap = 0;\n                int stackMapSize = 0;\n                int frameCount = 0;\n                int frameMode = 0;\n                int frameOffset = 0;\n                int frameLocalCount = 0;\n                int frameLocalDiff = 0;\n                int frameStackCount = 0;\n                Object[] frameLocal = null;\n                Object[] frameStack = null;\n                boolean zip = true;\n                cattrs = null;\n                j = readUnsignedShort(v);\n                v += 2;\n                for (; j > 0; --j) {\n                    attrName = readUTF8(v, c);\n                    if (\"LocalVariableTable\".equals(attrName)) {\n                        if (!skipDebug) {\n                            varTable = v + 6;\n                            k = readUnsignedShort(v + 6);\n                            w = v + 8;\n                            for (; k > 0; --k) {\n                                label = readUnsignedShort(w);\n                                if (labels[label] == null) {\n                                    readLabel(label, labels).status |= Label.DEBUG;\n                                }\n                                label += readUnsignedShort(w + 2);\n                                if (labels[label] == null) {\n                                    readLabel(label, labels).status |= Label.DEBUG;\n                                }\n                                w += 10;\n                            }\n                        }\n                    } else if (\"LocalVariableTypeTable\".equals(attrName)) {\n                        varTypeTable = v + 6;\n                    } else if (\"LineNumberTable\".equals(attrName)) {\n                        if (!skipDebug) {\n                            k = readUnsignedShort(v + 6);\n                            w = v + 8;\n                            for (; k > 0; --k) {\n                                label = readUnsignedShort(w);\n                                if (labels[label] == null) {\n                                    readLabel(label, labels).status |= Label.DEBUG;\n                                }\n                                labels[label].line = readUnsignedShort(w + 2);\n                                w += 4;\n                            }\n                        }\n                    } else if (FRAMES && \"StackMapTable\".equals(attrName)) {\n                        if ((flags & SKIP_FRAMES) == 0) {\n                            stackMap = v + 8;\n                            stackMapSize = readInt(v + 2);\n                            frameCount = readUnsignedShort(v + 6);\n                        }\n                        /*\n                         * here we do not extract the labels corresponding to\n                         * the attribute content. This would require a full\n                         * parsing of the attribute, which would need to be\n                         * repeated in the second phase (see below). Instead the\n                         * content of the attribute is read one frame at a time\n                         * (i.e. after a frame has been visited, the next frame\n                         * is read), and the labels it contains are also\n                         * extracted one frame at a time. Thanks to the ordering\n                         * of frames, having only a \"one frame lookahead\" is not\n                         * a problem, i.e. it is not possible to see an offset\n                         * smaller than the offset of the current insn and for\n                         * which no Label exist.\n                         */\n                        /*\n                         * This is not true for UNINITIALIZED type offsets. We\n                         * solve this by parsing the stack map table without a\n                         * full decoding (see below).\n                         */\n                    } else if (FRAMES && \"StackMap\".equals(attrName)) {\n                        if ((flags & SKIP_FRAMES) == 0) {\n                            stackMap = v + 8;\n                            stackMapSize = readInt(v + 2);\n                            frameCount = readUnsignedShort(v + 6);\n                            zip = false;\n                        }\n                        /*\n                         * IMPORTANT! here we assume that the frames are\n                         * ordered, as in the StackMapTable attribute, although\n                         * this is not guaranteed by the attribute format.\n                         */\n                    } else {\n                        for (k = 0; k < attrs.length; ++k) {\n                            if (attrs[k].type.equals(attrName)) {\n                                attr = attrs[k].read(this, v + 6, readInt(v + 2), c, codeStart - 8, labels);\n                                if (attr != null) {\n                                    attr.next = cattrs;\n                                    cattrs = attr;\n                                }\n                            }\n                        }\n                    }\n                    v += 6 + readInt(v + 2);\n                }\n                // 2nd phase: visits each instruction\n                if (FRAMES && stackMap != 0) {\n                    // creates the very first (implicit) frame from the method\n                    // descriptor\n                    frameLocal = new Object[maxLocals];\n                    frameStack = new Object[maxStack];\n                    if (unzip) {\n                        int local = 0;\n                        if ((access & Opcodes.ACC_STATIC) == 0) {\n                            if (\"<init>\".equals(name)) {\n                                frameLocal[local++] = Opcodes.UNINITIALIZED_THIS;\n                            } else {\n                                frameLocal[local++] = readClass(header + 2, c);\n                            }\n                        }\n                        j = 1;\n                        loop: while (true) {\n                            k = j;\n                            switch(desc.charAt(j++)) {\n                                case 'Z':\n                                case 'C':\n                                case 'B':\n                                case 'S':\n                                case 'I':\n                                    frameLocal[local++] = Opcodes.INTEGER;\n                                    break;\n                                case 'F':\n                                    frameLocal[local++] = Opcodes.FLOAT;\n                                    break;\n                                case 'J':\n                                    frameLocal[local++] = Opcodes.LONG;\n                                    break;\n                                case 'D':\n                                    frameLocal[local++] = Opcodes.DOUBLE;\n                                    break;\n                                case '[':\n                                    while (desc.charAt(j) == '[') {\n                                        ++j;\n                                    }\n                                    if (desc.charAt(j) == 'L') {\n                                        ++j;\n                                        while (desc.charAt(j) != ';') {\n                                            ++j;\n                                        }\n                                    }\n                                    frameLocal[local++] = desc.substring(k, ++j);\n                                    break;\n                                case 'L':\n                                    while (desc.charAt(j) != ';') {\n                                        ++j;\n                                    }\n                                    frameLocal[local++] = desc.substring(k + 1, j++);\n                                    break;\n                                default:\n                                    break loop;\n                            }\n                        }\n                        frameLocalCount = local;\n                    }\n                    /*\n                     * for the first explicit frame the offset is not\n                     * offset_delta + 1 but only offset_delta; setting the\n                     * implicit frame offset to -1 allow the use of the\n                     * \"offset_delta + 1\" rule in all cases\n                     */\n                    frameOffset = -1;\n                    /*\n                     * Finds labels for UNINITIALIZED frame types. Instead of\n                     * decoding each element of the stack map table, we look\n                     * for 3 consecutive bytes that \"look like\" an UNINITIALIZED\n                     * type (tag 8, offset within code bounds, NEW instruction\n                     * at this offset). We may find false positives (i.e. not \n                     * real UNINITIALIZED types), but this should be rare, and \n                     * the only consequence will be the creation of an unneeded \n                     * label. This is better than creating a label for each NEW\n                     * instruction, and faster than fully decoding the whole \n                     * stack map table.\n                     */\n                    for (j = stackMap; j < stackMap + stackMapSize - 2; ++j) {\n                        if (b[j] == 8) {\n                            // UNINITIALIZED FRAME TYPE\n                            k = readUnsignedShort(j + 1);\n                            if (k >= 0 && k < codeLength) {\n                                // potential offset\n                                if ((b[codeStart + k] & 0xFF) == Opcodes.NEW) {\n                                    // NEW at this offset\n                                    readLabel(k, labels);\n                                }\n                            }\n                        }\n                    }\n                }\n                v = codeStart;\n                Label l;\n                while (v < codeEnd) {\n                    w = v - codeStart;\n                    l = labels[w];\n                    if (l != null) {\n                        mv.visitLabel(l);\n                        if (!skipDebug && l.line > 0) {\n                            mv.visitLineNumber(l.line, l);\n                        }\n                    }\n                    while (FRAMES && frameLocal != null && (frameOffset == w || frameOffset == -1)) {\n                        // if there is a frame for this offset,\n                        // makes the visitor visit it,\n                        // and reads the next frame if there is one.\n                        if (!zip || unzip) {\n                            mv.visitFrame(Opcodes.F_NEW, frameLocalCount, frameLocal, frameStackCount, frameStack);\n                        } else if (frameOffset != -1) {\n                            mv.visitFrame(frameMode, frameLocalDiff, frameLocal, frameStackCount, frameStack);\n                        }\n                        if (frameCount > 0) {\n                            int tag, delta, n;\n                            if (zip) {\n                                tag = b[stackMap++] & 0xFF;\n                            } else {\n                                tag = MethodWriter.FULL_FRAME;\n                                frameOffset = -1;\n                            }\n                            frameLocalDiff = 0;\n                            if (tag < MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME) {\n                                delta = tag;\n                                frameMode = Opcodes.F_SAME;\n                                frameStackCount = 0;\n                            } else if (tag < MethodWriter.RESERVED) {\n                                delta = tag - MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME;\n                                stackMap = readFrameType(frameStack, 0, stackMap, c, labels);\n                                frameMode = Opcodes.F_SAME1;\n                                frameStackCount = 1;\n                            } else {\n                                delta = readUnsignedShort(stackMap);\n                                stackMap += 2;\n                                if (tag == MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {\n                                    stackMap = readFrameType(frameStack, 0, stackMap, c, labels);\n                                    frameMode = Opcodes.F_SAME1;\n                                    frameStackCount = 1;\n                                } else if (tag >= MethodWriter.CHOP_FRAME && tag < MethodWriter.SAME_FRAME_EXTENDED) {\n                                    frameMode = Opcodes.F_CHOP;\n                                    frameLocalDiff = MethodWriter.SAME_FRAME_EXTENDED - tag;\n                                    frameLocalCount -= frameLocalDiff;\n                                    frameStackCount = 0;\n                                } else if (tag == MethodWriter.SAME_FRAME_EXTENDED) {\n                                    frameMode = Opcodes.F_SAME;\n                                    frameStackCount = 0;\n                                } else if (tag < MethodWriter.FULL_FRAME) {\n                                    j = unzip ? frameLocalCount : 0;\n                                    for (k = tag - MethodWriter.SAME_FRAME_EXTENDED; k > 0; k--) {\n                                        stackMap = readFrameType(frameLocal, j++, stackMap, c, labels);\n                                    }\n                                    frameMode = Opcodes.F_APPEND;\n                                    frameLocalDiff = tag - MethodWriter.SAME_FRAME_EXTENDED;\n                                    frameLocalCount += frameLocalDiff;\n                                    frameStackCount = 0;\n                                } else {\n                                    // if (tag == FULL_FRAME) {\n                                    frameMode = Opcodes.F_FULL;\n                                    n = frameLocalDiff = frameLocalCount = readUnsignedShort(stackMap);\n                                    stackMap += 2;\n                                    for (j = 0; n > 0; n--) {\n                                        stackMap = readFrameType(frameLocal, j++, stackMap, c, labels);\n                                    }\n                                    n = frameStackCount = readUnsignedShort(stackMap);\n                                    stackMap += 2;\n                                    for (j = 0; n > 0; n--) {\n                                        stackMap = readFrameType(frameStack, j++, stackMap, c, labels);\n                                    }\n                                }\n                            }\n                            frameOffset += delta + 1;\n                            readLabel(frameOffset, labels);\n                            --frameCount;\n                        } else {\n                            frameLocal = null;\n                        }\n                    }\n                    int opcode = b[v] & 0xFF;\n                    switch(ClassWriter.TYPE[opcode]) {\n                        case ClassWriter.NOARG_INSN:\n                            mv.visitInsn(opcode);\n                            v += 1;\n                            break;\n                        case ClassWriter.IMPLVAR_INSN:\n                            if (opcode > Opcodes.ISTORE) {\n                                // ISTORE_0\n                                opcode -= 59;\n                                mv.visitVarInsn(Opcodes.ISTORE + (opcode >> 2), opcode & 0x3);\n                            } else {\n                                // ILOAD_0\n                                opcode -= 26;\n                                mv.visitVarInsn(Opcodes.ILOAD + (opcode >> 2), opcode & 0x3);\n                            }\n                            v += 1;\n                            break;\n                        case ClassWriter.LABEL_INSN:\n                            mv.visitJumpInsn(opcode, labels[w + readShort(v + 1)]);\n                            v += 3;\n                            break;\n                        case ClassWriter.LABELW_INSN:\n                            mv.visitJumpInsn(opcode - 33, labels[w + readInt(v + 1)]);\n                            v += 5;\n                            break;\n                        case ClassWriter.WIDE_INSN:\n                            opcode = b[v + 1] & 0xFF;\n                            if (opcode == Opcodes.IINC) {\n                                mv.visitIincInsn(readUnsignedShort(v + 2), readShort(v + 4));\n                                v += 6;\n                            } else {\n                                mv.visitVarInsn(opcode, readUnsignedShort(v + 2));\n                                v += 4;\n                            }\n                            break;\n                        case ClassWriter.TABL_INSN:\n                            // skips 0 to 3 padding bytes\n                            v = v + 4 - (w & 3);\n                            // reads instruction\n                            label = w + readInt(v);\n                            int min = readInt(v + 4);\n                            int max = readInt(v + 8);\n                            v += 12;\n                            Label[] table = new Label[max - min + 1];\n                            for (j = 0; j < table.length; ++j) {\n                                table[j] = labels[w + readInt(v)];\n                                v += 4;\n                            }\n                            mv.visitTableSwitchInsn(min, max, labels[label], table);\n                            break;\n                        case ClassWriter.LOOK_INSN:\n                            // skips 0 to 3 padding bytes\n                            v = v + 4 - (w & 3);\n                            // reads instruction\n                            label = w + readInt(v);\n                            j = readInt(v + 4);\n                            v += 8;\n                            int[] keys = new int[j];\n                            Label[] values = new Label[j];\n                            for (j = 0; j < keys.length; ++j) {\n                                keys[j] = readInt(v);\n                                values[j] = labels[w + readInt(v + 4)];\n                                v += 8;\n                            }\n                            mv.visitLookupSwitchInsn(labels[label], keys, values);\n                            break;\n                        case ClassWriter.VAR_INSN:\n                            mv.visitVarInsn(opcode, b[v + 1] & 0xFF);\n                            v += 2;\n                            break;\n                        case ClassWriter.SBYTE_INSN:\n                            mv.visitIntInsn(opcode, b[v + 1]);\n                            v += 2;\n                            break;\n                        case ClassWriter.SHORT_INSN:\n                            mv.visitIntInsn(opcode, readShort(v + 1));\n                            v += 3;\n                            break;\n                        case ClassWriter.LDC_INSN:\n                            mv.visitLdcInsn(readConst(b[v + 1] & 0xFF, c));\n                            v += 2;\n                            break;\n                        case ClassWriter.LDCW_INSN:\n                            mv.visitLdcInsn(readConst(readUnsignedShort(v + 1), c));\n                            v += 3;\n                            break;\n                        case ClassWriter.FIELDORMETH_INSN:\n                        case ClassWriter.ITFDYNMETH_INSN:\n                            int cpIndex = items[readUnsignedShort(v + 1)];\n                            String iowner;\n                            // INVOKEDYNAMIC is receiverless\n                            if (opcode == Opcodes.INVOKEDYNAMIC) {\n                                iowner = Opcodes.INVOKEDYNAMIC_OWNER;\n                            } else {\n                                iowner = readClass(cpIndex, c);\n                                cpIndex = items[readUnsignedShort(cpIndex + 2)];\n                            }\n                            String iname = readUTF8(cpIndex, c);\n                            String idesc = readUTF8(cpIndex + 2, c);\n                            if (opcode < Opcodes.INVOKEVIRTUAL) {\n                                mv.visitFieldInsn(opcode, iowner, iname, idesc);\n                            } else {\n                                mv.visitMethodInsn(opcode, iowner, iname, idesc);\n                            }\n                            if (opcode == Opcodes.INVOKEINTERFACE || opcode == Opcodes.INVOKEDYNAMIC) {\n                                v += 5;\n                            } else {\n                                v += 3;\n                            }\n                            break;\n                        case ClassWriter.TYPE_INSN:\n                            mv.visitTypeInsn(opcode, readClass(v + 1, c));\n                            v += 3;\n                            break;\n                        case ClassWriter.IINC_INSN:\n                            mv.visitIincInsn(b[v + 1] & 0xFF, b[v + 2]);\n                            v += 3;\n                            break;\n                        // case MANA_INSN:\n                        default:\n                            mv.visitMultiANewArrayInsn(readClass(v + 1, c), b[v + 3] & 0xFF);\n                            v += 4;\n                            break;\n                    }\n                }\n                l = labels[codeEnd - codeStart];\n                if (l != null) {\n                    mv.visitLabel(l);\n                }\n                // visits the local variable tables\n                if (!skipDebug && varTable != 0) {\n                    int[] typeTable = null;\n                    if (varTypeTable != 0) {\n                        k = readUnsignedShort(varTypeTable) * 3;\n                        w = varTypeTable + 2;\n                        typeTable = new int[k];\n                        while (k > 0) {\n                            // signature\n                            typeTable[--k] = w + 6;\n                            // index\n                            typeTable[--k] = readUnsignedShort(w + 8);\n                            // start\n                            typeTable[--k] = readUnsignedShort(w);\n                            w += 10;\n                        }\n                    }\n                    k = readUnsignedShort(varTable);\n                    w = varTable + 2;\n                    for (; k > 0; --k) {\n                        int start = readUnsignedShort(w);\n                        int length = readUnsignedShort(w + 2);\n                        int index = readUnsignedShort(w + 8);\n                        String vsignature = null;\n                        if (typeTable != null) {\n                            for (int a = 0; a < typeTable.length; a += 3) {\n                                if (typeTable[a] == start && typeTable[a + 1] == index) {\n                                    vsignature = readUTF8(typeTable[a + 2], c);\n                                    break;\n                                }\n                            }\n                        }\n                        mv.visitLocalVariable(readUTF8(w + 4, c), readUTF8(w + 6, c), vsignature, labels[start], labels[start + length], index);\n                        w += 10;\n                    }\n                }\n                // visits the other attributes\n                while (cattrs != null) {\n                    attr = cattrs.next;\n                    cattrs.next = null;\n                    mv.visitAttribute(cattrs);\n                    cattrs = attr;\n                }\n                // visits the max stack and max locals values\n                mv.visitMaxs(maxStack, maxLocals);\n            }\n            if (mv != null) {\n                mv.visitEnd();\n            }\n        }\n        // visits the end of the class\n        classVisitor.visitEnd();\n    }\n\n    /**\n     * Reads parameter annotations and makes the given visitor visit them.\n     *\n     * @param v start offset in {@link #b b} of the annotations to be read.\n     * @param desc the method descriptor.\n     * @param buf buffer to be used to call {@link #readUTF8 readUTF8},\n     *        {@link #readClass(int,char[]) readClass} or\n     *        {@link #readConst readConst}.\n     * @param visible <tt>true</tt> if the annotations to be read are visible\n     *        at runtime.\n     * @param mv the visitor that must visit the annotations.\n     */\n    private void readParameterAnnotations(int v, final String desc, final char[] buf, final boolean visible, final MethodVisitor mv) {\n        int i;\n        int n = b[v++] & 0xFF;\n        // workaround for a bug in javac (javac compiler generates a parameter\n        // annotation array whose size is equal to the number of parameters in\n        // the Java source file, while it should generate an array whose size is\n        // equal to the number of parameters in the method descriptor - which\n        // includes the synthetic parameters added by the compiler). This work-\n        // around supposes that the synthetic parameters are the first ones.\n        int synthetics = Type.getArgumentTypes(desc).length - n;\n        AnnotationVisitor av;\n        for (i = 0; i < synthetics; ++i) {\n            // virtual annotation to detect synthetic parameters in MethodWriter\n            av = mv.visitParameterAnnotation(i, \"Ljava/lang/Synthetic;\", false);\n            if (av != null) {\n                av.visitEnd();\n            }\n        }\n        for (; i < n + synthetics; ++i) {\n            int j = readUnsignedShort(v);\n            v += 2;\n            for (; j > 0; --j) {\n                av = mv.visitParameterAnnotation(i, readUTF8(v, buf), visible);\n                v = readAnnotationValues(v + 2, buf, true, av);\n            }\n        }\n    }\n\n    /**\n     * Reads the values of an annotation and makes the given visitor visit them.\n     *\n     * @param v the start offset in {@link #b b} of the values to be read\n     *        (including the unsigned short that gives the number of values).\n     * @param buf buffer to be used to call {@link #readUTF8 readUTF8},\n     *        {@link #readClass(int,char[]) readClass} or\n     *        {@link #readConst readConst}.\n     * @param named if the annotation values are named or not.\n     * @param av the visitor that must visit the values.\n     * @return the end offset of the annotation values.\n     */\n    private int readAnnotationValues(int v, final char[] buf, final boolean named, final AnnotationVisitor av) {\n        int i = readUnsignedShort(v);\n        v += 2;\n        if (named) {\n            for (; i > 0; --i) {\n                v = readAnnotationValue(v + 2, buf, readUTF8(v, buf), av);\n            }\n        } else {\n            for (; i > 0; --i) {\n                v = readAnnotationValue(v, buf, null, av);\n            }\n        }\n        if (av != null) {\n            av.visitEnd();\n        }\n        return v;\n    }\n\n    /**\n     * Reads a value of an annotation and makes the given visitor visit it.\n     *\n     * @param v the start offset in {@link #b b} of the value to be read (<i>not\n     *        including the value name constant pool index</i>).\n     * @param buf buffer to be used to call {@link #readUTF8 readUTF8},\n     *        {@link #readClass(int,char[]) readClass} or\n     *        {@link #readConst readConst}.\n     * @param name the name of the value to be read.\n     * @param av the visitor that must visit the value.\n     * @return the end offset of the annotation value.\n     */\n    private int readAnnotationValue(int v, final char[] buf, final String name, final AnnotationVisitor av) {\n        int i;\n        if (av == null) {\n            switch(b[v] & 0xFF) {\n                case // enum_const_value\n                'e':\n                    return v + 5;\n                case // annotation_value\n                '@':\n                    return readAnnotationValues(v + 3, buf, true, null);\n                case // array_value\n                '[':\n                    return readAnnotationValues(v + 1, buf, false, null);\n                default:\n                    return v + 3;\n            }\n        }\n        switch(b[v++] & 0xFF) {\n            // pointer to CONSTANT_Integer\n            case 'I':\n            // pointer to CONSTANT_Long\n            case 'J':\n            // pointer to CONSTANT_Float\n            case 'F':\n            case // pointer to CONSTANT_Double\n            'D':\n                av.visit(name, readConst(readUnsignedShort(v), buf));\n                v += 2;\n                break;\n            case // pointer to CONSTANT_Byte\n            'B':\n                av.visit(name, new Byte((byte) readInt(items[readUnsignedShort(v)])));\n                v += 2;\n                break;\n            case // pointer to CONSTANT_Boolean\n            'Z':\n                av.visit(name, readInt(items[readUnsignedShort(v)]) == 0 ? Boolean.FALSE : Boolean.TRUE);\n                v += 2;\n                break;\n            case // pointer to CONSTANT_Short\n            'S':\n                av.visit(name, new Short((short) readInt(items[readUnsignedShort(v)])));\n                v += 2;\n                break;\n            case // pointer to CONSTANT_Char\n            'C':\n                av.visit(name, new Character((char) readInt(items[readUnsignedShort(v)])));\n                v += 2;\n                break;\n            case // pointer to CONSTANT_Utf8\n            's':\n                av.visit(name, readUTF8(v, buf));\n                v += 2;\n                break;\n            case // enum_const_value\n            'e':\n                av.visitEnum(name, readUTF8(v, buf), readUTF8(v + 2, buf));\n                v += 4;\n                break;\n            case // class_info\n            'c':\n                av.visit(name, Type.getType(readUTF8(v, buf)));\n                v += 2;\n                break;\n            case // annotation_value\n            '@':\n                v = readAnnotationValues(v + 2, buf, true, av.visitAnnotation(name, readUTF8(v, buf)));\n                break;\n            case // array_value\n            '[':\n                int size = readUnsignedShort(v);\n                v += 2;\n                if (size == 0) {\n                    return readAnnotationValues(v - 2, buf, false, av.visitArray(name));\n                }\n                switch(this.b[v++] & 0xFF) {\n                    case 'B':\n                        byte[] bv = new byte[size];\n                        for (i = 0; i < size; i++) {\n                            bv[i] = (byte) readInt(items[readUnsignedShort(v)]);\n                            v += 3;\n                        }\n                        av.visit(name, bv);\n                        --v;\n                        break;\n                    case 'Z':\n                        boolean[] zv = new boolean[size];\n                        for (i = 0; i < size; i++) {\n                            zv[i] = readInt(items[readUnsignedShort(v)]) != 0;\n                            v += 3;\n                        }\n                        av.visit(name, zv);\n                        --v;\n                        break;\n                    case 'S':\n                        short[] sv = new short[size];\n                        for (i = 0; i < size; i++) {\n                            sv[i] = (short) readInt(items[readUnsignedShort(v)]);\n                            v += 3;\n                        }\n                        av.visit(name, sv);\n                        --v;\n                        break;\n                    case 'C':\n                        char[] cv = new char[size];\n                        for (i = 0; i < size; i++) {\n                            cv[i] = (char) readInt(items[readUnsignedShort(v)]);\n                            v += 3;\n                        }\n                        av.visit(name, cv);\n                        --v;\n                        break;\n                    case 'I':\n                        int[] iv = new int[size];\n                        for (i = 0; i < size; i++) {\n                            iv[i] = readInt(items[readUnsignedShort(v)]);\n                            v += 3;\n                        }\n                        av.visit(name, iv);\n                        --v;\n                        break;\n                    case 'J':\n                        long[] lv = new long[size];\n                        for (i = 0; i < size; i++) {\n                            lv[i] = readLong(items[readUnsignedShort(v)]);\n                            v += 3;\n                        }\n                        av.visit(name, lv);\n                        --v;\n                        break;\n                    case 'F':\n                        float[] fv = new float[size];\n                        for (i = 0; i < size; i++) {\n                            fv[i] = Float.intBitsToFloat(readInt(items[readUnsignedShort(v)]));\n                            v += 3;\n                        }\n                        av.visit(name, fv);\n                        --v;\n                        break;\n                    case 'D':\n                        double[] dv = new double[size];\n                        for (i = 0; i < size; i++) {\n                            dv[i] = Double.longBitsToDouble(readLong(items[readUnsignedShort(v)]));\n                            v += 3;\n                        }\n                        av.visit(name, dv);\n                        --v;\n                        break;\n                    default:\n                        v = readAnnotationValues(v - 3, buf, false, av.visitArray(name));\n                }\n        }\n        return v;\n    }\n\n    private int readFrameType(final Object[] frame, final int index, int v, final char[] buf, final Label[] labels) {\n        int type = b[v++] & 0xFF;\n        switch(type) {\n            case 0:\n                frame[index] = Opcodes.TOP;\n                break;\n            case 1:\n                frame[index] = Opcodes.INTEGER;\n                break;\n            case 2:\n                frame[index] = Opcodes.FLOAT;\n                break;\n            case 3:\n                frame[index] = Opcodes.DOUBLE;\n                break;\n            case 4:\n                frame[index] = Opcodes.LONG;\n                break;\n            case 5:\n                frame[index] = Opcodes.NULL;\n                break;\n            case 6:\n                frame[index] = Opcodes.UNINITIALIZED_THIS;\n                break;\n            case // Object\n            7:\n                frame[index] = readClass(v, buf);\n                v += 2;\n                break;\n            default:\n                // Uninitialized\n                frame[index] = readLabel(readUnsignedShort(v), labels);\n                v += 2;\n        }\n        return v;\n    }\n\n    /**\n     * Returns the label corresponding to the given offset. The default\n     * implementation of this method creates a label for the given offset if it\n     * has not been already created.\n     *\n     * @param offset a bytecode offset in a method.\n     * @param labels the already created labels, indexed by their offset. If a\n     *        label already exists for offset this method must not create a new\n     *        one. Otherwise it must store the new label in this array.\n     * @return a non null Label, which must be equal to labels[offset].\n     */\n    protected Label readLabel(int offset, Label[] labels) {\n        if (labels[offset] == null) {\n            labels[offset] = new Label();\n        }\n        return labels[offset];\n    }\n\n    /**\n     * Reads an attribute in {@link #b b}.\n     *\n     * @param attrs prototypes of the attributes that must be parsed during the\n     *        visit of the class. Any attribute whose type is not equal to the\n     *        type of one the prototypes is ignored (i.e. an empty\n     *        {@link Attribute} instance is returned).\n     * @param type the type of the attribute.\n     * @param off index of the first byte of the attribute's content in\n     *        {@link #b b}. The 6 attribute header bytes, containing the type\n     *        and the length of the attribute, are not taken into account here\n     *        (they have already been read).\n     * @param len the length of the attribute's content.\n     * @param buf buffer to be used to call {@link #readUTF8 readUTF8},\n     *        {@link #readClass(int,char[]) readClass} or\n     *        {@link #readConst readConst}.\n     * @param codeOff index of the first byte of code's attribute content in\n     *        {@link #b b}, or -1 if the attribute to be read is not a code\n     *        attribute. The 6 attribute header bytes, containing the type and\n     *        the length of the attribute, are not taken into account here.\n     * @param labels the labels of the method's code, or <tt>null</tt> if the\n     *        attribute to be read is not a code attribute.\n     * @return the attribute that has been read, or <tt>null</tt> to skip this\n     *         attribute.\n     */\n    private Attribute readAttribute(final Attribute[] attrs, final String type, final int off, final int len, final char[] buf, final int codeOff, final Label[] labels) {\n        for (int i = 0; i < attrs.length; ++i) {\n            if (attrs[i].type.equals(type)) {\n                return attrs[i].read(this, off, len, buf, codeOff, labels);\n            }\n        }\n        return new Attribute(type).read(this, off, len, null, -1, null);\n    }\n\n    // ------------------------------------------------------------------------\n    // Utility methods: low level parsing\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the start index of the constant pool item in {@link #b b}, plus\n     * one. <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param item the index a constant pool item.\n     * @return the start index of the constant pool item in {@link #b b}, plus\n     *         one.\n     */\n    public int getItem(final int item) {\n        return items[item];\n    }\n\n    /**\n     * Reads a byte value in {@link #b b}. <i>This method is intended for\n     * {@link Attribute} sub classes, and is normally not needed by class\n     * generators or adapters.</i>\n     *\n     * @param index the start index of the value to be read in {@link #b b}.\n     * @return the read value.\n     */\n    public int readByte(final int index) {\n        return b[index] & 0xFF;\n    }\n\n    /**\n     * Reads an unsigned short value in {@link #b b}. <i>This method is\n     * intended for {@link Attribute} sub classes, and is normally not needed by\n     * class generators or adapters.</i>\n     *\n     * @param index the start index of the value to be read in {@link #b b}.\n     * @return the read value.\n     */\n    public int readUnsignedShort(final int index) {\n        byte[] b = this.b;\n        return ((b[index] & 0xFF) << 8) | (b[index + 1] & 0xFF);\n    }\n\n    /**\n     * Reads a signed short value in {@link #b b}. <i>This method is intended\n     * for {@link Attribute} sub classes, and is normally not needed by class\n     * generators or adapters.</i>\n     *\n     * @param index the start index of the value to be read in {@link #b b}.\n     * @return the read value.\n     */\n    public short readShort(final int index) {\n        byte[] b = this.b;\n        return (short) (((b[index] & 0xFF) << 8) | (b[index + 1] & 0xFF));\n    }\n\n    /**\n     * Reads a signed int value in {@link #b b}. <i>This method is intended for\n     * {@link Attribute} sub classes, and is normally not needed by class\n     * generators or adapters.</i>\n     *\n     * @param index the start index of the value to be read in {@link #b b}.\n     * @return the read value.\n     */\n    public int readInt(final int index) {\n        byte[] b = this.b;\n        return ((b[index] & 0xFF) << 24) | ((b[index + 1] & 0xFF) << 16) | ((b[index + 2] & 0xFF) << 8) | (b[index + 3] & 0xFF);\n    }\n\n    /**\n     * Reads a signed long value in {@link #b b}. <i>This method is intended\n     * for {@link Attribute} sub classes, and is normally not needed by class\n     * generators or adapters.</i>\n     *\n     * @param index the start index of the value to be read in {@link #b b}.\n     * @return the read value.\n     */\n    public long readLong(final int index) {\n        long l1 = readInt(index);\n        long l0 = readInt(index + 4) & 0xFFFFFFFFL;\n        return (l1 << 32) | l0;\n    }\n\n    /**\n     * Reads an UTF8 string constant pool item in {@link #b b}. <i>This method\n     * is intended for {@link Attribute} sub classes, and is normally not needed\n     * by class generators or adapters.</i>\n     *\n     * @param index the start index of an unsigned short value in {@link #b b},\n     *        whose value is the index of an UTF8 constant pool item.\n     * @param buf buffer to be used to read the item. This buffer must be\n     *        sufficiently large. It is not automatically resized.\n     * @return the String corresponding to the specified UTF8 item.\n     */\n    public String readUTF8(int index, final char[] buf) {\n        int item = readUnsignedShort(index);\n        String s = strings[item];\n        if (s != null) {\n            return s;\n        }\n        index = items[item];\n        return strings[item] = readUTF(index + 2, readUnsignedShort(index), buf);\n    }\n\n    /**\n     * Reads UTF8 string in {@link #b b}.\n     *\n     * @param index start offset of the UTF8 string to be read.\n     * @param utfLen length of the UTF8 string to be read.\n     * @param buf buffer to be used to read the string. This buffer must be\n     *        sufficiently large. It is not automatically resized.\n     * @return the String corresponding to the specified UTF8 string.\n     */\n    private String readUTF(int index, final int utfLen, final char[] buf) {\n        int endIndex = index + utfLen;\n        byte[] b = this.b;\n        int strLen = 0;\n        int c;\n        int st = 0;\n        char cc = 0;\n        while (index < endIndex) {\n            c = b[index++];\n            switch(st) {\n                case 0:\n                    c = c & 0xFF;\n                    if (c < 0x80) {\n                        // 0xxxxxxx\n                        buf[strLen++] = (char) c;\n                    } else if (c < 0xE0 && c > 0xBF) {\n                        // 110x xxxx 10xx xxxx\n                        cc = (char) (c & 0x1F);\n                        st = 1;\n                    } else {\n                        // 1110 xxxx 10xx xxxx 10xx xxxx\n                        cc = (char) (c & 0x0F);\n                        st = 2;\n                    }\n                    break;\n                case // byte 2 of 2-byte char or byte 3 of 3-byte char\n                1:\n                    buf[strLen++] = (char) ((cc << 6) | (c & 0x3F));\n                    st = 0;\n                    break;\n                case // byte 2 of 3-byte char\n                2:\n                    cc = (char) ((cc << 6) | (c & 0x3F));\n                    st = 1;\n                    break;\n            }\n        }\n        return new String(buf, 0, strLen);\n    }\n\n    /**\n     * Reads a class constant pool item in {@link #b b}. <i>This method is\n     * intended for {@link Attribute} sub classes, and is normally not needed by\n     * class generators or adapters.</i>\n     *\n     * @param index the start index of an unsigned short value in {@link #b b},\n     *        whose value is the index of a class constant pool item.\n     * @param buf buffer to be used to read the item. This buffer must be\n     *        sufficiently large. It is not automatically resized.\n     * @return the String corresponding to the specified class item.\n     */\n    public String readClass(final int index, final char[] buf) {\n        // computes the start index of the CONSTANT_Class item in b\n        // and reads the CONSTANT_Utf8 item designated by\n        // the first two bytes of this CONSTANT_Class item\n        return readUTF8(items[readUnsignedShort(index)], buf);\n    }\n\n    /**\n     * Reads a numeric or string constant pool item in {@link #b b}. <i>This\n     * method is intended for {@link Attribute} sub classes, and is normally not\n     * needed by class generators or adapters.</i>\n     *\n     * @param item the index of a constant pool item.\n     * @param buf buffer to be used to read the item. This buffer must be\n     *        sufficiently large. It is not automatically resized.\n     * @return the {@link Integer}, {@link Float}, {@link Long},\n     *         {@link Double}, {@link String} or {@link Type} corresponding to\n     *         the given constant pool item.\n     */\n    public Object readConst(final int item, final char[] buf) {\n        int index = items[item];\n        switch(b[index - 1]) {\n            case ClassWriter.INT:\n                return new Integer(readInt(index));\n            case ClassWriter.FLOAT:\n                return new Float(Float.intBitsToFloat(readInt(index)));\n            case ClassWriter.LONG:\n                return new Long(readLong(index));\n            case ClassWriter.DOUBLE:\n                return new Double(Double.longBitsToDouble(readLong(index)));\n            case ClassWriter.CLASS:\n                return Type.getObjectType(readUTF8(index, buf));\n            // case ClassWriter.STR:\n            default:\n                return readUTF8(index, buf);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/ClassReaderTest4.java",
		"test_prompt": "// ClassReaderTest4.java\npackage org.objectweb.asm.jip;\n\nimport java.io.InputStream;\nimport java.io.IOException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassReader}.\n* It contains ten unit test cases for the {@link ClassReader#readLong(int)} method.\n*/\nclass ClassReaderTest4 {"
	},
	{
		"original_code": "// ClassReader.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\nimport java.io.InputStream;\nimport java.io.IOException;\n\n/**\n * A Java class parser to make a {@link ClassVisitor} visit an existing class.\n * This class parses a byte array conforming to the Java class file format and\n * calls the appropriate visit methods of a given class visitor for each field,\n * method and bytecode instruction encountered.\n *\n * @author Eric Bruneton\n * @author Eugene Kuleshov\n */\npublic class ClassReader {\n\n    /**\n     * True to enable signatures support.\n     */\n    static final boolean SIGNATURES = true;\n\n    /**\n     * True to enable annotations support.\n     */\n    static final boolean ANNOTATIONS = true;\n\n    /**\n     * True to enable stack map frames support.\n     */\n    static final boolean FRAMES = true;\n\n    /**\n     * True to enable bytecode writing support.\n     */\n    static final boolean WRITER = true;\n\n    /**\n     * True to enable JSR_W and GOTO_W support.\n     */\n    static final boolean RESIZE = true;\n\n    /**\n     * Flag to skip method code. If this class is set <code>CODE</code>\n     * attribute won't be visited. This can be used, for example, to retrieve\n     * annotations for methods and method parameters.\n     */\n    public static final int SKIP_CODE = 1;\n\n    /**\n     * Flag to skip the debug information in the class. If this flag is set the\n     * debug information of the class is not visited, i.e. the\n     * {@link MethodVisitor#visitLocalVariable visitLocalVariable} and\n     * {@link MethodVisitor#visitLineNumber visitLineNumber} methods will not be\n     * called.\n     */\n    public static final int SKIP_DEBUG = 2;\n\n    /**\n     * Flag to skip the stack map frames in the class. If this flag is set the\n     * stack map frames of the class is not visited, i.e. the\n     * {@link MethodVisitor#visitFrame visitFrame} method will not be called.\n     * This flag is useful when the {@link ClassWriter#COMPUTE_FRAMES} option is\n     * used: it avoids visiting frames that will be ignored and recomputed from\n     * scratch in the class writer.\n     */\n    public static final int SKIP_FRAMES = 4;\n\n    /**\n     * Flag to expand the stack map frames. By default stack map frames are\n     * visited in their original format (i.e. \"expanded\" for classes whose\n     * version is less than V1_6, and \"compressed\" for the other classes). If\n     * this flag is set, stack map frames are always visited in expanded format\n     * (this option adds a decompression/recompression step in ClassReader and\n     * ClassWriter which degrades performances quite a lot).\n     */\n    public static final int EXPAND_FRAMES = 8;\n\n    /**\n     * The class to be parsed. <i>The content of this array must not be\n     * modified. This field is intended for {@link Attribute} sub classes, and\n     * is normally not needed by class generators or adapters.</i>\n     */\n    public final byte[] b;\n\n    /**\n     * The start index of each constant pool item in {@link #b b}, plus one.\n     * The one byte offset skips the constant pool item tag that indicates its\n     * type.\n     */\n    private final int[] items;\n\n    /**\n     * The String objects corresponding to the CONSTANT_Utf8 items. This cache\n     * avoids multiple parsing of a given CONSTANT_Utf8 constant pool item,\n     * which GREATLY improves performances (by a factor 2 to 3). This caching\n     * strategy could be extended to all constant pool items, but its benefit\n     * would not be so great for these items (because they are much less\n     * expensive to parse than CONSTANT_Utf8 items).\n     */\n    private final String[] strings;\n\n    /**\n     * Maximum length of the strings contained in the constant pool of the\n     * class.\n     */\n    private final int maxStringLength;\n\n    /**\n     * Start index of the class header information (access, name...) in\n     * {@link #b b}.\n     */\n    public final int header;\n\n    // ------------------------------------------------------------------------\n    // Constructors\n    // ------------------------------------------------------------------------\n    /**\n     * Constructs a new {@link ClassReader} object.\n     *\n     * @param b the bytecode of the class to be read.\n     */\n    public ClassReader(final byte[] b) {\n        this(b, 0, b.length);\n    }\n\n    /**\n     * Constructs a new {@link ClassReader} object.\n     *\n     * @param b the bytecode of the class to be read.\n     * @param off the start offset of the class data.\n     * @param len the length of the class data.\n     */\n    public ClassReader(final byte[] b, final int off, final int len) {\n        this.b = b;\n        // parses the constant pool\n        items = new int[readUnsignedShort(off + 8)];\n        int n = items.length;\n        strings = new String[n];\n        int max = 0;\n        int index = off + 10;\n        for (int i = 1; i < n; ++i) {\n            items[i] = index + 1;\n            int size;\n            switch(b[index]) {\n                case ClassWriter.FIELD:\n                case ClassWriter.METH:\n                case ClassWriter.IMETH:\n                case ClassWriter.INT:\n                case ClassWriter.FLOAT:\n                case ClassWriter.NAME_TYPE:\n                    size = 5;\n                    break;\n                case ClassWriter.LONG:\n                case ClassWriter.DOUBLE:\n                    size = 9;\n                    ++i;\n                    break;\n                case ClassWriter.UTF8:\n                    size = 3 + readUnsignedShort(index + 1);\n                    if (size > max) {\n                        max = size;\n                    }\n                    break;\n                // case ClassWriter.CLASS:\n                // case ClassWriter.STR:\n                default:\n                    size = 3;\n                    break;\n            }\n            index += size;\n        }\n        maxStringLength = max;\n        // the class header information starts just after the constant pool\n        header = index;\n    }\n\n    /**\n     * Returns the class's access flags (see {@link Opcodes}). This value may\n     * not reflect Deprecated and Synthetic flags when bytecode is before 1.5\n     * and those flags are represented by attributes.\n     *\n     * @return the class access flags\n     *\n     * @see ClassVisitor#visit(int, int, String, String, String, String[])\n     */\n    public int getAccess() {\n        return readUnsignedShort(header);\n    }\n\n    /**\n     * Returns the internal name of the class (see\n     * {@link Type#getInternalName() getInternalName}).\n     *\n     * @return the internal class name\n     *\n     * @see ClassVisitor#visit(int, int, String, String, String, String[])\n     */\n    public String getClassName() {\n        return readClass(header + 2, new char[maxStringLength]);\n    }\n\n    /**\n     * Returns the internal of name of the super class (see\n     * {@link Type#getInternalName() getInternalName}). For interfaces, the\n     * super class is {@link Object}.\n     *\n     * @return the internal name of super class, or <tt>null</tt> for\n     *         {@link Object} class.\n     *\n     * @see ClassVisitor#visit(int, int, String, String, String, String[])\n     */\n    public String getSuperName() {\n        int n = items[readUnsignedShort(header + 4)];\n        return n == 0 ? null : readUTF8(n, new char[maxStringLength]);\n    }\n\n    /**\n     * Returns the internal names of the class's interfaces (see\n     * {@link Type#getInternalName() getInternalName}).\n     *\n     * @return the array of internal names for all implemented interfaces or\n     *         <tt>null</tt>.\n     *\n     * @see ClassVisitor#visit(int, int, String, String, String, String[])\n     */\n    public String[] getInterfaces() {\n        int index = header + 6;\n        int n = readUnsignedShort(index);\n        String[] interfaces = new String[n];\n        if (n > 0) {\n            char[] buf = new char[maxStringLength];\n            for (int i = 0; i < n; ++i) {\n                index += 2;\n                interfaces[i] = readClass(index, buf);\n            }\n        }\n        return interfaces;\n    }\n\n    /**\n     * Copies the constant pool data into the given {@link ClassWriter}. Should\n     * be called before the {@link #accept(ClassVisitor,int)} method.\n     *\n     * @param classWriter the {@link ClassWriter} to copy constant pool into.\n     */\n    void copyPool(final ClassWriter classWriter) {\n        char[] buf = new char[maxStringLength];\n        int ll = items.length;\n        Item[] items2 = new Item[ll];\n        for (int i = 1; i < ll; i++) {\n            int index = items[i];\n            int tag = b[index - 1];\n            Item item = new Item(i);\n            int nameType;\n            switch(tag) {\n                case ClassWriter.FIELD:\n                case ClassWriter.METH:\n                case ClassWriter.IMETH:\n                    nameType = items[readUnsignedShort(index + 2)];\n                    item.set(tag, readClass(index, buf), readUTF8(nameType, buf), readUTF8(nameType + 2, buf));\n                    break;\n                case ClassWriter.INT:\n                    item.set(readInt(index));\n                    break;\n                case ClassWriter.FLOAT:\n                    item.set(Float.intBitsToFloat(readInt(index)));\n                    break;\n                case ClassWriter.NAME_TYPE:\n                    item.set(tag, readUTF8(index, buf), readUTF8(index + 2, buf), null);\n                    break;\n                case ClassWriter.LONG:\n                    item.set(readLong(index));\n                    ++i;\n                    break;\n                case ClassWriter.DOUBLE:\n                    item.set(Double.longBitsToDouble(readLong(index)));\n                    ++i;\n                    break;\n                case ClassWriter.UTF8:\n                    {\n                        String s = strings[i];\n                        if (s == null) {\n                            index = items[i];\n                            s = strings[i] = readUTF(index + 2, readUnsignedShort(index), buf);\n                        }\n                        item.set(tag, s, null, null);\n                    }\n                    break;\n                // case ClassWriter.STR:\n                // case ClassWriter.CLASS:\n                default:\n                    item.set(tag, readUTF8(index, buf), null, null);\n                    break;\n            }\n            int index2 = item.hashCode % items2.length;\n            item.next = items2[index2];\n            items2[index2] = item;\n        }\n        int off = items[1] - 1;\n        classWriter.pool.putByteArray(b, off, header - off);\n        classWriter.items = items2;\n        classWriter.threshold = (int) (0.75d * ll);\n        classWriter.index = ll;\n    }\n\n    /**\n     * Constructs a new {@link ClassReader} object.\n     *\n     * @param is an input stream from which to read the class.\n     * @throws IOException if a problem occurs during reading.\n     */\n    public ClassReader(final InputStream is) throws IOException {\n        this(readClass(is));\n    }\n\n    /**\n     * Constructs a new {@link ClassReader} object.\n     *\n     * @param name the fully qualified name of the class to be read.\n     * @throws IOException if an exception occurs during reading.\n     */\n    public ClassReader(final String name) throws IOException {\n        this(ClassLoader.getSystemResourceAsStream(name.replace('.', '/') + \".class\"));\n    }\n\n    /**\n     * Reads the bytecode of a class.\n     *\n     * @param is an input stream from which to read the class.\n     * @return the bytecode read from the given input stream.\n     * @throws IOException if a problem occurs during reading.\n     */\n    private static byte[] readClass(final InputStream is) throws IOException {\n        if (is == null) {\n            throw new IOException(\"Class not found\");\n        }\n        byte[] b = new byte[is.available()];\n        int len = 0;\n        while (true) {\n            int n = is.read(b, len, b.length - len);\n            if (n == -1) {\n                if (len < b.length) {\n                    byte[] c = new byte[len];\n                    System.arraycopy(b, 0, c, 0, len);\n                    b = c;\n                }\n                return b;\n            }\n            len += n;\n            if (len == b.length) {\n                int last = is.read();\n                if (last < 0) {\n                    return b;\n                }\n                byte[] c = new byte[b.length + 1000];\n                System.arraycopy(b, 0, c, 0, len);\n                c[len++] = (byte) last;\n                b = c;\n            }\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Public methods\n    // ------------------------------------------------------------------------\n    /**\n     * Makes the given visitor visit the Java class of this {@link ClassReader}.\n     * This class is the one specified in the constructor (see\n     * {@link #ClassReader(byte[]) ClassReader}).\n     *\n     * @param classVisitor the visitor that must visit this class.\n     * @param flags option flags that can be used to modify the default behavior\n     *        of this class. See {@link #SKIP_DEBUG}, {@link #EXPAND_FRAMES},\n     *        {@link #SKIP_FRAMES}, {@link #SKIP_CODE}.\n     */\n    public void accept(final ClassVisitor classVisitor, final int flags) {\n        accept(classVisitor, new Attribute[0], flags);\n    }\n\n    /**\n     * Makes the given visitor visit the Java class of this {@link ClassReader}.\n     * This class is the one specified in the constructor (see\n     * {@link #ClassReader(byte[]) ClassReader}).\n     *\n     * @param classVisitor the visitor that must visit this class.\n     * @param attrs prototypes of the attributes that must be parsed during the\n     *        visit of the class. Any attribute whose type is not equal to the\n     *        type of one the prototypes will not be parsed: its byte array\n     *        value will be passed unchanged to the ClassWriter. <i>This may\n     *        corrupt it if this value contains references to the constant pool,\n     *        or has syntactic or semantic links with a class element that has\n     *        been transformed by a class adapter between the reader and the\n     *        writer</i>.\n     * @param flags option flags that can be used to modify the default behavior\n     *        of this class. See {@link #SKIP_DEBUG}, {@link #EXPAND_FRAMES},\n     *        {@link #SKIP_FRAMES}, {@link #SKIP_CODE}.\n     */\n    public void accept(final ClassVisitor classVisitor, final Attribute[] attrs, final int flags) {\n        // the bytecode array\n        byte[] b = this.b;\n        // buffer used to read strings\n        char[] c = new char[maxStringLength];\n        // loop variables\n        int i, j, k;\n        // indexes in b\n        int u, v, w;\n        Attribute attr;\n        int access;\n        String name;\n        String desc;\n        String attrName;\n        String signature;\n        int anns = 0;\n        int ianns = 0;\n        Attribute cattrs = null;\n        // visits the header\n        u = header;\n        access = readUnsignedShort(u);\n        name = readClass(u + 2, c);\n        v = items[readUnsignedShort(u + 4)];\n        String superClassName = v == 0 ? null : readUTF8(v, c);\n        String[] implementedItfs = new String[readUnsignedShort(u + 6)];\n        w = 0;\n        u += 8;\n        for (i = 0; i < implementedItfs.length; ++i) {\n            implementedItfs[i] = readClass(u, c);\n            u += 2;\n        }\n        boolean skipCode = (flags & SKIP_CODE) != 0;\n        boolean skipDebug = (flags & SKIP_DEBUG) != 0;\n        boolean unzip = (flags & EXPAND_FRAMES) != 0;\n        // skips fields and methods\n        v = u;\n        i = readUnsignedShort(v);\n        v += 2;\n        for (; i > 0; --i) {\n            j = readUnsignedShort(v + 6);\n            v += 8;\n            for (; j > 0; --j) {\n                v += 6 + readInt(v + 2);\n            }\n        }\n        i = readUnsignedShort(v);\n        v += 2;\n        for (; i > 0; --i) {\n            j = readUnsignedShort(v + 6);\n            v += 8;\n            for (; j > 0; --j) {\n                v += 6 + readInt(v + 2);\n            }\n        }\n        // reads the class's attributes\n        signature = null;\n        String sourceFile = null;\n        String sourceDebug = null;\n        String enclosingOwner = null;\n        String enclosingName = null;\n        String enclosingDesc = null;\n        i = readUnsignedShort(v);\n        v += 2;\n        for (; i > 0; --i) {\n            attrName = readUTF8(v, c);\n            // tests are sorted in decreasing frequency order\n            // (based on frequencies observed on typical classes)\n            if (\"SourceFile\".equals(attrName)) {\n                sourceFile = readUTF8(v + 6, c);\n            } else if (\"InnerClasses\".equals(attrName)) {\n                w = v + 6;\n            } else if (\"EnclosingMethod\".equals(attrName)) {\n                enclosingOwner = readClass(v + 6, c);\n                int item = readUnsignedShort(v + 8);\n                if (item != 0) {\n                    enclosingName = readUTF8(items[item], c);\n                    enclosingDesc = readUTF8(items[item] + 2, c);\n                }\n            } else if (SIGNATURES && \"Signature\".equals(attrName)) {\n                signature = readUTF8(v + 6, c);\n            } else if (ANNOTATIONS && \"RuntimeVisibleAnnotations\".equals(attrName)) {\n                anns = v + 6;\n            } else if (\"Deprecated\".equals(attrName)) {\n                access |= Opcodes.ACC_DEPRECATED;\n            } else if (\"Synthetic\".equals(attrName)) {\n                access |= Opcodes.ACC_SYNTHETIC;\n            } else if (\"SourceDebugExtension\".equals(attrName)) {\n                int len = readInt(v + 2);\n                sourceDebug = readUTF(v + 6, len, new char[len]);\n            } else if (ANNOTATIONS && \"RuntimeInvisibleAnnotations\".equals(attrName)) {\n                ianns = v + 6;\n            } else {\n                attr = readAttribute(attrs, attrName, v + 6, readInt(v + 2), c, -1, null);\n                if (attr != null) {\n                    attr.next = cattrs;\n                    cattrs = attr;\n                }\n            }\n            v += 6 + readInt(v + 2);\n        }\n        // calls the visit method\n        classVisitor.visit(readInt(4), access, name, signature, superClassName, implementedItfs);\n        // calls the visitSource method\n        if (!skipDebug && (sourceFile != null || sourceDebug != null)) {\n            classVisitor.visitSource(sourceFile, sourceDebug);\n        }\n        // calls the visitOuterClass method\n        if (enclosingOwner != null) {\n            classVisitor.visitOuterClass(enclosingOwner, enclosingName, enclosingDesc);\n        }\n        // visits the class annotations\n        if (ANNOTATIONS) {\n            for (i = 1; i >= 0; --i) {\n                v = i == 0 ? ianns : anns;\n                if (v != 0) {\n                    j = readUnsignedShort(v);\n                    v += 2;\n                    for (; j > 0; --j) {\n                        v = readAnnotationValues(v + 2, c, true, classVisitor.visitAnnotation(readUTF8(v, c), i != 0));\n                    }\n                }\n            }\n        }\n        // visits the class attributes\n        while (cattrs != null) {\n            attr = cattrs.next;\n            cattrs.next = null;\n            classVisitor.visitAttribute(cattrs);\n            cattrs = attr;\n        }\n        // calls the visitInnerClass method\n        if (w != 0) {\n            i = readUnsignedShort(w);\n            w += 2;\n            for (; i > 0; --i) {\n                classVisitor.visitInnerClass(readUnsignedShort(w) == 0 ? null : readClass(w, c), readUnsignedShort(w + 2) == 0 ? null : readClass(w + 2, c), readUnsignedShort(w + 4) == 0 ? null : readUTF8(w + 4, c), readUnsignedShort(w + 6));\n                w += 8;\n            }\n        }\n        // visits the fields\n        i = readUnsignedShort(u);\n        u += 2;\n        for (; i > 0; --i) {\n            access = readUnsignedShort(u);\n            name = readUTF8(u + 2, c);\n            desc = readUTF8(u + 4, c);\n            // visits the field's attributes and looks for a ConstantValue\n            // attribute\n            int fieldValueItem = 0;\n            signature = null;\n            anns = 0;\n            ianns = 0;\n            cattrs = null;\n            j = readUnsignedShort(u + 6);\n            u += 8;\n            for (; j > 0; --j) {\n                attrName = readUTF8(u, c);\n                // tests are sorted in decreasing frequency order\n                // (based on frequencies observed on typical classes)\n                if (\"ConstantValue\".equals(attrName)) {\n                    fieldValueItem = readUnsignedShort(u + 6);\n                } else if (SIGNATURES && \"Signature\".equals(attrName)) {\n                    signature = readUTF8(u + 6, c);\n                } else if (\"Deprecated\".equals(attrName)) {\n                    access |= Opcodes.ACC_DEPRECATED;\n                } else if (\"Synthetic\".equals(attrName)) {\n                    access |= Opcodes.ACC_SYNTHETIC;\n                } else if (ANNOTATIONS && \"RuntimeVisibleAnnotations\".equals(attrName)) {\n                    anns = u + 6;\n                } else if (ANNOTATIONS && \"RuntimeInvisibleAnnotations\".equals(attrName)) {\n                    ianns = u + 6;\n                } else {\n                    attr = readAttribute(attrs, attrName, u + 6, readInt(u + 2), c, -1, null);\n                    if (attr != null) {\n                        attr.next = cattrs;\n                        cattrs = attr;\n                    }\n                }\n                u += 6 + readInt(u + 2);\n            }\n            // visits the field\n            FieldVisitor fv = classVisitor.visitField(access, name, desc, signature, fieldValueItem == 0 ? null : readConst(fieldValueItem, c));\n            // visits the field annotations and attributes\n            if (fv != null) {\n                if (ANNOTATIONS) {\n                    for (j = 1; j >= 0; --j) {\n                        v = j == 0 ? ianns : anns;\n                        if (v != 0) {\n                            k = readUnsignedShort(v);\n                            v += 2;\n                            for (; k > 0; --k) {\n                                v = readAnnotationValues(v + 2, c, true, fv.visitAnnotation(readUTF8(v, c), j != 0));\n                            }\n                        }\n                    }\n                }\n                while (cattrs != null) {\n                    attr = cattrs.next;\n                    cattrs.next = null;\n                    fv.visitAttribute(cattrs);\n                    cattrs = attr;\n                }\n                fv.visitEnd();\n            }\n        }\n        // visits the methods\n        i = readUnsignedShort(u);\n        u += 2;\n        for (; i > 0; --i) {\n            int u0 = u + 6;\n            access = readUnsignedShort(u);\n            name = readUTF8(u + 2, c);\n            desc = readUTF8(u + 4, c);\n            signature = null;\n            anns = 0;\n            ianns = 0;\n            int dann = 0;\n            int mpanns = 0;\n            int impanns = 0;\n            cattrs = null;\n            v = 0;\n            w = 0;\n            // looks for Code and Exceptions attributes\n            j = readUnsignedShort(u + 6);\n            u += 8;\n            for (; j > 0; --j) {\n                attrName = readUTF8(u, c);\n                int attrSize = readInt(u + 2);\n                u += 6;\n                // tests are sorted in decreasing frequency order\n                // (based on frequencies observed on typical classes)\n                if (\"Code\".equals(attrName)) {\n                    if (!skipCode) {\n                        v = u;\n                    }\n                } else if (\"Exceptions\".equals(attrName)) {\n                    w = u;\n                } else if (SIGNATURES && \"Signature\".equals(attrName)) {\n                    signature = readUTF8(u, c);\n                } else if (\"Deprecated\".equals(attrName)) {\n                    access |= Opcodes.ACC_DEPRECATED;\n                } else if (ANNOTATIONS && \"RuntimeVisibleAnnotations\".equals(attrName)) {\n                    anns = u;\n                } else if (ANNOTATIONS && \"AnnotationDefault\".equals(attrName)) {\n                    dann = u;\n                } else if (\"Synthetic\".equals(attrName)) {\n                    access |= Opcodes.ACC_SYNTHETIC;\n                } else if (ANNOTATIONS && \"RuntimeInvisibleAnnotations\".equals(attrName)) {\n                    ianns = u;\n                } else if (ANNOTATIONS && \"RuntimeVisibleParameterAnnotations\".equals(attrName)) {\n                    mpanns = u;\n                } else if (ANNOTATIONS && \"RuntimeInvisibleParameterAnnotations\".equals(attrName)) {\n                    impanns = u;\n                } else {\n                    attr = readAttribute(attrs, attrName, u, attrSize, c, -1, null);\n                    if (attr != null) {\n                        attr.next = cattrs;\n                        cattrs = attr;\n                    }\n                }\n                u += attrSize;\n            }\n            // reads declared exceptions\n            String[] exceptions;\n            if (w == 0) {\n                exceptions = null;\n            } else {\n                exceptions = new String[readUnsignedShort(w)];\n                w += 2;\n                for (j = 0; j < exceptions.length; ++j) {\n                    exceptions[j] = readClass(w, c);\n                    w += 2;\n                }\n            }\n            // visits the method's code, if any\n            MethodVisitor mv = classVisitor.visitMethod(access, name, desc, signature, exceptions);\n            if (mv != null) {\n                /*\n                 * if the returned MethodVisitor is in fact a MethodWriter, it\n                 * means there is no method adapter between the reader and the\n                 * writer. If, in addition, the writer's constant pool was\n                 * copied from this reader (mw.cw.cr == this), and the signature\n                 * and exceptions of the method have not been changed, then it\n                 * is possible to skip all visit events and just copy the\n                 * original code of the method to the writer (the access, name\n                 * and descriptor can have been changed, this is not important\n                 * since they are not copied as is from the reader).\n                 */\n                if (WRITER && mv instanceof MethodWriter) {\n                    MethodWriter mw = (MethodWriter) mv;\n                    if (mw.cw.cr == this) {\n                        if (signature == mw.signature) {\n                            boolean sameExceptions = false;\n                            if (exceptions == null) {\n                                sameExceptions = mw.exceptionCount == 0;\n                            } else {\n                                if (exceptions.length == mw.exceptionCount) {\n                                    sameExceptions = true;\n                                    for (j = exceptions.length - 1; j >= 0; --j) {\n                                        w -= 2;\n                                        if (mw.exceptions[j] != readUnsignedShort(w)) {\n                                            sameExceptions = false;\n                                            break;\n                                        }\n                                    }\n                                }\n                            }\n                            if (sameExceptions) {\n                                /*\n                                 * we do not copy directly the code into\n                                 * MethodWriter to save a byte array copy\n                                 * operation. The real copy will be done in\n                                 * ClassWriter.toByteArray().\n                                 */\n                                mw.classReaderOffset = u0;\n                                mw.classReaderLength = u - u0;\n                                continue;\n                            }\n                        }\n                    }\n                }\n                if (ANNOTATIONS && dann != 0) {\n                    AnnotationVisitor dv = mv.visitAnnotationDefault();\n                    readAnnotationValue(dann, c, null, dv);\n                    if (dv != null) {\n                        dv.visitEnd();\n                    }\n                }\n                if (ANNOTATIONS) {\n                    for (j = 1; j >= 0; --j) {\n                        w = j == 0 ? ianns : anns;\n                        if (w != 0) {\n                            k = readUnsignedShort(w);\n                            w += 2;\n                            for (; k > 0; --k) {\n                                w = readAnnotationValues(w + 2, c, true, mv.visitAnnotation(readUTF8(w, c), j != 0));\n                            }\n                        }\n                    }\n                }\n                if (ANNOTATIONS && mpanns != 0) {\n                    readParameterAnnotations(mpanns, desc, c, true, mv);\n                }\n                if (ANNOTATIONS && impanns != 0) {\n                    readParameterAnnotations(impanns, desc, c, false, mv);\n                }\n                while (cattrs != null) {\n                    attr = cattrs.next;\n                    cattrs.next = null;\n                    mv.visitAttribute(cattrs);\n                    cattrs = attr;\n                }\n            }\n            if (mv != null && v != 0) {\n                int maxStack = readUnsignedShort(v);\n                int maxLocals = readUnsignedShort(v + 2);\n                int codeLength = readInt(v + 4);\n                v += 8;\n                int codeStart = v;\n                int codeEnd = v + codeLength;\n                mv.visitCode();\n                // 1st phase: finds the labels\n                int label;\n                Label[] labels = new Label[codeLength + 2];\n                readLabel(codeLength + 1, labels);\n                while (v < codeEnd) {\n                    w = v - codeStart;\n                    int opcode = b[v] & 0xFF;\n                    switch(ClassWriter.TYPE[opcode]) {\n                        case ClassWriter.NOARG_INSN:\n                        case ClassWriter.IMPLVAR_INSN:\n                            v += 1;\n                            break;\n                        case ClassWriter.LABEL_INSN:\n                            readLabel(w + readShort(v + 1), labels);\n                            v += 3;\n                            break;\n                        case ClassWriter.LABELW_INSN:\n                            readLabel(w + readInt(v + 1), labels);\n                            v += 5;\n                            break;\n                        case ClassWriter.WIDE_INSN:\n                            opcode = b[v + 1] & 0xFF;\n                            if (opcode == Opcodes.IINC) {\n                                v += 6;\n                            } else {\n                                v += 4;\n                            }\n                            break;\n                        case ClassWriter.TABL_INSN:\n                            // skips 0 to 3 padding bytes*\n                            v = v + 4 - (w & 3);\n                            // reads instruction\n                            readLabel(w + readInt(v), labels);\n                            j = readInt(v + 8) - readInt(v + 4) + 1;\n                            v += 12;\n                            for (; j > 0; --j) {\n                                readLabel(w + readInt(v), labels);\n                                v += 4;\n                            }\n                            break;\n                        case ClassWriter.LOOK_INSN:\n                            // skips 0 to 3 padding bytes*\n                            v = v + 4 - (w & 3);\n                            // reads instruction\n                            readLabel(w + readInt(v), labels);\n                            j = readInt(v + 4);\n                            v += 8;\n                            for (; j > 0; --j) {\n                                readLabel(w + readInt(v + 4), labels);\n                                v += 8;\n                            }\n                            break;\n                        case ClassWriter.VAR_INSN:\n                        case ClassWriter.SBYTE_INSN:\n                        case ClassWriter.LDC_INSN:\n                            v += 2;\n                            break;\n                        case ClassWriter.SHORT_INSN:\n                        case ClassWriter.LDCW_INSN:\n                        case ClassWriter.FIELDORMETH_INSN:\n                        case ClassWriter.TYPE_INSN:\n                        case ClassWriter.IINC_INSN:\n                            v += 3;\n                            break;\n                        case ClassWriter.ITFDYNMETH_INSN:\n                            v += 5;\n                            break;\n                        // case MANA_INSN:\n                        default:\n                            v += 4;\n                            break;\n                    }\n                }\n                // parses the try catch entries\n                j = readUnsignedShort(v);\n                v += 2;\n                for (; j > 0; --j) {\n                    Label start = readLabel(readUnsignedShort(v), labels);\n                    Label end = readLabel(readUnsignedShort(v + 2), labels);\n                    Label handler = readLabel(readUnsignedShort(v + 4), labels);\n                    int type = readUnsignedShort(v + 6);\n                    if (type == 0) {\n                        mv.visitTryCatchBlock(start, end, handler, null);\n                    } else {\n                        mv.visitTryCatchBlock(start, end, handler, readUTF8(items[type], c));\n                    }\n                    v += 8;\n                }\n                // parses the local variable, line number tables, and code\n                // attributes\n                int varTable = 0;\n                int varTypeTable = 0;\n                int stackMap = 0;\n                int stackMapSize = 0;\n                int frameCount = 0;\n                int frameMode = 0;\n                int frameOffset = 0;\n                int frameLocalCount = 0;\n                int frameLocalDiff = 0;\n                int frameStackCount = 0;\n                Object[] frameLocal = null;\n                Object[] frameStack = null;\n                boolean zip = true;\n                cattrs = null;\n                j = readUnsignedShort(v);\n                v += 2;\n                for (; j > 0; --j) {\n                    attrName = readUTF8(v, c);\n                    if (\"LocalVariableTable\".equals(attrName)) {\n                        if (!skipDebug) {\n                            varTable = v + 6;\n                            k = readUnsignedShort(v + 6);\n                            w = v + 8;\n                            for (; k > 0; --k) {\n                                label = readUnsignedShort(w);\n                                if (labels[label] == null) {\n                                    readLabel(label, labels).status |= Label.DEBUG;\n                                }\n                                label += readUnsignedShort(w + 2);\n                                if (labels[label] == null) {\n                                    readLabel(label, labels).status |= Label.DEBUG;\n                                }\n                                w += 10;\n                            }\n                        }\n                    } else if (\"LocalVariableTypeTable\".equals(attrName)) {\n                        varTypeTable = v + 6;\n                    } else if (\"LineNumberTable\".equals(attrName)) {\n                        if (!skipDebug) {\n                            k = readUnsignedShort(v + 6);\n                            w = v + 8;\n                            for (; k > 0; --k) {\n                                label = readUnsignedShort(w);\n                                if (labels[label] == null) {\n                                    readLabel(label, labels).status |= Label.DEBUG;\n                                }\n                                labels[label].line = readUnsignedShort(w + 2);\n                                w += 4;\n                            }\n                        }\n                    } else if (FRAMES && \"StackMapTable\".equals(attrName)) {\n                        if ((flags & SKIP_FRAMES) == 0) {\n                            stackMap = v + 8;\n                            stackMapSize = readInt(v + 2);\n                            frameCount = readUnsignedShort(v + 6);\n                        }\n                        /*\n                         * here we do not extract the labels corresponding to\n                         * the attribute content. This would require a full\n                         * parsing of the attribute, which would need to be\n                         * repeated in the second phase (see below). Instead the\n                         * content of the attribute is read one frame at a time\n                         * (i.e. after a frame has been visited, the next frame\n                         * is read), and the labels it contains are also\n                         * extracted one frame at a time. Thanks to the ordering\n                         * of frames, having only a \"one frame lookahead\" is not\n                         * a problem, i.e. it is not possible to see an offset\n                         * smaller than the offset of the current insn and for\n                         * which no Label exist.\n                         */\n                        /*\n                         * This is not true for UNINITIALIZED type offsets. We\n                         * solve this by parsing the stack map table without a\n                         * full decoding (see below).\n                         */\n                    } else if (FRAMES && \"StackMap\".equals(attrName)) {\n                        if ((flags & SKIP_FRAMES) == 0) {\n                            stackMap = v + 8;\n                            stackMapSize = readInt(v + 2);\n                            frameCount = readUnsignedShort(v + 6);\n                            zip = false;\n                        }\n                        /*\n                         * IMPORTANT! here we assume that the frames are\n                         * ordered, as in the StackMapTable attribute, although\n                         * this is not guaranteed by the attribute format.\n                         */\n                    } else {\n                        for (k = 0; k < attrs.length; ++k) {\n                            if (attrs[k].type.equals(attrName)) {\n                                attr = attrs[k].read(this, v + 6, readInt(v + 2), c, codeStart - 8, labels);\n                                if (attr != null) {\n                                    attr.next = cattrs;\n                                    cattrs = attr;\n                                }\n                            }\n                        }\n                    }\n                    v += 6 + readInt(v + 2);\n                }\n                // 2nd phase: visits each instruction\n                if (FRAMES && stackMap != 0) {\n                    // creates the very first (implicit) frame from the method\n                    // descriptor\n                    frameLocal = new Object[maxLocals];\n                    frameStack = new Object[maxStack];\n                    if (unzip) {\n                        int local = 0;\n                        if ((access & Opcodes.ACC_STATIC) == 0) {\n                            if (\"<init>\".equals(name)) {\n                                frameLocal[local++] = Opcodes.UNINITIALIZED_THIS;\n                            } else {\n                                frameLocal[local++] = readClass(header + 2, c);\n                            }\n                        }\n                        j = 1;\n                        loop: while (true) {\n                            k = j;\n                            switch(desc.charAt(j++)) {\n                                case 'Z':\n                                case 'C':\n                                case 'B':\n                                case 'S':\n                                case 'I':\n                                    frameLocal[local++] = Opcodes.INTEGER;\n                                    break;\n                                case 'F':\n                                    frameLocal[local++] = Opcodes.FLOAT;\n                                    break;\n                                case 'J':\n                                    frameLocal[local++] = Opcodes.LONG;\n                                    break;\n                                case 'D':\n                                    frameLocal[local++] = Opcodes.DOUBLE;\n                                    break;\n                                case '[':\n                                    while (desc.charAt(j) == '[') {\n                                        ++j;\n                                    }\n                                    if (desc.charAt(j) == 'L') {\n                                        ++j;\n                                        while (desc.charAt(j) != ';') {\n                                            ++j;\n                                        }\n                                    }\n                                    frameLocal[local++] = desc.substring(k, ++j);\n                                    break;\n                                case 'L':\n                                    while (desc.charAt(j) != ';') {\n                                        ++j;\n                                    }\n                                    frameLocal[local++] = desc.substring(k + 1, j++);\n                                    break;\n                                default:\n                                    break loop;\n                            }\n                        }\n                        frameLocalCount = local;\n                    }\n                    /*\n                     * for the first explicit frame the offset is not\n                     * offset_delta + 1 but only offset_delta; setting the\n                     * implicit frame offset to -1 allow the use of the\n                     * \"offset_delta + 1\" rule in all cases\n                     */\n                    frameOffset = -1;\n                    /*\n                     * Finds labels for UNINITIALIZED frame types. Instead of\n                     * decoding each element of the stack map table, we look\n                     * for 3 consecutive bytes that \"look like\" an UNINITIALIZED\n                     * type (tag 8, offset within code bounds, NEW instruction\n                     * at this offset). We may find false positives (i.e. not \n                     * real UNINITIALIZED types), but this should be rare, and \n                     * the only consequence will be the creation of an unneeded \n                     * label. This is better than creating a label for each NEW\n                     * instruction, and faster than fully decoding the whole \n                     * stack map table.\n                     */\n                    for (j = stackMap; j < stackMap + stackMapSize - 2; ++j) {\n                        if (b[j] == 8) {\n                            // UNINITIALIZED FRAME TYPE\n                            k = readUnsignedShort(j + 1);\n                            if (k >= 0 && k < codeLength) {\n                                // potential offset\n                                if ((b[codeStart + k] & 0xFF) == Opcodes.NEW) {\n                                    // NEW at this offset\n                                    readLabel(k, labels);\n                                }\n                            }\n                        }\n                    }\n                }\n                v = codeStart;\n                Label l;\n                while (v < codeEnd) {\n                    w = v - codeStart;\n                    l = labels[w];\n                    if (l != null) {\n                        mv.visitLabel(l);\n                        if (!skipDebug && l.line > 0) {\n                            mv.visitLineNumber(l.line, l);\n                        }\n                    }\n                    while (FRAMES && frameLocal != null && (frameOffset == w || frameOffset == -1)) {\n                        // if there is a frame for this offset,\n                        // makes the visitor visit it,\n                        // and reads the next frame if there is one.\n                        if (!zip || unzip) {\n                            mv.visitFrame(Opcodes.F_NEW, frameLocalCount, frameLocal, frameStackCount, frameStack);\n                        } else if (frameOffset != -1) {\n                            mv.visitFrame(frameMode, frameLocalDiff, frameLocal, frameStackCount, frameStack);\n                        }\n                        if (frameCount > 0) {\n                            int tag, delta, n;\n                            if (zip) {\n                                tag = b[stackMap++] & 0xFF;\n                            } else {\n                                tag = MethodWriter.FULL_FRAME;\n                                frameOffset = -1;\n                            }\n                            frameLocalDiff = 0;\n                            if (tag < MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME) {\n                                delta = tag;\n                                frameMode = Opcodes.F_SAME;\n                                frameStackCount = 0;\n                            } else if (tag < MethodWriter.RESERVED) {\n                                delta = tag - MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME;\n                                stackMap = readFrameType(frameStack, 0, stackMap, c, labels);\n                                frameMode = Opcodes.F_SAME1;\n                                frameStackCount = 1;\n                            } else {\n                                delta = readUnsignedShort(stackMap);\n                                stackMap += 2;\n                                if (tag == MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {\n                                    stackMap = readFrameType(frameStack, 0, stackMap, c, labels);\n                                    frameMode = Opcodes.F_SAME1;\n                                    frameStackCount = 1;\n                                } else if (tag >= MethodWriter.CHOP_FRAME && tag < MethodWriter.SAME_FRAME_EXTENDED) {\n                                    frameMode = Opcodes.F_CHOP;\n                                    frameLocalDiff = MethodWriter.SAME_FRAME_EXTENDED - tag;\n                                    frameLocalCount -= frameLocalDiff;\n                                    frameStackCount = 0;\n                                } else if (tag == MethodWriter.SAME_FRAME_EXTENDED) {\n                                    frameMode = Opcodes.F_SAME;\n                                    frameStackCount = 0;\n                                } else if (tag < MethodWriter.FULL_FRAME) {\n                                    j = unzip ? frameLocalCount : 0;\n                                    for (k = tag - MethodWriter.SAME_FRAME_EXTENDED; k > 0; k--) {\n                                        stackMap = readFrameType(frameLocal, j++, stackMap, c, labels);\n                                    }\n                                    frameMode = Opcodes.F_APPEND;\n                                    frameLocalDiff = tag - MethodWriter.SAME_FRAME_EXTENDED;\n                                    frameLocalCount += frameLocalDiff;\n                                    frameStackCount = 0;\n                                } else {\n                                    // if (tag == FULL_FRAME) {\n                                    frameMode = Opcodes.F_FULL;\n                                    n = frameLocalDiff = frameLocalCount = readUnsignedShort(stackMap);\n                                    stackMap += 2;\n                                    for (j = 0; n > 0; n--) {\n                                        stackMap = readFrameType(frameLocal, j++, stackMap, c, labels);\n                                    }\n                                    n = frameStackCount = readUnsignedShort(stackMap);\n                                    stackMap += 2;\n                                    for (j = 0; n > 0; n--) {\n                                        stackMap = readFrameType(frameStack, j++, stackMap, c, labels);\n                                    }\n                                }\n                            }\n                            frameOffset += delta + 1;\n                            readLabel(frameOffset, labels);\n                            --frameCount;\n                        } else {\n                            frameLocal = null;\n                        }\n                    }\n                    int opcode = b[v] & 0xFF;\n                    switch(ClassWriter.TYPE[opcode]) {\n                        case ClassWriter.NOARG_INSN:\n                            mv.visitInsn(opcode);\n                            v += 1;\n                            break;\n                        case ClassWriter.IMPLVAR_INSN:\n                            if (opcode > Opcodes.ISTORE) {\n                                // ISTORE_0\n                                opcode -= 59;\n                                mv.visitVarInsn(Opcodes.ISTORE + (opcode >> 2), opcode & 0x3);\n                            } else {\n                                // ILOAD_0\n                                opcode -= 26;\n                                mv.visitVarInsn(Opcodes.ILOAD + (opcode >> 2), opcode & 0x3);\n                            }\n                            v += 1;\n                            break;\n                        case ClassWriter.LABEL_INSN:\n                            mv.visitJumpInsn(opcode, labels[w + readShort(v + 1)]);\n                            v += 3;\n                            break;\n                        case ClassWriter.LABELW_INSN:\n                            mv.visitJumpInsn(opcode - 33, labels[w + readInt(v + 1)]);\n                            v += 5;\n                            break;\n                        case ClassWriter.WIDE_INSN:\n                            opcode = b[v + 1] & 0xFF;\n                            if (opcode == Opcodes.IINC) {\n                                mv.visitIincInsn(readUnsignedShort(v + 2), readShort(v + 4));\n                                v += 6;\n                            } else {\n                                mv.visitVarInsn(opcode, readUnsignedShort(v + 2));\n                                v += 4;\n                            }\n                            break;\n                        case ClassWriter.TABL_INSN:\n                            // skips 0 to 3 padding bytes\n                            v = v + 4 - (w & 3);\n                            // reads instruction\n                            label = w + readInt(v);\n                            int min = readInt(v + 4);\n                            int max = readInt(v + 8);\n                            v += 12;\n                            Label[] table = new Label[max - min + 1];\n                            for (j = 0; j < table.length; ++j) {\n                                table[j] = labels[w + readInt(v)];\n                                v += 4;\n                            }\n                            mv.visitTableSwitchInsn(min, max, labels[label], table);\n                            break;\n                        case ClassWriter.LOOK_INSN:\n                            // skips 0 to 3 padding bytes\n                            v = v + 4 - (w & 3);\n                            // reads instruction\n                            label = w + readInt(v);\n                            j = readInt(v + 4);\n                            v += 8;\n                            int[] keys = new int[j];\n                            Label[] values = new Label[j];\n                            for (j = 0; j < keys.length; ++j) {\n                                keys[j] = readInt(v);\n                                values[j] = labels[w + readInt(v + 4)];\n                                v += 8;\n                            }\n                            mv.visitLookupSwitchInsn(labels[label], keys, values);\n                            break;\n                        case ClassWriter.VAR_INSN:\n                            mv.visitVarInsn(opcode, b[v + 1] & 0xFF);\n                            v += 2;\n                            break;\n                        case ClassWriter.SBYTE_INSN:\n                            mv.visitIntInsn(opcode, b[v + 1]);\n                            v += 2;\n                            break;\n                        case ClassWriter.SHORT_INSN:\n                            mv.visitIntInsn(opcode, readShort(v + 1));\n                            v += 3;\n                            break;\n                        case ClassWriter.LDC_INSN:\n                            mv.visitLdcInsn(readConst(b[v + 1] & 0xFF, c));\n                            v += 2;\n                            break;\n                        case ClassWriter.LDCW_INSN:\n                            mv.visitLdcInsn(readConst(readUnsignedShort(v + 1), c));\n                            v += 3;\n                            break;\n                        case ClassWriter.FIELDORMETH_INSN:\n                        case ClassWriter.ITFDYNMETH_INSN:\n                            int cpIndex = items[readUnsignedShort(v + 1)];\n                            String iowner;\n                            // INVOKEDYNAMIC is receiverless\n                            if (opcode == Opcodes.INVOKEDYNAMIC) {\n                                iowner = Opcodes.INVOKEDYNAMIC_OWNER;\n                            } else {\n                                iowner = readClass(cpIndex, c);\n                                cpIndex = items[readUnsignedShort(cpIndex + 2)];\n                            }\n                            String iname = readUTF8(cpIndex, c);\n                            String idesc = readUTF8(cpIndex + 2, c);\n                            if (opcode < Opcodes.INVOKEVIRTUAL) {\n                                mv.visitFieldInsn(opcode, iowner, iname, idesc);\n                            } else {\n                                mv.visitMethodInsn(opcode, iowner, iname, idesc);\n                            }\n                            if (opcode == Opcodes.INVOKEINTERFACE || opcode == Opcodes.INVOKEDYNAMIC) {\n                                v += 5;\n                            } else {\n                                v += 3;\n                            }\n                            break;\n                        case ClassWriter.TYPE_INSN:\n                            mv.visitTypeInsn(opcode, readClass(v + 1, c));\n                            v += 3;\n                            break;\n                        case ClassWriter.IINC_INSN:\n                            mv.visitIincInsn(b[v + 1] & 0xFF, b[v + 2]);\n                            v += 3;\n                            break;\n                        // case MANA_INSN:\n                        default:\n                            mv.visitMultiANewArrayInsn(readClass(v + 1, c), b[v + 3] & 0xFF);\n                            v += 4;\n                            break;\n                    }\n                }\n                l = labels[codeEnd - codeStart];\n                if (l != null) {\n                    mv.visitLabel(l);\n                }\n                // visits the local variable tables\n                if (!skipDebug && varTable != 0) {\n                    int[] typeTable = null;\n                    if (varTypeTable != 0) {\n                        k = readUnsignedShort(varTypeTable) * 3;\n                        w = varTypeTable + 2;\n                        typeTable = new int[k];\n                        while (k > 0) {\n                            // signature\n                            typeTable[--k] = w + 6;\n                            // index\n                            typeTable[--k] = readUnsignedShort(w + 8);\n                            // start\n                            typeTable[--k] = readUnsignedShort(w);\n                            w += 10;\n                        }\n                    }\n                    k = readUnsignedShort(varTable);\n                    w = varTable + 2;\n                    for (; k > 0; --k) {\n                        int start = readUnsignedShort(w);\n                        int length = readUnsignedShort(w + 2);\n                        int index = readUnsignedShort(w + 8);\n                        String vsignature = null;\n                        if (typeTable != null) {\n                            for (int a = 0; a < typeTable.length; a += 3) {\n                                if (typeTable[a] == start && typeTable[a + 1] == index) {\n                                    vsignature = readUTF8(typeTable[a + 2], c);\n                                    break;\n                                }\n                            }\n                        }\n                        mv.visitLocalVariable(readUTF8(w + 4, c), readUTF8(w + 6, c), vsignature, labels[start], labels[start + length], index);\n                        w += 10;\n                    }\n                }\n                // visits the other attributes\n                while (cattrs != null) {\n                    attr = cattrs.next;\n                    cattrs.next = null;\n                    mv.visitAttribute(cattrs);\n                    cattrs = attr;\n                }\n                // visits the max stack and max locals values\n                mv.visitMaxs(maxStack, maxLocals);\n            }\n            if (mv != null) {\n                mv.visitEnd();\n            }\n        }\n        // visits the end of the class\n        classVisitor.visitEnd();\n    }\n\n    /**\n     * Reads parameter annotations and makes the given visitor visit them.\n     *\n     * @param v start offset in {@link #b b} of the annotations to be read.\n     * @param desc the method descriptor.\n     * @param buf buffer to be used to call {@link #readUTF8 readUTF8},\n     *        {@link #readClass(int,char[]) readClass} or\n     *        {@link #readConst readConst}.\n     * @param visible <tt>true</tt> if the annotations to be read are visible\n     *        at runtime.\n     * @param mv the visitor that must visit the annotations.\n     */\n    private void readParameterAnnotations(int v, final String desc, final char[] buf, final boolean visible, final MethodVisitor mv) {\n        int i;\n        int n = b[v++] & 0xFF;\n        // workaround for a bug in javac (javac compiler generates a parameter\n        // annotation array whose size is equal to the number of parameters in\n        // the Java source file, while it should generate an array whose size is\n        // equal to the number of parameters in the method descriptor - which\n        // includes the synthetic parameters added by the compiler). This work-\n        // around supposes that the synthetic parameters are the first ones.\n        int synthetics = Type.getArgumentTypes(desc).length - n;\n        AnnotationVisitor av;\n        for (i = 0; i < synthetics; ++i) {\n            // virtual annotation to detect synthetic parameters in MethodWriter\n            av = mv.visitParameterAnnotation(i, \"Ljava/lang/Synthetic;\", false);\n            if (av != null) {\n                av.visitEnd();\n            }\n        }\n        for (; i < n + synthetics; ++i) {\n            int j = readUnsignedShort(v);\n            v += 2;\n            for (; j > 0; --j) {\n                av = mv.visitParameterAnnotation(i, readUTF8(v, buf), visible);\n                v = readAnnotationValues(v + 2, buf, true, av);\n            }\n        }\n    }\n\n    /**\n     * Reads the values of an annotation and makes the given visitor visit them.\n     *\n     * @param v the start offset in {@link #b b} of the values to be read\n     *        (including the unsigned short that gives the number of values).\n     * @param buf buffer to be used to call {@link #readUTF8 readUTF8},\n     *        {@link #readClass(int,char[]) readClass} or\n     *        {@link #readConst readConst}.\n     * @param named if the annotation values are named or not.\n     * @param av the visitor that must visit the values.\n     * @return the end offset of the annotation values.\n     */\n    private int readAnnotationValues(int v, final char[] buf, final boolean named, final AnnotationVisitor av) {\n        int i = readUnsignedShort(v);\n        v += 2;\n        if (named) {\n            for (; i > 0; --i) {\n                v = readAnnotationValue(v + 2, buf, readUTF8(v, buf), av);\n            }\n        } else {\n            for (; i > 0; --i) {\n                v = readAnnotationValue(v, buf, null, av);\n            }\n        }\n        if (av != null) {\n            av.visitEnd();\n        }\n        return v;\n    }\n\n    /**\n     * Reads a value of an annotation and makes the given visitor visit it.\n     *\n     * @param v the start offset in {@link #b b} of the value to be read (<i>not\n     *        including the value name constant pool index</i>).\n     * @param buf buffer to be used to call {@link #readUTF8 readUTF8},\n     *        {@link #readClass(int,char[]) readClass} or\n     *        {@link #readConst readConst}.\n     * @param name the name of the value to be read.\n     * @param av the visitor that must visit the value.\n     * @return the end offset of the annotation value.\n     */\n    private int readAnnotationValue(int v, final char[] buf, final String name, final AnnotationVisitor av) {\n        int i;\n        if (av == null) {\n            switch(b[v] & 0xFF) {\n                case // enum_const_value\n                'e':\n                    return v + 5;\n                case // annotation_value\n                '@':\n                    return readAnnotationValues(v + 3, buf, true, null);\n                case // array_value\n                '[':\n                    return readAnnotationValues(v + 1, buf, false, null);\n                default:\n                    return v + 3;\n            }\n        }\n        switch(b[v++] & 0xFF) {\n            // pointer to CONSTANT_Integer\n            case 'I':\n            // pointer to CONSTANT_Long\n            case 'J':\n            // pointer to CONSTANT_Float\n            case 'F':\n            case // pointer to CONSTANT_Double\n            'D':\n                av.visit(name, readConst(readUnsignedShort(v), buf));\n                v += 2;\n                break;\n            case // pointer to CONSTANT_Byte\n            'B':\n                av.visit(name, new Byte((byte) readInt(items[readUnsignedShort(v)])));\n                v += 2;\n                break;\n            case // pointer to CONSTANT_Boolean\n            'Z':\n                av.visit(name, readInt(items[readUnsignedShort(v)]) == 0 ? Boolean.FALSE : Boolean.TRUE);\n                v += 2;\n                break;\n            case // pointer to CONSTANT_Short\n            'S':\n                av.visit(name, new Short((short) readInt(items[readUnsignedShort(v)])));\n                v += 2;\n                break;\n            case // pointer to CONSTANT_Char\n            'C':\n                av.visit(name, new Character((char) readInt(items[readUnsignedShort(v)])));\n                v += 2;\n                break;\n            case // pointer to CONSTANT_Utf8\n            's':\n                av.visit(name, readUTF8(v, buf));\n                v += 2;\n                break;\n            case // enum_const_value\n            'e':\n                av.visitEnum(name, readUTF8(v, buf), readUTF8(v + 2, buf));\n                v += 4;\n                break;\n            case // class_info\n            'c':\n                av.visit(name, Type.getType(readUTF8(v, buf)));\n                v += 2;\n                break;\n            case // annotation_value\n            '@':\n                v = readAnnotationValues(v + 2, buf, true, av.visitAnnotation(name, readUTF8(v, buf)));\n                break;\n            case // array_value\n            '[':\n                int size = readUnsignedShort(v);\n                v += 2;\n                if (size == 0) {\n                    return readAnnotationValues(v - 2, buf, false, av.visitArray(name));\n                }\n                switch(this.b[v++] & 0xFF) {\n                    case 'B':\n                        byte[] bv = new byte[size];\n                        for (i = 0; i < size; i++) {\n                            bv[i] = (byte) readInt(items[readUnsignedShort(v)]);\n                            v += 3;\n                        }\n                        av.visit(name, bv);\n                        --v;\n                        break;\n                    case 'Z':\n                        boolean[] zv = new boolean[size];\n                        for (i = 0; i < size; i++) {\n                            zv[i] = readInt(items[readUnsignedShort(v)]) != 0;\n                            v += 3;\n                        }\n                        av.visit(name, zv);\n                        --v;\n                        break;\n                    case 'S':\n                        short[] sv = new short[size];\n                        for (i = 0; i < size; i++) {\n                            sv[i] = (short) readInt(items[readUnsignedShort(v)]);\n                            v += 3;\n                        }\n                        av.visit(name, sv);\n                        --v;\n                        break;\n                    case 'C':\n                        char[] cv = new char[size];\n                        for (i = 0; i < size; i++) {\n                            cv[i] = (char) readInt(items[readUnsignedShort(v)]);\n                            v += 3;\n                        }\n                        av.visit(name, cv);\n                        --v;\n                        break;\n                    case 'I':\n                        int[] iv = new int[size];\n                        for (i = 0; i < size; i++) {\n                            iv[i] = readInt(items[readUnsignedShort(v)]);\n                            v += 3;\n                        }\n                        av.visit(name, iv);\n                        --v;\n                        break;\n                    case 'J':\n                        long[] lv = new long[size];\n                        for (i = 0; i < size; i++) {\n                            lv[i] = readLong(items[readUnsignedShort(v)]);\n                            v += 3;\n                        }\n                        av.visit(name, lv);\n                        --v;\n                        break;\n                    case 'F':\n                        float[] fv = new float[size];\n                        for (i = 0; i < size; i++) {\n                            fv[i] = Float.intBitsToFloat(readInt(items[readUnsignedShort(v)]));\n                            v += 3;\n                        }\n                        av.visit(name, fv);\n                        --v;\n                        break;\n                    case 'D':\n                        double[] dv = new double[size];\n                        for (i = 0; i < size; i++) {\n                            dv[i] = Double.longBitsToDouble(readLong(items[readUnsignedShort(v)]));\n                            v += 3;\n                        }\n                        av.visit(name, dv);\n                        --v;\n                        break;\n                    default:\n                        v = readAnnotationValues(v - 3, buf, false, av.visitArray(name));\n                }\n        }\n        return v;\n    }\n\n    private int readFrameType(final Object[] frame, final int index, int v, final char[] buf, final Label[] labels) {\n        int type = b[v++] & 0xFF;\n        switch(type) {\n            case 0:\n                frame[index] = Opcodes.TOP;\n                break;\n            case 1:\n                frame[index] = Opcodes.INTEGER;\n                break;\n            case 2:\n                frame[index] = Opcodes.FLOAT;\n                break;\n            case 3:\n                frame[index] = Opcodes.DOUBLE;\n                break;\n            case 4:\n                frame[index] = Opcodes.LONG;\n                break;\n            case 5:\n                frame[index] = Opcodes.NULL;\n                break;\n            case 6:\n                frame[index] = Opcodes.UNINITIALIZED_THIS;\n                break;\n            case // Object\n            7:\n                frame[index] = readClass(v, buf);\n                v += 2;\n                break;\n            default:\n                // Uninitialized\n                frame[index] = readLabel(readUnsignedShort(v), labels);\n                v += 2;\n        }\n        return v;\n    }\n\n    /**\n     * Returns the label corresponding to the given offset. The default\n     * implementation of this method creates a label for the given offset if it\n     * has not been already created.\n     *\n     * @param offset a bytecode offset in a method.\n     * @param labels the already created labels, indexed by their offset. If a\n     *        label already exists for offset this method must not create a new\n     *        one. Otherwise it must store the new label in this array.\n     * @return a non null Label, which must be equal to labels[offset].\n     */\n    protected Label readLabel(int offset, Label[] labels) {\n        if (labels[offset] == null) {\n            labels[offset] = new Label();\n        }\n        return labels[offset];\n    }\n\n    /**\n     * Reads an attribute in {@link #b b}.\n     *\n     * @param attrs prototypes of the attributes that must be parsed during the\n     *        visit of the class. Any attribute whose type is not equal to the\n     *        type of one the prototypes is ignored (i.e. an empty\n     *        {@link Attribute} instance is returned).\n     * @param type the type of the attribute.\n     * @param off index of the first byte of the attribute's content in\n     *        {@link #b b}. The 6 attribute header bytes, containing the type\n     *        and the length of the attribute, are not taken into account here\n     *        (they have already been read).\n     * @param len the length of the attribute's content.\n     * @param buf buffer to be used to call {@link #readUTF8 readUTF8},\n     *        {@link #readClass(int,char[]) readClass} or\n     *        {@link #readConst readConst}.\n     * @param codeOff index of the first byte of code's attribute content in\n     *        {@link #b b}, or -1 if the attribute to be read is not a code\n     *        attribute. The 6 attribute header bytes, containing the type and\n     *        the length of the attribute, are not taken into account here.\n     * @param labels the labels of the method's code, or <tt>null</tt> if the\n     *        attribute to be read is not a code attribute.\n     * @return the attribute that has been read, or <tt>null</tt> to skip this\n     *         attribute.\n     */\n    private Attribute readAttribute(final Attribute[] attrs, final String type, final int off, final int len, final char[] buf, final int codeOff, final Label[] labels) {\n        for (int i = 0; i < attrs.length; ++i) {\n            if (attrs[i].type.equals(type)) {\n                return attrs[i].read(this, off, len, buf, codeOff, labels);\n            }\n        }\n        return new Attribute(type).read(this, off, len, null, -1, null);\n    }\n\n    // ------------------------------------------------------------------------\n    // Utility methods: low level parsing\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the start index of the constant pool item in {@link #b b}, plus\n     * one. <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param item the index a constant pool item.\n     * @return the start index of the constant pool item in {@link #b b}, plus\n     *         one.\n     */\n    public int getItem(final int item) {\n        return items[item];\n    }\n\n    /**\n     * Reads a byte value in {@link #b b}. <i>This method is intended for\n     * {@link Attribute} sub classes, and is normally not needed by class\n     * generators or adapters.</i>\n     *\n     * @param index the start index of the value to be read in {@link #b b}.\n     * @return the read value.\n     */\n    public int readByte(final int index) {\n        return b[index] & 0xFF;\n    }\n\n    /**\n     * Reads an unsigned short value in {@link #b b}. <i>This method is\n     * intended for {@link Attribute} sub classes, and is normally not needed by\n     * class generators or adapters.</i>\n     *\n     * @param index the start index of the value to be read in {@link #b b}.\n     * @return the read value.\n     */\n    public int readUnsignedShort(final int index) {\n        byte[] b = this.b;\n        return ((b[index] & 0xFF) << 8) | (b[index + 1] & 0xFF);\n    }\n\n    /**\n     * Reads a signed short value in {@link #b b}. <i>This method is intended\n     * for {@link Attribute} sub classes, and is normally not needed by class\n     * generators or adapters.</i>\n     *\n     * @param index the start index of the value to be read in {@link #b b}.\n     * @return the read value.\n     */\n    public short readShort(final int index) {\n        byte[] b = this.b;\n        return (short) (((b[index] & 0xFF) << 8) | (b[index + 1] & 0xFF));\n    }\n\n    /**\n     * Reads a signed int value in {@link #b b}. <i>This method is intended for\n     * {@link Attribute} sub classes, and is normally not needed by class\n     * generators or adapters.</i>\n     *\n     * @param index the start index of the value to be read in {@link #b b}.\n     * @return the read value.\n     */\n    public int readInt(final int index) {\n        byte[] b = this.b;\n        return ((b[index] & 0xFF) << 24) | ((b[index + 1] & 0xFF) << 16) | ((b[index + 2] & 0xFF) << 8) | (b[index + 3] & 0xFF);\n    }\n\n    /**\n     * Reads a signed long value in {@link #b b}. <i>This method is intended\n     * for {@link Attribute} sub classes, and is normally not needed by class\n     * generators or adapters.</i>\n     *\n     * @param index the start index of the value to be read in {@link #b b}.\n     * @return the read value.\n     */\n    public long readLong(final int index) {\n        long l1 = readInt(index);\n        long l0 = readInt(index + 4) & 0xFFFFFFFFL;\n        return (l1 << 32) | l0;\n    }\n\n    /**\n     * Reads an UTF8 string constant pool item in {@link #b b}. <i>This method\n     * is intended for {@link Attribute} sub classes, and is normally not needed\n     * by class generators or adapters.</i>\n     *\n     * @param index the start index of an unsigned short value in {@link #b b},\n     *        whose value is the index of an UTF8 constant pool item.\n     * @param buf buffer to be used to read the item. This buffer must be\n     *        sufficiently large. It is not automatically resized.\n     * @return the String corresponding to the specified UTF8 item.\n     */\n    public String readUTF8(int index, final char[] buf) {\n        int item = readUnsignedShort(index);\n        String s = strings[item];\n        if (s != null) {\n            return s;\n        }\n        index = items[item];\n        return strings[item] = readUTF(index + 2, readUnsignedShort(index), buf);\n    }\n\n    /**\n     * Reads UTF8 string in {@link #b b}.\n     *\n     * @param index start offset of the UTF8 string to be read.\n     * @param utfLen length of the UTF8 string to be read.\n     * @param buf buffer to be used to read the string. This buffer must be\n     *        sufficiently large. It is not automatically resized.\n     * @return the String corresponding to the specified UTF8 string.\n     */\n    private String readUTF(int index, final int utfLen, final char[] buf) {\n        int endIndex = index + utfLen;\n        byte[] b = this.b;\n        int strLen = 0;\n        int c;\n        int st = 0;\n        char cc = 0;\n        while (index < endIndex) {\n            c = b[index++];\n            switch(st) {\n                case 0:\n                    c = c & 0xFF;\n                    if (c < 0x80) {\n                        // 0xxxxxxx\n                        buf[strLen++] = (char) c;\n                    } else if (c < 0xE0 && c > 0xBF) {\n                        // 110x xxxx 10xx xxxx\n                        cc = (char) (c & 0x1F);\n                        st = 1;\n                    } else {\n                        // 1110 xxxx 10xx xxxx 10xx xxxx\n                        cc = (char) (c & 0x0F);\n                        st = 2;\n                    }\n                    break;\n                case // byte 2 of 2-byte char or byte 3 of 3-byte char\n                1:\n                    buf[strLen++] = (char) ((cc << 6) | (c & 0x3F));\n                    st = 0;\n                    break;\n                case // byte 2 of 3-byte char\n                2:\n                    cc = (char) ((cc << 6) | (c & 0x3F));\n                    st = 1;\n                    break;\n            }\n        }\n        return new String(buf, 0, strLen);\n    }\n\n    /**\n     * Reads a class constant pool item in {@link #b b}. <i>This method is\n     * intended for {@link Attribute} sub classes, and is normally not needed by\n     * class generators or adapters.</i>\n     *\n     * @param index the start index of an unsigned short value in {@link #b b},\n     *        whose value is the index of a class constant pool item.\n     * @param buf buffer to be used to read the item. This buffer must be\n     *        sufficiently large. It is not automatically resized.\n     * @return the String corresponding to the specified class item.\n     */\n    public String readClass(final int index, final char[] buf) {\n        // computes the start index of the CONSTANT_Class item in b\n        // and reads the CONSTANT_Utf8 item designated by\n        // the first two bytes of this CONSTANT_Class item\n        return readUTF8(items[readUnsignedShort(index)], buf);\n    }\n\n    /**\n     * Reads a numeric or string constant pool item in {@link #b b}. <i>This\n     * method is intended for {@link Attribute} sub classes, and is normally not\n     * needed by class generators or adapters.</i>\n     *\n     * @param item the index of a constant pool item.\n     * @param buf buffer to be used to read the item. This buffer must be\n     *        sufficiently large. It is not automatically resized.\n     * @return the {@link Integer}, {@link Float}, {@link Long},\n     *         {@link Double}, {@link String} or {@link Type} corresponding to\n     *         the given constant pool item.\n     */\n    public Object readConst(final int item, final char[] buf) {\n        int index = items[item];\n        switch(b[index - 1]) {\n            case ClassWriter.INT:\n                return new Integer(readInt(index));\n            case ClassWriter.FLOAT:\n                return new Float(Float.intBitsToFloat(readInt(index)));\n            case ClassWriter.LONG:\n                return new Long(readLong(index));\n            case ClassWriter.DOUBLE:\n                return new Double(Double.longBitsToDouble(readLong(index)));\n            case ClassWriter.CLASS:\n                return Type.getObjectType(readUTF8(index, buf));\n            // case ClassWriter.STR:\n            default:\n                return readUTF8(index, buf);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/ClassReaderTest5.java",
		"test_prompt": "// ClassReaderTest5.java\npackage org.objectweb.asm.jip;\n\nimport java.io.InputStream;\nimport java.io.IOException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassReader}.\n* It contains ten unit test cases for the {@link ClassReader#readUTF8(int, char[])} method.\n*/\nclass ClassReaderTest5 {"
	},
	{
		"original_code": "// ClassReader.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\nimport java.io.InputStream;\nimport java.io.IOException;\n\n/**\n * A Java class parser to make a {@link ClassVisitor} visit an existing class.\n * This class parses a byte array conforming to the Java class file format and\n * calls the appropriate visit methods of a given class visitor for each field,\n * method and bytecode instruction encountered.\n *\n * @author Eric Bruneton\n * @author Eugene Kuleshov\n */\npublic class ClassReader {\n\n    /**\n     * True to enable signatures support.\n     */\n    static final boolean SIGNATURES = true;\n\n    /**\n     * True to enable annotations support.\n     */\n    static final boolean ANNOTATIONS = true;\n\n    /**\n     * True to enable stack map frames support.\n     */\n    static final boolean FRAMES = true;\n\n    /**\n     * True to enable bytecode writing support.\n     */\n    static final boolean WRITER = true;\n\n    /**\n     * True to enable JSR_W and GOTO_W support.\n     */\n    static final boolean RESIZE = true;\n\n    /**\n     * Flag to skip method code. If this class is set <code>CODE</code>\n     * attribute won't be visited. This can be used, for example, to retrieve\n     * annotations for methods and method parameters.\n     */\n    public static final int SKIP_CODE = 1;\n\n    /**\n     * Flag to skip the debug information in the class. If this flag is set the\n     * debug information of the class is not visited, i.e. the\n     * {@link MethodVisitor#visitLocalVariable visitLocalVariable} and\n     * {@link MethodVisitor#visitLineNumber visitLineNumber} methods will not be\n     * called.\n     */\n    public static final int SKIP_DEBUG = 2;\n\n    /**\n     * Flag to skip the stack map frames in the class. If this flag is set the\n     * stack map frames of the class is not visited, i.e. the\n     * {@link MethodVisitor#visitFrame visitFrame} method will not be called.\n     * This flag is useful when the {@link ClassWriter#COMPUTE_FRAMES} option is\n     * used: it avoids visiting frames that will be ignored and recomputed from\n     * scratch in the class writer.\n     */\n    public static final int SKIP_FRAMES = 4;\n\n    /**\n     * Flag to expand the stack map frames. By default stack map frames are\n     * visited in their original format (i.e. \"expanded\" for classes whose\n     * version is less than V1_6, and \"compressed\" for the other classes). If\n     * this flag is set, stack map frames are always visited in expanded format\n     * (this option adds a decompression/recompression step in ClassReader and\n     * ClassWriter which degrades performances quite a lot).\n     */\n    public static final int EXPAND_FRAMES = 8;\n\n    /**\n     * The class to be parsed. <i>The content of this array must not be\n     * modified. This field is intended for {@link Attribute} sub classes, and\n     * is normally not needed by class generators or adapters.</i>\n     */\n    public final byte[] b;\n\n    /**\n     * The start index of each constant pool item in {@link #b b}, plus one.\n     * The one byte offset skips the constant pool item tag that indicates its\n     * type.\n     */\n    private final int[] items;\n\n    /**\n     * The String objects corresponding to the CONSTANT_Utf8 items. This cache\n     * avoids multiple parsing of a given CONSTANT_Utf8 constant pool item,\n     * which GREATLY improves performances (by a factor 2 to 3). This caching\n     * strategy could be extended to all constant pool items, but its benefit\n     * would not be so great for these items (because they are much less\n     * expensive to parse than CONSTANT_Utf8 items).\n     */\n    private final String[] strings;\n\n    /**\n     * Maximum length of the strings contained in the constant pool of the\n     * class.\n     */\n    private final int maxStringLength;\n\n    /**\n     * Start index of the class header information (access, name...) in\n     * {@link #b b}.\n     */\n    public final int header;\n\n    // ------------------------------------------------------------------------\n    // Constructors\n    // ------------------------------------------------------------------------\n    /**\n     * Constructs a new {@link ClassReader} object.\n     *\n     * @param b the bytecode of the class to be read.\n     */\n    public ClassReader(final byte[] b) {\n        this(b, 0, b.length);\n    }\n\n    /**\n     * Constructs a new {@link ClassReader} object.\n     *\n     * @param b the bytecode of the class to be read.\n     * @param off the start offset of the class data.\n     * @param len the length of the class data.\n     */\n    public ClassReader(final byte[] b, final int off, final int len) {\n        this.b = b;\n        // parses the constant pool\n        items = new int[readUnsignedShort(off + 8)];\n        int n = items.length;\n        strings = new String[n];\n        int max = 0;\n        int index = off + 10;\n        for (int i = 1; i < n; ++i) {\n            items[i] = index + 1;\n            int size;\n            switch(b[index]) {\n                case ClassWriter.FIELD:\n                case ClassWriter.METH:\n                case ClassWriter.IMETH:\n                case ClassWriter.INT:\n                case ClassWriter.FLOAT:\n                case ClassWriter.NAME_TYPE:\n                    size = 5;\n                    break;\n                case ClassWriter.LONG:\n                case ClassWriter.DOUBLE:\n                    size = 9;\n                    ++i;\n                    break;\n                case ClassWriter.UTF8:\n                    size = 3 + readUnsignedShort(index + 1);\n                    if (size > max) {\n                        max = size;\n                    }\n                    break;\n                // case ClassWriter.CLASS:\n                // case ClassWriter.STR:\n                default:\n                    size = 3;\n                    break;\n            }\n            index += size;\n        }\n        maxStringLength = max;\n        // the class header information starts just after the constant pool\n        header = index;\n    }\n\n    /**\n     * Returns the class's access flags (see {@link Opcodes}). This value may\n     * not reflect Deprecated and Synthetic flags when bytecode is before 1.5\n     * and those flags are represented by attributes.\n     *\n     * @return the class access flags\n     *\n     * @see ClassVisitor#visit(int, int, String, String, String, String[])\n     */\n    public int getAccess() {\n        return readUnsignedShort(header);\n    }\n\n    /**\n     * Returns the internal name of the class (see\n     * {@link Type#getInternalName() getInternalName}).\n     *\n     * @return the internal class name\n     *\n     * @see ClassVisitor#visit(int, int, String, String, String, String[])\n     */\n    public String getClassName() {\n        return readClass(header + 2, new char[maxStringLength]);\n    }\n\n    /**\n     * Returns the internal of name of the super class (see\n     * {@link Type#getInternalName() getInternalName}). For interfaces, the\n     * super class is {@link Object}.\n     *\n     * @return the internal name of super class, or <tt>null</tt> for\n     *         {@link Object} class.\n     *\n     * @see ClassVisitor#visit(int, int, String, String, String, String[])\n     */\n    public String getSuperName() {\n        int n = items[readUnsignedShort(header + 4)];\n        return n == 0 ? null : readUTF8(n, new char[maxStringLength]);\n    }\n\n    /**\n     * Returns the internal names of the class's interfaces (see\n     * {@link Type#getInternalName() getInternalName}).\n     *\n     * @return the array of internal names for all implemented interfaces or\n     *         <tt>null</tt>.\n     *\n     * @see ClassVisitor#visit(int, int, String, String, String, String[])\n     */\n    public String[] getInterfaces() {\n        int index = header + 6;\n        int n = readUnsignedShort(index);\n        String[] interfaces = new String[n];\n        if (n > 0) {\n            char[] buf = new char[maxStringLength];\n            for (int i = 0; i < n; ++i) {\n                index += 2;\n                interfaces[i] = readClass(index, buf);\n            }\n        }\n        return interfaces;\n    }\n\n    /**\n     * Copies the constant pool data into the given {@link ClassWriter}. Should\n     * be called before the {@link #accept(ClassVisitor,int)} method.\n     *\n     * @param classWriter the {@link ClassWriter} to copy constant pool into.\n     */\n    void copyPool(final ClassWriter classWriter) {\n        char[] buf = new char[maxStringLength];\n        int ll = items.length;\n        Item[] items2 = new Item[ll];\n        for (int i = 1; i < ll; i++) {\n            int index = items[i];\n            int tag = b[index - 1];\n            Item item = new Item(i);\n            int nameType;\n            switch(tag) {\n                case ClassWriter.FIELD:\n                case ClassWriter.METH:\n                case ClassWriter.IMETH:\n                    nameType = items[readUnsignedShort(index + 2)];\n                    item.set(tag, readClass(index, buf), readUTF8(nameType, buf), readUTF8(nameType + 2, buf));\n                    break;\n                case ClassWriter.INT:\n                    item.set(readInt(index));\n                    break;\n                case ClassWriter.FLOAT:\n                    item.set(Float.intBitsToFloat(readInt(index)));\n                    break;\n                case ClassWriter.NAME_TYPE:\n                    item.set(tag, readUTF8(index, buf), readUTF8(index + 2, buf), null);\n                    break;\n                case ClassWriter.LONG:\n                    item.set(readLong(index));\n                    ++i;\n                    break;\n                case ClassWriter.DOUBLE:\n                    item.set(Double.longBitsToDouble(readLong(index)));\n                    ++i;\n                    break;\n                case ClassWriter.UTF8:\n                    {\n                        String s = strings[i];\n                        if (s == null) {\n                            index = items[i];\n                            s = strings[i] = readUTF(index + 2, readUnsignedShort(index), buf);\n                        }\n                        item.set(tag, s, null, null);\n                    }\n                    break;\n                // case ClassWriter.STR:\n                // case ClassWriter.CLASS:\n                default:\n                    item.set(tag, readUTF8(index, buf), null, null);\n                    break;\n            }\n            int index2 = item.hashCode % items2.length;\n            item.next = items2[index2];\n            items2[index2] = item;\n        }\n        int off = items[1] - 1;\n        classWriter.pool.putByteArray(b, off, header - off);\n        classWriter.items = items2;\n        classWriter.threshold = (int) (0.75d * ll);\n        classWriter.index = ll;\n    }\n\n    /**\n     * Constructs a new {@link ClassReader} object.\n     *\n     * @param is an input stream from which to read the class.\n     * @throws IOException if a problem occurs during reading.\n     */\n    public ClassReader(final InputStream is) throws IOException {\n        this(readClass(is));\n    }\n\n    /**\n     * Constructs a new {@link ClassReader} object.\n     *\n     * @param name the fully qualified name of the class to be read.\n     * @throws IOException if an exception occurs during reading.\n     */\n    public ClassReader(final String name) throws IOException {\n        this(ClassLoader.getSystemResourceAsStream(name.replace('.', '/') + \".class\"));\n    }\n\n    /**\n     * Reads the bytecode of a class.\n     *\n     * @param is an input stream from which to read the class.\n     * @return the bytecode read from the given input stream.\n     * @throws IOException if a problem occurs during reading.\n     */\n    private static byte[] readClass(final InputStream is) throws IOException {\n        if (is == null) {\n            throw new IOException(\"Class not found\");\n        }\n        byte[] b = new byte[is.available()];\n        int len = 0;\n        while (true) {\n            int n = is.read(b, len, b.length - len);\n            if (n == -1) {\n                if (len < b.length) {\n                    byte[] c = new byte[len];\n                    System.arraycopy(b, 0, c, 0, len);\n                    b = c;\n                }\n                return b;\n            }\n            len += n;\n            if (len == b.length) {\n                int last = is.read();\n                if (last < 0) {\n                    return b;\n                }\n                byte[] c = new byte[b.length + 1000];\n                System.arraycopy(b, 0, c, 0, len);\n                c[len++] = (byte) last;\n                b = c;\n            }\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Public methods\n    // ------------------------------------------------------------------------\n    /**\n     * Makes the given visitor visit the Java class of this {@link ClassReader}.\n     * This class is the one specified in the constructor (see\n     * {@link #ClassReader(byte[]) ClassReader}).\n     *\n     * @param classVisitor the visitor that must visit this class.\n     * @param flags option flags that can be used to modify the default behavior\n     *        of this class. See {@link #SKIP_DEBUG}, {@link #EXPAND_FRAMES},\n     *        {@link #SKIP_FRAMES}, {@link #SKIP_CODE}.\n     */\n    public void accept(final ClassVisitor classVisitor, final int flags) {\n        accept(classVisitor, new Attribute[0], flags);\n    }\n\n    /**\n     * Makes the given visitor visit the Java class of this {@link ClassReader}.\n     * This class is the one specified in the constructor (see\n     * {@link #ClassReader(byte[]) ClassReader}).\n     *\n     * @param classVisitor the visitor that must visit this class.\n     * @param attrs prototypes of the attributes that must be parsed during the\n     *        visit of the class. Any attribute whose type is not equal to the\n     *        type of one the prototypes will not be parsed: its byte array\n     *        value will be passed unchanged to the ClassWriter. <i>This may\n     *        corrupt it if this value contains references to the constant pool,\n     *        or has syntactic or semantic links with a class element that has\n     *        been transformed by a class adapter between the reader and the\n     *        writer</i>.\n     * @param flags option flags that can be used to modify the default behavior\n     *        of this class. See {@link #SKIP_DEBUG}, {@link #EXPAND_FRAMES},\n     *        {@link #SKIP_FRAMES}, {@link #SKIP_CODE}.\n     */\n    public void accept(final ClassVisitor classVisitor, final Attribute[] attrs, final int flags) {\n        // the bytecode array\n        byte[] b = this.b;\n        // buffer used to read strings\n        char[] c = new char[maxStringLength];\n        // loop variables\n        int i, j, k;\n        // indexes in b\n        int u, v, w;\n        Attribute attr;\n        int access;\n        String name;\n        String desc;\n        String attrName;\n        String signature;\n        int anns = 0;\n        int ianns = 0;\n        Attribute cattrs = null;\n        // visits the header\n        u = header;\n        access = readUnsignedShort(u);\n        name = readClass(u + 2, c);\n        v = items[readUnsignedShort(u + 4)];\n        String superClassName = v == 0 ? null : readUTF8(v, c);\n        String[] implementedItfs = new String[readUnsignedShort(u + 6)];\n        w = 0;\n        u += 8;\n        for (i = 0; i < implementedItfs.length; ++i) {\n            implementedItfs[i] = readClass(u, c);\n            u += 2;\n        }\n        boolean skipCode = (flags & SKIP_CODE) != 0;\n        boolean skipDebug = (flags & SKIP_DEBUG) != 0;\n        boolean unzip = (flags & EXPAND_FRAMES) != 0;\n        // skips fields and methods\n        v = u;\n        i = readUnsignedShort(v);\n        v += 2;\n        for (; i > 0; --i) {\n            j = readUnsignedShort(v + 6);\n            v += 8;\n            for (; j > 0; --j) {\n                v += 6 + readInt(v + 2);\n            }\n        }\n        i = readUnsignedShort(v);\n        v += 2;\n        for (; i > 0; --i) {\n            j = readUnsignedShort(v + 6);\n            v += 8;\n            for (; j > 0; --j) {\n                v += 6 + readInt(v + 2);\n            }\n        }\n        // reads the class's attributes\n        signature = null;\n        String sourceFile = null;\n        String sourceDebug = null;\n        String enclosingOwner = null;\n        String enclosingName = null;\n        String enclosingDesc = null;\n        i = readUnsignedShort(v);\n        v += 2;\n        for (; i > 0; --i) {\n            attrName = readUTF8(v, c);\n            // tests are sorted in decreasing frequency order\n            // (based on frequencies observed on typical classes)\n            if (\"SourceFile\".equals(attrName)) {\n                sourceFile = readUTF8(v + 6, c);\n            } else if (\"InnerClasses\".equals(attrName)) {\n                w = v + 6;\n            } else if (\"EnclosingMethod\".equals(attrName)) {\n                enclosingOwner = readClass(v + 6, c);\n                int item = readUnsignedShort(v + 8);\n                if (item != 0) {\n                    enclosingName = readUTF8(items[item], c);\n                    enclosingDesc = readUTF8(items[item] + 2, c);\n                }\n            } else if (SIGNATURES && \"Signature\".equals(attrName)) {\n                signature = readUTF8(v + 6, c);\n            } else if (ANNOTATIONS && \"RuntimeVisibleAnnotations\".equals(attrName)) {\n                anns = v + 6;\n            } else if (\"Deprecated\".equals(attrName)) {\n                access |= Opcodes.ACC_DEPRECATED;\n            } else if (\"Synthetic\".equals(attrName)) {\n                access |= Opcodes.ACC_SYNTHETIC;\n            } else if (\"SourceDebugExtension\".equals(attrName)) {\n                int len = readInt(v + 2);\n                sourceDebug = readUTF(v + 6, len, new char[len]);\n            } else if (ANNOTATIONS && \"RuntimeInvisibleAnnotations\".equals(attrName)) {\n                ianns = v + 6;\n            } else {\n                attr = readAttribute(attrs, attrName, v + 6, readInt(v + 2), c, -1, null);\n                if (attr != null) {\n                    attr.next = cattrs;\n                    cattrs = attr;\n                }\n            }\n            v += 6 + readInt(v + 2);\n        }\n        // calls the visit method\n        classVisitor.visit(readInt(4), access, name, signature, superClassName, implementedItfs);\n        // calls the visitSource method\n        if (!skipDebug && (sourceFile != null || sourceDebug != null)) {\n            classVisitor.visitSource(sourceFile, sourceDebug);\n        }\n        // calls the visitOuterClass method\n        if (enclosingOwner != null) {\n            classVisitor.visitOuterClass(enclosingOwner, enclosingName, enclosingDesc);\n        }\n        // visits the class annotations\n        if (ANNOTATIONS) {\n            for (i = 1; i >= 0; --i) {\n                v = i == 0 ? ianns : anns;\n                if (v != 0) {\n                    j = readUnsignedShort(v);\n                    v += 2;\n                    for (; j > 0; --j) {\n                        v = readAnnotationValues(v + 2, c, true, classVisitor.visitAnnotation(readUTF8(v, c), i != 0));\n                    }\n                }\n            }\n        }\n        // visits the class attributes\n        while (cattrs != null) {\n            attr = cattrs.next;\n            cattrs.next = null;\n            classVisitor.visitAttribute(cattrs);\n            cattrs = attr;\n        }\n        // calls the visitInnerClass method\n        if (w != 0) {\n            i = readUnsignedShort(w);\n            w += 2;\n            for (; i > 0; --i) {\n                classVisitor.visitInnerClass(readUnsignedShort(w) == 0 ? null : readClass(w, c), readUnsignedShort(w + 2) == 0 ? null : readClass(w + 2, c), readUnsignedShort(w + 4) == 0 ? null : readUTF8(w + 4, c), readUnsignedShort(w + 6));\n                w += 8;\n            }\n        }\n        // visits the fields\n        i = readUnsignedShort(u);\n        u += 2;\n        for (; i > 0; --i) {\n            access = readUnsignedShort(u);\n            name = readUTF8(u + 2, c);\n            desc = readUTF8(u + 4, c);\n            // visits the field's attributes and looks for a ConstantValue\n            // attribute\n            int fieldValueItem = 0;\n            signature = null;\n            anns = 0;\n            ianns = 0;\n            cattrs = null;\n            j = readUnsignedShort(u + 6);\n            u += 8;\n            for (; j > 0; --j) {\n                attrName = readUTF8(u, c);\n                // tests are sorted in decreasing frequency order\n                // (based on frequencies observed on typical classes)\n                if (\"ConstantValue\".equals(attrName)) {\n                    fieldValueItem = readUnsignedShort(u + 6);\n                } else if (SIGNATURES && \"Signature\".equals(attrName)) {\n                    signature = readUTF8(u + 6, c);\n                } else if (\"Deprecated\".equals(attrName)) {\n                    access |= Opcodes.ACC_DEPRECATED;\n                } else if (\"Synthetic\".equals(attrName)) {\n                    access |= Opcodes.ACC_SYNTHETIC;\n                } else if (ANNOTATIONS && \"RuntimeVisibleAnnotations\".equals(attrName)) {\n                    anns = u + 6;\n                } else if (ANNOTATIONS && \"RuntimeInvisibleAnnotations\".equals(attrName)) {\n                    ianns = u + 6;\n                } else {\n                    attr = readAttribute(attrs, attrName, u + 6, readInt(u + 2), c, -1, null);\n                    if (attr != null) {\n                        attr.next = cattrs;\n                        cattrs = attr;\n                    }\n                }\n                u += 6 + readInt(u + 2);\n            }\n            // visits the field\n            FieldVisitor fv = classVisitor.visitField(access, name, desc, signature, fieldValueItem == 0 ? null : readConst(fieldValueItem, c));\n            // visits the field annotations and attributes\n            if (fv != null) {\n                if (ANNOTATIONS) {\n                    for (j = 1; j >= 0; --j) {\n                        v = j == 0 ? ianns : anns;\n                        if (v != 0) {\n                            k = readUnsignedShort(v);\n                            v += 2;\n                            for (; k > 0; --k) {\n                                v = readAnnotationValues(v + 2, c, true, fv.visitAnnotation(readUTF8(v, c), j != 0));\n                            }\n                        }\n                    }\n                }\n                while (cattrs != null) {\n                    attr = cattrs.next;\n                    cattrs.next = null;\n                    fv.visitAttribute(cattrs);\n                    cattrs = attr;\n                }\n                fv.visitEnd();\n            }\n        }\n        // visits the methods\n        i = readUnsignedShort(u);\n        u += 2;\n        for (; i > 0; --i) {\n            int u0 = u + 6;\n            access = readUnsignedShort(u);\n            name = readUTF8(u + 2, c);\n            desc = readUTF8(u + 4, c);\n            signature = null;\n            anns = 0;\n            ianns = 0;\n            int dann = 0;\n            int mpanns = 0;\n            int impanns = 0;\n            cattrs = null;\n            v = 0;\n            w = 0;\n            // looks for Code and Exceptions attributes\n            j = readUnsignedShort(u + 6);\n            u += 8;\n            for (; j > 0; --j) {\n                attrName = readUTF8(u, c);\n                int attrSize = readInt(u + 2);\n                u += 6;\n                // tests are sorted in decreasing frequency order\n                // (based on frequencies observed on typical classes)\n                if (\"Code\".equals(attrName)) {\n                    if (!skipCode) {\n                        v = u;\n                    }\n                } else if (\"Exceptions\".equals(attrName)) {\n                    w = u;\n                } else if (SIGNATURES && \"Signature\".equals(attrName)) {\n                    signature = readUTF8(u, c);\n                } else if (\"Deprecated\".equals(attrName)) {\n                    access |= Opcodes.ACC_DEPRECATED;\n                } else if (ANNOTATIONS && \"RuntimeVisibleAnnotations\".equals(attrName)) {\n                    anns = u;\n                } else if (ANNOTATIONS && \"AnnotationDefault\".equals(attrName)) {\n                    dann = u;\n                } else if (\"Synthetic\".equals(attrName)) {\n                    access |= Opcodes.ACC_SYNTHETIC;\n                } else if (ANNOTATIONS && \"RuntimeInvisibleAnnotations\".equals(attrName)) {\n                    ianns = u;\n                } else if (ANNOTATIONS && \"RuntimeVisibleParameterAnnotations\".equals(attrName)) {\n                    mpanns = u;\n                } else if (ANNOTATIONS && \"RuntimeInvisibleParameterAnnotations\".equals(attrName)) {\n                    impanns = u;\n                } else {\n                    attr = readAttribute(attrs, attrName, u, attrSize, c, -1, null);\n                    if (attr != null) {\n                        attr.next = cattrs;\n                        cattrs = attr;\n                    }\n                }\n                u += attrSize;\n            }\n            // reads declared exceptions\n            String[] exceptions;\n            if (w == 0) {\n                exceptions = null;\n            } else {\n                exceptions = new String[readUnsignedShort(w)];\n                w += 2;\n                for (j = 0; j < exceptions.length; ++j) {\n                    exceptions[j] = readClass(w, c);\n                    w += 2;\n                }\n            }\n            // visits the method's code, if any\n            MethodVisitor mv = classVisitor.visitMethod(access, name, desc, signature, exceptions);\n            if (mv != null) {\n                /*\n                 * if the returned MethodVisitor is in fact a MethodWriter, it\n                 * means there is no method adapter between the reader and the\n                 * writer. If, in addition, the writer's constant pool was\n                 * copied from this reader (mw.cw.cr == this), and the signature\n                 * and exceptions of the method have not been changed, then it\n                 * is possible to skip all visit events and just copy the\n                 * original code of the method to the writer (the access, name\n                 * and descriptor can have been changed, this is not important\n                 * since they are not copied as is from the reader).\n                 */\n                if (WRITER && mv instanceof MethodWriter) {\n                    MethodWriter mw = (MethodWriter) mv;\n                    if (mw.cw.cr == this) {\n                        if (signature == mw.signature) {\n                            boolean sameExceptions = false;\n                            if (exceptions == null) {\n                                sameExceptions = mw.exceptionCount == 0;\n                            } else {\n                                if (exceptions.length == mw.exceptionCount) {\n                                    sameExceptions = true;\n                                    for (j = exceptions.length - 1; j >= 0; --j) {\n                                        w -= 2;\n                                        if (mw.exceptions[j] != readUnsignedShort(w)) {\n                                            sameExceptions = false;\n                                            break;\n                                        }\n                                    }\n                                }\n                            }\n                            if (sameExceptions) {\n                                /*\n                                 * we do not copy directly the code into\n                                 * MethodWriter to save a byte array copy\n                                 * operation. The real copy will be done in\n                                 * ClassWriter.toByteArray().\n                                 */\n                                mw.classReaderOffset = u0;\n                                mw.classReaderLength = u - u0;\n                                continue;\n                            }\n                        }\n                    }\n                }\n                if (ANNOTATIONS && dann != 0) {\n                    AnnotationVisitor dv = mv.visitAnnotationDefault();\n                    readAnnotationValue(dann, c, null, dv);\n                    if (dv != null) {\n                        dv.visitEnd();\n                    }\n                }\n                if (ANNOTATIONS) {\n                    for (j = 1; j >= 0; --j) {\n                        w = j == 0 ? ianns : anns;\n                        if (w != 0) {\n                            k = readUnsignedShort(w);\n                            w += 2;\n                            for (; k > 0; --k) {\n                                w = readAnnotationValues(w + 2, c, true, mv.visitAnnotation(readUTF8(w, c), j != 0));\n                            }\n                        }\n                    }\n                }\n                if (ANNOTATIONS && mpanns != 0) {\n                    readParameterAnnotations(mpanns, desc, c, true, mv);\n                }\n                if (ANNOTATIONS && impanns != 0) {\n                    readParameterAnnotations(impanns, desc, c, false, mv);\n                }\n                while (cattrs != null) {\n                    attr = cattrs.next;\n                    cattrs.next = null;\n                    mv.visitAttribute(cattrs);\n                    cattrs = attr;\n                }\n            }\n            if (mv != null && v != 0) {\n                int maxStack = readUnsignedShort(v);\n                int maxLocals = readUnsignedShort(v + 2);\n                int codeLength = readInt(v + 4);\n                v += 8;\n                int codeStart = v;\n                int codeEnd = v + codeLength;\n                mv.visitCode();\n                // 1st phase: finds the labels\n                int label;\n                Label[] labels = new Label[codeLength + 2];\n                readLabel(codeLength + 1, labels);\n                while (v < codeEnd) {\n                    w = v - codeStart;\n                    int opcode = b[v] & 0xFF;\n                    switch(ClassWriter.TYPE[opcode]) {\n                        case ClassWriter.NOARG_INSN:\n                        case ClassWriter.IMPLVAR_INSN:\n                            v += 1;\n                            break;\n                        case ClassWriter.LABEL_INSN:\n                            readLabel(w + readShort(v + 1), labels);\n                            v += 3;\n                            break;\n                        case ClassWriter.LABELW_INSN:\n                            readLabel(w + readInt(v + 1), labels);\n                            v += 5;\n                            break;\n                        case ClassWriter.WIDE_INSN:\n                            opcode = b[v + 1] & 0xFF;\n                            if (opcode == Opcodes.IINC) {\n                                v += 6;\n                            } else {\n                                v += 4;\n                            }\n                            break;\n                        case ClassWriter.TABL_INSN:\n                            // skips 0 to 3 padding bytes*\n                            v = v + 4 - (w & 3);\n                            // reads instruction\n                            readLabel(w + readInt(v), labels);\n                            j = readInt(v + 8) - readInt(v + 4) + 1;\n                            v += 12;\n                            for (; j > 0; --j) {\n                                readLabel(w + readInt(v), labels);\n                                v += 4;\n                            }\n                            break;\n                        case ClassWriter.LOOK_INSN:\n                            // skips 0 to 3 padding bytes*\n                            v = v + 4 - (w & 3);\n                            // reads instruction\n                            readLabel(w + readInt(v), labels);\n                            j = readInt(v + 4);\n                            v += 8;\n                            for (; j > 0; --j) {\n                                readLabel(w + readInt(v + 4), labels);\n                                v += 8;\n                            }\n                            break;\n                        case ClassWriter.VAR_INSN:\n                        case ClassWriter.SBYTE_INSN:\n                        case ClassWriter.LDC_INSN:\n                            v += 2;\n                            break;\n                        case ClassWriter.SHORT_INSN:\n                        case ClassWriter.LDCW_INSN:\n                        case ClassWriter.FIELDORMETH_INSN:\n                        case ClassWriter.TYPE_INSN:\n                        case ClassWriter.IINC_INSN:\n                            v += 3;\n                            break;\n                        case ClassWriter.ITFDYNMETH_INSN:\n                            v += 5;\n                            break;\n                        // case MANA_INSN:\n                        default:\n                            v += 4;\n                            break;\n                    }\n                }\n                // parses the try catch entries\n                j = readUnsignedShort(v);\n                v += 2;\n                for (; j > 0; --j) {\n                    Label start = readLabel(readUnsignedShort(v), labels);\n                    Label end = readLabel(readUnsignedShort(v + 2), labels);\n                    Label handler = readLabel(readUnsignedShort(v + 4), labels);\n                    int type = readUnsignedShort(v + 6);\n                    if (type == 0) {\n                        mv.visitTryCatchBlock(start, end, handler, null);\n                    } else {\n                        mv.visitTryCatchBlock(start, end, handler, readUTF8(items[type], c));\n                    }\n                    v += 8;\n                }\n                // parses the local variable, line number tables, and code\n                // attributes\n                int varTable = 0;\n                int varTypeTable = 0;\n                int stackMap = 0;\n                int stackMapSize = 0;\n                int frameCount = 0;\n                int frameMode = 0;\n                int frameOffset = 0;\n                int frameLocalCount = 0;\n                int frameLocalDiff = 0;\n                int frameStackCount = 0;\n                Object[] frameLocal = null;\n                Object[] frameStack = null;\n                boolean zip = true;\n                cattrs = null;\n                j = readUnsignedShort(v);\n                v += 2;\n                for (; j > 0; --j) {\n                    attrName = readUTF8(v, c);\n                    if (\"LocalVariableTable\".equals(attrName)) {\n                        if (!skipDebug) {\n                            varTable = v + 6;\n                            k = readUnsignedShort(v + 6);\n                            w = v + 8;\n                            for (; k > 0; --k) {\n                                label = readUnsignedShort(w);\n                                if (labels[label] == null) {\n                                    readLabel(label, labels).status |= Label.DEBUG;\n                                }\n                                label += readUnsignedShort(w + 2);\n                                if (labels[label] == null) {\n                                    readLabel(label, labels).status |= Label.DEBUG;\n                                }\n                                w += 10;\n                            }\n                        }\n                    } else if (\"LocalVariableTypeTable\".equals(attrName)) {\n                        varTypeTable = v + 6;\n                    } else if (\"LineNumberTable\".equals(attrName)) {\n                        if (!skipDebug) {\n                            k = readUnsignedShort(v + 6);\n                            w = v + 8;\n                            for (; k > 0; --k) {\n                                label = readUnsignedShort(w);\n                                if (labels[label] == null) {\n                                    readLabel(label, labels).status |= Label.DEBUG;\n                                }\n                                labels[label].line = readUnsignedShort(w + 2);\n                                w += 4;\n                            }\n                        }\n                    } else if (FRAMES && \"StackMapTable\".equals(attrName)) {\n                        if ((flags & SKIP_FRAMES) == 0) {\n                            stackMap = v + 8;\n                            stackMapSize = readInt(v + 2);\n                            frameCount = readUnsignedShort(v + 6);\n                        }\n                        /*\n                         * here we do not extract the labels corresponding to\n                         * the attribute content. This would require a full\n                         * parsing of the attribute, which would need to be\n                         * repeated in the second phase (see below). Instead the\n                         * content of the attribute is read one frame at a time\n                         * (i.e. after a frame has been visited, the next frame\n                         * is read), and the labels it contains are also\n                         * extracted one frame at a time. Thanks to the ordering\n                         * of frames, having only a \"one frame lookahead\" is not\n                         * a problem, i.e. it is not possible to see an offset\n                         * smaller than the offset of the current insn and for\n                         * which no Label exist.\n                         */\n                        /*\n                         * This is not true for UNINITIALIZED type offsets. We\n                         * solve this by parsing the stack map table without a\n                         * full decoding (see below).\n                         */\n                    } else if (FRAMES && \"StackMap\".equals(attrName)) {\n                        if ((flags & SKIP_FRAMES) == 0) {\n                            stackMap = v + 8;\n                            stackMapSize = readInt(v + 2);\n                            frameCount = readUnsignedShort(v + 6);\n                            zip = false;\n                        }\n                        /*\n                         * IMPORTANT! here we assume that the frames are\n                         * ordered, as in the StackMapTable attribute, although\n                         * this is not guaranteed by the attribute format.\n                         */\n                    } else {\n                        for (k = 0; k < attrs.length; ++k) {\n                            if (attrs[k].type.equals(attrName)) {\n                                attr = attrs[k].read(this, v + 6, readInt(v + 2), c, codeStart - 8, labels);\n                                if (attr != null) {\n                                    attr.next = cattrs;\n                                    cattrs = attr;\n                                }\n                            }\n                        }\n                    }\n                    v += 6 + readInt(v + 2);\n                }\n                // 2nd phase: visits each instruction\n                if (FRAMES && stackMap != 0) {\n                    // creates the very first (implicit) frame from the method\n                    // descriptor\n                    frameLocal = new Object[maxLocals];\n                    frameStack = new Object[maxStack];\n                    if (unzip) {\n                        int local = 0;\n                        if ((access & Opcodes.ACC_STATIC) == 0) {\n                            if (\"<init>\".equals(name)) {\n                                frameLocal[local++] = Opcodes.UNINITIALIZED_THIS;\n                            } else {\n                                frameLocal[local++] = readClass(header + 2, c);\n                            }\n                        }\n                        j = 1;\n                        loop: while (true) {\n                            k = j;\n                            switch(desc.charAt(j++)) {\n                                case 'Z':\n                                case 'C':\n                                case 'B':\n                                case 'S':\n                                case 'I':\n                                    frameLocal[local++] = Opcodes.INTEGER;\n                                    break;\n                                case 'F':\n                                    frameLocal[local++] = Opcodes.FLOAT;\n                                    break;\n                                case 'J':\n                                    frameLocal[local++] = Opcodes.LONG;\n                                    break;\n                                case 'D':\n                                    frameLocal[local++] = Opcodes.DOUBLE;\n                                    break;\n                                case '[':\n                                    while (desc.charAt(j) == '[') {\n                                        ++j;\n                                    }\n                                    if (desc.charAt(j) == 'L') {\n                                        ++j;\n                                        while (desc.charAt(j) != ';') {\n                                            ++j;\n                                        }\n                                    }\n                                    frameLocal[local++] = desc.substring(k, ++j);\n                                    break;\n                                case 'L':\n                                    while (desc.charAt(j) != ';') {\n                                        ++j;\n                                    }\n                                    frameLocal[local++] = desc.substring(k + 1, j++);\n                                    break;\n                                default:\n                                    break loop;\n                            }\n                        }\n                        frameLocalCount = local;\n                    }\n                    /*\n                     * for the first explicit frame the offset is not\n                     * offset_delta + 1 but only offset_delta; setting the\n                     * implicit frame offset to -1 allow the use of the\n                     * \"offset_delta + 1\" rule in all cases\n                     */\n                    frameOffset = -1;\n                    /*\n                     * Finds labels for UNINITIALIZED frame types. Instead of\n                     * decoding each element of the stack map table, we look\n                     * for 3 consecutive bytes that \"look like\" an UNINITIALIZED\n                     * type (tag 8, offset within code bounds, NEW instruction\n                     * at this offset). We may find false positives (i.e. not \n                     * real UNINITIALIZED types), but this should be rare, and \n                     * the only consequence will be the creation of an unneeded \n                     * label. This is better than creating a label for each NEW\n                     * instruction, and faster than fully decoding the whole \n                     * stack map table.\n                     */\n                    for (j = stackMap; j < stackMap + stackMapSize - 2; ++j) {\n                        if (b[j] == 8) {\n                            // UNINITIALIZED FRAME TYPE\n                            k = readUnsignedShort(j + 1);\n                            if (k >= 0 && k < codeLength) {\n                                // potential offset\n                                if ((b[codeStart + k] & 0xFF) == Opcodes.NEW) {\n                                    // NEW at this offset\n                                    readLabel(k, labels);\n                                }\n                            }\n                        }\n                    }\n                }\n                v = codeStart;\n                Label l;\n                while (v < codeEnd) {\n                    w = v - codeStart;\n                    l = labels[w];\n                    if (l != null) {\n                        mv.visitLabel(l);\n                        if (!skipDebug && l.line > 0) {\n                            mv.visitLineNumber(l.line, l);\n                        }\n                    }\n                    while (FRAMES && frameLocal != null && (frameOffset == w || frameOffset == -1)) {\n                        // if there is a frame for this offset,\n                        // makes the visitor visit it,\n                        // and reads the next frame if there is one.\n                        if (!zip || unzip) {\n                            mv.visitFrame(Opcodes.F_NEW, frameLocalCount, frameLocal, frameStackCount, frameStack);\n                        } else if (frameOffset != -1) {\n                            mv.visitFrame(frameMode, frameLocalDiff, frameLocal, frameStackCount, frameStack);\n                        }\n                        if (frameCount > 0) {\n                            int tag, delta, n;\n                            if (zip) {\n                                tag = b[stackMap++] & 0xFF;\n                            } else {\n                                tag = MethodWriter.FULL_FRAME;\n                                frameOffset = -1;\n                            }\n                            frameLocalDiff = 0;\n                            if (tag < MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME) {\n                                delta = tag;\n                                frameMode = Opcodes.F_SAME;\n                                frameStackCount = 0;\n                            } else if (tag < MethodWriter.RESERVED) {\n                                delta = tag - MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME;\n                                stackMap = readFrameType(frameStack, 0, stackMap, c, labels);\n                                frameMode = Opcodes.F_SAME1;\n                                frameStackCount = 1;\n                            } else {\n                                delta = readUnsignedShort(stackMap);\n                                stackMap += 2;\n                                if (tag == MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {\n                                    stackMap = readFrameType(frameStack, 0, stackMap, c, labels);\n                                    frameMode = Opcodes.F_SAME1;\n                                    frameStackCount = 1;\n                                } else if (tag >= MethodWriter.CHOP_FRAME && tag < MethodWriter.SAME_FRAME_EXTENDED) {\n                                    frameMode = Opcodes.F_CHOP;\n                                    frameLocalDiff = MethodWriter.SAME_FRAME_EXTENDED - tag;\n                                    frameLocalCount -= frameLocalDiff;\n                                    frameStackCount = 0;\n                                } else if (tag == MethodWriter.SAME_FRAME_EXTENDED) {\n                                    frameMode = Opcodes.F_SAME;\n                                    frameStackCount = 0;\n                                } else if (tag < MethodWriter.FULL_FRAME) {\n                                    j = unzip ? frameLocalCount : 0;\n                                    for (k = tag - MethodWriter.SAME_FRAME_EXTENDED; k > 0; k--) {\n                                        stackMap = readFrameType(frameLocal, j++, stackMap, c, labels);\n                                    }\n                                    frameMode = Opcodes.F_APPEND;\n                                    frameLocalDiff = tag - MethodWriter.SAME_FRAME_EXTENDED;\n                                    frameLocalCount += frameLocalDiff;\n                                    frameStackCount = 0;\n                                } else {\n                                    // if (tag == FULL_FRAME) {\n                                    frameMode = Opcodes.F_FULL;\n                                    n = frameLocalDiff = frameLocalCount = readUnsignedShort(stackMap);\n                                    stackMap += 2;\n                                    for (j = 0; n > 0; n--) {\n                                        stackMap = readFrameType(frameLocal, j++, stackMap, c, labels);\n                                    }\n                                    n = frameStackCount = readUnsignedShort(stackMap);\n                                    stackMap += 2;\n                                    for (j = 0; n > 0; n--) {\n                                        stackMap = readFrameType(frameStack, j++, stackMap, c, labels);\n                                    }\n                                }\n                            }\n                            frameOffset += delta + 1;\n                            readLabel(frameOffset, labels);\n                            --frameCount;\n                        } else {\n                            frameLocal = null;\n                        }\n                    }\n                    int opcode = b[v] & 0xFF;\n                    switch(ClassWriter.TYPE[opcode]) {\n                        case ClassWriter.NOARG_INSN:\n                            mv.visitInsn(opcode);\n                            v += 1;\n                            break;\n                        case ClassWriter.IMPLVAR_INSN:\n                            if (opcode > Opcodes.ISTORE) {\n                                // ISTORE_0\n                                opcode -= 59;\n                                mv.visitVarInsn(Opcodes.ISTORE + (opcode >> 2), opcode & 0x3);\n                            } else {\n                                // ILOAD_0\n                                opcode -= 26;\n                                mv.visitVarInsn(Opcodes.ILOAD + (opcode >> 2), opcode & 0x3);\n                            }\n                            v += 1;\n                            break;\n                        case ClassWriter.LABEL_INSN:\n                            mv.visitJumpInsn(opcode, labels[w + readShort(v + 1)]);\n                            v += 3;\n                            break;\n                        case ClassWriter.LABELW_INSN:\n                            mv.visitJumpInsn(opcode - 33, labels[w + readInt(v + 1)]);\n                            v += 5;\n                            break;\n                        case ClassWriter.WIDE_INSN:\n                            opcode = b[v + 1] & 0xFF;\n                            if (opcode == Opcodes.IINC) {\n                                mv.visitIincInsn(readUnsignedShort(v + 2), readShort(v + 4));\n                                v += 6;\n                            } else {\n                                mv.visitVarInsn(opcode, readUnsignedShort(v + 2));\n                                v += 4;\n                            }\n                            break;\n                        case ClassWriter.TABL_INSN:\n                            // skips 0 to 3 padding bytes\n                            v = v + 4 - (w & 3);\n                            // reads instruction\n                            label = w + readInt(v);\n                            int min = readInt(v + 4);\n                            int max = readInt(v + 8);\n                            v += 12;\n                            Label[] table = new Label[max - min + 1];\n                            for (j = 0; j < table.length; ++j) {\n                                table[j] = labels[w + readInt(v)];\n                                v += 4;\n                            }\n                            mv.visitTableSwitchInsn(min, max, labels[label], table);\n                            break;\n                        case ClassWriter.LOOK_INSN:\n                            // skips 0 to 3 padding bytes\n                            v = v + 4 - (w & 3);\n                            // reads instruction\n                            label = w + readInt(v);\n                            j = readInt(v + 4);\n                            v += 8;\n                            int[] keys = new int[j];\n                            Label[] values = new Label[j];\n                            for (j = 0; j < keys.length; ++j) {\n                                keys[j] = readInt(v);\n                                values[j] = labels[w + readInt(v + 4)];\n                                v += 8;\n                            }\n                            mv.visitLookupSwitchInsn(labels[label], keys, values);\n                            break;\n                        case ClassWriter.VAR_INSN:\n                            mv.visitVarInsn(opcode, b[v + 1] & 0xFF);\n                            v += 2;\n                            break;\n                        case ClassWriter.SBYTE_INSN:\n                            mv.visitIntInsn(opcode, b[v + 1]);\n                            v += 2;\n                            break;\n                        case ClassWriter.SHORT_INSN:\n                            mv.visitIntInsn(opcode, readShort(v + 1));\n                            v += 3;\n                            break;\n                        case ClassWriter.LDC_INSN:\n                            mv.visitLdcInsn(readConst(b[v + 1] & 0xFF, c));\n                            v += 2;\n                            break;\n                        case ClassWriter.LDCW_INSN:\n                            mv.visitLdcInsn(readConst(readUnsignedShort(v + 1), c));\n                            v += 3;\n                            break;\n                        case ClassWriter.FIELDORMETH_INSN:\n                        case ClassWriter.ITFDYNMETH_INSN:\n                            int cpIndex = items[readUnsignedShort(v + 1)];\n                            String iowner;\n                            // INVOKEDYNAMIC is receiverless\n                            if (opcode == Opcodes.INVOKEDYNAMIC) {\n                                iowner = Opcodes.INVOKEDYNAMIC_OWNER;\n                            } else {\n                                iowner = readClass(cpIndex, c);\n                                cpIndex = items[readUnsignedShort(cpIndex + 2)];\n                            }\n                            String iname = readUTF8(cpIndex, c);\n                            String idesc = readUTF8(cpIndex + 2, c);\n                            if (opcode < Opcodes.INVOKEVIRTUAL) {\n                                mv.visitFieldInsn(opcode, iowner, iname, idesc);\n                            } else {\n                                mv.visitMethodInsn(opcode, iowner, iname, idesc);\n                            }\n                            if (opcode == Opcodes.INVOKEINTERFACE || opcode == Opcodes.INVOKEDYNAMIC) {\n                                v += 5;\n                            } else {\n                                v += 3;\n                            }\n                            break;\n                        case ClassWriter.TYPE_INSN:\n                            mv.visitTypeInsn(opcode, readClass(v + 1, c));\n                            v += 3;\n                            break;\n                        case ClassWriter.IINC_INSN:\n                            mv.visitIincInsn(b[v + 1] & 0xFF, b[v + 2]);\n                            v += 3;\n                            break;\n                        // case MANA_INSN:\n                        default:\n                            mv.visitMultiANewArrayInsn(readClass(v + 1, c), b[v + 3] & 0xFF);\n                            v += 4;\n                            break;\n                    }\n                }\n                l = labels[codeEnd - codeStart];\n                if (l != null) {\n                    mv.visitLabel(l);\n                }\n                // visits the local variable tables\n                if (!skipDebug && varTable != 0) {\n                    int[] typeTable = null;\n                    if (varTypeTable != 0) {\n                        k = readUnsignedShort(varTypeTable) * 3;\n                        w = varTypeTable + 2;\n                        typeTable = new int[k];\n                        while (k > 0) {\n                            // signature\n                            typeTable[--k] = w + 6;\n                            // index\n                            typeTable[--k] = readUnsignedShort(w + 8);\n                            // start\n                            typeTable[--k] = readUnsignedShort(w);\n                            w += 10;\n                        }\n                    }\n                    k = readUnsignedShort(varTable);\n                    w = varTable + 2;\n                    for (; k > 0; --k) {\n                        int start = readUnsignedShort(w);\n                        int length = readUnsignedShort(w + 2);\n                        int index = readUnsignedShort(w + 8);\n                        String vsignature = null;\n                        if (typeTable != null) {\n                            for (int a = 0; a < typeTable.length; a += 3) {\n                                if (typeTable[a] == start && typeTable[a + 1] == index) {\n                                    vsignature = readUTF8(typeTable[a + 2], c);\n                                    break;\n                                }\n                            }\n                        }\n                        mv.visitLocalVariable(readUTF8(w + 4, c), readUTF8(w + 6, c), vsignature, labels[start], labels[start + length], index);\n                        w += 10;\n                    }\n                }\n                // visits the other attributes\n                while (cattrs != null) {\n                    attr = cattrs.next;\n                    cattrs.next = null;\n                    mv.visitAttribute(cattrs);\n                    cattrs = attr;\n                }\n                // visits the max stack and max locals values\n                mv.visitMaxs(maxStack, maxLocals);\n            }\n            if (mv != null) {\n                mv.visitEnd();\n            }\n        }\n        // visits the end of the class\n        classVisitor.visitEnd();\n    }\n\n    /**\n     * Reads parameter annotations and makes the given visitor visit them.\n     *\n     * @param v start offset in {@link #b b} of the annotations to be read.\n     * @param desc the method descriptor.\n     * @param buf buffer to be used to call {@link #readUTF8 readUTF8},\n     *        {@link #readClass(int,char[]) readClass} or\n     *        {@link #readConst readConst}.\n     * @param visible <tt>true</tt> if the annotations to be read are visible\n     *        at runtime.\n     * @param mv the visitor that must visit the annotations.\n     */\n    private void readParameterAnnotations(int v, final String desc, final char[] buf, final boolean visible, final MethodVisitor mv) {\n        int i;\n        int n = b[v++] & 0xFF;\n        // workaround for a bug in javac (javac compiler generates a parameter\n        // annotation array whose size is equal to the number of parameters in\n        // the Java source file, while it should generate an array whose size is\n        // equal to the number of parameters in the method descriptor - which\n        // includes the synthetic parameters added by the compiler). This work-\n        // around supposes that the synthetic parameters are the first ones.\n        int synthetics = Type.getArgumentTypes(desc).length - n;\n        AnnotationVisitor av;\n        for (i = 0; i < synthetics; ++i) {\n            // virtual annotation to detect synthetic parameters in MethodWriter\n            av = mv.visitParameterAnnotation(i, \"Ljava/lang/Synthetic;\", false);\n            if (av != null) {\n                av.visitEnd();\n            }\n        }\n        for (; i < n + synthetics; ++i) {\n            int j = readUnsignedShort(v);\n            v += 2;\n            for (; j > 0; --j) {\n                av = mv.visitParameterAnnotation(i, readUTF8(v, buf), visible);\n                v = readAnnotationValues(v + 2, buf, true, av);\n            }\n        }\n    }\n\n    /**\n     * Reads the values of an annotation and makes the given visitor visit them.\n     *\n     * @param v the start offset in {@link #b b} of the values to be read\n     *        (including the unsigned short that gives the number of values).\n     * @param buf buffer to be used to call {@link #readUTF8 readUTF8},\n     *        {@link #readClass(int,char[]) readClass} or\n     *        {@link #readConst readConst}.\n     * @param named if the annotation values are named or not.\n     * @param av the visitor that must visit the values.\n     * @return the end offset of the annotation values.\n     */\n    private int readAnnotationValues(int v, final char[] buf, final boolean named, final AnnotationVisitor av) {\n        int i = readUnsignedShort(v);\n        v += 2;\n        if (named) {\n            for (; i > 0; --i) {\n                v = readAnnotationValue(v + 2, buf, readUTF8(v, buf), av);\n            }\n        } else {\n            for (; i > 0; --i) {\n                v = readAnnotationValue(v, buf, null, av);\n            }\n        }\n        if (av != null) {\n            av.visitEnd();\n        }\n        return v;\n    }\n\n    /**\n     * Reads a value of an annotation and makes the given visitor visit it.\n     *\n     * @param v the start offset in {@link #b b} of the value to be read (<i>not\n     *        including the value name constant pool index</i>).\n     * @param buf buffer to be used to call {@link #readUTF8 readUTF8},\n     *        {@link #readClass(int,char[]) readClass} or\n     *        {@link #readConst readConst}.\n     * @param name the name of the value to be read.\n     * @param av the visitor that must visit the value.\n     * @return the end offset of the annotation value.\n     */\n    private int readAnnotationValue(int v, final char[] buf, final String name, final AnnotationVisitor av) {\n        int i;\n        if (av == null) {\n            switch(b[v] & 0xFF) {\n                case // enum_const_value\n                'e':\n                    return v + 5;\n                case // annotation_value\n                '@':\n                    return readAnnotationValues(v + 3, buf, true, null);\n                case // array_value\n                '[':\n                    return readAnnotationValues(v + 1, buf, false, null);\n                default:\n                    return v + 3;\n            }\n        }\n        switch(b[v++] & 0xFF) {\n            // pointer to CONSTANT_Integer\n            case 'I':\n            // pointer to CONSTANT_Long\n            case 'J':\n            // pointer to CONSTANT_Float\n            case 'F':\n            case // pointer to CONSTANT_Double\n            'D':\n                av.visit(name, readConst(readUnsignedShort(v), buf));\n                v += 2;\n                break;\n            case // pointer to CONSTANT_Byte\n            'B':\n                av.visit(name, new Byte((byte) readInt(items[readUnsignedShort(v)])));\n                v += 2;\n                break;\n            case // pointer to CONSTANT_Boolean\n            'Z':\n                av.visit(name, readInt(items[readUnsignedShort(v)]) == 0 ? Boolean.FALSE : Boolean.TRUE);\n                v += 2;\n                break;\n            case // pointer to CONSTANT_Short\n            'S':\n                av.visit(name, new Short((short) readInt(items[readUnsignedShort(v)])));\n                v += 2;\n                break;\n            case // pointer to CONSTANT_Char\n            'C':\n                av.visit(name, new Character((char) readInt(items[readUnsignedShort(v)])));\n                v += 2;\n                break;\n            case // pointer to CONSTANT_Utf8\n            's':\n                av.visit(name, readUTF8(v, buf));\n                v += 2;\n                break;\n            case // enum_const_value\n            'e':\n                av.visitEnum(name, readUTF8(v, buf), readUTF8(v + 2, buf));\n                v += 4;\n                break;\n            case // class_info\n            'c':\n                av.visit(name, Type.getType(readUTF8(v, buf)));\n                v += 2;\n                break;\n            case // annotation_value\n            '@':\n                v = readAnnotationValues(v + 2, buf, true, av.visitAnnotation(name, readUTF8(v, buf)));\n                break;\n            case // array_value\n            '[':\n                int size = readUnsignedShort(v);\n                v += 2;\n                if (size == 0) {\n                    return readAnnotationValues(v - 2, buf, false, av.visitArray(name));\n                }\n                switch(this.b[v++] & 0xFF) {\n                    case 'B':\n                        byte[] bv = new byte[size];\n                        for (i = 0; i < size; i++) {\n                            bv[i] = (byte) readInt(items[readUnsignedShort(v)]);\n                            v += 3;\n                        }\n                        av.visit(name, bv);\n                        --v;\n                        break;\n                    case 'Z':\n                        boolean[] zv = new boolean[size];\n                        for (i = 0; i < size; i++) {\n                            zv[i] = readInt(items[readUnsignedShort(v)]) != 0;\n                            v += 3;\n                        }\n                        av.visit(name, zv);\n                        --v;\n                        break;\n                    case 'S':\n                        short[] sv = new short[size];\n                        for (i = 0; i < size; i++) {\n                            sv[i] = (short) readInt(items[readUnsignedShort(v)]);\n                            v += 3;\n                        }\n                        av.visit(name, sv);\n                        --v;\n                        break;\n                    case 'C':\n                        char[] cv = new char[size];\n                        for (i = 0; i < size; i++) {\n                            cv[i] = (char) readInt(items[readUnsignedShort(v)]);\n                            v += 3;\n                        }\n                        av.visit(name, cv);\n                        --v;\n                        break;\n                    case 'I':\n                        int[] iv = new int[size];\n                        for (i = 0; i < size; i++) {\n                            iv[i] = readInt(items[readUnsignedShort(v)]);\n                            v += 3;\n                        }\n                        av.visit(name, iv);\n                        --v;\n                        break;\n                    case 'J':\n                        long[] lv = new long[size];\n                        for (i = 0; i < size; i++) {\n                            lv[i] = readLong(items[readUnsignedShort(v)]);\n                            v += 3;\n                        }\n                        av.visit(name, lv);\n                        --v;\n                        break;\n                    case 'F':\n                        float[] fv = new float[size];\n                        for (i = 0; i < size; i++) {\n                            fv[i] = Float.intBitsToFloat(readInt(items[readUnsignedShort(v)]));\n                            v += 3;\n                        }\n                        av.visit(name, fv);\n                        --v;\n                        break;\n                    case 'D':\n                        double[] dv = new double[size];\n                        for (i = 0; i < size; i++) {\n                            dv[i] = Double.longBitsToDouble(readLong(items[readUnsignedShort(v)]));\n                            v += 3;\n                        }\n                        av.visit(name, dv);\n                        --v;\n                        break;\n                    default:\n                        v = readAnnotationValues(v - 3, buf, false, av.visitArray(name));\n                }\n        }\n        return v;\n    }\n\n    private int readFrameType(final Object[] frame, final int index, int v, final char[] buf, final Label[] labels) {\n        int type = b[v++] & 0xFF;\n        switch(type) {\n            case 0:\n                frame[index] = Opcodes.TOP;\n                break;\n            case 1:\n                frame[index] = Opcodes.INTEGER;\n                break;\n            case 2:\n                frame[index] = Opcodes.FLOAT;\n                break;\n            case 3:\n                frame[index] = Opcodes.DOUBLE;\n                break;\n            case 4:\n                frame[index] = Opcodes.LONG;\n                break;\n            case 5:\n                frame[index] = Opcodes.NULL;\n                break;\n            case 6:\n                frame[index] = Opcodes.UNINITIALIZED_THIS;\n                break;\n            case // Object\n            7:\n                frame[index] = readClass(v, buf);\n                v += 2;\n                break;\n            default:\n                // Uninitialized\n                frame[index] = readLabel(readUnsignedShort(v), labels);\n                v += 2;\n        }\n        return v;\n    }\n\n    /**\n     * Returns the label corresponding to the given offset. The default\n     * implementation of this method creates a label for the given offset if it\n     * has not been already created.\n     *\n     * @param offset a bytecode offset in a method.\n     * @param labels the already created labels, indexed by their offset. If a\n     *        label already exists for offset this method must not create a new\n     *        one. Otherwise it must store the new label in this array.\n     * @return a non null Label, which must be equal to labels[offset].\n     */\n    protected Label readLabel(int offset, Label[] labels) {\n        if (labels[offset] == null) {\n            labels[offset] = new Label();\n        }\n        return labels[offset];\n    }\n\n    /**\n     * Reads an attribute in {@link #b b}.\n     *\n     * @param attrs prototypes of the attributes that must be parsed during the\n     *        visit of the class. Any attribute whose type is not equal to the\n     *        type of one the prototypes is ignored (i.e. an empty\n     *        {@link Attribute} instance is returned).\n     * @param type the type of the attribute.\n     * @param off index of the first byte of the attribute's content in\n     *        {@link #b b}. The 6 attribute header bytes, containing the type\n     *        and the length of the attribute, are not taken into account here\n     *        (they have already been read).\n     * @param len the length of the attribute's content.\n     * @param buf buffer to be used to call {@link #readUTF8 readUTF8},\n     *        {@link #readClass(int,char[]) readClass} or\n     *        {@link #readConst readConst}.\n     * @param codeOff index of the first byte of code's attribute content in\n     *        {@link #b b}, or -1 if the attribute to be read is not a code\n     *        attribute. The 6 attribute header bytes, containing the type and\n     *        the length of the attribute, are not taken into account here.\n     * @param labels the labels of the method's code, or <tt>null</tt> if the\n     *        attribute to be read is not a code attribute.\n     * @return the attribute that has been read, or <tt>null</tt> to skip this\n     *         attribute.\n     */\n    private Attribute readAttribute(final Attribute[] attrs, final String type, final int off, final int len, final char[] buf, final int codeOff, final Label[] labels) {\n        for (int i = 0; i < attrs.length; ++i) {\n            if (attrs[i].type.equals(type)) {\n                return attrs[i].read(this, off, len, buf, codeOff, labels);\n            }\n        }\n        return new Attribute(type).read(this, off, len, null, -1, null);\n    }\n\n    // ------------------------------------------------------------------------\n    // Utility methods: low level parsing\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the start index of the constant pool item in {@link #b b}, plus\n     * one. <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param item the index a constant pool item.\n     * @return the start index of the constant pool item in {@link #b b}, plus\n     *         one.\n     */\n    public int getItem(final int item) {\n        return items[item];\n    }\n\n    /**\n     * Reads a byte value in {@link #b b}. <i>This method is intended for\n     * {@link Attribute} sub classes, and is normally not needed by class\n     * generators or adapters.</i>\n     *\n     * @param index the start index of the value to be read in {@link #b b}.\n     * @return the read value.\n     */\n    public int readByte(final int index) {\n        return b[index] & 0xFF;\n    }\n\n    /**\n     * Reads an unsigned short value in {@link #b b}. <i>This method is\n     * intended for {@link Attribute} sub classes, and is normally not needed by\n     * class generators or adapters.</i>\n     *\n     * @param index the start index of the value to be read in {@link #b b}.\n     * @return the read value.\n     */\n    public int readUnsignedShort(final int index) {\n        byte[] b = this.b;\n        return ((b[index] & 0xFF) << 8) | (b[index + 1] & 0xFF);\n    }\n\n    /**\n     * Reads a signed short value in {@link #b b}. <i>This method is intended\n     * for {@link Attribute} sub classes, and is normally not needed by class\n     * generators or adapters.</i>\n     *\n     * @param index the start index of the value to be read in {@link #b b}.\n     * @return the read value.\n     */\n    public short readShort(final int index) {\n        byte[] b = this.b;\n        return (short) (((b[index] & 0xFF) << 8) | (b[index + 1] & 0xFF));\n    }\n\n    /**\n     * Reads a signed int value in {@link #b b}. <i>This method is intended for\n     * {@link Attribute} sub classes, and is normally not needed by class\n     * generators or adapters.</i>\n     *\n     * @param index the start index of the value to be read in {@link #b b}.\n     * @return the read value.\n     */\n    public int readInt(final int index) {\n        byte[] b = this.b;\n        return ((b[index] & 0xFF) << 24) | ((b[index + 1] & 0xFF) << 16) | ((b[index + 2] & 0xFF) << 8) | (b[index + 3] & 0xFF);\n    }\n\n    /**\n     * Reads a signed long value in {@link #b b}. <i>This method is intended\n     * for {@link Attribute} sub classes, and is normally not needed by class\n     * generators or adapters.</i>\n     *\n     * @param index the start index of the value to be read in {@link #b b}.\n     * @return the read value.\n     */\n    public long readLong(final int index) {\n        long l1 = readInt(index);\n        long l0 = readInt(index + 4) & 0xFFFFFFFFL;\n        return (l1 << 32) | l0;\n    }\n\n    /**\n     * Reads an UTF8 string constant pool item in {@link #b b}. <i>This method\n     * is intended for {@link Attribute} sub classes, and is normally not needed\n     * by class generators or adapters.</i>\n     *\n     * @param index the start index of an unsigned short value in {@link #b b},\n     *        whose value is the index of an UTF8 constant pool item.\n     * @param buf buffer to be used to read the item. This buffer must be\n     *        sufficiently large. It is not automatically resized.\n     * @return the String corresponding to the specified UTF8 item.\n     */\n    public String readUTF8(int index, final char[] buf) {\n        int item = readUnsignedShort(index);\n        String s = strings[item];\n        if (s != null) {\n            return s;\n        }\n        index = items[item];\n        return strings[item] = readUTF(index + 2, readUnsignedShort(index), buf);\n    }\n\n    /**\n     * Reads UTF8 string in {@link #b b}.\n     *\n     * @param index start offset of the UTF8 string to be read.\n     * @param utfLen length of the UTF8 string to be read.\n     * @param buf buffer to be used to read the string. This buffer must be\n     *        sufficiently large. It is not automatically resized.\n     * @return the String corresponding to the specified UTF8 string.\n     */\n    private String readUTF(int index, final int utfLen, final char[] buf) {\n        int endIndex = index + utfLen;\n        byte[] b = this.b;\n        int strLen = 0;\n        int c;\n        int st = 0;\n        char cc = 0;\n        while (index < endIndex) {\n            c = b[index++];\n            switch(st) {\n                case 0:\n                    c = c & 0xFF;\n                    if (c < 0x80) {\n                        // 0xxxxxxx\n                        buf[strLen++] = (char) c;\n                    } else if (c < 0xE0 && c > 0xBF) {\n                        // 110x xxxx 10xx xxxx\n                        cc = (char) (c & 0x1F);\n                        st = 1;\n                    } else {\n                        // 1110 xxxx 10xx xxxx 10xx xxxx\n                        cc = (char) (c & 0x0F);\n                        st = 2;\n                    }\n                    break;\n                case // byte 2 of 2-byte char or byte 3 of 3-byte char\n                1:\n                    buf[strLen++] = (char) ((cc << 6) | (c & 0x3F));\n                    st = 0;\n                    break;\n                case // byte 2 of 3-byte char\n                2:\n                    cc = (char) ((cc << 6) | (c & 0x3F));\n                    st = 1;\n                    break;\n            }\n        }\n        return new String(buf, 0, strLen);\n    }\n\n    /**\n     * Reads a class constant pool item in {@link #b b}. <i>This method is\n     * intended for {@link Attribute} sub classes, and is normally not needed by\n     * class generators or adapters.</i>\n     *\n     * @param index the start index of an unsigned short value in {@link #b b},\n     *        whose value is the index of a class constant pool item.\n     * @param buf buffer to be used to read the item. This buffer must be\n     *        sufficiently large. It is not automatically resized.\n     * @return the String corresponding to the specified class item.\n     */\n    public String readClass(final int index, final char[] buf) {\n        // computes the start index of the CONSTANT_Class item in b\n        // and reads the CONSTANT_Utf8 item designated by\n        // the first two bytes of this CONSTANT_Class item\n        return readUTF8(items[readUnsignedShort(index)], buf);\n    }\n\n    /**\n     * Reads a numeric or string constant pool item in {@link #b b}. <i>This\n     * method is intended for {@link Attribute} sub classes, and is normally not\n     * needed by class generators or adapters.</i>\n     *\n     * @param item the index of a constant pool item.\n     * @param buf buffer to be used to read the item. This buffer must be\n     *        sufficiently large. It is not automatically resized.\n     * @return the {@link Integer}, {@link Float}, {@link Long},\n     *         {@link Double}, {@link String} or {@link Type} corresponding to\n     *         the given constant pool item.\n     */\n    public Object readConst(final int item, final char[] buf) {\n        int index = items[item];\n        switch(b[index - 1]) {\n            case ClassWriter.INT:\n                return new Integer(readInt(index));\n            case ClassWriter.FLOAT:\n                return new Float(Float.intBitsToFloat(readInt(index)));\n            case ClassWriter.LONG:\n                return new Long(readLong(index));\n            case ClassWriter.DOUBLE:\n                return new Double(Double.longBitsToDouble(readLong(index)));\n            case ClassWriter.CLASS:\n                return Type.getObjectType(readUTF8(index, buf));\n            // case ClassWriter.STR:\n            default:\n                return readUTF8(index, buf);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/ClassReaderTest6.java",
		"test_prompt": "// ClassReaderTest6.java\npackage org.objectweb.asm.jip;\n\nimport java.io.InputStream;\nimport java.io.IOException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassReader}.\n* It contains ten unit test cases for the {@link ClassReader#readClass(int, char[])} method.\n*/\nclass ClassReaderTest6 {"
	},
	{
		"original_code": "// ClassReader.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\nimport java.io.InputStream;\nimport java.io.IOException;\n\n/**\n * A Java class parser to make a {@link ClassVisitor} visit an existing class.\n * This class parses a byte array conforming to the Java class file format and\n * calls the appropriate visit methods of a given class visitor for each field,\n * method and bytecode instruction encountered.\n *\n * @author Eric Bruneton\n * @author Eugene Kuleshov\n */\npublic class ClassReader {\n\n    /**\n     * True to enable signatures support.\n     */\n    static final boolean SIGNATURES = true;\n\n    /**\n     * True to enable annotations support.\n     */\n    static final boolean ANNOTATIONS = true;\n\n    /**\n     * True to enable stack map frames support.\n     */\n    static final boolean FRAMES = true;\n\n    /**\n     * True to enable bytecode writing support.\n     */\n    static final boolean WRITER = true;\n\n    /**\n     * True to enable JSR_W and GOTO_W support.\n     */\n    static final boolean RESIZE = true;\n\n    /**\n     * Flag to skip method code. If this class is set <code>CODE</code>\n     * attribute won't be visited. This can be used, for example, to retrieve\n     * annotations for methods and method parameters.\n     */\n    public static final int SKIP_CODE = 1;\n\n    /**\n     * Flag to skip the debug information in the class. If this flag is set the\n     * debug information of the class is not visited, i.e. the\n     * {@link MethodVisitor#visitLocalVariable visitLocalVariable} and\n     * {@link MethodVisitor#visitLineNumber visitLineNumber} methods will not be\n     * called.\n     */\n    public static final int SKIP_DEBUG = 2;\n\n    /**\n     * Flag to skip the stack map frames in the class. If this flag is set the\n     * stack map frames of the class is not visited, i.e. the\n     * {@link MethodVisitor#visitFrame visitFrame} method will not be called.\n     * This flag is useful when the {@link ClassWriter#COMPUTE_FRAMES} option is\n     * used: it avoids visiting frames that will be ignored and recomputed from\n     * scratch in the class writer.\n     */\n    public static final int SKIP_FRAMES = 4;\n\n    /**\n     * Flag to expand the stack map frames. By default stack map frames are\n     * visited in their original format (i.e. \"expanded\" for classes whose\n     * version is less than V1_6, and \"compressed\" for the other classes). If\n     * this flag is set, stack map frames are always visited in expanded format\n     * (this option adds a decompression/recompression step in ClassReader and\n     * ClassWriter which degrades performances quite a lot).\n     */\n    public static final int EXPAND_FRAMES = 8;\n\n    /**\n     * The class to be parsed. <i>The content of this array must not be\n     * modified. This field is intended for {@link Attribute} sub classes, and\n     * is normally not needed by class generators or adapters.</i>\n     */\n    public final byte[] b;\n\n    /**\n     * The start index of each constant pool item in {@link #b b}, plus one.\n     * The one byte offset skips the constant pool item tag that indicates its\n     * type.\n     */\n    private final int[] items;\n\n    /**\n     * The String objects corresponding to the CONSTANT_Utf8 items. This cache\n     * avoids multiple parsing of a given CONSTANT_Utf8 constant pool item,\n     * which GREATLY improves performances (by a factor 2 to 3). This caching\n     * strategy could be extended to all constant pool items, but its benefit\n     * would not be so great for these items (because they are much less\n     * expensive to parse than CONSTANT_Utf8 items).\n     */\n    private final String[] strings;\n\n    /**\n     * Maximum length of the strings contained in the constant pool of the\n     * class.\n     */\n    private final int maxStringLength;\n\n    /**\n     * Start index of the class header information (access, name...) in\n     * {@link #b b}.\n     */\n    public final int header;\n\n    // ------------------------------------------------------------------------\n    // Constructors\n    // ------------------------------------------------------------------------\n    /**\n     * Constructs a new {@link ClassReader} object.\n     *\n     * @param b the bytecode of the class to be read.\n     */\n    public ClassReader(final byte[] b) {\n        this(b, 0, b.length);\n    }\n\n    /**\n     * Constructs a new {@link ClassReader} object.\n     *\n     * @param b the bytecode of the class to be read.\n     * @param off the start offset of the class data.\n     * @param len the length of the class data.\n     */\n    public ClassReader(final byte[] b, final int off, final int len) {\n        this.b = b;\n        // parses the constant pool\n        items = new int[readUnsignedShort(off + 8)];\n        int n = items.length;\n        strings = new String[n];\n        int max = 0;\n        int index = off + 10;\n        for (int i = 1; i < n; ++i) {\n            items[i] = index + 1;\n            int size;\n            switch(b[index]) {\n                case ClassWriter.FIELD:\n                case ClassWriter.METH:\n                case ClassWriter.IMETH:\n                case ClassWriter.INT:\n                case ClassWriter.FLOAT:\n                case ClassWriter.NAME_TYPE:\n                    size = 5;\n                    break;\n                case ClassWriter.LONG:\n                case ClassWriter.DOUBLE:\n                    size = 9;\n                    ++i;\n                    break;\n                case ClassWriter.UTF8:\n                    size = 3 + readUnsignedShort(index + 1);\n                    if (size > max) {\n                        max = size;\n                    }\n                    break;\n                // case ClassWriter.CLASS:\n                // case ClassWriter.STR:\n                default:\n                    size = 3;\n                    break;\n            }\n            index += size;\n        }\n        maxStringLength = max;\n        // the class header information starts just after the constant pool\n        header = index;\n    }\n\n    /**\n     * Returns the class's access flags (see {@link Opcodes}). This value may\n     * not reflect Deprecated and Synthetic flags when bytecode is before 1.5\n     * and those flags are represented by attributes.\n     *\n     * @return the class access flags\n     *\n     * @see ClassVisitor#visit(int, int, String, String, String, String[])\n     */\n    public int getAccess() {\n        return readUnsignedShort(header);\n    }\n\n    /**\n     * Returns the internal name of the class (see\n     * {@link Type#getInternalName() getInternalName}).\n     *\n     * @return the internal class name\n     *\n     * @see ClassVisitor#visit(int, int, String, String, String, String[])\n     */\n    public String getClassName() {\n        return readClass(header + 2, new char[maxStringLength]);\n    }\n\n    /**\n     * Returns the internal of name of the super class (see\n     * {@link Type#getInternalName() getInternalName}). For interfaces, the\n     * super class is {@link Object}.\n     *\n     * @return the internal name of super class, or <tt>null</tt> for\n     *         {@link Object} class.\n     *\n     * @see ClassVisitor#visit(int, int, String, String, String, String[])\n     */\n    public String getSuperName() {\n        int n = items[readUnsignedShort(header + 4)];\n        return n == 0 ? null : readUTF8(n, new char[maxStringLength]);\n    }\n\n    /**\n     * Returns the internal names of the class's interfaces (see\n     * {@link Type#getInternalName() getInternalName}).\n     *\n     * @return the array of internal names for all implemented interfaces or\n     *         <tt>null</tt>.\n     *\n     * @see ClassVisitor#visit(int, int, String, String, String, String[])\n     */\n    public String[] getInterfaces() {\n        int index = header + 6;\n        int n = readUnsignedShort(index);\n        String[] interfaces = new String[n];\n        if (n > 0) {\n            char[] buf = new char[maxStringLength];\n            for (int i = 0; i < n; ++i) {\n                index += 2;\n                interfaces[i] = readClass(index, buf);\n            }\n        }\n        return interfaces;\n    }\n\n    /**\n     * Copies the constant pool data into the given {@link ClassWriter}. Should\n     * be called before the {@link #accept(ClassVisitor,int)} method.\n     *\n     * @param classWriter the {@link ClassWriter} to copy constant pool into.\n     */\n    void copyPool(final ClassWriter classWriter) {\n        char[] buf = new char[maxStringLength];\n        int ll = items.length;\n        Item[] items2 = new Item[ll];\n        for (int i = 1; i < ll; i++) {\n            int index = items[i];\n            int tag = b[index - 1];\n            Item item = new Item(i);\n            int nameType;\n            switch(tag) {\n                case ClassWriter.FIELD:\n                case ClassWriter.METH:\n                case ClassWriter.IMETH:\n                    nameType = items[readUnsignedShort(index + 2)];\n                    item.set(tag, readClass(index, buf), readUTF8(nameType, buf), readUTF8(nameType + 2, buf));\n                    break;\n                case ClassWriter.INT:\n                    item.set(readInt(index));\n                    break;\n                case ClassWriter.FLOAT:\n                    item.set(Float.intBitsToFloat(readInt(index)));\n                    break;\n                case ClassWriter.NAME_TYPE:\n                    item.set(tag, readUTF8(index, buf), readUTF8(index + 2, buf), null);\n                    break;\n                case ClassWriter.LONG:\n                    item.set(readLong(index));\n                    ++i;\n                    break;\n                case ClassWriter.DOUBLE:\n                    item.set(Double.longBitsToDouble(readLong(index)));\n                    ++i;\n                    break;\n                case ClassWriter.UTF8:\n                    {\n                        String s = strings[i];\n                        if (s == null) {\n                            index = items[i];\n                            s = strings[i] = readUTF(index + 2, readUnsignedShort(index), buf);\n                        }\n                        item.set(tag, s, null, null);\n                    }\n                    break;\n                // case ClassWriter.STR:\n                // case ClassWriter.CLASS:\n                default:\n                    item.set(tag, readUTF8(index, buf), null, null);\n                    break;\n            }\n            int index2 = item.hashCode % items2.length;\n            item.next = items2[index2];\n            items2[index2] = item;\n        }\n        int off = items[1] - 1;\n        classWriter.pool.putByteArray(b, off, header - off);\n        classWriter.items = items2;\n        classWriter.threshold = (int) (0.75d * ll);\n        classWriter.index = ll;\n    }\n\n    /**\n     * Constructs a new {@link ClassReader} object.\n     *\n     * @param is an input stream from which to read the class.\n     * @throws IOException if a problem occurs during reading.\n     */\n    public ClassReader(final InputStream is) throws IOException {\n        this(readClass(is));\n    }\n\n    /**\n     * Constructs a new {@link ClassReader} object.\n     *\n     * @param name the fully qualified name of the class to be read.\n     * @throws IOException if an exception occurs during reading.\n     */\n    public ClassReader(final String name) throws IOException {\n        this(ClassLoader.getSystemResourceAsStream(name.replace('.', '/') + \".class\"));\n    }\n\n    /**\n     * Reads the bytecode of a class.\n     *\n     * @param is an input stream from which to read the class.\n     * @return the bytecode read from the given input stream.\n     * @throws IOException if a problem occurs during reading.\n     */\n    private static byte[] readClass(final InputStream is) throws IOException {\n        if (is == null) {\n            throw new IOException(\"Class not found\");\n        }\n        byte[] b = new byte[is.available()];\n        int len = 0;\n        while (true) {\n            int n = is.read(b, len, b.length - len);\n            if (n == -1) {\n                if (len < b.length) {\n                    byte[] c = new byte[len];\n                    System.arraycopy(b, 0, c, 0, len);\n                    b = c;\n                }\n                return b;\n            }\n            len += n;\n            if (len == b.length) {\n                int last = is.read();\n                if (last < 0) {\n                    return b;\n                }\n                byte[] c = new byte[b.length + 1000];\n                System.arraycopy(b, 0, c, 0, len);\n                c[len++] = (byte) last;\n                b = c;\n            }\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Public methods\n    // ------------------------------------------------------------------------\n    /**\n     * Makes the given visitor visit the Java class of this {@link ClassReader}.\n     * This class is the one specified in the constructor (see\n     * {@link #ClassReader(byte[]) ClassReader}).\n     *\n     * @param classVisitor the visitor that must visit this class.\n     * @param flags option flags that can be used to modify the default behavior\n     *        of this class. See {@link #SKIP_DEBUG}, {@link #EXPAND_FRAMES},\n     *        {@link #SKIP_FRAMES}, {@link #SKIP_CODE}.\n     */\n    public void accept(final ClassVisitor classVisitor, final int flags) {\n        accept(classVisitor, new Attribute[0], flags);\n    }\n\n    /**\n     * Makes the given visitor visit the Java class of this {@link ClassReader}.\n     * This class is the one specified in the constructor (see\n     * {@link #ClassReader(byte[]) ClassReader}).\n     *\n     * @param classVisitor the visitor that must visit this class.\n     * @param attrs prototypes of the attributes that must be parsed during the\n     *        visit of the class. Any attribute whose type is not equal to the\n     *        type of one the prototypes will not be parsed: its byte array\n     *        value will be passed unchanged to the ClassWriter. <i>This may\n     *        corrupt it if this value contains references to the constant pool,\n     *        or has syntactic or semantic links with a class element that has\n     *        been transformed by a class adapter between the reader and the\n     *        writer</i>.\n     * @param flags option flags that can be used to modify the default behavior\n     *        of this class. See {@link #SKIP_DEBUG}, {@link #EXPAND_FRAMES},\n     *        {@link #SKIP_FRAMES}, {@link #SKIP_CODE}.\n     */\n    public void accept(final ClassVisitor classVisitor, final Attribute[] attrs, final int flags) {\n        // the bytecode array\n        byte[] b = this.b;\n        // buffer used to read strings\n        char[] c = new char[maxStringLength];\n        // loop variables\n        int i, j, k;\n        // indexes in b\n        int u, v, w;\n        Attribute attr;\n        int access;\n        String name;\n        String desc;\n        String attrName;\n        String signature;\n        int anns = 0;\n        int ianns = 0;\n        Attribute cattrs = null;\n        // visits the header\n        u = header;\n        access = readUnsignedShort(u);\n        name = readClass(u + 2, c);\n        v = items[readUnsignedShort(u + 4)];\n        String superClassName = v == 0 ? null : readUTF8(v, c);\n        String[] implementedItfs = new String[readUnsignedShort(u + 6)];\n        w = 0;\n        u += 8;\n        for (i = 0; i < implementedItfs.length; ++i) {\n            implementedItfs[i] = readClass(u, c);\n            u += 2;\n        }\n        boolean skipCode = (flags & SKIP_CODE) != 0;\n        boolean skipDebug = (flags & SKIP_DEBUG) != 0;\n        boolean unzip = (flags & EXPAND_FRAMES) != 0;\n        // skips fields and methods\n        v = u;\n        i = readUnsignedShort(v);\n        v += 2;\n        for (; i > 0; --i) {\n            j = readUnsignedShort(v + 6);\n            v += 8;\n            for (; j > 0; --j) {\n                v += 6 + readInt(v + 2);\n            }\n        }\n        i = readUnsignedShort(v);\n        v += 2;\n        for (; i > 0; --i) {\n            j = readUnsignedShort(v + 6);\n            v += 8;\n            for (; j > 0; --j) {\n                v += 6 + readInt(v + 2);\n            }\n        }\n        // reads the class's attributes\n        signature = null;\n        String sourceFile = null;\n        String sourceDebug = null;\n        String enclosingOwner = null;\n        String enclosingName = null;\n        String enclosingDesc = null;\n        i = readUnsignedShort(v);\n        v += 2;\n        for (; i > 0; --i) {\n            attrName = readUTF8(v, c);\n            // tests are sorted in decreasing frequency order\n            // (based on frequencies observed on typical classes)\n            if (\"SourceFile\".equals(attrName)) {\n                sourceFile = readUTF8(v + 6, c);\n            } else if (\"InnerClasses\".equals(attrName)) {\n                w = v + 6;\n            } else if (\"EnclosingMethod\".equals(attrName)) {\n                enclosingOwner = readClass(v + 6, c);\n                int item = readUnsignedShort(v + 8);\n                if (item != 0) {\n                    enclosingName = readUTF8(items[item], c);\n                    enclosingDesc = readUTF8(items[item] + 2, c);\n                }\n            } else if (SIGNATURES && \"Signature\".equals(attrName)) {\n                signature = readUTF8(v + 6, c);\n            } else if (ANNOTATIONS && \"RuntimeVisibleAnnotations\".equals(attrName)) {\n                anns = v + 6;\n            } else if (\"Deprecated\".equals(attrName)) {\n                access |= Opcodes.ACC_DEPRECATED;\n            } else if (\"Synthetic\".equals(attrName)) {\n                access |= Opcodes.ACC_SYNTHETIC;\n            } else if (\"SourceDebugExtension\".equals(attrName)) {\n                int len = readInt(v + 2);\n                sourceDebug = readUTF(v + 6, len, new char[len]);\n            } else if (ANNOTATIONS && \"RuntimeInvisibleAnnotations\".equals(attrName)) {\n                ianns = v + 6;\n            } else {\n                attr = readAttribute(attrs, attrName, v + 6, readInt(v + 2), c, -1, null);\n                if (attr != null) {\n                    attr.next = cattrs;\n                    cattrs = attr;\n                }\n            }\n            v += 6 + readInt(v + 2);\n        }\n        // calls the visit method\n        classVisitor.visit(readInt(4), access, name, signature, superClassName, implementedItfs);\n        // calls the visitSource method\n        if (!skipDebug && (sourceFile != null || sourceDebug != null)) {\n            classVisitor.visitSource(sourceFile, sourceDebug);\n        }\n        // calls the visitOuterClass method\n        if (enclosingOwner != null) {\n            classVisitor.visitOuterClass(enclosingOwner, enclosingName, enclosingDesc);\n        }\n        // visits the class annotations\n        if (ANNOTATIONS) {\n            for (i = 1; i >= 0; --i) {\n                v = i == 0 ? ianns : anns;\n                if (v != 0) {\n                    j = readUnsignedShort(v);\n                    v += 2;\n                    for (; j > 0; --j) {\n                        v = readAnnotationValues(v + 2, c, true, classVisitor.visitAnnotation(readUTF8(v, c), i != 0));\n                    }\n                }\n            }\n        }\n        // visits the class attributes\n        while (cattrs != null) {\n            attr = cattrs.next;\n            cattrs.next = null;\n            classVisitor.visitAttribute(cattrs);\n            cattrs = attr;\n        }\n        // calls the visitInnerClass method\n        if (w != 0) {\n            i = readUnsignedShort(w);\n            w += 2;\n            for (; i > 0; --i) {\n                classVisitor.visitInnerClass(readUnsignedShort(w) == 0 ? null : readClass(w, c), readUnsignedShort(w + 2) == 0 ? null : readClass(w + 2, c), readUnsignedShort(w + 4) == 0 ? null : readUTF8(w + 4, c), readUnsignedShort(w + 6));\n                w += 8;\n            }\n        }\n        // visits the fields\n        i = readUnsignedShort(u);\n        u += 2;\n        for (; i > 0; --i) {\n            access = readUnsignedShort(u);\n            name = readUTF8(u + 2, c);\n            desc = readUTF8(u + 4, c);\n            // visits the field's attributes and looks for a ConstantValue\n            // attribute\n            int fieldValueItem = 0;\n            signature = null;\n            anns = 0;\n            ianns = 0;\n            cattrs = null;\n            j = readUnsignedShort(u + 6);\n            u += 8;\n            for (; j > 0; --j) {\n                attrName = readUTF8(u, c);\n                // tests are sorted in decreasing frequency order\n                // (based on frequencies observed on typical classes)\n                if (\"ConstantValue\".equals(attrName)) {\n                    fieldValueItem = readUnsignedShort(u + 6);\n                } else if (SIGNATURES && \"Signature\".equals(attrName)) {\n                    signature = readUTF8(u + 6, c);\n                } else if (\"Deprecated\".equals(attrName)) {\n                    access |= Opcodes.ACC_DEPRECATED;\n                } else if (\"Synthetic\".equals(attrName)) {\n                    access |= Opcodes.ACC_SYNTHETIC;\n                } else if (ANNOTATIONS && \"RuntimeVisibleAnnotations\".equals(attrName)) {\n                    anns = u + 6;\n                } else if (ANNOTATIONS && \"RuntimeInvisibleAnnotations\".equals(attrName)) {\n                    ianns = u + 6;\n                } else {\n                    attr = readAttribute(attrs, attrName, u + 6, readInt(u + 2), c, -1, null);\n                    if (attr != null) {\n                        attr.next = cattrs;\n                        cattrs = attr;\n                    }\n                }\n                u += 6 + readInt(u + 2);\n            }\n            // visits the field\n            FieldVisitor fv = classVisitor.visitField(access, name, desc, signature, fieldValueItem == 0 ? null : readConst(fieldValueItem, c));\n            // visits the field annotations and attributes\n            if (fv != null) {\n                if (ANNOTATIONS) {\n                    for (j = 1; j >= 0; --j) {\n                        v = j == 0 ? ianns : anns;\n                        if (v != 0) {\n                            k = readUnsignedShort(v);\n                            v += 2;\n                            for (; k > 0; --k) {\n                                v = readAnnotationValues(v + 2, c, true, fv.visitAnnotation(readUTF8(v, c), j != 0));\n                            }\n                        }\n                    }\n                }\n                while (cattrs != null) {\n                    attr = cattrs.next;\n                    cattrs.next = null;\n                    fv.visitAttribute(cattrs);\n                    cattrs = attr;\n                }\n                fv.visitEnd();\n            }\n        }\n        // visits the methods\n        i = readUnsignedShort(u);\n        u += 2;\n        for (; i > 0; --i) {\n            int u0 = u + 6;\n            access = readUnsignedShort(u);\n            name = readUTF8(u + 2, c);\n            desc = readUTF8(u + 4, c);\n            signature = null;\n            anns = 0;\n            ianns = 0;\n            int dann = 0;\n            int mpanns = 0;\n            int impanns = 0;\n            cattrs = null;\n            v = 0;\n            w = 0;\n            // looks for Code and Exceptions attributes\n            j = readUnsignedShort(u + 6);\n            u += 8;\n            for (; j > 0; --j) {\n                attrName = readUTF8(u, c);\n                int attrSize = readInt(u + 2);\n                u += 6;\n                // tests are sorted in decreasing frequency order\n                // (based on frequencies observed on typical classes)\n                if (\"Code\".equals(attrName)) {\n                    if (!skipCode) {\n                        v = u;\n                    }\n                } else if (\"Exceptions\".equals(attrName)) {\n                    w = u;\n                } else if (SIGNATURES && \"Signature\".equals(attrName)) {\n                    signature = readUTF8(u, c);\n                } else if (\"Deprecated\".equals(attrName)) {\n                    access |= Opcodes.ACC_DEPRECATED;\n                } else if (ANNOTATIONS && \"RuntimeVisibleAnnotations\".equals(attrName)) {\n                    anns = u;\n                } else if (ANNOTATIONS && \"AnnotationDefault\".equals(attrName)) {\n                    dann = u;\n                } else if (\"Synthetic\".equals(attrName)) {\n                    access |= Opcodes.ACC_SYNTHETIC;\n                } else if (ANNOTATIONS && \"RuntimeInvisibleAnnotations\".equals(attrName)) {\n                    ianns = u;\n                } else if (ANNOTATIONS && \"RuntimeVisibleParameterAnnotations\".equals(attrName)) {\n                    mpanns = u;\n                } else if (ANNOTATIONS && \"RuntimeInvisibleParameterAnnotations\".equals(attrName)) {\n                    impanns = u;\n                } else {\n                    attr = readAttribute(attrs, attrName, u, attrSize, c, -1, null);\n                    if (attr != null) {\n                        attr.next = cattrs;\n                        cattrs = attr;\n                    }\n                }\n                u += attrSize;\n            }\n            // reads declared exceptions\n            String[] exceptions;\n            if (w == 0) {\n                exceptions = null;\n            } else {\n                exceptions = new String[readUnsignedShort(w)];\n                w += 2;\n                for (j = 0; j < exceptions.length; ++j) {\n                    exceptions[j] = readClass(w, c);\n                    w += 2;\n                }\n            }\n            // visits the method's code, if any\n            MethodVisitor mv = classVisitor.visitMethod(access, name, desc, signature, exceptions);\n            if (mv != null) {\n                /*\n                 * if the returned MethodVisitor is in fact a MethodWriter, it\n                 * means there is no method adapter between the reader and the\n                 * writer. If, in addition, the writer's constant pool was\n                 * copied from this reader (mw.cw.cr == this), and the signature\n                 * and exceptions of the method have not been changed, then it\n                 * is possible to skip all visit events and just copy the\n                 * original code of the method to the writer (the access, name\n                 * and descriptor can have been changed, this is not important\n                 * since they are not copied as is from the reader).\n                 */\n                if (WRITER && mv instanceof MethodWriter) {\n                    MethodWriter mw = (MethodWriter) mv;\n                    if (mw.cw.cr == this) {\n                        if (signature == mw.signature) {\n                            boolean sameExceptions = false;\n                            if (exceptions == null) {\n                                sameExceptions = mw.exceptionCount == 0;\n                            } else {\n                                if (exceptions.length == mw.exceptionCount) {\n                                    sameExceptions = true;\n                                    for (j = exceptions.length - 1; j >= 0; --j) {\n                                        w -= 2;\n                                        if (mw.exceptions[j] != readUnsignedShort(w)) {\n                                            sameExceptions = false;\n                                            break;\n                                        }\n                                    }\n                                }\n                            }\n                            if (sameExceptions) {\n                                /*\n                                 * we do not copy directly the code into\n                                 * MethodWriter to save a byte array copy\n                                 * operation. The real copy will be done in\n                                 * ClassWriter.toByteArray().\n                                 */\n                                mw.classReaderOffset = u0;\n                                mw.classReaderLength = u - u0;\n                                continue;\n                            }\n                        }\n                    }\n                }\n                if (ANNOTATIONS && dann != 0) {\n                    AnnotationVisitor dv = mv.visitAnnotationDefault();\n                    readAnnotationValue(dann, c, null, dv);\n                    if (dv != null) {\n                        dv.visitEnd();\n                    }\n                }\n                if (ANNOTATIONS) {\n                    for (j = 1; j >= 0; --j) {\n                        w = j == 0 ? ianns : anns;\n                        if (w != 0) {\n                            k = readUnsignedShort(w);\n                            w += 2;\n                            for (; k > 0; --k) {\n                                w = readAnnotationValues(w + 2, c, true, mv.visitAnnotation(readUTF8(w, c), j != 0));\n                            }\n                        }\n                    }\n                }\n                if (ANNOTATIONS && mpanns != 0) {\n                    readParameterAnnotations(mpanns, desc, c, true, mv);\n                }\n                if (ANNOTATIONS && impanns != 0) {\n                    readParameterAnnotations(impanns, desc, c, false, mv);\n                }\n                while (cattrs != null) {\n                    attr = cattrs.next;\n                    cattrs.next = null;\n                    mv.visitAttribute(cattrs);\n                    cattrs = attr;\n                }\n            }\n            if (mv != null && v != 0) {\n                int maxStack = readUnsignedShort(v);\n                int maxLocals = readUnsignedShort(v + 2);\n                int codeLength = readInt(v + 4);\n                v += 8;\n                int codeStart = v;\n                int codeEnd = v + codeLength;\n                mv.visitCode();\n                // 1st phase: finds the labels\n                int label;\n                Label[] labels = new Label[codeLength + 2];\n                readLabel(codeLength + 1, labels);\n                while (v < codeEnd) {\n                    w = v - codeStart;\n                    int opcode = b[v] & 0xFF;\n                    switch(ClassWriter.TYPE[opcode]) {\n                        case ClassWriter.NOARG_INSN:\n                        case ClassWriter.IMPLVAR_INSN:\n                            v += 1;\n                            break;\n                        case ClassWriter.LABEL_INSN:\n                            readLabel(w + readShort(v + 1), labels);\n                            v += 3;\n                            break;\n                        case ClassWriter.LABELW_INSN:\n                            readLabel(w + readInt(v + 1), labels);\n                            v += 5;\n                            break;\n                        case ClassWriter.WIDE_INSN:\n                            opcode = b[v + 1] & 0xFF;\n                            if (opcode == Opcodes.IINC) {\n                                v += 6;\n                            } else {\n                                v += 4;\n                            }\n                            break;\n                        case ClassWriter.TABL_INSN:\n                            // skips 0 to 3 padding bytes*\n                            v = v + 4 - (w & 3);\n                            // reads instruction\n                            readLabel(w + readInt(v), labels);\n                            j = readInt(v + 8) - readInt(v + 4) + 1;\n                            v += 12;\n                            for (; j > 0; --j) {\n                                readLabel(w + readInt(v), labels);\n                                v += 4;\n                            }\n                            break;\n                        case ClassWriter.LOOK_INSN:\n                            // skips 0 to 3 padding bytes*\n                            v = v + 4 - (w & 3);\n                            // reads instruction\n                            readLabel(w + readInt(v), labels);\n                            j = readInt(v + 4);\n                            v += 8;\n                            for (; j > 0; --j) {\n                                readLabel(w + readInt(v + 4), labels);\n                                v += 8;\n                            }\n                            break;\n                        case ClassWriter.VAR_INSN:\n                        case ClassWriter.SBYTE_INSN:\n                        case ClassWriter.LDC_INSN:\n                            v += 2;\n                            break;\n                        case ClassWriter.SHORT_INSN:\n                        case ClassWriter.LDCW_INSN:\n                        case ClassWriter.FIELDORMETH_INSN:\n                        case ClassWriter.TYPE_INSN:\n                        case ClassWriter.IINC_INSN:\n                            v += 3;\n                            break;\n                        case ClassWriter.ITFDYNMETH_INSN:\n                            v += 5;\n                            break;\n                        // case MANA_INSN:\n                        default:\n                            v += 4;\n                            break;\n                    }\n                }\n                // parses the try catch entries\n                j = readUnsignedShort(v);\n                v += 2;\n                for (; j > 0; --j) {\n                    Label start = readLabel(readUnsignedShort(v), labels);\n                    Label end = readLabel(readUnsignedShort(v + 2), labels);\n                    Label handler = readLabel(readUnsignedShort(v + 4), labels);\n                    int type = readUnsignedShort(v + 6);\n                    if (type == 0) {\n                        mv.visitTryCatchBlock(start, end, handler, null);\n                    } else {\n                        mv.visitTryCatchBlock(start, end, handler, readUTF8(items[type], c));\n                    }\n                    v += 8;\n                }\n                // parses the local variable, line number tables, and code\n                // attributes\n                int varTable = 0;\n                int varTypeTable = 0;\n                int stackMap = 0;\n                int stackMapSize = 0;\n                int frameCount = 0;\n                int frameMode = 0;\n                int frameOffset = 0;\n                int frameLocalCount = 0;\n                int frameLocalDiff = 0;\n                int frameStackCount = 0;\n                Object[] frameLocal = null;\n                Object[] frameStack = null;\n                boolean zip = true;\n                cattrs = null;\n                j = readUnsignedShort(v);\n                v += 2;\n                for (; j > 0; --j) {\n                    attrName = readUTF8(v, c);\n                    if (\"LocalVariableTable\".equals(attrName)) {\n                        if (!skipDebug) {\n                            varTable = v + 6;\n                            k = readUnsignedShort(v + 6);\n                            w = v + 8;\n                            for (; k > 0; --k) {\n                                label = readUnsignedShort(w);\n                                if (labels[label] == null) {\n                                    readLabel(label, labels).status |= Label.DEBUG;\n                                }\n                                label += readUnsignedShort(w + 2);\n                                if (labels[label] == null) {\n                                    readLabel(label, labels).status |= Label.DEBUG;\n                                }\n                                w += 10;\n                            }\n                        }\n                    } else if (\"LocalVariableTypeTable\".equals(attrName)) {\n                        varTypeTable = v + 6;\n                    } else if (\"LineNumberTable\".equals(attrName)) {\n                        if (!skipDebug) {\n                            k = readUnsignedShort(v + 6);\n                            w = v + 8;\n                            for (; k > 0; --k) {\n                                label = readUnsignedShort(w);\n                                if (labels[label] == null) {\n                                    readLabel(label, labels).status |= Label.DEBUG;\n                                }\n                                labels[label].line = readUnsignedShort(w + 2);\n                                w += 4;\n                            }\n                        }\n                    } else if (FRAMES && \"StackMapTable\".equals(attrName)) {\n                        if ((flags & SKIP_FRAMES) == 0) {\n                            stackMap = v + 8;\n                            stackMapSize = readInt(v + 2);\n                            frameCount = readUnsignedShort(v + 6);\n                        }\n                        /*\n                         * here we do not extract the labels corresponding to\n                         * the attribute content. This would require a full\n                         * parsing of the attribute, which would need to be\n                         * repeated in the second phase (see below). Instead the\n                         * content of the attribute is read one frame at a time\n                         * (i.e. after a frame has been visited, the next frame\n                         * is read), and the labels it contains are also\n                         * extracted one frame at a time. Thanks to the ordering\n                         * of frames, having only a \"one frame lookahead\" is not\n                         * a problem, i.e. it is not possible to see an offset\n                         * smaller than the offset of the current insn and for\n                         * which no Label exist.\n                         */\n                        /*\n                         * This is not true for UNINITIALIZED type offsets. We\n                         * solve this by parsing the stack map table without a\n                         * full decoding (see below).\n                         */\n                    } else if (FRAMES && \"StackMap\".equals(attrName)) {\n                        if ((flags & SKIP_FRAMES) == 0) {\n                            stackMap = v + 8;\n                            stackMapSize = readInt(v + 2);\n                            frameCount = readUnsignedShort(v + 6);\n                            zip = false;\n                        }\n                        /*\n                         * IMPORTANT! here we assume that the frames are\n                         * ordered, as in the StackMapTable attribute, although\n                         * this is not guaranteed by the attribute format.\n                         */\n                    } else {\n                        for (k = 0; k < attrs.length; ++k) {\n                            if (attrs[k].type.equals(attrName)) {\n                                attr = attrs[k].read(this, v + 6, readInt(v + 2), c, codeStart - 8, labels);\n                                if (attr != null) {\n                                    attr.next = cattrs;\n                                    cattrs = attr;\n                                }\n                            }\n                        }\n                    }\n                    v += 6 + readInt(v + 2);\n                }\n                // 2nd phase: visits each instruction\n                if (FRAMES && stackMap != 0) {\n                    // creates the very first (implicit) frame from the method\n                    // descriptor\n                    frameLocal = new Object[maxLocals];\n                    frameStack = new Object[maxStack];\n                    if (unzip) {\n                        int local = 0;\n                        if ((access & Opcodes.ACC_STATIC) == 0) {\n                            if (\"<init>\".equals(name)) {\n                                frameLocal[local++] = Opcodes.UNINITIALIZED_THIS;\n                            } else {\n                                frameLocal[local++] = readClass(header + 2, c);\n                            }\n                        }\n                        j = 1;\n                        loop: while (true) {\n                            k = j;\n                            switch(desc.charAt(j++)) {\n                                case 'Z':\n                                case 'C':\n                                case 'B':\n                                case 'S':\n                                case 'I':\n                                    frameLocal[local++] = Opcodes.INTEGER;\n                                    break;\n                                case 'F':\n                                    frameLocal[local++] = Opcodes.FLOAT;\n                                    break;\n                                case 'J':\n                                    frameLocal[local++] = Opcodes.LONG;\n                                    break;\n                                case 'D':\n                                    frameLocal[local++] = Opcodes.DOUBLE;\n                                    break;\n                                case '[':\n                                    while (desc.charAt(j) == '[') {\n                                        ++j;\n                                    }\n                                    if (desc.charAt(j) == 'L') {\n                                        ++j;\n                                        while (desc.charAt(j) != ';') {\n                                            ++j;\n                                        }\n                                    }\n                                    frameLocal[local++] = desc.substring(k, ++j);\n                                    break;\n                                case 'L':\n                                    while (desc.charAt(j) != ';') {\n                                        ++j;\n                                    }\n                                    frameLocal[local++] = desc.substring(k + 1, j++);\n                                    break;\n                                default:\n                                    break loop;\n                            }\n                        }\n                        frameLocalCount = local;\n                    }\n                    /*\n                     * for the first explicit frame the offset is not\n                     * offset_delta + 1 but only offset_delta; setting the\n                     * implicit frame offset to -1 allow the use of the\n                     * \"offset_delta + 1\" rule in all cases\n                     */\n                    frameOffset = -1;\n                    /*\n                     * Finds labels for UNINITIALIZED frame types. Instead of\n                     * decoding each element of the stack map table, we look\n                     * for 3 consecutive bytes that \"look like\" an UNINITIALIZED\n                     * type (tag 8, offset within code bounds, NEW instruction\n                     * at this offset). We may find false positives (i.e. not \n                     * real UNINITIALIZED types), but this should be rare, and \n                     * the only consequence will be the creation of an unneeded \n                     * label. This is better than creating a label for each NEW\n                     * instruction, and faster than fully decoding the whole \n                     * stack map table.\n                     */\n                    for (j = stackMap; j < stackMap + stackMapSize - 2; ++j) {\n                        if (b[j] == 8) {\n                            // UNINITIALIZED FRAME TYPE\n                            k = readUnsignedShort(j + 1);\n                            if (k >= 0 && k < codeLength) {\n                                // potential offset\n                                if ((b[codeStart + k] & 0xFF) == Opcodes.NEW) {\n                                    // NEW at this offset\n                                    readLabel(k, labels);\n                                }\n                            }\n                        }\n                    }\n                }\n                v = codeStart;\n                Label l;\n                while (v < codeEnd) {\n                    w = v - codeStart;\n                    l = labels[w];\n                    if (l != null) {\n                        mv.visitLabel(l);\n                        if (!skipDebug && l.line > 0) {\n                            mv.visitLineNumber(l.line, l);\n                        }\n                    }\n                    while (FRAMES && frameLocal != null && (frameOffset == w || frameOffset == -1)) {\n                        // if there is a frame for this offset,\n                        // makes the visitor visit it,\n                        // and reads the next frame if there is one.\n                        if (!zip || unzip) {\n                            mv.visitFrame(Opcodes.F_NEW, frameLocalCount, frameLocal, frameStackCount, frameStack);\n                        } else if (frameOffset != -1) {\n                            mv.visitFrame(frameMode, frameLocalDiff, frameLocal, frameStackCount, frameStack);\n                        }\n                        if (frameCount > 0) {\n                            int tag, delta, n;\n                            if (zip) {\n                                tag = b[stackMap++] & 0xFF;\n                            } else {\n                                tag = MethodWriter.FULL_FRAME;\n                                frameOffset = -1;\n                            }\n                            frameLocalDiff = 0;\n                            if (tag < MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME) {\n                                delta = tag;\n                                frameMode = Opcodes.F_SAME;\n                                frameStackCount = 0;\n                            } else if (tag < MethodWriter.RESERVED) {\n                                delta = tag - MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME;\n                                stackMap = readFrameType(frameStack, 0, stackMap, c, labels);\n                                frameMode = Opcodes.F_SAME1;\n                                frameStackCount = 1;\n                            } else {\n                                delta = readUnsignedShort(stackMap);\n                                stackMap += 2;\n                                if (tag == MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {\n                                    stackMap = readFrameType(frameStack, 0, stackMap, c, labels);\n                                    frameMode = Opcodes.F_SAME1;\n                                    frameStackCount = 1;\n                                } else if (tag >= MethodWriter.CHOP_FRAME && tag < MethodWriter.SAME_FRAME_EXTENDED) {\n                                    frameMode = Opcodes.F_CHOP;\n                                    frameLocalDiff = MethodWriter.SAME_FRAME_EXTENDED - tag;\n                                    frameLocalCount -= frameLocalDiff;\n                                    frameStackCount = 0;\n                                } else if (tag == MethodWriter.SAME_FRAME_EXTENDED) {\n                                    frameMode = Opcodes.F_SAME;\n                                    frameStackCount = 0;\n                                } else if (tag < MethodWriter.FULL_FRAME) {\n                                    j = unzip ? frameLocalCount : 0;\n                                    for (k = tag - MethodWriter.SAME_FRAME_EXTENDED; k > 0; k--) {\n                                        stackMap = readFrameType(frameLocal, j++, stackMap, c, labels);\n                                    }\n                                    frameMode = Opcodes.F_APPEND;\n                                    frameLocalDiff = tag - MethodWriter.SAME_FRAME_EXTENDED;\n                                    frameLocalCount += frameLocalDiff;\n                                    frameStackCount = 0;\n                                } else {\n                                    // if (tag == FULL_FRAME) {\n                                    frameMode = Opcodes.F_FULL;\n                                    n = frameLocalDiff = frameLocalCount = readUnsignedShort(stackMap);\n                                    stackMap += 2;\n                                    for (j = 0; n > 0; n--) {\n                                        stackMap = readFrameType(frameLocal, j++, stackMap, c, labels);\n                                    }\n                                    n = frameStackCount = readUnsignedShort(stackMap);\n                                    stackMap += 2;\n                                    for (j = 0; n > 0; n--) {\n                                        stackMap = readFrameType(frameStack, j++, stackMap, c, labels);\n                                    }\n                                }\n                            }\n                            frameOffset += delta + 1;\n                            readLabel(frameOffset, labels);\n                            --frameCount;\n                        } else {\n                            frameLocal = null;\n                        }\n                    }\n                    int opcode = b[v] & 0xFF;\n                    switch(ClassWriter.TYPE[opcode]) {\n                        case ClassWriter.NOARG_INSN:\n                            mv.visitInsn(opcode);\n                            v += 1;\n                            break;\n                        case ClassWriter.IMPLVAR_INSN:\n                            if (opcode > Opcodes.ISTORE) {\n                                // ISTORE_0\n                                opcode -= 59;\n                                mv.visitVarInsn(Opcodes.ISTORE + (opcode >> 2), opcode & 0x3);\n                            } else {\n                                // ILOAD_0\n                                opcode -= 26;\n                                mv.visitVarInsn(Opcodes.ILOAD + (opcode >> 2), opcode & 0x3);\n                            }\n                            v += 1;\n                            break;\n                        case ClassWriter.LABEL_INSN:\n                            mv.visitJumpInsn(opcode, labels[w + readShort(v + 1)]);\n                            v += 3;\n                            break;\n                        case ClassWriter.LABELW_INSN:\n                            mv.visitJumpInsn(opcode - 33, labels[w + readInt(v + 1)]);\n                            v += 5;\n                            break;\n                        case ClassWriter.WIDE_INSN:\n                            opcode = b[v + 1] & 0xFF;\n                            if (opcode == Opcodes.IINC) {\n                                mv.visitIincInsn(readUnsignedShort(v + 2), readShort(v + 4));\n                                v += 6;\n                            } else {\n                                mv.visitVarInsn(opcode, readUnsignedShort(v + 2));\n                                v += 4;\n                            }\n                            break;\n                        case ClassWriter.TABL_INSN:\n                            // skips 0 to 3 padding bytes\n                            v = v + 4 - (w & 3);\n                            // reads instruction\n                            label = w + readInt(v);\n                            int min = readInt(v + 4);\n                            int max = readInt(v + 8);\n                            v += 12;\n                            Label[] table = new Label[max - min + 1];\n                            for (j = 0; j < table.length; ++j) {\n                                table[j] = labels[w + readInt(v)];\n                                v += 4;\n                            }\n                            mv.visitTableSwitchInsn(min, max, labels[label], table);\n                            break;\n                        case ClassWriter.LOOK_INSN:\n                            // skips 0 to 3 padding bytes\n                            v = v + 4 - (w & 3);\n                            // reads instruction\n                            label = w + readInt(v);\n                            j = readInt(v + 4);\n                            v += 8;\n                            int[] keys = new int[j];\n                            Label[] values = new Label[j];\n                            for (j = 0; j < keys.length; ++j) {\n                                keys[j] = readInt(v);\n                                values[j] = labels[w + readInt(v + 4)];\n                                v += 8;\n                            }\n                            mv.visitLookupSwitchInsn(labels[label], keys, values);\n                            break;\n                        case ClassWriter.VAR_INSN:\n                            mv.visitVarInsn(opcode, b[v + 1] & 0xFF);\n                            v += 2;\n                            break;\n                        case ClassWriter.SBYTE_INSN:\n                            mv.visitIntInsn(opcode, b[v + 1]);\n                            v += 2;\n                            break;\n                        case ClassWriter.SHORT_INSN:\n                            mv.visitIntInsn(opcode, readShort(v + 1));\n                            v += 3;\n                            break;\n                        case ClassWriter.LDC_INSN:\n                            mv.visitLdcInsn(readConst(b[v + 1] & 0xFF, c));\n                            v += 2;\n                            break;\n                        case ClassWriter.LDCW_INSN:\n                            mv.visitLdcInsn(readConst(readUnsignedShort(v + 1), c));\n                            v += 3;\n                            break;\n                        case ClassWriter.FIELDORMETH_INSN:\n                        case ClassWriter.ITFDYNMETH_INSN:\n                            int cpIndex = items[readUnsignedShort(v + 1)];\n                            String iowner;\n                            // INVOKEDYNAMIC is receiverless\n                            if (opcode == Opcodes.INVOKEDYNAMIC) {\n                                iowner = Opcodes.INVOKEDYNAMIC_OWNER;\n                            } else {\n                                iowner = readClass(cpIndex, c);\n                                cpIndex = items[readUnsignedShort(cpIndex + 2)];\n                            }\n                            String iname = readUTF8(cpIndex, c);\n                            String idesc = readUTF8(cpIndex + 2, c);\n                            if (opcode < Opcodes.INVOKEVIRTUAL) {\n                                mv.visitFieldInsn(opcode, iowner, iname, idesc);\n                            } else {\n                                mv.visitMethodInsn(opcode, iowner, iname, idesc);\n                            }\n                            if (opcode == Opcodes.INVOKEINTERFACE || opcode == Opcodes.INVOKEDYNAMIC) {\n                                v += 5;\n                            } else {\n                                v += 3;\n                            }\n                            break;\n                        case ClassWriter.TYPE_INSN:\n                            mv.visitTypeInsn(opcode, readClass(v + 1, c));\n                            v += 3;\n                            break;\n                        case ClassWriter.IINC_INSN:\n                            mv.visitIincInsn(b[v + 1] & 0xFF, b[v + 2]);\n                            v += 3;\n                            break;\n                        // case MANA_INSN:\n                        default:\n                            mv.visitMultiANewArrayInsn(readClass(v + 1, c), b[v + 3] & 0xFF);\n                            v += 4;\n                            break;\n                    }\n                }\n                l = labels[codeEnd - codeStart];\n                if (l != null) {\n                    mv.visitLabel(l);\n                }\n                // visits the local variable tables\n                if (!skipDebug && varTable != 0) {\n                    int[] typeTable = null;\n                    if (varTypeTable != 0) {\n                        k = readUnsignedShort(varTypeTable) * 3;\n                        w = varTypeTable + 2;\n                        typeTable = new int[k];\n                        while (k > 0) {\n                            // signature\n                            typeTable[--k] = w + 6;\n                            // index\n                            typeTable[--k] = readUnsignedShort(w + 8);\n                            // start\n                            typeTable[--k] = readUnsignedShort(w);\n                            w += 10;\n                        }\n                    }\n                    k = readUnsignedShort(varTable);\n                    w = varTable + 2;\n                    for (; k > 0; --k) {\n                        int start = readUnsignedShort(w);\n                        int length = readUnsignedShort(w + 2);\n                        int index = readUnsignedShort(w + 8);\n                        String vsignature = null;\n                        if (typeTable != null) {\n                            for (int a = 0; a < typeTable.length; a += 3) {\n                                if (typeTable[a] == start && typeTable[a + 1] == index) {\n                                    vsignature = readUTF8(typeTable[a + 2], c);\n                                    break;\n                                }\n                            }\n                        }\n                        mv.visitLocalVariable(readUTF8(w + 4, c), readUTF8(w + 6, c), vsignature, labels[start], labels[start + length], index);\n                        w += 10;\n                    }\n                }\n                // visits the other attributes\n                while (cattrs != null) {\n                    attr = cattrs.next;\n                    cattrs.next = null;\n                    mv.visitAttribute(cattrs);\n                    cattrs = attr;\n                }\n                // visits the max stack and max locals values\n                mv.visitMaxs(maxStack, maxLocals);\n            }\n            if (mv != null) {\n                mv.visitEnd();\n            }\n        }\n        // visits the end of the class\n        classVisitor.visitEnd();\n    }\n\n    /**\n     * Reads parameter annotations and makes the given visitor visit them.\n     *\n     * @param v start offset in {@link #b b} of the annotations to be read.\n     * @param desc the method descriptor.\n     * @param buf buffer to be used to call {@link #readUTF8 readUTF8},\n     *        {@link #readClass(int,char[]) readClass} or\n     *        {@link #readConst readConst}.\n     * @param visible <tt>true</tt> if the annotations to be read are visible\n     *        at runtime.\n     * @param mv the visitor that must visit the annotations.\n     */\n    private void readParameterAnnotations(int v, final String desc, final char[] buf, final boolean visible, final MethodVisitor mv) {\n        int i;\n        int n = b[v++] & 0xFF;\n        // workaround for a bug in javac (javac compiler generates a parameter\n        // annotation array whose size is equal to the number of parameters in\n        // the Java source file, while it should generate an array whose size is\n        // equal to the number of parameters in the method descriptor - which\n        // includes the synthetic parameters added by the compiler). This work-\n        // around supposes that the synthetic parameters are the first ones.\n        int synthetics = Type.getArgumentTypes(desc).length - n;\n        AnnotationVisitor av;\n        for (i = 0; i < synthetics; ++i) {\n            // virtual annotation to detect synthetic parameters in MethodWriter\n            av = mv.visitParameterAnnotation(i, \"Ljava/lang/Synthetic;\", false);\n            if (av != null) {\n                av.visitEnd();\n            }\n        }\n        for (; i < n + synthetics; ++i) {\n            int j = readUnsignedShort(v);\n            v += 2;\n            for (; j > 0; --j) {\n                av = mv.visitParameterAnnotation(i, readUTF8(v, buf), visible);\n                v = readAnnotationValues(v + 2, buf, true, av);\n            }\n        }\n    }\n\n    /**\n     * Reads the values of an annotation and makes the given visitor visit them.\n     *\n     * @param v the start offset in {@link #b b} of the values to be read\n     *        (including the unsigned short that gives the number of values).\n     * @param buf buffer to be used to call {@link #readUTF8 readUTF8},\n     *        {@link #readClass(int,char[]) readClass} or\n     *        {@link #readConst readConst}.\n     * @param named if the annotation values are named or not.\n     * @param av the visitor that must visit the values.\n     * @return the end offset of the annotation values.\n     */\n    private int readAnnotationValues(int v, final char[] buf, final boolean named, final AnnotationVisitor av) {\n        int i = readUnsignedShort(v);\n        v += 2;\n        if (named) {\n            for (; i > 0; --i) {\n                v = readAnnotationValue(v + 2, buf, readUTF8(v, buf), av);\n            }\n        } else {\n            for (; i > 0; --i) {\n                v = readAnnotationValue(v, buf, null, av);\n            }\n        }\n        if (av != null) {\n            av.visitEnd();\n        }\n        return v;\n    }\n\n    /**\n     * Reads a value of an annotation and makes the given visitor visit it.\n     *\n     * @param v the start offset in {@link #b b} of the value to be read (<i>not\n     *        including the value name constant pool index</i>).\n     * @param buf buffer to be used to call {@link #readUTF8 readUTF8},\n     *        {@link #readClass(int,char[]) readClass} or\n     *        {@link #readConst readConst}.\n     * @param name the name of the value to be read.\n     * @param av the visitor that must visit the value.\n     * @return the end offset of the annotation value.\n     */\n    private int readAnnotationValue(int v, final char[] buf, final String name, final AnnotationVisitor av) {\n        int i;\n        if (av == null) {\n            switch(b[v] & 0xFF) {\n                case // enum_const_value\n                'e':\n                    return v + 5;\n                case // annotation_value\n                '@':\n                    return readAnnotationValues(v + 3, buf, true, null);\n                case // array_value\n                '[':\n                    return readAnnotationValues(v + 1, buf, false, null);\n                default:\n                    return v + 3;\n            }\n        }\n        switch(b[v++] & 0xFF) {\n            // pointer to CONSTANT_Integer\n            case 'I':\n            // pointer to CONSTANT_Long\n            case 'J':\n            // pointer to CONSTANT_Float\n            case 'F':\n            case // pointer to CONSTANT_Double\n            'D':\n                av.visit(name, readConst(readUnsignedShort(v), buf));\n                v += 2;\n                break;\n            case // pointer to CONSTANT_Byte\n            'B':\n                av.visit(name, new Byte((byte) readInt(items[readUnsignedShort(v)])));\n                v += 2;\n                break;\n            case // pointer to CONSTANT_Boolean\n            'Z':\n                av.visit(name, readInt(items[readUnsignedShort(v)]) == 0 ? Boolean.FALSE : Boolean.TRUE);\n                v += 2;\n                break;\n            case // pointer to CONSTANT_Short\n            'S':\n                av.visit(name, new Short((short) readInt(items[readUnsignedShort(v)])));\n                v += 2;\n                break;\n            case // pointer to CONSTANT_Char\n            'C':\n                av.visit(name, new Character((char) readInt(items[readUnsignedShort(v)])));\n                v += 2;\n                break;\n            case // pointer to CONSTANT_Utf8\n            's':\n                av.visit(name, readUTF8(v, buf));\n                v += 2;\n                break;\n            case // enum_const_value\n            'e':\n                av.visitEnum(name, readUTF8(v, buf), readUTF8(v + 2, buf));\n                v += 4;\n                break;\n            case // class_info\n            'c':\n                av.visit(name, Type.getType(readUTF8(v, buf)));\n                v += 2;\n                break;\n            case // annotation_value\n            '@':\n                v = readAnnotationValues(v + 2, buf, true, av.visitAnnotation(name, readUTF8(v, buf)));\n                break;\n            case // array_value\n            '[':\n                int size = readUnsignedShort(v);\n                v += 2;\n                if (size == 0) {\n                    return readAnnotationValues(v - 2, buf, false, av.visitArray(name));\n                }\n                switch(this.b[v++] & 0xFF) {\n                    case 'B':\n                        byte[] bv = new byte[size];\n                        for (i = 0; i < size; i++) {\n                            bv[i] = (byte) readInt(items[readUnsignedShort(v)]);\n                            v += 3;\n                        }\n                        av.visit(name, bv);\n                        --v;\n                        break;\n                    case 'Z':\n                        boolean[] zv = new boolean[size];\n                        for (i = 0; i < size; i++) {\n                            zv[i] = readInt(items[readUnsignedShort(v)]) != 0;\n                            v += 3;\n                        }\n                        av.visit(name, zv);\n                        --v;\n                        break;\n                    case 'S':\n                        short[] sv = new short[size];\n                        for (i = 0; i < size; i++) {\n                            sv[i] = (short) readInt(items[readUnsignedShort(v)]);\n                            v += 3;\n                        }\n                        av.visit(name, sv);\n                        --v;\n                        break;\n                    case 'C':\n                        char[] cv = new char[size];\n                        for (i = 0; i < size; i++) {\n                            cv[i] = (char) readInt(items[readUnsignedShort(v)]);\n                            v += 3;\n                        }\n                        av.visit(name, cv);\n                        --v;\n                        break;\n                    case 'I':\n                        int[] iv = new int[size];\n                        for (i = 0; i < size; i++) {\n                            iv[i] = readInt(items[readUnsignedShort(v)]);\n                            v += 3;\n                        }\n                        av.visit(name, iv);\n                        --v;\n                        break;\n                    case 'J':\n                        long[] lv = new long[size];\n                        for (i = 0; i < size; i++) {\n                            lv[i] = readLong(items[readUnsignedShort(v)]);\n                            v += 3;\n                        }\n                        av.visit(name, lv);\n                        --v;\n                        break;\n                    case 'F':\n                        float[] fv = new float[size];\n                        for (i = 0; i < size; i++) {\n                            fv[i] = Float.intBitsToFloat(readInt(items[readUnsignedShort(v)]));\n                            v += 3;\n                        }\n                        av.visit(name, fv);\n                        --v;\n                        break;\n                    case 'D':\n                        double[] dv = new double[size];\n                        for (i = 0; i < size; i++) {\n                            dv[i] = Double.longBitsToDouble(readLong(items[readUnsignedShort(v)]));\n                            v += 3;\n                        }\n                        av.visit(name, dv);\n                        --v;\n                        break;\n                    default:\n                        v = readAnnotationValues(v - 3, buf, false, av.visitArray(name));\n                }\n        }\n        return v;\n    }\n\n    private int readFrameType(final Object[] frame, final int index, int v, final char[] buf, final Label[] labels) {\n        int type = b[v++] & 0xFF;\n        switch(type) {\n            case 0:\n                frame[index] = Opcodes.TOP;\n                break;\n            case 1:\n                frame[index] = Opcodes.INTEGER;\n                break;\n            case 2:\n                frame[index] = Opcodes.FLOAT;\n                break;\n            case 3:\n                frame[index] = Opcodes.DOUBLE;\n                break;\n            case 4:\n                frame[index] = Opcodes.LONG;\n                break;\n            case 5:\n                frame[index] = Opcodes.NULL;\n                break;\n            case 6:\n                frame[index] = Opcodes.UNINITIALIZED_THIS;\n                break;\n            case // Object\n            7:\n                frame[index] = readClass(v, buf);\n                v += 2;\n                break;\n            default:\n                // Uninitialized\n                frame[index] = readLabel(readUnsignedShort(v), labels);\n                v += 2;\n        }\n        return v;\n    }\n\n    /**\n     * Returns the label corresponding to the given offset. The default\n     * implementation of this method creates a label for the given offset if it\n     * has not been already created.\n     *\n     * @param offset a bytecode offset in a method.\n     * @param labels the already created labels, indexed by their offset. If a\n     *        label already exists for offset this method must not create a new\n     *        one. Otherwise it must store the new label in this array.\n     * @return a non null Label, which must be equal to labels[offset].\n     */\n    protected Label readLabel(int offset, Label[] labels) {\n        if (labels[offset] == null) {\n            labels[offset] = new Label();\n        }\n        return labels[offset];\n    }\n\n    /**\n     * Reads an attribute in {@link #b b}.\n     *\n     * @param attrs prototypes of the attributes that must be parsed during the\n     *        visit of the class. Any attribute whose type is not equal to the\n     *        type of one the prototypes is ignored (i.e. an empty\n     *        {@link Attribute} instance is returned).\n     * @param type the type of the attribute.\n     * @param off index of the first byte of the attribute's content in\n     *        {@link #b b}. The 6 attribute header bytes, containing the type\n     *        and the length of the attribute, are not taken into account here\n     *        (they have already been read).\n     * @param len the length of the attribute's content.\n     * @param buf buffer to be used to call {@link #readUTF8 readUTF8},\n     *        {@link #readClass(int,char[]) readClass} or\n     *        {@link #readConst readConst}.\n     * @param codeOff index of the first byte of code's attribute content in\n     *        {@link #b b}, or -1 if the attribute to be read is not a code\n     *        attribute. The 6 attribute header bytes, containing the type and\n     *        the length of the attribute, are not taken into account here.\n     * @param labels the labels of the method's code, or <tt>null</tt> if the\n     *        attribute to be read is not a code attribute.\n     * @return the attribute that has been read, or <tt>null</tt> to skip this\n     *         attribute.\n     */\n    private Attribute readAttribute(final Attribute[] attrs, final String type, final int off, final int len, final char[] buf, final int codeOff, final Label[] labels) {\n        for (int i = 0; i < attrs.length; ++i) {\n            if (attrs[i].type.equals(type)) {\n                return attrs[i].read(this, off, len, buf, codeOff, labels);\n            }\n        }\n        return new Attribute(type).read(this, off, len, null, -1, null);\n    }\n\n    // ------------------------------------------------------------------------\n    // Utility methods: low level parsing\n    // ------------------------------------------------------------------------\n    /**\n     * Returns the start index of the constant pool item in {@link #b b}, plus\n     * one. <i>This method is intended for {@link Attribute} sub classes, and is\n     * normally not needed by class generators or adapters.</i>\n     *\n     * @param item the index a constant pool item.\n     * @return the start index of the constant pool item in {@link #b b}, plus\n     *         one.\n     */\n    public int getItem(final int item) {\n        return items[item];\n    }\n\n    /**\n     * Reads a byte value in {@link #b b}. <i>This method is intended for\n     * {@link Attribute} sub classes, and is normally not needed by class\n     * generators or adapters.</i>\n     *\n     * @param index the start index of the value to be read in {@link #b b}.\n     * @return the read value.\n     */\n    public int readByte(final int index) {\n        return b[index] & 0xFF;\n    }\n\n    /**\n     * Reads an unsigned short value in {@link #b b}. <i>This method is\n     * intended for {@link Attribute} sub classes, and is normally not needed by\n     * class generators or adapters.</i>\n     *\n     * @param index the start index of the value to be read in {@link #b b}.\n     * @return the read value.\n     */\n    public int readUnsignedShort(final int index) {\n        byte[] b = this.b;\n        return ((b[index] & 0xFF) << 8) | (b[index + 1] & 0xFF);\n    }\n\n    /**\n     * Reads a signed short value in {@link #b b}. <i>This method is intended\n     * for {@link Attribute} sub classes, and is normally not needed by class\n     * generators or adapters.</i>\n     *\n     * @param index the start index of the value to be read in {@link #b b}.\n     * @return the read value.\n     */\n    public short readShort(final int index) {\n        byte[] b = this.b;\n        return (short) (((b[index] & 0xFF) << 8) | (b[index + 1] & 0xFF));\n    }\n\n    /**\n     * Reads a signed int value in {@link #b b}. <i>This method is intended for\n     * {@link Attribute} sub classes, and is normally not needed by class\n     * generators or adapters.</i>\n     *\n     * @param index the start index of the value to be read in {@link #b b}.\n     * @return the read value.\n     */\n    public int readInt(final int index) {\n        byte[] b = this.b;\n        return ((b[index] & 0xFF) << 24) | ((b[index + 1] & 0xFF) << 16) | ((b[index + 2] & 0xFF) << 8) | (b[index + 3] & 0xFF);\n    }\n\n    /**\n     * Reads a signed long value in {@link #b b}. <i>This method is intended\n     * for {@link Attribute} sub classes, and is normally not needed by class\n     * generators or adapters.</i>\n     *\n     * @param index the start index of the value to be read in {@link #b b}.\n     * @return the read value.\n     */\n    public long readLong(final int index) {\n        long l1 = readInt(index);\n        long l0 = readInt(index + 4) & 0xFFFFFFFFL;\n        return (l1 << 32) | l0;\n    }\n\n    /**\n     * Reads an UTF8 string constant pool item in {@link #b b}. <i>This method\n     * is intended for {@link Attribute} sub classes, and is normally not needed\n     * by class generators or adapters.</i>\n     *\n     * @param index the start index of an unsigned short value in {@link #b b},\n     *        whose value is the index of an UTF8 constant pool item.\n     * @param buf buffer to be used to read the item. This buffer must be\n     *        sufficiently large. It is not automatically resized.\n     * @return the String corresponding to the specified UTF8 item.\n     */\n    public String readUTF8(int index, final char[] buf) {\n        int item = readUnsignedShort(index);\n        String s = strings[item];\n        if (s != null) {\n            return s;\n        }\n        index = items[item];\n        return strings[item] = readUTF(index + 2, readUnsignedShort(index), buf);\n    }\n\n    /**\n     * Reads UTF8 string in {@link #b b}.\n     *\n     * @param index start offset of the UTF8 string to be read.\n     * @param utfLen length of the UTF8 string to be read.\n     * @param buf buffer to be used to read the string. This buffer must be\n     *        sufficiently large. It is not automatically resized.\n     * @return the String corresponding to the specified UTF8 string.\n     */\n    private String readUTF(int index, final int utfLen, final char[] buf) {\n        int endIndex = index + utfLen;\n        byte[] b = this.b;\n        int strLen = 0;\n        int c;\n        int st = 0;\n        char cc = 0;\n        while (index < endIndex) {\n            c = b[index++];\n            switch(st) {\n                case 0:\n                    c = c & 0xFF;\n                    if (c < 0x80) {\n                        // 0xxxxxxx\n                        buf[strLen++] = (char) c;\n                    } else if (c < 0xE0 && c > 0xBF) {\n                        // 110x xxxx 10xx xxxx\n                        cc = (char) (c & 0x1F);\n                        st = 1;\n                    } else {\n                        // 1110 xxxx 10xx xxxx 10xx xxxx\n                        cc = (char) (c & 0x0F);\n                        st = 2;\n                    }\n                    break;\n                case // byte 2 of 2-byte char or byte 3 of 3-byte char\n                1:\n                    buf[strLen++] = (char) ((cc << 6) | (c & 0x3F));\n                    st = 0;\n                    break;\n                case // byte 2 of 3-byte char\n                2:\n                    cc = (char) ((cc << 6) | (c & 0x3F));\n                    st = 1;\n                    break;\n            }\n        }\n        return new String(buf, 0, strLen);\n    }\n\n    /**\n     * Reads a class constant pool item in {@link #b b}. <i>This method is\n     * intended for {@link Attribute} sub classes, and is normally not needed by\n     * class generators or adapters.</i>\n     *\n     * @param index the start index of an unsigned short value in {@link #b b},\n     *        whose value is the index of a class constant pool item.\n     * @param buf buffer to be used to read the item. This buffer must be\n     *        sufficiently large. It is not automatically resized.\n     * @return the String corresponding to the specified class item.\n     */\n    public String readClass(final int index, final char[] buf) {\n        // computes the start index of the CONSTANT_Class item in b\n        // and reads the CONSTANT_Utf8 item designated by\n        // the first two bytes of this CONSTANT_Class item\n        return readUTF8(items[readUnsignedShort(index)], buf);\n    }\n\n    /**\n     * Reads a numeric or string constant pool item in {@link #b b}. <i>This\n     * method is intended for {@link Attribute} sub classes, and is normally not\n     * needed by class generators or adapters.</i>\n     *\n     * @param item the index of a constant pool item.\n     * @param buf buffer to be used to read the item. This buffer must be\n     *        sufficiently large. It is not automatically resized.\n     * @return the {@link Integer}, {@link Float}, {@link Long},\n     *         {@link Double}, {@link String} or {@link Type} corresponding to\n     *         the given constant pool item.\n     */\n    public Object readConst(final int item, final char[] buf) {\n        int index = items[item];\n        switch(b[index - 1]) {\n            case ClassWriter.INT:\n                return new Integer(readInt(index));\n            case ClassWriter.FLOAT:\n                return new Float(Float.intBitsToFloat(readInt(index)));\n            case ClassWriter.LONG:\n                return new Long(readLong(index));\n            case ClassWriter.DOUBLE:\n                return new Double(Double.longBitsToDouble(readLong(index)));\n            case ClassWriter.CLASS:\n                return Type.getObjectType(readUTF8(index, buf));\n            // case ClassWriter.STR:\n            default:\n                return readUTF8(index, buf);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/ClassReaderTest7.java",
		"test_prompt": "// ClassReaderTest7.java\npackage org.objectweb.asm.jip;\n\nimport java.io.InputStream;\nimport java.io.IOException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassReader}.\n* It contains ten unit test cases for the {@link ClassReader#readConst(int, char[])} method.\n*/\nclass ClassReaderTest7 {"
	},
	{
		"original_code": "// Attribute.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\n/**\n * A non standard class, field, method or code attribute.\n *\n * @author Eric Bruneton\n * @author Eugene Kuleshov\n */\npublic class Attribute {\n\n    /**\n     * The type of this attribute.\n     */\n    public final String type;\n\n    /**\n     * The raw value of this attribute, used only for unknown attributes.\n     */\n    byte[] value;\n\n    /**\n     * The next attribute in this attribute list. May be <tt>null</tt>.\n     */\n    Attribute next;\n\n    /**\n     * Constructs a new empty attribute.\n     *\n     * @param type the type of the attribute.\n     */\n    protected Attribute(final String type) {\n        this.type = type;\n    }\n\n    /**\n     * Returns <tt>true</tt> if this type of attribute is unknown. The default\n     * implementation of this method always returns <tt>true</tt>.\n     *\n     * @return <tt>true</tt> if this type of attribute is unknown.\n     */\n    public boolean isUnknown() {\n        return true;\n    }\n\n    /**\n     * Returns <tt>true</tt> if this type of attribute is a code attribute.\n     *\n     * @return <tt>true</tt> if this type of attribute is a code attribute.\n     */\n    public boolean isCodeAttribute() {\n        return false;\n    }\n\n    /**\n     * Returns the labels corresponding to this attribute.\n     *\n     * @return the labels corresponding to this attribute, or <tt>null</tt> if\n     *         this attribute is not a code attribute that contains labels.\n     */\n    protected Label[] getLabels() {\n        return null;\n    }\n\n    /**\n     * Reads a {@link #type type} attribute. This method must return a <i>new</i>\n     * {@link Attribute} object, of type {@link #type type}, corresponding to\n     * the <tt>len</tt> bytes starting at the given offset, in the given class\n     * reader.\n     *\n     * @param cr the class that contains the attribute to be read.\n     * @param off index of the first byte of the attribute's content in {@link\n     *        ClassReader#b cr.b}. The 6 attribute header bytes, containing the\n     *        type and the length of the attribute, are not taken into account\n     *        here.\n     * @param len the length of the attribute's content.\n     * @param buf buffer to be used to call\n     *        {@link ClassReader#readUTF8 readUTF8},\n     *        {@link ClassReader#readClass(int,char[]) readClass} or\n     *        {@link ClassReader#readConst readConst}.\n     * @param codeOff index of the first byte of code's attribute content in\n     *        {@link ClassReader#b cr.b}, or -1 if the attribute to be read is\n     *        not a code attribute. The 6 attribute header bytes, containing the\n     *        type and the length of the attribute, are not taken into account\n     *        here.\n     * @param labels the labels of the method's code, or <tt>null</tt> if the\n     *        attribute to be read is not a code attribute.\n     * @return a <i>new</i> {@link Attribute} object corresponding to the given\n     *         bytes.\n     */\n    protected Attribute read(final ClassReader cr, final int off, final int len, final char[] buf, final int codeOff, final Label[] labels) {\n        Attribute attr = new Attribute(type);\n        attr.value = new byte[len];\n        System.arraycopy(cr.b, off, attr.value, 0, len);\n        return attr;\n    }\n\n    /**\n     * Returns the byte array form of this attribute.\n     *\n     * @param cw the class to which this attribute must be added. This parameter\n     *        can be used to add to the constant pool of this class the items\n     *        that corresponds to this attribute.\n     * @param code the bytecode of the method corresponding to this code\n     *        attribute, or <tt>null</tt> if this attribute is not a code\n     *        attributes.\n     * @param len the length of the bytecode of the method corresponding to this\n     *        code attribute, or <tt>null</tt> if this attribute is not a code\n     *        attribute.\n     * @param maxStack the maximum stack size of the method corresponding to\n     *        this code attribute, or -1 if this attribute is not a code\n     *        attribute.\n     * @param maxLocals the maximum number of local variables of the method\n     *        corresponding to this code attribute, or -1 if this attribute is\n     *        not a code attribute.\n     * @return the byte array form of this attribute.\n     */\n    protected ByteVector write(final ClassWriter cw, final byte[] code, final int len, final int maxStack, final int maxLocals) {\n        ByteVector v = new ByteVector();\n        v.data = value;\n        v.length = value.length;\n        return v;\n    }\n\n    /**\n     * Returns the length of the attribute list that begins with this attribute.\n     *\n     * @return the length of the attribute list that begins with this attribute.\n     */\n    final int getCount() {\n        int count = 0;\n        Attribute attr = this;\n        while (attr != null) {\n            count += 1;\n            attr = attr.next;\n        }\n        return count;\n    }\n\n    /**\n     * Returns the size of all the attributes in this attribute list.\n     *\n     * @param cw the class writer to be used to convert the attributes into byte\n     *        arrays, with the {@link #write write} method.\n     * @param code the bytecode of the method corresponding to these code\n     *        attributes, or <tt>null</tt> if these attributes are not code\n     *        attributes.\n     * @param len the length of the bytecode of the method corresponding to\n     *        these code attributes, or <tt>null</tt> if these attributes are\n     *        not code attributes.\n     * @param maxStack the maximum stack size of the method corresponding to\n     *        these code attributes, or -1 if these attributes are not code\n     *        attributes.\n     * @param maxLocals the maximum number of local variables of the method\n     *        corresponding to these code attributes, or -1 if these attributes\n     *        are not code attributes.\n     * @return the size of all the attributes in this attribute list. This size\n     *         includes the size of the attribute headers.\n     */\n    final int getSize(final ClassWriter cw, final byte[] code, final int len, final int maxStack, final int maxLocals) {\n        Attribute attr = this;\n        int size = 0;\n        while (attr != null) {\n            cw.newUTF8(attr.type);\n            size += attr.write(cw, code, len, maxStack, maxLocals).length + 6;\n            attr = attr.next;\n        }\n        return size;\n    }\n\n    /**\n     * Writes all the attributes of this attribute list in the given byte\n     * vector.\n     *\n     * @param cw the class writer to be used to convert the attributes into byte\n     *        arrays, with the {@link #write write} method.\n     * @param code the bytecode of the method corresponding to these code\n     *        attributes, or <tt>null</tt> if these attributes are not code\n     *        attributes.\n     * @param len the length of the bytecode of the method corresponding to\n     *        these code attributes, or <tt>null</tt> if these attributes are\n     *        not code attributes.\n     * @param maxStack the maximum stack size of the method corresponding to\n     *        these code attributes, or -1 if these attributes are not code\n     *        attributes.\n     * @param maxLocals the maximum number of local variables of the method\n     *        corresponding to these code attributes, or -1 if these attributes\n     *        are not code attributes.\n     * @param out where the attributes must be written.\n     */\n    final void put(final ClassWriter cw, final byte[] code, final int len, final int maxStack, final int maxLocals, final ByteVector out) {\n        Attribute attr = this;\n        while (attr != null) {\n            ByteVector b = attr.write(cw, code, len, maxStack, maxLocals);\n            out.putShort(cw.newUTF8(attr.type)).putInt(b.length);\n            out.putByteArray(b.data, 0, b.length);\n            attr = attr.next;\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/AttributeTest0.java",
		"test_prompt": "// AttributeTest0.java\npackage org.objectweb.asm.jip;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Attribute}.\n* It contains ten unit test cases for the {@link Attribute#isUnknown()} method.\n*/\nclass AttributeTest0 {"
	},
	{
		"original_code": "// Attribute.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\n/**\n * A non standard class, field, method or code attribute.\n *\n * @author Eric Bruneton\n * @author Eugene Kuleshov\n */\npublic class Attribute {\n\n    /**\n     * The type of this attribute.\n     */\n    public final String type;\n\n    /**\n     * The raw value of this attribute, used only for unknown attributes.\n     */\n    byte[] value;\n\n    /**\n     * The next attribute in this attribute list. May be <tt>null</tt>.\n     */\n    Attribute next;\n\n    /**\n     * Constructs a new empty attribute.\n     *\n     * @param type the type of the attribute.\n     */\n    protected Attribute(final String type) {\n        this.type = type;\n    }\n\n    /**\n     * Returns <tt>true</tt> if this type of attribute is unknown. The default\n     * implementation of this method always returns <tt>true</tt>.\n     *\n     * @return <tt>true</tt> if this type of attribute is unknown.\n     */\n    public boolean isUnknown() {\n        return true;\n    }\n\n    /**\n     * Returns <tt>true</tt> if this type of attribute is a code attribute.\n     *\n     * @return <tt>true</tt> if this type of attribute is a code attribute.\n     */\n    public boolean isCodeAttribute() {\n        return false;\n    }\n\n    /**\n     * Returns the labels corresponding to this attribute.\n     *\n     * @return the labels corresponding to this attribute, or <tt>null</tt> if\n     *         this attribute is not a code attribute that contains labels.\n     */\n    protected Label[] getLabels() {\n        return null;\n    }\n\n    /**\n     * Reads a {@link #type type} attribute. This method must return a <i>new</i>\n     * {@link Attribute} object, of type {@link #type type}, corresponding to\n     * the <tt>len</tt> bytes starting at the given offset, in the given class\n     * reader.\n     *\n     * @param cr the class that contains the attribute to be read.\n     * @param off index of the first byte of the attribute's content in {@link\n     *        ClassReader#b cr.b}. The 6 attribute header bytes, containing the\n     *        type and the length of the attribute, are not taken into account\n     *        here.\n     * @param len the length of the attribute's content.\n     * @param buf buffer to be used to call\n     *        {@link ClassReader#readUTF8 readUTF8},\n     *        {@link ClassReader#readClass(int,char[]) readClass} or\n     *        {@link ClassReader#readConst readConst}.\n     * @param codeOff index of the first byte of code's attribute content in\n     *        {@link ClassReader#b cr.b}, or -1 if the attribute to be read is\n     *        not a code attribute. The 6 attribute header bytes, containing the\n     *        type and the length of the attribute, are not taken into account\n     *        here.\n     * @param labels the labels of the method's code, or <tt>null</tt> if the\n     *        attribute to be read is not a code attribute.\n     * @return a <i>new</i> {@link Attribute} object corresponding to the given\n     *         bytes.\n     */\n    protected Attribute read(final ClassReader cr, final int off, final int len, final char[] buf, final int codeOff, final Label[] labels) {\n        Attribute attr = new Attribute(type);\n        attr.value = new byte[len];\n        System.arraycopy(cr.b, off, attr.value, 0, len);\n        return attr;\n    }\n\n    /**\n     * Returns the byte array form of this attribute.\n     *\n     * @param cw the class to which this attribute must be added. This parameter\n     *        can be used to add to the constant pool of this class the items\n     *        that corresponds to this attribute.\n     * @param code the bytecode of the method corresponding to this code\n     *        attribute, or <tt>null</tt> if this attribute is not a code\n     *        attributes.\n     * @param len the length of the bytecode of the method corresponding to this\n     *        code attribute, or <tt>null</tt> if this attribute is not a code\n     *        attribute.\n     * @param maxStack the maximum stack size of the method corresponding to\n     *        this code attribute, or -1 if this attribute is not a code\n     *        attribute.\n     * @param maxLocals the maximum number of local variables of the method\n     *        corresponding to this code attribute, or -1 if this attribute is\n     *        not a code attribute.\n     * @return the byte array form of this attribute.\n     */\n    protected ByteVector write(final ClassWriter cw, final byte[] code, final int len, final int maxStack, final int maxLocals) {\n        ByteVector v = new ByteVector();\n        v.data = value;\n        v.length = value.length;\n        return v;\n    }\n\n    /**\n     * Returns the length of the attribute list that begins with this attribute.\n     *\n     * @return the length of the attribute list that begins with this attribute.\n     */\n    final int getCount() {\n        int count = 0;\n        Attribute attr = this;\n        while (attr != null) {\n            count += 1;\n            attr = attr.next;\n        }\n        return count;\n    }\n\n    /**\n     * Returns the size of all the attributes in this attribute list.\n     *\n     * @param cw the class writer to be used to convert the attributes into byte\n     *        arrays, with the {@link #write write} method.\n     * @param code the bytecode of the method corresponding to these code\n     *        attributes, or <tt>null</tt> if these attributes are not code\n     *        attributes.\n     * @param len the length of the bytecode of the method corresponding to\n     *        these code attributes, or <tt>null</tt> if these attributes are\n     *        not code attributes.\n     * @param maxStack the maximum stack size of the method corresponding to\n     *        these code attributes, or -1 if these attributes are not code\n     *        attributes.\n     * @param maxLocals the maximum number of local variables of the method\n     *        corresponding to these code attributes, or -1 if these attributes\n     *        are not code attributes.\n     * @return the size of all the attributes in this attribute list. This size\n     *         includes the size of the attribute headers.\n     */\n    final int getSize(final ClassWriter cw, final byte[] code, final int len, final int maxStack, final int maxLocals) {\n        Attribute attr = this;\n        int size = 0;\n        while (attr != null) {\n            cw.newUTF8(attr.type);\n            size += attr.write(cw, code, len, maxStack, maxLocals).length + 6;\n            attr = attr.next;\n        }\n        return size;\n    }\n\n    /**\n     * Writes all the attributes of this attribute list in the given byte\n     * vector.\n     *\n     * @param cw the class writer to be used to convert the attributes into byte\n     *        arrays, with the {@link #write write} method.\n     * @param code the bytecode of the method corresponding to these code\n     *        attributes, or <tt>null</tt> if these attributes are not code\n     *        attributes.\n     * @param len the length of the bytecode of the method corresponding to\n     *        these code attributes, or <tt>null</tt> if these attributes are\n     *        not code attributes.\n     * @param maxStack the maximum stack size of the method corresponding to\n     *        these code attributes, or -1 if these attributes are not code\n     *        attributes.\n     * @param maxLocals the maximum number of local variables of the method\n     *        corresponding to these code attributes, or -1 if these attributes\n     *        are not code attributes.\n     * @param out where the attributes must be written.\n     */\n    final void put(final ClassWriter cw, final byte[] code, final int len, final int maxStack, final int maxLocals, final ByteVector out) {\n        Attribute attr = this;\n        while (attr != null) {\n            ByteVector b = attr.write(cw, code, len, maxStack, maxLocals);\n            out.putShort(cw.newUTF8(attr.type)).putInt(b.length);\n            out.putByteArray(b.data, 0, b.length);\n            attr = attr.next;\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/AttributeTest1.java",
		"test_prompt": "// AttributeTest1.java\npackage org.objectweb.asm.jip;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Attribute}.\n* It contains ten unit test cases for the {@link Attribute#isCodeAttribute()} method.\n*/\nclass AttributeTest1 {"
	},
	{
		"original_code": "// MethodAdapter.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\n/**\n * An empty {@link MethodVisitor} that delegates to another\n * {@link MethodVisitor}. This class can be used as a super class to quickly\n * implement usefull method adapter classes, just by overriding the necessary\n * methods.\n *\n * @author Eric Bruneton\n */\npublic class MethodAdapter implements MethodVisitor {\n\n    /**\n     * The {@link MethodVisitor} to which this adapter delegates calls.\n     */\n    protected MethodVisitor mv;\n\n    /**\n     * Constructs a new {@link MethodAdapter} object.\n     *\n     * @param mv the code visitor to which this adapter must delegate calls.\n     */\n    public MethodAdapter(final MethodVisitor mv) {\n        this.mv = mv;\n    }\n\n    public AnnotationVisitor visitAnnotationDefault() {\n        return mv.visitAnnotationDefault();\n    }\n\n    public AnnotationVisitor visitAnnotation(final String desc, final boolean visible) {\n        return mv.visitAnnotation(desc, visible);\n    }\n\n    public AnnotationVisitor visitParameterAnnotation(final int parameter, final String desc, final boolean visible) {\n        return mv.visitParameterAnnotation(parameter, desc, visible);\n    }\n\n    public void visitAttribute(final Attribute attr) {\n        mv.visitAttribute(attr);\n    }\n\n    public void visitCode() {\n        mv.visitCode();\n    }\n\n    public void visitFrame(final int type, final int nLocal, final Object[] local, final int nStack, final Object[] stack) {\n        mv.visitFrame(type, nLocal, local, nStack, stack);\n    }\n\n    public void visitInsn(final int opcode) {\n        mv.visitInsn(opcode);\n    }\n\n    public void visitIntInsn(final int opcode, final int operand) {\n        mv.visitIntInsn(opcode, operand);\n    }\n\n    public void visitVarInsn(final int opcode, final int var) {\n        mv.visitVarInsn(opcode, var);\n    }\n\n    public void visitTypeInsn(final int opcode, final String type) {\n        mv.visitTypeInsn(opcode, type);\n    }\n\n    public void visitFieldInsn(final int opcode, final String owner, final String name, final String desc) {\n        mv.visitFieldInsn(opcode, owner, name, desc);\n    }\n\n    public void visitMethodInsn(final int opcode, final String owner, final String name, final String desc) {\n        mv.visitMethodInsn(opcode, owner, name, desc);\n    }\n\n    public void visitJumpInsn(final int opcode, final Label label) {\n        mv.visitJumpInsn(opcode, label);\n    }\n\n    public void visitLabel(final Label label) {\n        mv.visitLabel(label);\n    }\n\n    public void visitLdcInsn(final Object cst) {\n        mv.visitLdcInsn(cst);\n    }\n\n    public void visitIincInsn(final int var, final int increment) {\n        mv.visitIincInsn(var, increment);\n    }\n\n    public void visitTableSwitchInsn(final int min, final int max, final Label dflt, final Label[] labels) {\n        mv.visitTableSwitchInsn(min, max, dflt, labels);\n    }\n\n    public void visitLookupSwitchInsn(final Label dflt, final int[] keys, final Label[] labels) {\n        mv.visitLookupSwitchInsn(dflt, keys, labels);\n    }\n\n    public void visitMultiANewArrayInsn(final String desc, final int dims) {\n        mv.visitMultiANewArrayInsn(desc, dims);\n    }\n\n    public void visitTryCatchBlock(final Label start, final Label end, final Label handler, final String type) {\n        mv.visitTryCatchBlock(start, end, handler, type);\n    }\n\n    public void visitLocalVariable(final String name, final String desc, final String signature, final Label start, final Label end, final int index) {\n        mv.visitLocalVariable(name, desc, signature, start, end, index);\n    }\n\n    public void visitLineNumber(final int line, final Label start) {\n        mv.visitLineNumber(line, start);\n    }\n\n    public void visitMaxs(final int maxStack, final int maxLocals) {\n        mv.visitMaxs(maxStack, maxLocals);\n    }\n\n    public void visitEnd() {\n        mv.visitEnd();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/MethodAdapterTest0.java",
		"test_prompt": "// MethodAdapterTest0.java\npackage org.objectweb.asm.jip;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MethodAdapter}.\n* It contains ten unit test cases for the {@link MethodAdapter#visitAnnotationDefault()} method.\n*/\nclass MethodAdapterTest0 {"
	},
	{
		"original_code": "// MethodAdapter.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\n/**\n * An empty {@link MethodVisitor} that delegates to another\n * {@link MethodVisitor}. This class can be used as a super class to quickly\n * implement usefull method adapter classes, just by overriding the necessary\n * methods.\n *\n * @author Eric Bruneton\n */\npublic class MethodAdapter implements MethodVisitor {\n\n    /**\n     * The {@link MethodVisitor} to which this adapter delegates calls.\n     */\n    protected MethodVisitor mv;\n\n    /**\n     * Constructs a new {@link MethodAdapter} object.\n     *\n     * @param mv the code visitor to which this adapter must delegate calls.\n     */\n    public MethodAdapter(final MethodVisitor mv) {\n        this.mv = mv;\n    }\n\n    public AnnotationVisitor visitAnnotationDefault() {\n        return mv.visitAnnotationDefault();\n    }\n\n    public AnnotationVisitor visitAnnotation(final String desc, final boolean visible) {\n        return mv.visitAnnotation(desc, visible);\n    }\n\n    public AnnotationVisitor visitParameterAnnotation(final int parameter, final String desc, final boolean visible) {\n        return mv.visitParameterAnnotation(parameter, desc, visible);\n    }\n\n    public void visitAttribute(final Attribute attr) {\n        mv.visitAttribute(attr);\n    }\n\n    public void visitCode() {\n        mv.visitCode();\n    }\n\n    public void visitFrame(final int type, final int nLocal, final Object[] local, final int nStack, final Object[] stack) {\n        mv.visitFrame(type, nLocal, local, nStack, stack);\n    }\n\n    public void visitInsn(final int opcode) {\n        mv.visitInsn(opcode);\n    }\n\n    public void visitIntInsn(final int opcode, final int operand) {\n        mv.visitIntInsn(opcode, operand);\n    }\n\n    public void visitVarInsn(final int opcode, final int var) {\n        mv.visitVarInsn(opcode, var);\n    }\n\n    public void visitTypeInsn(final int opcode, final String type) {\n        mv.visitTypeInsn(opcode, type);\n    }\n\n    public void visitFieldInsn(final int opcode, final String owner, final String name, final String desc) {\n        mv.visitFieldInsn(opcode, owner, name, desc);\n    }\n\n    public void visitMethodInsn(final int opcode, final String owner, final String name, final String desc) {\n        mv.visitMethodInsn(opcode, owner, name, desc);\n    }\n\n    public void visitJumpInsn(final int opcode, final Label label) {\n        mv.visitJumpInsn(opcode, label);\n    }\n\n    public void visitLabel(final Label label) {\n        mv.visitLabel(label);\n    }\n\n    public void visitLdcInsn(final Object cst) {\n        mv.visitLdcInsn(cst);\n    }\n\n    public void visitIincInsn(final int var, final int increment) {\n        mv.visitIincInsn(var, increment);\n    }\n\n    public void visitTableSwitchInsn(final int min, final int max, final Label dflt, final Label[] labels) {\n        mv.visitTableSwitchInsn(min, max, dflt, labels);\n    }\n\n    public void visitLookupSwitchInsn(final Label dflt, final int[] keys, final Label[] labels) {\n        mv.visitLookupSwitchInsn(dflt, keys, labels);\n    }\n\n    public void visitMultiANewArrayInsn(final String desc, final int dims) {\n        mv.visitMultiANewArrayInsn(desc, dims);\n    }\n\n    public void visitTryCatchBlock(final Label start, final Label end, final Label handler, final String type) {\n        mv.visitTryCatchBlock(start, end, handler, type);\n    }\n\n    public void visitLocalVariable(final String name, final String desc, final String signature, final Label start, final Label end, final int index) {\n        mv.visitLocalVariable(name, desc, signature, start, end, index);\n    }\n\n    public void visitLineNumber(final int line, final Label start) {\n        mv.visitLineNumber(line, start);\n    }\n\n    public void visitMaxs(final int maxStack, final int maxLocals) {\n        mv.visitMaxs(maxStack, maxLocals);\n    }\n\n    public void visitEnd() {\n        mv.visitEnd();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/MethodAdapterTest1.java",
		"test_prompt": "// MethodAdapterTest1.java\npackage org.objectweb.asm.jip;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MethodAdapter}.\n* It contains ten unit test cases for the {@link MethodAdapter#visitAnnotation(String, boolean)} method.\n*/\nclass MethodAdapterTest1 {"
	},
	{
		"original_code": "// MethodAdapter.java\n/**\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2007 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.objectweb.asm.jip;\n\n/**\n * An empty {@link MethodVisitor} that delegates to another\n * {@link MethodVisitor}. This class can be used as a super class to quickly\n * implement usefull method adapter classes, just by overriding the necessary\n * methods.\n *\n * @author Eric Bruneton\n */\npublic class MethodAdapter implements MethodVisitor {\n\n    /**\n     * The {@link MethodVisitor} to which this adapter delegates calls.\n     */\n    protected MethodVisitor mv;\n\n    /**\n     * Constructs a new {@link MethodAdapter} object.\n     *\n     * @param mv the code visitor to which this adapter must delegate calls.\n     */\n    public MethodAdapter(final MethodVisitor mv) {\n        this.mv = mv;\n    }\n\n    public AnnotationVisitor visitAnnotationDefault() {\n        return mv.visitAnnotationDefault();\n    }\n\n    public AnnotationVisitor visitAnnotation(final String desc, final boolean visible) {\n        return mv.visitAnnotation(desc, visible);\n    }\n\n    public AnnotationVisitor visitParameterAnnotation(final int parameter, final String desc, final boolean visible) {\n        return mv.visitParameterAnnotation(parameter, desc, visible);\n    }\n\n    public void visitAttribute(final Attribute attr) {\n        mv.visitAttribute(attr);\n    }\n\n    public void visitCode() {\n        mv.visitCode();\n    }\n\n    public void visitFrame(final int type, final int nLocal, final Object[] local, final int nStack, final Object[] stack) {\n        mv.visitFrame(type, nLocal, local, nStack, stack);\n    }\n\n    public void visitInsn(final int opcode) {\n        mv.visitInsn(opcode);\n    }\n\n    public void visitIntInsn(final int opcode, final int operand) {\n        mv.visitIntInsn(opcode, operand);\n    }\n\n    public void visitVarInsn(final int opcode, final int var) {\n        mv.visitVarInsn(opcode, var);\n    }\n\n    public void visitTypeInsn(final int opcode, final String type) {\n        mv.visitTypeInsn(opcode, type);\n    }\n\n    public void visitFieldInsn(final int opcode, final String owner, final String name, final String desc) {\n        mv.visitFieldInsn(opcode, owner, name, desc);\n    }\n\n    public void visitMethodInsn(final int opcode, final String owner, final String name, final String desc) {\n        mv.visitMethodInsn(opcode, owner, name, desc);\n    }\n\n    public void visitJumpInsn(final int opcode, final Label label) {\n        mv.visitJumpInsn(opcode, label);\n    }\n\n    public void visitLabel(final Label label) {\n        mv.visitLabel(label);\n    }\n\n    public void visitLdcInsn(final Object cst) {\n        mv.visitLdcInsn(cst);\n    }\n\n    public void visitIincInsn(final int var, final int increment) {\n        mv.visitIincInsn(var, increment);\n    }\n\n    public void visitTableSwitchInsn(final int min, final int max, final Label dflt, final Label[] labels) {\n        mv.visitTableSwitchInsn(min, max, dflt, labels);\n    }\n\n    public void visitLookupSwitchInsn(final Label dflt, final int[] keys, final Label[] labels) {\n        mv.visitLookupSwitchInsn(dflt, keys, labels);\n    }\n\n    public void visitMultiANewArrayInsn(final String desc, final int dims) {\n        mv.visitMultiANewArrayInsn(desc, dims);\n    }\n\n    public void visitTryCatchBlock(final Label start, final Label end, final Label handler, final String type) {\n        mv.visitTryCatchBlock(start, end, handler, type);\n    }\n\n    public void visitLocalVariable(final String name, final String desc, final String signature, final Label start, final Label end, final int index) {\n        mv.visitLocalVariable(name, desc, signature, start, end, index);\n    }\n\n    public void visitLineNumber(final int line, final Label start) {\n        mv.visitLineNumber(line, start);\n    }\n\n    public void visitMaxs(final int maxStack, final int maxLocals) {\n        mv.visitMaxs(maxStack, maxLocals);\n    }\n\n    public void visitEnd() {\n        mv.visitEnd();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/org/objectweb/asm/jip/MethodAdapterTest2.java",
		"test_prompt": "// MethodAdapterTest2.java\npackage org.objectweb.asm.jip;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MethodAdapter}.\n* It contains ten unit test cases for the {@link MethodAdapter#visitParameterAnnotation(int, String, boolean)} method.\n*/\nclass MethodAdapterTest2 {"
	},
	{
		"original_code": "// PerfClassAdapter.java\n/*\nCopyright (c) 2005, MentorGen, LLC\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions are met:\n\n+ Redistributions of source code must retain the above copyright notice, \n  this list of conditions and the following disclaimer.\n+ Redistributions in binary form must reproduce the above copyright notice, \n  this list of conditions and the following disclaimer in the documentation \n  and/or other materials provided with the distribution.\n+ Neither the name of MentorGen LLC nor the names of its contributors may be \n  used to endorse or promote products derived from this software without \n  specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \n  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE \n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \n  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \n  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \n  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n  POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.mentorgen.tools.profile.instrument;\n\nimport org.objectweb.asm.jip.ClassAdapter;\nimport org.objectweb.asm.jip.ClassVisitor;\nimport org.objectweb.asm.jip.MethodVisitor;\nimport com.mentorgen.tools.profile.Controller;\n\n/**\n * @author Andrew Wilcox\n * @see org.objectweb.asm.jip.ClassAdapter\n */\npublic class PerfClassAdapter extends ClassAdapter {\n\n    private String className;\n\n    public PerfClassAdapter(ClassVisitor visitor, String theClass) {\n        super(visitor);\n        this.className = theClass;\n    }\n\n    public MethodVisitor visitMethod(int arg, String name, String descriptor, String signature, String[] exceptions) {\n        MethodVisitor mv = super.visitMethod(arg, name, descriptor, signature, exceptions);\n        if (Controller._outputMethodSignatures && descriptor != null) {\n            return new PerfMethodAdapter(mv, className, name + descriptor);\n        } else {\n            return new PerfMethodAdapter(mv, className, name);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/com/mentorgen/tools/profile/instrument/PerfClassAdapterTest.java",
		"test_prompt": "// PerfClassAdapterTest.java\npackage com.mentorgen.tools.profile.instrument;\n\nimport org.objectweb.asm.jip.ClassAdapter;\nimport org.objectweb.asm.jip.ClassVisitor;\nimport org.objectweb.asm.jip.MethodVisitor;\nimport com.mentorgen.tools.profile.Controller;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PerfClassAdapter}.\n* It contains ten unit test cases for the {@link PerfClassAdapter#visitMethod(int, String, String, String, String[])} method.\n*/\nclass PerfClassAdapterTest {"
	},
	{
		"original_code": "// WebAppClassLoaderFilter.java\n/*\nCopyright (c) 2005, MentorGen, LLC\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions are met:\n\n+ Redistributions of source code must retain the above copyright notice, \n  this list of conditions and the following disclaimer.\n+ Redistributions in binary form must reproduce the above copyright notice, \n  this list of conditions and the following disclaimer in the documentation \n  and/or other materials provided with the distribution.\n+ Neither the name of MentorGen LLC nor the names of its contributors may be \n  used to endorse or promote products derived from this software without \n  specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \n  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE \n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \n  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \n  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \n  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n  POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.mentorgen.tools.profile.instrument.clfilter;\n\n/**\n * A filter that accepts classes that are loaded by Tomcat's\n * web app class loader (this has only been tested with Tomcat 5.5.x)\n *\n * @author Andrew Wilcox\n * @see com.mentorgen.tools.profile.instrument.clfilter.ClassLoaderFilter\n */\npublic class WebAppClassLoaderFilter implements ClassLoaderFilter {\n\n    private static final String CLASSLOADER = \"org.apache.catalina.loader.WebappClassLoader\";\n\n    public boolean canFilter() {\n        return System.getProperty(\"catalina.home\") != null;\n    }\n\n    public boolean accept(ClassLoader loader) {\n        return loader.getClass().getName().equals(CLASSLOADER);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/com/mentorgen/tools/profile/instrument/clfilter/WebAppClassLoaderFilterTest0.java",
		"test_prompt": "// WebAppClassLoaderFilterTest0.java\npackage com.mentorgen.tools.profile.instrument.clfilter;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link WebAppClassLoaderFilter}.\n* It contains ten unit test cases for the {@link WebAppClassLoaderFilter#canFilter()} method.\n*/\nclass WebAppClassLoaderFilterTest0 {"
	},
	{
		"original_code": "// WebAppClassLoaderFilter.java\n/*\nCopyright (c) 2005, MentorGen, LLC\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions are met:\n\n+ Redistributions of source code must retain the above copyright notice, \n  this list of conditions and the following disclaimer.\n+ Redistributions in binary form must reproduce the above copyright notice, \n  this list of conditions and the following disclaimer in the documentation \n  and/or other materials provided with the distribution.\n+ Neither the name of MentorGen LLC nor the names of its contributors may be \n  used to endorse or promote products derived from this software without \n  specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \n  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE \n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \n  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \n  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \n  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n  POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.mentorgen.tools.profile.instrument.clfilter;\n\n/**\n * A filter that accepts classes that are loaded by Tomcat's\n * web app class loader (this has only been tested with Tomcat 5.5.x)\n *\n * @author Andrew Wilcox\n * @see com.mentorgen.tools.profile.instrument.clfilter.ClassLoaderFilter\n */\npublic class WebAppClassLoaderFilter implements ClassLoaderFilter {\n\n    private static final String CLASSLOADER = \"org.apache.catalina.loader.WebappClassLoader\";\n\n    public boolean canFilter() {\n        return System.getProperty(\"catalina.home\") != null;\n    }\n\n    public boolean accept(ClassLoader loader) {\n        return loader.getClass().getName().equals(CLASSLOADER);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/com/mentorgen/tools/profile/instrument/clfilter/WebAppClassLoaderFilterTest1.java",
		"test_prompt": "// WebAppClassLoaderFilterTest1.java\npackage com.mentorgen.tools.profile.instrument.clfilter;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link WebAppClassLoaderFilter}.\n* It contains ten unit test cases for the {@link WebAppClassLoaderFilter#accept(ClassLoader)} method.\n*/\nclass WebAppClassLoaderFilterTest1 {"
	},
	{
		"original_code": "// TomcatInternalClassLoaderFilter.java\npackage com.mentorgen.tools.profile.instrument.clfilter;\n\npublic class TomcatInternalClassLoaderFilter implements ClassLoaderFilter {\n\n    private static final String CLASSLOADER = \"org.apache.catalina.loader.StandardClassLoader\";\n\n    public boolean accept(ClassLoader loader) {\n        return loader.getClass().getName().equals(CLASSLOADER);\n    }\n\n    public boolean canFilter() {\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/com/mentorgen/tools/profile/instrument/clfilter/TomcatInternalClassLoaderFilterTest0.java",
		"test_prompt": "// TomcatInternalClassLoaderFilterTest0.java\npackage com.mentorgen.tools.profile.instrument.clfilter;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TomcatInternalClassLoaderFilter}.\n* It contains ten unit test cases for the {@link TomcatInternalClassLoaderFilter#accept(ClassLoader)} method.\n*/\nclass TomcatInternalClassLoaderFilterTest0 {"
	},
	{
		"original_code": "// TomcatInternalClassLoaderFilter.java\npackage com.mentorgen.tools.profile.instrument.clfilter;\n\npublic class TomcatInternalClassLoaderFilter implements ClassLoaderFilter {\n\n    private static final String CLASSLOADER = \"org.apache.catalina.loader.StandardClassLoader\";\n\n    public boolean accept(ClassLoader loader) {\n        return loader.getClass().getName().equals(CLASSLOADER);\n    }\n\n    public boolean canFilter() {\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/com/mentorgen/tools/profile/instrument/clfilter/TomcatInternalClassLoaderFilterTest1.java",
		"test_prompt": "// TomcatInternalClassLoaderFilterTest1.java\npackage com.mentorgen.tools.profile.instrument.clfilter;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TomcatInternalClassLoaderFilter}.\n* It contains ten unit test cases for the {@link TomcatInternalClassLoaderFilter#canFilter()} method.\n*/\nclass TomcatInternalClassLoaderFilterTest1 {"
	},
	{
		"original_code": "// ExtensionsClassLoaderFilter.java\n/*\nCopyright (c) 2005, MentorGen, LLC\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions are met:\n\n+ Redistributions of source code must retain the above copyright notice, \n  this list of conditions and the following disclaimer.\n+ Redistributions in binary form must reproduce the above copyright notice, \n  this list of conditions and the following disclaimer in the documentation \n  and/or other materials provided with the distribution.\n+ Neither the name of MentorGen LLC nor the names of its contributors may be \n  used to endorse or promote products derived from this software without \n  specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \n  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE \n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \n  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \n  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \n  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n  POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.mentorgen.tools.profile.instrument.clfilter;\n\n/**\n * This Filter accepts classes that are loaded by the standard and extensions\n * classloader.\n *\n * @author Andrew Wilcox\n * @see com.mentorgen.tools.profile.instrument.clfilter.ClassLoaderFilter\n */\npublic class ExtensionsClassLoaderFilter implements ClassLoaderFilter {\n\n    public boolean canFilter() {\n        return true;\n    }\n\n    public boolean accept(ClassLoader loader) {\n        return loader == ClassLoader.getSystemClassLoader() || loader == ClassLoader.getSystemClassLoader().getParent();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/com/mentorgen/tools/profile/instrument/clfilter/ExtensionsClassLoaderFilterTest0.java",
		"test_prompt": "// ExtensionsClassLoaderFilterTest0.java\npackage com.mentorgen.tools.profile.instrument.clfilter;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ExtensionsClassLoaderFilter}.\n* It contains ten unit test cases for the {@link ExtensionsClassLoaderFilter#canFilter()} method.\n*/\nclass ExtensionsClassLoaderFilterTest0 {"
	},
	{
		"original_code": "// ExtensionsClassLoaderFilter.java\n/*\nCopyright (c) 2005, MentorGen, LLC\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions are met:\n\n+ Redistributions of source code must retain the above copyright notice, \n  this list of conditions and the following disclaimer.\n+ Redistributions in binary form must reproduce the above copyright notice, \n  this list of conditions and the following disclaimer in the documentation \n  and/or other materials provided with the distribution.\n+ Neither the name of MentorGen LLC nor the names of its contributors may be \n  used to endorse or promote products derived from this software without \n  specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \n  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE \n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \n  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \n  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \n  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n  POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.mentorgen.tools.profile.instrument.clfilter;\n\n/**\n * This Filter accepts classes that are loaded by the standard and extensions\n * classloader.\n *\n * @author Andrew Wilcox\n * @see com.mentorgen.tools.profile.instrument.clfilter.ClassLoaderFilter\n */\npublic class ExtensionsClassLoaderFilter implements ClassLoaderFilter {\n\n    public boolean canFilter() {\n        return true;\n    }\n\n    public boolean accept(ClassLoader loader) {\n        return loader == ClassLoader.getSystemClassLoader() || loader == ClassLoader.getSystemClassLoader().getParent();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/com/mentorgen/tools/profile/instrument/clfilter/ExtensionsClassLoaderFilterTest1.java",
		"test_prompt": "// ExtensionsClassLoaderFilterTest1.java\npackage com.mentorgen.tools.profile.instrument.clfilter;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ExtensionsClassLoaderFilter}.\n* It contains ten unit test cases for the {@link ExtensionsClassLoaderFilter#accept(ClassLoader)} method.\n*/\nclass ExtensionsClassLoaderFilterTest1 {"
	},
	{
		"original_code": "// AntTaskClassLoaderFilter.java\n/*\nCopyright (c) 2006, \nPaul Hudson (paulhu@users.sourceforge.net),\nAndrew Wilcox (andrewbwilcox@users.sourceforge.net)\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions are met:\n\n+ Redistributions of source code must retain the above copyright notice, \n  this list of conditions and the following disclaimer.\n+ Redistributions in binary form must reproduce the above copyright notice, \n  this list of conditions and the following disclaimer in the documentation \n  and/or other materials provided with the distribution.\n+ Neither the name of MentorGen LLC nor the names of its contributors may be \n  used to endorse or promote products derived from this software without \n  specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \n  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE \n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \n  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \n  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \n  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n  POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.mentorgen.tools.profile.instrument.clfilter;\n\n/**\n * @author andrewwilcox\n * @author Paul Hudson\n */\npublic class AntTaskClassLoaderFilter {\n\n    private static final String CLASSLOADER = \"org.apache.tools.ant.loader.AntClassLoader2\";\n\n    public boolean canFilter() {\n        return true;\n    }\n\n    public boolean accept(ClassLoader loader) {\n        return loader.getClass().getName().equals(CLASSLOADER);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/com/mentorgen/tools/profile/instrument/clfilter/AntTaskClassLoaderFilterTest0.java",
		"test_prompt": "// AntTaskClassLoaderFilterTest0.java\npackage com.mentorgen.tools.profile.instrument.clfilter;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AntTaskClassLoaderFilter}.\n* It contains ten unit test cases for the {@link AntTaskClassLoaderFilter#canFilter()} method.\n*/\nclass AntTaskClassLoaderFilterTest0 {"
	},
	{
		"original_code": "// AntTaskClassLoaderFilter.java\n/*\nCopyright (c) 2006, \nPaul Hudson (paulhu@users.sourceforge.net),\nAndrew Wilcox (andrewbwilcox@users.sourceforge.net)\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions are met:\n\n+ Redistributions of source code must retain the above copyright notice, \n  this list of conditions and the following disclaimer.\n+ Redistributions in binary form must reproduce the above copyright notice, \n  this list of conditions and the following disclaimer in the documentation \n  and/or other materials provided with the distribution.\n+ Neither the name of MentorGen LLC nor the names of its contributors may be \n  used to endorse or promote products derived from this software without \n  specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \n  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE \n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \n  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \n  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \n  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n  POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.mentorgen.tools.profile.instrument.clfilter;\n\n/**\n * @author andrewwilcox\n * @author Paul Hudson\n */\npublic class AntTaskClassLoaderFilter {\n\n    private static final String CLASSLOADER = \"org.apache.tools.ant.loader.AntClassLoader2\";\n\n    public boolean canFilter() {\n        return true;\n    }\n\n    public boolean accept(ClassLoader loader) {\n        return loader.getClass().getName().equals(CLASSLOADER);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/com/mentorgen/tools/profile/instrument/clfilter/AntTaskClassLoaderFilterTest1.java",
		"test_prompt": "// AntTaskClassLoaderFilterTest1.java\npackage com.mentorgen.tools.profile.instrument.clfilter;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AntTaskClassLoaderFilter}.\n* It contains ten unit test cases for the {@link AntTaskClassLoaderFilter#accept(ClassLoader)} method.\n*/\nclass AntTaskClassLoaderFilterTest1 {"
	},
	{
		"original_code": "// CustomMultiClassLoaderFilter.java\npackage com.mentorgen.tools.profile.instrument.clfilter;\n\nimport com.mentorgen.tools.profile.Controller;\nimport com.mentorgen.tools.profile.instrument.clfilter.ClassLoaderFilter;\n\npublic class CustomMultiClassLoaderFilter implements ClassLoaderFilter {\n\n    public boolean canFilter() {\n        return true;\n    }\n\n    public boolean accept(ClassLoader loader) {\n        for (String TheClassLoaderName : Controller._acceptClassLoadersByName) {\n            if (loader.getClass().getName().equals(TheClassLoaderName)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/com/mentorgen/tools/profile/instrument/clfilter/CustomMultiClassLoaderFilterTest0.java",
		"test_prompt": "// CustomMultiClassLoaderFilterTest0.java\npackage com.mentorgen.tools.profile.instrument.clfilter;\n\nimport com.mentorgen.tools.profile.Controller;\nimport com.mentorgen.tools.profile.instrument.clfilter.ClassLoaderFilter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CustomMultiClassLoaderFilter}.\n* It contains ten unit test cases for the {@link CustomMultiClassLoaderFilter#canFilter()} method.\n*/\nclass CustomMultiClassLoaderFilterTest0 {"
	},
	{
		"original_code": "// CustomMultiClassLoaderFilter.java\npackage com.mentorgen.tools.profile.instrument.clfilter;\n\nimport com.mentorgen.tools.profile.Controller;\nimport com.mentorgen.tools.profile.instrument.clfilter.ClassLoaderFilter;\n\npublic class CustomMultiClassLoaderFilter implements ClassLoaderFilter {\n\n    public boolean canFilter() {\n        return true;\n    }\n\n    public boolean accept(ClassLoader loader) {\n        for (String TheClassLoaderName : Controller._acceptClassLoadersByName) {\n            if (loader.getClass().getName().equals(TheClassLoaderName)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/com/mentorgen/tools/profile/instrument/clfilter/CustomMultiClassLoaderFilterTest1.java",
		"test_prompt": "// CustomMultiClassLoaderFilterTest1.java\npackage com.mentorgen.tools.profile.instrument.clfilter;\n\nimport com.mentorgen.tools.profile.Controller;\nimport com.mentorgen.tools.profile.instrument.clfilter.ClassLoaderFilter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CustomMultiClassLoaderFilter}.\n* It contains ten unit test cases for the {@link CustomMultiClassLoaderFilter#accept(ClassLoader)} method.\n*/\nclass CustomMultiClassLoaderFilterTest1 {"
	},
	{
		"original_code": "// JettyClassLoaderFilter.java\n/*\nCopyright (c) 2008,  Itai Zukerman\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions are met:\n\n+ Redistributions of source code must retain the above copyright notice, \n  this list of conditions and the following disclaimer.\n+ Redistributions in binary form must reproduce the above copyright notice, \n  this list of conditions and the following disclaimer in the documentation \n  and/or other materials provided with the distribution.\n+ Neither the name of MentorGen LLC nor the names of its contributors may be \n  used to endorse or promote products derived from this software without \n  specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \n  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE \n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \n  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \n  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \n  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n  POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.mentorgen.tools.profile.instrument.clfilter;\n\npublic class JettyClassLoaderFilter implements ClassLoaderFilter {\n\n    public boolean canFilter() {\n        return true;\n    }\n\n    public boolean accept(ClassLoader loader) {\n        return loader.getClass().getName().equals(\"org.mortbay.jetty.webapp.WebAppClassLoader\");\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/com/mentorgen/tools/profile/instrument/clfilter/JettyClassLoaderFilterTest0.java",
		"test_prompt": "// JettyClassLoaderFilterTest0.java\npackage com.mentorgen.tools.profile.instrument.clfilter;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JettyClassLoaderFilter}.\n* It contains ten unit test cases for the {@link JettyClassLoaderFilter#canFilter()} method.\n*/\nclass JettyClassLoaderFilterTest0 {"
	},
	{
		"original_code": "// JettyClassLoaderFilter.java\n/*\nCopyright (c) 2008,  Itai Zukerman\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions are met:\n\n+ Redistributions of source code must retain the above copyright notice, \n  this list of conditions and the following disclaimer.\n+ Redistributions in binary form must reproduce the above copyright notice, \n  this list of conditions and the following disclaimer in the documentation \n  and/or other materials provided with the distribution.\n+ Neither the name of MentorGen LLC nor the names of its contributors may be \n  used to endorse or promote products derived from this software without \n  specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \n  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE \n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \n  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \n  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \n  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n  POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.mentorgen.tools.profile.instrument.clfilter;\n\npublic class JettyClassLoaderFilter implements ClassLoaderFilter {\n\n    public boolean canFilter() {\n        return true;\n    }\n\n    public boolean accept(ClassLoader loader) {\n        return loader.getClass().getName().equals(\"org.mortbay.jetty.webapp.WebAppClassLoader\");\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/com/mentorgen/tools/profile/instrument/clfilter/JettyClassLoaderFilterTest1.java",
		"test_prompt": "// JettyClassLoaderFilterTest1.java\npackage com.mentorgen.tools.profile.instrument.clfilter;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JettyClassLoaderFilter}.\n* It contains ten unit test cases for the {@link JettyClassLoaderFilter#accept(ClassLoader)} method.\n*/\nclass JettyClassLoaderFilterTest1 {"
	},
	{
		"original_code": "// StandardClassLoaderFilter.java\n/*\nCopyright (c) 2005, MentorGen, LLC\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions are met:\n\n+ Redistributions of source code must retain the above copyright notice, \n  this list of conditions and the following disclaimer.\n+ Redistributions in binary form must reproduce the above copyright notice, \n  this list of conditions and the following disclaimer in the documentation \n  and/or other materials provided with the distribution.\n+ Neither the name of MentorGen LLC nor the names of its contributors may be \n  used to endorse or promote products derived from this software without \n  specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \n  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE \n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \n  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \n  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \n  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n  POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.mentorgen.tools.profile.instrument.clfilter;\n\n/**\n * The filter for standalone applications.\n *\n * @author Andrew Wilcox\n * @see com.mentorgen.tools.profile.instrument.clfilter.ClassLoaderFilter\n */\npublic class StandardClassLoaderFilter implements ClassLoaderFilter {\n\n    public boolean canFilter() {\n        return true;\n    }\n\n    public boolean accept(ClassLoader loader) {\n        return loader == ClassLoader.getSystemClassLoader();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/com/mentorgen/tools/profile/instrument/clfilter/StandardClassLoaderFilterTest0.java",
		"test_prompt": "// StandardClassLoaderFilterTest0.java\npackage com.mentorgen.tools.profile.instrument.clfilter;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StandardClassLoaderFilter}.\n* It contains ten unit test cases for the {@link StandardClassLoaderFilter#canFilter()} method.\n*/\nclass StandardClassLoaderFilterTest0 {"
	},
	{
		"original_code": "// StandardClassLoaderFilter.java\n/*\nCopyright (c) 2005, MentorGen, LLC\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions are met:\n\n+ Redistributions of source code must retain the above copyright notice, \n  this list of conditions and the following disclaimer.\n+ Redistributions in binary form must reproduce the above copyright notice, \n  this list of conditions and the following disclaimer in the documentation \n  and/or other materials provided with the distribution.\n+ Neither the name of MentorGen LLC nor the names of its contributors may be \n  used to endorse or promote products derived from this software without \n  specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \n  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE \n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \n  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \n  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \n  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n  POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.mentorgen.tools.profile.instrument.clfilter;\n\n/**\n * The filter for standalone applications.\n *\n * @author Andrew Wilcox\n * @see com.mentorgen.tools.profile.instrument.clfilter.ClassLoaderFilter\n */\npublic class StandardClassLoaderFilter implements ClassLoaderFilter {\n\n    public boolean canFilter() {\n        return true;\n    }\n\n    public boolean accept(ClassLoader loader) {\n        return loader == ClassLoader.getSystemClassLoader();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/com/mentorgen/tools/profile/instrument/clfilter/StandardClassLoaderFilterTest1.java",
		"test_prompt": "// StandardClassLoaderFilterTest1.java\npackage com.mentorgen.tools.profile.instrument.clfilter;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StandardClassLoaderFilter}.\n* It contains ten unit test cases for the {@link StandardClassLoaderFilter#accept(ClassLoader)} method.\n*/\nclass StandardClassLoaderFilterTest1 {"
	},
	{
		"original_code": "// Transformer.java\n/*\nCopyright (c) 2005, MentorGen, LLC\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions are met:\n\n+ Redistributions of source code must retain the above copyright notice, \n  this list of conditions and the following disclaimer.\n+ Redistributions in binary form must reproduce the above copyright notice, \n  this list of conditions and the following disclaimer in the documentation \n  and/or other materials provided with the distribution.\n+ Neither the name of MentorGen LLC nor the names of its contributors may be \n  used to endorse or promote products derived from this software without \n  specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \n  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE \n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \n  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \n  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \n  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n  POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.mentorgen.tools.profile.instrument;\n\nimport java.lang.instrument.ClassFileTransformer;\nimport java.lang.instrument.IllegalClassFormatException;\nimport java.security.ProtectionDomain;\nimport org.objectweb.asm.jip.ClassAdapter;\nimport org.objectweb.asm.jip.ClassReader;\nimport org.objectweb.asm.jip.ClassWriter;\nimport com.mentorgen.tools.profile.Controller;\n\n/**\n * This class determines if a given class should be instrumented\n * with profiling code or not. The property <code>debug</code>, when\n * set to <code>on</code>, will show you which classes are being instrumented\n * and what ones are not.\n *\n * @author Andrew Wilcox\n * @see java.lang.instrument.ClassFileTransformer\n */\npublic class Transformer implements ClassFileTransformer {\n\n    public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {\n        // can't profile yourself\n        //\n        if (className.startsWith(\"com/mentorgen/tools/profile\") || className.startsWith(\"net/sourceforge/jiprof\")) {\n            return classfileBuffer;\n        }\n        // include\n        //\n        if (Controller._includeList.length > 0) {\n            boolean toInclude = false;\n            for (String include : Controller._includeList) {\n                if (className.startsWith(include)) {\n                    toInclude = true;\n                    break;\n                }\n            }\n            if (!toInclude) {\n                if (Controller._debug) {\n                    debug(loader, className, false);\n                }\n                return classfileBuffer;\n            }\n        }\n        if (!Controller._filter.accept(loader)) {\n            if (Controller._debug) {\n                debug(loader, className, false);\n            }\n            return classfileBuffer;\n        }\n        // exclude\n        //\n        for (String exclude : Controller._excludeList) {\n            if (className.startsWith(exclude)) {\n                if (Controller._debug) {\n                    debug(loader, className, false);\n                }\n                return classfileBuffer;\n            }\n        }\n        byte[] result = classfileBuffer;\n        try {\n            if (Controller._debug) {\n                debug(loader, className, true);\n            }\n            Controller._instrumentCount++;\n            ClassReader reader = new ClassReader(classfileBuffer);\n            ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n            ClassAdapter adapter = new PerfClassAdapter(writer, className);\n            reader.accept(adapter, ClassReader.SKIP_DEBUG);\n            result = writer.toByteArray();\n        } catch (Throwable t) {\n            t.printStackTrace();\n            throw new RuntimeException(t);\n        }\n        return result;\n    }\n\n    private void debug(ClassLoader loader, String className, boolean transformed) {\n        StringBuffer b = new StringBuffer();\n        if (transformed) {\n            b.append(\"INST\");\n        } else {\n            b.append(\"skip\");\n        }\n        b.append(\"\\t\");\n        b.append(className);\n        b.append(\"\\t\");\n        b.append(\"[\");\n        b.append(loader.getClass().getName());\n        b.append(\"]\");\n        System.out.println(b.toString());\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/com/mentorgen/tools/profile/instrument/TransformerTest.java",
		"test_prompt": "// TransformerTest.java\npackage com.mentorgen.tools.profile.instrument;\n\nimport java.lang.instrument.ClassFileTransformer;\nimport java.lang.instrument.IllegalClassFormatException;\nimport java.security.ProtectionDomain;\nimport org.objectweb.asm.jip.ClassAdapter;\nimport org.objectweb.asm.jip.ClassReader;\nimport org.objectweb.asm.jip.ClassWriter;\nimport com.mentorgen.tools.profile.Controller;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Transformer}.\n* It contains ten unit test cases for the {@link Transformer#transform(ClassLoader, String, Class, ProtectionDomain, byte[])} method.\n*/\nclass TransformerTest {"
	},
	{
		"original_code": "// Profile.java\n/*\nCopyright (c) 2005-2006, MentorGen, LLC\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions are met:\n\n+ Redistributions of source code must retain the above copyright notice, \n  this list of conditions and the following disclaimer.\n+ Redistributions in binary form must reproduce the above copyright notice, \n  this list of conditions and the following disclaimer in the documentation \n  and/or other materials provided with the distribution.\n+ Neither the name of MentorGen LLC nor the names of its contributors may be \n  used to endorse or promote products derived from this software without \n  specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \n  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE \n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \n  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \n  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \n  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n  POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.mentorgen.tools.profile.runtime;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport com.mentorgen.tools.profile.Controller;\nimport com.mentorgen.tools.profile.output.ProfileDump;\n\n/**\n * The <code>Profiler</code> is the class that actually profiles the code.\n * Code to be profiled is instrumented, when the byte code is loaded,\n * to make calls to this class:\n * <ul>\n * \t<li>At the beginning of each method (calls <code>Profiler.start()</cdoe>)</li>\n * \t<li>At the end of each method (that is, when return is called, which\n * \t\tmight not actaully be at the end of the method)\n * \t\t(calls <code>Profiler.end()</cdoe>)</li>\n * \t<li>When an exception is thrown (also calls <code>Profiler.end()</cdoe>)</li>\n * \t<li>Each time a constructor is called (optional)</li>\n * </ul>\n *\n * <blockquote>\n * Note: Instrumenting code can interfer with line numbers that are added to\n * the code for debugging. If you are debugging code and your stack traces\n * don't have line numbers, don't use the profiler (ie, don't use <code>\n * -javaagent)</code>\n * </blockquote>\n *\n * @author Andrew Wilcox\n */\npublic final class Profile implements Runnable {\n\n    private static boolean _debugStart = false;\n\n    private static boolean _debugException = false;\n\n    private static ThreadDictionary _threadDictionary;\n\n    private static List<Frame> _frameList;\n\n    private static Map<Long, Frame> _threadActiveFrame;\n\n    private static Map<String, Method> _methodDictionary;\n\n    private static Object _lock;\n\n    private static Map<String, ClassAllocation> _allocList;\n\n    private static Controller _controller;\n\n    private static Thread _controllerThread;\n\n    public static void initProfiler() {\n        System.err.println(\"Java Interactive Profiler: starting\");\n        init();\n        Runtime.getRuntime().addShutdownHook(new Thread(new Profile()));\n        _controller = new Controller();\n        if (Controller._remote) {\n            _controllerThread = new Thread(_controller);\n            _controllerThread.start();\n        }\n    }\n\n    public static void init() {\n        _threadActiveFrame = new HashMap<Long, Frame>(1001);\n        _threadDictionary = new ThreadDictionary();\n        _methodDictionary = new HashMap<String, Method>(2003);\n        _frameList = new ArrayList<Frame>(1001);\n        _lock = new Object();\n        _allocList = new HashMap<String, ClassAllocation>();\n    }\n\n    //\n    // Methods to programatically manipulate the Profiler\n    //\n    public static void clear() {\n        init();\n    }\n\n    public static void start() {\n        _controller.start();\n    }\n\n    public static void stop() {\n        _controller.stop();\n    }\n\n    public static void setFileName(String fileName) {\n        _controller.setFileName(fileName);\n    }\n\n    public static void shutdown() {\n        synchronized (_lock) {\n            Controller._profile = false;\n            for (Long threadId : _threadDictionary.keySet()) {\n                Frame f = _threadDictionary.getMostRecentFrame(threadId);\n                f.close();\n            }\n            for (Frame frame : frameList()) {\n                frame.computeNetTime();\n            }\n        }\n        // synchronized\n    }\n\n    //\n    // Methods called when generating output\n    //\n    public static Iterable<Long> threads() {\n        return _threadDictionary.threads();\n    }\n\n    public static Iterable<Frame> interactions(long threadId) {\n        return _threadDictionary.interactions((threadId));\n    }\n\n    public static Iterable<Frame> frameList() {\n        return _frameList;\n    }\n\n    public static Iterable<ClassAllocation> allocations() {\n        return _allocList.values();\n    }\n\n    public static long getThreadTotalTime(long threadId) {\n        return _threadDictionary.getThreadTotalTime(threadId);\n    }\n\n    public static void sortFrameList(Comparator<Frame> comp) {\n        synchronized (_lock) {\n            Collections.sort(_frameList, comp);\n        }\n    }\n\n    //\n    // Methods that are called by instrumented code\n    //\n    public static void start(String className, String methodName) {\n        long start = System.nanoTime();\n        long threadId = Thread.currentThread().getId();\n        synchronized (_lock) {\n            if (!Controller._profile) {\n                return;\n            }\n            // try to get the method from the method pool\n            //\n            Method method = new Method(className, methodName);\n            if (_methodDictionary.get(method.toString()) == null) {\n                _methodDictionary.put(method.toString(), method);\n            }\n            Frame parent = (Frame) _threadActiveFrame.get(threadId);\n            Frame target = null;\n            if (parent != null) {\n                target = (Frame) parent.getChild(method);\n                if (target == null) {\n                    target = new Frame(parent, method, threadId);\n                    _frameList.add(target);\n                }\n            } else {\n                target = new Frame(null, method, threadId);\n                _frameList.add(target);\n                _threadDictionary.add(threadId, target);\n            }\n            if (_debugStart) {\n                System.out.print(\"  (\");\n                System.out.print(className);\n                System.out.print(\" : \");\n                System.out.print(methodName);\n                System.out.println(')');\n                Frame root = _threadDictionary.getMostRecentFrame(threadId);\n                System.out.println(root);\n            }\n            // \"push\"\n            _threadActiveFrame.put(threadId, target);\n            target.overhead(System.nanoTime() - start);\n            target.setBeginTime(start);\n        }\n        // synchronized\n    }\n\n    public static void end(String className, String method) {\n        long start = System.nanoTime();\n        synchronized (_lock) {\n            long threadId = Thread.currentThread().getId();\n            Frame target = findFrame(threadId, className, method);\n            if (target == null) {\n                return;\n            }\n            if (target.getParent() != null) {\n                // \"pop\"\n                _threadActiveFrame.put(threadId, target.getParent());\n            } else {\n                _threadActiveFrame.put(threadId, null);\n            }\n            target.overhead(System.nanoTime() - start);\n            target.setEndTime(System.nanoTime());\n        }\n        // synchronized\n    }\n\n    public static void beginWait(String className, String methodName) {\n        long start = System.nanoTime();\n        synchronized (_lock) {\n            Frame target = findFrame(Thread.currentThread().getId(), className, methodName);\n            if (target == null) {\n                return;\n            }\n            target.overhead(System.nanoTime() - start);\n            target.beginWait(System.nanoTime());\n        }\n    }\n\n    public static void endWait(String className, String methodName) {\n        long start = System.nanoTime();\n        synchronized (_lock) {\n            Frame target = findFrame(Thread.currentThread().getId(), className, methodName);\n            if (target == null) {\n                return;\n            }\n            target.overhead(System.nanoTime() - start);\n            target.endWait(System.nanoTime());\n        }\n    }\n\n    public static void unwind(String className, String methodName, String exception) {\n        if (_debugException || Controller._debug) {\n            System.out.println(\"Catch: \" + exception);\n        }\n        synchronized (_lock) {\n            long threadId = Thread.currentThread().getId();\n            Frame target = findFrame(threadId, className, methodName);\n            if (target == null) {\n                return;\n            }\n            _threadActiveFrame.put(threadId, target);\n        }\n        // synchronized\n    }\n\n    // MUST be called from a block that has synchronized on _lock!\n    //\n    private static final Frame findFrame(long threadId, String className, String methodName) {\n        if (!Controller._profile) {\n            return null;\n        }\n        Frame target = (Frame) _threadActiveFrame.get(threadId);\n        if (target == null) {\n            return null;\n        }\n        // The flow of control is interrupted when an exception is\n        // thrown. This code will detect this an unwind the stack\n        // until it figures out where we are.\n        // Note that this method has its problems. Because it tries to figure\n        // out were it is based on the class name method name, it's possible\n        // that it could unwind the call stack to the wrong place. Worse yet,\n        // if the flow of control is transfered to the same method, but at a\n        // different point in the call stack,the exception will not be detected\n        // at all.\n        //\n        boolean detectedException = false;\n        while (true) {\n            if (target.getClassName().equals(className) && target.getMethodName().equals(methodName)) {\n                break;\n            }\n            if (!detectedException) {\n                detectedException = true;\n                if (_debugException || Controller._debug) {\n                    System.err.print(\"Detected an exception at \");\n                    System.err.print(className);\n                    System.err.print('.');\n                    System.err.println(methodName);\n                }\n            } else if (_debugException) {\n                System.err.print(\"Unwinding \");\n                System.err.print(target.getClassName());\n                System.err.print('.');\n                System.err.println(target.getMethodName());\n            }\n            target.setEndTime(System.nanoTime());\n            target = target.getParent();\n            // the stack has been unwound to pass the point where\n            // we started to profile.\n            //\n            if (target == null) {\n                if (_debugException) {\n                    System.err.println(\"Stack completely unwound.\");\n                }\n                return null;\n            }\n        }\n        return target;\n    }\n\n    // Uses synchronization for thread safety. I thought this\n    // would slow things down a whole bunch, but on Java 5\n    // I haven't seen any major performance problems.\n    //\n    public static void alloc(String className) {\n        synchronized (_lock) {\n            if (!Controller._profile) {\n                return;\n            }\n            // this code guards against a constructor calling another constructor\n            // in the same class\n            long threadId = Thread.currentThread().getId();\n            Frame target = (Frame) _threadActiveFrame.get(threadId);\n            if (target != null && target.getClassName().equals(className) && target.getMethodName().equals(\"<init>\")) {\n                return;\n            }\n            ClassAllocation ca = _allocList.get(className);\n            if (ca == null) {\n                ca = new ClassAllocation(className);\n                _allocList.put(className, ca);\n            }\n            ca.incAllocCount();\n        }\n        // synchronized\n    }\n\n    /**\n     * ShutdownHook: This will dump the profiling info when the VM shutsdown.\n     */\n    public void run() {\n        try {\n            if (_threadDictionary.size() > 0) {\n                shutdown();\n                ProfileDump.dump();\n            }\n            // fix up the Controller\n            //\n            //closes the socket\n            _controller.close();\n            if (_controllerThread != null) {\n                _controllerThread.interrupt();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/com/mentorgen/tools/profile/runtime/ProfileTest0.java",
		"test_prompt": "// ProfileTest0.java\npackage com.mentorgen.tools.profile.runtime;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport com.mentorgen.tools.profile.Controller;\nimport com.mentorgen.tools.profile.output.ProfileDump;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Profile}.\n* It contains ten unit test cases for the {@link Profile#threads()} method.\n*/\nclass ProfileTest0 {"
	},
	{
		"original_code": "// Profile.java\n/*\nCopyright (c) 2005-2006, MentorGen, LLC\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions are met:\n\n+ Redistributions of source code must retain the above copyright notice, \n  this list of conditions and the following disclaimer.\n+ Redistributions in binary form must reproduce the above copyright notice, \n  this list of conditions and the following disclaimer in the documentation \n  and/or other materials provided with the distribution.\n+ Neither the name of MentorGen LLC nor the names of its contributors may be \n  used to endorse or promote products derived from this software without \n  specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \n  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE \n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \n  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \n  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \n  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n  POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.mentorgen.tools.profile.runtime;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport com.mentorgen.tools.profile.Controller;\nimport com.mentorgen.tools.profile.output.ProfileDump;\n\n/**\n * The <code>Profiler</code> is the class that actually profiles the code.\n * Code to be profiled is instrumented, when the byte code is loaded,\n * to make calls to this class:\n * <ul>\n * \t<li>At the beginning of each method (calls <code>Profiler.start()</cdoe>)</li>\n * \t<li>At the end of each method (that is, when return is called, which\n * \t\tmight not actaully be at the end of the method)\n * \t\t(calls <code>Profiler.end()</cdoe>)</li>\n * \t<li>When an exception is thrown (also calls <code>Profiler.end()</cdoe>)</li>\n * \t<li>Each time a constructor is called (optional)</li>\n * </ul>\n *\n * <blockquote>\n * Note: Instrumenting code can interfer with line numbers that are added to\n * the code for debugging. If you are debugging code and your stack traces\n * don't have line numbers, don't use the profiler (ie, don't use <code>\n * -javaagent)</code>\n * </blockquote>\n *\n * @author Andrew Wilcox\n */\npublic final class Profile implements Runnable {\n\n    private static boolean _debugStart = false;\n\n    private static boolean _debugException = false;\n\n    private static ThreadDictionary _threadDictionary;\n\n    private static List<Frame> _frameList;\n\n    private static Map<Long, Frame> _threadActiveFrame;\n\n    private static Map<String, Method> _methodDictionary;\n\n    private static Object _lock;\n\n    private static Map<String, ClassAllocation> _allocList;\n\n    private static Controller _controller;\n\n    private static Thread _controllerThread;\n\n    public static void initProfiler() {\n        System.err.println(\"Java Interactive Profiler: starting\");\n        init();\n        Runtime.getRuntime().addShutdownHook(new Thread(new Profile()));\n        _controller = new Controller();\n        if (Controller._remote) {\n            _controllerThread = new Thread(_controller);\n            _controllerThread.start();\n        }\n    }\n\n    public static void init() {\n        _threadActiveFrame = new HashMap<Long, Frame>(1001);\n        _threadDictionary = new ThreadDictionary();\n        _methodDictionary = new HashMap<String, Method>(2003);\n        _frameList = new ArrayList<Frame>(1001);\n        _lock = new Object();\n        _allocList = new HashMap<String, ClassAllocation>();\n    }\n\n    //\n    // Methods to programatically manipulate the Profiler\n    //\n    public static void clear() {\n        init();\n    }\n\n    public static void start() {\n        _controller.start();\n    }\n\n    public static void stop() {\n        _controller.stop();\n    }\n\n    public static void setFileName(String fileName) {\n        _controller.setFileName(fileName);\n    }\n\n    public static void shutdown() {\n        synchronized (_lock) {\n            Controller._profile = false;\n            for (Long threadId : _threadDictionary.keySet()) {\n                Frame f = _threadDictionary.getMostRecentFrame(threadId);\n                f.close();\n            }\n            for (Frame frame : frameList()) {\n                frame.computeNetTime();\n            }\n        }\n        // synchronized\n    }\n\n    //\n    // Methods called when generating output\n    //\n    public static Iterable<Long> threads() {\n        return _threadDictionary.threads();\n    }\n\n    public static Iterable<Frame> interactions(long threadId) {\n        return _threadDictionary.interactions((threadId));\n    }\n\n    public static Iterable<Frame> frameList() {\n        return _frameList;\n    }\n\n    public static Iterable<ClassAllocation> allocations() {\n        return _allocList.values();\n    }\n\n    public static long getThreadTotalTime(long threadId) {\n        return _threadDictionary.getThreadTotalTime(threadId);\n    }\n\n    public static void sortFrameList(Comparator<Frame> comp) {\n        synchronized (_lock) {\n            Collections.sort(_frameList, comp);\n        }\n    }\n\n    //\n    // Methods that are called by instrumented code\n    //\n    public static void start(String className, String methodName) {\n        long start = System.nanoTime();\n        long threadId = Thread.currentThread().getId();\n        synchronized (_lock) {\n            if (!Controller._profile) {\n                return;\n            }\n            // try to get the method from the method pool\n            //\n            Method method = new Method(className, methodName);\n            if (_methodDictionary.get(method.toString()) == null) {\n                _methodDictionary.put(method.toString(), method);\n            }\n            Frame parent = (Frame) _threadActiveFrame.get(threadId);\n            Frame target = null;\n            if (parent != null) {\n                target = (Frame) parent.getChild(method);\n                if (target == null) {\n                    target = new Frame(parent, method, threadId);\n                    _frameList.add(target);\n                }\n            } else {\n                target = new Frame(null, method, threadId);\n                _frameList.add(target);\n                _threadDictionary.add(threadId, target);\n            }\n            if (_debugStart) {\n                System.out.print(\"  (\");\n                System.out.print(className);\n                System.out.print(\" : \");\n                System.out.print(methodName);\n                System.out.println(')');\n                Frame root = _threadDictionary.getMostRecentFrame(threadId);\n                System.out.println(root);\n            }\n            // \"push\"\n            _threadActiveFrame.put(threadId, target);\n            target.overhead(System.nanoTime() - start);\n            target.setBeginTime(start);\n        }\n        // synchronized\n    }\n\n    public static void end(String className, String method) {\n        long start = System.nanoTime();\n        synchronized (_lock) {\n            long threadId = Thread.currentThread().getId();\n            Frame target = findFrame(threadId, className, method);\n            if (target == null) {\n                return;\n            }\n            if (target.getParent() != null) {\n                // \"pop\"\n                _threadActiveFrame.put(threadId, target.getParent());\n            } else {\n                _threadActiveFrame.put(threadId, null);\n            }\n            target.overhead(System.nanoTime() - start);\n            target.setEndTime(System.nanoTime());\n        }\n        // synchronized\n    }\n\n    public static void beginWait(String className, String methodName) {\n        long start = System.nanoTime();\n        synchronized (_lock) {\n            Frame target = findFrame(Thread.currentThread().getId(), className, methodName);\n            if (target == null) {\n                return;\n            }\n            target.overhead(System.nanoTime() - start);\n            target.beginWait(System.nanoTime());\n        }\n    }\n\n    public static void endWait(String className, String methodName) {\n        long start = System.nanoTime();\n        synchronized (_lock) {\n            Frame target = findFrame(Thread.currentThread().getId(), className, methodName);\n            if (target == null) {\n                return;\n            }\n            target.overhead(System.nanoTime() - start);\n            target.endWait(System.nanoTime());\n        }\n    }\n\n    public static void unwind(String className, String methodName, String exception) {\n        if (_debugException || Controller._debug) {\n            System.out.println(\"Catch: \" + exception);\n        }\n        synchronized (_lock) {\n            long threadId = Thread.currentThread().getId();\n            Frame target = findFrame(threadId, className, methodName);\n            if (target == null) {\n                return;\n            }\n            _threadActiveFrame.put(threadId, target);\n        }\n        // synchronized\n    }\n\n    // MUST be called from a block that has synchronized on _lock!\n    //\n    private static final Frame findFrame(long threadId, String className, String methodName) {\n        if (!Controller._profile) {\n            return null;\n        }\n        Frame target = (Frame) _threadActiveFrame.get(threadId);\n        if (target == null) {\n            return null;\n        }\n        // The flow of control is interrupted when an exception is\n        // thrown. This code will detect this an unwind the stack\n        // until it figures out where we are.\n        // Note that this method has its problems. Because it tries to figure\n        // out were it is based on the class name method name, it's possible\n        // that it could unwind the call stack to the wrong place. Worse yet,\n        // if the flow of control is transfered to the same method, but at a\n        // different point in the call stack,the exception will not be detected\n        // at all.\n        //\n        boolean detectedException = false;\n        while (true) {\n            if (target.getClassName().equals(className) && target.getMethodName().equals(methodName)) {\n                break;\n            }\n            if (!detectedException) {\n                detectedException = true;\n                if (_debugException || Controller._debug) {\n                    System.err.print(\"Detected an exception at \");\n                    System.err.print(className);\n                    System.err.print('.');\n                    System.err.println(methodName);\n                }\n            } else if (_debugException) {\n                System.err.print(\"Unwinding \");\n                System.err.print(target.getClassName());\n                System.err.print('.');\n                System.err.println(target.getMethodName());\n            }\n            target.setEndTime(System.nanoTime());\n            target = target.getParent();\n            // the stack has been unwound to pass the point where\n            // we started to profile.\n            //\n            if (target == null) {\n                if (_debugException) {\n                    System.err.println(\"Stack completely unwound.\");\n                }\n                return null;\n            }\n        }\n        return target;\n    }\n\n    // Uses synchronization for thread safety. I thought this\n    // would slow things down a whole bunch, but on Java 5\n    // I haven't seen any major performance problems.\n    //\n    public static void alloc(String className) {\n        synchronized (_lock) {\n            if (!Controller._profile) {\n                return;\n            }\n            // this code guards against a constructor calling another constructor\n            // in the same class\n            long threadId = Thread.currentThread().getId();\n            Frame target = (Frame) _threadActiveFrame.get(threadId);\n            if (target != null && target.getClassName().equals(className) && target.getMethodName().equals(\"<init>\")) {\n                return;\n            }\n            ClassAllocation ca = _allocList.get(className);\n            if (ca == null) {\n                ca = new ClassAllocation(className);\n                _allocList.put(className, ca);\n            }\n            ca.incAllocCount();\n        }\n        // synchronized\n    }\n\n    /**\n     * ShutdownHook: This will dump the profiling info when the VM shutsdown.\n     */\n    public void run() {\n        try {\n            if (_threadDictionary.size() > 0) {\n                shutdown();\n                ProfileDump.dump();\n            }\n            // fix up the Controller\n            //\n            //closes the socket\n            _controller.close();\n            if (_controllerThread != null) {\n                _controllerThread.interrupt();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/com/mentorgen/tools/profile/runtime/ProfileTest1.java",
		"test_prompt": "// ProfileTest1.java\npackage com.mentorgen.tools.profile.runtime;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport com.mentorgen.tools.profile.Controller;\nimport com.mentorgen.tools.profile.output.ProfileDump;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Profile}.\n* It contains ten unit test cases for the {@link Profile#interactions(long)} method.\n*/\nclass ProfileTest1 {"
	},
	{
		"original_code": "// Profile.java\n/*\nCopyright (c) 2005-2006, MentorGen, LLC\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions are met:\n\n+ Redistributions of source code must retain the above copyright notice, \n  this list of conditions and the following disclaimer.\n+ Redistributions in binary form must reproduce the above copyright notice, \n  this list of conditions and the following disclaimer in the documentation \n  and/or other materials provided with the distribution.\n+ Neither the name of MentorGen LLC nor the names of its contributors may be \n  used to endorse or promote products derived from this software without \n  specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \n  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE \n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \n  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \n  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \n  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n  POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.mentorgen.tools.profile.runtime;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport com.mentorgen.tools.profile.Controller;\nimport com.mentorgen.tools.profile.output.ProfileDump;\n\n/**\n * The <code>Profiler</code> is the class that actually profiles the code.\n * Code to be profiled is instrumented, when the byte code is loaded,\n * to make calls to this class:\n * <ul>\n * \t<li>At the beginning of each method (calls <code>Profiler.start()</cdoe>)</li>\n * \t<li>At the end of each method (that is, when return is called, which\n * \t\tmight not actaully be at the end of the method)\n * \t\t(calls <code>Profiler.end()</cdoe>)</li>\n * \t<li>When an exception is thrown (also calls <code>Profiler.end()</cdoe>)</li>\n * \t<li>Each time a constructor is called (optional)</li>\n * </ul>\n *\n * <blockquote>\n * Note: Instrumenting code can interfer with line numbers that are added to\n * the code for debugging. If you are debugging code and your stack traces\n * don't have line numbers, don't use the profiler (ie, don't use <code>\n * -javaagent)</code>\n * </blockquote>\n *\n * @author Andrew Wilcox\n */\npublic final class Profile implements Runnable {\n\n    private static boolean _debugStart = false;\n\n    private static boolean _debugException = false;\n\n    private static ThreadDictionary _threadDictionary;\n\n    private static List<Frame> _frameList;\n\n    private static Map<Long, Frame> _threadActiveFrame;\n\n    private static Map<String, Method> _methodDictionary;\n\n    private static Object _lock;\n\n    private static Map<String, ClassAllocation> _allocList;\n\n    private static Controller _controller;\n\n    private static Thread _controllerThread;\n\n    public static void initProfiler() {\n        System.err.println(\"Java Interactive Profiler: starting\");\n        init();\n        Runtime.getRuntime().addShutdownHook(new Thread(new Profile()));\n        _controller = new Controller();\n        if (Controller._remote) {\n            _controllerThread = new Thread(_controller);\n            _controllerThread.start();\n        }\n    }\n\n    public static void init() {\n        _threadActiveFrame = new HashMap<Long, Frame>(1001);\n        _threadDictionary = new ThreadDictionary();\n        _methodDictionary = new HashMap<String, Method>(2003);\n        _frameList = new ArrayList<Frame>(1001);\n        _lock = new Object();\n        _allocList = new HashMap<String, ClassAllocation>();\n    }\n\n    //\n    // Methods to programatically manipulate the Profiler\n    //\n    public static void clear() {\n        init();\n    }\n\n    public static void start() {\n        _controller.start();\n    }\n\n    public static void stop() {\n        _controller.stop();\n    }\n\n    public static void setFileName(String fileName) {\n        _controller.setFileName(fileName);\n    }\n\n    public static void shutdown() {\n        synchronized (_lock) {\n            Controller._profile = false;\n            for (Long threadId : _threadDictionary.keySet()) {\n                Frame f = _threadDictionary.getMostRecentFrame(threadId);\n                f.close();\n            }\n            for (Frame frame : frameList()) {\n                frame.computeNetTime();\n            }\n        }\n        // synchronized\n    }\n\n    //\n    // Methods called when generating output\n    //\n    public static Iterable<Long> threads() {\n        return _threadDictionary.threads();\n    }\n\n    public static Iterable<Frame> interactions(long threadId) {\n        return _threadDictionary.interactions((threadId));\n    }\n\n    public static Iterable<Frame> frameList() {\n        return _frameList;\n    }\n\n    public static Iterable<ClassAllocation> allocations() {\n        return _allocList.values();\n    }\n\n    public static long getThreadTotalTime(long threadId) {\n        return _threadDictionary.getThreadTotalTime(threadId);\n    }\n\n    public static void sortFrameList(Comparator<Frame> comp) {\n        synchronized (_lock) {\n            Collections.sort(_frameList, comp);\n        }\n    }\n\n    //\n    // Methods that are called by instrumented code\n    //\n    public static void start(String className, String methodName) {\n        long start = System.nanoTime();\n        long threadId = Thread.currentThread().getId();\n        synchronized (_lock) {\n            if (!Controller._profile) {\n                return;\n            }\n            // try to get the method from the method pool\n            //\n            Method method = new Method(className, methodName);\n            if (_methodDictionary.get(method.toString()) == null) {\n                _methodDictionary.put(method.toString(), method);\n            }\n            Frame parent = (Frame) _threadActiveFrame.get(threadId);\n            Frame target = null;\n            if (parent != null) {\n                target = (Frame) parent.getChild(method);\n                if (target == null) {\n                    target = new Frame(parent, method, threadId);\n                    _frameList.add(target);\n                }\n            } else {\n                target = new Frame(null, method, threadId);\n                _frameList.add(target);\n                _threadDictionary.add(threadId, target);\n            }\n            if (_debugStart) {\n                System.out.print(\"  (\");\n                System.out.print(className);\n                System.out.print(\" : \");\n                System.out.print(methodName);\n                System.out.println(')');\n                Frame root = _threadDictionary.getMostRecentFrame(threadId);\n                System.out.println(root);\n            }\n            // \"push\"\n            _threadActiveFrame.put(threadId, target);\n            target.overhead(System.nanoTime() - start);\n            target.setBeginTime(start);\n        }\n        // synchronized\n    }\n\n    public static void end(String className, String method) {\n        long start = System.nanoTime();\n        synchronized (_lock) {\n            long threadId = Thread.currentThread().getId();\n            Frame target = findFrame(threadId, className, method);\n            if (target == null) {\n                return;\n            }\n            if (target.getParent() != null) {\n                // \"pop\"\n                _threadActiveFrame.put(threadId, target.getParent());\n            } else {\n                _threadActiveFrame.put(threadId, null);\n            }\n            target.overhead(System.nanoTime() - start);\n            target.setEndTime(System.nanoTime());\n        }\n        // synchronized\n    }\n\n    public static void beginWait(String className, String methodName) {\n        long start = System.nanoTime();\n        synchronized (_lock) {\n            Frame target = findFrame(Thread.currentThread().getId(), className, methodName);\n            if (target == null) {\n                return;\n            }\n            target.overhead(System.nanoTime() - start);\n            target.beginWait(System.nanoTime());\n        }\n    }\n\n    public static void endWait(String className, String methodName) {\n        long start = System.nanoTime();\n        synchronized (_lock) {\n            Frame target = findFrame(Thread.currentThread().getId(), className, methodName);\n            if (target == null) {\n                return;\n            }\n            target.overhead(System.nanoTime() - start);\n            target.endWait(System.nanoTime());\n        }\n    }\n\n    public static void unwind(String className, String methodName, String exception) {\n        if (_debugException || Controller._debug) {\n            System.out.println(\"Catch: \" + exception);\n        }\n        synchronized (_lock) {\n            long threadId = Thread.currentThread().getId();\n            Frame target = findFrame(threadId, className, methodName);\n            if (target == null) {\n                return;\n            }\n            _threadActiveFrame.put(threadId, target);\n        }\n        // synchronized\n    }\n\n    // MUST be called from a block that has synchronized on _lock!\n    //\n    private static final Frame findFrame(long threadId, String className, String methodName) {\n        if (!Controller._profile) {\n            return null;\n        }\n        Frame target = (Frame) _threadActiveFrame.get(threadId);\n        if (target == null) {\n            return null;\n        }\n        // The flow of control is interrupted when an exception is\n        // thrown. This code will detect this an unwind the stack\n        // until it figures out where we are.\n        // Note that this method has its problems. Because it tries to figure\n        // out were it is based on the class name method name, it's possible\n        // that it could unwind the call stack to the wrong place. Worse yet,\n        // if the flow of control is transfered to the same method, but at a\n        // different point in the call stack,the exception will not be detected\n        // at all.\n        //\n        boolean detectedException = false;\n        while (true) {\n            if (target.getClassName().equals(className) && target.getMethodName().equals(methodName)) {\n                break;\n            }\n            if (!detectedException) {\n                detectedException = true;\n                if (_debugException || Controller._debug) {\n                    System.err.print(\"Detected an exception at \");\n                    System.err.print(className);\n                    System.err.print('.');\n                    System.err.println(methodName);\n                }\n            } else if (_debugException) {\n                System.err.print(\"Unwinding \");\n                System.err.print(target.getClassName());\n                System.err.print('.');\n                System.err.println(target.getMethodName());\n            }\n            target.setEndTime(System.nanoTime());\n            target = target.getParent();\n            // the stack has been unwound to pass the point where\n            // we started to profile.\n            //\n            if (target == null) {\n                if (_debugException) {\n                    System.err.println(\"Stack completely unwound.\");\n                }\n                return null;\n            }\n        }\n        return target;\n    }\n\n    // Uses synchronization for thread safety. I thought this\n    // would slow things down a whole bunch, but on Java 5\n    // I haven't seen any major performance problems.\n    //\n    public static void alloc(String className) {\n        synchronized (_lock) {\n            if (!Controller._profile) {\n                return;\n            }\n            // this code guards against a constructor calling another constructor\n            // in the same class\n            long threadId = Thread.currentThread().getId();\n            Frame target = (Frame) _threadActiveFrame.get(threadId);\n            if (target != null && target.getClassName().equals(className) && target.getMethodName().equals(\"<init>\")) {\n                return;\n            }\n            ClassAllocation ca = _allocList.get(className);\n            if (ca == null) {\n                ca = new ClassAllocation(className);\n                _allocList.put(className, ca);\n            }\n            ca.incAllocCount();\n        }\n        // synchronized\n    }\n\n    /**\n     * ShutdownHook: This will dump the profiling info when the VM shutsdown.\n     */\n    public void run() {\n        try {\n            if (_threadDictionary.size() > 0) {\n                shutdown();\n                ProfileDump.dump();\n            }\n            // fix up the Controller\n            //\n            //closes the socket\n            _controller.close();\n            if (_controllerThread != null) {\n                _controllerThread.interrupt();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/com/mentorgen/tools/profile/runtime/ProfileTest2.java",
		"test_prompt": "// ProfileTest2.java\npackage com.mentorgen.tools.profile.runtime;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport com.mentorgen.tools.profile.Controller;\nimport com.mentorgen.tools.profile.output.ProfileDump;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Profile}.\n* It contains ten unit test cases for the {@link Profile#frameList()} method.\n*/\nclass ProfileTest2 {"
	},
	{
		"original_code": "// Profile.java\n/*\nCopyright (c) 2005-2006, MentorGen, LLC\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions are met:\n\n+ Redistributions of source code must retain the above copyright notice, \n  this list of conditions and the following disclaimer.\n+ Redistributions in binary form must reproduce the above copyright notice, \n  this list of conditions and the following disclaimer in the documentation \n  and/or other materials provided with the distribution.\n+ Neither the name of MentorGen LLC nor the names of its contributors may be \n  used to endorse or promote products derived from this software without \n  specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \n  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE \n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \n  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \n  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \n  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n  POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.mentorgen.tools.profile.runtime;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport com.mentorgen.tools.profile.Controller;\nimport com.mentorgen.tools.profile.output.ProfileDump;\n\n/**\n * The <code>Profiler</code> is the class that actually profiles the code.\n * Code to be profiled is instrumented, when the byte code is loaded,\n * to make calls to this class:\n * <ul>\n * \t<li>At the beginning of each method (calls <code>Profiler.start()</cdoe>)</li>\n * \t<li>At the end of each method (that is, when return is called, which\n * \t\tmight not actaully be at the end of the method)\n * \t\t(calls <code>Profiler.end()</cdoe>)</li>\n * \t<li>When an exception is thrown (also calls <code>Profiler.end()</cdoe>)</li>\n * \t<li>Each time a constructor is called (optional)</li>\n * </ul>\n *\n * <blockquote>\n * Note: Instrumenting code can interfer with line numbers that are added to\n * the code for debugging. If you are debugging code and your stack traces\n * don't have line numbers, don't use the profiler (ie, don't use <code>\n * -javaagent)</code>\n * </blockquote>\n *\n * @author Andrew Wilcox\n */\npublic final class Profile implements Runnable {\n\n    private static boolean _debugStart = false;\n\n    private static boolean _debugException = false;\n\n    private static ThreadDictionary _threadDictionary;\n\n    private static List<Frame> _frameList;\n\n    private static Map<Long, Frame> _threadActiveFrame;\n\n    private static Map<String, Method> _methodDictionary;\n\n    private static Object _lock;\n\n    private static Map<String, ClassAllocation> _allocList;\n\n    private static Controller _controller;\n\n    private static Thread _controllerThread;\n\n    public static void initProfiler() {\n        System.err.println(\"Java Interactive Profiler: starting\");\n        init();\n        Runtime.getRuntime().addShutdownHook(new Thread(new Profile()));\n        _controller = new Controller();\n        if (Controller._remote) {\n            _controllerThread = new Thread(_controller);\n            _controllerThread.start();\n        }\n    }\n\n    public static void init() {\n        _threadActiveFrame = new HashMap<Long, Frame>(1001);\n        _threadDictionary = new ThreadDictionary();\n        _methodDictionary = new HashMap<String, Method>(2003);\n        _frameList = new ArrayList<Frame>(1001);\n        _lock = new Object();\n        _allocList = new HashMap<String, ClassAllocation>();\n    }\n\n    //\n    // Methods to programatically manipulate the Profiler\n    //\n    public static void clear() {\n        init();\n    }\n\n    public static void start() {\n        _controller.start();\n    }\n\n    public static void stop() {\n        _controller.stop();\n    }\n\n    public static void setFileName(String fileName) {\n        _controller.setFileName(fileName);\n    }\n\n    public static void shutdown() {\n        synchronized (_lock) {\n            Controller._profile = false;\n            for (Long threadId : _threadDictionary.keySet()) {\n                Frame f = _threadDictionary.getMostRecentFrame(threadId);\n                f.close();\n            }\n            for (Frame frame : frameList()) {\n                frame.computeNetTime();\n            }\n        }\n        // synchronized\n    }\n\n    //\n    // Methods called when generating output\n    //\n    public static Iterable<Long> threads() {\n        return _threadDictionary.threads();\n    }\n\n    public static Iterable<Frame> interactions(long threadId) {\n        return _threadDictionary.interactions((threadId));\n    }\n\n    public static Iterable<Frame> frameList() {\n        return _frameList;\n    }\n\n    public static Iterable<ClassAllocation> allocations() {\n        return _allocList.values();\n    }\n\n    public static long getThreadTotalTime(long threadId) {\n        return _threadDictionary.getThreadTotalTime(threadId);\n    }\n\n    public static void sortFrameList(Comparator<Frame> comp) {\n        synchronized (_lock) {\n            Collections.sort(_frameList, comp);\n        }\n    }\n\n    //\n    // Methods that are called by instrumented code\n    //\n    public static void start(String className, String methodName) {\n        long start = System.nanoTime();\n        long threadId = Thread.currentThread().getId();\n        synchronized (_lock) {\n            if (!Controller._profile) {\n                return;\n            }\n            // try to get the method from the method pool\n            //\n            Method method = new Method(className, methodName);\n            if (_methodDictionary.get(method.toString()) == null) {\n                _methodDictionary.put(method.toString(), method);\n            }\n            Frame parent = (Frame) _threadActiveFrame.get(threadId);\n            Frame target = null;\n            if (parent != null) {\n                target = (Frame) parent.getChild(method);\n                if (target == null) {\n                    target = new Frame(parent, method, threadId);\n                    _frameList.add(target);\n                }\n            } else {\n                target = new Frame(null, method, threadId);\n                _frameList.add(target);\n                _threadDictionary.add(threadId, target);\n            }\n            if (_debugStart) {\n                System.out.print(\"  (\");\n                System.out.print(className);\n                System.out.print(\" : \");\n                System.out.print(methodName);\n                System.out.println(')');\n                Frame root = _threadDictionary.getMostRecentFrame(threadId);\n                System.out.println(root);\n            }\n            // \"push\"\n            _threadActiveFrame.put(threadId, target);\n            target.overhead(System.nanoTime() - start);\n            target.setBeginTime(start);\n        }\n        // synchronized\n    }\n\n    public static void end(String className, String method) {\n        long start = System.nanoTime();\n        synchronized (_lock) {\n            long threadId = Thread.currentThread().getId();\n            Frame target = findFrame(threadId, className, method);\n            if (target == null) {\n                return;\n            }\n            if (target.getParent() != null) {\n                // \"pop\"\n                _threadActiveFrame.put(threadId, target.getParent());\n            } else {\n                _threadActiveFrame.put(threadId, null);\n            }\n            target.overhead(System.nanoTime() - start);\n            target.setEndTime(System.nanoTime());\n        }\n        // synchronized\n    }\n\n    public static void beginWait(String className, String methodName) {\n        long start = System.nanoTime();\n        synchronized (_lock) {\n            Frame target = findFrame(Thread.currentThread().getId(), className, methodName);\n            if (target == null) {\n                return;\n            }\n            target.overhead(System.nanoTime() - start);\n            target.beginWait(System.nanoTime());\n        }\n    }\n\n    public static void endWait(String className, String methodName) {\n        long start = System.nanoTime();\n        synchronized (_lock) {\n            Frame target = findFrame(Thread.currentThread().getId(), className, methodName);\n            if (target == null) {\n                return;\n            }\n            target.overhead(System.nanoTime() - start);\n            target.endWait(System.nanoTime());\n        }\n    }\n\n    public static void unwind(String className, String methodName, String exception) {\n        if (_debugException || Controller._debug) {\n            System.out.println(\"Catch: \" + exception);\n        }\n        synchronized (_lock) {\n            long threadId = Thread.currentThread().getId();\n            Frame target = findFrame(threadId, className, methodName);\n            if (target == null) {\n                return;\n            }\n            _threadActiveFrame.put(threadId, target);\n        }\n        // synchronized\n    }\n\n    // MUST be called from a block that has synchronized on _lock!\n    //\n    private static final Frame findFrame(long threadId, String className, String methodName) {\n        if (!Controller._profile) {\n            return null;\n        }\n        Frame target = (Frame) _threadActiveFrame.get(threadId);\n        if (target == null) {\n            return null;\n        }\n        // The flow of control is interrupted when an exception is\n        // thrown. This code will detect this an unwind the stack\n        // until it figures out where we are.\n        // Note that this method has its problems. Because it tries to figure\n        // out were it is based on the class name method name, it's possible\n        // that it could unwind the call stack to the wrong place. Worse yet,\n        // if the flow of control is transfered to the same method, but at a\n        // different point in the call stack,the exception will not be detected\n        // at all.\n        //\n        boolean detectedException = false;\n        while (true) {\n            if (target.getClassName().equals(className) && target.getMethodName().equals(methodName)) {\n                break;\n            }\n            if (!detectedException) {\n                detectedException = true;\n                if (_debugException || Controller._debug) {\n                    System.err.print(\"Detected an exception at \");\n                    System.err.print(className);\n                    System.err.print('.');\n                    System.err.println(methodName);\n                }\n            } else if (_debugException) {\n                System.err.print(\"Unwinding \");\n                System.err.print(target.getClassName());\n                System.err.print('.');\n                System.err.println(target.getMethodName());\n            }\n            target.setEndTime(System.nanoTime());\n            target = target.getParent();\n            // the stack has been unwound to pass the point where\n            // we started to profile.\n            //\n            if (target == null) {\n                if (_debugException) {\n                    System.err.println(\"Stack completely unwound.\");\n                }\n                return null;\n            }\n        }\n        return target;\n    }\n\n    // Uses synchronization for thread safety. I thought this\n    // would slow things down a whole bunch, but on Java 5\n    // I haven't seen any major performance problems.\n    //\n    public static void alloc(String className) {\n        synchronized (_lock) {\n            if (!Controller._profile) {\n                return;\n            }\n            // this code guards against a constructor calling another constructor\n            // in the same class\n            long threadId = Thread.currentThread().getId();\n            Frame target = (Frame) _threadActiveFrame.get(threadId);\n            if (target != null && target.getClassName().equals(className) && target.getMethodName().equals(\"<init>\")) {\n                return;\n            }\n            ClassAllocation ca = _allocList.get(className);\n            if (ca == null) {\n                ca = new ClassAllocation(className);\n                _allocList.put(className, ca);\n            }\n            ca.incAllocCount();\n        }\n        // synchronized\n    }\n\n    /**\n     * ShutdownHook: This will dump the profiling info when the VM shutsdown.\n     */\n    public void run() {\n        try {\n            if (_threadDictionary.size() > 0) {\n                shutdown();\n                ProfileDump.dump();\n            }\n            // fix up the Controller\n            //\n            //closes the socket\n            _controller.close();\n            if (_controllerThread != null) {\n                _controllerThread.interrupt();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/com/mentorgen/tools/profile/runtime/ProfileTest3.java",
		"test_prompt": "// ProfileTest3.java\npackage com.mentorgen.tools.profile.runtime;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport com.mentorgen.tools.profile.Controller;\nimport com.mentorgen.tools.profile.output.ProfileDump;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Profile}.\n* It contains ten unit test cases for the {@link Profile#allocations()} method.\n*/\nclass ProfileTest3 {"
	},
	{
		"original_code": "// Profile.java\n/*\nCopyright (c) 2005-2006, MentorGen, LLC\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions are met:\n\n+ Redistributions of source code must retain the above copyright notice, \n  this list of conditions and the following disclaimer.\n+ Redistributions in binary form must reproduce the above copyright notice, \n  this list of conditions and the following disclaimer in the documentation \n  and/or other materials provided with the distribution.\n+ Neither the name of MentorGen LLC nor the names of its contributors may be \n  used to endorse or promote products derived from this software without \n  specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \n  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE \n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \n  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \n  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \n  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n  POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.mentorgen.tools.profile.runtime;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport com.mentorgen.tools.profile.Controller;\nimport com.mentorgen.tools.profile.output.ProfileDump;\n\n/**\n * The <code>Profiler</code> is the class that actually profiles the code.\n * Code to be profiled is instrumented, when the byte code is loaded,\n * to make calls to this class:\n * <ul>\n * \t<li>At the beginning of each method (calls <code>Profiler.start()</cdoe>)</li>\n * \t<li>At the end of each method (that is, when return is called, which\n * \t\tmight not actaully be at the end of the method)\n * \t\t(calls <code>Profiler.end()</cdoe>)</li>\n * \t<li>When an exception is thrown (also calls <code>Profiler.end()</cdoe>)</li>\n * \t<li>Each time a constructor is called (optional)</li>\n * </ul>\n *\n * <blockquote>\n * Note: Instrumenting code can interfer with line numbers that are added to\n * the code for debugging. If you are debugging code and your stack traces\n * don't have line numbers, don't use the profiler (ie, don't use <code>\n * -javaagent)</code>\n * </blockquote>\n *\n * @author Andrew Wilcox\n */\npublic final class Profile implements Runnable {\n\n    private static boolean _debugStart = false;\n\n    private static boolean _debugException = false;\n\n    private static ThreadDictionary _threadDictionary;\n\n    private static List<Frame> _frameList;\n\n    private static Map<Long, Frame> _threadActiveFrame;\n\n    private static Map<String, Method> _methodDictionary;\n\n    private static Object _lock;\n\n    private static Map<String, ClassAllocation> _allocList;\n\n    private static Controller _controller;\n\n    private static Thread _controllerThread;\n\n    public static void initProfiler() {\n        System.err.println(\"Java Interactive Profiler: starting\");\n        init();\n        Runtime.getRuntime().addShutdownHook(new Thread(new Profile()));\n        _controller = new Controller();\n        if (Controller._remote) {\n            _controllerThread = new Thread(_controller);\n            _controllerThread.start();\n        }\n    }\n\n    public static void init() {\n        _threadActiveFrame = new HashMap<Long, Frame>(1001);\n        _threadDictionary = new ThreadDictionary();\n        _methodDictionary = new HashMap<String, Method>(2003);\n        _frameList = new ArrayList<Frame>(1001);\n        _lock = new Object();\n        _allocList = new HashMap<String, ClassAllocation>();\n    }\n\n    //\n    // Methods to programatically manipulate the Profiler\n    //\n    public static void clear() {\n        init();\n    }\n\n    public static void start() {\n        _controller.start();\n    }\n\n    public static void stop() {\n        _controller.stop();\n    }\n\n    public static void setFileName(String fileName) {\n        _controller.setFileName(fileName);\n    }\n\n    public static void shutdown() {\n        synchronized (_lock) {\n            Controller._profile = false;\n            for (Long threadId : _threadDictionary.keySet()) {\n                Frame f = _threadDictionary.getMostRecentFrame(threadId);\n                f.close();\n            }\n            for (Frame frame : frameList()) {\n                frame.computeNetTime();\n            }\n        }\n        // synchronized\n    }\n\n    //\n    // Methods called when generating output\n    //\n    public static Iterable<Long> threads() {\n        return _threadDictionary.threads();\n    }\n\n    public static Iterable<Frame> interactions(long threadId) {\n        return _threadDictionary.interactions((threadId));\n    }\n\n    public static Iterable<Frame> frameList() {\n        return _frameList;\n    }\n\n    public static Iterable<ClassAllocation> allocations() {\n        return _allocList.values();\n    }\n\n    public static long getThreadTotalTime(long threadId) {\n        return _threadDictionary.getThreadTotalTime(threadId);\n    }\n\n    public static void sortFrameList(Comparator<Frame> comp) {\n        synchronized (_lock) {\n            Collections.sort(_frameList, comp);\n        }\n    }\n\n    //\n    // Methods that are called by instrumented code\n    //\n    public static void start(String className, String methodName) {\n        long start = System.nanoTime();\n        long threadId = Thread.currentThread().getId();\n        synchronized (_lock) {\n            if (!Controller._profile) {\n                return;\n            }\n            // try to get the method from the method pool\n            //\n            Method method = new Method(className, methodName);\n            if (_methodDictionary.get(method.toString()) == null) {\n                _methodDictionary.put(method.toString(), method);\n            }\n            Frame parent = (Frame) _threadActiveFrame.get(threadId);\n            Frame target = null;\n            if (parent != null) {\n                target = (Frame) parent.getChild(method);\n                if (target == null) {\n                    target = new Frame(parent, method, threadId);\n                    _frameList.add(target);\n                }\n            } else {\n                target = new Frame(null, method, threadId);\n                _frameList.add(target);\n                _threadDictionary.add(threadId, target);\n            }\n            if (_debugStart) {\n                System.out.print(\"  (\");\n                System.out.print(className);\n                System.out.print(\" : \");\n                System.out.print(methodName);\n                System.out.println(')');\n                Frame root = _threadDictionary.getMostRecentFrame(threadId);\n                System.out.println(root);\n            }\n            // \"push\"\n            _threadActiveFrame.put(threadId, target);\n            target.overhead(System.nanoTime() - start);\n            target.setBeginTime(start);\n        }\n        // synchronized\n    }\n\n    public static void end(String className, String method) {\n        long start = System.nanoTime();\n        synchronized (_lock) {\n            long threadId = Thread.currentThread().getId();\n            Frame target = findFrame(threadId, className, method);\n            if (target == null) {\n                return;\n            }\n            if (target.getParent() != null) {\n                // \"pop\"\n                _threadActiveFrame.put(threadId, target.getParent());\n            } else {\n                _threadActiveFrame.put(threadId, null);\n            }\n            target.overhead(System.nanoTime() - start);\n            target.setEndTime(System.nanoTime());\n        }\n        // synchronized\n    }\n\n    public static void beginWait(String className, String methodName) {\n        long start = System.nanoTime();\n        synchronized (_lock) {\n            Frame target = findFrame(Thread.currentThread().getId(), className, methodName);\n            if (target == null) {\n                return;\n            }\n            target.overhead(System.nanoTime() - start);\n            target.beginWait(System.nanoTime());\n        }\n    }\n\n    public static void endWait(String className, String methodName) {\n        long start = System.nanoTime();\n        synchronized (_lock) {\n            Frame target = findFrame(Thread.currentThread().getId(), className, methodName);\n            if (target == null) {\n                return;\n            }\n            target.overhead(System.nanoTime() - start);\n            target.endWait(System.nanoTime());\n        }\n    }\n\n    public static void unwind(String className, String methodName, String exception) {\n        if (_debugException || Controller._debug) {\n            System.out.println(\"Catch: \" + exception);\n        }\n        synchronized (_lock) {\n            long threadId = Thread.currentThread().getId();\n            Frame target = findFrame(threadId, className, methodName);\n            if (target == null) {\n                return;\n            }\n            _threadActiveFrame.put(threadId, target);\n        }\n        // synchronized\n    }\n\n    // MUST be called from a block that has synchronized on _lock!\n    //\n    private static final Frame findFrame(long threadId, String className, String methodName) {\n        if (!Controller._profile) {\n            return null;\n        }\n        Frame target = (Frame) _threadActiveFrame.get(threadId);\n        if (target == null) {\n            return null;\n        }\n        // The flow of control is interrupted when an exception is\n        // thrown. This code will detect this an unwind the stack\n        // until it figures out where we are.\n        // Note that this method has its problems. Because it tries to figure\n        // out were it is based on the class name method name, it's possible\n        // that it could unwind the call stack to the wrong place. Worse yet,\n        // if the flow of control is transfered to the same method, but at a\n        // different point in the call stack,the exception will not be detected\n        // at all.\n        //\n        boolean detectedException = false;\n        while (true) {\n            if (target.getClassName().equals(className) && target.getMethodName().equals(methodName)) {\n                break;\n            }\n            if (!detectedException) {\n                detectedException = true;\n                if (_debugException || Controller._debug) {\n                    System.err.print(\"Detected an exception at \");\n                    System.err.print(className);\n                    System.err.print('.');\n                    System.err.println(methodName);\n                }\n            } else if (_debugException) {\n                System.err.print(\"Unwinding \");\n                System.err.print(target.getClassName());\n                System.err.print('.');\n                System.err.println(target.getMethodName());\n            }\n            target.setEndTime(System.nanoTime());\n            target = target.getParent();\n            // the stack has been unwound to pass the point where\n            // we started to profile.\n            //\n            if (target == null) {\n                if (_debugException) {\n                    System.err.println(\"Stack completely unwound.\");\n                }\n                return null;\n            }\n        }\n        return target;\n    }\n\n    // Uses synchronization for thread safety. I thought this\n    // would slow things down a whole bunch, but on Java 5\n    // I haven't seen any major performance problems.\n    //\n    public static void alloc(String className) {\n        synchronized (_lock) {\n            if (!Controller._profile) {\n                return;\n            }\n            // this code guards against a constructor calling another constructor\n            // in the same class\n            long threadId = Thread.currentThread().getId();\n            Frame target = (Frame) _threadActiveFrame.get(threadId);\n            if (target != null && target.getClassName().equals(className) && target.getMethodName().equals(\"<init>\")) {\n                return;\n            }\n            ClassAllocation ca = _allocList.get(className);\n            if (ca == null) {\n                ca = new ClassAllocation(className);\n                _allocList.put(className, ca);\n            }\n            ca.incAllocCount();\n        }\n        // synchronized\n    }\n\n    /**\n     * ShutdownHook: This will dump the profiling info when the VM shutsdown.\n     */\n    public void run() {\n        try {\n            if (_threadDictionary.size() > 0) {\n                shutdown();\n                ProfileDump.dump();\n            }\n            // fix up the Controller\n            //\n            //closes the socket\n            _controller.close();\n            if (_controllerThread != null) {\n                _controllerThread.interrupt();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/com/mentorgen/tools/profile/runtime/ProfileTest4.java",
		"test_prompt": "// ProfileTest4.java\npackage com.mentorgen.tools.profile.runtime;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport com.mentorgen.tools.profile.Controller;\nimport com.mentorgen.tools.profile.output.ProfileDump;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Profile}.\n* It contains ten unit test cases for the {@link Profile#getThreadTotalTime(long)} method.\n*/\nclass ProfileTest4 {"
	},
	{
		"original_code": "// Method.java\n/*\nCopyright (c) 2005, MentorGen, LLC\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions are met:\n\n+ Redistributions of source code must retain the above copyright notice, \n  this list of conditions and the following disclaimer.\n+ Redistributions in binary form must reproduce the above copyright notice, \n  this list of conditions and the following disclaimer in the documentation \n  and/or other materials provided with the distribution.\n+ Neither the name of MentorGen LLC nor the names of its contributors may be \n  used to endorse or promote products derived from this software without \n  specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \n  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE \n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \n  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \n  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \n  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n  POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.mentorgen.tools.profile.runtime;\n\n/**\n * A simple class to capture metrics for a method in a particular thread\n *\n * @author Andrew Wilcox\n */\nfinal class Method {\n\n    private String _className;\n\n    private String _methodName;\n\n    Method(String className, String method) {\n        _className = className;\n        _methodName = method;\n    }\n\n    String getClassName() {\n        return _className;\n    }\n\n    String getMethodName() {\n        return _methodName;\n    }\n\n    String toInvertedString() {\n        String className = _className.replace('/', '.');\n        int index = className.lastIndexOf('.');\n        String shortName = null;\n        String packageName = \"\";\n        if (index > -1) {\n            shortName = className.substring(index + 1);\n            packageName = className.substring(0, index);\n        } else {\n            shortName = className;\n        }\n        StringBuffer b = new StringBuffer();\n        b.append(shortName);\n        b.append(':');\n        b.append(_methodName);\n        b.append(\"\\t(\");\n        b.append(packageName);\n        b.append(\")\");\n        return b.toString();\n    }\n\n    //\n    // from object\n    //\n    public String toString() {\n        StringBuffer b = new StringBuffer(_className.replace('/', '.'));\n        b.append(':');\n        b.append(_methodName);\n        return b.toString();\n    }\n\n    @Override\n    public boolean equals(Object other) {\n        assert other instanceof Method;\n        Method m = (Method) other;\n        return this._className.equals(m._className) && this._methodName.equals(m._methodName);\n    }\n\n    @Override\n    public int hashCode() {\n        return _className.hashCode() + _methodName.hashCode();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/com/mentorgen/tools/profile/runtime/MethodTest0.java",
		"test_prompt": "// MethodTest0.java\npackage com.mentorgen.tools.profile.runtime;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Method}.\n* It contains ten unit test cases for the {@link Method#equals(Object)} method.\n*/\nclass MethodTest0 {"
	},
	{
		"original_code": "// Method.java\n/*\nCopyright (c) 2005, MentorGen, LLC\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions are met:\n\n+ Redistributions of source code must retain the above copyright notice, \n  this list of conditions and the following disclaimer.\n+ Redistributions in binary form must reproduce the above copyright notice, \n  this list of conditions and the following disclaimer in the documentation \n  and/or other materials provided with the distribution.\n+ Neither the name of MentorGen LLC nor the names of its contributors may be \n  used to endorse or promote products derived from this software without \n  specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \n  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE \n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \n  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \n  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \n  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n  POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.mentorgen.tools.profile.runtime;\n\n/**\n * A simple class to capture metrics for a method in a particular thread\n *\n * @author Andrew Wilcox\n */\nfinal class Method {\n\n    private String _className;\n\n    private String _methodName;\n\n    Method(String className, String method) {\n        _className = className;\n        _methodName = method;\n    }\n\n    String getClassName() {\n        return _className;\n    }\n\n    String getMethodName() {\n        return _methodName;\n    }\n\n    String toInvertedString() {\n        String className = _className.replace('/', '.');\n        int index = className.lastIndexOf('.');\n        String shortName = null;\n        String packageName = \"\";\n        if (index > -1) {\n            shortName = className.substring(index + 1);\n            packageName = className.substring(0, index);\n        } else {\n            shortName = className;\n        }\n        StringBuffer b = new StringBuffer();\n        b.append(shortName);\n        b.append(':');\n        b.append(_methodName);\n        b.append(\"\\t(\");\n        b.append(packageName);\n        b.append(\")\");\n        return b.toString();\n    }\n\n    //\n    // from object\n    //\n    public String toString() {\n        StringBuffer b = new StringBuffer(_className.replace('/', '.'));\n        b.append(':');\n        b.append(_methodName);\n        return b.toString();\n    }\n\n    @Override\n    public boolean equals(Object other) {\n        assert other instanceof Method;\n        Method m = (Method) other;\n        return this._className.equals(m._className) && this._methodName.equals(m._methodName);\n    }\n\n    @Override\n    public int hashCode() {\n        return _className.hashCode() + _methodName.hashCode();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/com/mentorgen/tools/profile/runtime/MethodTest1.java",
		"test_prompt": "// MethodTest1.java\npackage com.mentorgen.tools.profile.runtime;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Method}.\n* It contains ten unit test cases for the {@link Method#hashCode()} method.\n*/\nclass MethodTest1 {"
	},
	{
		"original_code": "// Frame.java\n/*\nCopyright (c) 2005 - 2006, MentorGen, LLC\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions are met:\n\n+ Redistributions of source code must retain the above copyright notice, \n  this list of conditions and the following disclaimer.\n+ Redistributions in binary form must reproduce the above copyright notice, \n  this list of conditions and the following disclaimer in the documentation \n  and/or other materials provided with the distribution.\n+ Neither the name of MentorGen LLC nor the names of its contributors may be \n  used to endorse or promote products derived from this software without \n  specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \n  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE \n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \n  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \n  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \n  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n  POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.mentorgen.tools.profile.runtime;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Map;\nimport com.mentorgen.tools.profile.Controller;\n\n/**\n * Models a (call) stack frame.\n *\n * @author Andrew Wilcox\n */\npublic final class Frame {\n\n    // identification\n    //\n    private Method _method;\n\n    private Frame _parent;\n\n    private long _netTime = 0;\n\n    private long _threadId;\n\n    private Map<Method, Frame> _children = new HashMap<Method, Frame>();\n\n    private ArrayList<Frame> _childList = new ArrayList<Frame>();\n\n    // metrics\n    //\n    public Metrics _metrics = new Metrics();\n\n    private long _lastStartTime = 0;\n\n    private long _lastWaitStartTime = 0;\n\n    private long _waitTime = 0;\n\n    private Frame() {\n    }\n\n    Frame(Frame parent, Method method, long threadId) {\n        assert method != null;\n        _parent = parent;\n        _method = method;\n        _threadId = threadId;\n        if (parent != null) {\n            parent.addChild(method, this);\n        }\n    }\n\n    //\n    // from object\n    //\n    // for debugging\n    public String toString() {\n        StringBuffer b = new StringBuffer();\n        toStringBuffer(b, 0);\n        return b.toString();\n    }\n\n    //\n    // public query methods\n    //\n    public long getThreadId() {\n        return _threadId;\n    }\n\n    public String getName() {\n        return _method.toString();\n    }\n\n    public String getInvertedName() {\n        return _method.toInvertedString();\n    }\n\n    public String getClassName() {\n        return _method.getClassName();\n    }\n\n    public String getMethodName() {\n        return _method.getMethodName();\n    }\n\n    public Iterable<Frame> childIterator() {\n        return _childList;\n    }\n\n    public boolean hasChildren() {\n        return _childList.size() > 0;\n    }\n\n    public Frame getParent() {\n        return _parent;\n    }\n\n    public long netTime() {\n        return _netTime;\n    }\n\n    //\n    // public \"action\" methods\n    //\n    void computeNetTime() {\n        long childTime = 0;\n        for (Frame child : _childList) {\n            childTime += child._metrics.getTotalTime();\n        }\n        _netTime = _metrics.getTotalTime() - childTime - _waitTime;\n        if (_netTime < 0) {\n            _netTime = 0;\n        }\n    }\n\n    //\n    // package methods used by the runtime profiler\n    //\n    void setBeginTime(long time) {\n        _lastStartTime = time;\n    }\n\n    void setEndTime(long endTime) {\n        if (_lastStartTime == 0) {\n            _metrics.inc(0);\n        } else if (0 < (endTime - _lastStartTime)) {\n            _metrics.inc(endTime - _lastStartTime);\n        } else {\n            _metrics.inc(0);\n        }\n        _lastStartTime = 0;\n    }\n\n    void beginWait(long time) {\n        _lastWaitStartTime = time;\n    }\n\n    void endWait(long time) {\n        if (0 < (time - _lastWaitStartTime)) {\n            _waitTime += (time - _lastWaitStartTime);\n        }\n        _lastWaitStartTime = 0;\n    }\n\n    Frame getChild(Method m) {\n        return _children.get(m);\n    }\n\n    void overhead(long overhead) {\n        _metrics.adjust(overhead);\n    }\n\n    void close() {\n        if (_lastStartTime > 0) {\n            this.setEndTime(System.nanoTime());\n            if (Controller._debug) {\n                System.err.print(\"Fixup: \");\n                System.err.println(_method);\n            }\n        }\n        // make sure that all of the child frames are closed\n        //\n        for (Frame child : _childList) {\n            child.close();\n        }\n    }\n\n    //\n    // private\n    //\n    private void addChild(Method m, Frame f) {\n        _children.put(m, f);\n        _childList.add(f);\n    }\n\n    // very similar to a section of FrameDump\n    private void toStringBuffer(StringBuffer b, int depth) {\n        if (depth > 5) {\n            return;\n        }\n        b.append(\" \");\n        for (int i = 0; i < depth; i++) {\n            b.append(\"| \");\n        }\n        b.append(\"+--\");\n        b.append(this.getInvertedName());\n        b.append(System.getProperty(\"line.separator\"));\n        if (Controller._threadDepth != Controller.UNLIMITED && depth == Controller._threadDepth - 1) {\n            return;\n        }\n        for (Frame child : _childList) {\n            if (Controller._compactThreadDepth && child._metrics.getTotalTime() < Controller._compactThreadThreshold * 1000000) {\n                continue;\n            }\n            child.toStringBuffer(b, depth + 1);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/com/mentorgen/tools/profile/runtime/FrameTest0.java",
		"test_prompt": "// FrameTest0.java\npackage com.mentorgen.tools.profile.runtime;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Map;\nimport com.mentorgen.tools.profile.Controller;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Frame}.\n* It contains ten unit test cases for the {@link Frame#childIterator()} method.\n*/\nclass FrameTest0 {"
	},
	{
		"original_code": "// Frame.java\n/*\nCopyright (c) 2005 - 2006, MentorGen, LLC\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions are met:\n\n+ Redistributions of source code must retain the above copyright notice, \n  this list of conditions and the following disclaimer.\n+ Redistributions in binary form must reproduce the above copyright notice, \n  this list of conditions and the following disclaimer in the documentation \n  and/or other materials provided with the distribution.\n+ Neither the name of MentorGen LLC nor the names of its contributors may be \n  used to endorse or promote products derived from this software without \n  specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \n  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE \n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \n  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \n  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \n  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n  POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.mentorgen.tools.profile.runtime;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Map;\nimport com.mentorgen.tools.profile.Controller;\n\n/**\n * Models a (call) stack frame.\n *\n * @author Andrew Wilcox\n */\npublic final class Frame {\n\n    // identification\n    //\n    private Method _method;\n\n    private Frame _parent;\n\n    private long _netTime = 0;\n\n    private long _threadId;\n\n    private Map<Method, Frame> _children = new HashMap<Method, Frame>();\n\n    private ArrayList<Frame> _childList = new ArrayList<Frame>();\n\n    // metrics\n    //\n    public Metrics _metrics = new Metrics();\n\n    private long _lastStartTime = 0;\n\n    private long _lastWaitStartTime = 0;\n\n    private long _waitTime = 0;\n\n    private Frame() {\n    }\n\n    Frame(Frame parent, Method method, long threadId) {\n        assert method != null;\n        _parent = parent;\n        _method = method;\n        _threadId = threadId;\n        if (parent != null) {\n            parent.addChild(method, this);\n        }\n    }\n\n    //\n    // from object\n    //\n    // for debugging\n    public String toString() {\n        StringBuffer b = new StringBuffer();\n        toStringBuffer(b, 0);\n        return b.toString();\n    }\n\n    //\n    // public query methods\n    //\n    public long getThreadId() {\n        return _threadId;\n    }\n\n    public String getName() {\n        return _method.toString();\n    }\n\n    public String getInvertedName() {\n        return _method.toInvertedString();\n    }\n\n    public String getClassName() {\n        return _method.getClassName();\n    }\n\n    public String getMethodName() {\n        return _method.getMethodName();\n    }\n\n    public Iterable<Frame> childIterator() {\n        return _childList;\n    }\n\n    public boolean hasChildren() {\n        return _childList.size() > 0;\n    }\n\n    public Frame getParent() {\n        return _parent;\n    }\n\n    public long netTime() {\n        return _netTime;\n    }\n\n    //\n    // public \"action\" methods\n    //\n    void computeNetTime() {\n        long childTime = 0;\n        for (Frame child : _childList) {\n            childTime += child._metrics.getTotalTime();\n        }\n        _netTime = _metrics.getTotalTime() - childTime - _waitTime;\n        if (_netTime < 0) {\n            _netTime = 0;\n        }\n    }\n\n    //\n    // package methods used by the runtime profiler\n    //\n    void setBeginTime(long time) {\n        _lastStartTime = time;\n    }\n\n    void setEndTime(long endTime) {\n        if (_lastStartTime == 0) {\n            _metrics.inc(0);\n        } else if (0 < (endTime - _lastStartTime)) {\n            _metrics.inc(endTime - _lastStartTime);\n        } else {\n            _metrics.inc(0);\n        }\n        _lastStartTime = 0;\n    }\n\n    void beginWait(long time) {\n        _lastWaitStartTime = time;\n    }\n\n    void endWait(long time) {\n        if (0 < (time - _lastWaitStartTime)) {\n            _waitTime += (time - _lastWaitStartTime);\n        }\n        _lastWaitStartTime = 0;\n    }\n\n    Frame getChild(Method m) {\n        return _children.get(m);\n    }\n\n    void overhead(long overhead) {\n        _metrics.adjust(overhead);\n    }\n\n    void close() {\n        if (_lastStartTime > 0) {\n            this.setEndTime(System.nanoTime());\n            if (Controller._debug) {\n                System.err.print(\"Fixup: \");\n                System.err.println(_method);\n            }\n        }\n        // make sure that all of the child frames are closed\n        //\n        for (Frame child : _childList) {\n            child.close();\n        }\n    }\n\n    //\n    // private\n    //\n    private void addChild(Method m, Frame f) {\n        _children.put(m, f);\n        _childList.add(f);\n    }\n\n    // very similar to a section of FrameDump\n    private void toStringBuffer(StringBuffer b, int depth) {\n        if (depth > 5) {\n            return;\n        }\n        b.append(\" \");\n        for (int i = 0; i < depth; i++) {\n            b.append(\"| \");\n        }\n        b.append(\"+--\");\n        b.append(this.getInvertedName());\n        b.append(System.getProperty(\"line.separator\"));\n        if (Controller._threadDepth != Controller.UNLIMITED && depth == Controller._threadDepth - 1) {\n            return;\n        }\n        for (Frame child : _childList) {\n            if (Controller._compactThreadDepth && child._metrics.getTotalTime() < Controller._compactThreadThreshold * 1000000) {\n                continue;\n            }\n            child.toStringBuffer(b, depth + 1);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/com/mentorgen/tools/profile/runtime/FrameTest1.java",
		"test_prompt": "// FrameTest1.java\npackage com.mentorgen.tools.profile.runtime;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Map;\nimport com.mentorgen.tools.profile.Controller;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Frame}.\n* It contains ten unit test cases for the {@link Frame#hasChildren()} method.\n*/\nclass FrameTest1 {"
	},
	{
		"original_code": "// Frame.java\n/*\nCopyright (c) 2005 - 2006, MentorGen, LLC\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions are met:\n\n+ Redistributions of source code must retain the above copyright notice, \n  this list of conditions and the following disclaimer.\n+ Redistributions in binary form must reproduce the above copyright notice, \n  this list of conditions and the following disclaimer in the documentation \n  and/or other materials provided with the distribution.\n+ Neither the name of MentorGen LLC nor the names of its contributors may be \n  used to endorse or promote products derived from this software without \n  specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \n  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE \n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \n  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \n  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \n  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n  POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.mentorgen.tools.profile.runtime;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Map;\nimport com.mentorgen.tools.profile.Controller;\n\n/**\n * Models a (call) stack frame.\n *\n * @author Andrew Wilcox\n */\npublic final class Frame {\n\n    // identification\n    //\n    private Method _method;\n\n    private Frame _parent;\n\n    private long _netTime = 0;\n\n    private long _threadId;\n\n    private Map<Method, Frame> _children = new HashMap<Method, Frame>();\n\n    private ArrayList<Frame> _childList = new ArrayList<Frame>();\n\n    // metrics\n    //\n    public Metrics _metrics = new Metrics();\n\n    private long _lastStartTime = 0;\n\n    private long _lastWaitStartTime = 0;\n\n    private long _waitTime = 0;\n\n    private Frame() {\n    }\n\n    Frame(Frame parent, Method method, long threadId) {\n        assert method != null;\n        _parent = parent;\n        _method = method;\n        _threadId = threadId;\n        if (parent != null) {\n            parent.addChild(method, this);\n        }\n    }\n\n    //\n    // from object\n    //\n    // for debugging\n    public String toString() {\n        StringBuffer b = new StringBuffer();\n        toStringBuffer(b, 0);\n        return b.toString();\n    }\n\n    //\n    // public query methods\n    //\n    public long getThreadId() {\n        return _threadId;\n    }\n\n    public String getName() {\n        return _method.toString();\n    }\n\n    public String getInvertedName() {\n        return _method.toInvertedString();\n    }\n\n    public String getClassName() {\n        return _method.getClassName();\n    }\n\n    public String getMethodName() {\n        return _method.getMethodName();\n    }\n\n    public Iterable<Frame> childIterator() {\n        return _childList;\n    }\n\n    public boolean hasChildren() {\n        return _childList.size() > 0;\n    }\n\n    public Frame getParent() {\n        return _parent;\n    }\n\n    public long netTime() {\n        return _netTime;\n    }\n\n    //\n    // public \"action\" methods\n    //\n    void computeNetTime() {\n        long childTime = 0;\n        for (Frame child : _childList) {\n            childTime += child._metrics.getTotalTime();\n        }\n        _netTime = _metrics.getTotalTime() - childTime - _waitTime;\n        if (_netTime < 0) {\n            _netTime = 0;\n        }\n    }\n\n    //\n    // package methods used by the runtime profiler\n    //\n    void setBeginTime(long time) {\n        _lastStartTime = time;\n    }\n\n    void setEndTime(long endTime) {\n        if (_lastStartTime == 0) {\n            _metrics.inc(0);\n        } else if (0 < (endTime - _lastStartTime)) {\n            _metrics.inc(endTime - _lastStartTime);\n        } else {\n            _metrics.inc(0);\n        }\n        _lastStartTime = 0;\n    }\n\n    void beginWait(long time) {\n        _lastWaitStartTime = time;\n    }\n\n    void endWait(long time) {\n        if (0 < (time - _lastWaitStartTime)) {\n            _waitTime += (time - _lastWaitStartTime);\n        }\n        _lastWaitStartTime = 0;\n    }\n\n    Frame getChild(Method m) {\n        return _children.get(m);\n    }\n\n    void overhead(long overhead) {\n        _metrics.adjust(overhead);\n    }\n\n    void close() {\n        if (_lastStartTime > 0) {\n            this.setEndTime(System.nanoTime());\n            if (Controller._debug) {\n                System.err.print(\"Fixup: \");\n                System.err.println(_method);\n            }\n        }\n        // make sure that all of the child frames are closed\n        //\n        for (Frame child : _childList) {\n            child.close();\n        }\n    }\n\n    //\n    // private\n    //\n    private void addChild(Method m, Frame f) {\n        _children.put(m, f);\n        _childList.add(f);\n    }\n\n    // very similar to a section of FrameDump\n    private void toStringBuffer(StringBuffer b, int depth) {\n        if (depth > 5) {\n            return;\n        }\n        b.append(\" \");\n        for (int i = 0; i < depth; i++) {\n            b.append(\"| \");\n        }\n        b.append(\"+--\");\n        b.append(this.getInvertedName());\n        b.append(System.getProperty(\"line.separator\"));\n        if (Controller._threadDepth != Controller.UNLIMITED && depth == Controller._threadDepth - 1) {\n            return;\n        }\n        for (Frame child : _childList) {\n            if (Controller._compactThreadDepth && child._metrics.getTotalTime() < Controller._compactThreadThreshold * 1000000) {\n                continue;\n            }\n            child.toStringBuffer(b, depth + 1);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/com/mentorgen/tools/profile/runtime/FrameTest2.java",
		"test_prompt": "// FrameTest2.java\npackage com.mentorgen.tools.profile.runtime;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Map;\nimport com.mentorgen.tools.profile.Controller;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Frame}.\n* It contains ten unit test cases for the {@link Frame#netTime()} method.\n*/\nclass FrameTest2 {"
	},
	{
		"original_code": "// Math.java\npackage com.mentorgen.tools.profile.output;\n\nfinal class Math {\n\n    public static double nanoToMilli(long time) {\n        return ((double) time) / 1000000;\n    }\n\n    public static double toPercent(long num, double denom) {\n        return (((double) num) / denom) * 100;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/com/mentorgen/tools/profile/output/MathTest0.java",
		"test_prompt": "// MathTest0.java\npackage com.mentorgen.tools.profile.output;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Math}.\n* It contains ten unit test cases for the {@link Math#nanoToMilli(long)} method.\n*/\nclass MathTest0 {"
	},
	{
		"original_code": "// Math.java\npackage com.mentorgen.tools.profile.output;\n\nfinal class Math {\n\n    public static double nanoToMilli(long time) {\n        return ((double) time) / 1000000;\n    }\n\n    public static double toPercent(long num, double denom) {\n        return (((double) num) / denom) * 100;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/com/mentorgen/tools/profile/output/MathTest1.java",
		"test_prompt": "// MathTest1.java\npackage com.mentorgen.tools.profile.output;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Math}.\n* It contains ten unit test cases for the {@link Math#toPercent(long, double)} method.\n*/\nclass MathTest1 {"
	},
	{
		"original_code": "// TableSorter.java\n//\n// The Swing JTable tutorial includes the TableSorter class in this file saying\n// \"You can use TableSorter as-is to provide sorting functionality...\". I've\n// added the sample code license text I found on the tutorial site.  I also\n// added the trivial viewIndex() method.  -- ab\n//\n// Useful links:\n//\n//  \"How to Use Tables\":\n//     http://java.sun.com/docs/books/tutorial/uiswing/components/table.html\n//\n//  TableSorter.java:\n//     http://java.sun.com/docs/books/tutorial/uiswing/components/example-1dot4/TableSorter.java\n//\n//  \"Building GUIs with JFC/Swing APIs Code Samples\":\n//    http://java.sun.com/developer/codesamples/swing.html\n//\n//  License pointed at by \"Building GUIs...\" document.\n//    http://developers.sun.com/license/berkeley_license.html\n//\n/*/////////////////////////////////////////////////////////////////////\n\nCopyright 1994-2006 Sun Microsystems, Inc. All Rights Reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n \n\n    * Redistribution of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistribution in binary form must reproduce the above copyright notice,\n      this list of conditions and the following disclaimer in the documentation\n      and/or other materials provided with the distribution.\n\n \nNeither the name of Sun Microsystems, Inc. or the names of contributors may be\nused to endorse or promote products derived from this software without specific\nprior written permission.\n \nThis software is provided \"AS IS,\" without a warranty of any kind. ALL EXPRESS\nOR IMPLIED CONDITIONS, REPRESENTATIONS AND WARRANTIES, INCLUDING ANY IMPLIED\nWARRANTY OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR\nNON-INFRINGEMENT, ARE HEREBY EXCLUDED. SUN MICROSYSTEMS, INC. (\"SUN\") AND ITS\nLICENSORS SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT\nOF USING, MODIFYING OR DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES. IN NO\nEVENT WILL SUN OR ITS LICENSORS BE LIABLE FOR ANY LOST REVENUE, PROFIT OR DATA,\nOR FOR DIRECT, INDIRECT, SPECIAL, CONSEQUENTIAL, INCIDENTAL OR PUNITIVE\nDAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT\nOF THE USE OF OR INABILITY TO USE THIS SOFTWARE, EVEN IF SUN HAS BEEN ADVISED\nOF THE POSSIBILITY OF SUCH DAMAGES.\n \nYou acknowledge that this software is not designed, licensed or intended for\nuse in the design, construction, operation or maintenance of any nuclear\nfacility.\n\n/////////////////////////////////////////////////////////////////////*/\npackage com.tivo.jipviewer;\n\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.util.*;\nimport java.util.List;\nimport javax.swing.*;\nimport javax.swing.event.TableModelEvent;\nimport javax.swing.event.TableModelListener;\nimport javax.swing.table.*;\n\n/**\n * TableSorter is a decorator for TableModels; adding sorting\n * functionality to a supplied TableModel. TableSorter does\n * not store or copy the data in its TableModel; instead it maintains\n * a map from the row indexes of the view to the row indexes of the\n * model. As requests are made of the sorter (like getValueAt(row, col))\n * they are passed to the underlying model after the row numbers\n * have been translated via the internal mapping array. This way,\n * the TableSorter appears to hold another copy of the table\n * with the rows in a different order.\n * <p/>\n * TableSorter registers itself as a listener to the underlying model,\n * just as the JTable itself would. Events recieved from the model\n * are examined, sometimes manipulated (typically widened), and then\n * passed on to the TableSorter's listeners (typically the JTable).\n * If a change to the model has invalidated the order of TableSorter's\n * rows, a note of this is made and the sorter will resort the\n * rows the next time a value is requested.\n * <p/>\n * When the tableHeader property is set, either by using the\n * setTableHeader() method or the two argument constructor, the\n * table header may be used as a complete UI for TableSorter.\n * The default renderer of the tableHeader is decorated with a renderer\n * that indicates the sorting status of each column. In addition,\n * a mouse listener is installed with the following behavior:\n * <ul>\n * <li>\n * Mouse-click: Clears the sorting status of all other columns\n * and advances the sorting status of that column through three\n * values: {NOT_SORTED, ASCENDING, DESCENDING} (then back to\n * NOT_SORTED again).\n * <li>\n * SHIFT-mouse-click: Clears the sorting status of all other columns\n * and cycles the sorting status of the column through the same\n * three values, in the opposite order: {NOT_SORTED, DESCENDING, ASCENDING}.\n * <li>\n * CONTROL-mouse-click and CONTROL-SHIFT-mouse-click: as above except\n * that the changes to the column do not cancel the statuses of columns\n * that are already sorting - giving a way to initiate a compound\n * sort.\n * </ul>\n * <p/>\n * This is a long overdue rewrite of a class of the same name that\n * first appeared in the swing table demos in 1997.\n *\n * @author Philip Milne\n * @author Brendon McLean\n * @author Dan van Enckevort\n * @author Parwinder Sekhon\n * @version 2.0 02/27/04\n */\npublic class TableSorter extends AbstractTableModel {\n\n    protected TableModel tableModel;\n\n    public static final int DESCENDING = -1;\n\n    public static final int NOT_SORTED = 0;\n\n    public static final int ASCENDING = 1;\n\n    private static Directive EMPTY_DIRECTIVE = new Directive(-1, NOT_SORTED);\n\n    public static final Comparator COMPARABLE_COMAPRATOR = new Comparator() {\n\n        public int compare(Object o1, Object o2) {\n            return ((Comparable) o1).compareTo(o2);\n        }\n    };\n\n    public static final Comparator LEXICAL_COMPARATOR = new Comparator() {\n\n        public int compare(Object o1, Object o2) {\n            return o1.toString().compareTo(o2.toString());\n        }\n    };\n\n    private Row[] viewToModel;\n\n    private int[] modelToView;\n\n    private JTableHeader tableHeader;\n\n    private MouseListener mouseListener;\n\n    private TableModelListener tableModelListener;\n\n    private Map columnComparators = new HashMap();\n\n    private List sortingColumns = new ArrayList();\n\n    public TableSorter() {\n        this.mouseListener = new MouseHandler();\n        this.tableModelListener = new TableModelHandler();\n    }\n\n    public TableSorter(TableModel tableModel) {\n        this();\n        setTableModel(tableModel);\n    }\n\n    public TableSorter(TableModel tableModel, JTableHeader tableHeader) {\n        this();\n        setTableHeader(tableHeader);\n        setTableModel(tableModel);\n    }\n\n    private void clearSortingState() {\n        viewToModel = null;\n        modelToView = null;\n    }\n\n    public TableModel getTableModel() {\n        return tableModel;\n    }\n\n    public void setTableModel(TableModel tableModel) {\n        if (this.tableModel != null) {\n            this.tableModel.removeTableModelListener(tableModelListener);\n        }\n        this.tableModel = tableModel;\n        if (this.tableModel != null) {\n            this.tableModel.addTableModelListener(tableModelListener);\n        }\n        clearSortingState();\n        fireTableStructureChanged();\n    }\n\n    public JTableHeader getTableHeader() {\n        return tableHeader;\n    }\n\n    public void setTableHeader(JTableHeader tableHeader) {\n        if (this.tableHeader != null) {\n            this.tableHeader.removeMouseListener(mouseListener);\n            TableCellRenderer defaultRenderer = this.tableHeader.getDefaultRenderer();\n            if (defaultRenderer instanceof SortableHeaderRenderer) {\n                this.tableHeader.setDefaultRenderer(((SortableHeaderRenderer) defaultRenderer).tableCellRenderer);\n            }\n        }\n        this.tableHeader = tableHeader;\n        if (this.tableHeader != null) {\n            this.tableHeader.addMouseListener(mouseListener);\n            this.tableHeader.setDefaultRenderer(new SortableHeaderRenderer(this.tableHeader.getDefaultRenderer()));\n        }\n    }\n\n    public boolean isSorting() {\n        return sortingColumns.size() != 0;\n    }\n\n    private Directive getDirective(int column) {\n        for (int i = 0; i < sortingColumns.size(); i++) {\n            Directive directive = (Directive) sortingColumns.get(i);\n            if (directive.column == column) {\n                return directive;\n            }\n        }\n        return EMPTY_DIRECTIVE;\n    }\n\n    public int getSortingStatus(int column) {\n        return getDirective(column).direction;\n    }\n\n    private void sortingStatusChanged() {\n        clearSortingState();\n        fireTableDataChanged();\n        if (tableHeader != null) {\n            tableHeader.repaint();\n        }\n    }\n\n    public void setSortingStatus(int column, int status) {\n        Directive directive = getDirective(column);\n        if (directive != EMPTY_DIRECTIVE) {\n            sortingColumns.remove(directive);\n        }\n        if (status != NOT_SORTED) {\n            sortingColumns.add(new Directive(column, status));\n        }\n        sortingStatusChanged();\n    }\n\n    protected Icon getHeaderRendererIcon(int column, int size) {\n        Directive directive = getDirective(column);\n        if (directive == EMPTY_DIRECTIVE) {\n            return null;\n        }\n        return new Arrow(directive.direction == DESCENDING, size, sortingColumns.indexOf(directive));\n    }\n\n    private void cancelSorting() {\n        sortingColumns.clear();\n        sortingStatusChanged();\n    }\n\n    public void setColumnComparator(Class type, Comparator comparator) {\n        if (comparator == null) {\n            columnComparators.remove(type);\n        } else {\n            columnComparators.put(type, comparator);\n        }\n    }\n\n    protected Comparator getComparator(int column) {\n        Class columnType = tableModel.getColumnClass(column);\n        Comparator comparator = (Comparator) columnComparators.get(columnType);\n        if (comparator != null) {\n            return comparator;\n        }\n        if (Comparable.class.isAssignableFrom(columnType)) {\n            return COMPARABLE_COMAPRATOR;\n        }\n        return LEXICAL_COMPARATOR;\n    }\n\n    private Row[] getViewToModel() {\n        if (viewToModel == null) {\n            int tableModelRowCount = tableModel.getRowCount();\n            viewToModel = new Row[tableModelRowCount];\n            for (int row = 0; row < tableModelRowCount; row++) {\n                viewToModel[row] = new Row(row);\n            }\n            if (isSorting()) {\n                Arrays.sort(viewToModel);\n            }\n        }\n        return viewToModel;\n    }\n\n    public int modelIndex(int viewIndex) {\n        return getViewToModel()[viewIndex].modelIndex;\n    }\n\n    public int viewIndex(int modelIndex) {\n        return getModelToView()[modelIndex];\n    }\n\n    private int[] getModelToView() {\n        if (modelToView == null) {\n            int n = getViewToModel().length;\n            modelToView = new int[n];\n            for (int i = 0; i < n; i++) {\n                modelToView[modelIndex(i)] = i;\n            }\n        }\n        return modelToView;\n    }\n\n    // TableModel interface methods\n    public int getRowCount() {\n        return (tableModel == null) ? 0 : tableModel.getRowCount();\n    }\n\n    public int getColumnCount() {\n        return (tableModel == null) ? 0 : tableModel.getColumnCount();\n    }\n\n    public String getColumnName(int column) {\n        return tableModel.getColumnName(column);\n    }\n\n    public Class getColumnClass(int column) {\n        return tableModel.getColumnClass(column);\n    }\n\n    public boolean isCellEditable(int row, int column) {\n        return tableModel.isCellEditable(modelIndex(row), column);\n    }\n\n    public Object getValueAt(int row, int column) {\n        return tableModel.getValueAt(modelIndex(row), column);\n    }\n\n    public void setValueAt(Object aValue, int row, int column) {\n        tableModel.setValueAt(aValue, modelIndex(row), column);\n    }\n\n    // Helper classes\n    private class Row implements Comparable {\n\n        private int modelIndex;\n\n        public Row(int index) {\n            this.modelIndex = index;\n        }\n\n        public int compareTo(Object o) {\n            int row1 = modelIndex;\n            int row2 = ((Row) o).modelIndex;\n            for (Iterator it = sortingColumns.iterator(); it.hasNext(); ) {\n                Directive directive = (Directive) it.next();\n                int column = directive.column;\n                Object o1 = tableModel.getValueAt(row1, column);\n                Object o2 = tableModel.getValueAt(row2, column);\n                int comparison = 0;\n                // Define null less than everything, except null.\n                if (o1 == null && o2 == null) {\n                    comparison = 0;\n                } else if (o1 == null) {\n                    comparison = -1;\n                } else if (o2 == null) {\n                    comparison = 1;\n                } else {\n                    comparison = getComparator(column).compare(o1, o2);\n                }\n                if (comparison != 0) {\n                    return directive.direction == DESCENDING ? -comparison : comparison;\n                }\n            }\n            return 0;\n        }\n    }\n\n    private class TableModelHandler implements TableModelListener {\n\n        public void tableChanged(TableModelEvent e) {\n            // If we're not sorting by anything, just pass the event along.\n            if (!isSorting()) {\n                clearSortingState();\n                fireTableChanged(e);\n                return;\n            }\n            // If the table structure has changed, cancel the sorting; the\n            // sorting columns may have been either moved or deleted from\n            // the model.\n            if (e.getFirstRow() == TableModelEvent.HEADER_ROW) {\n                cancelSorting();\n                fireTableChanged(e);\n                return;\n            }\n            // We can map a cell event through to the view without widening\n            // when the following conditions apply:\n            //\n            // a) all the changes are on one row (e.getFirstRow() == e.getLastRow()) and,\n            // b) all the changes are in one column (column != TableModelEvent.ALL_COLUMNS) and,\n            // c) we are not sorting on that column (getSortingStatus(column) == NOT_SORTED) and,\n            // d) a reverse lookup will not trigger a sort (modelToView != null)\n            //\n            // Note: INSERT and DELETE events fail this test as they have column == ALL_COLUMNS.\n            //\n            // The last check, for (modelToView != null) is to see if modelToView\n            // is already allocated. If we don't do this check; sorting can become\n            // a performance bottleneck for applications where cells\n            // change rapidly in different parts of the table. If cells\n            // change alternately in the sorting column and then outside of\n            // it this class can end up re-sorting on alternate cell updates -\n            // which can be a performance problem for large tables. The last\n            // clause avoids this problem.\n            int column = e.getColumn();\n            if (e.getFirstRow() == e.getLastRow() && column != TableModelEvent.ALL_COLUMNS && getSortingStatus(column) == NOT_SORTED && modelToView != null) {\n                int viewIndex = getModelToView()[e.getFirstRow()];\n                fireTableChanged(new TableModelEvent(TableSorter.this, viewIndex, viewIndex, column, e.getType()));\n                return;\n            }\n            // Something has happened to the data that may have invalidated the row order.\n            clearSortingState();\n            fireTableDataChanged();\n            return;\n        }\n    }\n\n    private class MouseHandler extends MouseAdapter {\n\n        public void mouseClicked(MouseEvent e) {\n            JTableHeader h = (JTableHeader) e.getSource();\n            TableColumnModel columnModel = h.getColumnModel();\n            int viewColumn = columnModel.getColumnIndexAtX(e.getX());\n            int column = columnModel.getColumn(viewColumn).getModelIndex();\n            if (column != -1) {\n                int status = getSortingStatus(column);\n                if (!e.isControlDown()) {\n                    cancelSorting();\n                }\n                // Cycle the sorting states through {NOT_SORTED, ASCENDING, DESCENDING} or\n                // {NOT_SORTED, DESCENDING, ASCENDING} depending on whether shift is pressed.\n                status = status + (e.isShiftDown() ? -1 : 1);\n                // signed mod, returning {-1, 0, 1}\n                status = (status + 4) % 3 - 1;\n                setSortingStatus(column, status);\n            }\n        }\n    }\n\n    private static class Arrow implements Icon {\n\n        private boolean descending;\n\n        private int size;\n\n        private int priority;\n\n        public Arrow(boolean descending, int size, int priority) {\n            this.descending = descending;\n            this.size = size;\n            this.priority = priority;\n        }\n\n        public void paintIcon(Component c, Graphics g, int x, int y) {\n            Color color = c == null ? Color.GRAY : c.getBackground();\n            // In a compound sort, make each succesive triangle 20%\n            // smaller than the previous one.\n            int dx = (int) (size / 2 * Math.pow(0.8, priority));\n            int dy = descending ? dx : -dx;\n            // Align icon (roughly) with font baseline.\n            y = y + 5 * size / 6 + (descending ? -dy : 0);\n            int shift = descending ? 1 : -1;\n            g.translate(x, y);\n            // Right diagonal.\n            g.setColor(color.darker());\n            g.drawLine(dx / 2, dy, 0, 0);\n            g.drawLine(dx / 2, dy + shift, 0, shift);\n            // Left diagonal.\n            g.setColor(color.brighter());\n            g.drawLine(dx / 2, dy, dx, 0);\n            g.drawLine(dx / 2, dy + shift, dx, shift);\n            // Horizontal line.\n            if (descending) {\n                g.setColor(color.darker().darker());\n            } else {\n                g.setColor(color.brighter().brighter());\n            }\n            g.drawLine(dx, 0, 0, 0);\n            g.setColor(color);\n            g.translate(-x, -y);\n        }\n\n        public int getIconWidth() {\n            return size;\n        }\n\n        public int getIconHeight() {\n            return size;\n        }\n    }\n\n    private class SortableHeaderRenderer implements TableCellRenderer {\n\n        private TableCellRenderer tableCellRenderer;\n\n        public SortableHeaderRenderer(TableCellRenderer tableCellRenderer) {\n            this.tableCellRenderer = tableCellRenderer;\n        }\n\n        public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {\n            Component c = tableCellRenderer.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);\n            if (c instanceof JLabel) {\n                JLabel l = (JLabel) c;\n                l.setHorizontalTextPosition(JLabel.LEFT);\n                int modelColumn = table.convertColumnIndexToModel(column);\n                l.setIcon(getHeaderRendererIcon(modelColumn, l.getFont().getSize()));\n            }\n            return c;\n        }\n    }\n\n    private static class Directive {\n\n        private int column;\n\n        private int direction;\n\n        public Directive(int column, int direction) {\n            this.column = column;\n            this.direction = direction;\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/com/tivo/jipviewer/TableSorterTest0.java",
		"test_prompt": "// TableSorterTest0.java\n// The Swing JTable tutorial includes the TableSorter class in this file saying\n// \"You can use TableSorter as-is to provide sorting functionality...\". I've\n// added the sample code license text I found on the tutorial site.  I also\n// added the trivial viewIndex() method.  -- ab\n//\n// Useful links:\n//\n//  \"How to Use Tables\":\n//     http://java.sun.com/docs/books/tutorial/uiswing/components/table.html\n//\n//  TableSorter.java:\n//     http://java.sun.com/docs/books/tutorial/uiswing/components/example-1dot4/TableSorter.java\n//\n//  \"Building GUIs with JFC/Swing APIs Code Samples\":\n//    http://java.sun.com/developer/codesamples/swing.html\n//\n//  License pointed at by \"Building GUIs...\" document.\n//    http://developers.sun.com/license/berkeley_license.html\n//\n/*/////////////////////////////////////////////////////////////////////\n\nCopyright 1994-2006 Sun Microsystems, Inc. All Rights Reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n \n\n    * Redistribution of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistribution in binary form must reproduce the above copyright notice,\n      this list of conditions and the following disclaimer in the documentation\n      and/or other materials provided with the distribution.\n\n \nNeither the name of Sun Microsystems, Inc. or the names of contributors may be\nused to endorse or promote products derived from this software without specific\nprior written permission.\n \nThis software is provided \"AS IS,\" without a warranty of any kind. ALL EXPRESS\nOR IMPLIED CONDITIONS, REPRESENTATIONS AND WARRANTIES, INCLUDING ANY IMPLIED\nWARRANTY OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR\nNON-INFRINGEMENT, ARE HEREBY EXCLUDED. SUN MICROSYSTEMS, INC. (\"SUN\") AND ITS\nLICENSORS SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT\nOF USING, MODIFYING OR DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES. IN NO\nEVENT WILL SUN OR ITS LICENSORS BE LIABLE FOR ANY LOST REVENUE, PROFIT OR DATA,\nOR FOR DIRECT, INDIRECT, SPECIAL, CONSEQUENTIAL, INCIDENTAL OR PUNITIVE\nDAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT\nOF THE USE OF OR INABILITY TO USE THIS SOFTWARE, EVEN IF SUN HAS BEEN ADVISED\nOF THE POSSIBILITY OF SUCH DAMAGES.\n \nYou acknowledge that this software is not designed, licensed or intended for\nuse in the design, construction, operation or maintenance of any nuclear\nfacility.\n\n/////////////////////////////////////////////////////////////////////*/\npackage com.tivo.jipviewer;\n\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.util.*;\nimport java.util.List;\nimport javax.swing.*;\nimport javax.swing.event.TableModelEvent;\nimport javax.swing.event.TableModelListener;\nimport javax.swing.table.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TableSorter}.\n* It contains ten unit test cases for the {@link TableSorter#isSorting()} method.\n*/\nclass TableSorterTest0 {"
	},
	{
		"original_code": "// TableSorter.java\n//\n// The Swing JTable tutorial includes the TableSorter class in this file saying\n// \"You can use TableSorter as-is to provide sorting functionality...\". I've\n// added the sample code license text I found on the tutorial site.  I also\n// added the trivial viewIndex() method.  -- ab\n//\n// Useful links:\n//\n//  \"How to Use Tables\":\n//     http://java.sun.com/docs/books/tutorial/uiswing/components/table.html\n//\n//  TableSorter.java:\n//     http://java.sun.com/docs/books/tutorial/uiswing/components/example-1dot4/TableSorter.java\n//\n//  \"Building GUIs with JFC/Swing APIs Code Samples\":\n//    http://java.sun.com/developer/codesamples/swing.html\n//\n//  License pointed at by \"Building GUIs...\" document.\n//    http://developers.sun.com/license/berkeley_license.html\n//\n/*/////////////////////////////////////////////////////////////////////\n\nCopyright 1994-2006 Sun Microsystems, Inc. All Rights Reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n \n\n    * Redistribution of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistribution in binary form must reproduce the above copyright notice,\n      this list of conditions and the following disclaimer in the documentation\n      and/or other materials provided with the distribution.\n\n \nNeither the name of Sun Microsystems, Inc. or the names of contributors may be\nused to endorse or promote products derived from this software without specific\nprior written permission.\n \nThis software is provided \"AS IS,\" without a warranty of any kind. ALL EXPRESS\nOR IMPLIED CONDITIONS, REPRESENTATIONS AND WARRANTIES, INCLUDING ANY IMPLIED\nWARRANTY OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR\nNON-INFRINGEMENT, ARE HEREBY EXCLUDED. SUN MICROSYSTEMS, INC. (\"SUN\") AND ITS\nLICENSORS SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT\nOF USING, MODIFYING OR DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES. IN NO\nEVENT WILL SUN OR ITS LICENSORS BE LIABLE FOR ANY LOST REVENUE, PROFIT OR DATA,\nOR FOR DIRECT, INDIRECT, SPECIAL, CONSEQUENTIAL, INCIDENTAL OR PUNITIVE\nDAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT\nOF THE USE OF OR INABILITY TO USE THIS SOFTWARE, EVEN IF SUN HAS BEEN ADVISED\nOF THE POSSIBILITY OF SUCH DAMAGES.\n \nYou acknowledge that this software is not designed, licensed or intended for\nuse in the design, construction, operation or maintenance of any nuclear\nfacility.\n\n/////////////////////////////////////////////////////////////////////*/\npackage com.tivo.jipviewer;\n\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.util.*;\nimport java.util.List;\nimport javax.swing.*;\nimport javax.swing.event.TableModelEvent;\nimport javax.swing.event.TableModelListener;\nimport javax.swing.table.*;\n\n/**\n * TableSorter is a decorator for TableModels; adding sorting\n * functionality to a supplied TableModel. TableSorter does\n * not store or copy the data in its TableModel; instead it maintains\n * a map from the row indexes of the view to the row indexes of the\n * model. As requests are made of the sorter (like getValueAt(row, col))\n * they are passed to the underlying model after the row numbers\n * have been translated via the internal mapping array. This way,\n * the TableSorter appears to hold another copy of the table\n * with the rows in a different order.\n * <p/>\n * TableSorter registers itself as a listener to the underlying model,\n * just as the JTable itself would. Events recieved from the model\n * are examined, sometimes manipulated (typically widened), and then\n * passed on to the TableSorter's listeners (typically the JTable).\n * If a change to the model has invalidated the order of TableSorter's\n * rows, a note of this is made and the sorter will resort the\n * rows the next time a value is requested.\n * <p/>\n * When the tableHeader property is set, either by using the\n * setTableHeader() method or the two argument constructor, the\n * table header may be used as a complete UI for TableSorter.\n * The default renderer of the tableHeader is decorated with a renderer\n * that indicates the sorting status of each column. In addition,\n * a mouse listener is installed with the following behavior:\n * <ul>\n * <li>\n * Mouse-click: Clears the sorting status of all other columns\n * and advances the sorting status of that column through three\n * values: {NOT_SORTED, ASCENDING, DESCENDING} (then back to\n * NOT_SORTED again).\n * <li>\n * SHIFT-mouse-click: Clears the sorting status of all other columns\n * and cycles the sorting status of the column through the same\n * three values, in the opposite order: {NOT_SORTED, DESCENDING, ASCENDING}.\n * <li>\n * CONTROL-mouse-click and CONTROL-SHIFT-mouse-click: as above except\n * that the changes to the column do not cancel the statuses of columns\n * that are already sorting - giving a way to initiate a compound\n * sort.\n * </ul>\n * <p/>\n * This is a long overdue rewrite of a class of the same name that\n * first appeared in the swing table demos in 1997.\n *\n * @author Philip Milne\n * @author Brendon McLean\n * @author Dan van Enckevort\n * @author Parwinder Sekhon\n * @version 2.0 02/27/04\n */\npublic class TableSorter extends AbstractTableModel {\n\n    protected TableModel tableModel;\n\n    public static final int DESCENDING = -1;\n\n    public static final int NOT_SORTED = 0;\n\n    public static final int ASCENDING = 1;\n\n    private static Directive EMPTY_DIRECTIVE = new Directive(-1, NOT_SORTED);\n\n    public static final Comparator COMPARABLE_COMAPRATOR = new Comparator() {\n\n        public int compare(Object o1, Object o2) {\n            return ((Comparable) o1).compareTo(o2);\n        }\n    };\n\n    public static final Comparator LEXICAL_COMPARATOR = new Comparator() {\n\n        public int compare(Object o1, Object o2) {\n            return o1.toString().compareTo(o2.toString());\n        }\n    };\n\n    private Row[] viewToModel;\n\n    private int[] modelToView;\n\n    private JTableHeader tableHeader;\n\n    private MouseListener mouseListener;\n\n    private TableModelListener tableModelListener;\n\n    private Map columnComparators = new HashMap();\n\n    private List sortingColumns = new ArrayList();\n\n    public TableSorter() {\n        this.mouseListener = new MouseHandler();\n        this.tableModelListener = new TableModelHandler();\n    }\n\n    public TableSorter(TableModel tableModel) {\n        this();\n        setTableModel(tableModel);\n    }\n\n    public TableSorter(TableModel tableModel, JTableHeader tableHeader) {\n        this();\n        setTableHeader(tableHeader);\n        setTableModel(tableModel);\n    }\n\n    private void clearSortingState() {\n        viewToModel = null;\n        modelToView = null;\n    }\n\n    public TableModel getTableModel() {\n        return tableModel;\n    }\n\n    public void setTableModel(TableModel tableModel) {\n        if (this.tableModel != null) {\n            this.tableModel.removeTableModelListener(tableModelListener);\n        }\n        this.tableModel = tableModel;\n        if (this.tableModel != null) {\n            this.tableModel.addTableModelListener(tableModelListener);\n        }\n        clearSortingState();\n        fireTableStructureChanged();\n    }\n\n    public JTableHeader getTableHeader() {\n        return tableHeader;\n    }\n\n    public void setTableHeader(JTableHeader tableHeader) {\n        if (this.tableHeader != null) {\n            this.tableHeader.removeMouseListener(mouseListener);\n            TableCellRenderer defaultRenderer = this.tableHeader.getDefaultRenderer();\n            if (defaultRenderer instanceof SortableHeaderRenderer) {\n                this.tableHeader.setDefaultRenderer(((SortableHeaderRenderer) defaultRenderer).tableCellRenderer);\n            }\n        }\n        this.tableHeader = tableHeader;\n        if (this.tableHeader != null) {\n            this.tableHeader.addMouseListener(mouseListener);\n            this.tableHeader.setDefaultRenderer(new SortableHeaderRenderer(this.tableHeader.getDefaultRenderer()));\n        }\n    }\n\n    public boolean isSorting() {\n        return sortingColumns.size() != 0;\n    }\n\n    private Directive getDirective(int column) {\n        for (int i = 0; i < sortingColumns.size(); i++) {\n            Directive directive = (Directive) sortingColumns.get(i);\n            if (directive.column == column) {\n                return directive;\n            }\n        }\n        return EMPTY_DIRECTIVE;\n    }\n\n    public int getSortingStatus(int column) {\n        return getDirective(column).direction;\n    }\n\n    private void sortingStatusChanged() {\n        clearSortingState();\n        fireTableDataChanged();\n        if (tableHeader != null) {\n            tableHeader.repaint();\n        }\n    }\n\n    public void setSortingStatus(int column, int status) {\n        Directive directive = getDirective(column);\n        if (directive != EMPTY_DIRECTIVE) {\n            sortingColumns.remove(directive);\n        }\n        if (status != NOT_SORTED) {\n            sortingColumns.add(new Directive(column, status));\n        }\n        sortingStatusChanged();\n    }\n\n    protected Icon getHeaderRendererIcon(int column, int size) {\n        Directive directive = getDirective(column);\n        if (directive == EMPTY_DIRECTIVE) {\n            return null;\n        }\n        return new Arrow(directive.direction == DESCENDING, size, sortingColumns.indexOf(directive));\n    }\n\n    private void cancelSorting() {\n        sortingColumns.clear();\n        sortingStatusChanged();\n    }\n\n    public void setColumnComparator(Class type, Comparator comparator) {\n        if (comparator == null) {\n            columnComparators.remove(type);\n        } else {\n            columnComparators.put(type, comparator);\n        }\n    }\n\n    protected Comparator getComparator(int column) {\n        Class columnType = tableModel.getColumnClass(column);\n        Comparator comparator = (Comparator) columnComparators.get(columnType);\n        if (comparator != null) {\n            return comparator;\n        }\n        if (Comparable.class.isAssignableFrom(columnType)) {\n            return COMPARABLE_COMAPRATOR;\n        }\n        return LEXICAL_COMPARATOR;\n    }\n\n    private Row[] getViewToModel() {\n        if (viewToModel == null) {\n            int tableModelRowCount = tableModel.getRowCount();\n            viewToModel = new Row[tableModelRowCount];\n            for (int row = 0; row < tableModelRowCount; row++) {\n                viewToModel[row] = new Row(row);\n            }\n            if (isSorting()) {\n                Arrays.sort(viewToModel);\n            }\n        }\n        return viewToModel;\n    }\n\n    public int modelIndex(int viewIndex) {\n        return getViewToModel()[viewIndex].modelIndex;\n    }\n\n    public int viewIndex(int modelIndex) {\n        return getModelToView()[modelIndex];\n    }\n\n    private int[] getModelToView() {\n        if (modelToView == null) {\n            int n = getViewToModel().length;\n            modelToView = new int[n];\n            for (int i = 0; i < n; i++) {\n                modelToView[modelIndex(i)] = i;\n            }\n        }\n        return modelToView;\n    }\n\n    // TableModel interface methods\n    public int getRowCount() {\n        return (tableModel == null) ? 0 : tableModel.getRowCount();\n    }\n\n    public int getColumnCount() {\n        return (tableModel == null) ? 0 : tableModel.getColumnCount();\n    }\n\n    public String getColumnName(int column) {\n        return tableModel.getColumnName(column);\n    }\n\n    public Class getColumnClass(int column) {\n        return tableModel.getColumnClass(column);\n    }\n\n    public boolean isCellEditable(int row, int column) {\n        return tableModel.isCellEditable(modelIndex(row), column);\n    }\n\n    public Object getValueAt(int row, int column) {\n        return tableModel.getValueAt(modelIndex(row), column);\n    }\n\n    public void setValueAt(Object aValue, int row, int column) {\n        tableModel.setValueAt(aValue, modelIndex(row), column);\n    }\n\n    // Helper classes\n    private class Row implements Comparable {\n\n        private int modelIndex;\n\n        public Row(int index) {\n            this.modelIndex = index;\n        }\n\n        public int compareTo(Object o) {\n            int row1 = modelIndex;\n            int row2 = ((Row) o).modelIndex;\n            for (Iterator it = sortingColumns.iterator(); it.hasNext(); ) {\n                Directive directive = (Directive) it.next();\n                int column = directive.column;\n                Object o1 = tableModel.getValueAt(row1, column);\n                Object o2 = tableModel.getValueAt(row2, column);\n                int comparison = 0;\n                // Define null less than everything, except null.\n                if (o1 == null && o2 == null) {\n                    comparison = 0;\n                } else if (o1 == null) {\n                    comparison = -1;\n                } else if (o2 == null) {\n                    comparison = 1;\n                } else {\n                    comparison = getComparator(column).compare(o1, o2);\n                }\n                if (comparison != 0) {\n                    return directive.direction == DESCENDING ? -comparison : comparison;\n                }\n            }\n            return 0;\n        }\n    }\n\n    private class TableModelHandler implements TableModelListener {\n\n        public void tableChanged(TableModelEvent e) {\n            // If we're not sorting by anything, just pass the event along.\n            if (!isSorting()) {\n                clearSortingState();\n                fireTableChanged(e);\n                return;\n            }\n            // If the table structure has changed, cancel the sorting; the\n            // sorting columns may have been either moved or deleted from\n            // the model.\n            if (e.getFirstRow() == TableModelEvent.HEADER_ROW) {\n                cancelSorting();\n                fireTableChanged(e);\n                return;\n            }\n            // We can map a cell event through to the view without widening\n            // when the following conditions apply:\n            //\n            // a) all the changes are on one row (e.getFirstRow() == e.getLastRow()) and,\n            // b) all the changes are in one column (column != TableModelEvent.ALL_COLUMNS) and,\n            // c) we are not sorting on that column (getSortingStatus(column) == NOT_SORTED) and,\n            // d) a reverse lookup will not trigger a sort (modelToView != null)\n            //\n            // Note: INSERT and DELETE events fail this test as they have column == ALL_COLUMNS.\n            //\n            // The last check, for (modelToView != null) is to see if modelToView\n            // is already allocated. If we don't do this check; sorting can become\n            // a performance bottleneck for applications where cells\n            // change rapidly in different parts of the table. If cells\n            // change alternately in the sorting column and then outside of\n            // it this class can end up re-sorting on alternate cell updates -\n            // which can be a performance problem for large tables. The last\n            // clause avoids this problem.\n            int column = e.getColumn();\n            if (e.getFirstRow() == e.getLastRow() && column != TableModelEvent.ALL_COLUMNS && getSortingStatus(column) == NOT_SORTED && modelToView != null) {\n                int viewIndex = getModelToView()[e.getFirstRow()];\n                fireTableChanged(new TableModelEvent(TableSorter.this, viewIndex, viewIndex, column, e.getType()));\n                return;\n            }\n            // Something has happened to the data that may have invalidated the row order.\n            clearSortingState();\n            fireTableDataChanged();\n            return;\n        }\n    }\n\n    private class MouseHandler extends MouseAdapter {\n\n        public void mouseClicked(MouseEvent e) {\n            JTableHeader h = (JTableHeader) e.getSource();\n            TableColumnModel columnModel = h.getColumnModel();\n            int viewColumn = columnModel.getColumnIndexAtX(e.getX());\n            int column = columnModel.getColumn(viewColumn).getModelIndex();\n            if (column != -1) {\n                int status = getSortingStatus(column);\n                if (!e.isControlDown()) {\n                    cancelSorting();\n                }\n                // Cycle the sorting states through {NOT_SORTED, ASCENDING, DESCENDING} or\n                // {NOT_SORTED, DESCENDING, ASCENDING} depending on whether shift is pressed.\n                status = status + (e.isShiftDown() ? -1 : 1);\n                // signed mod, returning {-1, 0, 1}\n                status = (status + 4) % 3 - 1;\n                setSortingStatus(column, status);\n            }\n        }\n    }\n\n    private static class Arrow implements Icon {\n\n        private boolean descending;\n\n        private int size;\n\n        private int priority;\n\n        public Arrow(boolean descending, int size, int priority) {\n            this.descending = descending;\n            this.size = size;\n            this.priority = priority;\n        }\n\n        public void paintIcon(Component c, Graphics g, int x, int y) {\n            Color color = c == null ? Color.GRAY : c.getBackground();\n            // In a compound sort, make each succesive triangle 20%\n            // smaller than the previous one.\n            int dx = (int) (size / 2 * Math.pow(0.8, priority));\n            int dy = descending ? dx : -dx;\n            // Align icon (roughly) with font baseline.\n            y = y + 5 * size / 6 + (descending ? -dy : 0);\n            int shift = descending ? 1 : -1;\n            g.translate(x, y);\n            // Right diagonal.\n            g.setColor(color.darker());\n            g.drawLine(dx / 2, dy, 0, 0);\n            g.drawLine(dx / 2, dy + shift, 0, shift);\n            // Left diagonal.\n            g.setColor(color.brighter());\n            g.drawLine(dx / 2, dy, dx, 0);\n            g.drawLine(dx / 2, dy + shift, dx, shift);\n            // Horizontal line.\n            if (descending) {\n                g.setColor(color.darker().darker());\n            } else {\n                g.setColor(color.brighter().brighter());\n            }\n            g.drawLine(dx, 0, 0, 0);\n            g.setColor(color);\n            g.translate(-x, -y);\n        }\n\n        public int getIconWidth() {\n            return size;\n        }\n\n        public int getIconHeight() {\n            return size;\n        }\n    }\n\n    private class SortableHeaderRenderer implements TableCellRenderer {\n\n        private TableCellRenderer tableCellRenderer;\n\n        public SortableHeaderRenderer(TableCellRenderer tableCellRenderer) {\n            this.tableCellRenderer = tableCellRenderer;\n        }\n\n        public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {\n            Component c = tableCellRenderer.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);\n            if (c instanceof JLabel) {\n                JLabel l = (JLabel) c;\n                l.setHorizontalTextPosition(JLabel.LEFT);\n                int modelColumn = table.convertColumnIndexToModel(column);\n                l.setIcon(getHeaderRendererIcon(modelColumn, l.getFont().getSize()));\n            }\n            return c;\n        }\n    }\n\n    private static class Directive {\n\n        private int column;\n\n        private int direction;\n\n        public Directive(int column, int direction) {\n            this.column = column;\n            this.direction = direction;\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/com/tivo/jipviewer/TableSorterTest1.java",
		"test_prompt": "// TableSorterTest1.java\n// The Swing JTable tutorial includes the TableSorter class in this file saying\n// \"You can use TableSorter as-is to provide sorting functionality...\". I've\n// added the sample code license text I found on the tutorial site.  I also\n// added the trivial viewIndex() method.  -- ab\n//\n// Useful links:\n//\n//  \"How to Use Tables\":\n//     http://java.sun.com/docs/books/tutorial/uiswing/components/table.html\n//\n//  TableSorter.java:\n//     http://java.sun.com/docs/books/tutorial/uiswing/components/example-1dot4/TableSorter.java\n//\n//  \"Building GUIs with JFC/Swing APIs Code Samples\":\n//    http://java.sun.com/developer/codesamples/swing.html\n//\n//  License pointed at by \"Building GUIs...\" document.\n//    http://developers.sun.com/license/berkeley_license.html\n//\n/*/////////////////////////////////////////////////////////////////////\n\nCopyright 1994-2006 Sun Microsystems, Inc. All Rights Reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n \n\n    * Redistribution of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistribution in binary form must reproduce the above copyright notice,\n      this list of conditions and the following disclaimer in the documentation\n      and/or other materials provided with the distribution.\n\n \nNeither the name of Sun Microsystems, Inc. or the names of contributors may be\nused to endorse or promote products derived from this software without specific\nprior written permission.\n \nThis software is provided \"AS IS,\" without a warranty of any kind. ALL EXPRESS\nOR IMPLIED CONDITIONS, REPRESENTATIONS AND WARRANTIES, INCLUDING ANY IMPLIED\nWARRANTY OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR\nNON-INFRINGEMENT, ARE HEREBY EXCLUDED. SUN MICROSYSTEMS, INC. (\"SUN\") AND ITS\nLICENSORS SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT\nOF USING, MODIFYING OR DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES. IN NO\nEVENT WILL SUN OR ITS LICENSORS BE LIABLE FOR ANY LOST REVENUE, PROFIT OR DATA,\nOR FOR DIRECT, INDIRECT, SPECIAL, CONSEQUENTIAL, INCIDENTAL OR PUNITIVE\nDAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT\nOF THE USE OF OR INABILITY TO USE THIS SOFTWARE, EVEN IF SUN HAS BEEN ADVISED\nOF THE POSSIBILITY OF SUCH DAMAGES.\n \nYou acknowledge that this software is not designed, licensed or intended for\nuse in the design, construction, operation or maintenance of any nuclear\nfacility.\n\n/////////////////////////////////////////////////////////////////////*/\npackage com.tivo.jipviewer;\n\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.util.*;\nimport java.util.List;\nimport javax.swing.*;\nimport javax.swing.event.TableModelEvent;\nimport javax.swing.event.TableModelListener;\nimport javax.swing.table.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TableSorter}.\n* It contains ten unit test cases for the {@link TableSorter#modelIndex(int)} method.\n*/\nclass TableSorterTest1 {"
	},
	{
		"original_code": "// TableSorter.java\n//\n// The Swing JTable tutorial includes the TableSorter class in this file saying\n// \"You can use TableSorter as-is to provide sorting functionality...\". I've\n// added the sample code license text I found on the tutorial site.  I also\n// added the trivial viewIndex() method.  -- ab\n//\n// Useful links:\n//\n//  \"How to Use Tables\":\n//     http://java.sun.com/docs/books/tutorial/uiswing/components/table.html\n//\n//  TableSorter.java:\n//     http://java.sun.com/docs/books/tutorial/uiswing/components/example-1dot4/TableSorter.java\n//\n//  \"Building GUIs with JFC/Swing APIs Code Samples\":\n//    http://java.sun.com/developer/codesamples/swing.html\n//\n//  License pointed at by \"Building GUIs...\" document.\n//    http://developers.sun.com/license/berkeley_license.html\n//\n/*/////////////////////////////////////////////////////////////////////\n\nCopyright 1994-2006 Sun Microsystems, Inc. All Rights Reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n \n\n    * Redistribution of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistribution in binary form must reproduce the above copyright notice,\n      this list of conditions and the following disclaimer in the documentation\n      and/or other materials provided with the distribution.\n\n \nNeither the name of Sun Microsystems, Inc. or the names of contributors may be\nused to endorse or promote products derived from this software without specific\nprior written permission.\n \nThis software is provided \"AS IS,\" without a warranty of any kind. ALL EXPRESS\nOR IMPLIED CONDITIONS, REPRESENTATIONS AND WARRANTIES, INCLUDING ANY IMPLIED\nWARRANTY OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR\nNON-INFRINGEMENT, ARE HEREBY EXCLUDED. SUN MICROSYSTEMS, INC. (\"SUN\") AND ITS\nLICENSORS SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT\nOF USING, MODIFYING OR DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES. IN NO\nEVENT WILL SUN OR ITS LICENSORS BE LIABLE FOR ANY LOST REVENUE, PROFIT OR DATA,\nOR FOR DIRECT, INDIRECT, SPECIAL, CONSEQUENTIAL, INCIDENTAL OR PUNITIVE\nDAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT\nOF THE USE OF OR INABILITY TO USE THIS SOFTWARE, EVEN IF SUN HAS BEEN ADVISED\nOF THE POSSIBILITY OF SUCH DAMAGES.\n \nYou acknowledge that this software is not designed, licensed or intended for\nuse in the design, construction, operation or maintenance of any nuclear\nfacility.\n\n/////////////////////////////////////////////////////////////////////*/\npackage com.tivo.jipviewer;\n\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.util.*;\nimport java.util.List;\nimport javax.swing.*;\nimport javax.swing.event.TableModelEvent;\nimport javax.swing.event.TableModelListener;\nimport javax.swing.table.*;\n\n/**\n * TableSorter is a decorator for TableModels; adding sorting\n * functionality to a supplied TableModel. TableSorter does\n * not store or copy the data in its TableModel; instead it maintains\n * a map from the row indexes of the view to the row indexes of the\n * model. As requests are made of the sorter (like getValueAt(row, col))\n * they are passed to the underlying model after the row numbers\n * have been translated via the internal mapping array. This way,\n * the TableSorter appears to hold another copy of the table\n * with the rows in a different order.\n * <p/>\n * TableSorter registers itself as a listener to the underlying model,\n * just as the JTable itself would. Events recieved from the model\n * are examined, sometimes manipulated (typically widened), and then\n * passed on to the TableSorter's listeners (typically the JTable).\n * If a change to the model has invalidated the order of TableSorter's\n * rows, a note of this is made and the sorter will resort the\n * rows the next time a value is requested.\n * <p/>\n * When the tableHeader property is set, either by using the\n * setTableHeader() method or the two argument constructor, the\n * table header may be used as a complete UI for TableSorter.\n * The default renderer of the tableHeader is decorated with a renderer\n * that indicates the sorting status of each column. In addition,\n * a mouse listener is installed with the following behavior:\n * <ul>\n * <li>\n * Mouse-click: Clears the sorting status of all other columns\n * and advances the sorting status of that column through three\n * values: {NOT_SORTED, ASCENDING, DESCENDING} (then back to\n * NOT_SORTED again).\n * <li>\n * SHIFT-mouse-click: Clears the sorting status of all other columns\n * and cycles the sorting status of the column through the same\n * three values, in the opposite order: {NOT_SORTED, DESCENDING, ASCENDING}.\n * <li>\n * CONTROL-mouse-click and CONTROL-SHIFT-mouse-click: as above except\n * that the changes to the column do not cancel the statuses of columns\n * that are already sorting - giving a way to initiate a compound\n * sort.\n * </ul>\n * <p/>\n * This is a long overdue rewrite of a class of the same name that\n * first appeared in the swing table demos in 1997.\n *\n * @author Philip Milne\n * @author Brendon McLean\n * @author Dan van Enckevort\n * @author Parwinder Sekhon\n * @version 2.0 02/27/04\n */\npublic class TableSorter extends AbstractTableModel {\n\n    protected TableModel tableModel;\n\n    public static final int DESCENDING = -1;\n\n    public static final int NOT_SORTED = 0;\n\n    public static final int ASCENDING = 1;\n\n    private static Directive EMPTY_DIRECTIVE = new Directive(-1, NOT_SORTED);\n\n    public static final Comparator COMPARABLE_COMAPRATOR = new Comparator() {\n\n        public int compare(Object o1, Object o2) {\n            return ((Comparable) o1).compareTo(o2);\n        }\n    };\n\n    public static final Comparator LEXICAL_COMPARATOR = new Comparator() {\n\n        public int compare(Object o1, Object o2) {\n            return o1.toString().compareTo(o2.toString());\n        }\n    };\n\n    private Row[] viewToModel;\n\n    private int[] modelToView;\n\n    private JTableHeader tableHeader;\n\n    private MouseListener mouseListener;\n\n    private TableModelListener tableModelListener;\n\n    private Map columnComparators = new HashMap();\n\n    private List sortingColumns = new ArrayList();\n\n    public TableSorter() {\n        this.mouseListener = new MouseHandler();\n        this.tableModelListener = new TableModelHandler();\n    }\n\n    public TableSorter(TableModel tableModel) {\n        this();\n        setTableModel(tableModel);\n    }\n\n    public TableSorter(TableModel tableModel, JTableHeader tableHeader) {\n        this();\n        setTableHeader(tableHeader);\n        setTableModel(tableModel);\n    }\n\n    private void clearSortingState() {\n        viewToModel = null;\n        modelToView = null;\n    }\n\n    public TableModel getTableModel() {\n        return tableModel;\n    }\n\n    public void setTableModel(TableModel tableModel) {\n        if (this.tableModel != null) {\n            this.tableModel.removeTableModelListener(tableModelListener);\n        }\n        this.tableModel = tableModel;\n        if (this.tableModel != null) {\n            this.tableModel.addTableModelListener(tableModelListener);\n        }\n        clearSortingState();\n        fireTableStructureChanged();\n    }\n\n    public JTableHeader getTableHeader() {\n        return tableHeader;\n    }\n\n    public void setTableHeader(JTableHeader tableHeader) {\n        if (this.tableHeader != null) {\n            this.tableHeader.removeMouseListener(mouseListener);\n            TableCellRenderer defaultRenderer = this.tableHeader.getDefaultRenderer();\n            if (defaultRenderer instanceof SortableHeaderRenderer) {\n                this.tableHeader.setDefaultRenderer(((SortableHeaderRenderer) defaultRenderer).tableCellRenderer);\n            }\n        }\n        this.tableHeader = tableHeader;\n        if (this.tableHeader != null) {\n            this.tableHeader.addMouseListener(mouseListener);\n            this.tableHeader.setDefaultRenderer(new SortableHeaderRenderer(this.tableHeader.getDefaultRenderer()));\n        }\n    }\n\n    public boolean isSorting() {\n        return sortingColumns.size() != 0;\n    }\n\n    private Directive getDirective(int column) {\n        for (int i = 0; i < sortingColumns.size(); i++) {\n            Directive directive = (Directive) sortingColumns.get(i);\n            if (directive.column == column) {\n                return directive;\n            }\n        }\n        return EMPTY_DIRECTIVE;\n    }\n\n    public int getSortingStatus(int column) {\n        return getDirective(column).direction;\n    }\n\n    private void sortingStatusChanged() {\n        clearSortingState();\n        fireTableDataChanged();\n        if (tableHeader != null) {\n            tableHeader.repaint();\n        }\n    }\n\n    public void setSortingStatus(int column, int status) {\n        Directive directive = getDirective(column);\n        if (directive != EMPTY_DIRECTIVE) {\n            sortingColumns.remove(directive);\n        }\n        if (status != NOT_SORTED) {\n            sortingColumns.add(new Directive(column, status));\n        }\n        sortingStatusChanged();\n    }\n\n    protected Icon getHeaderRendererIcon(int column, int size) {\n        Directive directive = getDirective(column);\n        if (directive == EMPTY_DIRECTIVE) {\n            return null;\n        }\n        return new Arrow(directive.direction == DESCENDING, size, sortingColumns.indexOf(directive));\n    }\n\n    private void cancelSorting() {\n        sortingColumns.clear();\n        sortingStatusChanged();\n    }\n\n    public void setColumnComparator(Class type, Comparator comparator) {\n        if (comparator == null) {\n            columnComparators.remove(type);\n        } else {\n            columnComparators.put(type, comparator);\n        }\n    }\n\n    protected Comparator getComparator(int column) {\n        Class columnType = tableModel.getColumnClass(column);\n        Comparator comparator = (Comparator) columnComparators.get(columnType);\n        if (comparator != null) {\n            return comparator;\n        }\n        if (Comparable.class.isAssignableFrom(columnType)) {\n            return COMPARABLE_COMAPRATOR;\n        }\n        return LEXICAL_COMPARATOR;\n    }\n\n    private Row[] getViewToModel() {\n        if (viewToModel == null) {\n            int tableModelRowCount = tableModel.getRowCount();\n            viewToModel = new Row[tableModelRowCount];\n            for (int row = 0; row < tableModelRowCount; row++) {\n                viewToModel[row] = new Row(row);\n            }\n            if (isSorting()) {\n                Arrays.sort(viewToModel);\n            }\n        }\n        return viewToModel;\n    }\n\n    public int modelIndex(int viewIndex) {\n        return getViewToModel()[viewIndex].modelIndex;\n    }\n\n    public int viewIndex(int modelIndex) {\n        return getModelToView()[modelIndex];\n    }\n\n    private int[] getModelToView() {\n        if (modelToView == null) {\n            int n = getViewToModel().length;\n            modelToView = new int[n];\n            for (int i = 0; i < n; i++) {\n                modelToView[modelIndex(i)] = i;\n            }\n        }\n        return modelToView;\n    }\n\n    // TableModel interface methods\n    public int getRowCount() {\n        return (tableModel == null) ? 0 : tableModel.getRowCount();\n    }\n\n    public int getColumnCount() {\n        return (tableModel == null) ? 0 : tableModel.getColumnCount();\n    }\n\n    public String getColumnName(int column) {\n        return tableModel.getColumnName(column);\n    }\n\n    public Class getColumnClass(int column) {\n        return tableModel.getColumnClass(column);\n    }\n\n    public boolean isCellEditable(int row, int column) {\n        return tableModel.isCellEditable(modelIndex(row), column);\n    }\n\n    public Object getValueAt(int row, int column) {\n        return tableModel.getValueAt(modelIndex(row), column);\n    }\n\n    public void setValueAt(Object aValue, int row, int column) {\n        tableModel.setValueAt(aValue, modelIndex(row), column);\n    }\n\n    // Helper classes\n    private class Row implements Comparable {\n\n        private int modelIndex;\n\n        public Row(int index) {\n            this.modelIndex = index;\n        }\n\n        public int compareTo(Object o) {\n            int row1 = modelIndex;\n            int row2 = ((Row) o).modelIndex;\n            for (Iterator it = sortingColumns.iterator(); it.hasNext(); ) {\n                Directive directive = (Directive) it.next();\n                int column = directive.column;\n                Object o1 = tableModel.getValueAt(row1, column);\n                Object o2 = tableModel.getValueAt(row2, column);\n                int comparison = 0;\n                // Define null less than everything, except null.\n                if (o1 == null && o2 == null) {\n                    comparison = 0;\n                } else if (o1 == null) {\n                    comparison = -1;\n                } else if (o2 == null) {\n                    comparison = 1;\n                } else {\n                    comparison = getComparator(column).compare(o1, o2);\n                }\n                if (comparison != 0) {\n                    return directive.direction == DESCENDING ? -comparison : comparison;\n                }\n            }\n            return 0;\n        }\n    }\n\n    private class TableModelHandler implements TableModelListener {\n\n        public void tableChanged(TableModelEvent e) {\n            // If we're not sorting by anything, just pass the event along.\n            if (!isSorting()) {\n                clearSortingState();\n                fireTableChanged(e);\n                return;\n            }\n            // If the table structure has changed, cancel the sorting; the\n            // sorting columns may have been either moved or deleted from\n            // the model.\n            if (e.getFirstRow() == TableModelEvent.HEADER_ROW) {\n                cancelSorting();\n                fireTableChanged(e);\n                return;\n            }\n            // We can map a cell event through to the view without widening\n            // when the following conditions apply:\n            //\n            // a) all the changes are on one row (e.getFirstRow() == e.getLastRow()) and,\n            // b) all the changes are in one column (column != TableModelEvent.ALL_COLUMNS) and,\n            // c) we are not sorting on that column (getSortingStatus(column) == NOT_SORTED) and,\n            // d) a reverse lookup will not trigger a sort (modelToView != null)\n            //\n            // Note: INSERT and DELETE events fail this test as they have column == ALL_COLUMNS.\n            //\n            // The last check, for (modelToView != null) is to see if modelToView\n            // is already allocated. If we don't do this check; sorting can become\n            // a performance bottleneck for applications where cells\n            // change rapidly in different parts of the table. If cells\n            // change alternately in the sorting column and then outside of\n            // it this class can end up re-sorting on alternate cell updates -\n            // which can be a performance problem for large tables. The last\n            // clause avoids this problem.\n            int column = e.getColumn();\n            if (e.getFirstRow() == e.getLastRow() && column != TableModelEvent.ALL_COLUMNS && getSortingStatus(column) == NOT_SORTED && modelToView != null) {\n                int viewIndex = getModelToView()[e.getFirstRow()];\n                fireTableChanged(new TableModelEvent(TableSorter.this, viewIndex, viewIndex, column, e.getType()));\n                return;\n            }\n            // Something has happened to the data that may have invalidated the row order.\n            clearSortingState();\n            fireTableDataChanged();\n            return;\n        }\n    }\n\n    private class MouseHandler extends MouseAdapter {\n\n        public void mouseClicked(MouseEvent e) {\n            JTableHeader h = (JTableHeader) e.getSource();\n            TableColumnModel columnModel = h.getColumnModel();\n            int viewColumn = columnModel.getColumnIndexAtX(e.getX());\n            int column = columnModel.getColumn(viewColumn).getModelIndex();\n            if (column != -1) {\n                int status = getSortingStatus(column);\n                if (!e.isControlDown()) {\n                    cancelSorting();\n                }\n                // Cycle the sorting states through {NOT_SORTED, ASCENDING, DESCENDING} or\n                // {NOT_SORTED, DESCENDING, ASCENDING} depending on whether shift is pressed.\n                status = status + (e.isShiftDown() ? -1 : 1);\n                // signed mod, returning {-1, 0, 1}\n                status = (status + 4) % 3 - 1;\n                setSortingStatus(column, status);\n            }\n        }\n    }\n\n    private static class Arrow implements Icon {\n\n        private boolean descending;\n\n        private int size;\n\n        private int priority;\n\n        public Arrow(boolean descending, int size, int priority) {\n            this.descending = descending;\n            this.size = size;\n            this.priority = priority;\n        }\n\n        public void paintIcon(Component c, Graphics g, int x, int y) {\n            Color color = c == null ? Color.GRAY : c.getBackground();\n            // In a compound sort, make each succesive triangle 20%\n            // smaller than the previous one.\n            int dx = (int) (size / 2 * Math.pow(0.8, priority));\n            int dy = descending ? dx : -dx;\n            // Align icon (roughly) with font baseline.\n            y = y + 5 * size / 6 + (descending ? -dy : 0);\n            int shift = descending ? 1 : -1;\n            g.translate(x, y);\n            // Right diagonal.\n            g.setColor(color.darker());\n            g.drawLine(dx / 2, dy, 0, 0);\n            g.drawLine(dx / 2, dy + shift, 0, shift);\n            // Left diagonal.\n            g.setColor(color.brighter());\n            g.drawLine(dx / 2, dy, dx, 0);\n            g.drawLine(dx / 2, dy + shift, dx, shift);\n            // Horizontal line.\n            if (descending) {\n                g.setColor(color.darker().darker());\n            } else {\n                g.setColor(color.brighter().brighter());\n            }\n            g.drawLine(dx, 0, 0, 0);\n            g.setColor(color);\n            g.translate(-x, -y);\n        }\n\n        public int getIconWidth() {\n            return size;\n        }\n\n        public int getIconHeight() {\n            return size;\n        }\n    }\n\n    private class SortableHeaderRenderer implements TableCellRenderer {\n\n        private TableCellRenderer tableCellRenderer;\n\n        public SortableHeaderRenderer(TableCellRenderer tableCellRenderer) {\n            this.tableCellRenderer = tableCellRenderer;\n        }\n\n        public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {\n            Component c = tableCellRenderer.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);\n            if (c instanceof JLabel) {\n                JLabel l = (JLabel) c;\n                l.setHorizontalTextPosition(JLabel.LEFT);\n                int modelColumn = table.convertColumnIndexToModel(column);\n                l.setIcon(getHeaderRendererIcon(modelColumn, l.getFont().getSize()));\n            }\n            return c;\n        }\n    }\n\n    private static class Directive {\n\n        private int column;\n\n        private int direction;\n\n        public Directive(int column, int direction) {\n            this.column = column;\n            this.direction = direction;\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/com/tivo/jipviewer/TableSorterTest2.java",
		"test_prompt": "// TableSorterTest2.java\n// The Swing JTable tutorial includes the TableSorter class in this file saying\n// \"You can use TableSorter as-is to provide sorting functionality...\". I've\n// added the sample code license text I found on the tutorial site.  I also\n// added the trivial viewIndex() method.  -- ab\n//\n// Useful links:\n//\n//  \"How to Use Tables\":\n//     http://java.sun.com/docs/books/tutorial/uiswing/components/table.html\n//\n//  TableSorter.java:\n//     http://java.sun.com/docs/books/tutorial/uiswing/components/example-1dot4/TableSorter.java\n//\n//  \"Building GUIs with JFC/Swing APIs Code Samples\":\n//    http://java.sun.com/developer/codesamples/swing.html\n//\n//  License pointed at by \"Building GUIs...\" document.\n//    http://developers.sun.com/license/berkeley_license.html\n//\n/*/////////////////////////////////////////////////////////////////////\n\nCopyright 1994-2006 Sun Microsystems, Inc. All Rights Reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n \n\n    * Redistribution of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistribution in binary form must reproduce the above copyright notice,\n      this list of conditions and the following disclaimer in the documentation\n      and/or other materials provided with the distribution.\n\n \nNeither the name of Sun Microsystems, Inc. or the names of contributors may be\nused to endorse or promote products derived from this software without specific\nprior written permission.\n \nThis software is provided \"AS IS,\" without a warranty of any kind. ALL EXPRESS\nOR IMPLIED CONDITIONS, REPRESENTATIONS AND WARRANTIES, INCLUDING ANY IMPLIED\nWARRANTY OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR\nNON-INFRINGEMENT, ARE HEREBY EXCLUDED. SUN MICROSYSTEMS, INC. (\"SUN\") AND ITS\nLICENSORS SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT\nOF USING, MODIFYING OR DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES. IN NO\nEVENT WILL SUN OR ITS LICENSORS BE LIABLE FOR ANY LOST REVENUE, PROFIT OR DATA,\nOR FOR DIRECT, INDIRECT, SPECIAL, CONSEQUENTIAL, INCIDENTAL OR PUNITIVE\nDAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT\nOF THE USE OF OR INABILITY TO USE THIS SOFTWARE, EVEN IF SUN HAS BEEN ADVISED\nOF THE POSSIBILITY OF SUCH DAMAGES.\n \nYou acknowledge that this software is not designed, licensed or intended for\nuse in the design, construction, operation or maintenance of any nuclear\nfacility.\n\n/////////////////////////////////////////////////////////////////////*/\npackage com.tivo.jipviewer;\n\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.util.*;\nimport java.util.List;\nimport javax.swing.*;\nimport javax.swing.event.TableModelEvent;\nimport javax.swing.event.TableModelListener;\nimport javax.swing.table.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TableSorter}.\n* It contains ten unit test cases for the {@link TableSorter#viewIndex(int)} method.\n*/\nclass TableSorterTest2 {"
	},
	{
		"original_code": "// TableSorter.java\n//\n// The Swing JTable tutorial includes the TableSorter class in this file saying\n// \"You can use TableSorter as-is to provide sorting functionality...\". I've\n// added the sample code license text I found on the tutorial site.  I also\n// added the trivial viewIndex() method.  -- ab\n//\n// Useful links:\n//\n//  \"How to Use Tables\":\n//     http://java.sun.com/docs/books/tutorial/uiswing/components/table.html\n//\n//  TableSorter.java:\n//     http://java.sun.com/docs/books/tutorial/uiswing/components/example-1dot4/TableSorter.java\n//\n//  \"Building GUIs with JFC/Swing APIs Code Samples\":\n//    http://java.sun.com/developer/codesamples/swing.html\n//\n//  License pointed at by \"Building GUIs...\" document.\n//    http://developers.sun.com/license/berkeley_license.html\n//\n/*/////////////////////////////////////////////////////////////////////\n\nCopyright 1994-2006 Sun Microsystems, Inc. All Rights Reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n \n\n    * Redistribution of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistribution in binary form must reproduce the above copyright notice,\n      this list of conditions and the following disclaimer in the documentation\n      and/or other materials provided with the distribution.\n\n \nNeither the name of Sun Microsystems, Inc. or the names of contributors may be\nused to endorse or promote products derived from this software without specific\nprior written permission.\n \nThis software is provided \"AS IS,\" without a warranty of any kind. ALL EXPRESS\nOR IMPLIED CONDITIONS, REPRESENTATIONS AND WARRANTIES, INCLUDING ANY IMPLIED\nWARRANTY OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR\nNON-INFRINGEMENT, ARE HEREBY EXCLUDED. SUN MICROSYSTEMS, INC. (\"SUN\") AND ITS\nLICENSORS SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT\nOF USING, MODIFYING OR DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES. IN NO\nEVENT WILL SUN OR ITS LICENSORS BE LIABLE FOR ANY LOST REVENUE, PROFIT OR DATA,\nOR FOR DIRECT, INDIRECT, SPECIAL, CONSEQUENTIAL, INCIDENTAL OR PUNITIVE\nDAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT\nOF THE USE OF OR INABILITY TO USE THIS SOFTWARE, EVEN IF SUN HAS BEEN ADVISED\nOF THE POSSIBILITY OF SUCH DAMAGES.\n \nYou acknowledge that this software is not designed, licensed or intended for\nuse in the design, construction, operation or maintenance of any nuclear\nfacility.\n\n/////////////////////////////////////////////////////////////////////*/\npackage com.tivo.jipviewer;\n\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.util.*;\nimport java.util.List;\nimport javax.swing.*;\nimport javax.swing.event.TableModelEvent;\nimport javax.swing.event.TableModelListener;\nimport javax.swing.table.*;\n\n/**\n * TableSorter is a decorator for TableModels; adding sorting\n * functionality to a supplied TableModel. TableSorter does\n * not store or copy the data in its TableModel; instead it maintains\n * a map from the row indexes of the view to the row indexes of the\n * model. As requests are made of the sorter (like getValueAt(row, col))\n * they are passed to the underlying model after the row numbers\n * have been translated via the internal mapping array. This way,\n * the TableSorter appears to hold another copy of the table\n * with the rows in a different order.\n * <p/>\n * TableSorter registers itself as a listener to the underlying model,\n * just as the JTable itself would. Events recieved from the model\n * are examined, sometimes manipulated (typically widened), and then\n * passed on to the TableSorter's listeners (typically the JTable).\n * If a change to the model has invalidated the order of TableSorter's\n * rows, a note of this is made and the sorter will resort the\n * rows the next time a value is requested.\n * <p/>\n * When the tableHeader property is set, either by using the\n * setTableHeader() method or the two argument constructor, the\n * table header may be used as a complete UI for TableSorter.\n * The default renderer of the tableHeader is decorated with a renderer\n * that indicates the sorting status of each column. In addition,\n * a mouse listener is installed with the following behavior:\n * <ul>\n * <li>\n * Mouse-click: Clears the sorting status of all other columns\n * and advances the sorting status of that column through three\n * values: {NOT_SORTED, ASCENDING, DESCENDING} (then back to\n * NOT_SORTED again).\n * <li>\n * SHIFT-mouse-click: Clears the sorting status of all other columns\n * and cycles the sorting status of the column through the same\n * three values, in the opposite order: {NOT_SORTED, DESCENDING, ASCENDING}.\n * <li>\n * CONTROL-mouse-click and CONTROL-SHIFT-mouse-click: as above except\n * that the changes to the column do not cancel the statuses of columns\n * that are already sorting - giving a way to initiate a compound\n * sort.\n * </ul>\n * <p/>\n * This is a long overdue rewrite of a class of the same name that\n * first appeared in the swing table demos in 1997.\n *\n * @author Philip Milne\n * @author Brendon McLean\n * @author Dan van Enckevort\n * @author Parwinder Sekhon\n * @version 2.0 02/27/04\n */\npublic class TableSorter extends AbstractTableModel {\n\n    protected TableModel tableModel;\n\n    public static final int DESCENDING = -1;\n\n    public static final int NOT_SORTED = 0;\n\n    public static final int ASCENDING = 1;\n\n    private static Directive EMPTY_DIRECTIVE = new Directive(-1, NOT_SORTED);\n\n    public static final Comparator COMPARABLE_COMAPRATOR = new Comparator() {\n\n        public int compare(Object o1, Object o2) {\n            return ((Comparable) o1).compareTo(o2);\n        }\n    };\n\n    public static final Comparator LEXICAL_COMPARATOR = new Comparator() {\n\n        public int compare(Object o1, Object o2) {\n            return o1.toString().compareTo(o2.toString());\n        }\n    };\n\n    private Row[] viewToModel;\n\n    private int[] modelToView;\n\n    private JTableHeader tableHeader;\n\n    private MouseListener mouseListener;\n\n    private TableModelListener tableModelListener;\n\n    private Map columnComparators = new HashMap();\n\n    private List sortingColumns = new ArrayList();\n\n    public TableSorter() {\n        this.mouseListener = new MouseHandler();\n        this.tableModelListener = new TableModelHandler();\n    }\n\n    public TableSorter(TableModel tableModel) {\n        this();\n        setTableModel(tableModel);\n    }\n\n    public TableSorter(TableModel tableModel, JTableHeader tableHeader) {\n        this();\n        setTableHeader(tableHeader);\n        setTableModel(tableModel);\n    }\n\n    private void clearSortingState() {\n        viewToModel = null;\n        modelToView = null;\n    }\n\n    public TableModel getTableModel() {\n        return tableModel;\n    }\n\n    public void setTableModel(TableModel tableModel) {\n        if (this.tableModel != null) {\n            this.tableModel.removeTableModelListener(tableModelListener);\n        }\n        this.tableModel = tableModel;\n        if (this.tableModel != null) {\n            this.tableModel.addTableModelListener(tableModelListener);\n        }\n        clearSortingState();\n        fireTableStructureChanged();\n    }\n\n    public JTableHeader getTableHeader() {\n        return tableHeader;\n    }\n\n    public void setTableHeader(JTableHeader tableHeader) {\n        if (this.tableHeader != null) {\n            this.tableHeader.removeMouseListener(mouseListener);\n            TableCellRenderer defaultRenderer = this.tableHeader.getDefaultRenderer();\n            if (defaultRenderer instanceof SortableHeaderRenderer) {\n                this.tableHeader.setDefaultRenderer(((SortableHeaderRenderer) defaultRenderer).tableCellRenderer);\n            }\n        }\n        this.tableHeader = tableHeader;\n        if (this.tableHeader != null) {\n            this.tableHeader.addMouseListener(mouseListener);\n            this.tableHeader.setDefaultRenderer(new SortableHeaderRenderer(this.tableHeader.getDefaultRenderer()));\n        }\n    }\n\n    public boolean isSorting() {\n        return sortingColumns.size() != 0;\n    }\n\n    private Directive getDirective(int column) {\n        for (int i = 0; i < sortingColumns.size(); i++) {\n            Directive directive = (Directive) sortingColumns.get(i);\n            if (directive.column == column) {\n                return directive;\n            }\n        }\n        return EMPTY_DIRECTIVE;\n    }\n\n    public int getSortingStatus(int column) {\n        return getDirective(column).direction;\n    }\n\n    private void sortingStatusChanged() {\n        clearSortingState();\n        fireTableDataChanged();\n        if (tableHeader != null) {\n            tableHeader.repaint();\n        }\n    }\n\n    public void setSortingStatus(int column, int status) {\n        Directive directive = getDirective(column);\n        if (directive != EMPTY_DIRECTIVE) {\n            sortingColumns.remove(directive);\n        }\n        if (status != NOT_SORTED) {\n            sortingColumns.add(new Directive(column, status));\n        }\n        sortingStatusChanged();\n    }\n\n    protected Icon getHeaderRendererIcon(int column, int size) {\n        Directive directive = getDirective(column);\n        if (directive == EMPTY_DIRECTIVE) {\n            return null;\n        }\n        return new Arrow(directive.direction == DESCENDING, size, sortingColumns.indexOf(directive));\n    }\n\n    private void cancelSorting() {\n        sortingColumns.clear();\n        sortingStatusChanged();\n    }\n\n    public void setColumnComparator(Class type, Comparator comparator) {\n        if (comparator == null) {\n            columnComparators.remove(type);\n        } else {\n            columnComparators.put(type, comparator);\n        }\n    }\n\n    protected Comparator getComparator(int column) {\n        Class columnType = tableModel.getColumnClass(column);\n        Comparator comparator = (Comparator) columnComparators.get(columnType);\n        if (comparator != null) {\n            return comparator;\n        }\n        if (Comparable.class.isAssignableFrom(columnType)) {\n            return COMPARABLE_COMAPRATOR;\n        }\n        return LEXICAL_COMPARATOR;\n    }\n\n    private Row[] getViewToModel() {\n        if (viewToModel == null) {\n            int tableModelRowCount = tableModel.getRowCount();\n            viewToModel = new Row[tableModelRowCount];\n            for (int row = 0; row < tableModelRowCount; row++) {\n                viewToModel[row] = new Row(row);\n            }\n            if (isSorting()) {\n                Arrays.sort(viewToModel);\n            }\n        }\n        return viewToModel;\n    }\n\n    public int modelIndex(int viewIndex) {\n        return getViewToModel()[viewIndex].modelIndex;\n    }\n\n    public int viewIndex(int modelIndex) {\n        return getModelToView()[modelIndex];\n    }\n\n    private int[] getModelToView() {\n        if (modelToView == null) {\n            int n = getViewToModel().length;\n            modelToView = new int[n];\n            for (int i = 0; i < n; i++) {\n                modelToView[modelIndex(i)] = i;\n            }\n        }\n        return modelToView;\n    }\n\n    // TableModel interface methods\n    public int getRowCount() {\n        return (tableModel == null) ? 0 : tableModel.getRowCount();\n    }\n\n    public int getColumnCount() {\n        return (tableModel == null) ? 0 : tableModel.getColumnCount();\n    }\n\n    public String getColumnName(int column) {\n        return tableModel.getColumnName(column);\n    }\n\n    public Class getColumnClass(int column) {\n        return tableModel.getColumnClass(column);\n    }\n\n    public boolean isCellEditable(int row, int column) {\n        return tableModel.isCellEditable(modelIndex(row), column);\n    }\n\n    public Object getValueAt(int row, int column) {\n        return tableModel.getValueAt(modelIndex(row), column);\n    }\n\n    public void setValueAt(Object aValue, int row, int column) {\n        tableModel.setValueAt(aValue, modelIndex(row), column);\n    }\n\n    // Helper classes\n    private class Row implements Comparable {\n\n        private int modelIndex;\n\n        public Row(int index) {\n            this.modelIndex = index;\n        }\n\n        public int compareTo(Object o) {\n            int row1 = modelIndex;\n            int row2 = ((Row) o).modelIndex;\n            for (Iterator it = sortingColumns.iterator(); it.hasNext(); ) {\n                Directive directive = (Directive) it.next();\n                int column = directive.column;\n                Object o1 = tableModel.getValueAt(row1, column);\n                Object o2 = tableModel.getValueAt(row2, column);\n                int comparison = 0;\n                // Define null less than everything, except null.\n                if (o1 == null && o2 == null) {\n                    comparison = 0;\n                } else if (o1 == null) {\n                    comparison = -1;\n                } else if (o2 == null) {\n                    comparison = 1;\n                } else {\n                    comparison = getComparator(column).compare(o1, o2);\n                }\n                if (comparison != 0) {\n                    return directive.direction == DESCENDING ? -comparison : comparison;\n                }\n            }\n            return 0;\n        }\n    }\n\n    private class TableModelHandler implements TableModelListener {\n\n        public void tableChanged(TableModelEvent e) {\n            // If we're not sorting by anything, just pass the event along.\n            if (!isSorting()) {\n                clearSortingState();\n                fireTableChanged(e);\n                return;\n            }\n            // If the table structure has changed, cancel the sorting; the\n            // sorting columns may have been either moved or deleted from\n            // the model.\n            if (e.getFirstRow() == TableModelEvent.HEADER_ROW) {\n                cancelSorting();\n                fireTableChanged(e);\n                return;\n            }\n            // We can map a cell event through to the view without widening\n            // when the following conditions apply:\n            //\n            // a) all the changes are on one row (e.getFirstRow() == e.getLastRow()) and,\n            // b) all the changes are in one column (column != TableModelEvent.ALL_COLUMNS) and,\n            // c) we are not sorting on that column (getSortingStatus(column) == NOT_SORTED) and,\n            // d) a reverse lookup will not trigger a sort (modelToView != null)\n            //\n            // Note: INSERT and DELETE events fail this test as they have column == ALL_COLUMNS.\n            //\n            // The last check, for (modelToView != null) is to see if modelToView\n            // is already allocated. If we don't do this check; sorting can become\n            // a performance bottleneck for applications where cells\n            // change rapidly in different parts of the table. If cells\n            // change alternately in the sorting column and then outside of\n            // it this class can end up re-sorting on alternate cell updates -\n            // which can be a performance problem for large tables. The last\n            // clause avoids this problem.\n            int column = e.getColumn();\n            if (e.getFirstRow() == e.getLastRow() && column != TableModelEvent.ALL_COLUMNS && getSortingStatus(column) == NOT_SORTED && modelToView != null) {\n                int viewIndex = getModelToView()[e.getFirstRow()];\n                fireTableChanged(new TableModelEvent(TableSorter.this, viewIndex, viewIndex, column, e.getType()));\n                return;\n            }\n            // Something has happened to the data that may have invalidated the row order.\n            clearSortingState();\n            fireTableDataChanged();\n            return;\n        }\n    }\n\n    private class MouseHandler extends MouseAdapter {\n\n        public void mouseClicked(MouseEvent e) {\n            JTableHeader h = (JTableHeader) e.getSource();\n            TableColumnModel columnModel = h.getColumnModel();\n            int viewColumn = columnModel.getColumnIndexAtX(e.getX());\n            int column = columnModel.getColumn(viewColumn).getModelIndex();\n            if (column != -1) {\n                int status = getSortingStatus(column);\n                if (!e.isControlDown()) {\n                    cancelSorting();\n                }\n                // Cycle the sorting states through {NOT_SORTED, ASCENDING, DESCENDING} or\n                // {NOT_SORTED, DESCENDING, ASCENDING} depending on whether shift is pressed.\n                status = status + (e.isShiftDown() ? -1 : 1);\n                // signed mod, returning {-1, 0, 1}\n                status = (status + 4) % 3 - 1;\n                setSortingStatus(column, status);\n            }\n        }\n    }\n\n    private static class Arrow implements Icon {\n\n        private boolean descending;\n\n        private int size;\n\n        private int priority;\n\n        public Arrow(boolean descending, int size, int priority) {\n            this.descending = descending;\n            this.size = size;\n            this.priority = priority;\n        }\n\n        public void paintIcon(Component c, Graphics g, int x, int y) {\n            Color color = c == null ? Color.GRAY : c.getBackground();\n            // In a compound sort, make each succesive triangle 20%\n            // smaller than the previous one.\n            int dx = (int) (size / 2 * Math.pow(0.8, priority));\n            int dy = descending ? dx : -dx;\n            // Align icon (roughly) with font baseline.\n            y = y + 5 * size / 6 + (descending ? -dy : 0);\n            int shift = descending ? 1 : -1;\n            g.translate(x, y);\n            // Right diagonal.\n            g.setColor(color.darker());\n            g.drawLine(dx / 2, dy, 0, 0);\n            g.drawLine(dx / 2, dy + shift, 0, shift);\n            // Left diagonal.\n            g.setColor(color.brighter());\n            g.drawLine(dx / 2, dy, dx, 0);\n            g.drawLine(dx / 2, dy + shift, dx, shift);\n            // Horizontal line.\n            if (descending) {\n                g.setColor(color.darker().darker());\n            } else {\n                g.setColor(color.brighter().brighter());\n            }\n            g.drawLine(dx, 0, 0, 0);\n            g.setColor(color);\n            g.translate(-x, -y);\n        }\n\n        public int getIconWidth() {\n            return size;\n        }\n\n        public int getIconHeight() {\n            return size;\n        }\n    }\n\n    private class SortableHeaderRenderer implements TableCellRenderer {\n\n        private TableCellRenderer tableCellRenderer;\n\n        public SortableHeaderRenderer(TableCellRenderer tableCellRenderer) {\n            this.tableCellRenderer = tableCellRenderer;\n        }\n\n        public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {\n            Component c = tableCellRenderer.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);\n            if (c instanceof JLabel) {\n                JLabel l = (JLabel) c;\n                l.setHorizontalTextPosition(JLabel.LEFT);\n                int modelColumn = table.convertColumnIndexToModel(column);\n                l.setIcon(getHeaderRendererIcon(modelColumn, l.getFont().getSize()));\n            }\n            return c;\n        }\n    }\n\n    private static class Directive {\n\n        private int column;\n\n        private int direction;\n\n        public Directive(int column, int direction) {\n            this.column = column;\n            this.direction = direction;\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/com/tivo/jipviewer/TableSorterTest3.java",
		"test_prompt": "// TableSorterTest3.java\n// The Swing JTable tutorial includes the TableSorter class in this file saying\n// \"You can use TableSorter as-is to provide sorting functionality...\". I've\n// added the sample code license text I found on the tutorial site.  I also\n// added the trivial viewIndex() method.  -- ab\n//\n// Useful links:\n//\n//  \"How to Use Tables\":\n//     http://java.sun.com/docs/books/tutorial/uiswing/components/table.html\n//\n//  TableSorter.java:\n//     http://java.sun.com/docs/books/tutorial/uiswing/components/example-1dot4/TableSorter.java\n//\n//  \"Building GUIs with JFC/Swing APIs Code Samples\":\n//    http://java.sun.com/developer/codesamples/swing.html\n//\n//  License pointed at by \"Building GUIs...\" document.\n//    http://developers.sun.com/license/berkeley_license.html\n//\n/*/////////////////////////////////////////////////////////////////////\n\nCopyright 1994-2006 Sun Microsystems, Inc. All Rights Reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n \n\n    * Redistribution of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistribution in binary form must reproduce the above copyright notice,\n      this list of conditions and the following disclaimer in the documentation\n      and/or other materials provided with the distribution.\n\n \nNeither the name of Sun Microsystems, Inc. or the names of contributors may be\nused to endorse or promote products derived from this software without specific\nprior written permission.\n \nThis software is provided \"AS IS,\" without a warranty of any kind. ALL EXPRESS\nOR IMPLIED CONDITIONS, REPRESENTATIONS AND WARRANTIES, INCLUDING ANY IMPLIED\nWARRANTY OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR\nNON-INFRINGEMENT, ARE HEREBY EXCLUDED. SUN MICROSYSTEMS, INC. (\"SUN\") AND ITS\nLICENSORS SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT\nOF USING, MODIFYING OR DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES. IN NO\nEVENT WILL SUN OR ITS LICENSORS BE LIABLE FOR ANY LOST REVENUE, PROFIT OR DATA,\nOR FOR DIRECT, INDIRECT, SPECIAL, CONSEQUENTIAL, INCIDENTAL OR PUNITIVE\nDAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT\nOF THE USE OF OR INABILITY TO USE THIS SOFTWARE, EVEN IF SUN HAS BEEN ADVISED\nOF THE POSSIBILITY OF SUCH DAMAGES.\n \nYou acknowledge that this software is not designed, licensed or intended for\nuse in the design, construction, operation or maintenance of any nuclear\nfacility.\n\n/////////////////////////////////////////////////////////////////////*/\npackage com.tivo.jipviewer;\n\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.util.*;\nimport java.util.List;\nimport javax.swing.*;\nimport javax.swing.event.TableModelEvent;\nimport javax.swing.event.TableModelListener;\nimport javax.swing.table.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TableSorter}.\n* It contains ten unit test cases for the {@link TableSorter#isCellEditable(int, int)} method.\n*/\nclass TableSorterTest3 {"
	},
	{
		"original_code": "// JipParser.java\n/*/////////////////////////////////////////////////////////////////////\n\nCopyright (C) 2006 TiVo Inc.  All rights reserved.\n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions are met:\n\n+ Redistributions of source code must retain the above copyright notice, \n  this list of conditions and the following disclaimer.\n+ Redistributions in binary form must reproduce the above copyright notice, \n  this list of conditions and the following disclaimer in the documentation \n  and/or other materials provided with the distribution.\n+ Neither the name of TiVo Inc nor the names of its contributors may be \n  used to endorse or promote products derived from this software without \n  specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \n  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE \n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \n  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \n  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \n  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n  POSSIBILITY OF SUCH DAMAGE.\n\n/////////////////////////////////////////////////////////////////////*/\npackage com.tivo.jipviewer;\n\nimport java.io.FileReader;\nimport org.xml.sax.XMLReader;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXParseException;\nimport org.xml.sax.helpers.XMLReaderFactory;\nimport org.xml.sax.helpers.DefaultHandler;\n\npublic class JipParser extends DefaultHandler {\n\n    private IJipParseHandler mHandler;\n\n    private JipParser(IJipParseHandler handler) {\n        mHandler = handler;\n    }\n\n    public static JipRun parse(String filename) throws Exception {\n        JipRun run = new JipRun();\n        JipParser jipParser = new JipParser(run);\n        XMLReader xr = XMLReaderFactory.createXMLReader();\n        xr.setContentHandler(jipParser);\n        xr.setErrorHandler(jipParser);\n        FileReader r = new FileReader(filename);\n        xr.parse(new InputSource(r));\n        return run;\n    }\n\n    public void error(SAXParseException exception) throws SAXException {\n        throw exception;\n    }\n\n    public void fatalError(SAXParseException exception) throws SAXException {\n        throw exception;\n    }\n\n    public void warning(SAXParseException exception) throws SAXException {\n        throw exception;\n    }\n\n    public void startElement(String uri, String name, String qName, Attributes atts) {\n        //System.out.println(\"startElt \" + name);\n        if (name.equals(\"profile\")) {\n            String date = getAttrString(atts, \"date\");\n            mHandler.setDate(date);\n        } else if (name.equals(\"thread\")) {\n            mHandler.startThread(getAttrLong(atts, \"id\"));\n        } else if (name.equals(\"interaction\")) {\n            mHandler.startInteraction(getAttrLong(atts, \"id\"));\n        } else if (name.equals(\"frame\")) {\n            mHandler.startFrame(getAttrString(atts, \"cn\"), getAttrString(atts, \"mn\"), getAttrLong(atts, \"c\"), getAttrLong(atts, \"t\"));\n        } else if (name.equals(\"entry\")) {\n            mHandler.addToClassMap(getAttrString(atts, \"s\"), getAttrString(atts, \"f\"));\n        } else if (name.equals(\"allocation\")) {\n        } else if (name.equals(\"class\")) {\n        } else if (name.equals(\"class-map\")) {\n        } else {\n            throw new RuntimeException(\"unexpected tag <\" + name + \">\");\n        }\n    }\n\n    public void endElement(String uri, String name, String qName) {\n        if (name.equals(\"thread\")) {\n            mHandler.endThread();\n        } else if (name.equals(\"interaction\")) {\n            mHandler.endInteraction();\n        } else if (name.equals(\"frame\")) {\n            mHandler.endFrame();\n        }\n    }\n\n    private String getAttrString(Attributes atts, String name) {\n        String value = atts.getValue(name);\n        if (value == null) {\n            throw new RuntimeException(\"no value for '\" + name + \"'\");\n        }\n        return value;\n    }\n\n    private long getAttrLong(Attributes atts, String name) {\n        String value = getAttrString(atts, name);\n        try {\n            return Long.parseLong(value);\n        } catch (NumberFormatException e) {\n            throw new RuntimeException(name + \" (\" + value + \") isn't a long\");\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/com/tivo/jipviewer/JipParserTest.java",
		"test_prompt": "// JipParserTest.java\npackage com.tivo.jipviewer;\n\nimport java.io.FileReader;\nimport org.xml.sax.XMLReader;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXParseException;\nimport org.xml.sax.helpers.XMLReaderFactory;\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JipParser}.\n* It contains ten unit test cases for the {@link JipParser#parse(String)} method.\n*/\nclass JipParserTest {"
	},
	{
		"original_code": "// JipMethod.java\n/*/////////////////////////////////////////////////////////////////////\n\nCopyright (C) 2006 TiVo Inc.  All rights reserved.\n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions are met:\n\n+ Redistributions of source code must retain the above copyright notice, \n  this list of conditions and the following disclaimer.\n+ Redistributions in binary form must reproduce the above copyright notice, \n  this list of conditions and the following disclaimer in the documentation \n  and/or other materials provided with the distribution.\n+ Neither the name of TiVo Inc nor the names of its contributors may be \n  used to endorse or promote products derived from this software without \n  specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \n  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE \n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \n  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \n  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \n  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n  POSSIBILITY OF SUCH DAMAGE.\n\n/////////////////////////////////////////////////////////////////////*/\npackage com.tivo.jipviewer;\n\n/**\n * Represents a method.\n * It's immutable.\n *\n * Some definitions:\n *    if constructed with the name 'com.tivo.trio.util.Dict:getString',\n *\n *       methodName = getString\n *       className  = Dict\n *       package    = com.tivo.trio.util\n */\nclass JipMethod {\n\n    final String mName;\n\n    // these are just so i don't keep parsing them out\n    // on every call.  they're fully computable from mName!\n    final String mMethodName;\n\n    final String mClassName;\n\n    final String mPackageName;\n\n    JipMethod(String name) {\n        mName = name;\n        //\n        // pre-compute all the subnames.\n        //\n        // method name...\n        int iColon = mName.lastIndexOf(':');\n        mMethodName = mName.substring(iColon + 1);\n        if (iColon == -1) {\n            mClassName = \"\";\n            mPackageName = \"\";\n        } else {\n            String fullClass = mName.substring(0, iColon);\n            int iDot = fullClass.lastIndexOf('.');\n            mClassName = fullClass.substring(iDot + 1);\n            if (iDot == -1) {\n                mPackageName = \"\";\n            } else {\n                mPackageName = fullClass.substring(0, iDot);\n            }\n        }\n    }\n\n    String getName() {\n        return mName;\n    }\n\n    String getClassName() {\n        return mClassName;\n    }\n\n    String getMethodName() {\n        return mMethodName;\n    }\n\n    String getPackageName() {\n        return mPackageName;\n    }\n\n    //\n    // from object\n    //\n    @Override\n    public String toString() {\n        return mName;\n    }\n\n    @Override\n    public boolean equals(Object object) {\n        if (!(object instanceof JipMethod)) {\n            throw new RuntimeException(\"other isA \" + object.getClass());\n        }\n        JipMethod other = (JipMethod) object;\n        return mName.equals(other.mName);\n    }\n\n    @Override\n    public int hashCode() {\n        return mName.hashCode();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/com/tivo/jipviewer/JipMethodTest0.java",
		"test_prompt": "// JipMethodTest0.java\npackage com.tivo.jipviewer;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JipMethod}.\n* It contains ten unit test cases for the {@link JipMethod#equals(Object)} method.\n*/\nclass JipMethodTest0 {"
	},
	{
		"original_code": "// JipMethod.java\n/*/////////////////////////////////////////////////////////////////////\n\nCopyright (C) 2006 TiVo Inc.  All rights reserved.\n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions are met:\n\n+ Redistributions of source code must retain the above copyright notice, \n  this list of conditions and the following disclaimer.\n+ Redistributions in binary form must reproduce the above copyright notice, \n  this list of conditions and the following disclaimer in the documentation \n  and/or other materials provided with the distribution.\n+ Neither the name of TiVo Inc nor the names of its contributors may be \n  used to endorse or promote products derived from this software without \n  specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \n  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE \n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \n  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \n  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \n  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n  POSSIBILITY OF SUCH DAMAGE.\n\n/////////////////////////////////////////////////////////////////////*/\npackage com.tivo.jipviewer;\n\n/**\n * Represents a method.\n * It's immutable.\n *\n * Some definitions:\n *    if constructed with the name 'com.tivo.trio.util.Dict:getString',\n *\n *       methodName = getString\n *       className  = Dict\n *       package    = com.tivo.trio.util\n */\nclass JipMethod {\n\n    final String mName;\n\n    // these are just so i don't keep parsing them out\n    // on every call.  they're fully computable from mName!\n    final String mMethodName;\n\n    final String mClassName;\n\n    final String mPackageName;\n\n    JipMethod(String name) {\n        mName = name;\n        //\n        // pre-compute all the subnames.\n        //\n        // method name...\n        int iColon = mName.lastIndexOf(':');\n        mMethodName = mName.substring(iColon + 1);\n        if (iColon == -1) {\n            mClassName = \"\";\n            mPackageName = \"\";\n        } else {\n            String fullClass = mName.substring(0, iColon);\n            int iDot = fullClass.lastIndexOf('.');\n            mClassName = fullClass.substring(iDot + 1);\n            if (iDot == -1) {\n                mPackageName = \"\";\n            } else {\n                mPackageName = fullClass.substring(0, iDot);\n            }\n        }\n    }\n\n    String getName() {\n        return mName;\n    }\n\n    String getClassName() {\n        return mClassName;\n    }\n\n    String getMethodName() {\n        return mMethodName;\n    }\n\n    String getPackageName() {\n        return mPackageName;\n    }\n\n    //\n    // from object\n    //\n    @Override\n    public String toString() {\n        return mName;\n    }\n\n    @Override\n    public boolean equals(Object object) {\n        if (!(object instanceof JipMethod)) {\n            throw new RuntimeException(\"other isA \" + object.getClass());\n        }\n        JipMethod other = (JipMethod) object;\n        return mName.equals(other.mName);\n    }\n\n    @Override\n    public int hashCode() {\n        return mName.hashCode();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/com/tivo/jipviewer/JipMethodTest1.java",
		"test_prompt": "// JipMethodTest1.java\npackage com.tivo.jipviewer;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JipMethod}.\n* It contains ten unit test cases for the {@link JipMethod#hashCode()} method.\n*/\nclass JipMethodTest1 {"
	},
	{
		"original_code": "// JipRun.java\n/*/////////////////////////////////////////////////////////////////////\n\nCopyright (C) 2006 TiVo Inc.  All rights reserved.\n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions are met:\n\n+ Redistributions of source code must retain the above copyright notice, \n  this list of conditions and the following disclaimer.\n+ Redistributions in binary form must reproduce the above copyright notice, \n  this list of conditions and the following disclaimer in the documentation \n  and/or other materials provided with the distribution.\n+ Neither the name of TiVo Inc nor the names of its contributors may be \n  used to endorse or promote products derived from this software without \n  specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \n  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE \n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \n  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \n  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \n  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n  POSSIBILITY OF SUCH DAMAGE.\n\n/////////////////////////////////////////////////////////////////////*/\npackage com.tivo.jipviewer;\n\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.HashMap;\nimport java.util.TreeMap;\nimport java.util.HashSet;\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass JipRun implements IJipParseHandler {\n\n    private String mDate;\n\n    // current thread, or 0 if none...\n    private long mCurThreadId;\n\n    // maps threadId (as Long) to List<JipFrame>\n    private Map<Long, List<JipFrame>> mThreads = new HashMap<Long, List<JipFrame>>();\n\n    // current interaction id or 0.\n    private long mCurInteractionId;\n\n    // current frame or null\n    private JipFrame mCurFrame;\n\n    // from each short class name to the full class name\n    private Map<String, String> mFullClassNames = new TreeMap();\n\n    // maps from a method to the PerMethodInfo for it.\n    private Map<JipMethod, PerMethodInfo> mPerMethods = new HashMap<JipMethod, PerMethodInfo>();\n\n    public void setDate(String date) {\n        if (mDate != null) {\n            throw new RuntimeException(\"already set date! (\" + mDate + \")\");\n        }\n        mDate = date;\n    }\n\n    public void startThread(long threadId) {\n        if (mCurThreadId != 0) {\n            throw new RuntimeException(\"already in thread \" + mCurThreadId);\n        }\n        mCurThreadId = threadId;\n    }\n\n    public void endThread() {\n        if (mCurThreadId == 0) {\n            throw new RuntimeException(\"there's no thread to end!\");\n        }\n        mCurThreadId = 0;\n    }\n\n    public void startInteraction(long id) {\n        if (mCurInteractionId != 0) {\n            throw new RuntimeException(\"already in interaction \" + mCurInteractionId);\n        }\n        mCurInteractionId = id;\n    }\n\n    public void endInteraction() {\n        if (mCurInteractionId == 0) {\n            throw new RuntimeException(\"there's no interaction to end!\");\n        }\n        mCurInteractionId = 0;\n    }\n\n    public void startFrame(String className, String methodName, long count, long time) {\n        //System.out.println(\"startFrame(\" + className + \", \" +\n        //methodName + \", \" + count + \", \" + time);\n        /*\n         * NOTE: I'm basically ignoring className because I don't really\n         *       see the usefulness of the split between className and\n         *       methodName in profile.xml.  If we're gonna use the classMap,\n         *       let's not include the full class name in the methodName.\n         */\n        JipMethod method = new JipMethod(methodName);\n        JipFrame frame = new JipFrame(mCurFrame, method, mCurThreadId, count, time);\n        if (mCurFrame == null) {\n            List<JipFrame> vFrame = mThreads.get(mCurThreadId);\n            if (vFrame == null) {\n                vFrame = new ArrayList<JipFrame>();\n                mThreads.put(mCurThreadId, vFrame);\n            }\n            vFrame.add(frame);\n        }\n        mCurFrame = frame;\n    }\n\n    public void endFrame() {\n        mCurFrame.computeNetTime();\n        updatePerMethodInfo(mCurFrame);\n        // pop!\n        mCurFrame = mCurFrame.getParentOrNull();\n    }\n\n    // allocations not handled -- i want some examples first -- :)\n    public void addToClassMap(String abbrev, String full) {\n        mFullClassNames.put(abbrev, full);\n    }\n\n    public String toString() {\n        StringBuffer buf = new StringBuffer();\n        buf.append(\"JipRun\\n\");\n        buf.append(\"{\\n\");\n        for (Long threadId : mThreads.keySet()) {\n            int i = 1;\n            for (JipFrame f : mThreads.get(threadId)) {\n                buf.append(\"* thread \" + threadId + \" interaction \" + i + \"\\n\");\n                buf.append(f);\n                i++;\n            }\n        }\n        buf.append(\"}\\n\");\n        return buf.toString();\n    }\n\n    public Iterable<Long> threads() {\n        return mThreads.keySet();\n    }\n\n    long getTotalTimeForAllThreads() {\n        long total = 0;\n        for (Long threadId : threads()) {\n            for (JipFrame frame : mThreads.get(threadId.longValue())) {\n                total += frame.getTotalTime();\n            }\n        }\n        return total;\n    }\n\n    public Iterable<JipFrame> interactions(long threadId) {\n        return mThreads.get(threadId);\n    }\n\n    public Iterable<JipFrame> allCallers(JipMethod method) {\n        Set<JipFrame> set = new HashSet<JipFrame>();\n        PerMethodInfo perMethod = mPerMethods.get(method);\n        if (perMethod != null) {\n            for (JipFrame frame : perMethod.allFrames()) {\n                JipFrame parent = frame.getParentOrNull();\n                if (parent != null) {\n                    set.add(parent);\n                }\n            }\n        }\n        return set;\n    }\n\n    public Iterable<JipFrame> allCallees(JipMethod method) {\n        Set set = new HashSet<JipFrame>();\n        PerMethodInfo perMethod = mPerMethods.get(method);\n        if (perMethod != null) {\n            for (JipFrame frame : perMethod.allFrames()) {\n                for (JipFrame callee : frame.getChildren()) {\n                    set.add(callee);\n                }\n            }\n        }\n        return set;\n    }\n\n    /**\n     * Returns an iterable containing PerMethodInfos in descending totalTime\n     * order.\n     */\n    public List<PerMethodInfo> perMethodsInTotalTimeOrder() {\n        Comparator cmp = new Comparator<PerMethodInfo>() {\n\n            public int compare(PerMethodInfo a, PerMethodInfo b) {\n                long timeA = a.getAllThreadAllFramesTime();\n                long timeB = b.getAllThreadAllFramesTime();\n                if (timeA < timeB) {\n                    return -1;\n                } else if (timeA > timeB) {\n                    return 1;\n                } else {\n                    String nameA = a.getMethod().getMethodName();\n                    String nameB = a.getMethod().getMethodName();\n                    return nameA.compareToIgnoreCase(nameB);\n                }\n            }\n        };\n        List v = new ArrayList(mPerMethods.values());\n        Collections.sort(v, cmp);\n        return v;\n    }\n\n    public PerMethodInfo getPerMethod(JipMethod method) {\n        PerMethodInfo perMethod = mPerMethods.get(method);\n        if (perMethod == null) {\n            throw new RuntimeException(\"unknown method (\" + method + \")?\");\n        }\n        return perMethod;\n    }\n\n    static class PerMethodInfo {\n\n        private JipMethod mMethod;\n\n        // NOTE: mAllThreadsAllFramesTime includes times from *all* threads.\n        private long mAllThreadsAllFramesTime;\n\n        private long mAllThreadsAllFramesTimeIncludingReentrant;\n\n        private List<JipFrame> mvFrame = new ArrayList<JipFrame>();\n\n        PerMethodInfo(JipMethod method) {\n            mMethod = method;\n        }\n\n        JipMethod getMethod() {\n            return mMethod;\n        }\n\n        void addFrame(JipFrame frame) {\n            mvFrame.add(frame);\n            long frameTime = frame.getTotalTime();\n            mAllThreadsAllFramesTimeIncludingReentrant += frameTime;\n            if (!frame.isReentrant()) {\n                mAllThreadsAllFramesTime += frameTime;\n            }\n        }\n\n        long getAllThreadAllFramesTime() {\n            return mAllThreadsAllFramesTime;\n        }\n\n        long getAllThreadAllFramesTimeIncludingReentrant() {\n            return mAllThreadsAllFramesTimeIncludingReentrant;\n        }\n\n        Iterable<JipFrame> allFrames() {\n            return mvFrame;\n        }\n\n        public String toString() {\n            return mMethod.getMethodName();\n        }\n    }\n\n    private void updatePerMethodInfo(JipFrame frame) {\n        JipMethod method = frame.getMethod();\n        PerMethodInfo perMethod = mPerMethods.get(method);\n        if (perMethod == null) {\n            perMethod = new PerMethodInfo(method);\n            mPerMethods.put(method, perMethod);\n        }\n        perMethod.addFrame(frame);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/com/tivo/jipviewer/JipRunTest0.java",
		"test_prompt": "// JipRunTest0.java\npackage com.tivo.jipviewer;\n\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.HashMap;\nimport java.util.TreeMap;\nimport java.util.HashSet;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JipRun}.\n* It contains ten unit test cases for the {@link JipRun#threads()} method.\n*/\nclass JipRunTest0 {"
	},
	{
		"original_code": "// JipRun.java\n/*/////////////////////////////////////////////////////////////////////\n\nCopyright (C) 2006 TiVo Inc.  All rights reserved.\n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions are met:\n\n+ Redistributions of source code must retain the above copyright notice, \n  this list of conditions and the following disclaimer.\n+ Redistributions in binary form must reproduce the above copyright notice, \n  this list of conditions and the following disclaimer in the documentation \n  and/or other materials provided with the distribution.\n+ Neither the name of TiVo Inc nor the names of its contributors may be \n  used to endorse or promote products derived from this software without \n  specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \n  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE \n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \n  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \n  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \n  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n  POSSIBILITY OF SUCH DAMAGE.\n\n/////////////////////////////////////////////////////////////////////*/\npackage com.tivo.jipviewer;\n\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.HashMap;\nimport java.util.TreeMap;\nimport java.util.HashSet;\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass JipRun implements IJipParseHandler {\n\n    private String mDate;\n\n    // current thread, or 0 if none...\n    private long mCurThreadId;\n\n    // maps threadId (as Long) to List<JipFrame>\n    private Map<Long, List<JipFrame>> mThreads = new HashMap<Long, List<JipFrame>>();\n\n    // current interaction id or 0.\n    private long mCurInteractionId;\n\n    // current frame or null\n    private JipFrame mCurFrame;\n\n    // from each short class name to the full class name\n    private Map<String, String> mFullClassNames = new TreeMap();\n\n    // maps from a method to the PerMethodInfo for it.\n    private Map<JipMethod, PerMethodInfo> mPerMethods = new HashMap<JipMethod, PerMethodInfo>();\n\n    public void setDate(String date) {\n        if (mDate != null) {\n            throw new RuntimeException(\"already set date! (\" + mDate + \")\");\n        }\n        mDate = date;\n    }\n\n    public void startThread(long threadId) {\n        if (mCurThreadId != 0) {\n            throw new RuntimeException(\"already in thread \" + mCurThreadId);\n        }\n        mCurThreadId = threadId;\n    }\n\n    public void endThread() {\n        if (mCurThreadId == 0) {\n            throw new RuntimeException(\"there's no thread to end!\");\n        }\n        mCurThreadId = 0;\n    }\n\n    public void startInteraction(long id) {\n        if (mCurInteractionId != 0) {\n            throw new RuntimeException(\"already in interaction \" + mCurInteractionId);\n        }\n        mCurInteractionId = id;\n    }\n\n    public void endInteraction() {\n        if (mCurInteractionId == 0) {\n            throw new RuntimeException(\"there's no interaction to end!\");\n        }\n        mCurInteractionId = 0;\n    }\n\n    public void startFrame(String className, String methodName, long count, long time) {\n        //System.out.println(\"startFrame(\" + className + \", \" +\n        //methodName + \", \" + count + \", \" + time);\n        /*\n         * NOTE: I'm basically ignoring className because I don't really\n         *       see the usefulness of the split between className and\n         *       methodName in profile.xml.  If we're gonna use the classMap,\n         *       let's not include the full class name in the methodName.\n         */\n        JipMethod method = new JipMethod(methodName);\n        JipFrame frame = new JipFrame(mCurFrame, method, mCurThreadId, count, time);\n        if (mCurFrame == null) {\n            List<JipFrame> vFrame = mThreads.get(mCurThreadId);\n            if (vFrame == null) {\n                vFrame = new ArrayList<JipFrame>();\n                mThreads.put(mCurThreadId, vFrame);\n            }\n            vFrame.add(frame);\n        }\n        mCurFrame = frame;\n    }\n\n    public void endFrame() {\n        mCurFrame.computeNetTime();\n        updatePerMethodInfo(mCurFrame);\n        // pop!\n        mCurFrame = mCurFrame.getParentOrNull();\n    }\n\n    // allocations not handled -- i want some examples first -- :)\n    public void addToClassMap(String abbrev, String full) {\n        mFullClassNames.put(abbrev, full);\n    }\n\n    public String toString() {\n        StringBuffer buf = new StringBuffer();\n        buf.append(\"JipRun\\n\");\n        buf.append(\"{\\n\");\n        for (Long threadId : mThreads.keySet()) {\n            int i = 1;\n            for (JipFrame f : mThreads.get(threadId)) {\n                buf.append(\"* thread \" + threadId + \" interaction \" + i + \"\\n\");\n                buf.append(f);\n                i++;\n            }\n        }\n        buf.append(\"}\\n\");\n        return buf.toString();\n    }\n\n    public Iterable<Long> threads() {\n        return mThreads.keySet();\n    }\n\n    long getTotalTimeForAllThreads() {\n        long total = 0;\n        for (Long threadId : threads()) {\n            for (JipFrame frame : mThreads.get(threadId.longValue())) {\n                total += frame.getTotalTime();\n            }\n        }\n        return total;\n    }\n\n    public Iterable<JipFrame> interactions(long threadId) {\n        return mThreads.get(threadId);\n    }\n\n    public Iterable<JipFrame> allCallers(JipMethod method) {\n        Set<JipFrame> set = new HashSet<JipFrame>();\n        PerMethodInfo perMethod = mPerMethods.get(method);\n        if (perMethod != null) {\n            for (JipFrame frame : perMethod.allFrames()) {\n                JipFrame parent = frame.getParentOrNull();\n                if (parent != null) {\n                    set.add(parent);\n                }\n            }\n        }\n        return set;\n    }\n\n    public Iterable<JipFrame> allCallees(JipMethod method) {\n        Set set = new HashSet<JipFrame>();\n        PerMethodInfo perMethod = mPerMethods.get(method);\n        if (perMethod != null) {\n            for (JipFrame frame : perMethod.allFrames()) {\n                for (JipFrame callee : frame.getChildren()) {\n                    set.add(callee);\n                }\n            }\n        }\n        return set;\n    }\n\n    /**\n     * Returns an iterable containing PerMethodInfos in descending totalTime\n     * order.\n     */\n    public List<PerMethodInfo> perMethodsInTotalTimeOrder() {\n        Comparator cmp = new Comparator<PerMethodInfo>() {\n\n            public int compare(PerMethodInfo a, PerMethodInfo b) {\n                long timeA = a.getAllThreadAllFramesTime();\n                long timeB = b.getAllThreadAllFramesTime();\n                if (timeA < timeB) {\n                    return -1;\n                } else if (timeA > timeB) {\n                    return 1;\n                } else {\n                    String nameA = a.getMethod().getMethodName();\n                    String nameB = a.getMethod().getMethodName();\n                    return nameA.compareToIgnoreCase(nameB);\n                }\n            }\n        };\n        List v = new ArrayList(mPerMethods.values());\n        Collections.sort(v, cmp);\n        return v;\n    }\n\n    public PerMethodInfo getPerMethod(JipMethod method) {\n        PerMethodInfo perMethod = mPerMethods.get(method);\n        if (perMethod == null) {\n            throw new RuntimeException(\"unknown method (\" + method + \")?\");\n        }\n        return perMethod;\n    }\n\n    static class PerMethodInfo {\n\n        private JipMethod mMethod;\n\n        // NOTE: mAllThreadsAllFramesTime includes times from *all* threads.\n        private long mAllThreadsAllFramesTime;\n\n        private long mAllThreadsAllFramesTimeIncludingReentrant;\n\n        private List<JipFrame> mvFrame = new ArrayList<JipFrame>();\n\n        PerMethodInfo(JipMethod method) {\n            mMethod = method;\n        }\n\n        JipMethod getMethod() {\n            return mMethod;\n        }\n\n        void addFrame(JipFrame frame) {\n            mvFrame.add(frame);\n            long frameTime = frame.getTotalTime();\n            mAllThreadsAllFramesTimeIncludingReentrant += frameTime;\n            if (!frame.isReentrant()) {\n                mAllThreadsAllFramesTime += frameTime;\n            }\n        }\n\n        long getAllThreadAllFramesTime() {\n            return mAllThreadsAllFramesTime;\n        }\n\n        long getAllThreadAllFramesTimeIncludingReentrant() {\n            return mAllThreadsAllFramesTimeIncludingReentrant;\n        }\n\n        Iterable<JipFrame> allFrames() {\n            return mvFrame;\n        }\n\n        public String toString() {\n            return mMethod.getMethodName();\n        }\n    }\n\n    private void updatePerMethodInfo(JipFrame frame) {\n        JipMethod method = frame.getMethod();\n        PerMethodInfo perMethod = mPerMethods.get(method);\n        if (perMethod == null) {\n            perMethod = new PerMethodInfo(method);\n            mPerMethods.put(method, perMethod);\n        }\n        perMethod.addFrame(frame);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/com/tivo/jipviewer/JipRunTest1.java",
		"test_prompt": "// JipRunTest1.java\npackage com.tivo.jipviewer;\n\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.HashMap;\nimport java.util.TreeMap;\nimport java.util.HashSet;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JipRun}.\n* It contains ten unit test cases for the {@link JipRun#interactions(long)} method.\n*/\nclass JipRunTest1 {"
	},
	{
		"original_code": "// JipRun.java\n/*/////////////////////////////////////////////////////////////////////\n\nCopyright (C) 2006 TiVo Inc.  All rights reserved.\n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions are met:\n\n+ Redistributions of source code must retain the above copyright notice, \n  this list of conditions and the following disclaimer.\n+ Redistributions in binary form must reproduce the above copyright notice, \n  this list of conditions and the following disclaimer in the documentation \n  and/or other materials provided with the distribution.\n+ Neither the name of TiVo Inc nor the names of its contributors may be \n  used to endorse or promote products derived from this software without \n  specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \n  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE \n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \n  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \n  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \n  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n  POSSIBILITY OF SUCH DAMAGE.\n\n/////////////////////////////////////////////////////////////////////*/\npackage com.tivo.jipviewer;\n\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.HashMap;\nimport java.util.TreeMap;\nimport java.util.HashSet;\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass JipRun implements IJipParseHandler {\n\n    private String mDate;\n\n    // current thread, or 0 if none...\n    private long mCurThreadId;\n\n    // maps threadId (as Long) to List<JipFrame>\n    private Map<Long, List<JipFrame>> mThreads = new HashMap<Long, List<JipFrame>>();\n\n    // current interaction id or 0.\n    private long mCurInteractionId;\n\n    // current frame or null\n    private JipFrame mCurFrame;\n\n    // from each short class name to the full class name\n    private Map<String, String> mFullClassNames = new TreeMap();\n\n    // maps from a method to the PerMethodInfo for it.\n    private Map<JipMethod, PerMethodInfo> mPerMethods = new HashMap<JipMethod, PerMethodInfo>();\n\n    public void setDate(String date) {\n        if (mDate != null) {\n            throw new RuntimeException(\"already set date! (\" + mDate + \")\");\n        }\n        mDate = date;\n    }\n\n    public void startThread(long threadId) {\n        if (mCurThreadId != 0) {\n            throw new RuntimeException(\"already in thread \" + mCurThreadId);\n        }\n        mCurThreadId = threadId;\n    }\n\n    public void endThread() {\n        if (mCurThreadId == 0) {\n            throw new RuntimeException(\"there's no thread to end!\");\n        }\n        mCurThreadId = 0;\n    }\n\n    public void startInteraction(long id) {\n        if (mCurInteractionId != 0) {\n            throw new RuntimeException(\"already in interaction \" + mCurInteractionId);\n        }\n        mCurInteractionId = id;\n    }\n\n    public void endInteraction() {\n        if (mCurInteractionId == 0) {\n            throw new RuntimeException(\"there's no interaction to end!\");\n        }\n        mCurInteractionId = 0;\n    }\n\n    public void startFrame(String className, String methodName, long count, long time) {\n        //System.out.println(\"startFrame(\" + className + \", \" +\n        //methodName + \", \" + count + \", \" + time);\n        /*\n         * NOTE: I'm basically ignoring className because I don't really\n         *       see the usefulness of the split between className and\n         *       methodName in profile.xml.  If we're gonna use the classMap,\n         *       let's not include the full class name in the methodName.\n         */\n        JipMethod method = new JipMethod(methodName);\n        JipFrame frame = new JipFrame(mCurFrame, method, mCurThreadId, count, time);\n        if (mCurFrame == null) {\n            List<JipFrame> vFrame = mThreads.get(mCurThreadId);\n            if (vFrame == null) {\n                vFrame = new ArrayList<JipFrame>();\n                mThreads.put(mCurThreadId, vFrame);\n            }\n            vFrame.add(frame);\n        }\n        mCurFrame = frame;\n    }\n\n    public void endFrame() {\n        mCurFrame.computeNetTime();\n        updatePerMethodInfo(mCurFrame);\n        // pop!\n        mCurFrame = mCurFrame.getParentOrNull();\n    }\n\n    // allocations not handled -- i want some examples first -- :)\n    public void addToClassMap(String abbrev, String full) {\n        mFullClassNames.put(abbrev, full);\n    }\n\n    public String toString() {\n        StringBuffer buf = new StringBuffer();\n        buf.append(\"JipRun\\n\");\n        buf.append(\"{\\n\");\n        for (Long threadId : mThreads.keySet()) {\n            int i = 1;\n            for (JipFrame f : mThreads.get(threadId)) {\n                buf.append(\"* thread \" + threadId + \" interaction \" + i + \"\\n\");\n                buf.append(f);\n                i++;\n            }\n        }\n        buf.append(\"}\\n\");\n        return buf.toString();\n    }\n\n    public Iterable<Long> threads() {\n        return mThreads.keySet();\n    }\n\n    long getTotalTimeForAllThreads() {\n        long total = 0;\n        for (Long threadId : threads()) {\n            for (JipFrame frame : mThreads.get(threadId.longValue())) {\n                total += frame.getTotalTime();\n            }\n        }\n        return total;\n    }\n\n    public Iterable<JipFrame> interactions(long threadId) {\n        return mThreads.get(threadId);\n    }\n\n    public Iterable<JipFrame> allCallers(JipMethod method) {\n        Set<JipFrame> set = new HashSet<JipFrame>();\n        PerMethodInfo perMethod = mPerMethods.get(method);\n        if (perMethod != null) {\n            for (JipFrame frame : perMethod.allFrames()) {\n                JipFrame parent = frame.getParentOrNull();\n                if (parent != null) {\n                    set.add(parent);\n                }\n            }\n        }\n        return set;\n    }\n\n    public Iterable<JipFrame> allCallees(JipMethod method) {\n        Set set = new HashSet<JipFrame>();\n        PerMethodInfo perMethod = mPerMethods.get(method);\n        if (perMethod != null) {\n            for (JipFrame frame : perMethod.allFrames()) {\n                for (JipFrame callee : frame.getChildren()) {\n                    set.add(callee);\n                }\n            }\n        }\n        return set;\n    }\n\n    /**\n     * Returns an iterable containing PerMethodInfos in descending totalTime\n     * order.\n     */\n    public List<PerMethodInfo> perMethodsInTotalTimeOrder() {\n        Comparator cmp = new Comparator<PerMethodInfo>() {\n\n            public int compare(PerMethodInfo a, PerMethodInfo b) {\n                long timeA = a.getAllThreadAllFramesTime();\n                long timeB = b.getAllThreadAllFramesTime();\n                if (timeA < timeB) {\n                    return -1;\n                } else if (timeA > timeB) {\n                    return 1;\n                } else {\n                    String nameA = a.getMethod().getMethodName();\n                    String nameB = a.getMethod().getMethodName();\n                    return nameA.compareToIgnoreCase(nameB);\n                }\n            }\n        };\n        List v = new ArrayList(mPerMethods.values());\n        Collections.sort(v, cmp);\n        return v;\n    }\n\n    public PerMethodInfo getPerMethod(JipMethod method) {\n        PerMethodInfo perMethod = mPerMethods.get(method);\n        if (perMethod == null) {\n            throw new RuntimeException(\"unknown method (\" + method + \")?\");\n        }\n        return perMethod;\n    }\n\n    static class PerMethodInfo {\n\n        private JipMethod mMethod;\n\n        // NOTE: mAllThreadsAllFramesTime includes times from *all* threads.\n        private long mAllThreadsAllFramesTime;\n\n        private long mAllThreadsAllFramesTimeIncludingReentrant;\n\n        private List<JipFrame> mvFrame = new ArrayList<JipFrame>();\n\n        PerMethodInfo(JipMethod method) {\n            mMethod = method;\n        }\n\n        JipMethod getMethod() {\n            return mMethod;\n        }\n\n        void addFrame(JipFrame frame) {\n            mvFrame.add(frame);\n            long frameTime = frame.getTotalTime();\n            mAllThreadsAllFramesTimeIncludingReentrant += frameTime;\n            if (!frame.isReentrant()) {\n                mAllThreadsAllFramesTime += frameTime;\n            }\n        }\n\n        long getAllThreadAllFramesTime() {\n            return mAllThreadsAllFramesTime;\n        }\n\n        long getAllThreadAllFramesTimeIncludingReentrant() {\n            return mAllThreadsAllFramesTimeIncludingReentrant;\n        }\n\n        Iterable<JipFrame> allFrames() {\n            return mvFrame;\n        }\n\n        public String toString() {\n            return mMethod.getMethodName();\n        }\n    }\n\n    private void updatePerMethodInfo(JipFrame frame) {\n        JipMethod method = frame.getMethod();\n        PerMethodInfo perMethod = mPerMethods.get(method);\n        if (perMethod == null) {\n            perMethod = new PerMethodInfo(method);\n            mPerMethods.put(method, perMethod);\n        }\n        perMethod.addFrame(frame);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/com/tivo/jipviewer/JipRunTest2.java",
		"test_prompt": "// JipRunTest2.java\npackage com.tivo.jipviewer;\n\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.HashMap;\nimport java.util.TreeMap;\nimport java.util.HashSet;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JipRun}.\n* It contains ten unit test cases for the {@link JipRun#allCallers(JipMethod)} method.\n*/\nclass JipRunTest2 {"
	},
	{
		"original_code": "// JipRun.java\n/*/////////////////////////////////////////////////////////////////////\n\nCopyright (C) 2006 TiVo Inc.  All rights reserved.\n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions are met:\n\n+ Redistributions of source code must retain the above copyright notice, \n  this list of conditions and the following disclaimer.\n+ Redistributions in binary form must reproduce the above copyright notice, \n  this list of conditions and the following disclaimer in the documentation \n  and/or other materials provided with the distribution.\n+ Neither the name of TiVo Inc nor the names of its contributors may be \n  used to endorse or promote products derived from this software without \n  specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \n  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE \n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \n  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \n  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \n  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n  POSSIBILITY OF SUCH DAMAGE.\n\n/////////////////////////////////////////////////////////////////////*/\npackage com.tivo.jipviewer;\n\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.HashMap;\nimport java.util.TreeMap;\nimport java.util.HashSet;\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass JipRun implements IJipParseHandler {\n\n    private String mDate;\n\n    // current thread, or 0 if none...\n    private long mCurThreadId;\n\n    // maps threadId (as Long) to List<JipFrame>\n    private Map<Long, List<JipFrame>> mThreads = new HashMap<Long, List<JipFrame>>();\n\n    // current interaction id or 0.\n    private long mCurInteractionId;\n\n    // current frame or null\n    private JipFrame mCurFrame;\n\n    // from each short class name to the full class name\n    private Map<String, String> mFullClassNames = new TreeMap();\n\n    // maps from a method to the PerMethodInfo for it.\n    private Map<JipMethod, PerMethodInfo> mPerMethods = new HashMap<JipMethod, PerMethodInfo>();\n\n    public void setDate(String date) {\n        if (mDate != null) {\n            throw new RuntimeException(\"already set date! (\" + mDate + \")\");\n        }\n        mDate = date;\n    }\n\n    public void startThread(long threadId) {\n        if (mCurThreadId != 0) {\n            throw new RuntimeException(\"already in thread \" + mCurThreadId);\n        }\n        mCurThreadId = threadId;\n    }\n\n    public void endThread() {\n        if (mCurThreadId == 0) {\n            throw new RuntimeException(\"there's no thread to end!\");\n        }\n        mCurThreadId = 0;\n    }\n\n    public void startInteraction(long id) {\n        if (mCurInteractionId != 0) {\n            throw new RuntimeException(\"already in interaction \" + mCurInteractionId);\n        }\n        mCurInteractionId = id;\n    }\n\n    public void endInteraction() {\n        if (mCurInteractionId == 0) {\n            throw new RuntimeException(\"there's no interaction to end!\");\n        }\n        mCurInteractionId = 0;\n    }\n\n    public void startFrame(String className, String methodName, long count, long time) {\n        //System.out.println(\"startFrame(\" + className + \", \" +\n        //methodName + \", \" + count + \", \" + time);\n        /*\n         * NOTE: I'm basically ignoring className because I don't really\n         *       see the usefulness of the split between className and\n         *       methodName in profile.xml.  If we're gonna use the classMap,\n         *       let's not include the full class name in the methodName.\n         */\n        JipMethod method = new JipMethod(methodName);\n        JipFrame frame = new JipFrame(mCurFrame, method, mCurThreadId, count, time);\n        if (mCurFrame == null) {\n            List<JipFrame> vFrame = mThreads.get(mCurThreadId);\n            if (vFrame == null) {\n                vFrame = new ArrayList<JipFrame>();\n                mThreads.put(mCurThreadId, vFrame);\n            }\n            vFrame.add(frame);\n        }\n        mCurFrame = frame;\n    }\n\n    public void endFrame() {\n        mCurFrame.computeNetTime();\n        updatePerMethodInfo(mCurFrame);\n        // pop!\n        mCurFrame = mCurFrame.getParentOrNull();\n    }\n\n    // allocations not handled -- i want some examples first -- :)\n    public void addToClassMap(String abbrev, String full) {\n        mFullClassNames.put(abbrev, full);\n    }\n\n    public String toString() {\n        StringBuffer buf = new StringBuffer();\n        buf.append(\"JipRun\\n\");\n        buf.append(\"{\\n\");\n        for (Long threadId : mThreads.keySet()) {\n            int i = 1;\n            for (JipFrame f : mThreads.get(threadId)) {\n                buf.append(\"* thread \" + threadId + \" interaction \" + i + \"\\n\");\n                buf.append(f);\n                i++;\n            }\n        }\n        buf.append(\"}\\n\");\n        return buf.toString();\n    }\n\n    public Iterable<Long> threads() {\n        return mThreads.keySet();\n    }\n\n    long getTotalTimeForAllThreads() {\n        long total = 0;\n        for (Long threadId : threads()) {\n            for (JipFrame frame : mThreads.get(threadId.longValue())) {\n                total += frame.getTotalTime();\n            }\n        }\n        return total;\n    }\n\n    public Iterable<JipFrame> interactions(long threadId) {\n        return mThreads.get(threadId);\n    }\n\n    public Iterable<JipFrame> allCallers(JipMethod method) {\n        Set<JipFrame> set = new HashSet<JipFrame>();\n        PerMethodInfo perMethod = mPerMethods.get(method);\n        if (perMethod != null) {\n            for (JipFrame frame : perMethod.allFrames()) {\n                JipFrame parent = frame.getParentOrNull();\n                if (parent != null) {\n                    set.add(parent);\n                }\n            }\n        }\n        return set;\n    }\n\n    public Iterable<JipFrame> allCallees(JipMethod method) {\n        Set set = new HashSet<JipFrame>();\n        PerMethodInfo perMethod = mPerMethods.get(method);\n        if (perMethod != null) {\n            for (JipFrame frame : perMethod.allFrames()) {\n                for (JipFrame callee : frame.getChildren()) {\n                    set.add(callee);\n                }\n            }\n        }\n        return set;\n    }\n\n    /**\n     * Returns an iterable containing PerMethodInfos in descending totalTime\n     * order.\n     */\n    public List<PerMethodInfo> perMethodsInTotalTimeOrder() {\n        Comparator cmp = new Comparator<PerMethodInfo>() {\n\n            public int compare(PerMethodInfo a, PerMethodInfo b) {\n                long timeA = a.getAllThreadAllFramesTime();\n                long timeB = b.getAllThreadAllFramesTime();\n                if (timeA < timeB) {\n                    return -1;\n                } else if (timeA > timeB) {\n                    return 1;\n                } else {\n                    String nameA = a.getMethod().getMethodName();\n                    String nameB = a.getMethod().getMethodName();\n                    return nameA.compareToIgnoreCase(nameB);\n                }\n            }\n        };\n        List v = new ArrayList(mPerMethods.values());\n        Collections.sort(v, cmp);\n        return v;\n    }\n\n    public PerMethodInfo getPerMethod(JipMethod method) {\n        PerMethodInfo perMethod = mPerMethods.get(method);\n        if (perMethod == null) {\n            throw new RuntimeException(\"unknown method (\" + method + \")?\");\n        }\n        return perMethod;\n    }\n\n    static class PerMethodInfo {\n\n        private JipMethod mMethod;\n\n        // NOTE: mAllThreadsAllFramesTime includes times from *all* threads.\n        private long mAllThreadsAllFramesTime;\n\n        private long mAllThreadsAllFramesTimeIncludingReentrant;\n\n        private List<JipFrame> mvFrame = new ArrayList<JipFrame>();\n\n        PerMethodInfo(JipMethod method) {\n            mMethod = method;\n        }\n\n        JipMethod getMethod() {\n            return mMethod;\n        }\n\n        void addFrame(JipFrame frame) {\n            mvFrame.add(frame);\n            long frameTime = frame.getTotalTime();\n            mAllThreadsAllFramesTimeIncludingReentrant += frameTime;\n            if (!frame.isReentrant()) {\n                mAllThreadsAllFramesTime += frameTime;\n            }\n        }\n\n        long getAllThreadAllFramesTime() {\n            return mAllThreadsAllFramesTime;\n        }\n\n        long getAllThreadAllFramesTimeIncludingReentrant() {\n            return mAllThreadsAllFramesTimeIncludingReentrant;\n        }\n\n        Iterable<JipFrame> allFrames() {\n            return mvFrame;\n        }\n\n        public String toString() {\n            return mMethod.getMethodName();\n        }\n    }\n\n    private void updatePerMethodInfo(JipFrame frame) {\n        JipMethod method = frame.getMethod();\n        PerMethodInfo perMethod = mPerMethods.get(method);\n        if (perMethod == null) {\n            perMethod = new PerMethodInfo(method);\n            mPerMethods.put(method, perMethod);\n        }\n        perMethod.addFrame(frame);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/com/tivo/jipviewer/JipRunTest3.java",
		"test_prompt": "// JipRunTest3.java\npackage com.tivo.jipviewer;\n\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.HashMap;\nimport java.util.TreeMap;\nimport java.util.HashSet;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JipRun}.\n* It contains ten unit test cases for the {@link JipRun#allCallees(JipMethod)} method.\n*/\nclass JipRunTest3 {"
	},
	{
		"original_code": "// JipRun.java\n/*/////////////////////////////////////////////////////////////////////\n\nCopyright (C) 2006 TiVo Inc.  All rights reserved.\n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions are met:\n\n+ Redistributions of source code must retain the above copyright notice, \n  this list of conditions and the following disclaimer.\n+ Redistributions in binary form must reproduce the above copyright notice, \n  this list of conditions and the following disclaimer in the documentation \n  and/or other materials provided with the distribution.\n+ Neither the name of TiVo Inc nor the names of its contributors may be \n  used to endorse or promote products derived from this software without \n  specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \n  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE \n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \n  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \n  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \n  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n  POSSIBILITY OF SUCH DAMAGE.\n\n/////////////////////////////////////////////////////////////////////*/\npackage com.tivo.jipviewer;\n\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.HashMap;\nimport java.util.TreeMap;\nimport java.util.HashSet;\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass JipRun implements IJipParseHandler {\n\n    private String mDate;\n\n    // current thread, or 0 if none...\n    private long mCurThreadId;\n\n    // maps threadId (as Long) to List<JipFrame>\n    private Map<Long, List<JipFrame>> mThreads = new HashMap<Long, List<JipFrame>>();\n\n    // current interaction id or 0.\n    private long mCurInteractionId;\n\n    // current frame or null\n    private JipFrame mCurFrame;\n\n    // from each short class name to the full class name\n    private Map<String, String> mFullClassNames = new TreeMap();\n\n    // maps from a method to the PerMethodInfo for it.\n    private Map<JipMethod, PerMethodInfo> mPerMethods = new HashMap<JipMethod, PerMethodInfo>();\n\n    public void setDate(String date) {\n        if (mDate != null) {\n            throw new RuntimeException(\"already set date! (\" + mDate + \")\");\n        }\n        mDate = date;\n    }\n\n    public void startThread(long threadId) {\n        if (mCurThreadId != 0) {\n            throw new RuntimeException(\"already in thread \" + mCurThreadId);\n        }\n        mCurThreadId = threadId;\n    }\n\n    public void endThread() {\n        if (mCurThreadId == 0) {\n            throw new RuntimeException(\"there's no thread to end!\");\n        }\n        mCurThreadId = 0;\n    }\n\n    public void startInteraction(long id) {\n        if (mCurInteractionId != 0) {\n            throw new RuntimeException(\"already in interaction \" + mCurInteractionId);\n        }\n        mCurInteractionId = id;\n    }\n\n    public void endInteraction() {\n        if (mCurInteractionId == 0) {\n            throw new RuntimeException(\"there's no interaction to end!\");\n        }\n        mCurInteractionId = 0;\n    }\n\n    public void startFrame(String className, String methodName, long count, long time) {\n        //System.out.println(\"startFrame(\" + className + \", \" +\n        //methodName + \", \" + count + \", \" + time);\n        /*\n         * NOTE: I'm basically ignoring className because I don't really\n         *       see the usefulness of the split between className and\n         *       methodName in profile.xml.  If we're gonna use the classMap,\n         *       let's not include the full class name in the methodName.\n         */\n        JipMethod method = new JipMethod(methodName);\n        JipFrame frame = new JipFrame(mCurFrame, method, mCurThreadId, count, time);\n        if (mCurFrame == null) {\n            List<JipFrame> vFrame = mThreads.get(mCurThreadId);\n            if (vFrame == null) {\n                vFrame = new ArrayList<JipFrame>();\n                mThreads.put(mCurThreadId, vFrame);\n            }\n            vFrame.add(frame);\n        }\n        mCurFrame = frame;\n    }\n\n    public void endFrame() {\n        mCurFrame.computeNetTime();\n        updatePerMethodInfo(mCurFrame);\n        // pop!\n        mCurFrame = mCurFrame.getParentOrNull();\n    }\n\n    // allocations not handled -- i want some examples first -- :)\n    public void addToClassMap(String abbrev, String full) {\n        mFullClassNames.put(abbrev, full);\n    }\n\n    public String toString() {\n        StringBuffer buf = new StringBuffer();\n        buf.append(\"JipRun\\n\");\n        buf.append(\"{\\n\");\n        for (Long threadId : mThreads.keySet()) {\n            int i = 1;\n            for (JipFrame f : mThreads.get(threadId)) {\n                buf.append(\"* thread \" + threadId + \" interaction \" + i + \"\\n\");\n                buf.append(f);\n                i++;\n            }\n        }\n        buf.append(\"}\\n\");\n        return buf.toString();\n    }\n\n    public Iterable<Long> threads() {\n        return mThreads.keySet();\n    }\n\n    long getTotalTimeForAllThreads() {\n        long total = 0;\n        for (Long threadId : threads()) {\n            for (JipFrame frame : mThreads.get(threadId.longValue())) {\n                total += frame.getTotalTime();\n            }\n        }\n        return total;\n    }\n\n    public Iterable<JipFrame> interactions(long threadId) {\n        return mThreads.get(threadId);\n    }\n\n    public Iterable<JipFrame> allCallers(JipMethod method) {\n        Set<JipFrame> set = new HashSet<JipFrame>();\n        PerMethodInfo perMethod = mPerMethods.get(method);\n        if (perMethod != null) {\n            for (JipFrame frame : perMethod.allFrames()) {\n                JipFrame parent = frame.getParentOrNull();\n                if (parent != null) {\n                    set.add(parent);\n                }\n            }\n        }\n        return set;\n    }\n\n    public Iterable<JipFrame> allCallees(JipMethod method) {\n        Set set = new HashSet<JipFrame>();\n        PerMethodInfo perMethod = mPerMethods.get(method);\n        if (perMethod != null) {\n            for (JipFrame frame : perMethod.allFrames()) {\n                for (JipFrame callee : frame.getChildren()) {\n                    set.add(callee);\n                }\n            }\n        }\n        return set;\n    }\n\n    /**\n     * Returns an iterable containing PerMethodInfos in descending totalTime\n     * order.\n     */\n    public List<PerMethodInfo> perMethodsInTotalTimeOrder() {\n        Comparator cmp = new Comparator<PerMethodInfo>() {\n\n            public int compare(PerMethodInfo a, PerMethodInfo b) {\n                long timeA = a.getAllThreadAllFramesTime();\n                long timeB = b.getAllThreadAllFramesTime();\n                if (timeA < timeB) {\n                    return -1;\n                } else if (timeA > timeB) {\n                    return 1;\n                } else {\n                    String nameA = a.getMethod().getMethodName();\n                    String nameB = a.getMethod().getMethodName();\n                    return nameA.compareToIgnoreCase(nameB);\n                }\n            }\n        };\n        List v = new ArrayList(mPerMethods.values());\n        Collections.sort(v, cmp);\n        return v;\n    }\n\n    public PerMethodInfo getPerMethod(JipMethod method) {\n        PerMethodInfo perMethod = mPerMethods.get(method);\n        if (perMethod == null) {\n            throw new RuntimeException(\"unknown method (\" + method + \")?\");\n        }\n        return perMethod;\n    }\n\n    static class PerMethodInfo {\n\n        private JipMethod mMethod;\n\n        // NOTE: mAllThreadsAllFramesTime includes times from *all* threads.\n        private long mAllThreadsAllFramesTime;\n\n        private long mAllThreadsAllFramesTimeIncludingReentrant;\n\n        private List<JipFrame> mvFrame = new ArrayList<JipFrame>();\n\n        PerMethodInfo(JipMethod method) {\n            mMethod = method;\n        }\n\n        JipMethod getMethod() {\n            return mMethod;\n        }\n\n        void addFrame(JipFrame frame) {\n            mvFrame.add(frame);\n            long frameTime = frame.getTotalTime();\n            mAllThreadsAllFramesTimeIncludingReentrant += frameTime;\n            if (!frame.isReentrant()) {\n                mAllThreadsAllFramesTime += frameTime;\n            }\n        }\n\n        long getAllThreadAllFramesTime() {\n            return mAllThreadsAllFramesTime;\n        }\n\n        long getAllThreadAllFramesTimeIncludingReentrant() {\n            return mAllThreadsAllFramesTimeIncludingReentrant;\n        }\n\n        Iterable<JipFrame> allFrames() {\n            return mvFrame;\n        }\n\n        public String toString() {\n            return mMethod.getMethodName();\n        }\n    }\n\n    private void updatePerMethodInfo(JipFrame frame) {\n        JipMethod method = frame.getMethod();\n        PerMethodInfo perMethod = mPerMethods.get(method);\n        if (perMethod == null) {\n            perMethod = new PerMethodInfo(method);\n            mPerMethods.put(method, perMethod);\n        }\n        perMethod.addFrame(frame);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/51_jiprof/src/main/java/com/tivo/jipviewer/JipRunTest4.java",
		"test_prompt": "// JipRunTest4.java\npackage com.tivo.jipviewer;\n\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.HashMap;\nimport java.util.TreeMap;\nimport java.util.HashSet;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JipRun}.\n* It contains ten unit test cases for the {@link JipRun#perMethodsInTotalTimeOrder()} method.\n*/\nclass JipRunTest4 {"
	}
]