[
	{
		"original_code": "// ExplosionBounds.java\npackage server;\r\n\r\nimport java.awt.Point;\r\n\r\n/**\r\n * This class is used by the server to define the bounds of a bomb explosion.\r\n * It contains four integer fields indicating the min/max pixel value\r\n * in the given direction that is affected by the explosion. It further offers\r\n * a method to test if a given point lies within the defined bounds.\r\n *\r\n * @author Steffen\r\n */\r\npublic class ExplosionBounds {\r\n\r\n    private int up;\r\n\r\n    private int down;\r\n\r\n    private int right;\r\n\r\n    private int left;\r\n\r\n    /**\r\n     * Creates a new ExplosionBounds object. The four integer parameters define\r\n     * the min/max pixel value in the given direction.\r\n     *\r\n     * @param up\r\n     * @param down\r\n     * @param right\r\n     * @param left\r\n     */\r\n    public ExplosionBounds(int up, int down, int right, int left) {\r\n        super();\r\n        this.up = up;\r\n        this.down = down;\r\n        this.right = right;\r\n        this.left = left;\r\n    }\r\n\r\n    public int getUp() {\r\n        return up;\r\n    }\r\n\r\n    public int getDown() {\r\n        return down;\r\n    }\r\n\r\n    public int getRight() {\r\n        return right;\r\n    }\r\n\r\n    public int getLeft() {\r\n        return left;\r\n    }\r\n\r\n    /**\r\n     * Checks whether the given point lies within the bounds of the explosion.\r\n     *\r\n     * @param p The Point to be checked.\r\n     * @return True if p lies within the bounds, false if not.\r\n     */\r\n    public boolean contain(Point p) {\r\n        if (up <= p.y && down >= p.y && right >= p.x && left <= p.x) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/server/ExplosionBoundsTest.java",
		"test_prompt": "// ExplosionBoundsTest.java\npackage server;\n\nimport java.awt.Point;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ExplosionBounds}.\n* It contains ten unit test cases for the {@link ExplosionBounds#contain(Point)} method.\n*/\nclass ExplosionBoundsTest {"
	},
	{
		"original_code": "// BomberServer.java\npackage server;\n\nimport java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport messages.Message;\nimport messages.global.GlobalServerMsg;\nimport messages.global.SessionDetailsMsg;\nimport messages.global.SessionListMsg;\nimport org.apache.log4j.Logger;\nimport org.hsqldb.Server;\nimport org.hsqldb.jdbc.jdbcDataSource;\nimport common.Constants;\n\n/**\n * This is the main server class. It is responsible for accepting connections\n * from clients and starting new games/session.\n *\n * @author Steffen, Bj�rn, Daniel\n */\npublic class BomberServer {\n\n    private static final Logger logger = Logger.getLogger(BomberServer.class);\n\n    /**\n     * The BomberServer singleton.\n     */\n    private static BomberServer bomberServer;\n\n    /**\n     * The ServerSocket on which connections are accepted.\n     */\n    private ServerSocket srvSocket;\n\n    /**\n     * The sessions currently running on this on this server. key: session name,\n     * value: corresponding session object\n     */\n    private HashMap<String, ServerGameSession> gameSessions = new HashMap<String, ServerGameSession>();\n\n    /**\n     * Contains all the clients who are currently in the global lobby.\n     */\n    private Vector<ClientInfo> globalClients = new Vector<ClientInfo>();\n\n    /**\n     * Contains all the clients who are currently connected to the Server.\n     */\n    private Vector<ClientInfo> allClients = new Vector<ClientInfo>();\n\n    private static int port = Constants.DEFAULT_SERVER_PORT;\n\n    private ServerGameSession newSession;\n\n    /**\n     * Private constructor. Creates a new BomberServer. Use the\n     * getInstance-method to obtain the BomberServer singleton.\n     */\n    private BomberServer() {\n        startDB();\n        try {\n            srvSocket = new ServerSocket(port);\n        } catch (IOException e) {\n            logger.fatal(\"Couldn't create ServerSocket\", e);\n        }\n    }\n\n    private void startDB() {\n        String[] options = new String[] { \"-database.0\", \"hsqldb/datenbank\", \"-dbname.0\", \"datenbank\" };\n        Server.main(options);\n    }\n\n    /**\n     * Main method. One optional parameter may be specified, which will be\n     * interpreted as the port number the server accepts client connections on.\n     *\n     * @param args\n     */\n    public static void main(String[] args) {\n        // try to read user-defined port if specified\n        if (args.length > 0) {\n            try {\n                port = Integer.valueOf(args[0]);\n            } catch (NumberFormatException e) {\n                logger.warn(\"Incorrect server port specified! Using default...\");\n            }\n        }\n        logger.info(\"Starting server on port: \" + port);\n        BomberServer bomberSrv = getInstance();\n        bomberSrv.waitForClients();\n    }\n\n    /**\n     * Accepts incoming client connections.\n     */\n    public void waitForClients() {\n        new Thread() {\n\n            public void run() {\n                logger.info(\"Waiting for players...\");\n                while (!isInterrupted()) {\n                    Socket clientSocket;\n                    try {\n                        clientSocket = srvSocket.accept();\n                        ClientInfo clientInfo = new ClientInfo(clientSocket);\n                        addClientToGlobal(clientInfo);\n                        addClient(clientInfo);\n                    } catch (IOException e) {\n                        logger.fatal(\"Couldn't accept connection on ServerSocket\", e);\n                    }\n                }\n            }\n        }.start();\n    }\n\n    /**\n     * Creates a new GameSession.\n     *\n     * @param name\n     * @param totalRounds\n     * @return The newly created GameSession-object, null if the session name\n     *         was already taken\n     */\n    public ServerGameSession createSession(String name, List<String> maps, ImageIcon mapPreview, int nrOfPlayers, int totalRounds) {\n        if (gameSessions.containsKey(name)) {\n            return null;\n        } else {\n            newSession = new ServerGameSession(name, maps, mapPreview, nrOfPlayers, totalRounds);\n            gameSessions.put(name, newSession);\n            newSession.broadcastMsg(new SessionListMsg());\n            broadcastSessionList();\n            return newSession;\n        }\n    }\n\n    /**\n     * Creates a SessionListMsg from all open sessions and\n     * sends it to all clients.\n     */\n    private void broadcastSessionList() {\n        SessionListMsg response = new SessionListMsg();\n        for (ServerGameSession session : getGameSessions()) {\n            // a session has at least one player in it (hacky)\n            int nrOfPlayers = 1;\n            if (session.getCurrentNrOfPlayers() != 0) {\n                nrOfPlayers = session.getCurrentNrOfPlayers();\n            }\n            SessionDetailsMsg sessionInfo = new SessionDetailsMsg(session.getName(), session.getMaps(), session.getPreview(), session.getTotalNrOfPlayers(), nrOfPlayers, session.getTotalRounds());\n            response.addSessionInfo(sessionInfo);\n        }\n        multicastMsg(response, null);\n    }\n\n    /**\n     * Sends the message to all clients except the original sender itself.\n     *\n     * @param msg\n     *            The message to be sent.\n     * @param sender\n     *            The original sender of the msg.\n     */\n    public void multicastMsg(Message msg, ClientInfo sender) {\n        for (ClientInfo participant : globalClients) {\n            if (participant != sender) {\n                participant.sendMsg(msg);\n            }\n        }\n    }\n\n    /**\n     * Broadcasts a message to all connected clients.\n     *\n     * @param msg\n     *            The message to be sent.\n     */\n    public void broadcastMsg(Message msg) {\n        for (ClientInfo client : globalClients) {\n            client.sendMsg(msg);\n        }\n    }\n\n    /**\n     * this will exit the server\n     *\n     * @author Bj�rn\n     */\n    public void stopServer() {\n        closeDB();\n        logger.info(\"Server stopped\");\n        System.exit(0);\n    }\n\n    // shutdown database\n    public static void closeDB() {\n        jdbcDataSource dataSource = setupDataSource();\n        try {\n            Connection connection = dataSource.getConnection();\n            Statement statement = connection.createStatement();\n            statement.execute(\"SHUTDOWN\");\n            statement.close();\n            connection.close();\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static jdbcDataSource setupDataSource() {\n        jdbcDataSource dataSource = new jdbcDataSource();\n        dataSource.setDatabase(\"jdbc:hsqldb:hsql://localhost/datenbank\");\n        dataSource.setUser(\"sa\");\n        dataSource.setPassword(\"\");\n        return dataSource;\n    }\n\n    /**\n     * Removes the client whose ClientInfo object is passed as a parameter from\n     * the global area. As a result this client will no longer receive global\n     * messages.\n     *\n     * @param clientInfo\n     */\n    public void removeClientFromGlobal(ClientInfo clientInfo) {\n        globalClients.remove(clientInfo);\n    }\n\n    public void addClientToGlobal(ClientInfo clientInfo) {\n        globalClients.add(clientInfo);\n    }\n\n    /**\n     * Removes a client\n     *\n     * @param clientInfo\n     */\n    public void removeClient(ClientInfo clientInfo) {\n        allClients.remove(clientInfo);\n    }\n\n    public void addClient(ClientInfo clientInfo) {\n        allClients.add(clientInfo);\n    }\n\n    /**\n     * Static factory method.\n     *\n     * @return The BomberServer Singleton\n     */\n    public static BomberServer getInstance() {\n        if (bomberServer == null) {\n            bomberServer = new BomberServer();\n        }\n        return bomberServer;\n    }\n\n    public Collection<ServerGameSession> getGameSessions() {\n        return gameSessions.values();\n    }\n\n    public ServerGameSession getGameSession(String name) {\n        return gameSessions.get(name);\n    }\n\n    public void removeSession(String name) {\n        gameSessions.remove(name);\n        newSession.broadcastMsg(new SessionListMsg());\n    }\n\n    public Vector<ClientInfo> getClients() {\n        return allClients;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/server/BomberServerTest0.java",
		"test_prompt": "// BomberServerTest0.java\npackage server;\n\nimport java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport messages.Message;\nimport messages.global.GlobalServerMsg;\nimport messages.global.SessionDetailsMsg;\nimport messages.global.SessionListMsg;\nimport org.apache.log4j.Logger;\nimport org.hsqldb.Server;\nimport org.hsqldb.jdbc.jdbcDataSource;\nimport common.Constants;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BomberServer}.\n* It contains ten unit test cases for the {@link BomberServer#createSession(String, List, ImageIcon, int, int)} method.\n*/\nclass BomberServerTest0 {"
	},
	{
		"original_code": "// BomberServer.java\npackage server;\n\nimport java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport messages.Message;\nimport messages.global.GlobalServerMsg;\nimport messages.global.SessionDetailsMsg;\nimport messages.global.SessionListMsg;\nimport org.apache.log4j.Logger;\nimport org.hsqldb.Server;\nimport org.hsqldb.jdbc.jdbcDataSource;\nimport common.Constants;\n\n/**\n * This is the main server class. It is responsible for accepting connections\n * from clients and starting new games/session.\n *\n * @author Steffen, Bj�rn, Daniel\n */\npublic class BomberServer {\n\n    private static final Logger logger = Logger.getLogger(BomberServer.class);\n\n    /**\n     * The BomberServer singleton.\n     */\n    private static BomberServer bomberServer;\n\n    /**\n     * The ServerSocket on which connections are accepted.\n     */\n    private ServerSocket srvSocket;\n\n    /**\n     * The sessions currently running on this on this server. key: session name,\n     * value: corresponding session object\n     */\n    private HashMap<String, ServerGameSession> gameSessions = new HashMap<String, ServerGameSession>();\n\n    /**\n     * Contains all the clients who are currently in the global lobby.\n     */\n    private Vector<ClientInfo> globalClients = new Vector<ClientInfo>();\n\n    /**\n     * Contains all the clients who are currently connected to the Server.\n     */\n    private Vector<ClientInfo> allClients = new Vector<ClientInfo>();\n\n    private static int port = Constants.DEFAULT_SERVER_PORT;\n\n    private ServerGameSession newSession;\n\n    /**\n     * Private constructor. Creates a new BomberServer. Use the\n     * getInstance-method to obtain the BomberServer singleton.\n     */\n    private BomberServer() {\n        startDB();\n        try {\n            srvSocket = new ServerSocket(port);\n        } catch (IOException e) {\n            logger.fatal(\"Couldn't create ServerSocket\", e);\n        }\n    }\n\n    private void startDB() {\n        String[] options = new String[] { \"-database.0\", \"hsqldb/datenbank\", \"-dbname.0\", \"datenbank\" };\n        Server.main(options);\n    }\n\n    /**\n     * Main method. One optional parameter may be specified, which will be\n     * interpreted as the port number the server accepts client connections on.\n     *\n     * @param args\n     */\n    public static void main(String[] args) {\n        // try to read user-defined port if specified\n        if (args.length > 0) {\n            try {\n                port = Integer.valueOf(args[0]);\n            } catch (NumberFormatException e) {\n                logger.warn(\"Incorrect server port specified! Using default...\");\n            }\n        }\n        logger.info(\"Starting server on port: \" + port);\n        BomberServer bomberSrv = getInstance();\n        bomberSrv.waitForClients();\n    }\n\n    /**\n     * Accepts incoming client connections.\n     */\n    public void waitForClients() {\n        new Thread() {\n\n            public void run() {\n                logger.info(\"Waiting for players...\");\n                while (!isInterrupted()) {\n                    Socket clientSocket;\n                    try {\n                        clientSocket = srvSocket.accept();\n                        ClientInfo clientInfo = new ClientInfo(clientSocket);\n                        addClientToGlobal(clientInfo);\n                        addClient(clientInfo);\n                    } catch (IOException e) {\n                        logger.fatal(\"Couldn't accept connection on ServerSocket\", e);\n                    }\n                }\n            }\n        }.start();\n    }\n\n    /**\n     * Creates a new GameSession.\n     *\n     * @param name\n     * @param totalRounds\n     * @return The newly created GameSession-object, null if the session name\n     *         was already taken\n     */\n    public ServerGameSession createSession(String name, List<String> maps, ImageIcon mapPreview, int nrOfPlayers, int totalRounds) {\n        if (gameSessions.containsKey(name)) {\n            return null;\n        } else {\n            newSession = new ServerGameSession(name, maps, mapPreview, nrOfPlayers, totalRounds);\n            gameSessions.put(name, newSession);\n            newSession.broadcastMsg(new SessionListMsg());\n            broadcastSessionList();\n            return newSession;\n        }\n    }\n\n    /**\n     * Creates a SessionListMsg from all open sessions and\n     * sends it to all clients.\n     */\n    private void broadcastSessionList() {\n        SessionListMsg response = new SessionListMsg();\n        for (ServerGameSession session : getGameSessions()) {\n            // a session has at least one player in it (hacky)\n            int nrOfPlayers = 1;\n            if (session.getCurrentNrOfPlayers() != 0) {\n                nrOfPlayers = session.getCurrentNrOfPlayers();\n            }\n            SessionDetailsMsg sessionInfo = new SessionDetailsMsg(session.getName(), session.getMaps(), session.getPreview(), session.getTotalNrOfPlayers(), nrOfPlayers, session.getTotalRounds());\n            response.addSessionInfo(sessionInfo);\n        }\n        multicastMsg(response, null);\n    }\n\n    /**\n     * Sends the message to all clients except the original sender itself.\n     *\n     * @param msg\n     *            The message to be sent.\n     * @param sender\n     *            The original sender of the msg.\n     */\n    public void multicastMsg(Message msg, ClientInfo sender) {\n        for (ClientInfo participant : globalClients) {\n            if (participant != sender) {\n                participant.sendMsg(msg);\n            }\n        }\n    }\n\n    /**\n     * Broadcasts a message to all connected clients.\n     *\n     * @param msg\n     *            The message to be sent.\n     */\n    public void broadcastMsg(Message msg) {\n        for (ClientInfo client : globalClients) {\n            client.sendMsg(msg);\n        }\n    }\n\n    /**\n     * this will exit the server\n     *\n     * @author Bj�rn\n     */\n    public void stopServer() {\n        closeDB();\n        logger.info(\"Server stopped\");\n        System.exit(0);\n    }\n\n    // shutdown database\n    public static void closeDB() {\n        jdbcDataSource dataSource = setupDataSource();\n        try {\n            Connection connection = dataSource.getConnection();\n            Statement statement = connection.createStatement();\n            statement.execute(\"SHUTDOWN\");\n            statement.close();\n            connection.close();\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static jdbcDataSource setupDataSource() {\n        jdbcDataSource dataSource = new jdbcDataSource();\n        dataSource.setDatabase(\"jdbc:hsqldb:hsql://localhost/datenbank\");\n        dataSource.setUser(\"sa\");\n        dataSource.setPassword(\"\");\n        return dataSource;\n    }\n\n    /**\n     * Removes the client whose ClientInfo object is passed as a parameter from\n     * the global area. As a result this client will no longer receive global\n     * messages.\n     *\n     * @param clientInfo\n     */\n    public void removeClientFromGlobal(ClientInfo clientInfo) {\n        globalClients.remove(clientInfo);\n    }\n\n    public void addClientToGlobal(ClientInfo clientInfo) {\n        globalClients.add(clientInfo);\n    }\n\n    /**\n     * Removes a client\n     *\n     * @param clientInfo\n     */\n    public void removeClient(ClientInfo clientInfo) {\n        allClients.remove(clientInfo);\n    }\n\n    public void addClient(ClientInfo clientInfo) {\n        allClients.add(clientInfo);\n    }\n\n    /**\n     * Static factory method.\n     *\n     * @return The BomberServer Singleton\n     */\n    public static BomberServer getInstance() {\n        if (bomberServer == null) {\n            bomberServer = new BomberServer();\n        }\n        return bomberServer;\n    }\n\n    public Collection<ServerGameSession> getGameSessions() {\n        return gameSessions.values();\n    }\n\n    public ServerGameSession getGameSession(String name) {\n        return gameSessions.get(name);\n    }\n\n    public void removeSession(String name) {\n        gameSessions.remove(name);\n        newSession.broadcastMsg(new SessionListMsg());\n    }\n\n    public Vector<ClientInfo> getClients() {\n        return allClients;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/server/BomberServerTest1.java",
		"test_prompt": "// BomberServerTest1.java\npackage server;\n\nimport java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport messages.Message;\nimport messages.global.GlobalServerMsg;\nimport messages.global.SessionDetailsMsg;\nimport messages.global.SessionListMsg;\nimport org.apache.log4j.Logger;\nimport org.hsqldb.Server;\nimport org.hsqldb.jdbc.jdbcDataSource;\nimport common.Constants;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BomberServer}.\n* It contains ten unit test cases for the {@link BomberServer#getInstance()} method.\n*/\nclass BomberServerTest1 {"
	},
	{
		"original_code": "// ServerBomb.java\npackage server;\r\n\r\nimport java.awt.Point;\r\nimport java.awt.Rectangle;\r\nimport java.util.Collection;\r\nimport java.util.Vector;\r\nimport messages.round.BombExplodedMsg;\r\nimport org.apache.log4j.Logger;\r\nimport common.Bomb;\r\nimport common.Constants;\r\nimport common.GameObject;\r\nimport common.Player;\r\nimport common.PowerUp;\r\nimport common.Tile;\r\nimport db.DBException;\r\nimport db.DBGameUser;\r\nimport db.DBServiceFactory;\r\n\r\n/**\r\n * The Bomb Object of the Server. This Bomb ticks some times and then exploded.\r\n * Then it detects the player and the tile hits.\r\n *\r\n * @author Bj�rn, Steffen, Daniel\r\n */\r\npublic class ServerBomb extends Bomb {\r\n\r\n    /**\r\n     * The negated number of frames rendered after an explosion\r\n     */\r\n    private static final int POST_EXPLOSION_FRAMES = -40;\r\n\r\n    private static final Logger logger = Logger.getLogger(ServerBomb.class);\r\n\r\n    private int tickTime = 2500;\r\n\r\n    private int tickFrames = tickTime / 16;\r\n\r\n    private ServerGameSession session;\r\n\r\n    private boolean hasAlreadyExploded;\r\n\r\n    private ExplosionBounds bounds;\r\n\r\n    private boolean explodesrightnow = false;\r\n\r\n    public ServerBomb(Point position, ServerGameSession session) {\r\n        super(position);\r\n        this.session = session;\r\n    }\r\n\r\n    @Override\r\n    protected synchronized void move() {\r\n    }\r\n\r\n    @Override\r\n    public synchronized void updateMovement(Point targetPosition) {\r\n        position.setLocation(targetPosition);\r\n    }\r\n\r\n    /**\r\n     * Handles the explosion and the hit-detection of the bomb\r\n     *\r\n     * @return\r\n     */\r\n    public void explode(Collection<GameObject> gameObjects) {\r\n        logger.info(\"Bomb exploded: \" + id);\r\n        bounds = getExplosionBounds(gameObjects);\r\n        explodesrightnow = true;\r\n        determineHits(gameObjects);\r\n        hasAlreadyExploded = true;\r\n    }\r\n\r\n    private void determineHits(Collection<GameObject> gameObjects) {\r\n        Vector<Integer> playerHits = new Vector<Integer>();\r\n        Vector<Integer> tileHits = new Vector<Integer>();\r\n        Vector<Integer> powerupHits = new Vector<Integer>();\r\n        for (GameObject gameObject : gameObjects) {\r\n            // hit players?\r\n            if (Player.class.isInstance(gameObject)) {\r\n                Player player = (Player) gameObject;\r\n                if (bounds.contain(player.getPosition()) && this.checkHit(gameObject)) {\r\n                    int playerid = player.getId();\r\n                    logger.info(\"exploded and check for hits \" + explodesrightnow);\r\n                    if (explodesrightnow == true) {\r\n                        if (getPlanterId() == playerid) {\r\n                            logger.info(playerid + \" killed himself \" + getPlanterId());\r\n                            session.getCurrentRound().addRoundScore(getPlanterId(), -1);\r\n                        } else {\r\n                            logger.info(playerid + \" scored one \" + getPlanterId());\r\n                            session.getCurrentRound().addRoundScore(getPlanterId(), 1);\r\n                        }\r\n                    }\r\n                    logger.info(\"Hit player: \" + gameObject.getId() + \" at \" + gameObject.getPosition());\r\n                    playerHits.add(gameObject.getId());\r\n                    gameObject.setInactive();\r\n                }\r\n            }\r\n            // hit tiles?\r\n            if (Tile.class.isInstance(gameObject)) {\r\n                Tile t = (Tile) gameObject;\r\n                if (t.isBombable()) {\r\n                    if (this.checkHit(t) && bounds.contain(t.getPosition())) {\r\n                        logger.info(\"Hit tile: \" + t.getId() + \" at \" + t.getPosition().x + \", \" + t.getPosition().y);\r\n                        tileHits.add(t.getId());\r\n                        t.setInactive();\r\n                    }\r\n                }\r\n            }\r\n            // hit powerups?\r\n            if (ServerPowerUp.class.isInstance(gameObject)) {\r\n                ServerPowerUp powerUp = (ServerPowerUp) gameObject;\r\n                if (!powerUp.isVisible() && powerUp.isActive()) {\r\n                    if (this.checkHit(powerUp) && bounds.contain(powerUp.getPosition())) {\r\n                        logger.info(\"Hit powerup: \" + powerUp.getId() + \" at \" + powerUp.getPosition().x + \", \" + powerUp.getPosition().y);\r\n                        powerUp.setVisible();\r\n                        powerupHits.add(powerUp.getId());\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (tickFrames == POST_EXPLOSION_FRAMES) {\r\n            active = false;\r\n        }\r\n        // msg is only sent the first time or if somebody ran into the explosion\r\n        if (!hasAlreadyExploded || !(playerHits.isEmpty() && tileHits.isEmpty())) {\r\n            BombExplodedMsg msg = new BombExplodedMsg(this.getId(), playerHits, tileHits, powerupHits, hasAlreadyExploded);\r\n            msg.setExplosionBounds(bounds);\r\n            session.broadcastMsg(msg);\r\n        }\r\n    }\r\n\r\n    private ExplosionBounds getExplosionBounds(Collection<GameObject> gameObjects) {\r\n        int distance = (diameter * Constants.TILE_BORDER) / 2;\r\n        int top, bottom, left, right;\r\n        top = position.y - distance;\r\n        bottom = position.y + distance;\r\n        left = position.x - distance;\r\n        right = position.x + distance;\r\n        for (GameObject gameObject : gameObjects) {\r\n            if (Tile.class.isInstance(gameObject)) {\r\n                Tile t = (Tile) gameObject;\r\n                // if (!t.isBombable()) {\r\n                Point pos = t.getPosition();\r\n                Point p = new Point(pos.x, pos.y);\r\n                if (getVerticalHitBox().contains(p)) {\r\n                    int y = p.y - position.y;\r\n                    if (y < 0) {\r\n                        top = Math.max(top, p.y);\r\n                    } else {\r\n                        bottom = Math.min(bottom, p.y);\r\n                    }\r\n                }\r\n                if (getHorizontalHitBox().contains(p)) {\r\n                    int x = p.x - position.x;\r\n                    if (x > 0) {\r\n                        right = Math.min(right, p.x);\r\n                    } else {\r\n                        left = Math.max(left, p.x);\r\n                    }\r\n                }\r\n                // }\r\n            }\r\n        }\r\n        logger.info(\"Explosion bounds: \");\r\n        logger.info(\"top: \" + top);\r\n        logger.info(\"bottom: \" + bottom);\r\n        logger.info(\"left: \" + left);\r\n        logger.info(\"right: \" + right);\r\n        return new ExplosionBounds(top, bottom, right, left);\r\n    }\r\n\r\n    /**\r\n     * Returns the vertical hitbox of the bomb\r\n     *\r\n     * @return\r\n     */\r\n    private Rectangle getVerticalHitBox() {\r\n        int x = position.getLocation().x - (Constants.TILE_BORDER / 2);\r\n        int y = position.getLocation().y - ((diameter * Constants.TILE_BORDER) / 2);\r\n        Rectangle rectangle = new Rectangle(x + 5, y, Constants.EXPLOSION_WIDTH, diameter * Constants.EXPLOSION_LENGTH - 1);\r\n        return rectangle;\r\n    }\r\n\r\n    /**\r\n     * Returns the horizontal hitbox of the bomb\r\n     *\r\n     * @return\r\n     */\r\n    private Rectangle getHorizontalHitBox() {\r\n        int x = position.getLocation().x - ((diameter * Constants.TILE_BORDER) / 2);\r\n        int y = position.getLocation().y - (Constants.TILE_BORDER / 2);\r\n        Rectangle rectangle = new Rectangle(x, y + 5, diameter * Constants.EXPLOSION_LENGTH - 1, Constants.EXPLOSION_WIDTH);\r\n        return rectangle;\r\n    }\r\n\r\n    @Override\r\n    public void updateWithCollisionCheck(Collection<GameObject> gameObjects) {\r\n        super.updateWithCollisionCheck(gameObjects);\r\n        if (stopped) {\r\n            if (tick()) {\r\n                explode(gameObjects);\r\n            } else if (tickFrames > POST_EXPLOSION_FRAMES && tickFrames < 0) {\r\n                // detect if a player ran into the explosion afterwards\r\n                // (explosion\r\n                // rendering\r\n                // lasts 8 frames)\r\n                determineHits(gameObjects);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * handles the tick of the bomb\r\n     *\r\n     * @return\r\n     */\r\n    public boolean tick() {\r\n        this.tickFrames--;\r\n        if (tickFrames == 0) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * check if a gameObject is hit by the bomb\r\n     *\r\n     * @param gameObject\r\n     * @return\r\n     */\r\n    private boolean checkHit(GameObject gameObject) {\r\n        Rectangle[] rects = new Rectangle[] { this.getHorizontalHitBox(), this.getVerticalHitBox() };\r\n        for (Rectangle rect : rects) {\r\n            if (this.id != gameObject.getId()) {\r\n                if (rect.intersects(gameObject.getCollisionRectangle())) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/server/ServerBombTest.java",
		"test_prompt": "// ServerBombTest.java\npackage server;\n\nimport java.awt.Point;\nimport java.awt.Rectangle;\nimport java.util.Collection;\nimport java.util.Vector;\nimport messages.round.BombExplodedMsg;\nimport org.apache.log4j.Logger;\nimport common.Bomb;\nimport common.Constants;\nimport common.GameObject;\nimport common.Player;\nimport common.PowerUp;\nimport common.Tile;\nimport db.DBException;\nimport db.DBGameUser;\nimport db.DBServiceFactory;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ServerBomb}.\n* It contains ten unit test cases for the {@link ServerBomb#tick()} method.\n*/\nclass ServerBombTest {"
	},
	{
		"original_code": "// StopServer.java\npackage server;\r\n\r\nimport java.io.IOException;\r\nimport java.io.ObjectOutputStream;\r\nimport java.net.Socket;\r\nimport messages.Message;\r\nimport messages.global.StopServerMsg;\r\n\r\n/**\r\n * Sends a Message to the Server, that he should closed\r\n *\r\n * @author Bj�rn\r\n */\r\npublic class StopServer {\r\n\r\n    private ObjectOutputStream out;\r\n\r\n    private Socket server;\r\n\r\n    private String serverName = \"193.196.141.182\";\r\n\r\n    private int serverPort = 6666;\r\n\r\n    /**\r\n     * sends a message\r\n     *\r\n     * @param msg\r\n     */\r\n    public void sendMsg(Message msg) {\r\n        try {\r\n            out.writeObject(msg);\r\n        } catch (IOException e) {\r\n            // TODO Auto-generated catch block\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Connect to the Server\r\n     */\r\n    public boolean connectToSrv() {\r\n        try {\r\n            //System.out.println(\"Connecting...\");\r\n            System.out.println(\"Establishing a connection \");\r\n            server = new Socket(serverName, serverPort);\r\n            out = new ObjectOutputStream(server.getOutputStream());\r\n            System.out.println(\"connected to \" + serverName);\r\n            return true;\r\n        } catch (IOException e) {\r\n            // TODO Auto-generated catch block\r\n            // e.printStackTrace();\r\n            System.out.println(\"Connection failed\");\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Connect to the server, and send the message\r\n     *\r\n     * @param stop\r\n     */\r\n    public void callingStopServer(StopServer stop) {\r\n        if (stop.connectToSrv()) {\r\n            System.out.println(\"stopping Server...\");\r\n            StopServerMsg msg = new StopServerMsg();\r\n            stop.sendMsg(msg);\r\n            System.out.println(\"Server stopped\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param args\r\n     */\r\n    public static void main(String[] args) {\r\n        StopServer stop = new StopServer();\r\n        stop.callingStopServer(stop);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/server/StopServerTest.java",
		"test_prompt": "// StopServerTest.java\npackage server;\n\nimport java.io.IOException;\nimport java.io.ObjectOutputStream;\nimport java.net.Socket;\nimport messages.Message;\nimport messages.global.StopServerMsg;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StopServer}.\n* It contains ten unit test cases for the {@link StopServer#connectToSrv()} method.\n*/\nclass StopServerTest {"
	},
	{
		"original_code": "// ServerPowerUp.java\npackage server;\r\n\r\nimport java.awt.Point;\r\nimport java.awt.Rectangle;\r\nimport java.util.Collection;\r\nimport org.apache.log4j.Logger;\r\nimport messages.round.PowerUpHitMsg;\r\nimport common.Actor;\r\nimport common.Constants;\r\nimport common.GameObject;\r\nimport common.Player;\r\nimport common.PowerUp;\r\n\r\n/**\r\n * @author Bj�rn\r\n */\r\npublic class ServerPowerUp extends PowerUp {\r\n\r\n    private static final Logger logger = Logger.getLogger(Actor.class);\r\n\r\n    private ServerGameSession session;\r\n\r\n    public ServerPowerUp(Point position, ServerGameSession session) {\r\n        super(position);\r\n        this.session = session;\r\n    }\r\n\r\n    /**\r\n     * {@inheritDoc}\r\n     */\r\n    @Override\r\n    public void updateWithCollisionCheck(Collection<GameObject> gameObjects) {\r\n        if (isVisible()) {\r\n            for (GameObject gameObject : gameObjects) {\r\n                if (ServerPlayer.class.isInstance(gameObject)) {\r\n                    ServerPlayer player = (ServerPlayer) gameObject;\r\n                    if (checkHit(player)) {\r\n                        PowerUpHitMsg msg = new PowerUpHitMsg(getTypeInt(), getId(), gameObject.getId());\r\n                        session.broadcastMsg(msg);\r\n                        if (getTypeInt() == 1) {\r\n                            player.increaseSpeed();\r\n                        }\r\n                        setInactive();\r\n                        setInvisible();\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * check if a gameObject hits the powerup.\r\n     *\r\n     * @param gameObject\r\n     * @return\r\n     */\r\n    public boolean checkHit(ServerPlayer player) {\r\n        Rectangle rect = getCollisionRectangle();\r\n        Rectangle rect2 = player.getCollisionRectangle();\r\n        if (this.getId() != player.getId()) {\r\n            if (rect.intersects(rect2)) {\r\n                logger.info(\"Player \" + player.getId() + \" hit Power UP \" + getId());\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/server/ServerPowerUpTest.java",
		"test_prompt": "// ServerPowerUpTest.java\npackage server;\n\nimport java.awt.Point;\nimport java.awt.Rectangle;\nimport java.util.Collection;\nimport org.apache.log4j.Logger;\nimport messages.round.PowerUpHitMsg;\nimport common.Actor;\nimport common.Constants;\nimport common.GameObject;\nimport common.Player;\nimport common.PowerUp;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ServerPowerUp}.\n* It contains ten unit test cases for the {@link ServerPowerUp#checkHit(ServerPlayer)} method.\n*/\nclass ServerPowerUpTest {"
	},
	{
		"original_code": "// ServerGameSession.java\npackage server;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.HashSet;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\nimport java.util.Set;\r\nimport java.util.Vector;\r\nimport java.util.Map.Entry;\r\nimport javax.swing.ImageIcon;\r\nimport messages.Message;\r\nimport messages.global.ParticipantInfo;\r\nimport messages.round.RoundScoreMsg;\r\nimport messages.session.InitializeRoundMsg;\r\nimport messages.session.SessionScoreMsg;\r\nimport org.apache.log4j.Logger;\r\nimport common.GameSession;\r\nimport db.DBException;\r\nimport db.DBGameUser;\r\nimport db.DBServiceFactory;\r\n\r\n/**\r\n * The server representation of a game session. A session may consist of several\r\n * rounds.\r\n *\r\n * @author Steffen\r\n * @see ServerGameRound\r\n */\r\npublic class ServerGameSession extends GameSession {\r\n\r\n    /**\r\n     * False if the first game round hasn't begun yet, true otherwise.\r\n     */\r\n    private boolean hasBegun = false;\r\n\r\n    private static final Logger logger = Logger.getLogger(ServerGameSession.class);\r\n\r\n    /**\r\n     * Iterates over the maps that have been selected for this session. The\r\n     * mapIterator is used by getNextMap().\r\n     */\r\n    private Iterator<String> mapIterator;\r\n\r\n    /**\r\n     * The current game round.\r\n     */\r\n    private ServerGameRound currentRound;\r\n\r\n    /**\r\n     * Contains the clients that have signaled that they are ready for the next\r\n     * round\r\n     */\r\n    private Set<ClientInfo> readyClients = new HashSet<ClientInfo>();\r\n\r\n    /**\r\n     * Is used by getNextIdOffset().\r\n     */\r\n    private int nextIdOffset = 1000000;\r\n\r\n    /**\r\n     * The ClientInfo objects of all clients parcticipating in this session.\r\n     */\r\n    private Vector<ClientInfo> participants = new Vector<ClientInfo>();\r\n\r\n    protected HashMap<String, Integer> sessionScores = new HashMap<String, Integer>();\r\n\r\n    public HashMap<String, Integer> getSessionScores() {\r\n        return sessionScores;\r\n    }\r\n\r\n    public ClientInfo getParticipantById(int id) {\r\n        for (int i = 0; i < participants.size(); i++) {\r\n            ClientInfo participant = participants.get(i);\r\n            if (participant.getIdOffset() == id) {\r\n                return participant;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Creates a new ServerGameSession.\r\n     *\r\n     * @param name\r\n     *            The session name.\r\n     * @param maps\r\n     *            A List of Strings containing the names of the maps to be\r\n     *            played in this session.\r\n     * @param totalNrOfPlayers\r\n     *            The total number of players that are expected to participate\r\n     *            in this session.\r\n     * @param totalRounds\r\n     *            The Total number of rounds to be played in this session.\r\n     */\r\n    public ServerGameSession(String name, List<String> maps, ImageIcon mapPreview, int totalNrOfPlayers, int totalRounds) {\r\n        super(name, maps, mapPreview, totalNrOfPlayers, totalRounds);\r\n        this.mapIterator = maps.iterator();\r\n    }\r\n\r\n    /**\r\n     * @param participant\r\n     * @return -1 if the session was already full, the idOffset if the\r\n     *         participant was succesfully added.\r\n     */\r\n    synchronized public int addParticipant(ClientInfo participant) {\r\n        if (participants.size() >= totalNrOfPlayers || participants.contains(participant)) {\r\n            logger.info(\"Couldn't add \" + participant.getName());\r\n            return -1;\r\n        } else {\r\n            logger.info(\"Adding client \" + participant.getName() + \" to session \" + name);\r\n            participants.add(participant);\r\n            return getNextIdOffset();\r\n        }\r\n    }\r\n\r\n    public void beginRoundIfReady() {\r\n        if (participants.size() == totalNrOfPlayers) {\r\n            // for logging\r\n            StringBuffer playerNames = new StringBuffer();\r\n            for (ClientInfo participant : participants) {\r\n                playerNames.append(participant.getName());\r\n                playerNames.append(\", \");\r\n            }\r\n            logger.info(\"Beginning round with players: \" + playerNames.toString());\r\n            hasBegun = true;\r\n            beginRound();\r\n            // remove the session from the global list after it started, so that\r\n            // no more clients can try to join\r\n            BomberServer.getInstance().removeSession(name);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the next idOffset. An idOffset is unique for within a session.\r\n     * Based on its idOffset each client can create unique IDs for the objects\r\n     * it adds to the game model.\r\n     *\r\n     * @return The next idOffset.\r\n     */\r\n    private int getNextIdOffset() {\r\n        int result = nextIdOffset;\r\n        nextIdOffset += 1000000;\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Removes the given participant.\r\n     *\r\n     * @param participant\r\n     */\r\n    synchronized public void removeParticipant(ClientInfo participant) {\r\n        logger.info(\"Removing participant \" + participant.getName() + \" from session \" + name);\r\n        participants.remove(participant);\r\n        // If a client disconnects and the first round is currently going on or\r\n        // has already been played, the expected number of players must be\r\n        // adjusted, so\r\n        // that the next round can start normally.\r\n        if (hasBegun) {\r\n            totalNrOfPlayers--;\r\n        }\r\n        if (participants.isEmpty()) {\r\n            logger.info(\"Removing session \" + name + \"(empty)\");\r\n            BomberServer.getInstance().removeSession(name);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Broacasts the given message to all clients in this session.\r\n     *\r\n     * @param msg\r\n     */\r\n    public void broadcastMsg(Message msg) {\r\n        for (ClientInfo participant : participants) {\r\n            participant.sendMsg(msg);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * {@inheritDoc}\r\n     */\r\n    @Override\r\n    public void beginRound() {\r\n        logger.info(\"Beginning new game round...\");\r\n        currentRoundNr++;\r\n        currentRound = new ServerGameRound(this, participants, getNextMap());\r\n        currentRound.begin();\r\n    }\r\n\r\n    private String getNextMap() {\r\n        if (!mapIterator.hasNext()) {\r\n            mapIterator = maps.iterator();\r\n        }\r\n        return mapIterator.next();\r\n    }\r\n\r\n    /**\r\n     * Sends the message to all clients except the original sender itself.\r\n     *\r\n     * @param msg\r\n     *            The message to be sent.\r\n     * @param sender\r\n     *            The original sender of the msg.\r\n     */\r\n    public void multicastMsg(Message msg, ClientInfo sender) {\r\n        for (ClientInfo participant : participants) {\r\n            if (participant != sender) {\r\n                participant.sendMsg(msg);\r\n            }\r\n        }\r\n    }\r\n\r\n    public ServerGameRound getCurrentRound() {\r\n        return currentRound;\r\n    }\r\n\r\n    /**\r\n     * @param scores\r\n     */\r\n    public void addRoundScore(HashMap<Integer, Integer> scores) {\r\n        for (Entry<Integer, Integer> entry : scores.entrySet()) {\r\n            int key = entry.getKey();\r\n            int score = entry.getValue();\r\n            int oldscore = 0;\r\n            if (this.scores.get(key) != null) {\r\n                oldscore = this.scores.get(key);\r\n            }\r\n            this.scores.put(key, oldscore + score);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculates the session scores and if there are more rounds to be played\r\n     * initializes the wait for all players to send the ready signal.\r\n     */\r\n    @Override\r\n    public void doPostRoundProcessing() {\r\n        logger.info(\"Doing post round processing...\");\r\n        logger.info(\"Calculating scores...\");\r\n        addRoundScore(currentRound.getScores());\r\n        broadcastMsg(new RoundScoreMsg(currentRound.roundScores));\r\n        currentRound = null;\r\n        // if there are more rounds to be played wait for all players to be\r\n        // ready\r\n        if (currentRoundNr < totalRounds) {\r\n            initializeWait();\r\n            logger.info(\"Waiting for players to be ready for next round...\");\r\n        } else {\r\n            // else end the session\r\n            logger.info(\"servergamesession ended\");\r\n            doPostSessionProcessing();\r\n            logger.info(\"/servergamesession ended\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes all clients from the session and puts them back into the global\r\n     * lobby. Then removes the session object from the session list.\r\n     */\r\n    @Override\r\n    protected void doPostSessionProcessing() {\r\n        logger.info(\"Doing post session processing...\");\r\n        logger.info(\"writing scores to db\");\r\n        aggregateScore();\r\n        broadcastMsg(new SessionScoreMsg(sessionScores));\r\n        BomberServer bomberSrv = BomberServer.getInstance();\r\n        // doesn't work properly\r\n        // TODO: participants leave right after session end\r\n        // but they are needed for clientside highscore calculation\r\n        while (!participants.isEmpty()) {\r\n            logger.info(\"ServerGameSession -> leaving\");\r\n            ClientInfo participant = participants.firstElement();\r\n            participant.leaveGameSession();\r\n            bomberSrv.addClientToGlobal(participant);\r\n            logger.info(\"/ServerGameSession -> leaving\");\r\n        }\r\n        bomberSrv.removeSession(name);\r\n    }\r\n\r\n    /**\r\n     * Initializes the wait for all clients to be marked ready for the next\r\n     * round.\r\n     */\r\n    private void initializeWait() {\r\n        readyClients = new HashSet<ClientInfo>(participants.size());\r\n    }\r\n\r\n    public void aggregateScore() {\r\n        for (int i = 0; i < participants.size(); i++) {\r\n            ClientInfo cf = participants.get(i);\r\n            int score = 0;\r\n            for (Entry<Integer, Integer> entry : this.scores.entrySet()) {\r\n                if (entry.getKey() == cf.getIdOffset()) {\r\n                    score = entry.getValue();\r\n                }\r\n            }\r\n            logger.info(\"DB writing --> processing \" + cf.getName() + \" \" + cf.getIdOffset() + \" \" + score);\r\n            try {\r\n                sessionScores.put(cf.getName(), score);\r\n                DBGameUser user = DBServiceFactory.getInstance().getDBUser(cf.getName());\r\n                if (user.getName() != null && !user.getName().equals(\"\")) {\r\n                    user.setScore(user.getScore() + score);\r\n                    DBServiceFactory.getInstance().updateScore(user);\r\n                }\r\n            } catch (DBException e) {\r\n                logger.error(\"DB Error: \" + e.toString());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return The number of clients currently in this session.\r\n     */\r\n    public int getCurrentNrOfPlayers() {\r\n        return participants.size();\r\n    }\r\n\r\n    /**\r\n     * Marks the given client ready for the next round.\r\n     *\r\n     * @param clientInfo\r\n     *            The client to be marked ready.\r\n     */\r\n    public void markClientReady(ClientInfo clientInfo) {\r\n        logger.info(clientInfo.getName() + \" is ready for the next round.\");\r\n        readyClients.add(clientInfo);\r\n        if (readyClients.size() == participants.size()) {\r\n            beginRound();\r\n        }\r\n    }\r\n\r\n    public List<ParticipantInfo> getParticipantInfos() {\r\n        List<ParticipantInfo> participantInfos = new ArrayList<ParticipantInfo>();\r\n        for (ClientInfo participant : participants) {\r\n            String name = participant.getName();\r\n            int id = participant.getIdOffset();\r\n            ParticipantInfo participantInfo = new ParticipantInfo(id, name);\r\n            participantInfos.add(participantInfo);\r\n        }\r\n        return participantInfos;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/server/ServerGameSessionTest.java",
		"test_prompt": "// ServerGameSessionTest.java\npackage server;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.Vector;\nimport java.util.Map.Entry;\nimport javax.swing.ImageIcon;\nimport messages.Message;\nimport messages.global.ParticipantInfo;\nimport messages.round.RoundScoreMsg;\nimport messages.session.InitializeRoundMsg;\nimport messages.session.SessionScoreMsg;\nimport org.apache.log4j.Logger;\nimport common.GameSession;\nimport db.DBException;\nimport db.DBGameUser;\nimport db.DBServiceFactory;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ServerGameSession}.\n* It contains ten unit test cases for the {@link ServerGameSession#addParticipant(ClientInfo)} method.\n*/\nclass ServerGameSessionTest {"
	},
	{
		"original_code": "// ServerLogin.java\npackage server;\r\n\r\nimport org.apache.log4j.Logger;\r\nimport db.DBException;\r\nimport db.DBGameUser;\r\nimport db.DBServiceFactory;\r\n\r\n/**\r\n * The Class for the login and the registration\r\n *\r\n * @author Bj�rn\r\n */\r\npublic class ServerLogin {\r\n\r\n    public static final int LOGIN_SUCCESSFUL = 1;\r\n\r\n    public static final int USERNAME_TAKEN = 2;\r\n\r\n    public static final int WRONG_PASSWORD = 3;\r\n\r\n    public static final int WRONG_USERNAME = 4;\r\n\r\n    public static final int USER_STILL_LOGGED_IN = 5;\r\n\r\n    /**\r\n     * the DBGameUser object\r\n     */\r\n    private DBGameUser user = null;\r\n\r\n    /**\r\n     * the status of the login\r\n     */\r\n    private int status;\r\n\r\n    /**\r\n     * the logger for login\r\n     */\r\n    private static final Logger logger = Logger.getLogger(BomberServer.class);\r\n\r\n    /**\r\n     * Handles the register of a new user.\r\n     *\r\n     * @param username\r\n     * @param password\r\n     * @return boolean status, true if register is correct\r\n     */\r\n    public int register(String username, String password) {\r\n        try {\r\n            user = DBServiceFactory.getInstance().getDBUser(username);\r\n            if (user.getName() == null) {\r\n                for (ClientInfo client : BomberServer.getInstance().getClients()) {\r\n                    if (client.getName() != null) {\r\n                        if (client.getName().equals(username)) {\r\n                            status = USERNAME_TAKEN;\r\n                            break;\r\n                        } else {\r\n                            status = LOGIN_SUCCESSFUL;\r\n                        }\r\n                    } else {\r\n                        status = LOGIN_SUCCESSFUL;\r\n                    }\r\n                }\r\n            } else {\r\n                status = USERNAME_TAKEN;\r\n            }\r\n            if (status == LOGIN_SUCCESSFUL) {\r\n                logger.info(\"creating user \" + username);\r\n                user = new DBGameUser();\r\n                user.setName(username);\r\n                user.setPassword(password);\r\n                user.setScore(0);\r\n                DBServiceFactory.getInstance().saveGameUser(user);\r\n                status = LOGIN_SUCCESSFUL;\r\n                String userstr = DBServiceFactory.getInstance().getDBUser(user.getName()).toString();\r\n                logger.info(userstr);\r\n                logger.info(\"register as \" + username + \" correct!\");\r\n            }\r\n        } catch (DBException e) {\r\n        }\r\n        return status;\r\n    }\r\n\r\n    /**\r\n     * Handles the login as a registered user.\r\n     *\r\n     * @param username\r\n     * @param password\r\n     * @return boolean status, true if login is correct\r\n     */\r\n    public int login(String username, String password) {\r\n        try {\r\n            user = DBServiceFactory.getInstance().getDBUser(username);\r\n            if (user.getName() != null) {\r\n                if (password.equals(user.getPassword())) {\r\n                    for (ClientInfo client : BomberServer.getInstance().getClients()) {\r\n                        if (client.getName() != null) {\r\n                            if (client.getName().equals(username)) {\r\n                                status = USER_STILL_LOGGED_IN;\r\n                                break;\r\n                            } else {\r\n                                status = LOGIN_SUCCESSFUL;\r\n                            }\r\n                        } else {\r\n                            status = LOGIN_SUCCESSFUL;\r\n                        }\r\n                    }\r\n                } else {\r\n                    status = WRONG_PASSWORD;\r\n                }\r\n            } else {\r\n                status = WRONG_USERNAME;\r\n            }\r\n            if (status == LOGIN_SUCCESSFUL) {\r\n                logger.info(\"login as \" + username + \" correct!\");\r\n            }\r\n        } catch (DBException e) {\r\n        }\r\n        return status;\r\n    }\r\n\r\n    /**\r\n     * Handles the login as a guest.\r\n     *\r\n     * @param username\r\n     * @return boolean status, true if login is correct\r\n     */\r\n    public int loginGuest(String username) {\r\n        try {\r\n            if (username.equals(\"\")) {\r\n                return WRONG_USERNAME;\r\n            }\r\n            logger.info(\"loginGuest called \" + username);\r\n            user = DBServiceFactory.getInstance().getDBUser(username);\r\n            if (user == null || user.getName() == null || user.getName().equals(\"\")) {\r\n                logger.info(\"loginGuest user not in db \" + username);\r\n                register(username, \"\");\r\n                user = DBServiceFactory.getInstance().getDBUser(username);\r\n            }\r\n            if (user != null && (user.getPassword() == null || user.getPassword().equals(\"\"))) {\r\n                logger.info(\"user \" + username + \" (Guest) logged with score \" + user.getScore());\r\n                for (ClientInfo client : BomberServer.getInstance().getClients()) {\r\n                    if (client.getName() != null) {\r\n                        if (client.getName().equals(username)) {\r\n                            status = USERNAME_TAKEN;\r\n                            break;\r\n                        } else {\r\n                            status = LOGIN_SUCCESSFUL;\r\n                        }\r\n                    } else {\r\n                        status = LOGIN_SUCCESSFUL;\r\n                    }\r\n                }\r\n            } else {\r\n                status = USERNAME_TAKEN;\r\n            }\r\n        } catch (DBException e) {\r\n        }\r\n        if (status == LOGIN_SUCCESSFUL) {\r\n            logger.info(\"login as \" + username + \" correct!\");\r\n        }\r\n        return status;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/server/ServerLoginTest0.java",
		"test_prompt": "// ServerLoginTest0.java\npackage server;\n\nimport org.apache.log4j.Logger;\nimport db.DBException;\nimport db.DBGameUser;\nimport db.DBServiceFactory;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ServerLogin}.\n* It contains ten unit test cases for the {@link ServerLogin#register(String, String)} method.\n*/\nclass ServerLoginTest0 {"
	},
	{
		"original_code": "// ServerLogin.java\npackage server;\r\n\r\nimport org.apache.log4j.Logger;\r\nimport db.DBException;\r\nimport db.DBGameUser;\r\nimport db.DBServiceFactory;\r\n\r\n/**\r\n * The Class for the login and the registration\r\n *\r\n * @author Bj�rn\r\n */\r\npublic class ServerLogin {\r\n\r\n    public static final int LOGIN_SUCCESSFUL = 1;\r\n\r\n    public static final int USERNAME_TAKEN = 2;\r\n\r\n    public static final int WRONG_PASSWORD = 3;\r\n\r\n    public static final int WRONG_USERNAME = 4;\r\n\r\n    public static final int USER_STILL_LOGGED_IN = 5;\r\n\r\n    /**\r\n     * the DBGameUser object\r\n     */\r\n    private DBGameUser user = null;\r\n\r\n    /**\r\n     * the status of the login\r\n     */\r\n    private int status;\r\n\r\n    /**\r\n     * the logger for login\r\n     */\r\n    private static final Logger logger = Logger.getLogger(BomberServer.class);\r\n\r\n    /**\r\n     * Handles the register of a new user.\r\n     *\r\n     * @param username\r\n     * @param password\r\n     * @return boolean status, true if register is correct\r\n     */\r\n    public int register(String username, String password) {\r\n        try {\r\n            user = DBServiceFactory.getInstance().getDBUser(username);\r\n            if (user.getName() == null) {\r\n                for (ClientInfo client : BomberServer.getInstance().getClients()) {\r\n                    if (client.getName() != null) {\r\n                        if (client.getName().equals(username)) {\r\n                            status = USERNAME_TAKEN;\r\n                            break;\r\n                        } else {\r\n                            status = LOGIN_SUCCESSFUL;\r\n                        }\r\n                    } else {\r\n                        status = LOGIN_SUCCESSFUL;\r\n                    }\r\n                }\r\n            } else {\r\n                status = USERNAME_TAKEN;\r\n            }\r\n            if (status == LOGIN_SUCCESSFUL) {\r\n                logger.info(\"creating user \" + username);\r\n                user = new DBGameUser();\r\n                user.setName(username);\r\n                user.setPassword(password);\r\n                user.setScore(0);\r\n                DBServiceFactory.getInstance().saveGameUser(user);\r\n                status = LOGIN_SUCCESSFUL;\r\n                String userstr = DBServiceFactory.getInstance().getDBUser(user.getName()).toString();\r\n                logger.info(userstr);\r\n                logger.info(\"register as \" + username + \" correct!\");\r\n            }\r\n        } catch (DBException e) {\r\n        }\r\n        return status;\r\n    }\r\n\r\n    /**\r\n     * Handles the login as a registered user.\r\n     *\r\n     * @param username\r\n     * @param password\r\n     * @return boolean status, true if login is correct\r\n     */\r\n    public int login(String username, String password) {\r\n        try {\r\n            user = DBServiceFactory.getInstance().getDBUser(username);\r\n            if (user.getName() != null) {\r\n                if (password.equals(user.getPassword())) {\r\n                    for (ClientInfo client : BomberServer.getInstance().getClients()) {\r\n                        if (client.getName() != null) {\r\n                            if (client.getName().equals(username)) {\r\n                                status = USER_STILL_LOGGED_IN;\r\n                                break;\r\n                            } else {\r\n                                status = LOGIN_SUCCESSFUL;\r\n                            }\r\n                        } else {\r\n                            status = LOGIN_SUCCESSFUL;\r\n                        }\r\n                    }\r\n                } else {\r\n                    status = WRONG_PASSWORD;\r\n                }\r\n            } else {\r\n                status = WRONG_USERNAME;\r\n            }\r\n            if (status == LOGIN_SUCCESSFUL) {\r\n                logger.info(\"login as \" + username + \" correct!\");\r\n            }\r\n        } catch (DBException e) {\r\n        }\r\n        return status;\r\n    }\r\n\r\n    /**\r\n     * Handles the login as a guest.\r\n     *\r\n     * @param username\r\n     * @return boolean status, true if login is correct\r\n     */\r\n    public int loginGuest(String username) {\r\n        try {\r\n            if (username.equals(\"\")) {\r\n                return WRONG_USERNAME;\r\n            }\r\n            logger.info(\"loginGuest called \" + username);\r\n            user = DBServiceFactory.getInstance().getDBUser(username);\r\n            if (user == null || user.getName() == null || user.getName().equals(\"\")) {\r\n                logger.info(\"loginGuest user not in db \" + username);\r\n                register(username, \"\");\r\n                user = DBServiceFactory.getInstance().getDBUser(username);\r\n            }\r\n            if (user != null && (user.getPassword() == null || user.getPassword().equals(\"\"))) {\r\n                logger.info(\"user \" + username + \" (Guest) logged with score \" + user.getScore());\r\n                for (ClientInfo client : BomberServer.getInstance().getClients()) {\r\n                    if (client.getName() != null) {\r\n                        if (client.getName().equals(username)) {\r\n                            status = USERNAME_TAKEN;\r\n                            break;\r\n                        } else {\r\n                            status = LOGIN_SUCCESSFUL;\r\n                        }\r\n                    } else {\r\n                        status = LOGIN_SUCCESSFUL;\r\n                    }\r\n                }\r\n            } else {\r\n                status = USERNAME_TAKEN;\r\n            }\r\n        } catch (DBException e) {\r\n        }\r\n        if (status == LOGIN_SUCCESSFUL) {\r\n            logger.info(\"login as \" + username + \" correct!\");\r\n        }\r\n        return status;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/server/ServerLoginTest1.java",
		"test_prompt": "// ServerLoginTest1.java\npackage server;\n\nimport org.apache.log4j.Logger;\nimport db.DBException;\nimport db.DBGameUser;\nimport db.DBServiceFactory;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ServerLogin}.\n* It contains ten unit test cases for the {@link ServerLogin#login(String, String)} method.\n*/\nclass ServerLoginTest1 {"
	},
	{
		"original_code": "// ServerLogin.java\npackage server;\r\n\r\nimport org.apache.log4j.Logger;\r\nimport db.DBException;\r\nimport db.DBGameUser;\r\nimport db.DBServiceFactory;\r\n\r\n/**\r\n * The Class for the login and the registration\r\n *\r\n * @author Bj�rn\r\n */\r\npublic class ServerLogin {\r\n\r\n    public static final int LOGIN_SUCCESSFUL = 1;\r\n\r\n    public static final int USERNAME_TAKEN = 2;\r\n\r\n    public static final int WRONG_PASSWORD = 3;\r\n\r\n    public static final int WRONG_USERNAME = 4;\r\n\r\n    public static final int USER_STILL_LOGGED_IN = 5;\r\n\r\n    /**\r\n     * the DBGameUser object\r\n     */\r\n    private DBGameUser user = null;\r\n\r\n    /**\r\n     * the status of the login\r\n     */\r\n    private int status;\r\n\r\n    /**\r\n     * the logger for login\r\n     */\r\n    private static final Logger logger = Logger.getLogger(BomberServer.class);\r\n\r\n    /**\r\n     * Handles the register of a new user.\r\n     *\r\n     * @param username\r\n     * @param password\r\n     * @return boolean status, true if register is correct\r\n     */\r\n    public int register(String username, String password) {\r\n        try {\r\n            user = DBServiceFactory.getInstance().getDBUser(username);\r\n            if (user.getName() == null) {\r\n                for (ClientInfo client : BomberServer.getInstance().getClients()) {\r\n                    if (client.getName() != null) {\r\n                        if (client.getName().equals(username)) {\r\n                            status = USERNAME_TAKEN;\r\n                            break;\r\n                        } else {\r\n                            status = LOGIN_SUCCESSFUL;\r\n                        }\r\n                    } else {\r\n                        status = LOGIN_SUCCESSFUL;\r\n                    }\r\n                }\r\n            } else {\r\n                status = USERNAME_TAKEN;\r\n            }\r\n            if (status == LOGIN_SUCCESSFUL) {\r\n                logger.info(\"creating user \" + username);\r\n                user = new DBGameUser();\r\n                user.setName(username);\r\n                user.setPassword(password);\r\n                user.setScore(0);\r\n                DBServiceFactory.getInstance().saveGameUser(user);\r\n                status = LOGIN_SUCCESSFUL;\r\n                String userstr = DBServiceFactory.getInstance().getDBUser(user.getName()).toString();\r\n                logger.info(userstr);\r\n                logger.info(\"register as \" + username + \" correct!\");\r\n            }\r\n        } catch (DBException e) {\r\n        }\r\n        return status;\r\n    }\r\n\r\n    /**\r\n     * Handles the login as a registered user.\r\n     *\r\n     * @param username\r\n     * @param password\r\n     * @return boolean status, true if login is correct\r\n     */\r\n    public int login(String username, String password) {\r\n        try {\r\n            user = DBServiceFactory.getInstance().getDBUser(username);\r\n            if (user.getName() != null) {\r\n                if (password.equals(user.getPassword())) {\r\n                    for (ClientInfo client : BomberServer.getInstance().getClients()) {\r\n                        if (client.getName() != null) {\r\n                            if (client.getName().equals(username)) {\r\n                                status = USER_STILL_LOGGED_IN;\r\n                                break;\r\n                            } else {\r\n                                status = LOGIN_SUCCESSFUL;\r\n                            }\r\n                        } else {\r\n                            status = LOGIN_SUCCESSFUL;\r\n                        }\r\n                    }\r\n                } else {\r\n                    status = WRONG_PASSWORD;\r\n                }\r\n            } else {\r\n                status = WRONG_USERNAME;\r\n            }\r\n            if (status == LOGIN_SUCCESSFUL) {\r\n                logger.info(\"login as \" + username + \" correct!\");\r\n            }\r\n        } catch (DBException e) {\r\n        }\r\n        return status;\r\n    }\r\n\r\n    /**\r\n     * Handles the login as a guest.\r\n     *\r\n     * @param username\r\n     * @return boolean status, true if login is correct\r\n     */\r\n    public int loginGuest(String username) {\r\n        try {\r\n            if (username.equals(\"\")) {\r\n                return WRONG_USERNAME;\r\n            }\r\n            logger.info(\"loginGuest called \" + username);\r\n            user = DBServiceFactory.getInstance().getDBUser(username);\r\n            if (user == null || user.getName() == null || user.getName().equals(\"\")) {\r\n                logger.info(\"loginGuest user not in db \" + username);\r\n                register(username, \"\");\r\n                user = DBServiceFactory.getInstance().getDBUser(username);\r\n            }\r\n            if (user != null && (user.getPassword() == null || user.getPassword().equals(\"\"))) {\r\n                logger.info(\"user \" + username + \" (Guest) logged with score \" + user.getScore());\r\n                for (ClientInfo client : BomberServer.getInstance().getClients()) {\r\n                    if (client.getName() != null) {\r\n                        if (client.getName().equals(username)) {\r\n                            status = USERNAME_TAKEN;\r\n                            break;\r\n                        } else {\r\n                            status = LOGIN_SUCCESSFUL;\r\n                        }\r\n                    } else {\r\n                        status = LOGIN_SUCCESSFUL;\r\n                    }\r\n                }\r\n            } else {\r\n                status = USERNAME_TAKEN;\r\n            }\r\n        } catch (DBException e) {\r\n        }\r\n        if (status == LOGIN_SUCCESSFUL) {\r\n            logger.info(\"login as \" + username + \" correct!\");\r\n        }\r\n        return status;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/server/ServerLoginTest2.java",
		"test_prompt": "// ServerLoginTest2.java\npackage server;\n\nimport org.apache.log4j.Logger;\nimport db.DBException;\nimport db.DBGameUser;\nimport db.DBServiceFactory;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ServerLogin}.\n* It contains ten unit test cases for the {@link ServerLogin#loginGuest(String)} method.\n*/\nclass ServerLoginTest2 {"
	},
	{
		"original_code": "// Bomb.java\npackage common;\r\n\r\nimport java.awt.Point;\r\nimport java.awt.Rectangle;\r\nimport org.apache.log4j.Logger;\r\n\r\npublic class Bomb extends Actor {\r\n\r\n    private static final Logger logger = Logger.getLogger(Bomb.class);\r\n\r\n    /**\r\n     * Explosion diameter of the bomb measured in tiles. Valid diameters are\r\n     * 1,3,5,7...2*n+1 ( n >= 0).\r\n     */\r\n    protected int diameter = Constants.BOMB_DIAMETER;\r\n\r\n    protected GameObject planter;\r\n\r\n    protected int planterId;\r\n\r\n    protected boolean accessible;\r\n\r\n    protected boolean firstUpdate = true;\r\n\r\n    protected boolean exploded = false;\r\n\r\n    protected boolean stopped = false;\r\n\r\n    private int updates = 0;\r\n\r\n    // hitbox collision\r\n    protected static final int COLLISION_WIDTH = 40;\r\n\r\n    protected static final int COLLISION_HEIGHT = 40;\r\n\r\n    protected static final int COLLISION_X_OFFSET = COLLISION_WIDTH / 2;\r\n\r\n    protected static final int COLLISION_Y_OFFSET = COLLISION_HEIGHT / 2;\r\n\r\n    // hitbox explosion\r\n    protected static final int BODY_WIDTH = 38;\r\n\r\n    protected static final int BODY_HEIGHT = 60;\r\n\r\n    protected static final int BODY_Y_OFFSET = 55;\r\n\r\n    protected static final int BODY_X_OFFSET = 19;\r\n\r\n    public int getPlanterId() {\r\n        return planterId;\r\n    }\r\n\r\n    public void setPlanterId(int planterId) {\r\n        this.planterId = planterId;\r\n    }\r\n\r\n    public Bomb(Point position) {\r\n        super(position);\r\n    }\r\n\r\n    /**\r\n     * @param position\r\n     * @param planter\r\n     * @param type\r\n     */\r\n    public Bomb(Point position, GameObject planter, int type) {\r\n        super(position);\r\n        this.planter = planter;\r\n        this.planterId = planter.getId();\r\n    }\r\n\r\n    /**\r\n     * @param position\r\n     * @param planter\r\n     */\r\n    public Bomb(Point position, GameObject planter) {\r\n        super(position);\r\n        this.planter = planter;\r\n        this.planterId = planter.getId();\r\n    }\r\n\r\n    @Override\r\n    protected void preUpdate() {\r\n        setChanged();\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see common.Actor#postUpdate()\r\n     */\r\n    @Override\r\n    protected void postUpdate() {\r\n        if (updates < 5) {\r\n            updates++;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * don't ask...\r\n     */\r\n    public boolean hasJustBeenPlanted() {\r\n        return updates < 5;\r\n    }\r\n\r\n    @Override\r\n    public boolean isAccessable() {\r\n        return accessible;\r\n    }\r\n\r\n    /**\r\n     * explode\r\n     */\r\n    public void explode() {\r\n        logger.info(\"Bomb \" + id + \" exploded!\");\r\n        exploded = true;\r\n        active = false;\r\n        setChanged();\r\n        notifyObservers();\r\n    }\r\n\r\n    public int getDiameter() {\r\n        return diameter;\r\n    }\r\n\r\n    public void setDiameter(int diameter) {\r\n        this.diameter = diameter;\r\n    }\r\n\r\n    @Override\r\n    public Rectangle getCollisionRectangle() {\r\n        return new Rectangle(position.x - COLLISION_X_OFFSET, position.y - COLLISION_Y_OFFSET, COLLISION_WIDTH, COLLISION_HEIGHT);\r\n    }\r\n\r\n    public void setAccessible(boolean accessible) {\r\n        this.accessible = accessible;\r\n    }\r\n\r\n    /**\r\n     * Returns weather the bomb has been exploded or not.\r\n     *\r\n     * @return boolean\r\n     */\r\n    public boolean isExploded() {\r\n        return exploded;\r\n    }\r\n\r\n    public boolean isStopped() {\r\n        return stopped;\r\n    }\r\n\r\n    public void setStopped(boolean stopped) {\r\n        this.stopped = stopped;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/common/BombTest0.java",
		"test_prompt": "// BombTest0.java\npackage common;\n\nimport java.awt.Point;\nimport java.awt.Rectangle;\nimport org.apache.log4j.Logger;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Bomb}.\n* It contains ten unit test cases for the {@link Bomb#hasJustBeenPlanted()} method.\n*/\nclass BombTest0 {"
	},
	{
		"original_code": "// Bomb.java\npackage common;\r\n\r\nimport java.awt.Point;\r\nimport java.awt.Rectangle;\r\nimport org.apache.log4j.Logger;\r\n\r\npublic class Bomb extends Actor {\r\n\r\n    private static final Logger logger = Logger.getLogger(Bomb.class);\r\n\r\n    /**\r\n     * Explosion diameter of the bomb measured in tiles. Valid diameters are\r\n     * 1,3,5,7...2*n+1 ( n >= 0).\r\n     */\r\n    protected int diameter = Constants.BOMB_DIAMETER;\r\n\r\n    protected GameObject planter;\r\n\r\n    protected int planterId;\r\n\r\n    protected boolean accessible;\r\n\r\n    protected boolean firstUpdate = true;\r\n\r\n    protected boolean exploded = false;\r\n\r\n    protected boolean stopped = false;\r\n\r\n    private int updates = 0;\r\n\r\n    // hitbox collision\r\n    protected static final int COLLISION_WIDTH = 40;\r\n\r\n    protected static final int COLLISION_HEIGHT = 40;\r\n\r\n    protected static final int COLLISION_X_OFFSET = COLLISION_WIDTH / 2;\r\n\r\n    protected static final int COLLISION_Y_OFFSET = COLLISION_HEIGHT / 2;\r\n\r\n    // hitbox explosion\r\n    protected static final int BODY_WIDTH = 38;\r\n\r\n    protected static final int BODY_HEIGHT = 60;\r\n\r\n    protected static final int BODY_Y_OFFSET = 55;\r\n\r\n    protected static final int BODY_X_OFFSET = 19;\r\n\r\n    public int getPlanterId() {\r\n        return planterId;\r\n    }\r\n\r\n    public void setPlanterId(int planterId) {\r\n        this.planterId = planterId;\r\n    }\r\n\r\n    public Bomb(Point position) {\r\n        super(position);\r\n    }\r\n\r\n    /**\r\n     * @param position\r\n     * @param planter\r\n     * @param type\r\n     */\r\n    public Bomb(Point position, GameObject planter, int type) {\r\n        super(position);\r\n        this.planter = planter;\r\n        this.planterId = planter.getId();\r\n    }\r\n\r\n    /**\r\n     * @param position\r\n     * @param planter\r\n     */\r\n    public Bomb(Point position, GameObject planter) {\r\n        super(position);\r\n        this.planter = planter;\r\n        this.planterId = planter.getId();\r\n    }\r\n\r\n    @Override\r\n    protected void preUpdate() {\r\n        setChanged();\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see common.Actor#postUpdate()\r\n     */\r\n    @Override\r\n    protected void postUpdate() {\r\n        if (updates < 5) {\r\n            updates++;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * don't ask...\r\n     */\r\n    public boolean hasJustBeenPlanted() {\r\n        return updates < 5;\r\n    }\r\n\r\n    @Override\r\n    public boolean isAccessable() {\r\n        return accessible;\r\n    }\r\n\r\n    /**\r\n     * explode\r\n     */\r\n    public void explode() {\r\n        logger.info(\"Bomb \" + id + \" exploded!\");\r\n        exploded = true;\r\n        active = false;\r\n        setChanged();\r\n        notifyObservers();\r\n    }\r\n\r\n    public int getDiameter() {\r\n        return diameter;\r\n    }\r\n\r\n    public void setDiameter(int diameter) {\r\n        this.diameter = diameter;\r\n    }\r\n\r\n    @Override\r\n    public Rectangle getCollisionRectangle() {\r\n        return new Rectangle(position.x - COLLISION_X_OFFSET, position.y - COLLISION_Y_OFFSET, COLLISION_WIDTH, COLLISION_HEIGHT);\r\n    }\r\n\r\n    public void setAccessible(boolean accessible) {\r\n        this.accessible = accessible;\r\n    }\r\n\r\n    /**\r\n     * Returns weather the bomb has been exploded or not.\r\n     *\r\n     * @return boolean\r\n     */\r\n    public boolean isExploded() {\r\n        return exploded;\r\n    }\r\n\r\n    public boolean isStopped() {\r\n        return stopped;\r\n    }\r\n\r\n    public void setStopped(boolean stopped) {\r\n        this.stopped = stopped;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/common/BombTest1.java",
		"test_prompt": "// BombTest1.java\npackage common;\n\nimport java.awt.Point;\nimport java.awt.Rectangle;\nimport org.apache.log4j.Logger;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Bomb}.\n* It contains ten unit test cases for the {@link Bomb#isAccessable()} method.\n*/\nclass BombTest1 {"
	},
	{
		"original_code": "// Bomb.java\npackage common;\r\n\r\nimport java.awt.Point;\r\nimport java.awt.Rectangle;\r\nimport org.apache.log4j.Logger;\r\n\r\npublic class Bomb extends Actor {\r\n\r\n    private static final Logger logger = Logger.getLogger(Bomb.class);\r\n\r\n    /**\r\n     * Explosion diameter of the bomb measured in tiles. Valid diameters are\r\n     * 1,3,5,7...2*n+1 ( n >= 0).\r\n     */\r\n    protected int diameter = Constants.BOMB_DIAMETER;\r\n\r\n    protected GameObject planter;\r\n\r\n    protected int planterId;\r\n\r\n    protected boolean accessible;\r\n\r\n    protected boolean firstUpdate = true;\r\n\r\n    protected boolean exploded = false;\r\n\r\n    protected boolean stopped = false;\r\n\r\n    private int updates = 0;\r\n\r\n    // hitbox collision\r\n    protected static final int COLLISION_WIDTH = 40;\r\n\r\n    protected static final int COLLISION_HEIGHT = 40;\r\n\r\n    protected static final int COLLISION_X_OFFSET = COLLISION_WIDTH / 2;\r\n\r\n    protected static final int COLLISION_Y_OFFSET = COLLISION_HEIGHT / 2;\r\n\r\n    // hitbox explosion\r\n    protected static final int BODY_WIDTH = 38;\r\n\r\n    protected static final int BODY_HEIGHT = 60;\r\n\r\n    protected static final int BODY_Y_OFFSET = 55;\r\n\r\n    protected static final int BODY_X_OFFSET = 19;\r\n\r\n    public int getPlanterId() {\r\n        return planterId;\r\n    }\r\n\r\n    public void setPlanterId(int planterId) {\r\n        this.planterId = planterId;\r\n    }\r\n\r\n    public Bomb(Point position) {\r\n        super(position);\r\n    }\r\n\r\n    /**\r\n     * @param position\r\n     * @param planter\r\n     * @param type\r\n     */\r\n    public Bomb(Point position, GameObject planter, int type) {\r\n        super(position);\r\n        this.planter = planter;\r\n        this.planterId = planter.getId();\r\n    }\r\n\r\n    /**\r\n     * @param position\r\n     * @param planter\r\n     */\r\n    public Bomb(Point position, GameObject planter) {\r\n        super(position);\r\n        this.planter = planter;\r\n        this.planterId = planter.getId();\r\n    }\r\n\r\n    @Override\r\n    protected void preUpdate() {\r\n        setChanged();\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see common.Actor#postUpdate()\r\n     */\r\n    @Override\r\n    protected void postUpdate() {\r\n        if (updates < 5) {\r\n            updates++;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * don't ask...\r\n     */\r\n    public boolean hasJustBeenPlanted() {\r\n        return updates < 5;\r\n    }\r\n\r\n    @Override\r\n    public boolean isAccessable() {\r\n        return accessible;\r\n    }\r\n\r\n    /**\r\n     * explode\r\n     */\r\n    public void explode() {\r\n        logger.info(\"Bomb \" + id + \" exploded!\");\r\n        exploded = true;\r\n        active = false;\r\n        setChanged();\r\n        notifyObservers();\r\n    }\r\n\r\n    public int getDiameter() {\r\n        return diameter;\r\n    }\r\n\r\n    public void setDiameter(int diameter) {\r\n        this.diameter = diameter;\r\n    }\r\n\r\n    @Override\r\n    public Rectangle getCollisionRectangle() {\r\n        return new Rectangle(position.x - COLLISION_X_OFFSET, position.y - COLLISION_Y_OFFSET, COLLISION_WIDTH, COLLISION_HEIGHT);\r\n    }\r\n\r\n    public void setAccessible(boolean accessible) {\r\n        this.accessible = accessible;\r\n    }\r\n\r\n    /**\r\n     * Returns weather the bomb has been exploded or not.\r\n     *\r\n     * @return boolean\r\n     */\r\n    public boolean isExploded() {\r\n        return exploded;\r\n    }\r\n\r\n    public boolean isStopped() {\r\n        return stopped;\r\n    }\r\n\r\n    public void setStopped(boolean stopped) {\r\n        this.stopped = stopped;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/common/BombTest2.java",
		"test_prompt": "// BombTest2.java\npackage common;\n\nimport java.awt.Point;\nimport java.awt.Rectangle;\nimport org.apache.log4j.Logger;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Bomb}.\n* It contains ten unit test cases for the {@link Bomb#isExploded()} method.\n*/\nclass BombTest2 {"
	},
	{
		"original_code": "// Bomb.java\npackage common;\r\n\r\nimport java.awt.Point;\r\nimport java.awt.Rectangle;\r\nimport org.apache.log4j.Logger;\r\n\r\npublic class Bomb extends Actor {\r\n\r\n    private static final Logger logger = Logger.getLogger(Bomb.class);\r\n\r\n    /**\r\n     * Explosion diameter of the bomb measured in tiles. Valid diameters are\r\n     * 1,3,5,7...2*n+1 ( n >= 0).\r\n     */\r\n    protected int diameter = Constants.BOMB_DIAMETER;\r\n\r\n    protected GameObject planter;\r\n\r\n    protected int planterId;\r\n\r\n    protected boolean accessible;\r\n\r\n    protected boolean firstUpdate = true;\r\n\r\n    protected boolean exploded = false;\r\n\r\n    protected boolean stopped = false;\r\n\r\n    private int updates = 0;\r\n\r\n    // hitbox collision\r\n    protected static final int COLLISION_WIDTH = 40;\r\n\r\n    protected static final int COLLISION_HEIGHT = 40;\r\n\r\n    protected static final int COLLISION_X_OFFSET = COLLISION_WIDTH / 2;\r\n\r\n    protected static final int COLLISION_Y_OFFSET = COLLISION_HEIGHT / 2;\r\n\r\n    // hitbox explosion\r\n    protected static final int BODY_WIDTH = 38;\r\n\r\n    protected static final int BODY_HEIGHT = 60;\r\n\r\n    protected static final int BODY_Y_OFFSET = 55;\r\n\r\n    protected static final int BODY_X_OFFSET = 19;\r\n\r\n    public int getPlanterId() {\r\n        return planterId;\r\n    }\r\n\r\n    public void setPlanterId(int planterId) {\r\n        this.planterId = planterId;\r\n    }\r\n\r\n    public Bomb(Point position) {\r\n        super(position);\r\n    }\r\n\r\n    /**\r\n     * @param position\r\n     * @param planter\r\n     * @param type\r\n     */\r\n    public Bomb(Point position, GameObject planter, int type) {\r\n        super(position);\r\n        this.planter = planter;\r\n        this.planterId = planter.getId();\r\n    }\r\n\r\n    /**\r\n     * @param position\r\n     * @param planter\r\n     */\r\n    public Bomb(Point position, GameObject planter) {\r\n        super(position);\r\n        this.planter = planter;\r\n        this.planterId = planter.getId();\r\n    }\r\n\r\n    @Override\r\n    protected void preUpdate() {\r\n        setChanged();\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see common.Actor#postUpdate()\r\n     */\r\n    @Override\r\n    protected void postUpdate() {\r\n        if (updates < 5) {\r\n            updates++;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * don't ask...\r\n     */\r\n    public boolean hasJustBeenPlanted() {\r\n        return updates < 5;\r\n    }\r\n\r\n    @Override\r\n    public boolean isAccessable() {\r\n        return accessible;\r\n    }\r\n\r\n    /**\r\n     * explode\r\n     */\r\n    public void explode() {\r\n        logger.info(\"Bomb \" + id + \" exploded!\");\r\n        exploded = true;\r\n        active = false;\r\n        setChanged();\r\n        notifyObservers();\r\n    }\r\n\r\n    public int getDiameter() {\r\n        return diameter;\r\n    }\r\n\r\n    public void setDiameter(int diameter) {\r\n        this.diameter = diameter;\r\n    }\r\n\r\n    @Override\r\n    public Rectangle getCollisionRectangle() {\r\n        return new Rectangle(position.x - COLLISION_X_OFFSET, position.y - COLLISION_Y_OFFSET, COLLISION_WIDTH, COLLISION_HEIGHT);\r\n    }\r\n\r\n    public void setAccessible(boolean accessible) {\r\n        this.accessible = accessible;\r\n    }\r\n\r\n    /**\r\n     * Returns weather the bomb has been exploded or not.\r\n     *\r\n     * @return boolean\r\n     */\r\n    public boolean isExploded() {\r\n        return exploded;\r\n    }\r\n\r\n    public boolean isStopped() {\r\n        return stopped;\r\n    }\r\n\r\n    public void setStopped(boolean stopped) {\r\n        this.stopped = stopped;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/common/BombTest3.java",
		"test_prompt": "// BombTest3.java\npackage common;\n\nimport java.awt.Point;\nimport java.awt.Rectangle;\nimport org.apache.log4j.Logger;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Bomb}.\n* It contains ten unit test cases for the {@link Bomb#isStopped()} method.\n*/\nclass BombTest3 {"
	},
	{
		"original_code": "// Map.java\npackage common;\r\n\r\nimport java.awt.Point;\r\nimport java.io.Serializable;\r\nimport java.util.Date;\r\nimport java.util.Iterator;\r\nimport java.util.NoSuchElementException;\r\nimport java.util.Vector;\r\n\r\n/**\r\n * Map-Class with all information needed for map use of iterators tile-iterator:\r\n * for(Tile tile : map) - powerup-iterator: for(PowerUp powerup :\r\n * map.powerupiterator)\r\n *\r\n * @author christian\r\n */\r\npublic class Map implements Iterable<Tile>, Serializable {\r\n\r\n    private static final long serialVersionUID = 1L;\r\n\r\n    // flags if tiles, powerups and startpoints need to be read and set\r\n    private boolean settiles = true;\r\n\r\n    private boolean setpowerups = true;\r\n\r\n    private boolean setstartpoints = true;\r\n\r\n    // 2 dimensional game board\r\n    private Object[][] MapGrid;\r\n\r\n    private Vector<PowerUp> Powerups = new Vector<PowerUp>();\r\n\r\n    private Point[] StartPoint;\r\n\r\n    private Point area;\r\n\r\n    private String name;\r\n\r\n    private String imageSet;\r\n\r\n    private String version;\r\n\r\n    private String author;\r\n\r\n    private Date date;\r\n\r\n    private int difficulty;\r\n\r\n    private int maxPlayers;\r\n\r\n    private String filePath;\r\n\r\n    private int itemId = 0;\r\n\r\n    // iterator for powerups\r\n    public Map.PowerUpIterator powerupiterator;\r\n\r\n    /**\r\n     * creates map-object with empty Tile objects\r\n     *\r\n     * @param xmlFile -\r\n     *            path to xml file\r\n     */\r\n    public Map(String xmlFile) {\r\n        mapInit(xmlFile);\r\n    }\r\n\r\n    /**\r\n     * creates map-object with or without Tile objects\r\n     *\r\n     * @param xmlFile -\r\n     *            path to xml file\r\n     * @param info -\r\n     *            Boolean (noTile) if tiles should be read (false) or not (true)\r\n     */\r\n    public Map(String xmlFile, boolean settiles, boolean setpowerups, boolean setstartpoints) {\r\n        this.settiles = settiles;\r\n        this.setpowerups = setpowerups;\r\n        this.setstartpoints = setstartpoints;\r\n        mapInit(xmlFile);\r\n    }\r\n\r\n    /**\r\n     * initiate map and create MapReader Object\r\n     *\r\n     * @param xmlFile\r\n     */\r\n    private void mapInit(String xmlFile) {\r\n        // create Map-Reader an read xml into map\r\n        MapReader xml = new MapReader(xmlFile);\r\n        // get map dimensions\r\n        area = xml.getArea();\r\n        // MapXMLReader writes read properties to map-object\r\n        xml.setMapProperies(this);\r\n        // Tiles +++++++++++++++++++++++++++++++++++++++++++++++++++\r\n        // create map grid with \"empty\" objects if settiles is true\r\n        if (settiles) {\r\n            MapGrid = new Object[area.x][area.y];\r\n            for (int i = 0; i < area.x; i++) {\r\n                for (int j = 0; j < area.y; j++) {\r\n                    Tile tile = new Tile(new Point((area.x * Constants.TILE_BORDER), (area.y * Constants.TILE_BORDER)));\r\n                    MapGrid[i][j] = tile;\r\n                }\r\n            }\r\n            // overwrite specific tiles from xml to map\r\n            xml.setTiles(this);\r\n            // sets tile to wall if type not set\r\n            for (Tile tile : this) {\r\n                if (tile.getType() == null) {\r\n                    tile.setType(\"wall\");\r\n                }\r\n                tile.setId(itemId++);\r\n            }\r\n        }\r\n        // Powerups ++++++++++++++++++++++++++++++++++++++++++++++++\r\n        // create map grid with \"empty\" powerup objects if setpowerups is true\r\n        if (setpowerups) {\r\n            powerupiterator = new PowerUpIterator();\r\n            // overwrite specific powerups from xml to map\r\n            xml.setPowerups(this);\r\n        }\r\n        // Starpoints ++++++++++++++++++++++++++++++++++++++++++++++++\r\n        // set start points to map\r\n        if (setstartpoints) {\r\n            xml.setStartPoints(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * overwrite specific MapTile at Index x, y\r\n     *\r\n     * @param x -\r\n     *            number of horizontal tile\r\n     * @param y -\r\n     *            number of vertical tile\r\n     * @param tile -\r\n     *            MapTile object\r\n     */\r\n    public void setTileByIndex(int x, int y, Tile tile) {\r\n        MapGrid[x][y] = tile;\r\n    }\r\n\r\n    /**\r\n     * return MapTile object at Index x, y\r\n     *\r\n     * @param x -\r\n     *            number of horizontal tile\r\n     * @param y -\r\n     *            number of vertical tile\r\n     * @return MapTile object\r\n     */\r\n    public Tile getTileByIndex(int x, int y) {\r\n        return (Tile) MapGrid[x][y];\r\n    }\r\n\r\n    /**\r\n     * overwrite specific MapTile at Position x, y\r\n     *\r\n     * @param x -\r\n     *            number of horizontal tile\r\n     * @param y -\r\n     *            number of vertical tile\r\n     * @param tile -\r\n     *            MapTile object\r\n     */\r\n    public void setTile(int x, int y, Tile tile) {\r\n        MapGrid[(int) Math.floor((double) x / Constants.TILE_BORDER)][(int) Math.floor((double) y / Constants.TILE_BORDER)] = tile;\r\n    }\r\n\r\n    /**\r\n     * return MapTile object at Position x, y\r\n     *\r\n     * @param x -\r\n     *            number of horizontal tile\r\n     * @param y -\r\n     *            number of vertical tile\r\n     * @return MapTile object\r\n     */\r\n    public Tile getTile(int x, int y) {\r\n        return (Tile) MapGrid[(int) Math.floor((double) x / Constants.TILE_BORDER)][(int) Math.floor((double) y / Constants.TILE_BORDER)];\r\n    }\r\n\r\n    /**\r\n     * Resets a tile to \"empty\" tile at specific position\r\n     *\r\n     * @param x -\r\n     *            number of horizontal tile\r\n     * @param y -\r\n     *            number of vertical tile\r\n     */\r\n    public void resetTileByIndex(int x, int y) {\r\n        MapGrid[x][y] = new Tile(new Point(x * Constants.TILE_BORDER, y * Constants.TILE_BORDER));\r\n    }\r\n\r\n    /**\r\n     * Resets a tile to \"empty\" tile at specific coordinates\r\n     *\r\n     * @param x -\r\n     *            coordinates of horizontal tile\r\n     * @param y -\r\n     *            coordinates of vertical tile\r\n     */\r\n    public void resetTile(int x, int y) {\r\n        MapGrid[(int) Math.floor((double) x / Constants.TILE_BORDER)][(int) Math.floor((double) y / Constants.TILE_BORDER)] = new Tile(new Point(x, y));\r\n    }\r\n\r\n    /**\r\n     * overwrite specific PowerUp at Index x, y\r\n     *\r\n     * @param x -\r\n     *            number of horizontal tile\r\n     * @param y -\r\n     *            number of vertical tile\r\n     * @param tile -\r\n     *            PoweUp object\r\n     */\r\n    public void addPowerup(PowerUp powerup) {\r\n        powerup.setId(itemId++);\r\n        Powerups.addElement(powerup);\r\n    }\r\n\r\n    /**\r\n     * retrieves a Vector with all PowerUps\r\n     *\r\n     * @return\r\n     */\r\n    public Vector<PowerUp> getPowerups() {\r\n        return this.Powerups;\r\n    }\r\n\r\n    // Getters and Setter for map properties\r\n    /**\r\n     * sets a bunch of properties to map\r\n     *\r\n     * @param mapName -\r\n     *            Name of map\r\n     * @param mapVersion -\r\n     *            Version of map\r\n     * @param mapAuthor -\r\n     *            Name of author\r\n     * @param mapDate -\r\n     *            Date of map\r\n     * @param mapDifficulty -\r\n     *            Difficulty of map\r\n     * @param mapImageSet -\r\n     *            Default image set\r\n     * @param mapMaxPlayers -\r\n     *            Number of max players\r\n     * @param mapFilePath -\r\n     *            path to map xml file\r\n     */\r\n    public void setProperties(String mapName, String mapVersion, String mapAuthor, Date mapDate, int mapDifficulty, String mapImageSet, int mapMaxPlayers, String mapFilePath) {\r\n        this.name = mapName;\r\n        this.version = mapVersion;\r\n        this.author = mapAuthor;\r\n        this.date = mapDate;\r\n        this.difficulty = mapDifficulty;\r\n        this.imageSet = mapImageSet;\r\n        this.maxPlayers = mapMaxPlayers;\r\n        this.filePath = mapFilePath;\r\n    }\r\n\r\n    public String getImageSet() {\r\n        return imageSet;\r\n    }\r\n\r\n    public String getVersion() {\r\n        return version;\r\n    }\r\n\r\n    public String getAuthor() {\r\n        return author;\r\n    }\r\n\r\n    public Date getDate() {\r\n        return date;\r\n    }\r\n\r\n    public int getDifficulty() {\r\n        return difficulty;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public int getMaxPlayers() {\r\n        return maxPlayers;\r\n    }\r\n\r\n    public String getFilePath() {\r\n        return filePath;\r\n    }\r\n\r\n    /**\r\n     * sets measures of map\r\n     *\r\n     * @param x -\r\n     *            number of horizontal fields\r\n     * @param y -\r\n     *            number of vertical fields\r\n     */\r\n    public void setArea(int x, int y) {\r\n        Point area = new Point();\r\n        area.x = x;\r\n        area.y = y;\r\n        this.area = area;\r\n    }\r\n\r\n    /**\r\n     * retrieve measures of map, number of horizontal and vertical fields\r\n     *\r\n     * @return\r\n     */\r\n    public Point getArea() {\r\n        return this.area;\r\n    }\r\n\r\n    /**\r\n     * sets the start-point-position to map\r\n     *\r\n     * @param StPo -\r\n     *            array of start-point-positions\r\n     */\r\n    public void setStartPoints(Point[] StPo) {\r\n        this.StartPoint = StPo;\r\n    }\r\n\r\n    /**\r\n     * gets array of start-point positions (not coordinates)\r\n     *\r\n     * @return\r\n     */\r\n    public Point[] getStartPoints() {\r\n        return this.StartPoint;\r\n    }\r\n\r\n    /**\r\n     * gets start-point-coordinates of player no. if not set, return coordinates\r\n     * of field 1/1\r\n     *\r\n     * @param playerNo -\r\n     *            number of player\r\n     * @return Point with coordinates\r\n     */\r\n    public Point getStartPoint(int playerNo) {\r\n        // startpoint for player is not set, default 1/1\r\n        if (playerNo > StartPoint.length) {\r\n            return new Point(1 * Constants.TILE_BORDER + Constants.TILE_BORDER / 2, // field\r\n            1 * Constants.TILE_BORDER + Constants.TILE_BORDER / 2);\r\n            // 1/1\r\n        } else {\r\n            Point retPoint = StartPoint[(playerNo - 1)];\r\n            retPoint.x = retPoint.x * Constants.TILE_BORDER + 20;\r\n            retPoint.y = retPoint.y * Constants.TILE_BORDER + 20;\r\n            return retPoint;\r\n        }\r\n    }\r\n\r\n    /*\r\n\t * (non-Javadoc)\r\n\t * \r\n\t * @see java.lang.Iterable#iterator()\r\n\t */\r\n    @Override\r\n    public Iterator<Tile> iterator() {\r\n        return new Iterator<Tile>() {\r\n\r\n            private int idx = 0;\r\n\r\n            int width = MapGrid.length;\r\n\r\n            int height = MapGrid[0].length;\r\n\r\n            private int size = width * height;\r\n\r\n            @Override\r\n            public boolean hasNext() {\r\n                return idx < size;\r\n            }\r\n\r\n            @Override\r\n            public Tile next() {\r\n                if (!hasNext()) {\r\n                    throw new NoSuchElementException();\r\n                }\r\n                Tile tile = (Tile) MapGrid[idx % width][idx / width];\r\n                idx++;\r\n                return tile;\r\n            }\r\n\r\n            @Override\r\n            public void remove() {\r\n                throw new UnsupportedOperationException();\r\n            }\r\n        };\r\n    }\r\n\r\n    /*\r\n\t * (non-Javadoc)\r\n\t * \r\n\t * @see java.lang.Iterable#iterator()\r\n\t */\r\n    /**\r\n     * iterator for PowerUp Objects in map\r\n     *\r\n     * @author christian\r\n     */\r\n    public class PowerUpIterator implements Iterable<PowerUp>, Serializable {\r\n\r\n        private static final long serialVersionUID = 1L;\r\n\r\n        @Override\r\n        public Iterator<PowerUp> iterator() {\r\n            return Powerups.iterator();\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/common/MapTest.java",
		"test_prompt": "// MapTest.java\npackage common;\n\nimport java.awt.Point;\nimport java.io.Serializable;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Map}.\n* It contains ten unit test cases for the {@link Map#iterator()} method.\n*/\nclass MapTest {"
	},
	{
		"original_code": "// ResourceService.java\n/**\r\n */\r\npackage common;\r\n\r\nimport java.awt.Image;\r\nimport java.awt.image.BufferedImage;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport javax.imageio.ImageIO;\r\nimport javax.swing.ImageIcon;\r\n\r\n/**\r\n * This is an utility class that offers functionality to load resources that are\r\n * located in the classpath. This is used to load resources like images and sound files\r\n * from the client jar file.\r\n *\r\n * @author andi\r\n */\r\npublic class ResourceService {\r\n\r\n    /**\r\n     * Loads the {@link Image} that is located at the specified path.\r\n     * @param path The location of the image within the classpath.\r\n     * @return The loaded {@link Image} or null if there was an IOException while trying\r\n     * to read the image from a stream.\r\n     */\r\n    public static Image getImage(String path) {\r\n        BufferedImage image;\r\n        try {\r\n            image = ImageIO.read(getInputStream(path));\r\n        } catch (IOException e) {\r\n            image = null;\r\n        }\r\n        return image;\r\n    }\r\n\r\n    /**\r\n     * Loads the {@link ImageIcon} that is located at the specified path.\r\n     * @param path The location of the image within the classpath.\r\n     * @return The loaded {@link ImageIcon}\r\n     */\r\n    public static ImageIcon getImageIcon(String path) {\r\n        return new ImageIcon(getImage(path));\r\n    }\r\n\r\n    /**\r\n     * Creates a connection to the resource that is located at the specified\r\n     * path via an {@link InputStream}.\r\n     * @param path The location of the resource within the classpath.\r\n     * @return The {@link InputStream} that points the requested resource.\r\n     */\r\n    public static InputStream getInputStream(String path) {\r\n        InputStream resourceAsStream = ResourceService.class.getResourceAsStream(path);\r\n        if (resourceAsStream == null) {\r\n            throw new IllegalArgumentException(\"No such resource: \" + path);\r\n        }\r\n        return resourceAsStream;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/common/ResourceServiceTest0.java",
		"test_prompt": "// ResourceServiceTest0.java\npackage common;\n\nimport java.awt.Image;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport javax.imageio.ImageIO;\nimport javax.swing.ImageIcon;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ResourceService}.\n* It contains ten unit test cases for the {@link ResourceService#getImage(String)} method.\n*/\nclass ResourceServiceTest0 {"
	},
	{
		"original_code": "// ResourceService.java\n/**\r\n */\r\npackage common;\r\n\r\nimport java.awt.Image;\r\nimport java.awt.image.BufferedImage;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport javax.imageio.ImageIO;\r\nimport javax.swing.ImageIcon;\r\n\r\n/**\r\n * This is an utility class that offers functionality to load resources that are\r\n * located in the classpath. This is used to load resources like images and sound files\r\n * from the client jar file.\r\n *\r\n * @author andi\r\n */\r\npublic class ResourceService {\r\n\r\n    /**\r\n     * Loads the {@link Image} that is located at the specified path.\r\n     * @param path The location of the image within the classpath.\r\n     * @return The loaded {@link Image} or null if there was an IOException while trying\r\n     * to read the image from a stream.\r\n     */\r\n    public static Image getImage(String path) {\r\n        BufferedImage image;\r\n        try {\r\n            image = ImageIO.read(getInputStream(path));\r\n        } catch (IOException e) {\r\n            image = null;\r\n        }\r\n        return image;\r\n    }\r\n\r\n    /**\r\n     * Loads the {@link ImageIcon} that is located at the specified path.\r\n     * @param path The location of the image within the classpath.\r\n     * @return The loaded {@link ImageIcon}\r\n     */\r\n    public static ImageIcon getImageIcon(String path) {\r\n        return new ImageIcon(getImage(path));\r\n    }\r\n\r\n    /**\r\n     * Creates a connection to the resource that is located at the specified\r\n     * path via an {@link InputStream}.\r\n     * @param path The location of the resource within the classpath.\r\n     * @return The {@link InputStream} that points the requested resource.\r\n     */\r\n    public static InputStream getInputStream(String path) {\r\n        InputStream resourceAsStream = ResourceService.class.getResourceAsStream(path);\r\n        if (resourceAsStream == null) {\r\n            throw new IllegalArgumentException(\"No such resource: \" + path);\r\n        }\r\n        return resourceAsStream;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/common/ResourceServiceTest1.java",
		"test_prompt": "// ResourceServiceTest1.java\npackage common;\n\nimport java.awt.Image;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport javax.imageio.ImageIO;\nimport javax.swing.ImageIcon;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ResourceService}.\n* It contains ten unit test cases for the {@link ResourceService#getImageIcon(String)} method.\n*/\nclass ResourceServiceTest1 {"
	},
	{
		"original_code": "// ResourceService.java\n/**\r\n */\r\npackage common;\r\n\r\nimport java.awt.Image;\r\nimport java.awt.image.BufferedImage;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport javax.imageio.ImageIO;\r\nimport javax.swing.ImageIcon;\r\n\r\n/**\r\n * This is an utility class that offers functionality to load resources that are\r\n * located in the classpath. This is used to load resources like images and sound files\r\n * from the client jar file.\r\n *\r\n * @author andi\r\n */\r\npublic class ResourceService {\r\n\r\n    /**\r\n     * Loads the {@link Image} that is located at the specified path.\r\n     * @param path The location of the image within the classpath.\r\n     * @return The loaded {@link Image} or null if there was an IOException while trying\r\n     * to read the image from a stream.\r\n     */\r\n    public static Image getImage(String path) {\r\n        BufferedImage image;\r\n        try {\r\n            image = ImageIO.read(getInputStream(path));\r\n        } catch (IOException e) {\r\n            image = null;\r\n        }\r\n        return image;\r\n    }\r\n\r\n    /**\r\n     * Loads the {@link ImageIcon} that is located at the specified path.\r\n     * @param path The location of the image within the classpath.\r\n     * @return The loaded {@link ImageIcon}\r\n     */\r\n    public static ImageIcon getImageIcon(String path) {\r\n        return new ImageIcon(getImage(path));\r\n    }\r\n\r\n    /**\r\n     * Creates a connection to the resource that is located at the specified\r\n     * path via an {@link InputStream}.\r\n     * @param path The location of the resource within the classpath.\r\n     * @return The {@link InputStream} that points the requested resource.\r\n     */\r\n    public static InputStream getInputStream(String path) {\r\n        InputStream resourceAsStream = ResourceService.class.getResourceAsStream(path);\r\n        if (resourceAsStream == null) {\r\n            throw new IllegalArgumentException(\"No such resource: \" + path);\r\n        }\r\n        return resourceAsStream;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/common/ResourceServiceTest2.java",
		"test_prompt": "// ResourceServiceTest2.java\npackage common;\n\nimport java.awt.Image;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport javax.imageio.ImageIO;\nimport javax.swing.ImageIcon;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ResourceService}.\n* It contains ten unit test cases for the {@link ResourceService#getInputStream(String)} method.\n*/\nclass ResourceServiceTest2 {"
	},
	{
		"original_code": "// Tile.java\npackage common;\r\n\r\nimport java.awt.Point;\r\nimport java.awt.Rectangle;\r\nimport java.util.Collection;\r\n\r\n/**\r\n * tile object can be specified for each tile of map\r\n *\r\n * @author christian, Daniel Tunjic\r\n */\r\npublic class Tile extends GameObject {\r\n\r\n    // tile properties\r\n    private String type;\r\n\r\n    private boolean accessible = true;\r\n\r\n    private boolean bombable = false;\r\n\r\n    private boolean visible = true;\r\n\r\n    private double speedFactor = 1.0;\r\n\r\n    /**\r\n     * create tile object at coordinates p\r\n     *\r\n     * @param p\r\n     */\r\n    public Tile(Point p) {\r\n        super(p);\r\n    }\r\n\r\n    @Override\r\n    public void update() {\r\n        // TODO Auto-generated method stub\r\n    }\r\n\r\n    /**\r\n     * gets type of tile, important for tile image\r\n     * @return\r\n     */\r\n    public String getType() {\r\n        return this.type;\r\n    }\r\n\r\n    /**\r\n     * sets type of tile, important for tile image\r\n     * @param type\r\n     */\r\n    public void setType(String type) {\r\n        this.type = type;\r\n    }\r\n\r\n    /**\r\n     * sets a bunch of properties\r\n     * @param type - String, type of tile\r\n     * @param accessible - Boolean, is tile accessible\r\n     * @param bombable - Boolean, is tile bombable\r\n     */\r\n    public void setProperties(String type, boolean accessible, boolean bombable) {\r\n        this.type = type;\r\n        this.bombable = bombable;\r\n        this.accessible = accessible;\r\n    }\r\n\r\n    /**\r\n     * returns weather tile accessible or not\r\n     *  isAccessable is identical but wrong spelled\r\n     * @return\r\n     */\r\n    public boolean isAccessible() {\r\n        return this.accessible;\r\n    }\r\n\r\n    /**\r\n     * returns weather tile accessible or not\r\n     *  isAccessable is identical but wrong spelled\r\n     * @return\r\n     */\r\n    @Override\r\n    public boolean isAccessable() {\r\n        return this.accessible;\r\n    }\r\n\r\n    /**\r\n     * sets if tile is accessible or not\r\n     * @param a\r\n     */\r\n    public void setAccessible(boolean a) {\r\n        this.accessible = a;\r\n    }\r\n\r\n    /**\r\n     * checks if tile can be bombed\r\n     * @return\r\n     */\r\n    public boolean isBombable() {\r\n        return this.bombable;\r\n    }\r\n\r\n    /**\r\n     * sets if tile can be bombed\r\n     * @param b\r\n     */\r\n    public void setBombable(boolean b) {\r\n        this.bombable = b;\r\n    }\r\n\r\n    /**\r\n     * checks if tile is visible\r\n     * @return\r\n     */\r\n    public boolean isVisible() {\r\n        return visible;\r\n    }\r\n\r\n    /**\r\n     * sets if tile is visible\r\n     * @param visible\r\n     */\r\n    public void setVisible(boolean visible) {\r\n        this.visible = visible;\r\n    }\r\n\r\n    /**\r\n     * returns speedfactor for tile\r\n     * @return\r\n     */\r\n    public double getSpeedFactor() {\r\n        return speedFactor;\r\n    }\r\n\r\n    @Override\r\n    public void updateWithCollisionCheck(Collection<GameObject> gameObjects) {\r\n        // TODO Auto-generated method stub\r\n    }\r\n\r\n    @Override\r\n    public boolean collide(GameObject gameobject) {\r\n        // TODO Auto-generated method stub\r\n        return false;\r\n    }\r\n\r\n    @Override\r\n    public Rectangle getCollisionRectangle() {\r\n        return new Rectangle(position.getLocation().x - Constants.HALF_TILE, position.getLocation().y - Constants.HALF_TILE, Constants.TILE_BORDER, Constants.TILE_BORDER);\r\n    }\r\n\r\n    public void die() {\r\n        active = false;\r\n        if (bombable) {\r\n            accessible = true;\r\n        }\r\n    }\r\n\r\n    public void destroy() {\r\n        die();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/common/TileTest0.java",
		"test_prompt": "// TileTest0.java\npackage common;\n\nimport java.awt.Point;\nimport java.awt.Rectangle;\nimport java.util.Collection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Tile}.\n* It contains ten unit test cases for the {@link Tile#isAccessible()} method.\n*/\nclass TileTest0 {"
	},
	{
		"original_code": "// Tile.java\npackage common;\r\n\r\nimport java.awt.Point;\r\nimport java.awt.Rectangle;\r\nimport java.util.Collection;\r\n\r\n/**\r\n * tile object can be specified for each tile of map\r\n *\r\n * @author christian, Daniel Tunjic\r\n */\r\npublic class Tile extends GameObject {\r\n\r\n    // tile properties\r\n    private String type;\r\n\r\n    private boolean accessible = true;\r\n\r\n    private boolean bombable = false;\r\n\r\n    private boolean visible = true;\r\n\r\n    private double speedFactor = 1.0;\r\n\r\n    /**\r\n     * create tile object at coordinates p\r\n     *\r\n     * @param p\r\n     */\r\n    public Tile(Point p) {\r\n        super(p);\r\n    }\r\n\r\n    @Override\r\n    public void update() {\r\n        // TODO Auto-generated method stub\r\n    }\r\n\r\n    /**\r\n     * gets type of tile, important for tile image\r\n     * @return\r\n     */\r\n    public String getType() {\r\n        return this.type;\r\n    }\r\n\r\n    /**\r\n     * sets type of tile, important for tile image\r\n     * @param type\r\n     */\r\n    public void setType(String type) {\r\n        this.type = type;\r\n    }\r\n\r\n    /**\r\n     * sets a bunch of properties\r\n     * @param type - String, type of tile\r\n     * @param accessible - Boolean, is tile accessible\r\n     * @param bombable - Boolean, is tile bombable\r\n     */\r\n    public void setProperties(String type, boolean accessible, boolean bombable) {\r\n        this.type = type;\r\n        this.bombable = bombable;\r\n        this.accessible = accessible;\r\n    }\r\n\r\n    /**\r\n     * returns weather tile accessible or not\r\n     *  isAccessable is identical but wrong spelled\r\n     * @return\r\n     */\r\n    public boolean isAccessible() {\r\n        return this.accessible;\r\n    }\r\n\r\n    /**\r\n     * returns weather tile accessible or not\r\n     *  isAccessable is identical but wrong spelled\r\n     * @return\r\n     */\r\n    @Override\r\n    public boolean isAccessable() {\r\n        return this.accessible;\r\n    }\r\n\r\n    /**\r\n     * sets if tile is accessible or not\r\n     * @param a\r\n     */\r\n    public void setAccessible(boolean a) {\r\n        this.accessible = a;\r\n    }\r\n\r\n    /**\r\n     * checks if tile can be bombed\r\n     * @return\r\n     */\r\n    public boolean isBombable() {\r\n        return this.bombable;\r\n    }\r\n\r\n    /**\r\n     * sets if tile can be bombed\r\n     * @param b\r\n     */\r\n    public void setBombable(boolean b) {\r\n        this.bombable = b;\r\n    }\r\n\r\n    /**\r\n     * checks if tile is visible\r\n     * @return\r\n     */\r\n    public boolean isVisible() {\r\n        return visible;\r\n    }\r\n\r\n    /**\r\n     * sets if tile is visible\r\n     * @param visible\r\n     */\r\n    public void setVisible(boolean visible) {\r\n        this.visible = visible;\r\n    }\r\n\r\n    /**\r\n     * returns speedfactor for tile\r\n     * @return\r\n     */\r\n    public double getSpeedFactor() {\r\n        return speedFactor;\r\n    }\r\n\r\n    @Override\r\n    public void updateWithCollisionCheck(Collection<GameObject> gameObjects) {\r\n        // TODO Auto-generated method stub\r\n    }\r\n\r\n    @Override\r\n    public boolean collide(GameObject gameobject) {\r\n        // TODO Auto-generated method stub\r\n        return false;\r\n    }\r\n\r\n    @Override\r\n    public Rectangle getCollisionRectangle() {\r\n        return new Rectangle(position.getLocation().x - Constants.HALF_TILE, position.getLocation().y - Constants.HALF_TILE, Constants.TILE_BORDER, Constants.TILE_BORDER);\r\n    }\r\n\r\n    public void die() {\r\n        active = false;\r\n        if (bombable) {\r\n            accessible = true;\r\n        }\r\n    }\r\n\r\n    public void destroy() {\r\n        die();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/common/TileTest1.java",
		"test_prompt": "// TileTest1.java\npackage common;\n\nimport java.awt.Point;\nimport java.awt.Rectangle;\nimport java.util.Collection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Tile}.\n* It contains ten unit test cases for the {@link Tile#isAccessable()} method.\n*/\nclass TileTest1 {"
	},
	{
		"original_code": "// Tile.java\npackage common;\r\n\r\nimport java.awt.Point;\r\nimport java.awt.Rectangle;\r\nimport java.util.Collection;\r\n\r\n/**\r\n * tile object can be specified for each tile of map\r\n *\r\n * @author christian, Daniel Tunjic\r\n */\r\npublic class Tile extends GameObject {\r\n\r\n    // tile properties\r\n    private String type;\r\n\r\n    private boolean accessible = true;\r\n\r\n    private boolean bombable = false;\r\n\r\n    private boolean visible = true;\r\n\r\n    private double speedFactor = 1.0;\r\n\r\n    /**\r\n     * create tile object at coordinates p\r\n     *\r\n     * @param p\r\n     */\r\n    public Tile(Point p) {\r\n        super(p);\r\n    }\r\n\r\n    @Override\r\n    public void update() {\r\n        // TODO Auto-generated method stub\r\n    }\r\n\r\n    /**\r\n     * gets type of tile, important for tile image\r\n     * @return\r\n     */\r\n    public String getType() {\r\n        return this.type;\r\n    }\r\n\r\n    /**\r\n     * sets type of tile, important for tile image\r\n     * @param type\r\n     */\r\n    public void setType(String type) {\r\n        this.type = type;\r\n    }\r\n\r\n    /**\r\n     * sets a bunch of properties\r\n     * @param type - String, type of tile\r\n     * @param accessible - Boolean, is tile accessible\r\n     * @param bombable - Boolean, is tile bombable\r\n     */\r\n    public void setProperties(String type, boolean accessible, boolean bombable) {\r\n        this.type = type;\r\n        this.bombable = bombable;\r\n        this.accessible = accessible;\r\n    }\r\n\r\n    /**\r\n     * returns weather tile accessible or not\r\n     *  isAccessable is identical but wrong spelled\r\n     * @return\r\n     */\r\n    public boolean isAccessible() {\r\n        return this.accessible;\r\n    }\r\n\r\n    /**\r\n     * returns weather tile accessible or not\r\n     *  isAccessable is identical but wrong spelled\r\n     * @return\r\n     */\r\n    @Override\r\n    public boolean isAccessable() {\r\n        return this.accessible;\r\n    }\r\n\r\n    /**\r\n     * sets if tile is accessible or not\r\n     * @param a\r\n     */\r\n    public void setAccessible(boolean a) {\r\n        this.accessible = a;\r\n    }\r\n\r\n    /**\r\n     * checks if tile can be bombed\r\n     * @return\r\n     */\r\n    public boolean isBombable() {\r\n        return this.bombable;\r\n    }\r\n\r\n    /**\r\n     * sets if tile can be bombed\r\n     * @param b\r\n     */\r\n    public void setBombable(boolean b) {\r\n        this.bombable = b;\r\n    }\r\n\r\n    /**\r\n     * checks if tile is visible\r\n     * @return\r\n     */\r\n    public boolean isVisible() {\r\n        return visible;\r\n    }\r\n\r\n    /**\r\n     * sets if tile is visible\r\n     * @param visible\r\n     */\r\n    public void setVisible(boolean visible) {\r\n        this.visible = visible;\r\n    }\r\n\r\n    /**\r\n     * returns speedfactor for tile\r\n     * @return\r\n     */\r\n    public double getSpeedFactor() {\r\n        return speedFactor;\r\n    }\r\n\r\n    @Override\r\n    public void updateWithCollisionCheck(Collection<GameObject> gameObjects) {\r\n        // TODO Auto-generated method stub\r\n    }\r\n\r\n    @Override\r\n    public boolean collide(GameObject gameobject) {\r\n        // TODO Auto-generated method stub\r\n        return false;\r\n    }\r\n\r\n    @Override\r\n    public Rectangle getCollisionRectangle() {\r\n        return new Rectangle(position.getLocation().x - Constants.HALF_TILE, position.getLocation().y - Constants.HALF_TILE, Constants.TILE_BORDER, Constants.TILE_BORDER);\r\n    }\r\n\r\n    public void die() {\r\n        active = false;\r\n        if (bombable) {\r\n            accessible = true;\r\n        }\r\n    }\r\n\r\n    public void destroy() {\r\n        die();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/common/TileTest2.java",
		"test_prompt": "// TileTest2.java\npackage common;\n\nimport java.awt.Point;\nimport java.awt.Rectangle;\nimport java.util.Collection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Tile}.\n* It contains ten unit test cases for the {@link Tile#isBombable()} method.\n*/\nclass TileTest2 {"
	},
	{
		"original_code": "// Tile.java\npackage common;\r\n\r\nimport java.awt.Point;\r\nimport java.awt.Rectangle;\r\nimport java.util.Collection;\r\n\r\n/**\r\n * tile object can be specified for each tile of map\r\n *\r\n * @author christian, Daniel Tunjic\r\n */\r\npublic class Tile extends GameObject {\r\n\r\n    // tile properties\r\n    private String type;\r\n\r\n    private boolean accessible = true;\r\n\r\n    private boolean bombable = false;\r\n\r\n    private boolean visible = true;\r\n\r\n    private double speedFactor = 1.0;\r\n\r\n    /**\r\n     * create tile object at coordinates p\r\n     *\r\n     * @param p\r\n     */\r\n    public Tile(Point p) {\r\n        super(p);\r\n    }\r\n\r\n    @Override\r\n    public void update() {\r\n        // TODO Auto-generated method stub\r\n    }\r\n\r\n    /**\r\n     * gets type of tile, important for tile image\r\n     * @return\r\n     */\r\n    public String getType() {\r\n        return this.type;\r\n    }\r\n\r\n    /**\r\n     * sets type of tile, important for tile image\r\n     * @param type\r\n     */\r\n    public void setType(String type) {\r\n        this.type = type;\r\n    }\r\n\r\n    /**\r\n     * sets a bunch of properties\r\n     * @param type - String, type of tile\r\n     * @param accessible - Boolean, is tile accessible\r\n     * @param bombable - Boolean, is tile bombable\r\n     */\r\n    public void setProperties(String type, boolean accessible, boolean bombable) {\r\n        this.type = type;\r\n        this.bombable = bombable;\r\n        this.accessible = accessible;\r\n    }\r\n\r\n    /**\r\n     * returns weather tile accessible or not\r\n     *  isAccessable is identical but wrong spelled\r\n     * @return\r\n     */\r\n    public boolean isAccessible() {\r\n        return this.accessible;\r\n    }\r\n\r\n    /**\r\n     * returns weather tile accessible or not\r\n     *  isAccessable is identical but wrong spelled\r\n     * @return\r\n     */\r\n    @Override\r\n    public boolean isAccessable() {\r\n        return this.accessible;\r\n    }\r\n\r\n    /**\r\n     * sets if tile is accessible or not\r\n     * @param a\r\n     */\r\n    public void setAccessible(boolean a) {\r\n        this.accessible = a;\r\n    }\r\n\r\n    /**\r\n     * checks if tile can be bombed\r\n     * @return\r\n     */\r\n    public boolean isBombable() {\r\n        return this.bombable;\r\n    }\r\n\r\n    /**\r\n     * sets if tile can be bombed\r\n     * @param b\r\n     */\r\n    public void setBombable(boolean b) {\r\n        this.bombable = b;\r\n    }\r\n\r\n    /**\r\n     * checks if tile is visible\r\n     * @return\r\n     */\r\n    public boolean isVisible() {\r\n        return visible;\r\n    }\r\n\r\n    /**\r\n     * sets if tile is visible\r\n     * @param visible\r\n     */\r\n    public void setVisible(boolean visible) {\r\n        this.visible = visible;\r\n    }\r\n\r\n    /**\r\n     * returns speedfactor for tile\r\n     * @return\r\n     */\r\n    public double getSpeedFactor() {\r\n        return speedFactor;\r\n    }\r\n\r\n    @Override\r\n    public void updateWithCollisionCheck(Collection<GameObject> gameObjects) {\r\n        // TODO Auto-generated method stub\r\n    }\r\n\r\n    @Override\r\n    public boolean collide(GameObject gameobject) {\r\n        // TODO Auto-generated method stub\r\n        return false;\r\n    }\r\n\r\n    @Override\r\n    public Rectangle getCollisionRectangle() {\r\n        return new Rectangle(position.getLocation().x - Constants.HALF_TILE, position.getLocation().y - Constants.HALF_TILE, Constants.TILE_BORDER, Constants.TILE_BORDER);\r\n    }\r\n\r\n    public void die() {\r\n        active = false;\r\n        if (bombable) {\r\n            accessible = true;\r\n        }\r\n    }\r\n\r\n    public void destroy() {\r\n        die();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/common/TileTest3.java",
		"test_prompt": "// TileTest3.java\npackage common;\n\nimport java.awt.Point;\nimport java.awt.Rectangle;\nimport java.util.Collection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Tile}.\n* It contains ten unit test cases for the {@link Tile#isVisible()} method.\n*/\nclass TileTest3 {"
	},
	{
		"original_code": "// Tile.java\npackage common;\r\n\r\nimport java.awt.Point;\r\nimport java.awt.Rectangle;\r\nimport java.util.Collection;\r\n\r\n/**\r\n * tile object can be specified for each tile of map\r\n *\r\n * @author christian, Daniel Tunjic\r\n */\r\npublic class Tile extends GameObject {\r\n\r\n    // tile properties\r\n    private String type;\r\n\r\n    private boolean accessible = true;\r\n\r\n    private boolean bombable = false;\r\n\r\n    private boolean visible = true;\r\n\r\n    private double speedFactor = 1.0;\r\n\r\n    /**\r\n     * create tile object at coordinates p\r\n     *\r\n     * @param p\r\n     */\r\n    public Tile(Point p) {\r\n        super(p);\r\n    }\r\n\r\n    @Override\r\n    public void update() {\r\n        // TODO Auto-generated method stub\r\n    }\r\n\r\n    /**\r\n     * gets type of tile, important for tile image\r\n     * @return\r\n     */\r\n    public String getType() {\r\n        return this.type;\r\n    }\r\n\r\n    /**\r\n     * sets type of tile, important for tile image\r\n     * @param type\r\n     */\r\n    public void setType(String type) {\r\n        this.type = type;\r\n    }\r\n\r\n    /**\r\n     * sets a bunch of properties\r\n     * @param type - String, type of tile\r\n     * @param accessible - Boolean, is tile accessible\r\n     * @param bombable - Boolean, is tile bombable\r\n     */\r\n    public void setProperties(String type, boolean accessible, boolean bombable) {\r\n        this.type = type;\r\n        this.bombable = bombable;\r\n        this.accessible = accessible;\r\n    }\r\n\r\n    /**\r\n     * returns weather tile accessible or not\r\n     *  isAccessable is identical but wrong spelled\r\n     * @return\r\n     */\r\n    public boolean isAccessible() {\r\n        return this.accessible;\r\n    }\r\n\r\n    /**\r\n     * returns weather tile accessible or not\r\n     *  isAccessable is identical but wrong spelled\r\n     * @return\r\n     */\r\n    @Override\r\n    public boolean isAccessable() {\r\n        return this.accessible;\r\n    }\r\n\r\n    /**\r\n     * sets if tile is accessible or not\r\n     * @param a\r\n     */\r\n    public void setAccessible(boolean a) {\r\n        this.accessible = a;\r\n    }\r\n\r\n    /**\r\n     * checks if tile can be bombed\r\n     * @return\r\n     */\r\n    public boolean isBombable() {\r\n        return this.bombable;\r\n    }\r\n\r\n    /**\r\n     * sets if tile can be bombed\r\n     * @param b\r\n     */\r\n    public void setBombable(boolean b) {\r\n        this.bombable = b;\r\n    }\r\n\r\n    /**\r\n     * checks if tile is visible\r\n     * @return\r\n     */\r\n    public boolean isVisible() {\r\n        return visible;\r\n    }\r\n\r\n    /**\r\n     * sets if tile is visible\r\n     * @param visible\r\n     */\r\n    public void setVisible(boolean visible) {\r\n        this.visible = visible;\r\n    }\r\n\r\n    /**\r\n     * returns speedfactor for tile\r\n     * @return\r\n     */\r\n    public double getSpeedFactor() {\r\n        return speedFactor;\r\n    }\r\n\r\n    @Override\r\n    public void updateWithCollisionCheck(Collection<GameObject> gameObjects) {\r\n        // TODO Auto-generated method stub\r\n    }\r\n\r\n    @Override\r\n    public boolean collide(GameObject gameobject) {\r\n        // TODO Auto-generated method stub\r\n        return false;\r\n    }\r\n\r\n    @Override\r\n    public Rectangle getCollisionRectangle() {\r\n        return new Rectangle(position.getLocation().x - Constants.HALF_TILE, position.getLocation().y - Constants.HALF_TILE, Constants.TILE_BORDER, Constants.TILE_BORDER);\r\n    }\r\n\r\n    public void die() {\r\n        active = false;\r\n        if (bombable) {\r\n            accessible = true;\r\n        }\r\n    }\r\n\r\n    public void destroy() {\r\n        die();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/common/TileTest4.java",
		"test_prompt": "// TileTest4.java\npackage common;\n\nimport java.awt.Point;\nimport java.awt.Rectangle;\nimport java.util.Collection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Tile}.\n* It contains ten unit test cases for the {@link Tile#collide(GameObject)} method.\n*/\nclass TileTest4 {"
	},
	{
		"original_code": "// PowerUp.java\n/**\r\n */\r\npackage common;\r\n\r\nimport java.awt.Point;\r\nimport java.awt.Rectangle;\r\nimport java.util.Collection;\r\nimport org.apache.log4j.Logger;\r\nimport org.postgresql.core.VisibleBufferedInputStream;\r\n\r\n/**\r\n * @author Bj�rn\r\n */\r\npublic class PowerUp extends GameObject {\r\n\r\n    /**\r\n     * @param position\r\n     *            the position of the powerup\r\n     */\r\n    public PowerUp(Point position) {\r\n        super(position);\r\n        setActive();\r\n        setInvisible();\r\n    }\r\n\r\n    /**\r\n     * Type of this powerup.\r\n     */\r\n    private String type;\r\n\r\n    @Override\r\n    public boolean collide(GameObject gameobject) {\r\n        return false;\r\n    }\r\n\r\n    @Override\r\n    public Rectangle getCollisionRectangle() {\r\n        return new Rectangle(getPosition().x - Constants.HALF_POWERUP, getPosition().y - Constants.HALF_POWERUP, Constants.POWERUP_BORDER, Constants.POWERUP_BORDER);\r\n    }\r\n\r\n    @Override\r\n    public boolean isAccessable() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public void update() {\r\n    }\r\n\r\n    @Override\r\n    public void updateWithCollisionCheck(Collection<GameObject> gameObjects) {\r\n    }\r\n\r\n    /**\r\n     * Returns the type of this powerup as a string.\r\n     *\r\n     * @return String type of powerup\r\n     */\r\n    public String getType() {\r\n        return type;\r\n    }\r\n\r\n    /**\r\n     * Sets the type of this powerup.\r\n     *\r\n     * @param type,\r\n     *            which should be set\r\n     */\r\n    public void setType(String type) {\r\n        this.type = type;\r\n    }\r\n\r\n    /**\r\n     */\r\n    public void die() {\r\n        active = true;\r\n    }\r\n\r\n    /**\r\n     * Returns the type of this powerup as a integer.\r\n     *\r\n     * @return int type of powerup\r\n     *\r\n     * missing powerup-types: bomb, poison, timer\r\n     */\r\n    public int getTypeInt() {\r\n        if (getType().equals(\"speed\"))\r\n            return 1;\r\n        else if (getType().equals(\"bowl\"))\r\n            return 2;\r\n        else if (getType().equals(\"longray\"))\r\n            return 3;\r\n        else if (getType().equals(\"multibomb\"))\r\n            return 4;\r\n        else\r\n            return 0;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/common/PowerUpTest0.java",
		"test_prompt": "// PowerUpTest0.java\npackage common;\n\nimport java.awt.Point;\nimport java.awt.Rectangle;\nimport java.util.Collection;\nimport org.apache.log4j.Logger;\nimport org.postgresql.core.VisibleBufferedInputStream;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PowerUp}.\n* It contains ten unit test cases for the {@link PowerUp#collide(GameObject)} method.\n*/\nclass PowerUpTest0 {"
	},
	{
		"original_code": "// PowerUp.java\n/**\r\n */\r\npackage common;\r\n\r\nimport java.awt.Point;\r\nimport java.awt.Rectangle;\r\nimport java.util.Collection;\r\nimport org.apache.log4j.Logger;\r\nimport org.postgresql.core.VisibleBufferedInputStream;\r\n\r\n/**\r\n * @author Bj�rn\r\n */\r\npublic class PowerUp extends GameObject {\r\n\r\n    /**\r\n     * @param position\r\n     *            the position of the powerup\r\n     */\r\n    public PowerUp(Point position) {\r\n        super(position);\r\n        setActive();\r\n        setInvisible();\r\n    }\r\n\r\n    /**\r\n     * Type of this powerup.\r\n     */\r\n    private String type;\r\n\r\n    @Override\r\n    public boolean collide(GameObject gameobject) {\r\n        return false;\r\n    }\r\n\r\n    @Override\r\n    public Rectangle getCollisionRectangle() {\r\n        return new Rectangle(getPosition().x - Constants.HALF_POWERUP, getPosition().y - Constants.HALF_POWERUP, Constants.POWERUP_BORDER, Constants.POWERUP_BORDER);\r\n    }\r\n\r\n    @Override\r\n    public boolean isAccessable() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public void update() {\r\n    }\r\n\r\n    @Override\r\n    public void updateWithCollisionCheck(Collection<GameObject> gameObjects) {\r\n    }\r\n\r\n    /**\r\n     * Returns the type of this powerup as a string.\r\n     *\r\n     * @return String type of powerup\r\n     */\r\n    public String getType() {\r\n        return type;\r\n    }\r\n\r\n    /**\r\n     * Sets the type of this powerup.\r\n     *\r\n     * @param type,\r\n     *            which should be set\r\n     */\r\n    public void setType(String type) {\r\n        this.type = type;\r\n    }\r\n\r\n    /**\r\n     */\r\n    public void die() {\r\n        active = true;\r\n    }\r\n\r\n    /**\r\n     * Returns the type of this powerup as a integer.\r\n     *\r\n     * @return int type of powerup\r\n     *\r\n     * missing powerup-types: bomb, poison, timer\r\n     */\r\n    public int getTypeInt() {\r\n        if (getType().equals(\"speed\"))\r\n            return 1;\r\n        else if (getType().equals(\"bowl\"))\r\n            return 2;\r\n        else if (getType().equals(\"longray\"))\r\n            return 3;\r\n        else if (getType().equals(\"multibomb\"))\r\n            return 4;\r\n        else\r\n            return 0;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/common/PowerUpTest1.java",
		"test_prompt": "// PowerUpTest1.java\npackage common;\n\nimport java.awt.Point;\nimport java.awt.Rectangle;\nimport java.util.Collection;\nimport org.apache.log4j.Logger;\nimport org.postgresql.core.VisibleBufferedInputStream;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PowerUp}.\n* It contains ten unit test cases for the {@link PowerUp#isAccessable()} method.\n*/\nclass PowerUpTest1 {"
	},
	{
		"original_code": "// MapPreview.java\npackage common;\r\n\r\nimport java.awt.Color;\r\nimport java.awt.Graphics;\r\nimport java.awt.Image;\r\nimport java.awt.Point;\r\nimport java.awt.geom.AffineTransform;\r\nimport java.awt.image.AffineTransformOp;\r\nimport java.awt.image.BufferedImage;\r\nimport java.io.File;\r\nimport java.io.IOException;\r\nimport java.util.Vector;\r\nimport javax.imageio.ImageIO;\r\nimport javax.swing.ImageIcon;\r\nimport org.apache.log4j.Logger;\r\n\r\n/**\r\n * create a ImageIcon Map Preview of a map object\r\n *\r\n * usage example: MapPreview mp = new MapPreview(map); mp.setImageSet(\"desert\");\r\n * (optional) ImageIcon ii = mp.getMapPreview(150); !!\r\n *\r\n * @author christian\r\n */\r\npublic class MapPreview {\r\n\r\n    private String mapImageSet;\r\n\r\n    private Point mapArea;\r\n\r\n    private ImageIcon mapPreviewIcon;\r\n\r\n    private BufferedImage mapPreview;\r\n\r\n    private Map mapMap;\r\n\r\n    private String mapFile;\r\n\r\n    // map tile Images, for caching purposes\r\n    private static Image TILE_WALL_IMAGE;\r\n\r\n    private static Image TILE_STONE_IMAGE;\r\n\r\n    private static final Logger logger = Logger.getLogger(MapPreview.class);\r\n\r\n    /**\r\n     * class for creating map Preview of Map map\r\n     *\r\n     * @param map -\r\n     *            map for which preview should be created\r\n     */\r\n    public MapPreview(Map map) {\r\n        mapMap = map;\r\n        mapImageSet = map.getImageSet();\r\n        mapArea = map.getArea();\r\n        mapFile = map.getFilePath();\r\n    }\r\n\r\n    /**\r\n     * set imageSet, overrides default map imageSet\r\n     *\r\n     * @param imageSet -\r\n     *            String, imageSet (-folder)\r\n     */\r\n    public void setImageSet(String imageSet) {\r\n        this.mapImageSet = imageSet;\r\n    }\r\n\r\n    /**\r\n     * returns preview of current map\r\n     *\r\n     * @param previewWidth -\r\n     *            Width of preview. Proportions are constrained\r\n     * @return BufferedImage with map preview\r\n     */\r\n    public ImageIcon getMapPreview(int previewWidth) {\r\n        // check if file is available, file name is identical to\r\n        // xml file with appended .png\r\n        File checkFile = new File(mapFile + \"_\" + mapImageSet + \".png\");\r\n        if (checkFile.exists()) {\r\n            logger.info(\"Loading map preview: \" + checkFile.getName());\r\n            BufferedImage mapPreview;\r\n            try {\r\n                mapPreview = ImageIO.read(new File(mapFile + \"_\" + mapImageSet + \".png\"));\r\n                mapPreviewIcon = new ImageIcon();\r\n                mapPreviewIcon.setImage((Image) mapPreview);\r\n            } catch (IOException e) {\r\n                logger.error(e);\r\n            }\r\n        } else {\r\n            // image not found, create it\r\n            logger.info(\"Creating map preview: \" + checkFile.getName());\r\n            // preload images\r\n            TILE_WALL_IMAGE = LoadImage(\"wall\");\r\n            TILE_STONE_IMAGE = LoadImage(\"stone\");\r\n            mapPreviewIcon = new ImageIcon();\r\n            mapPreview = new BufferedImage(mapArea.x * Constants.TILE_BORDER, mapArea.y * Constants.TILE_BORDER, BufferedImage.TYPE_INT_RGB);\r\n            // draw map to BufferedImage\r\n            drawMap();\r\n            try {\r\n                ImageIO.write(scale(mapPreview, previewWidth), \"png\", checkFile);\r\n            } catch (Exception e) {\r\n                logger.error(\"Caught in getMapPreview(): \" + e);\r\n            }\r\n            // return / resize and return\r\n            if (previewWidth == (mapArea.x * Constants.TILE_BORDER)) {\r\n                mapPreviewIcon.setImage((Image) mapPreview);\r\n            } else {\r\n                mapPreviewIcon.setImage((Image) scale(mapPreview, previewWidth));\r\n            }\r\n        }\r\n        return mapPreviewIcon;\r\n    }\r\n\r\n    /**\r\n     * draws all map tiles to Graphics object\r\n     */\r\n    private void drawMap() {\r\n        logger.info(\"draw mapPreview...\");\r\n        Graphics g = mapPreview.getGraphics();\r\n        g.setColor(Color.white);\r\n        g.fillRect(0, 0, 800, 600);\r\n        for (Tile tile : mapMap) {\r\n            drawTile(g, tile.getPosition(), tile.getType(), true);\r\n        }\r\n        g.dispose();\r\n    }\r\n\r\n    /**\r\n     * method for scaling/resizing BufferedImages to target width\r\n     *\r\n     * @param bi -\r\n     *            BufferedImage\r\n     * @param targetWidth -\r\n     *            target width of resized image\r\n     * @return BufferedImage - with map preview\r\n     */\r\n    private BufferedImage scale(BufferedImage bi, int targetWidth) {\r\n        // calculate scale-factor\r\n        double scaleFactor = (double) targetWidth / (double) bi.getWidth();\r\n        logger.info(\"resize map preview to width: \" + targetWidth);\r\n        AffineTransform tx = new AffineTransform();\r\n        tx.scale(scaleFactor, scaleFactor);\r\n        AffineTransformOp op = new AffineTransformOp(tx, AffineTransformOp.TYPE_NEAREST_NEIGHBOR);\r\n        return op.filter(bi, null);\r\n    }\r\n\r\n    /**\r\n     * loads an image-file into an Image object\r\n     *\r\n     * @param fileName -\r\n     *            String, name of file, w/o path and ending\r\n     * @return Image\r\n     */\r\n    public Image LoadImage(String fileName) {\r\n        Image image = null;\r\n        try {\r\n            image = ImageIO.read(new File(\"resources/gfx/map/\" + mapImageSet + \"/\" + fileName + \".png\"));\r\n        } catch (IOException e) {\r\n            logger.error(e.toString());\r\n        }\r\n        return image;\r\n    }\r\n\r\n    /**\r\n     * draws tile at specific position\r\n     *\r\n     * @param g2d -\r\n     *            Graphics2D object\r\n     * @param position -\r\n     *            Point, coordinates\r\n     * @param fileName -\r\n     *            String, name of file, w/o path and ending\r\n     * @param middle -\r\n     *            is the position of element set to middle, correct the upper\r\n     *            left coordinate\r\n     */\r\n    public void drawTile(Graphics g, Point position, String fileName, Boolean middle) {\r\n        Image image;\r\n        int posCorrection = 0;\r\n        if (middle) {\r\n            posCorrection = Constants.TILE_BORDER / 2;\r\n        }\r\n        // use cached image or load image\r\n        if (fileName.equals(\"wall\")) {\r\n            image = TILE_WALL_IMAGE;\r\n        } else if (fileName.equals(\"stone\")) {\r\n            image = TILE_STONE_IMAGE;\r\n        } else {\r\n            image = LoadImage(fileName);\r\n        }\r\n        g.drawImage(image, position.x - posCorrection, position.y - posCorrection, null);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/common/MapPreviewTest.java",
		"test_prompt": "// MapPreviewTest.java\npackage common;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Image;\nimport java.awt.Point;\nimport java.awt.geom.AffineTransform;\nimport java.awt.image.AffineTransformOp;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Vector;\nimport javax.imageio.ImageIO;\nimport javax.swing.ImageIcon;\nimport org.apache.log4j.Logger;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MapPreview}.\n* It contains ten unit test cases for the {@link MapPreview#LoadImage(String)} method.\n*/\nclass MapPreviewTest {"
	},
	{
		"original_code": "// XmlFunctions.java\npackage common;\r\n\r\nimport java.io.File;\r\nimport java.io.IOException;\r\nimport javax.xml.parsers.DocumentBuilder;\r\nimport javax.xml.parsers.DocumentBuilderFactory;\r\nimport javax.xml.parsers.ParserConfigurationException;\r\nimport javax.xml.transform.Result;\r\nimport javax.xml.transform.Source;\r\nimport javax.xml.transform.Transformer;\r\nimport javax.xml.transform.TransformerConfigurationException;\r\nimport javax.xml.transform.TransformerException;\r\nimport javax.xml.transform.TransformerFactory;\r\nimport javax.xml.transform.dom.DOMSource;\r\nimport javax.xml.transform.stream.StreamResult;\r\nimport javax.xml.xpath.XPath;\r\nimport javax.xml.xpath.XPathConstants;\r\nimport javax.xml.xpath.XPathExpression;\r\nimport javax.xml.xpath.XPathExpressionException;\r\nimport javax.xml.xpath.XPathFactory;\r\nimport org.apache.log4j.Logger;\r\nimport org.w3c.dom.Document;\r\nimport org.w3c.dom.Node;\r\nimport org.w3c.dom.NodeList;\r\nimport org.xml.sax.SAXException;\r\n\r\n/**\r\n * basic functions for reading and writing xml files\r\n *\r\n * @author christian\r\n */\r\npublic class XmlFunctions {\r\n\r\n    private static final Logger logger = Logger.getLogger(XmlFunctions.class);\r\n\r\n    Document xml;\r\n\r\n    String fileName;\r\n\r\n    /**\r\n     * constructor\r\n     *\r\n     * @param XmlFileName -\r\n     *            path to xml file\r\n     */\r\n    public XmlFunctions(String XmlFileName) {\r\n        this.fileName = XmlFileName;\r\n        openXmlFile(fileName);\r\n    }\r\n\r\n    /**\r\n     * sets value to specific xml node and saves the xml file\r\n     *\r\n     * @param element -\r\n     *            name of xml element\r\n     * @param value -\r\n     *            String, value to be set\r\n     */\r\n    public void setXmlValue(String xmlPath, String value) {\r\n        Node node = findXmlNode(xmlPath);\r\n        node.setTextContent(value);\r\n        // (re)write xml file\r\n        writeXmlFile();\r\n    }\r\n\r\n    /**\r\n     * returns value of specific xml element\r\n     *\r\n     * @param XmlPath -\r\n     *            element path (XPath)\r\n     * @return String with value of element\r\n     */\r\n    public String getXmlValue(String XmlPath) {\r\n        Node node = findXmlNode(XmlPath);\r\n        return node.getTextContent();\r\n    }\r\n\r\n    /**\r\n     * reads a xml file into a Document object\r\n     *\r\n     * @param fileName -\r\n     *            path to xml file\r\n     */\r\n    private void openXmlFile(String fileName) {\r\n        try {\r\n            DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\r\n            xml = builder.parse(new File(fileName));\r\n        } catch (SAXException ex) {\r\n            logger.error(ex);\r\n        } catch (IOException ex) {\r\n            logger.error(ex);\r\n        } catch (ParserConfigurationException ex) {\r\n            logger.error(ex);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * finds a xml node in the Document object and returns it\r\n     *\r\n     * @param XmlPath -\r\n     *            element path (XPath)\r\n     * @return Node - found node\r\n     */\r\n    private Node findXmlNode(String XmlPath) {\r\n        Node node = null;\r\n        try {\r\n            XPath xpath = XPathFactory.newInstance().newXPath();\r\n            XPathExpression expr = xpath.compile(XmlPath);\r\n            Object result = expr.evaluate(xml, XPathConstants.NODE);\r\n            node = (Node) result;\r\n            if (node == null) {\r\n                logger.error(\"Node: \" + XmlPath + \" nicht gefunden.\");\r\n            }\r\n        } catch (XPathExpressionException ex) {\r\n            logger.error(ex);\r\n        }\r\n        return node;\r\n    }\r\n\r\n    /**\r\n     * returns a list of nodes matching to the element name\r\n     *\r\n     * @param NodeName -\r\n     *            name of element(s)\r\n     * @return NodeList with found nodes\r\n     */\r\n    public NodeList findXmlNodes(String NodeName) {\r\n        try {\r\n            XPath xpath = XPathFactory.newInstance().newXPath();\r\n            XPathExpression expr = xpath.compile(NodeName);\r\n            Object result = expr.evaluate(xml, XPathConstants.NODESET);\r\n            return (NodeList) result;\r\n        } catch (XPathExpressionException ex) {\r\n            logger.error(ex);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * writes global Document object xml (back) into xml file\r\n     */\r\n    private void writeXmlFile() {\r\n        try {\r\n            // Prepare the DOM document for writing\r\n            Source source = new DOMSource(xml);\r\n            // Prepare the output file\r\n            File xmlFile = new File(fileName);\r\n            Result result = new StreamResult(xmlFile);\r\n            // Write the DOM document to the file\r\n            Transformer xformer = TransformerFactory.newInstance().newTransformer();\r\n            xformer.transform(source, result);\r\n        } catch (TransformerConfigurationException e) {\r\n            logger.error(e);\r\n        } catch (TransformerException e) {\r\n            logger.error(e);\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/common/XmlFunctionsTest.java",
		"test_prompt": "// XmlFunctionsTest.java\npackage common;\n\nimport java.io.File;\nimport java.io.IOException;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.Result;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpression;\nimport javax.xml.xpath.XPathExpressionException;\nimport javax.xml.xpath.XPathFactory;\nimport org.apache.log4j.Logger;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.SAXException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XmlFunctions}.\n* It contains ten unit test cases for the {@link XmlFunctions#findXmlNodes(String)} method.\n*/\nclass XmlFunctionsTest {"
	},
	{
		"original_code": "// Player.java\npackage common;\n\nimport java.awt.Point;\nimport java.awt.Rectangle;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\nimport org.apache.log4j.Logger;\n\npublic class Player extends Actor {\n\n    private static final Logger logger = Logger.getLogger(Player.class);\n\n    private static final int MIN_SPEED = 1;\n\n    private static final int MAX_SPEED = 3;\n\n    // hitbox collision\n    protected static final int COLLISION_WIDTH = 26;\n\n    protected static final int COLLISION_HEIGHT = 25;\n\n    protected static final int COLLISION_X_OFFSET = COLLISION_WIDTH / 2;\n\n    protected static final int COLLISION_Y_OFFSET = 19;\n\n    // hitbox explosion\n    protected static final int BODY_WIDTH = 38;\n\n    protected static final int BODY_HEIGHT = 60;\n\n    private static final int BODY_Y_OFFSET = 55;\n\n    private static final int BODY_X_OFFSET = 19;\n\n    /**\n     * The tolerance for tile collision detection. This value is used to shrink\n     * the hit box by TILE_COLLISION_TOLERANCE units on each side.\n     */\n    private static final int TILE_COLLISION_TOLERANCE = 4;\n\n    private int roundScore;\n\n    private boolean accessToBombs = false;\n\n    private int totalscore;\n\n    private String name = null;\n\n    protected Set<Bomb> bombsThatSpawnedOnMe = Collections.synchronizedSet(new HashSet<Bomb>());\n\n    public Player(Point position) {\n        super(position);\n    }\n\n    public int getRoundScore() {\n        return roundScore;\n    }\n\n    @Override\n    public void update() {\n        super.update();\n    }\n\n    public void increaseSpeed() {\n        if (speed < MAX_SPEED) {\n            speed = speed + 1;\n        }\n    }\n\n    public void resetSpeed() {\n        speed = MIN_SPEED;\n    }\n\n    public void die() {\n        active = false;\n        setChanged();\n        notifyObservers();\n    }\n\n    @Override\n    public boolean isAccessable() {\n        return true;\n    }\n\n    @Override\n    public Rectangle getCollisionRectangle() {\n        return new Rectangle(position.x - COLLISION_X_OFFSET, position.y - COLLISION_Y_OFFSET, COLLISION_WIDTH, COLLISION_HEIGHT);\n    }\n\n    public void plantBomb() {\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void addRoundScore(int roundScore) {\n        this.roundScore += roundScore;\n    }\n\n    /**\n     * Checks for a collision involving this {@link Actor} and the specified\n     * {@link GameObject}. The calculation is done with a greater 'tolerance' than\n     * in the {@link Actor} implementation.\n     *\n     * @param gameObject\n     * @return\n     */\n    public boolean collide(GameObject gameObject) {\n        if (gameObject.isAccessable() == false) {\n            Rectangle myrect = this.getCollisionRectangle();\n            int tolerance = TILE_COLLISION_TOLERANCE;\n            int xSign = moveVector.x < 0 ? -1 : 1;\n            int ySign = moveVector.y < 0 ? -1 : 1;\n            Rectangle rect = new Rectangle(myrect.x + moveVector.x + tolerance * xSign, myrect.y + moveVector.y + tolerance * ySign, myrect.width - tolerance * 2, myrect.height - tolerance * 2);\n            if (this.id != gameObject.id) {\n                if (rect.intersects(gameObject.getCollisionRectangle())) {\n                    // collision?\n                    remoteMovementHelper();\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /* (non-Javadoc)\n     * @see common.Actor#extendedCollisionCheck()\n     */\n    @Override\n    protected boolean extendedCollisionCheck(GameObject gameObject) {\n        boolean collision = false;\n        if (Bomb.class.isInstance(gameObject)) {\n            Bomb bomb = (Bomb) gameObject;\n            if (this.collide(bomb)) {\n                /*\n                 * This player collides with the bomb.\n                 * If the bomb has not been updated yet, it must have spawned\n                 * on this player.\n                 */\n                if (bomb.hasJustBeenPlanted()) {\n                    bombsThatSpawnedOnMe.add(bomb);\n                } else if (!bombsThatSpawnedOnMe.contains(bomb)) {\n                    collision = true;\n                }\n            } else {\n                /* This player doesn't collide with the bomb,\n                 * so we remove it from the collection of bombs that\n                 * have spawned on this player.\n                 * If the bomb is not a member of the bombsThatSpawnedOnMe\n                 * set, this will do nothing.\n                 */\n                if (bombsThatSpawnedOnMe.contains(bomb)) {\n                    bombsThatSpawnedOnMe.remove(bomb);\n                }\n            }\n        }\n        return collision;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/common/PlayerTest0.java",
		"test_prompt": "// PlayerTest0.java\npackage common;\n\nimport java.awt.Point;\nimport java.awt.Rectangle;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\nimport org.apache.log4j.Logger;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Player}.\n* It contains ten unit test cases for the {@link Player#isAccessable()} method.\n*/\nclass PlayerTest0 {"
	},
	{
		"original_code": "// Player.java\npackage common;\n\nimport java.awt.Point;\nimport java.awt.Rectangle;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\nimport org.apache.log4j.Logger;\n\npublic class Player extends Actor {\n\n    private static final Logger logger = Logger.getLogger(Player.class);\n\n    private static final int MIN_SPEED = 1;\n\n    private static final int MAX_SPEED = 3;\n\n    // hitbox collision\n    protected static final int COLLISION_WIDTH = 26;\n\n    protected static final int COLLISION_HEIGHT = 25;\n\n    protected static final int COLLISION_X_OFFSET = COLLISION_WIDTH / 2;\n\n    protected static final int COLLISION_Y_OFFSET = 19;\n\n    // hitbox explosion\n    protected static final int BODY_WIDTH = 38;\n\n    protected static final int BODY_HEIGHT = 60;\n\n    private static final int BODY_Y_OFFSET = 55;\n\n    private static final int BODY_X_OFFSET = 19;\n\n    /**\n     * The tolerance for tile collision detection. This value is used to shrink\n     * the hit box by TILE_COLLISION_TOLERANCE units on each side.\n     */\n    private static final int TILE_COLLISION_TOLERANCE = 4;\n\n    private int roundScore;\n\n    private boolean accessToBombs = false;\n\n    private int totalscore;\n\n    private String name = null;\n\n    protected Set<Bomb> bombsThatSpawnedOnMe = Collections.synchronizedSet(new HashSet<Bomb>());\n\n    public Player(Point position) {\n        super(position);\n    }\n\n    public int getRoundScore() {\n        return roundScore;\n    }\n\n    @Override\n    public void update() {\n        super.update();\n    }\n\n    public void increaseSpeed() {\n        if (speed < MAX_SPEED) {\n            speed = speed + 1;\n        }\n    }\n\n    public void resetSpeed() {\n        speed = MIN_SPEED;\n    }\n\n    public void die() {\n        active = false;\n        setChanged();\n        notifyObservers();\n    }\n\n    @Override\n    public boolean isAccessable() {\n        return true;\n    }\n\n    @Override\n    public Rectangle getCollisionRectangle() {\n        return new Rectangle(position.x - COLLISION_X_OFFSET, position.y - COLLISION_Y_OFFSET, COLLISION_WIDTH, COLLISION_HEIGHT);\n    }\n\n    public void plantBomb() {\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void addRoundScore(int roundScore) {\n        this.roundScore += roundScore;\n    }\n\n    /**\n     * Checks for a collision involving this {@link Actor} and the specified\n     * {@link GameObject}. The calculation is done with a greater 'tolerance' than\n     * in the {@link Actor} implementation.\n     *\n     * @param gameObject\n     * @return\n     */\n    public boolean collide(GameObject gameObject) {\n        if (gameObject.isAccessable() == false) {\n            Rectangle myrect = this.getCollisionRectangle();\n            int tolerance = TILE_COLLISION_TOLERANCE;\n            int xSign = moveVector.x < 0 ? -1 : 1;\n            int ySign = moveVector.y < 0 ? -1 : 1;\n            Rectangle rect = new Rectangle(myrect.x + moveVector.x + tolerance * xSign, myrect.y + moveVector.y + tolerance * ySign, myrect.width - tolerance * 2, myrect.height - tolerance * 2);\n            if (this.id != gameObject.id) {\n                if (rect.intersects(gameObject.getCollisionRectangle())) {\n                    // collision?\n                    remoteMovementHelper();\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /* (non-Javadoc)\n     * @see common.Actor#extendedCollisionCheck()\n     */\n    @Override\n    protected boolean extendedCollisionCheck(GameObject gameObject) {\n        boolean collision = false;\n        if (Bomb.class.isInstance(gameObject)) {\n            Bomb bomb = (Bomb) gameObject;\n            if (this.collide(bomb)) {\n                /*\n                 * This player collides with the bomb.\n                 * If the bomb has not been updated yet, it must have spawned\n                 * on this player.\n                 */\n                if (bomb.hasJustBeenPlanted()) {\n                    bombsThatSpawnedOnMe.add(bomb);\n                } else if (!bombsThatSpawnedOnMe.contains(bomb)) {\n                    collision = true;\n                }\n            } else {\n                /* This player doesn't collide with the bomb,\n                 * so we remove it from the collection of bombs that\n                 * have spawned on this player.\n                 * If the bomb is not a member of the bombsThatSpawnedOnMe\n                 * set, this will do nothing.\n                 */\n                if (bombsThatSpawnedOnMe.contains(bomb)) {\n                    bombsThatSpawnedOnMe.remove(bomb);\n                }\n            }\n        }\n        return collision;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/common/PlayerTest1.java",
		"test_prompt": "// PlayerTest1.java\npackage common;\n\nimport java.awt.Point;\nimport java.awt.Rectangle;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\nimport org.apache.log4j.Logger;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Player}.\n* It contains ten unit test cases for the {@link Player#collide(GameObject)} method.\n*/\nclass PlayerTest1 {"
	},
	{
		"original_code": "// GameObject.java\npackage common;\r\n\r\nimport java.awt.Point;\r\nimport java.awt.Rectangle;\r\nimport java.io.Serializable;\r\nimport java.util.Collection;\r\nimport java.util.Observable;\r\nimport java.util.Observer;\r\nimport java.util.Vector;\r\n\r\npublic abstract class GameObject extends Observable implements Serializable {\r\n\r\n    protected Point position;\r\n\r\n    protected int id;\r\n\r\n    protected Vector<Observer> observers;\r\n\r\n    protected boolean active = true;\r\n\r\n    protected boolean visible = true;\r\n\r\n    protected GameObject(Point position) {\r\n        this.position = position;\r\n    }\r\n\r\n    public abstract void update();\r\n\r\n    public abstract Rectangle getCollisionRectangle();\r\n\r\n    public abstract void updateWithCollisionCheck(Collection<GameObject> gameObjects);\r\n\r\n    public abstract boolean collide(GameObject gameobject);\r\n\r\n    public abstract boolean isAccessable();\r\n\r\n    /**\r\n     * @return the id\r\n     */\r\n    public int getId() {\r\n        return id;\r\n    }\r\n\r\n    /**\r\n     * @param id\r\n     *            the id to set\r\n     */\r\n    public void setId(int id) {\r\n        this.id = id;\r\n    }\r\n\r\n    /**\r\n     * @return the position\r\n     */\r\n    public Point getPosition() {\r\n        return position;\r\n    }\r\n\r\n    /**\r\n     * @param position\r\n     *            the position to set\r\n     */\r\n    public void setPosition(Point position) {\r\n        this.position.setLocation(position);\r\n    }\r\n\r\n    /**\r\n     * Returns the active status\r\n     *\r\n     * @author Bj�rn\r\n     */\r\n    public boolean isActive() {\r\n        return active;\r\n    }\r\n\r\n    /**\r\n     * Sets the object inactive\r\n     *\r\n     * @author Bj�rn\r\n     */\r\n    public void setInactive() {\r\n        this.active = false;\r\n    }\r\n\r\n    /**\r\n     * Sets the object active\r\n     *\r\n     * @author Bj�rn\r\n     */\r\n    public void setActive() {\r\n        this.active = true;\r\n    }\r\n\r\n    public void setVisible() {\r\n        this.visible = true;\r\n    }\r\n\r\n    public void setInvisible() {\r\n        this.visible = false;\r\n    }\r\n\r\n    public boolean isVisible() {\r\n        return visible;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/common/GameObjectTest0.java",
		"test_prompt": "// GameObjectTest0.java\npackage common;\n\nimport java.awt.Point;\nimport java.awt.Rectangle;\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Observable;\nimport java.util.Observer;\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GameObject}.\n* It contains ten unit test cases for the {@link GameObject#isActive()} method.\n*/\nclass GameObjectTest0 {"
	},
	{
		"original_code": "// GameObject.java\npackage common;\r\n\r\nimport java.awt.Point;\r\nimport java.awt.Rectangle;\r\nimport java.io.Serializable;\r\nimport java.util.Collection;\r\nimport java.util.Observable;\r\nimport java.util.Observer;\r\nimport java.util.Vector;\r\n\r\npublic abstract class GameObject extends Observable implements Serializable {\r\n\r\n    protected Point position;\r\n\r\n    protected int id;\r\n\r\n    protected Vector<Observer> observers;\r\n\r\n    protected boolean active = true;\r\n\r\n    protected boolean visible = true;\r\n\r\n    protected GameObject(Point position) {\r\n        this.position = position;\r\n    }\r\n\r\n    public abstract void update();\r\n\r\n    public abstract Rectangle getCollisionRectangle();\r\n\r\n    public abstract void updateWithCollisionCheck(Collection<GameObject> gameObjects);\r\n\r\n    public abstract boolean collide(GameObject gameobject);\r\n\r\n    public abstract boolean isAccessable();\r\n\r\n    /**\r\n     * @return the id\r\n     */\r\n    public int getId() {\r\n        return id;\r\n    }\r\n\r\n    /**\r\n     * @param id\r\n     *            the id to set\r\n     */\r\n    public void setId(int id) {\r\n        this.id = id;\r\n    }\r\n\r\n    /**\r\n     * @return the position\r\n     */\r\n    public Point getPosition() {\r\n        return position;\r\n    }\r\n\r\n    /**\r\n     * @param position\r\n     *            the position to set\r\n     */\r\n    public void setPosition(Point position) {\r\n        this.position.setLocation(position);\r\n    }\r\n\r\n    /**\r\n     * Returns the active status\r\n     *\r\n     * @author Bj�rn\r\n     */\r\n    public boolean isActive() {\r\n        return active;\r\n    }\r\n\r\n    /**\r\n     * Sets the object inactive\r\n     *\r\n     * @author Bj�rn\r\n     */\r\n    public void setInactive() {\r\n        this.active = false;\r\n    }\r\n\r\n    /**\r\n     * Sets the object active\r\n     *\r\n     * @author Bj�rn\r\n     */\r\n    public void setActive() {\r\n        this.active = true;\r\n    }\r\n\r\n    public void setVisible() {\r\n        this.visible = true;\r\n    }\r\n\r\n    public void setInvisible() {\r\n        this.visible = false;\r\n    }\r\n\r\n    public boolean isVisible() {\r\n        return visible;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/common/GameObjectTest1.java",
		"test_prompt": "// GameObjectTest1.java\npackage common;\n\nimport java.awt.Point;\nimport java.awt.Rectangle;\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Observable;\nimport java.util.Observer;\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GameObject}.\n* It contains ten unit test cases for the {@link GameObject#isVisible()} method.\n*/\nclass GameObjectTest1 {"
	},
	{
		"original_code": "// Actor.java\npackage common;\r\n\r\nimport java.awt.Point;\r\nimport java.awt.Rectangle;\r\nimport java.util.Collection;\r\nimport org.apache.log4j.Logger;\r\n\r\n/**\r\n * @author Andi, Steffen, Tobi, Daniel, Bj�rn\r\n */\r\npublic abstract class Actor extends GameObject {\r\n\r\n    private static final Logger logger = Logger.getLogger(Actor.class);\r\n\r\n    protected int speed = 1;\r\n\r\n    protected Point moveVector;\r\n\r\n    // protected Point previousMoveVector = NULL_MOVE_VECTOR;\r\n    protected Point currTargetPosition;\r\n\r\n    /**\r\n     * Direction of the actor. Up = 1, Down = 2, Left = 3, Right = 4\r\n     */\r\n    protected int direction;\r\n\r\n    /**\r\n     * Indicates whether this object represents a remote Actor or not. TODO it\r\n     * is probably better to derive a RemoteActor class instead of doing this\r\n     */\r\n    protected boolean isRemote = false;\r\n\r\n    // fields for movement calculation\r\n    private boolean updated;\r\n\r\n    private int calcX;\r\n\r\n    private int calcY;\r\n\r\n    private boolean remoteCollided;\r\n\r\n    /**\r\n     * The basic movement distance. An actor with speed = 1 will move MOVE_DELTA\r\n     * units forward.\r\n     */\r\n    protected static final int MOVE_DELTA = 2;\r\n\r\n    /**\r\n     * Neutral movement vector.\r\n     */\r\n    private static final Point NULL_MOVE_VECTOR = new Point(0, 0);\r\n\r\n    protected Actor(Point position) {\r\n        super(position);\r\n        moveVector = NULL_MOVE_VECTOR;\r\n        currTargetPosition = new Point(position);\r\n    }\r\n\r\n    public void moveUp() {\r\n        moveVector = new Point(0, -MOVE_DELTA - speed);\r\n        direction = 1;\r\n    }\r\n\r\n    public void moveDown() {\r\n        moveVector = new Point(0, MOVE_DELTA + speed);\r\n        direction = 2;\r\n    }\r\n\r\n    public void moveLeft() {\r\n        moveVector = new Point(-MOVE_DELTA - speed, 0);\r\n        direction = 3;\r\n    }\r\n\r\n    public void moveRight() {\r\n        moveVector = new Point(MOVE_DELTA + speed, 0);\r\n        direction = 4;\r\n    }\r\n\r\n    public void stop() {\r\n        this.moveVector = NULL_MOVE_VECTOR;\r\n    }\r\n\r\n    /*\r\n     * (non-Javadoc)\r\n     * \r\n     * @see common.GameObject#update()\r\n     */\r\n    @Override\r\n    public void update() {\r\n        // Mark this actor as changed so the observers will\r\n        // be notified when calling notifyObservers().\r\n        preUpdate();\r\n        // previousMoveVector = moveVector;\r\n        move();\r\n        notifyObservers();\r\n        postUpdate();\r\n    }\r\n\r\n    synchronized protected void move() {\r\n        if (isRemote) {\r\n            if (currTargetPosition.equals(position)) {\r\n                moveVector.setLocation(NULL_MOVE_VECTOR);\r\n            } else if (currTargetPosition.x == position.x || remoteCollided) {\r\n                moveVector = new Point(0, calcY);\r\n            }\r\n            // radical position correction if the difference from the actual\r\n            // position is too big\r\n            if (position.distance(currTargetPosition) > 80) {\r\n                position.setLocation(currTargetPosition);\r\n            }\r\n        }\r\n        int newX = position.x + moveVector.x;\r\n        int newY = position.y + moveVector.y;\r\n        setPosition(new Point(newX, newY));\r\n        remoteCollided = false;\r\n    }\r\n\r\n    /**\r\n     */\r\n    protected void preUpdate() {\r\n    }\r\n\r\n    /**\r\n     */\r\n    protected void postUpdate() {\r\n    }\r\n\r\n    public Point getMoveVector() {\r\n        return moveVector;\r\n    }\r\n\r\n    /**\r\n     * Calculates and sets the new moveVector. If currTargetPosition has been\r\n     * updated, the extrapolated X and Y values are determined. If not, the\r\n     * movement axis is changed to the Y-axis. This is necessary because X- and\r\n     * Y- movement have to be executed sequentially in order to avoid diagonal\r\n     * movement.\r\n     *\r\n     * This method depends on frequent ClientStatusMsgs.\r\n     *\r\n     * This method is only used for remote players.\r\n     */\r\n    private void calcMoveVector() {\r\n        if (updated) {\r\n            calcX = currTargetPosition.x - position.x;\r\n            calcY = currTargetPosition.y - position.y;\r\n            if (calcY != 0) {\r\n                calcY = calcY / Math.abs(calcY) * MOVE_DELTA;\r\n                if (calcY < 0) {\r\n                    calcY = calcY - speed;\r\n                } else {\r\n                    calcY = calcY + speed;\r\n                }\r\n            }\r\n            updated = false;\r\n        }\r\n        if (calcX != 0) {\r\n            calcX = calcX / Math.abs(calcX) * MOVE_DELTA;\r\n            if (calcX < 0) {\r\n                calcX = calcX - speed;\r\n            } else {\r\n                calcX = calcX + speed;\r\n            }\r\n            moveVector = new Point(calcX, 0);\r\n        } else {\r\n            moveVector = new Point(0, calcY);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the movement of a remote Actor.\r\n     *\r\n     * This method is only used by RemoteControl.\r\n     *\r\n     * @param targetPosition\r\n     */\r\n    synchronized public void updateMovement(Point targetPosition) {\r\n        // logger.info(\"Current position: \" + position + \"; Target position: \" +\r\n        // targetPosition);\r\n        this.currTargetPosition = targetPosition;\r\n        updated = true;\r\n        calcMoveVector();\r\n    }\r\n\r\n    /**\r\n     * updates and checks other gameObjects for collision\r\n     *\r\n     * @see common.GameObject#update_universe(java.util.Vector)\r\n     */\r\n    /*\r\n     * ALL MODIFICATIONS THAT ARE SPECIFIC FOR SUBCLASSES HAVE TO BE IMPLEMENTED\r\n     * THERE.\r\n     * NO MORE POOR MAN'S INHERITANCE!\r\n     * -andi-\r\n     * \r\n     * see also:\r\n     * * this.extendedCollisionCheck()\r\n     \r\n     */\r\n    @Override\r\n    synchronized public void updateWithCollisionCheck(Collection<GameObject> gameObjects) {\r\n        /*\r\n         * read the comment above before changing anything here\r\n         */\r\n        boolean collision = false;\r\n        for (GameObject gameObject : gameObjects) {\r\n            if (Tile.class.isInstance(gameObject) && this.collide(gameObject)) {\r\n                collision = true;\r\n                break;\r\n            }\r\n            if (extendedCollisionCheck(gameObject)) {\r\n                collision = true;\r\n                break;\r\n            }\r\n        }\r\n        if (collision) {\r\n            stop();\r\n        }\r\n        update();\r\n    }\r\n\r\n    /**\r\n     * Perform specific collision check that goes beyond wall collisions.\r\n     * Override this in a subclass that needs this kind of behaviour.\r\n     * @param gameObject The candidate for a collision\r\n     * @return true if the extended check yields a collision, false otherwise\r\n     */\r\n    protected boolean extendedCollisionCheck(GameObject gameObject) {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * checks whether the actor would collide with a gameobject or not\r\n     *\r\n     * @see common.GameObject#collide(common.GameObject)\r\n     */\r\n    @Override\r\n    public boolean collide(GameObject gameobject) {\r\n        if (gameobject.isAccessable() == false) {\r\n            Rectangle myrect = this.getCollisionRectangle();\r\n            Rectangle rect = new Rectangle(myrect.x + moveVector.x, myrect.y + moveVector.y, myrect.width, myrect.height);\r\n            if (this.id != gameobject.id) {\r\n                if (rect.intersects(gameobject.getCollisionRectangle())) {\r\n                    // collision?\r\n                    remoteMovementHelper();\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    protected void remoteMovementHelper() {\r\n        if (moveVector.x != 0 && calcY != 0) {\r\n            remoteCollided = true;\r\n        }\r\n    }\r\n\r\n    public void setRemote(boolean isRemote) {\r\n        this.isRemote = isRemote;\r\n    }\r\n\r\n    /**\r\n     * Sets the moveVector of this actor\r\n     *\r\n     * @param moveVector,\r\n     *            which should be set\r\n     */\r\n    public void setMoveVector(Point moveVector) {\r\n        this.moveVector = moveVector;\r\n    }\r\n\r\n    /**\r\n     * Returns the actual direction of this actor\r\n     *\r\n     * @return int direction of actor\r\n     */\r\n    public int getDirection() {\r\n        return direction;\r\n    }\r\n\r\n    public boolean isRemote() {\r\n        return isRemote;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/common/ActorTest0.java",
		"test_prompt": "// ActorTest0.java\npackage common;\n\nimport java.awt.Point;\nimport java.awt.Rectangle;\nimport java.util.Collection;\nimport org.apache.log4j.Logger;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Actor}.\n* It contains ten unit test cases for the {@link Actor#collide(GameObject)} method.\n*/\nclass ActorTest0 {"
	},
	{
		"original_code": "// Actor.java\npackage common;\r\n\r\nimport java.awt.Point;\r\nimport java.awt.Rectangle;\r\nimport java.util.Collection;\r\nimport org.apache.log4j.Logger;\r\n\r\n/**\r\n * @author Andi, Steffen, Tobi, Daniel, Bj�rn\r\n */\r\npublic abstract class Actor extends GameObject {\r\n\r\n    private static final Logger logger = Logger.getLogger(Actor.class);\r\n\r\n    protected int speed = 1;\r\n\r\n    protected Point moveVector;\r\n\r\n    // protected Point previousMoveVector = NULL_MOVE_VECTOR;\r\n    protected Point currTargetPosition;\r\n\r\n    /**\r\n     * Direction of the actor. Up = 1, Down = 2, Left = 3, Right = 4\r\n     */\r\n    protected int direction;\r\n\r\n    /**\r\n     * Indicates whether this object represents a remote Actor or not. TODO it\r\n     * is probably better to derive a RemoteActor class instead of doing this\r\n     */\r\n    protected boolean isRemote = false;\r\n\r\n    // fields for movement calculation\r\n    private boolean updated;\r\n\r\n    private int calcX;\r\n\r\n    private int calcY;\r\n\r\n    private boolean remoteCollided;\r\n\r\n    /**\r\n     * The basic movement distance. An actor with speed = 1 will move MOVE_DELTA\r\n     * units forward.\r\n     */\r\n    protected static final int MOVE_DELTA = 2;\r\n\r\n    /**\r\n     * Neutral movement vector.\r\n     */\r\n    private static final Point NULL_MOVE_VECTOR = new Point(0, 0);\r\n\r\n    protected Actor(Point position) {\r\n        super(position);\r\n        moveVector = NULL_MOVE_VECTOR;\r\n        currTargetPosition = new Point(position);\r\n    }\r\n\r\n    public void moveUp() {\r\n        moveVector = new Point(0, -MOVE_DELTA - speed);\r\n        direction = 1;\r\n    }\r\n\r\n    public void moveDown() {\r\n        moveVector = new Point(0, MOVE_DELTA + speed);\r\n        direction = 2;\r\n    }\r\n\r\n    public void moveLeft() {\r\n        moveVector = new Point(-MOVE_DELTA - speed, 0);\r\n        direction = 3;\r\n    }\r\n\r\n    public void moveRight() {\r\n        moveVector = new Point(MOVE_DELTA + speed, 0);\r\n        direction = 4;\r\n    }\r\n\r\n    public void stop() {\r\n        this.moveVector = NULL_MOVE_VECTOR;\r\n    }\r\n\r\n    /*\r\n     * (non-Javadoc)\r\n     * \r\n     * @see common.GameObject#update()\r\n     */\r\n    @Override\r\n    public void update() {\r\n        // Mark this actor as changed so the observers will\r\n        // be notified when calling notifyObservers().\r\n        preUpdate();\r\n        // previousMoveVector = moveVector;\r\n        move();\r\n        notifyObservers();\r\n        postUpdate();\r\n    }\r\n\r\n    synchronized protected void move() {\r\n        if (isRemote) {\r\n            if (currTargetPosition.equals(position)) {\r\n                moveVector.setLocation(NULL_MOVE_VECTOR);\r\n            } else if (currTargetPosition.x == position.x || remoteCollided) {\r\n                moveVector = new Point(0, calcY);\r\n            }\r\n            // radical position correction if the difference from the actual\r\n            // position is too big\r\n            if (position.distance(currTargetPosition) > 80) {\r\n                position.setLocation(currTargetPosition);\r\n            }\r\n        }\r\n        int newX = position.x + moveVector.x;\r\n        int newY = position.y + moveVector.y;\r\n        setPosition(new Point(newX, newY));\r\n        remoteCollided = false;\r\n    }\r\n\r\n    /**\r\n     */\r\n    protected void preUpdate() {\r\n    }\r\n\r\n    /**\r\n     */\r\n    protected void postUpdate() {\r\n    }\r\n\r\n    public Point getMoveVector() {\r\n        return moveVector;\r\n    }\r\n\r\n    /**\r\n     * Calculates and sets the new moveVector. If currTargetPosition has been\r\n     * updated, the extrapolated X and Y values are determined. If not, the\r\n     * movement axis is changed to the Y-axis. This is necessary because X- and\r\n     * Y- movement have to be executed sequentially in order to avoid diagonal\r\n     * movement.\r\n     *\r\n     * This method depends on frequent ClientStatusMsgs.\r\n     *\r\n     * This method is only used for remote players.\r\n     */\r\n    private void calcMoveVector() {\r\n        if (updated) {\r\n            calcX = currTargetPosition.x - position.x;\r\n            calcY = currTargetPosition.y - position.y;\r\n            if (calcY != 0) {\r\n                calcY = calcY / Math.abs(calcY) * MOVE_DELTA;\r\n                if (calcY < 0) {\r\n                    calcY = calcY - speed;\r\n                } else {\r\n                    calcY = calcY + speed;\r\n                }\r\n            }\r\n            updated = false;\r\n        }\r\n        if (calcX != 0) {\r\n            calcX = calcX / Math.abs(calcX) * MOVE_DELTA;\r\n            if (calcX < 0) {\r\n                calcX = calcX - speed;\r\n            } else {\r\n                calcX = calcX + speed;\r\n            }\r\n            moveVector = new Point(calcX, 0);\r\n        } else {\r\n            moveVector = new Point(0, calcY);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the movement of a remote Actor.\r\n     *\r\n     * This method is only used by RemoteControl.\r\n     *\r\n     * @param targetPosition\r\n     */\r\n    synchronized public void updateMovement(Point targetPosition) {\r\n        // logger.info(\"Current position: \" + position + \"; Target position: \" +\r\n        // targetPosition);\r\n        this.currTargetPosition = targetPosition;\r\n        updated = true;\r\n        calcMoveVector();\r\n    }\r\n\r\n    /**\r\n     * updates and checks other gameObjects for collision\r\n     *\r\n     * @see common.GameObject#update_universe(java.util.Vector)\r\n     */\r\n    /*\r\n     * ALL MODIFICATIONS THAT ARE SPECIFIC FOR SUBCLASSES HAVE TO BE IMPLEMENTED\r\n     * THERE.\r\n     * NO MORE POOR MAN'S INHERITANCE!\r\n     * -andi-\r\n     * \r\n     * see also:\r\n     * * this.extendedCollisionCheck()\r\n     \r\n     */\r\n    @Override\r\n    synchronized public void updateWithCollisionCheck(Collection<GameObject> gameObjects) {\r\n        /*\r\n         * read the comment above before changing anything here\r\n         */\r\n        boolean collision = false;\r\n        for (GameObject gameObject : gameObjects) {\r\n            if (Tile.class.isInstance(gameObject) && this.collide(gameObject)) {\r\n                collision = true;\r\n                break;\r\n            }\r\n            if (extendedCollisionCheck(gameObject)) {\r\n                collision = true;\r\n                break;\r\n            }\r\n        }\r\n        if (collision) {\r\n            stop();\r\n        }\r\n        update();\r\n    }\r\n\r\n    /**\r\n     * Perform specific collision check that goes beyond wall collisions.\r\n     * Override this in a subclass that needs this kind of behaviour.\r\n     * @param gameObject The candidate for a collision\r\n     * @return true if the extended check yields a collision, false otherwise\r\n     */\r\n    protected boolean extendedCollisionCheck(GameObject gameObject) {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * checks whether the actor would collide with a gameobject or not\r\n     *\r\n     * @see common.GameObject#collide(common.GameObject)\r\n     */\r\n    @Override\r\n    public boolean collide(GameObject gameobject) {\r\n        if (gameobject.isAccessable() == false) {\r\n            Rectangle myrect = this.getCollisionRectangle();\r\n            Rectangle rect = new Rectangle(myrect.x + moveVector.x, myrect.y + moveVector.y, myrect.width, myrect.height);\r\n            if (this.id != gameobject.id) {\r\n                if (rect.intersects(gameobject.getCollisionRectangle())) {\r\n                    // collision?\r\n                    remoteMovementHelper();\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    protected void remoteMovementHelper() {\r\n        if (moveVector.x != 0 && calcY != 0) {\r\n            remoteCollided = true;\r\n        }\r\n    }\r\n\r\n    public void setRemote(boolean isRemote) {\r\n        this.isRemote = isRemote;\r\n    }\r\n\r\n    /**\r\n     * Sets the moveVector of this actor\r\n     *\r\n     * @param moveVector,\r\n     *            which should be set\r\n     */\r\n    public void setMoveVector(Point moveVector) {\r\n        this.moveVector = moveVector;\r\n    }\r\n\r\n    /**\r\n     * Returns the actual direction of this actor\r\n     *\r\n     * @return int direction of actor\r\n     */\r\n    public int getDirection() {\r\n        return direction;\r\n    }\r\n\r\n    public boolean isRemote() {\r\n        return isRemote;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/common/ActorTest1.java",
		"test_prompt": "// ActorTest1.java\npackage common;\n\nimport java.awt.Point;\nimport java.awt.Rectangle;\nimport java.util.Collection;\nimport org.apache.log4j.Logger;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Actor}.\n* It contains ten unit test cases for the {@link Actor#isRemote()} method.\n*/\nclass ActorTest1 {"
	},
	{
		"original_code": "// MapFilesLister.java\npackage common;\r\n\r\nimport java.io.File;\r\nimport java.util.LinkedList;\r\nimport java.util.List;\r\nimport java.util.Vector;\r\nimport org.apache.log4j.Logger;\r\nimport messages.global.MapInfo;\r\n\r\n/**\r\n * class for listing maps and returning map information\r\n *\r\n * @author christian\r\n */\r\npublic class MapFilesLister {\r\n\r\n    private static final Logger logger = Logger.getLogger(MapFilesLister.class);\r\n\r\n    public MapFilesLister() {\r\n    }\r\n\r\n    /**\r\n     * reads directory and returns a list of found xml-files\r\n     *\r\n     * @param dir -\r\n     *            directory to be searched in\r\n     * @return Vector<File>\r\n     */\r\n    public Vector<File> ListMaps(String dir) {\r\n        // open map folder\r\n        logger.info(\"Read map directory: \" + dir + \"...\");\r\n        File mapDir = new File(dir);\r\n        File[] mapDirFiles = mapDir.listFiles();\r\n        Vector<File> foundFiles = new Vector<File>();\r\n        // open directories in map folder\r\n        for (int i = 0; i < mapDirFiles.length; i++) {\r\n            if (mapDirFiles[i].isFile() && mapDirFiles[i].toString().endsWith(\".xml\")) {\r\n                logger.info(\"XML: \" + mapDirFiles[i]);\r\n                foundFiles.add(mapDirFiles[i]);\r\n            }\r\n        }\r\n        return foundFiles;\r\n    }\r\n\r\n    /**\r\n     * retrieve list of MapInfo objects\r\n     *\r\n     * @return\r\n     */\r\n    public List<MapInfo> getMapInfoList() {\r\n        // clear map previews\r\n        clearPreviews();\r\n        List<MapInfo> maps = new LinkedList<MapInfo>();\r\n        // read map directory\r\n        Vector<File> mapFiles = ListMaps(Constants.MAP_PATH);\r\n        for (File mapFile : mapFiles) {\r\n            // get map, just the tiles, no start points and powerups\r\n            Map map = new Map(mapFile.getAbsolutePath(), true, false, false);\r\n            MapPreview mapPreview = new MapPreview(map);\r\n            MapInfo mapInfo = new MapInfo(mapFile.getName(), map.getName(), map.getMaxPlayers());\r\n            // creates or reads map preview with 300px width\r\n            mapInfo.setPreview(mapPreview.getMapPreview(300));\r\n            maps.add(mapInfo);\r\n        }\r\n        return maps;\r\n    }\r\n\r\n    /**\r\n     * clears unused or obsolete map preview files\r\n     */\r\n    public void clearPreviews() {\r\n        String dir = Constants.MAP_PATH;\r\n        logger.info(\"Clear map-previews in directory: \" + dir + \"...\");\r\n        File mapDir = new File(dir);\r\n        File[] mapDirPreviews = mapDir.listFiles();\r\n        // list files in map directory\r\n        for (int i = 0; i < mapDirPreviews.length; i++) {\r\n            if (mapDirPreviews[i].isFile() && mapDirPreviews[i].toString().endsWith(\".png\")) {\r\n                // check if map xml is newer than preview\r\n                File mapFileName = new File(mapDirPreviews[i].getPath().replaceAll(\"_[a-z]+.png$\", \"\"));\r\n                // does map still exist\r\n                if (!mapFileName.exists()) {\r\n                    mapDirPreviews[i].delete();\r\n                    logger.info(\"Preview: \" + mapDirPreviews[i] + \" deleted because corresponding map doesn't exists.\");\r\n                } else {\r\n                    // is preview older than map\r\n                    long mapDate = mapFileName.lastModified();\r\n                    if (mapDate > mapDirPreviews[i].lastModified()) {\r\n                        mapDirPreviews[i].delete();\r\n                        logger.info(\"Preview: \" + mapDirPreviews[i] + \" deleted because it was older than the map itself\");\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/common/MapFilesListerTest.java",
		"test_prompt": "// MapFilesListerTest.java\npackage common;\n\nimport java.io.File;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Vector;\nimport org.apache.log4j.Logger;\nimport messages.global.MapInfo;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MapFilesLister}.\n* It contains ten unit test cases for the {@link MapFilesLister#ListMaps(String)} method.\n*/\nclass MapFilesListerTest {"
	},
	{
		"original_code": "// GameModel.java\npackage common;\r\n\r\nimport java.awt.Point;\r\nimport java.util.Collection;\r\nimport java.util.HashMap;\r\nimport java.util.Vector;\r\nimport java.util.Map.Entry;\r\nimport messages.round.RoundTimeOverMsg;\r\nimport org.apache.log4j.Logger;\r\n\r\n/**\r\n * @author Steffen, Andi, Bj�rn\r\n */\r\npublic class GameModel {\r\n\r\n    protected HashMap<Integer, GameObject> gameObjects = new HashMap<Integer, GameObject>();\r\n\r\n    protected Vector<Player> players = new Vector<Player>();\r\n\r\n    protected long time = Constants.time;\r\n\r\n    protected static final Logger logger = Logger.getLogger(GameModel.class);\r\n\r\n    public void update() {\r\n        synchronized (gameObjects) {\r\n            HashMap<Integer, GameObject> inactiveObjects = new HashMap<Integer, GameObject>();\r\n            for (Entry<Integer, GameObject> entry : gameObjects.entrySet()) {\r\n                GameObject gameObject = entry.getValue();\r\n                if (gameObject.isActive()) {\r\n                    gameObject.updateWithCollisionCheck(gameObjects.values());\r\n                }\r\n            }\r\n            for (Entry<Integer, GameObject> entry : gameObjects.entrySet()) {\r\n                if (!entry.getValue().isActive()) {\r\n                    inactiveObjects.put(entry.getKey(), entry.getValue());\r\n                }\r\n            }\r\n            // remove inactive objects now\r\n            for (Entry<Integer, GameObject> entry : inactiveObjects.entrySet()) {\r\n                logger.info(\"Removing game object: \" + entry.getKey());\r\n                gameObjects.remove(entry.getKey());\r\n                if (Player.class.isInstance(entry.getValue())) {\r\n                    logger.info(\"Removing player: \" + entry.getKey());\r\n                    players.remove(entry.getValue());\r\n                }\r\n            }\r\n            inactiveObjects = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if the game is over and if yes returns the gameObjectId of the\r\n     * winner.\r\n     *\r\n     * @return -1 if game still running, 0 in case of a tie, gameObjectId of the\r\n     *         winner in all other cases\r\n     */\r\n    public int checkForWinner() {\r\n        if (players.size() < 2) {\r\n            // 0 means it's a tie (all remaining players got\r\n            int winnerId = 0;\r\n            // killed by the same bomb)\r\n            if (players.size() == 1) {\r\n                // only the winner is left\r\n                winnerId = players.get(0).getId();\r\n            }\r\n            return winnerId;\r\n        } else {\r\n            // game still running\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param arg0\r\n     * @return\r\n     * @see java.util.Vector#add(java.lang.Object)\r\n     */\r\n    public void addGameObject(int id, GameObject newGameObject) {\r\n        synchronized (gameObjects) {\r\n            this.gameObjects.put(id, newGameObject);\r\n            if (Player.class.isInstance(newGameObject)) {\r\n                players.add((Player) newGameObject);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param id\r\n     * @return\r\n     */\r\n    public GameObject getGameObjectById(int id) {\r\n        return gameObjects.get(id);\r\n    }\r\n\r\n    public void snapToGrid(Bomb bomb) {\r\n        Point pos = bomb.getPosition();\r\n        int newX = (pos.x / 40) * 40 + 20;\r\n        int newY = (pos.y / 40) * 40 + 20;\r\n        pos.setLocation(newX, newY);\r\n    }\r\n\r\n    /**\r\n     * Returns the actual time of this GameModel.\r\n     *\r\n     * @return long - actual time\r\n     */\r\n    public long getTime() {\r\n        return time;\r\n    }\r\n\r\n    /**\r\n     * Sets the time of this GameModel.\r\n     *\r\n     * @param time\r\n     *            the time, which should be set\r\n     */\r\n    public void setTime(long time) {\r\n        this.time = time;\r\n    }\r\n\r\n    public Vector<Player> getPlayers() {\r\n        return players;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/common/GameModelTest.java",
		"test_prompt": "// GameModelTest.java\npackage common;\n\nimport java.awt.Point;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Vector;\nimport java.util.Map.Entry;\nimport messages.round.RoundTimeOverMsg;\nimport org.apache.log4j.Logger;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GameModel}.\n* It contains ten unit test cases for the {@link GameModel#checkForWinner()} method.\n*/\nclass GameModelTest {"
	},
	{
		"original_code": "// DBEntityManagerFactory.java\npackage db;\r\n\r\nimport javax.persistence.EntityManagerFactory;\r\nimport javax.persistence.Persistence;\r\n\r\n/**\r\n * This class creates an instance of the EntityManager. The EntityManager provides services for\r\n * persistent data management. It's implemented in the \"BombermanDBService\" class.\r\n *\r\n * @author Daniel Tunjic\r\n */\r\npublic class DBEntityManagerFactory {\r\n\r\n    private static EntityManagerFactory instance = null;\r\n\r\n    private DBEntityManagerFactory() {\r\n    }\r\n\r\n    public synchronized static EntityManagerFactory getInstance() throws DBException {\r\n        if (instance == null) {\r\n            throw new DBException(\"Keine Instanz vorhanden\");\r\n        }\r\n        return instance;\r\n    }\r\n\r\n    public synchronized static void createEntityManagerFactory() {\r\n        if (instance == null) {\r\n            instance = Persistence.createEntityManagerFactory(\"bomberman\");\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/db/DBEntityManagerFactoryTest.java",
		"test_prompt": "// DBEntityManagerFactoryTest.java\npackage db;\n\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DBEntityManagerFactory}.\n* It contains ten unit test cases for the {@link DBEntityManagerFactory#getInstance()} method.\n*/\nclass DBEntityManagerFactoryTest {"
	},
	{
		"original_code": "// DBServiceFactory.java\npackage db;\r\n\r\n/**\r\n * This class returns an instance for bomberman database services.\r\n * The access to the methods for the database services is supplied by this class\r\n *\r\n * @author Daniel Tunjic\r\n */\r\npublic class DBServiceFactory {\r\n\r\n    private static BombermanDBService instance = null;\r\n\r\n    private DBServiceFactory() {\r\n    }\r\n\r\n    public synchronized static BombermanDBService getInstance() {\r\n        if (instance == null) {\r\n            instance = new BombermanDBService();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/db/DBServiceFactoryTest.java",
		"test_prompt": "// DBServiceFactoryTest.java\npackage db;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DBServiceFactory}.\n* It contains ten unit test cases for the {@link DBServiceFactory#getInstance()} method.\n*/\nclass DBServiceFactoryTest {"
	},
	{
		"original_code": "// SoundPlayer.java\n/**\r\n */\r\npackage sound;\r\n\r\n/**\r\n * @author Andi\r\n */\r\npublic class SoundPlayer {\r\n\r\n    private static SoundPlayer instance;\r\n\r\n    private SoundPlayer() {\r\n    }\r\n\r\n    public static SoundPlayer getInstance() {\r\n        if (instance == null) {\r\n            instance = new SoundPlayer();\r\n        }\r\n        return instance;\r\n    }\r\n\r\n    public void intro() {\r\n        play(ISound.INTRO);\r\n    }\r\n\r\n    public void button() {\r\n        play(ISound.BUTTON);\r\n    }\r\n\r\n    public void button2() {\r\n        play(ISound.BUTTON2);\r\n    }\r\n\r\n    public void hintergrund() {\r\n        play(ISound.HINTERGRUND);\r\n    }\r\n\r\n    public void bWerfen() {\r\n        play(ISound.B_WERFEN);\r\n    }\r\n\r\n    public void explosion1() {\r\n        play(ISound.EXPLOSION1);\r\n    }\r\n\r\n    public void explosion2() {\r\n        play(ISound.EXPLOSION1);\r\n    }\r\n\r\n    public void kasse() {\r\n        play(ISound.KASSE);\r\n    }\r\n\r\n    public void powerUp() {\r\n        play(ISound.POWER_UP);\r\n    }\r\n\r\n    public void verliert() {\r\n        play(ISound.VERLIERT);\r\n    }\r\n\r\n    public void gewinnt() {\r\n        play(ISound.GEWINNT);\r\n    }\r\n\r\n    public void outro() {\r\n        play(ISound.OUTRO);\r\n    }\r\n\r\n    public void stirbt() {\r\n        play(ISound.STIRBT);\r\n    }\r\n\r\n    /**\r\n     * @param sound\r\n     */\r\n    private void play(String sound) {\r\n        new Thread(new Sound(sound)).start();\r\n    }\r\n\r\n    /**\r\n     */\r\n    public void ready() {\r\n        play(ISound.READY);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/sound/SoundPlayerTest.java",
		"test_prompt": "// SoundPlayerTest.java\npackage sound;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SoundPlayer}.\n* It contains ten unit test cases for the {@link SoundPlayer#getInstance()} method.\n*/\nclass SoundPlayerTest {"
	},
	{
		"original_code": "// ClientProperties.java\npackage client;\r\n\r\nimport java.io.File;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport org.apache.log4j.Logger;\r\nimport common.Constants;\r\nimport common.XmlFunctions;\r\n\r\n/**\r\n * reads and writes properties to xml-file\r\n * properties file is saved to user directory\r\n *\r\n * @author christian\r\n */\r\npublic class ClientProperties {\r\n\r\n    private XmlFunctions xmlFunctions;\r\n\r\n    // is set to true if file can not be copied or\r\n    // found in user directory\r\n    // if set to true, class is ignoring invocations\r\n    private boolean fileError = false;\r\n\r\n    private static final Logger logger = Logger.getLogger(ClientProperties.class);\r\n\r\n    /**\r\n     * constructor, opens file for reading if exists\r\n     *\r\n     * @param fileName -\r\n     *            Name to xml file\r\n     */\r\n    public ClientProperties(String fileName) {\r\n        CheckPropertiesFile(fileName);\r\n        if (!fileError) {\r\n            xmlFunctions = new XmlFunctions(fileName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * checks if local properties file is present, if not tries to copy empty\r\n     * file to location. If this fails, flag fileError is set to true and read\r\n     * or write access is bypassed\r\n     *\r\n     * @param fileName -\r\n     *            name of file\r\n     */\r\n    private void CheckPropertiesFile(String fileName) {\r\n        // properties file on users file system\r\n        File checkFile = new File(fileName);\r\n        if (!checkFile.exists()) {\r\n            logger.info(\"File fubarman_properties.xml was not found in user directory. Try to copy default file...\");\r\n            InputStream defaultFile = common.ResourceService.getInputStream(Constants.PROPERTIES_DEFAULTFILE);\r\n            if (!fileCopy(defaultFile, checkFile)) {\r\n                logger.error(\"File fubarman_properties.xml could not be copied to user directory. Properties disabled.\");\r\n                this.fileError = true;\r\n            } else {\r\n                logger.info(\"File fubarman_properties.xml was successfully copied to user directory.\");\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * get property value by element-name returns empty string if fileError is\r\n     * true\r\n     *\r\n     * @param element -\r\n     *            Name of element\r\n     * @return String - value\r\n     */\r\n    public String getProperty(String element) {\r\n        if (!fileError) {\r\n            String XmlPath = \"//\" + element;\r\n            return xmlFunctions.getXmlValue(XmlPath);\r\n        } else {\r\n            return new String(\"\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * (over)writes value of specific element\r\n     * does nothing if fileError is true\r\n     *\r\n     * @param element -\r\n     *            Name of element\r\n     * @param value -\r\n     *            new value\r\n     */\r\n    public void setProperty(String element, String value) {\r\n        if (!fileError) {\r\n            String XmlPath = \"//\" + element;\r\n            xmlFunctions.setXmlValue(XmlPath, value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * copies a file from a to b\r\n     * used InputStream as provided from ResourceService class as\r\n     * source and File as destination\r\n     *\r\n     * @param sourceFile -\r\n     *            InputStream - File which should be copied\r\n     * @param destFile -\r\n     *            destination where file should be copied to\r\n     * @return boolean - true if successfully copied, otherwise false\r\n     */\r\n    public static boolean fileCopy(InputStream sourceFile, File destFile) {\r\n        try {\r\n            InputStream in = sourceFile;\r\n            FileOutputStream out = new FileOutputStream(destFile);\r\n            byte[] buf = new byte[4096];\r\n            int len;\r\n            while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\r\n            out.close();\r\n            in.close();\r\n        } catch (IOException e) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/client/ClientPropertiesTest.java",
		"test_prompt": "// ClientPropertiesTest.java\npackage client;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport org.apache.log4j.Logger;\nimport common.Constants;\nimport common.XmlFunctions;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClientProperties}.\n* It contains ten unit test cases for the {@link ClientProperties#fileCopy(InputStream, File)} method.\n*/\nclass ClientPropertiesTest {"
	},
	{
		"original_code": "// ClientPlayer.java\n/**\r\n */\r\npackage client;\r\n\r\nimport java.awt.Point;\r\nimport org.apache.log4j.Logger;\r\nimport sound.SoundPlayer;\r\nimport common.Actor;\r\nimport common.Constants;\r\nimport common.Player;\r\n\r\n/**\r\n * The client specific implemetation of a Player. This implementation will\r\n * notify any number of registered observers about changes to their state.\r\n *\r\n * @author Andi, Bj�rn\r\n */\r\npublic class ClientPlayer extends Player {\r\n\r\n    private boolean bowlBombs = false;\r\n\r\n    private Logger logger = Logger.getLogger(ClientPlayer.class);\r\n\r\n    private int bombsPlanted = 0;\r\n\r\n    private int bombDiameter = Constants.BOMB_DIAMETER;\r\n\r\n    private int maxBombs = Constants.MIN_BOMBS;\r\n\r\n    private long lastPlant;\r\n\r\n    /**\r\n     * Creates a new ClientPlayer that starts on a fixed position.\r\n     *\r\n     * @param position\r\n     *            The starting location for this player.\r\n     */\r\n    public ClientPlayer(Point position, int id) {\r\n        super(position);\r\n        this.id = id;\r\n    }\r\n\r\n    /*\r\n\t * (non-Javadoc)\r\n\t * \r\n\t * @see common.Actor#preUpdate()\r\n\t */\r\n    @Override\r\n    protected void preUpdate() {\r\n        // if (!moveVector.equals(previousMoveVector)) {\r\n        setChanged();\r\n        // }\r\n    }\r\n\r\n    /**\r\n     * Plants a bomb on the battlefield. The bomb will be located at the current\r\n     * position. If the user can bowl bombs the bomb get a moveVector. This will\r\n     * trigger a notification for the observers.\r\n     */\r\n    public void plantBomb() {\r\n        long time = System.currentTimeMillis();\r\n        if ((bombsPlanted >= maxBombs) || (time - lastPlant < 100)) {\r\n            return;\r\n        }\r\n        lastPlant = time;\r\n        setChanged();\r\n        Point posClone = (Point) getPosition().clone();\r\n        ClientBomb bomb = new ClientBomb(posClone, this);\r\n        bomb.setId(BomberClient.getInstance().getNextId());\r\n        bomb.setDiameter(bombDiameter);\r\n        bomb.setRemote(false);\r\n        Point moveVec = new Point(0, 0);\r\n        if (bowlBombs) {\r\n            bomb.setStopped(false);\r\n            if (getDirection() == 1) {\r\n                moveVec.y = -Actor.MOVE_DELTA * speed;\r\n            } else if (getDirection() == 2) {\r\n                moveVec.y = Actor.MOVE_DELTA * speed;\r\n            } else if (getDirection() == 3) {\r\n                moveVec.x = -Actor.MOVE_DELTA * speed;\r\n            } else if (getDirection() == 4) {\r\n                moveVec.x = Actor.MOVE_DELTA * speed;\r\n            }\r\n        } else {\r\n            bomb.setStopped(true);\r\n        }\r\n        bomb.setMoveVector(moveVec);\r\n        bombsThatSpawnedOnMe.add(bomb);\r\n        notifyObservers(bomb);\r\n        SoundPlayer.getInstance().bWerfen();\r\n        /*\r\n\t\t * This needs synchronization to prevent lost updates. A lost update\r\n\t\t * could occur when another thread changes the bombsPlanted variable\r\n\t\t * between the read/write operation of the increment.\r\n\t\t */\r\n        synchronized (this) {\r\n            bombsPlanted = bombsPlanted + 1;\r\n        }\r\n    }\r\n\r\n    /*\r\n\t * (non-Javadoc)\r\n\t * \r\n\t * @see common.Player#die()\r\n\t */\r\n    @Override\r\n    public void die() {\r\n        super.die();\r\n        SoundPlayer.getInstance().stirbt();\r\n        logger.info(\"#\" + getId() + \" died\");\r\n    }\r\n\r\n    /**\r\n     * Increases the maximum number of bombs this player can plant by one. If\r\n     * the player can already plant MAX_BOMDS bombs, this method will do\r\n     * nothing.\r\n     */\r\n    public void increaseMaxBombs() {\r\n        if (maxBombs < Constants.MAX_BOMBS) {\r\n            maxBombs = maxBombs + 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets the maximum number of bombs this player can plant by one.\r\n     */\r\n    public void resetMaxBombs() {\r\n        maxBombs = Constants.MIN_BOMBS;\r\n    }\r\n\r\n    /**\r\n     * Notifies this player that a previously planted bomb has exploded. This\r\n     * will decrease the count of currently planted bombs.\r\n     */\r\n    public void plantedBombExploded() {\r\n        /*\r\n\t\t * This needs synchronization to prevent lost updates. A lost update\r\n\t\t * could occur when another thread changes the bombsPlanted variable\r\n\t\t * between the read/write operation of the decrement.\r\n\t\t */\r\n        synchronized (this) {\r\n            bombsPlanted = bombsPlanted - 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Increases the diameter of the bomb, that this player can plant.\r\n     */\r\n    public void increaseBombDiameter() {\r\n        bombDiameter += 2;\r\n    }\r\n\r\n    /**\r\n     * Resets the diameter of the bomb, that this player can plant.\r\n     */\r\n    public void resetBombDiameter() {\r\n        bombDiameter = Constants.BOMB_DIAMETER;\r\n    }\r\n\r\n    /**\r\n     * Sets, that player can bowl bombs\r\n     */\r\n    public void setBowlBombs() {\r\n        bowlBombs = true;\r\n    }\r\n\r\n    /**\r\n     * Sets, that player can't bowl bombs\r\n     */\r\n    public void resetBowlBombs() {\r\n        bowlBombs = false;\r\n    }\r\n\r\n    /**\r\n     * Returns weather the player can bowl bombs\r\n     *\r\n     * @return boolean can bowl bombs\r\n     */\r\n    public boolean canBowlBombs() {\r\n        return bowlBombs;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/client/ClientPlayerTest.java",
		"test_prompt": "// ClientPlayerTest.java\npackage client;\n\nimport java.awt.Point;\nimport org.apache.log4j.Logger;\nimport sound.SoundPlayer;\nimport common.Actor;\nimport common.Constants;\nimport common.Player;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClientPlayer}.\n* It contains ten unit test cases for the {@link ClientPlayer#canBowlBombs()} method.\n*/\nclass ClientPlayerTest {"
	},
	{
		"original_code": "// StartFrame.java\npackage client.gui;\r\n\r\nimport java.awt.Component;\r\nimport java.awt.Cursor;\r\nimport java.awt.Dimension;\r\nimport java.awt.DisplayMode;\r\nimport java.awt.GraphicsConfiguration;\r\nimport java.awt.GraphicsDevice;\r\nimport java.awt.GraphicsEnvironment;\r\nimport java.awt.Image;\r\nimport java.awt.Point;\r\nimport java.awt.Rectangle;\r\nimport java.awt.event.ActionEvent;\r\nimport java.awt.event.ActionListener;\r\nimport java.awt.event.ComponentEvent;\r\nimport java.awt.event.ComponentListener;\r\nimport java.awt.event.KeyEvent;\r\nimport java.awt.event.KeyListener;\r\nimport java.awt.event.WindowEvent;\r\nimport java.awt.event.WindowFocusListener;\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.Vector;\r\nimport javax.swing.ImageIcon;\r\nimport javax.swing.JButton;\r\nimport javax.swing.JComboBox;\r\nimport javax.swing.JFrame;\r\nimport javax.swing.JLabel;\r\nimport javax.swing.JTextField;\r\nimport messages.global.MapInfo;\r\nimport messages.global.SessionDetailsMsg;\r\nimport org.apache.log4j.Logger;\r\nimport sound.SoundPlayer;\r\nimport client.BomberClient;\r\nimport client.gui.components.MyPanel;\r\nimport client.view.GameCanvas;\r\nimport db.DBGameUser;\r\n\r\npublic class StartFrame extends JFrame implements KeyListener, ComponentListener, WindowFocusListener {\r\n\r\n    private static final Logger logger = Logger.getLogger(StartFrame.class);\r\n\r\n    /**\r\n     * @param args\r\n     */\r\n    /**\r\n     * for fullscreen mode\r\n     */\r\n    private static String fullscreen = \" \";\r\n\r\n    private Component actualPanel;\r\n\r\n    MyPanel jPanelFirst = new MyPanel();\r\n\r\n    MyPanel jPanelSelectGame = new MyPanel();\r\n\r\n    public ServerSelectionDialog jPanelSelectServer = new ServerSelectionDialog();\r\n\r\n    MyPanel jPanelConfig = new MyPanel();\r\n\r\n    MyPanel jPanelJoinGame = new MyPanel();\r\n\r\n    Game jPanelGame = new Game();\r\n\r\n    // TODO\r\n    GameCanvas gameCanvas = jPanelGame.gameCanvas;\r\n\r\n    // GameCanvas gameCanvas = new GameCanvas(800, 600);\r\n    GlobalLobby jPanelGlobalLobby = new GlobalLobby();\r\n\r\n    CreateGameDialog jPanelNewGame = new CreateGameDialog();\r\n\r\n    LoginDialog jPanelLogin = LoginDialog.init();\r\n\r\n    SessionLobby jPanelWaitForGame = new SessionLobby();\r\n\r\n    public HighscoreLobby jPanelHighscoreLobby = new HighscoreLobby();\r\n\r\n    GlobalHighscoreLobby jPanelGlobalHighscoreLobby = new GlobalHighscoreLobby();\r\n\r\n    JButton jButtonSelectServer = new JButton(\"SelectServer\");\r\n\r\n    JButton jButtonConfig = new JButton(\"Config\");\r\n\r\n    // JButton jButtonSelectServer\r\n    JTextField jTextFieldSelectedServerIP = new JTextField();\r\n\r\n    JTextField jTextFieldSelectedServerName = new JTextField();\r\n\r\n    JComboBox jComboBoxSelectedServerLoad = new JComboBox();\r\n\r\n    JButton jButtonSelectedServerLoad = new JButton(\"Load\");\r\n\r\n    JButton jButtonSelectedServerStore = new JButton(\"Store\");\r\n\r\n    JButton jButtonSelectedServerCancel = new JButton(\"Cancel\");\r\n\r\n    JButton jButtonSelectedServerOkay = new JButton(\"Okay\");\r\n\r\n    JButton jButtonSelectedServerConfig = new JButton(\"Config\");\r\n\r\n    JTextField jTextFieldLoginUsername = new JTextField();\r\n\r\n    JTextField jTextFieldLoginPassword = new JTextField();\r\n\r\n    JButton jButtonLoginCancel = new JButton(\"Cancel\");\r\n\r\n    JButton jButtonLoginLogin = new JButton(\"Login\");\r\n\r\n    public static StartFrame startFrame = null;\r\n\r\n    ActionListenerChangePanel actionListenerChangePanel = new ActionListenerChangePanel();\r\n\r\n    // TODO\r\n    Cash myCash = new Cash();\r\n\r\n    public static void main(String[] args) {\r\n        if (args.length > 0) {\r\n            fullscreen = args[0];\r\n        }\r\n        System.out.println(fullscreen);\r\n        SplashThread splash = new SplashThread();\r\n        SoundPlayer.getInstance().intro();\r\n        splash.start();\r\n        startFrame = new StartFrame();\r\n        startFrame.setActualPanel(startFrame.jPanelSelectServer);\r\n        splash.setRun(false);\r\n        synchronized (splash) {\r\n            splash.notify();\r\n        }\r\n        // SoundPlayer.getInstance().hintergrund();\r\n    }\r\n\r\n    public static StartFrame getInstance() {\r\n        if (startFrame == null) {\r\n            startFrame = new StartFrame();\r\n        }\r\n        return startFrame;\r\n    }\r\n\r\n    private StartFrame() {\r\n        super(\"Fubarman\");\r\n        startFrame = this;\r\n        initFrame();\r\n        this.setDefaultCloseOperation(EXIT_ON_CLOSE);\r\n    }\r\n\r\n    /*\r\n\t * Spiel in Fullscreen @Ghazwan\r\n\t * \r\n\t * \r\n\t */\r\n    int width = 0;\r\n\r\n    int height = 0;\r\n\r\n    private Cursor theCursor;\r\n\r\n    public void setFullScreen() {\r\n        /*\r\n\t\t * Rectangle virtualBounds = new Rectangle(); GraphicsDevice GDEVICE =\r\n\t\t * GraphicsEnvironment.getLocalGraphicsEnvironment()\r\n\t\t * .getDefaultScreenDevice(); GraphicsConfiguration[] gc =\r\n\t\t * GDEVICE.getConfigurations();\r\n\t\t * \r\n\t\t * setResizable(false); setUndecorated(true); virtualBounds =\r\n\t\t * virtualBounds.union(gc[0].getBounds()); width = virtualBounds.width;\r\n\t\t * height = virtualBounds.height; setVisible(true);\r\n\t\t * GDEVICE.setFullScreenWindow(this);\r\n\t\t */\r\n        setUndecorated(true);\r\n        GraphicsDevice device = GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice();\r\n        // setSize(800, 600);\r\n        // setVisible(true);\r\n        // setResizable(false);\r\n        device.setFullScreenWindow(this);\r\n        if (device.isDisplayChangeSupported()) {\r\n            DisplayMode dm = new DisplayMode(800, 600, 32, DisplayMode.REFRESH_RATE_UNKNOWN);\r\n            device.setDisplayMode(dm);\r\n        }\r\n        // device.setDisplayMode(new DisplayMode(800 , 600, 16, 85));\r\n    }\r\n\r\n    // private JFrame hackFrame;\r\n    public void initFrame() {\r\n        // Add the bomb as cursor\r\n        // Image i = ResourceService.getImage(\"/images/mousecursor.png\");\r\n        // Cursor c = getToolkit().createCustomCursor(i, new Point(10, 10),\r\n        // \"CUSTOM_CURSOR\");\r\n        // setCursor(c);\r\n        // Calculate the Size of the screen for fullscreen\r\n        Rectangle virtualBounds = new Rectangle();\r\n        GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();\r\n        GraphicsDevice[] gs = ge.getScreenDevices();\r\n        this.addKeyListener(this);\r\n        try {\r\n            GraphicsDevice gd = gs[0];\r\n            // System.out.println(\"GraphicsConfig:\r\n            GraphicsConfiguration[] gc = gd.getConfigurations();\r\n            // \" +\r\n            gd.getConfigurations();\r\n            virtualBounds = virtualBounds.union(gc[0].getBounds());\r\n            width = virtualBounds.width;\r\n            height = virtualBounds.height;\r\n        } catch (Exception e) {\r\n        }\r\n        Dimension dimm = new Dimension(width, height);\r\n        startFrame.setSize(dimm);\r\n        // startFrame.setResizable(false);\r\n        // startFrame.setUndecorated(true);\r\n        startFrame.getContentPane().setLayout(null);\r\n        // startFrame.setForeground(new Color(255,255,255));\r\n        // JButton but = new JButton(\"Test\");\r\n        // getContentPane().add (but);\r\n        if (fullscreen.equals(\"-fullscreen\")) {\r\n            logger.info(\"Changing to fullscreen mode\");\r\n            setFullScreen();\r\n        } else {\r\n            setMiddel(jPanelSelectServer);\r\n            setMiddel(jPanelLogin);\r\n            setMiddel(jPanelGame);\r\n            setMiddel(jPanelGlobalLobby);\r\n            setMiddel(jPanelHighscoreLobby);\r\n            setMiddel(jPanelWaitForGame);\r\n            setMiddel(jPanelNewGame);\r\n            setMiddel(jPanelGlobalHighscoreLobby);\r\n        }\r\n        getContentPane().add(jPanelSelectServer);\r\n        actualPanel = jPanelSelectServer;\r\n        initjPanelConfig();\r\n        //\t\tinitjPanelLogin();\r\n        //\t\tgetContentPane().add(jPanelGlobalLobby);\r\n        //\t\tgetContentPane().add(jPanelLogin);\r\n        //\t\tgetContentPane().add(jPanelNewGame);\r\n        //\t\tgetContentPane().add(jPanelGame);\r\n        //\t\tgetContentPane().add(jPanelWaitForGame);\r\n        //\t\tgetContentPane().add(jPanelHighscoreLobby);\r\n        //\t\tgetContentPane().add(jPanelGlobalHighscoreLobby);\r\n        //\t\tgetContentPane().add(jPanelLogin);\r\n        //\t\tjPanelGlobalLobby.setVisible(false);\r\n        //\t\tjPanelLogin.setVisible(false);\r\n        //\t\tjPanelNewGame.setVisible(false);\r\n        //\t\tjPanelGame.setVisible(false);\r\n        //\t\tjPanelWaitForGame.setVisible(false);\r\n        //\t\tjPanelHighscoreLobby.setVisible(false);\r\n        //\t\tjPanelGlobalHighscoreLobby.setVisible(false);\r\n        //\t\tjPanelLogin.setVisible(false);\r\n        jButtonSelectServer.addActionListener(actionListenerChangePanel);\r\n        jButtonConfig.addActionListener(actionListenerChangePanel);\r\n        jButtonSelectedServerOkay.addActionListener(actionListenerChangePanel);\r\n        jButtonSelectedServerConfig.addActionListener(actionListenerChangePanel);\r\n        // getContentPane().add(myCash);\r\n        // gameCanvas.getCanvas().setBackground(Color.white);\r\n        // changePanel(gameCanvas);\r\n        // this.setResizable(false);\r\n        // startFrame.getContentPane().setBackground(new Color(0, 0, 0));\r\n        // but.requestFocus();\r\n        startFrame.addKeyListener(this);\r\n    }\r\n\r\n    private void setMiddel(MyPanel panel) {\r\n        int pwidth = (int) panel.getBounds().getWidth();\r\n        int pheight = (int) panel.getBounds().getHeight();\r\n        int offsetX = (width / 2) - (pwidth / 2);\r\n        int offsetY = (height / 2) - (pheight / 2);\r\n        panel.setBounds(offsetX, offsetY, pwidth, pheight);\r\n    }\r\n\r\n    private void initjPanelConfig() {\r\n        jPanelConfig.setSize(new Dimension(800, 600));\r\n        jPanelConfig.add(new JLabel(\"Config\"));\r\n    }\r\n\r\n    public class ActionListenerChangePanel implements ActionListener {\r\n\r\n        public void actionPerformed(ActionEvent evt) {\r\n            jPanelFirst.setVisible(false);\r\n            jPanelSelectServer.setVisible(false);\r\n            jPanelConfig.setVisible(false);\r\n            // startFrame.removeAll();\r\n            if (evt.getSource().equals(jButtonSelectServer)) {\r\n                // System.out.println(\"SelectServer\");\r\n                jPanelSelectServer.setVisible(true);\r\n            } else if (evt.getSource().equals(jButtonConfig)) {\r\n                // System.out.println(\"Config\");\r\n                jPanelConfig.setVisible(true);\r\n            }\r\n            // else if (evt.getSource().equals(jButtonSelectedServerConfig)) {\r\n            // System.out.println(\"Config\");\r\n            // jPanelConfig.setVisible(true);\r\n            //\r\n            // }else if (evt.getSource().equals(jButtonSelectedServerOkay)) {\r\n            // System.out.println(\"Config\");\r\n            // jPanelLogin.setVisible(true);\r\n            //\r\n            // }\r\n        }\r\n    }\r\n\r\n    public GlobalLobby getJPanelGlobalLobby() {\r\n        return jPanelGlobalLobby;\r\n    }\r\n\r\n    public void changePanel(Component panel) {\r\n        getContentPane().remove(actualPanel);\r\n        panel.setVisible(false);\r\n        getContentPane().add(panel);\r\n        panel.setVisible(true);\r\n        actualPanel = panel;\r\n        //\t\tjPanelFirst.setVisible(false);\r\n        //\t\tjPanelSelectServer.setVisible(false);\r\n        //\t\tjPanelConfig.setVisible(false);\r\n        //\t\tjPanelGlobalLobby.setVisible(false);\r\n        //\t\tjPanelNewGame.setVisible(false);\r\n        //\t\tjPanelWaitForGame.setVisible(false);\r\n        //\t\tjPanelGame.setVisible(false);\r\n        //\t\tjPanelLogin.setVisible(false);\r\n        //\t\tjPanelHighscoreLobby.setVisible(false);\r\n        //\t\tjPanelGlobalHighscoreLobby.setVisible(false);\r\n    }\r\n\r\n    public void keyPressed(KeyEvent evt) {\r\n        System.out.println(\"Key pressed\");\r\n        if (evt.getKeyCode() == KeyEvent.VK_ESCAPE) {\r\n            System.out.println(\"Escape pressedS\");\r\n            System.out.println(evt.getKeyCode());\r\n        }\r\n    }\r\n\r\n    /*\r\n\t * Sollte das gesamte Spiel beenden durch \"Esc\" funktioniert aber noch\r\n\t * nicht!\r\n\t * \r\n\t * @see java.awt.event.KeyListener#keyReleased(java.awt.event.KeyEvent)\r\n\t */\r\n    public void keyReleased(KeyEvent evt) {\r\n        if (evt.getKeyCode() == KeyEvent.VK_ESCAPE) {\r\n            // System.out.println(\"Exit\");\r\n            System.exit(0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * wird nicht verwendet\r\n     */\r\n    public void keyTyped(KeyEvent arg0) {\r\n    }\r\n\r\n    /**\r\n     * liefert die GameCanvas\r\n     *\r\n     * @return\r\n     */\r\n    public GameCanvas getGameCanvas() {\r\n        return gameCanvas;\r\n    }\r\n\r\n    /**\r\n     * Das GameCanvas wird auf dem Bilschirm angezeigt\r\n     */\r\n    public void showGameCanvas() {\r\n        logger.debug(\"Showing GameCanvas, isVisible: \" + gameCanvas.isVisible());\r\n        // gameCanvas.getCanvas().setBackground(Color.white);\r\n        changePanel(jPanelGame);\r\n        theCursor = getCursor();\r\n        // Add the bomb as cursor\r\n        Image i = new ImageIcon(\"\").getImage();\r\n        Cursor c = getToolkit().createCustomCursor(i, new Point(10, 10), \"CUSTOM_CURSOR\");\r\n        setCursor(c);\r\n        jPanelGame.gameCanvas.requestFocus();\r\n    }\r\n\r\n    /**\r\n     * Game wird vom Bildschirm genommen und der Screen \"Join_New_Game\" zur\r\n     * auswahl eines Spieles oder erstellen eines neuen Spieles\r\n     */\r\n    // TODO\r\n    public void showHighscoreLobby() {\r\n        jPanelHighscoreLobby.jButtonNextRound.setVisible(true);\r\n        jPanelHighscoreLobby.repaint();\r\n        this.changePanel(jPanelHighscoreLobby);\r\n        // // Add the bomb as cursor\r\n        // Image i = ResourceService.getImage(\"/images/mousecursor.png\");\r\n        // Cursor c = getToolkit().createCustomCursor(i, new Point(10, 10),\r\n        // \"CUSTOM_CURSOR\");\r\n        setCursor(theCursor);\r\n    }\r\n\r\n    public void updateRoundScoreData(HashMap<String, Integer> rndscore) {\r\n        jPanelHighscoreLobby.setTable(rndscore);\r\n    }\r\n\r\n    public void updateSessionScoreData(HashMap<String, Integer> rndscore) {\r\n        jPanelHighscoreLobby.setSessionTable(rndscore);\r\n    }\r\n\r\n    public void removeHighScoreData() {\r\n        jPanelHighscoreLobby.removeTable();\r\n    }\r\n\r\n    public void removeSessionHighScoreData() {\r\n        jPanelHighscoreLobby.removeSessionTable();\r\n    }\r\n\r\n    public void setAvailableMaps(Vector<MapInfo> maps) {\r\n        jPanelNewGame.jListMap.setListData(maps);\r\n        jPanelNewGame.jListMap.requestFocus();\r\n    }\r\n\r\n    public void setAvailableSessions(Vector<SessionDetailsMsg> sessions) {\r\n        jPanelGlobalLobby.jListGames.setListData(sessions);\r\n    }\r\n\r\n    /**\r\n     * @param sender\r\n     * @param msg\r\n     */\r\n    public void addChatMessageSession(String sender, String msg) {\r\n        if (jPanelWaitForGame.isVisible()) {\r\n            jPanelWaitForGame.getChat().addChatMessage(sender, msg);\r\n        } else {\r\n            jPanelHighscoreLobby.chat.addChatMessage(sender, msg);\r\n        }\r\n    }\r\n\r\n    /**\r\n     */\r\n    public void removeChatMessageSession() {\r\n        jPanelWaitForGame.getChat().clearChat();\r\n        jPanelHighscoreLobby.chat.clearChat();\r\n    }\r\n\r\n    public void addChatMessageGlobal(String sender, String msg) {\r\n        getJPanelGlobalLobby().getChat().addChatMessage(sender, msg);\r\n        // jPanelHighscoreLobby.chat.addChatMessage(sender, msg);\r\n    }\r\n\r\n    public void showGlobalLobby() {\r\n        BomberClient.getInstance().requestSessionList();\r\n        jPanelGlobalLobby.hideInfos();\r\n        jPanelGlobalLobby.jListGames.setSelectedIndex(-1);\r\n        changePanel(jPanelGlobalLobby);\r\n        // Image i = ResourceService.getImage(\"/images/mousecursor.png\");\r\n        // Cursor c = getToolkit().createCustomCursor(i, new Point(10, 10),\r\n        // \"CUSTOM_CURSOR\");\r\n        if (theCursor != null)\r\n            setCursor(theCursor);\r\n    }\r\n\r\n    public void setGlobalScore(ArrayList<DBGameUser> list) {\r\n        jPanelGlobalHighscoreLobby.fillScore(list);\r\n    }\r\n\r\n    public void logout() {\r\n        StartFrame.getInstance().changePanel(StartFrame.getInstance().jPanelSelectServer);\r\n        BomberClient.getInstance().closeConnection();\r\n    }\r\n\r\n    public SessionLobby getSessionLobby() {\r\n        return jPanelWaitForGame;\r\n    }\r\n\r\n    public void windowGainedFocus(WindowEvent e) {\r\n        repaint();\r\n    }\r\n\r\n    public void windowLostFocus(WindowEvent e) {\r\n        repaint();\r\n    }\r\n\r\n    public void componentHidden(ComponentEvent e) {\r\n        repaint();\r\n    }\r\n\r\n    public void componentMoved(ComponentEvent e) {\r\n        repaint();\r\n    }\r\n\r\n    public void componentResized(ComponentEvent e) {\r\n        repaint();\r\n    }\r\n\r\n    public void componentShown(ComponentEvent e) {\r\n        repaint();\r\n    }\r\n\r\n    /**\r\n     */\r\n    public void showNewGamePanel() {\r\n        changePanel(jPanelNewGame);\r\n    }\r\n\r\n    /**\r\n     */\r\n    public void showSessionLobby() {\r\n        changePanel(jPanelWaitForGame);\r\n        StartFrame.getInstance().jPanelWaitForGame.updateInfo();\r\n    }\r\n\r\n    public Component getActualPanel() {\r\n        return actualPanel;\r\n    }\r\n\r\n    public void setActualPanel(Component actualPanel) {\r\n        this.actualPanel = actualPanel;\r\n    }\r\n\r\n    public void setCursorWait() {\r\n        setCursor(new Cursor(Cursor.WAIT_CURSOR));\r\n    }\r\n\r\n    public void setCursorNormal() {\r\n        setCursor(theCursor);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/client/gui/StartFrameTest.java",
		"test_prompt": "// StartFrameTest.java\npackage client.gui;\n\nimport java.awt.Component;\nimport java.awt.Cursor;\nimport java.awt.Dimension;\nimport java.awt.DisplayMode;\nimport java.awt.GraphicsConfiguration;\nimport java.awt.GraphicsDevice;\nimport java.awt.GraphicsEnvironment;\nimport java.awt.Image;\nimport java.awt.Point;\nimport java.awt.Rectangle;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.ComponentEvent;\nimport java.awt.event.ComponentListener;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\nimport java.awt.event.WindowEvent;\nimport java.awt.event.WindowFocusListener;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport javax.swing.JButton;\nimport javax.swing.JComboBox;\nimport javax.swing.JFrame;\nimport javax.swing.JLabel;\nimport javax.swing.JTextField;\nimport messages.global.MapInfo;\nimport messages.global.SessionDetailsMsg;\nimport org.apache.log4j.Logger;\nimport sound.SoundPlayer;\nimport client.BomberClient;\nimport client.gui.components.MyPanel;\nimport client.view.GameCanvas;\nimport db.DBGameUser;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StartFrame}.\n* It contains ten unit test cases for the {@link StartFrame#getInstance()} method.\n*/\nclass StartFrameTest {"
	},
	{
		"original_code": "// LoginDialog.java\npackage client.gui;\n\nimport java.awt.Color;\nimport java.awt.Cursor;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseListener;\nimport javax.swing.JLabel;\nimport javax.swing.JPasswordField;\nimport javax.swing.JTextField;\nimport common.Constants;\nimport messages.global.LoginMsg;\nimport client.BomberClient;\nimport client.ClientProperties;\nimport client.gui.components.MyButton;\nimport client.gui.components.MyPanel;\n\npublic class LoginDialog extends MyPanel implements KeyListener, MouseListener, ActionListener {\n\n    MyPanel jPanelRegUser = new MyPanel();\n\n    MyPanel jPanelGuestUser = new MyPanel();\n\n    MyPanel jPanelNewAccount = new MyPanel();\n\n    JLabel jLabelRegUser = new JLabel(\"User: \");\n\n    JLabel jLabelRegPassword = new JLabel(\"Password: \");\n\n    JLabel jLabelGuestUser = new JLabel(\"User: \");\n\n    JLabel jLabelNewUser = new JLabel(\"User: \");\n\n    JLabel jLabelNewPassword_01 = new JLabel(\"new Password: \");\n\n    JLabel jLabelNewPassword_02 = new JLabel(\"retype Password: \");\n\n    JLabel jLabelMessage = new JLabel(\" \");\n\n    JTextField jTextFieldGuestUser = new JTextField(\"\");\n\n    JPasswordField jTextFieldGuestPassword = new JPasswordField(\"\");\n\n    JTextField jTextFieldRegUser = new JTextField(\"\");\n\n    JPasswordField jTextFieldRegPassword = new JPasswordField(\"\");\n\n    JTextField jTextFieldNewUser = new JTextField(\"\");\n\n    JPasswordField jTextFieldNewPassword_01 = new JPasswordField(\"\");\n\n    JPasswordField jTextFieldNewPassword_02 = new JPasswordField(\"\");\n\n    MyButton jButtonLogin = new MyButton(\"Login\");\n\n    MyButton jButtonBack = new MyButton(\"Back\");\n\n    MyButton jButtonGast = new MyButton(\"Login\");\n\n    MyButton jButtonNewAccount = new MyButton(\"New Account\");\n\n    MyButton jButtonCreate = new MyButton(\"Create\");\n\n    MyButton jButtonReturn = new MyButton(\"Back\");\n\n    String userName;\n\n    String userType;\n\n    ClientProperties clientProperties;\n\n    public static LoginDialog loginDialog;\n\n    public static LoginDialog init() {\n        if (loginDialog == null) {\n            loginDialog = new LoginDialog();\n        }\n        return loginDialog;\n    }\n\n    private LoginDialog() {\n        setLayout(null);\n        setSize(800, 600);\n        //setBackground(new Color(255, 150, 255));\n        // check properties in properties.xml\n        clientProperties = new ClientProperties(Constants.PROPERTIES_FILE);\n        userName = clientProperties.getProperty(\"nickname\");\n        if (!userName.isEmpty()) {\n            userType = clientProperties.getProperty(\"usertype\");\n            if (userType.equals(\"guest\")) {\n                jTextFieldGuestUser.setText(userName);\n            } else {\n                jTextFieldRegUser.setText(userName);\n                jTextFieldRegPassword.setText(clientProperties.getProperty(\"password\"));\n            }\n            super.repaint();\n        }\n        //jPanelRegUser.setBackground(Color.cyan);\n        //jPanelGuestUser.setBackground(Color.blue);\n        jPanelGuestUser.setBounds(150, 215, 500, 60);\n        jPanelRegUser.setBounds(150, 285, 500, 150);\n        jPanelNewAccount.setBounds(150, 225, 500, 150);\n        jLabelMessage.setBounds(150, 150, 500, 50);\n        jPanelRegUser.setLayout(null);\n        jPanelGuestUser.setLayout(null);\n        jPanelNewAccount.setLayout(null);\n        // TODO Kay\n        jPanelRegUser.setPicture(\"/images/simple_background.png\");\n        jPanelGuestUser.setPicture(\"/images/simple_background.png\");\n        jPanelNewAccount.setPicture(\"/images/simple_background.png\");\n        jPanelRegUser.setTitel(\"Registered User\");\n        jPanelGuestUser.setTitel(\"Guest\");\n        jPanelNewAccount.setTitel(\"New Account\");\n        add(jPanelRegUser);\n        add(jPanelGuestUser);\n        add(jPanelNewAccount);\n        jPanelNewAccount.setVisible(false);\n        jLabelMessage.setVisible(true);\n        addLabel(jLabelMessage);\n        //\t\taddLabel(jLabelTest);\n        jButtonLogin.addActionListener(this);\n        jButtonGast.addActionListener(this);\n        jButtonNewAccount.addActionListener(this);\n        jButtonCreate.addActionListener(this);\n        jButtonReturn.addActionListener(this);\n        jButtonBack.addActionListener(this);\n        jTextFieldRegPassword.addKeyListener(this);\n        jTextFieldGuestUser.addKeyListener(this);\n        // Guestpanel init:\n        jLabelGuestUser.setBounds(20, 20, 70, 25);\n        jTextFieldGuestUser.setBounds(90, 20, 250, 25);\n        jButtonGast.setBounds(350, 20, 120, 25);\n        jButtonBack.setBounds(20, 100, 120, 25);\n        jPanelGuestUser.add(jButtonGast);\n        jPanelGuestUser.addLabel(jLabelGuestUser);\n        jPanelGuestUser.add(jTextFieldGuestUser);\n        // LoginPanel init:\n        jLabelRegUser.setBounds(20, 20, 100, 25);\n        jLabelRegPassword.setBounds(20, 55, 70, 25);\n        jTextFieldRegUser.setBounds(90, 20, 250, 25);\n        jTextFieldRegPassword.setBounds(90, 55, 250, 25);\n        jButtonLogin.setBounds(350, 55, 120, 25);\n        jButtonNewAccount.setBounds(350, 20, 120, 25);\n        jPanelRegUser.add(jButtonLogin);\n        jPanelRegUser.add(jButtonBack);\n        jPanelRegUser.add(jButtonNewAccount);\n        jPanelRegUser.addLabel(jLabelRegPassword);\n        jPanelRegUser.addLabel(jLabelRegUser);\n        jPanelRegUser.add(jTextFieldRegPassword);\n        jPanelRegUser.add(jTextFieldRegUser);\n        // new Accout init:\n        jLabelNewUser.setBounds(20, 20, 120, 25);\n        jLabelNewPassword_01.setBounds(20, 55, 120, 25);\n        jLabelNewPassword_02.setBounds(20, 90, 120, 25);\n        jTextFieldNewUser.setBounds(150, 20, 220, 25);\n        jTextFieldNewPassword_01.setBounds(150, 55, 220, 25);\n        jTextFieldNewPassword_02.setBounds(150, 90, 220, 25);\n        jButtonCreate.setBounds(390, 90, 100, 25);\n        jButtonReturn.setBounds(390, 20, 100, 25);\n        jPanelNewAccount.addLabel(jLabelNewUser);\n        jPanelNewAccount.addLabel(jLabelNewPassword_01);\n        jPanelNewAccount.addLabel(jLabelNewPassword_02);\n        jPanelNewAccount.add(jTextFieldNewPassword_01);\n        jPanelNewAccount.add(jTextFieldNewPassword_02);\n        jPanelNewAccount.add(jTextFieldNewUser);\n        jPanelNewAccount.add(jButtonCreate);\n        jPanelNewAccount.add(jButtonReturn);\n    }\n\n    /**\n     * ActionListener fuer <br>\n     * jButtonLogin<br>\n     * jButtonGast<br>\n     * jButtonNewAccount<br>\n     * <br>\n     * Es wird geprueft ob alle notwendigen Felder ausgefuellt sind.<br>\n     * Anschliessend wird die entsprechende Session gestartet.\n     */\n    public void actionPerformed(ActionEvent evt) {\n        jLabelGuestUser.setForeground(Color.BLACK);\n        jLabelRegUser.setForeground(Color.BLACK);\n        jLabelRegPassword.setForeground(Color.BLACK);\n        jLabelNewPassword_01.setForeground(Color.black);\n        jLabelNewPassword_02.setForeground(Color.black);\n        jLabelNewUser.setForeground(Color.black);\n        jLabelMessage.setText(\"\");\n        String s = \"\";\n        if (evt.getSource().equals(jButtonLogin)) {\n            if (jTextFieldRegUser.getText().equals(\"\")) {\n                s += \"<br>- Username\";\n                jLabelRegUser.setForeground(Color.red);\n            }\n            if (jTextFieldRegPassword.getText().equals(\"\")) {\n                s += \"<br>- Password\";\n                jLabelRegPassword.setForeground(Color.red);\n            }\n            if (!s.equals(\"\")) {\n                jLabelMessage.setText(\"<Html>The following things are requried:\" + s + \"\");\n            } else {\n                clientProperties = new ClientProperties(Constants.PROPERTIES_FILE);\n                clientProperties.setProperty(\"nickname\", jTextFieldRegUser.getText());\n                clientProperties.setProperty(\"usertype\", \"registered\");\n                if (Integer.parseInt(clientProperties.getProperty(\"savepwd\")) == 1) {\n                    clientProperties.setProperty(\"password\", jTextFieldRegPassword.getText());\n                } else {\n                    clientProperties.setProperty(\"password\", \"\");\n                }\n                loginSession(jTextFieldRegUser.getText(), jTextFieldRegPassword.getText());\n                StartFrame.getInstance().setCursorWait();\n            }\n        } else if (evt.getSource().equals(jButtonGast)) {\n            if (jTextFieldGuestUser.getText().equals(\"\")) {\n                jLabelMessage.setText(\"You need a username to play as guest!\");\n                jLabelGuestUser.setForeground(Color.red);\n            } else {\n                clientProperties = new ClientProperties(Constants.PROPERTIES_FILE);\n                clientProperties.setProperty(\"nickname\", jTextFieldGuestUser.getText());\n                clientProperties.setProperty(\"usertype\", \"guest\");\n                clientProperties.setProperty(\"password\", \"\");\n                guestSession(jTextFieldGuestUser.getText());\n                StartFrame.getInstance().setCursorWait();\n            }\n        } else if (evt.getSource().equals(jButtonNewAccount)) {\n            jPanelRegUser.setVisible(false);\n            jPanelGuestUser.setVisible(false);\n            jPanelNewAccount.setVisible(true);\n        } else if (evt.getSource().equals(jButtonCreate)) {\n            //System.out.println(\"Create\");\n            if (jTextFieldNewUser.getText().equals(\"\")) {\n                s += \"<br>- Username\";\n                jLabelNewUser.setForeground(Color.red);\n            }\n            if (jTextFieldNewPassword_01.getText().equals(\"\")) {\n                s += \"<br>- Password\";\n                jLabelNewPassword_01.setForeground(Color.red);\n            }\n            if (jTextFieldNewPassword_02.getText().equals(\"\")) {\n                s += \"<br>- Password confirm\";\n                jLabelNewPassword_02.setForeground(Color.red);\n            }\n            //System.out.println(\"Pruefen\");\n            if (!s.equals(\"\")) {\n                jLabelMessage.setText(\"<Html>The following things are requried:\" + s + \"</Html>\");\n            } else if (!jTextFieldNewPassword_01.getText().equals(jTextFieldNewPassword_02.getText())) {\n                //\tSystem.out.println(\"Passwoerter stimmen nicht!\");\n                jLabelMessage.setText(\"The passwords are not equal!\");\n                jTextFieldNewPassword_01.setText(\"\");\n                jTextFieldNewPassword_02.setText(\"\");\n                jTextFieldNewPassword_01.requestFocus();\n                jLabelNewPassword_01.setForeground(Color.red);\n                jLabelNewPassword_02.setForeground(Color.red);\n            } else {\n                newAccountSession(jTextFieldNewUser.getText(), jTextFieldNewPassword_01.getText());\n                StartFrame.getInstance().setCursorWait();\n            }\n        } else if (evt.getSource().equals(jButtonReturn)) {\n            jPanelRegUser.setVisible(true);\n            jPanelGuestUser.setVisible(true);\n            jPanelNewAccount.setVisible(false);\n        } else if (evt.getSource().equals(jButtonBack)) {\n            StartFrame.getInstance().logout();\n        }\n        repaint();\n    }\n\n    public void keyPressed(KeyEvent evt) {\n        if (evt.getKeyCode() == KeyEvent.VK_ENTER) {\n            if (evt.getSource().equals(jTextFieldGuestUser)) {\n                if (!jTextFieldGuestUser.getText().equals(\"\")) {\n                    guestSession(jTextFieldGuestUser.getText());\n                    jLabelMessage.setText(\"GastLogin nach Enter!\");\n                }\n            } else if (evt.getSource().equals(jTextFieldRegPassword)) {\n                if (!jTextFieldRegUser.getText().equals(\"\") && !jTextFieldRegPassword.getText().equals(\"\")) {\n                    loginSession(jTextFieldRegUser.getText(), jTextFieldRegPassword.getText());\n                    jLabelMessage.setText(\"Login nach Enter!\");\n                }\n            } else if (evt.getSource().equals(jLabelNewPassword_02)) {\n                if (!jTextFieldNewPassword_01.getText().equals(\"\") && !jTextFieldNewPassword_02.getText().equals(\"\") && !jTextFieldNewUser.getText().equals(\"\")) {\n                    newAccountSession(jTextFieldNewUser.getText(), jTextFieldNewPassword_01.getText());\n                }\n            }\n        }\n    }\n\n    public void keyReleased(KeyEvent arg0) {\n    }\n\n    public void keyTyped(KeyEvent arg0) {\n    }\n\n    /**\n     * @author Bj�rn\n     *\n     * @param username\n     * @param password\n     */\n    public void loginSession(String username, String password) {\n        LoginMsg msg = new LoginMsg(username, password, LoginMsg.LOGIN);\n        BomberClient.getInstance().sendMsg(msg);\n        BomberClient.getInstance().setPlayerName(username);\n    }\n\n    /**\n     * @author Bj�rn\n     *\n     * @param username\n     */\n    public void guestSession(String username) {\n        LoginMsg msg = new LoginMsg(username, LoginMsg.GUEST_LOGIN);\n        BomberClient.getInstance().sendMsg(msg);\n        BomberClient.getInstance().setPlayerName(username);\n    }\n\n    /**\n     * @author Bj�rn\n     *\n     * @param username\n     * @param password\n     */\n    public void newAccountSession(String username, String password) {\n        LoginMsg msg = new LoginMsg(username, password, LoginMsg.REGISTER);\n        BomberClient.getInstance().sendMsg(msg);\n        BomberClient.getInstance().setPlayerName(username);\n    }\n\n    public void mouseClicked(MouseEvent e) {\n        //\t\tactionPerformed(e);\n    }\n\n    public void mouseEntered(MouseEvent e) {\n    }\n\n    public void mouseExited(MouseEvent e) {\n    }\n\n    public void mousePressed(MouseEvent e) {\n    }\n\n    public void mouseReleased(MouseEvent e) {\n    }\n\n    /**\n     * Handles the action, when the server sends, that the entered username is\n     * wrong\n     *\n     * @author Bj�rn\n     */\n    public void loginWrongUsername() {\n        StartFrame startFrame = StartFrame.getInstance();\n        startFrame.changePanel(startFrame.jPanelLogin);\n        jLabelMessage.setText(\"The username you have entered isn't correct!\");\n        jLabelRegUser.setForeground(Color.red);\n    }\n\n    /**\n     * Handles the action, when the server sends, that the entered password is\n     * wrong\n     *\n     * @author Bj�rn\n     */\n    public void loginWrongPassword() {\n        StartFrame startFrame = StartFrame.getInstance();\n        startFrame.changePanel(startFrame.jPanelLogin);\n        jLabelMessage.setText(\"The password you have entered isn't correct!\");\n        jLabelRegPassword.setForeground(Color.red);\n    }\n\n    /**\n     * Handles the action, when the server sends, that the entered username is\n     * assigned\n     *\n     * @author Bj�rn\n     */\n    public void loginUsernameTaken() {\n        StartFrame startFrame = StartFrame.getInstance();\n        startFrame.changePanel(startFrame.jPanelLogin);\n        jLabelMessage.setText(\"The username you have entered is assigned!\");\n        jLabelGuestUser.setForeground(Color.red);\n        jLabelNewUser.setForeground(Color.red);\n    }\n\n    /**\n     * Handles the action, when the server sends, that the entered user is still\n     * logged in\n     *\n     * @author Bj�rn\n     */\n    public void loginUserStillLogedIn() {\n        StartFrame startFrame = StartFrame.getInstance();\n        startFrame.changePanel(startFrame.jPanelLogin);\n        jLabelMessage.setText(\"The username you have entered is still logged in on this server!\");\n    }\n\n    /**\n     * Handles the action, when the server sends, that the login was successful\n     *\n     * @author Bj�rn\n     */\n    public void loginSuccessful() {\n        StartFrame startFrame = StartFrame.getInstance();\n        startFrame.changePanel(startFrame.jPanelGlobalLobby);\n    }\n    //\t@Override\n    //\tpublic void actionPerformed(ActionEvent e) {\n    //\t\tactionPerformed(e);\n    //\n    //\t}\n}\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/client/gui/LoginDialogTest.java",
		"test_prompt": "// LoginDialogTest.java\npackage client.gui;\n\nimport java.awt.Color;\nimport java.awt.Cursor;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseListener;\nimport javax.swing.JLabel;\nimport javax.swing.JPasswordField;\nimport javax.swing.JTextField;\nimport common.Constants;\nimport messages.global.LoginMsg;\nimport client.BomberClient;\nimport client.ClientProperties;\nimport client.gui.components.MyButton;\nimport client.gui.components.MyPanel;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link LoginDialog}.\n* It contains ten unit test cases for the {@link LoginDialog#init()} method.\n*/\nclass LoginDialogTest {"
	},
	{
		"original_code": "// CreateGameDialog.java\npackage client.gui;\r\n\r\nimport java.awt.Color;\r\nimport java.awt.Graphics;\r\nimport java.awt.event.ActionEvent;\r\nimport java.awt.event.ActionListener;\r\nimport java.awt.event.ItemEvent;\r\nimport java.awt.event.ItemListener;\r\nimport java.awt.event.MouseEvent;\r\nimport java.awt.event.MouseListener;\r\nimport java.util.ArrayList;\r\nimport java.util.Vector;\r\nimport javax.swing.ImageIcon;\r\nimport javax.swing.JLabel;\r\nimport javax.swing.JList;\r\nimport javax.swing.JTextField;\r\nimport messages.global.MapInfo;\r\nimport client.BomberClient;\r\nimport client.gui.components.MyButton;\r\nimport client.gui.components.MyPanel;\r\n\r\npublic class CreateGameDialog extends MyPanel implements ActionListener, ItemListener, MouseListener {\r\n\r\n    JList jListMap = new JList();\r\n\r\n    JTextField jTextFieldRounds = new JTextField();\r\n\r\n    JTextField jTextFieldPlayerNumber = new JTextField();\r\n\r\n    JTextField jTextFieldName = new JTextField(\"Game name\");\r\n\r\n    JLabel jLabelRounds = new JLabel(\"Rounds:\");\r\n\r\n    JLabel jLabelPlayerNumber = new JLabel(\"Playernumber: \");\r\n\r\n    JLabel jLabelPrev = new JLabel(\"Preview\");\r\n\r\n    ImageCache preview = new ImageCache(null, 400, 270, 300, 225);\r\n\r\n    JLabel jLabelName = new JLabel(\"Game Name:\");\r\n\r\n    JLabel jLabelMessage = new JLabel(\" \");\r\n\r\n    MyButton jButtonStart = new MyButton(\"Create Game\");\r\n\r\n    MyButton jButtonCancel = new MyButton(\"Cancel\");\r\n\r\n    MyButton jButtonReturn = new MyButton(\"Return\");\r\n\r\n    public void actionPerformed(ActionEvent evt) {\r\n        if (evt.getSource().equals(jButtonStart)) {\r\n        }\r\n    }\r\n\r\n    public CreateGameDialog() {\r\n        super();\r\n        this.setLayout(null);\r\n        this.setBounds(0, 0, 800, 600);\r\n        // setBackground(new Color(100, 100, 100));\r\n        jLabelRounds.setBounds(20, 20, 130, 25);\r\n        jLabelPlayerNumber.setBounds(20, 100, 130, 25);\r\n        jLabelName.setBounds(20, 200, 130, 25);\r\n        jTextFieldRounds.setBounds(140, 20, 50, 25);\r\n        jTextFieldPlayerNumber.setBounds(140, 100, 50, 25);\r\n        jTextFieldName.setBounds(140, 200, 200, 25);\r\n        jListMap.setBounds(400, 20, 300, 225);\r\n        jLabelPrev.setBounds(400, 250, 170, 110);\r\n        jButtonStart.setBounds(20, 250, 160, 25);\r\n        jButtonStart.setEnabled(false);\r\n        jButtonStart.setVisible(false);\r\n        // jButtonCancel.setBounds(190,195,160,25);\r\n        jButtonReturn.setBounds(190, 250, 160, 25);\r\n        jLabelMessage.setBounds(20, 300, 160, 25);\r\n        // ImageIcon icon = new ImageIcon(\"C:\\\\Bombermann\\\\PrevGruen.png\");\r\n        // jLabelPrev.setIcon(icon);\r\n        // jLabelPrev.setBackground(new Color(0, 0, 0));\r\n        // jLabelPrev.setForeground(new Color(255, 255, 255));\r\n        jTextFieldRounds.setText(\"3\");\r\n        jTextFieldPlayerNumber.setText(\"2\");\r\n        jTextFieldName.setText(\"Game Name\");\r\n        jListMap.addMouseListener(this);\r\n        jButtonStart.addMouseListener(this);\r\n        jButtonReturn.addMouseListener(this);\r\n        add(jButtonStart);\r\n        add(jButtonReturn);\r\n        addLabel(jLabelRounds);\r\n        addLabel(jLabelPlayerNumber);\r\n        add(jTextFieldRounds);\r\n        add(jTextFieldPlayerNumber);\r\n        add(jListMap);\r\n        add(jTextFieldName);\r\n        addLabel(jLabelName);\r\n        addLabel(jLabelPrev);\r\n        addLabel(jLabelMessage);\r\n        addImage(preview);\r\n    }\r\n\r\n    // Nobody uses this shit\r\n    public Vector<MapInfo> loadMaps() {\r\n        return BomberClient.getInstance().getAvailableMaps();\r\n    }\r\n\r\n    // Nobody uses this shit\r\n    public void loadAndDisplayMaps() {\r\n        jListMap.setListData(loadMaps());\r\n        jListMap.setFocusable(true);\r\n        jListMap.setEnabled(true);\r\n    }\r\n\r\n    public void itemStateChanged(ItemEvent arg0) {\r\n    }\r\n\r\n    public void mouseClicked(MouseEvent evt) {\r\n        if (evt.getSource().equals(jListMap)) {\r\n            if (jListMap.getSelectedIndex() != -1) {\r\n                jLabelMessage.setVisible(false);\r\n                boolean isOk = true;\r\n                int number = -1;\r\n                try {\r\n                    number = Integer.parseInt(jTextFieldPlayerNumber.getText());\r\n                } catch (Exception e) {\r\n                }\r\n                Object[] items = jListMap.getSelectedValues();\r\n                for (int i = 0; i < items.length; i++) {\r\n                    MapInfo cash = (MapInfo) items[i];\r\n                    int aktuellNumber = cash.getMaxPlayers();\r\n                    if (aktuellNumber < number) {\r\n                        isOk = false;\r\n                    }\r\n                }\r\n                if (isOk) {\r\n                    jButtonStart.setEnabled(true);\r\n                    jButtonStart.setVisible(true);\r\n                } else {\r\n                    jLabelMessage.setText(\"<HTML>At least one of the chosen maps <br>doesn't support \" + number + \" player\");\r\n                    jLabelMessage.setVisible(true);\r\n                    jButtonStart.setEnabled(false);\r\n                    jButtonStart.setVisible(false);\r\n                }\r\n            } else {\r\n                jButtonStart.setEnabled(false);\r\n                jButtonStart.setVisible(false);\r\n            }\r\n            Object o = jListMap.getSelectedValue();\r\n            ImageIcon icon = new ImageIcon();\r\n            icon = (((MapInfo) o).getPreview());\r\n            // draw preview direct to panel\r\n            preview.setImg(icon.getImage());\r\n            super.repaint();\r\n        } else if (evt.getSource().equals(jButtonStart) && jListMap.getSelectedIndex() != -1) {\r\n            int number = -1;\r\n            int rounds = -1;\r\n            try {\r\n                number = Integer.parseInt(jTextFieldPlayerNumber.getText());\r\n                rounds = Integer.parseInt(jTextFieldRounds.getText());\r\n                if (number < 2) {\r\n                    number = 2;\r\n                }\r\n                StartFrame frame = StartFrame.getInstance();\r\n                Config.playerNumber = number;\r\n                Config.rounds = rounds;\r\n                Config.gameName = jTextFieldName.getText();\r\n                ArrayList<String> selection = new ArrayList<String>();\r\n                ImageIcon previewIcon = null;\r\n                for (Object o : jListMap.getSelectedValues()) {\r\n                    selection.add(((MapInfo) o).getFile());\r\n                    // set preview of first map\r\n                    if (previewIcon == null) {\r\n                        previewIcon = ((MapInfo) o).getPreview();\r\n                    }\r\n                }\r\n                BomberClient.getInstance().createSession(Config.gameName, selection, previewIcon, Config.playerNumber, Config.rounds);\r\n            } catch (Exception e) {\r\n                // TODO Hinweis wegen geht nicht\r\n            }\r\n        } else if (evt.getSource().equals(jButtonReturn)) {\r\n            StartFrame.getInstance().showGlobalLobby();\r\n        }\r\n        repaint();\r\n    }\r\n\r\n    public void mousePressed(MouseEvent arg0) {\r\n        // TODO Auto-generated method stub\r\n    }\r\n\r\n    public void mouseReleased(MouseEvent arg0) {\r\n        // TODO Auto-generated method stub\r\n    }\r\n\r\n    public void mouseEntered(MouseEvent arg0) {\r\n        // TODO Auto-generated method stub\r\n    }\r\n\r\n    public void mouseExited(MouseEvent arg0) {\r\n        // TODO Auto-generated method stub\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/client/gui/CreateGameDialogTest.java",
		"test_prompt": "// CreateGameDialogTest.java\npackage client.gui;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.ItemEvent;\nimport java.awt.event.ItemListener;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseListener;\nimport java.util.ArrayList;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport javax.swing.JLabel;\nimport javax.swing.JList;\nimport javax.swing.JTextField;\nimport messages.global.MapInfo;\nimport client.BomberClient;\nimport client.gui.components.MyButton;\nimport client.gui.components.MyPanel;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CreateGameDialog}.\n* It contains ten unit test cases for the {@link CreateGameDialog#loadMaps()} method.\n*/\nclass CreateGameDialogTest {"
	},
	{
		"original_code": "// Chat.java\npackage client.gui;\n\nimport java.awt.Color;\nimport java.awt.Dimension;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseListener;\nimport java.text.DateFormat;\nimport java.util.Calendar;\nimport java.util.Date;\nimport javax.swing.JButton;\nimport javax.swing.JLabel;\nimport javax.swing.JPanel;\nimport javax.swing.JScrollPane;\nimport javax.swing.JTextArea;\nimport javax.swing.JTextField;\nimport org.apache.log4j.Logger;\nimport messages.global.GlobalChatMsg;\nimport messages.session.SessionChatMsg;\nimport client.BomberClient;\nimport client.gui.components.MyButton;\nimport client.gui.components.MyPanel;\nimport client.network.ClientMsgSender;\n\n/**\n * @author Tobi\n */\npublic class Chat extends MyPanel implements MouseListener, KeyListener, ActionListener {\n\n    private static Logger logger = Logger.getLogger(BomberClient.class);\n\n    private int id;\n\n    public final int GLOBAL = 1;\n\n    public final int SESSION = 2;\n\n    public void setType(int id) {\n        this.id = id;\n    }\n\n    public boolean isGlobal() {\n        return this.id == GLOBAL;\n    }\n\n    public boolean isSession() {\n        return this.id == SESSION;\n    }\n\n    MyButton jButtonSend = new MyButton(\"Send\");\n\n    JTextField jTextFieldChat = new JTextField(\"\");\n\n    JLabel jLabelChat = new JLabel(\"Your Text:\");\n\n    JTextArea jTextAreaChat = new JTextArea();\n\n    JScrollPane pane = new JScrollPane();\n\n    public Chat(int width, int height) {\n        super();\n        setLayout(null);\n        // setBounds(0,0,800,600);\n        setSize(new Dimension(width, height));\n        setVisible(true);\n        setBackground(new Color(50, 50, 200));\n        jTextFieldChat.addKeyListener(this);\n        jButtonSend.addKeyListener(this);\n        jTextFieldChat.addMouseListener(this);\n        jButtonSend.addActionListener(this);\n        jLabelChat.setBounds(20, height - 40, 60, 25);\n        jTextFieldChat.setBounds(100, height - 40, width - 210, 25);\n        jButtonSend.setBounds(width - 100, height - 40, 80, 25);\n        jTextAreaChat.setBounds(20, 20, width - 40, height - 70);\n        jTextAreaChat.setEditable(false);\n        pane.setBounds(20, 20, width - 40, height - 70);\n        // pane.setViewportView(new JTextArea());\n        pane.setViewportView(jTextAreaChat);\n        pane.setAutoscrolls(true);\n        // pane.setV\n        addLabel(jLabelChat);\n        add(jTextFieldChat);\n        add(jButtonSend);\n        add(pane);\n        setPicture(\"/images/simple_background.png\");\n    }\n\n    public void actionPerformed(ActionEvent arg0) {\n        actionPreformed();\n    }\n\n    public void setBounds(int x, int y, int width, int height) {\n        super.setBounds(x, y, width, height);\n    }\n\n    public void mouseClicked(MouseEvent arg0) {\n        actionPreformed();\n    }\n\n    public void mouseEntered(MouseEvent arg0) {\n    }\n\n    public void mouseExited(MouseEvent arg0) {\n    }\n\n    public void mousePressed(MouseEvent arg0) {\n    }\n\n    public void mouseReleased(MouseEvent arg0) {\n    }\n\n    public void actionPreformed() {\n        if (jTextFieldChat.getText().equals(\"\")) {\n            // System.out.println(\"nothing sent\");\n            // logger.debug(\"nothin sent\");\n            return;\n        }\n        // System.out.println(\"sending\");\n        logger.debug(\"sending chatmsg\");\n        // jTextAreaChat.setText(jTextAreaChat.getText() + \"\\n\" +\n        // jTextFieldChat.getText());\n        // System.out.println(\"Nachricht2: \" + jTextFieldChat.getText());\n        if (isGlobal()) {\n            logger.info(\"sending chat message glob\");\n            GlobalChatMsg chatmsg = new GlobalChatMsg(jTextFieldChat.getText());\n            BomberClient.getInstance().sendMsg(chatmsg);\n        }\n        if (isSession()) {\n            logger.info(\"sending chat message sess\");\n            SessionChatMsg chatmsg = new SessionChatMsg(jTextFieldChat.getText());\n            BomberClient.getInstance().sendMsg(chatmsg);\n        }\n        jTextFieldChat.setText(\"\");\n        jTextFieldChat.requestFocus();\n    }\n\n    public void keyPressed(KeyEvent arg0) {\n    }\n\n    public void keyReleased(KeyEvent evt) {\n        if (evt.getKeyCode() == evt.VK_ENTER) {\n            actionPreformed();\n        }\n    }\n\n    public void keyTyped(KeyEvent arg0) {\n    }\n\n    /**\n     * @param sender\n     * @param msg\n     */\n    public void addChatMessage(String sender, String msg) {\n        String newline = \"\\n\";\n        if (jTextAreaChat.getText().equals(\"\")) {\n            newline = \"\";\n        }\n        Calendar cal = Calendar.getInstance();\n        DateFormat df;\n        df = DateFormat.getTimeInstance(DateFormat.MEDIUM);\n        //18:34:08\n        String time = df.format(cal.getTime());\n        //logger.info(msg+\" said by \"+sender);\n        //Date d = new Date();\n        jTextAreaChat.append(newline + \"[\" + time + \"] \" + sender + \": \" + msg);\n        jTextAreaChat.setCaretPosition(jTextAreaChat.getDocument().getLength());\n    }\n\n    /**\n     */\n    public void clearChat() {\n        logger.info(\"clearing the chat text\");\n        //logger.info(jTextAreaChat.setText(\"\"));\n        this.jTextAreaChat.setText(\"\");\n    }\n}\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/client/gui/ChatTest0.java",
		"test_prompt": "// ChatTest0.java\npackage client.gui;\n\nimport java.awt.Color;\nimport java.awt.Dimension;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseListener;\nimport java.text.DateFormat;\nimport java.util.Calendar;\nimport java.util.Date;\nimport javax.swing.JButton;\nimport javax.swing.JLabel;\nimport javax.swing.JPanel;\nimport javax.swing.JScrollPane;\nimport javax.swing.JTextArea;\nimport javax.swing.JTextField;\nimport org.apache.log4j.Logger;\nimport messages.global.GlobalChatMsg;\nimport messages.session.SessionChatMsg;\nimport client.BomberClient;\nimport client.gui.components.MyButton;\nimport client.gui.components.MyPanel;\nimport client.network.ClientMsgSender;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Chat}.\n* It contains ten unit test cases for the {@link Chat#isGlobal()} method.\n*/\nclass ChatTest0 {"
	},
	{
		"original_code": "// Chat.java\npackage client.gui;\n\nimport java.awt.Color;\nimport java.awt.Dimension;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseListener;\nimport java.text.DateFormat;\nimport java.util.Calendar;\nimport java.util.Date;\nimport javax.swing.JButton;\nimport javax.swing.JLabel;\nimport javax.swing.JPanel;\nimport javax.swing.JScrollPane;\nimport javax.swing.JTextArea;\nimport javax.swing.JTextField;\nimport org.apache.log4j.Logger;\nimport messages.global.GlobalChatMsg;\nimport messages.session.SessionChatMsg;\nimport client.BomberClient;\nimport client.gui.components.MyButton;\nimport client.gui.components.MyPanel;\nimport client.network.ClientMsgSender;\n\n/**\n * @author Tobi\n */\npublic class Chat extends MyPanel implements MouseListener, KeyListener, ActionListener {\n\n    private static Logger logger = Logger.getLogger(BomberClient.class);\n\n    private int id;\n\n    public final int GLOBAL = 1;\n\n    public final int SESSION = 2;\n\n    public void setType(int id) {\n        this.id = id;\n    }\n\n    public boolean isGlobal() {\n        return this.id == GLOBAL;\n    }\n\n    public boolean isSession() {\n        return this.id == SESSION;\n    }\n\n    MyButton jButtonSend = new MyButton(\"Send\");\n\n    JTextField jTextFieldChat = new JTextField(\"\");\n\n    JLabel jLabelChat = new JLabel(\"Your Text:\");\n\n    JTextArea jTextAreaChat = new JTextArea();\n\n    JScrollPane pane = new JScrollPane();\n\n    public Chat(int width, int height) {\n        super();\n        setLayout(null);\n        // setBounds(0,0,800,600);\n        setSize(new Dimension(width, height));\n        setVisible(true);\n        setBackground(new Color(50, 50, 200));\n        jTextFieldChat.addKeyListener(this);\n        jButtonSend.addKeyListener(this);\n        jTextFieldChat.addMouseListener(this);\n        jButtonSend.addActionListener(this);\n        jLabelChat.setBounds(20, height - 40, 60, 25);\n        jTextFieldChat.setBounds(100, height - 40, width - 210, 25);\n        jButtonSend.setBounds(width - 100, height - 40, 80, 25);\n        jTextAreaChat.setBounds(20, 20, width - 40, height - 70);\n        jTextAreaChat.setEditable(false);\n        pane.setBounds(20, 20, width - 40, height - 70);\n        // pane.setViewportView(new JTextArea());\n        pane.setViewportView(jTextAreaChat);\n        pane.setAutoscrolls(true);\n        // pane.setV\n        addLabel(jLabelChat);\n        add(jTextFieldChat);\n        add(jButtonSend);\n        add(pane);\n        setPicture(\"/images/simple_background.png\");\n    }\n\n    public void actionPerformed(ActionEvent arg0) {\n        actionPreformed();\n    }\n\n    public void setBounds(int x, int y, int width, int height) {\n        super.setBounds(x, y, width, height);\n    }\n\n    public void mouseClicked(MouseEvent arg0) {\n        actionPreformed();\n    }\n\n    public void mouseEntered(MouseEvent arg0) {\n    }\n\n    public void mouseExited(MouseEvent arg0) {\n    }\n\n    public void mousePressed(MouseEvent arg0) {\n    }\n\n    public void mouseReleased(MouseEvent arg0) {\n    }\n\n    public void actionPreformed() {\n        if (jTextFieldChat.getText().equals(\"\")) {\n            // System.out.println(\"nothing sent\");\n            // logger.debug(\"nothin sent\");\n            return;\n        }\n        // System.out.println(\"sending\");\n        logger.debug(\"sending chatmsg\");\n        // jTextAreaChat.setText(jTextAreaChat.getText() + \"\\n\" +\n        // jTextFieldChat.getText());\n        // System.out.println(\"Nachricht2: \" + jTextFieldChat.getText());\n        if (isGlobal()) {\n            logger.info(\"sending chat message glob\");\n            GlobalChatMsg chatmsg = new GlobalChatMsg(jTextFieldChat.getText());\n            BomberClient.getInstance().sendMsg(chatmsg);\n        }\n        if (isSession()) {\n            logger.info(\"sending chat message sess\");\n            SessionChatMsg chatmsg = new SessionChatMsg(jTextFieldChat.getText());\n            BomberClient.getInstance().sendMsg(chatmsg);\n        }\n        jTextFieldChat.setText(\"\");\n        jTextFieldChat.requestFocus();\n    }\n\n    public void keyPressed(KeyEvent arg0) {\n    }\n\n    public void keyReleased(KeyEvent evt) {\n        if (evt.getKeyCode() == evt.VK_ENTER) {\n            actionPreformed();\n        }\n    }\n\n    public void keyTyped(KeyEvent arg0) {\n    }\n\n    /**\n     * @param sender\n     * @param msg\n     */\n    public void addChatMessage(String sender, String msg) {\n        String newline = \"\\n\";\n        if (jTextAreaChat.getText().equals(\"\")) {\n            newline = \"\";\n        }\n        Calendar cal = Calendar.getInstance();\n        DateFormat df;\n        df = DateFormat.getTimeInstance(DateFormat.MEDIUM);\n        //18:34:08\n        String time = df.format(cal.getTime());\n        //logger.info(msg+\" said by \"+sender);\n        //Date d = new Date();\n        jTextAreaChat.append(newline + \"[\" + time + \"] \" + sender + \": \" + msg);\n        jTextAreaChat.setCaretPosition(jTextAreaChat.getDocument().getLength());\n    }\n\n    /**\n     */\n    public void clearChat() {\n        logger.info(\"clearing the chat text\");\n        //logger.info(jTextAreaChat.setText(\"\"));\n        this.jTextAreaChat.setText(\"\");\n    }\n}\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/client/gui/ChatTest1.java",
		"test_prompt": "// ChatTest1.java\npackage client.gui;\n\nimport java.awt.Color;\nimport java.awt.Dimension;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseListener;\nimport java.text.DateFormat;\nimport java.util.Calendar;\nimport java.util.Date;\nimport javax.swing.JButton;\nimport javax.swing.JLabel;\nimport javax.swing.JPanel;\nimport javax.swing.JScrollPane;\nimport javax.swing.JTextArea;\nimport javax.swing.JTextField;\nimport org.apache.log4j.Logger;\nimport messages.global.GlobalChatMsg;\nimport messages.session.SessionChatMsg;\nimport client.BomberClient;\nimport client.gui.components.MyButton;\nimport client.gui.components.MyPanel;\nimport client.network.ClientMsgSender;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Chat}.\n* It contains ten unit test cases for the {@link Chat#isSession()} method.\n*/\nclass ChatTest1 {"
	},
	{
		"original_code": "// BomberClient.java\npackage client;\r\n\r\nimport java.io.IOException;\r\nimport java.net.Socket;\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Observable;\r\nimport java.util.Vector;\r\nimport javax.swing.ImageIcon;\r\nimport messages.Message;\r\nimport messages.global.InfoRequestMsg;\r\nimport messages.global.JoinSessionMsg;\r\nimport messages.global.MapInfo;\r\nimport messages.global.SessionDetailsMsg;\r\nimport messages.round.ClientQuitRunningSessionMsg;\r\nimport org.apache.log4j.Logger;\r\nimport client.gui.StartFrame;\r\nimport client.network.ClientMsgReceiver;\r\nimport client.network.ClientMsgSender;\r\n\r\n/**\r\n * This is central client class. It is responsible for globally scoped messages\r\n * and the creation of sessions.\r\n *\r\n * @author andi\r\n */\r\npublic class BomberClient extends Observable {\r\n\r\n    // for logging\r\n    private static Logger logger = Logger.getLogger(BomberClient.class);\r\n\r\n    /**\r\n     * The socket that is used to communicate with the server.\r\n     */\r\n    public Socket server;\r\n\r\n    /**\r\n     * The ip address of the server.\r\n     */\r\n    private String serverName = \"localhost\";\r\n\r\n    /**\r\n     * The port on the server to connect to.\r\n     */\r\n    private int serverPort = 6666;\r\n\r\n    /**\r\n     * The name of the player that is running this client.\r\n     */\r\n    private String playerName;\r\n\r\n    private ClientMsgReceiver msgReceiver;\r\n\r\n    private ClientMsgSender msgSender;\r\n\r\n    /**\r\n     * The id offset of this client. Generated ids will be in the range from\r\n     * idOffset to idOffset + 1000000.\r\n     */\r\n    private int idOffset = -1;\r\n\r\n    /**\r\n     * Singleton instance\r\n     */\r\n    private static BomberClient instance;\r\n\r\n    /**\r\n     * The currently used (and sole) session.\r\n     */\r\n    private ClientGameSession currentSession;\r\n\r\n    /**\r\n     * A list of sessions that are running on the server.\r\n     */\r\n    private Vector<SessionDetailsMsg> availableSessions = new Vector<SessionDetailsMsg>();\r\n\r\n    /**\r\n     * A list of maps that are availbale on the server.\r\n     */\r\n    private Vector<MapInfo> availableMaps;\r\n\r\n    private ClientGameSession requestedSession;\r\n\r\n    /**\r\n     * @return The current game session.\r\n     */\r\n    public ClientGameSession getCurrentSession() {\r\n        return currentSession;\r\n    }\r\n\r\n    /**\r\n     * Creates a new BomberClient. Use getInstance() to aquire an instance.\r\n     *\r\n     * @param playerName\r\n     *            The name of the player on this client.\r\n     */\r\n    private BomberClient(String playerName) {\r\n        this.playerName = playerName;\r\n        availableMaps = new Vector<MapInfo>();\r\n    }\r\n\r\n    /**\r\n     * Returns the singleton.\r\n     *\r\n     * @return The only BomberClient instance.\r\n     */\r\n    public static BomberClient getInstance() {\r\n        if (instance == null) {\r\n            logger.info(\"Creating BomberClient singleton instance\");\r\n            instance = new BomberClient(\"client\");\r\n        }\r\n        return instance;\r\n    }\r\n\r\n    /**\r\n     * Tries to connect to the server.\r\n     *\r\n     * @throws RuntimeException\r\n     *             Thrown when the connection attempt was not successful.\r\n     */\r\n    public boolean connectToSrv() {\r\n        try {\r\n            //System.out.println(\"Connecting...\");\r\n            logger.info(\"Establishing a connection \");\r\n            server = new Socket(serverName, serverPort);\r\n            msgSender = new ClientMsgSender(server);\r\n            msgSender.start();\r\n            msgReceiver = new ClientMsgReceiver(server, BomberClient.this);\r\n            msgReceiver.start();\r\n            msgSender.sendMsg(new InfoRequestMsg(InfoRequestMsg.GET_SESSION_LIST));\r\n            logger.info(\"connected to \" + serverName);\r\n            return true;\r\n        } catch (IOException e) {\r\n            // TODO Auto-generated catch block\r\n            // e.printStackTrace();\r\n            logger.info(\"Connection failed\");\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sends a message to the server. The passed object will be serialized and\r\n     * transmitted to the server.\r\n     *\r\n     * @param msg\r\n     *            The message to send.\r\n     */\r\n    public void sendMsg(Message msg) {\r\n        msgSender.sendMsg(msg);\r\n    }\r\n\r\n    /**\r\n     * Creates a new id that is guaranteed to be unique for this class.\r\n     *\r\n     * @return The next valid id for this class.\r\n     */\r\n    public int getNextId() {\r\n        return ++idOffset;\r\n    }\r\n\r\n    /**\r\n     * Sets the id offset.\r\n     *\r\n     * @param idOffset\r\n     *            to set\r\n     */\r\n    public void setIdOffset(int idOffset) {\r\n        this.idOffset = idOffset;\r\n    }\r\n\r\n    /**\r\n     * Sets the current session.\r\n     *\r\n     * @param The\r\n     *            ClientGameSession to set.\r\n     */\r\n    public void setCurrentSession(ClientGameSession currentSession) {\r\n        this.currentSession = currentSession;\r\n    }\r\n\r\n    /**\r\n     * Create a new session on the server. The given arguments are rolled up\r\n     * into a SessionDetailsMsg and sent to the server.\r\n     *\r\n     * @param name\r\n     *            The name for the new session.\r\n     * @param maps\r\n     *            A list of map names that will be used for this session\r\n     * @param totalPlayers\r\n     *            The total number of players.\r\n     * @param rounds\r\n     *            The number of rounds to play.\r\n     */\r\n    public void createSession(String name, List<String> maps, ImageIcon mapPreview, int totalPlayers, int rounds) {\r\n        SessionDetailsMsg sessionDetailsMsg = new SessionDetailsMsg(name, maps, mapPreview, totalPlayers, totalPlayers, rounds);\r\n        this.requestedSession = new ClientGameSession(name, maps, mapPreview, totalPlayers, rounds, idOffset);\r\n        msgSender.sendMsg(sessionDetailsMsg);\r\n    }\r\n\r\n    public void openSession() {\r\n        requestedSession.setIdOffset(idOffset);\r\n        setCurrentSession(requestedSession);\r\n        logger.info(\"opened session: \" + currentSession.getName());\r\n    }\r\n\r\n    /**\r\n     * Requests a list of active sessions on the server.\r\n     */\r\n    public void requestSessionList() {\r\n        InfoRequestMsg sessionRequest = new InfoRequestMsg(InfoRequestMsg.GET_SESSION_LIST);\r\n        sendMsg(sessionRequest);\r\n    }\r\n\r\n    /**\r\n     * Requests a list of available maps from the server.\r\n     */\r\n    public void requestMapList() {\r\n        InfoRequestMsg mapRequest = new InfoRequestMsg(InfoRequestMsg.GET_MAP_LIST);\r\n        sendMsg(mapRequest);\r\n    }\r\n\r\n    /**\r\n     * Returns a list of active sessions on the server. Invoke\r\n     * requestSessionList() to update this list.\r\n     *\r\n     * @return\r\n     */\r\n    public Vector<SessionDetailsMsg> getAvailableSessions() {\r\n        return availableSessions;\r\n    }\r\n\r\n    /**\r\n     * @param sessionInfos\r\n     */\r\n    public void setAvailableSessions(Vector<SessionDetailsMsg> sessionInfos) {\r\n        availableSessions.clear();\r\n        availableSessions.addAll(sessionInfos);\r\n        // TODO observer\r\n        StartFrame.getInstance().setAvailableSessions(availableSessions);\r\n    }\r\n\r\n    /**\r\n     * @param maps\r\n     */\r\n    public void setAvailableMaps(List<MapInfo> maps) {\r\n        availableMaps.clear();\r\n        availableMaps.addAll(maps);\r\n        // TODO observer\r\n        StartFrame.getInstance().setAvailableMaps(availableMaps);\r\n    }\r\n\r\n    /**\r\n     * @return the availableMaps\r\n     */\r\n    public Vector<MapInfo> getAvailableMaps() {\r\n        return availableMaps;\r\n    }\r\n\r\n    /**\r\n     * Creates a session from the details specified in the given\r\n     * SessionDetailMsg.\r\n     *\r\n     * @param session\r\n     *            The session to open on this client.\r\n     */\r\n    public void createSession(SessionDetailsMsg sessionDetails) {\r\n        ClientGameSession session = new ClientGameSession(sessionDetails.getGameName(), sessionDetails.getMaps(), sessionDetails.getPreview(), sessionDetails.getNrOfPlayers(), sessionDetails.getTotalRounds(), idOffset);\r\n        requestedSession = session;\r\n        JoinSessionMsg joinMsg = new JoinSessionMsg(session.getName(), playerName);\r\n        msgSender.sendMsg(joinMsg);\r\n    }\r\n\r\n    /**\r\n     * Sets the server-name\r\n     *\r\n     * @author Bj�rn\r\n     */\r\n    public void setServerName(String serverName) {\r\n        this.serverName = serverName;\r\n    }\r\n\r\n    /**\r\n     * Sets the server-port\r\n     *\r\n     * @author Bj�rn\r\n     */\r\n    public void setServerPort(int serverPort) {\r\n        this.serverPort = serverPort;\r\n    }\r\n\r\n    /**\r\n     * @param sender\r\n     * @param msg\r\n     */\r\n    public void addChatGlobal(String sender, String msg) {\r\n        logger.info(\"omg asd rofl\");\r\n        StartFrame.getInstance().addChatMessageGlobal(sender, msg);\r\n    }\r\n\r\n    /**\r\n     * @param sender\r\n     * @param msg\r\n     */\r\n    public void addChatSession(String sender, String msg) {\r\n        StartFrame.getInstance().addChatMessageSession(sender, msg);\r\n    }\r\n\r\n    public void discardSessionRequest() {\r\n        requestedSession = null;\r\n    }\r\n\r\n    /**\r\n     * Closes the current session.\r\n     */\r\n    public void closeSession() {\r\n        // TODO session highscore presentation\r\n        currentSession = null;\r\n        StartFrame sFrame = StartFrame.getInstance();\r\n        sFrame.showGlobalLobby();\r\n    }\r\n\r\n    /**\r\n     * Closes the current session.\r\n     */\r\n    public void closeSessionAndShowHighscores() {\r\n        // TODO session highscore presentation\r\n        currentSession = null;\r\n        StartFrame sFrame = StartFrame.getInstance();\r\n        sFrame.showHighscoreLobby();\r\n    }\r\n\r\n    /**\r\n     * Leave the current session.\r\n     */\r\n    public void leaveSession() {\r\n        if (currentSession != null) {\r\n            currentSession.leave();\r\n        }\r\n        currentSession = null;\r\n        StartFrame sFrame = StartFrame.getInstance();\r\n        sFrame.showGlobalLobby();\r\n    }\r\n\r\n    public void closeConnection() {\r\n        msgReceiver.closeConnection();\r\n    }\r\n\r\n    public String getPlayerName() {\r\n        return playerName;\r\n    }\r\n\r\n    public void setPlayerName(String playerName) {\r\n        this.playerName = playerName;\r\n    }\r\n\r\n    public void requestGlobalScore() {\r\n        msgSender.sendMsg(new InfoRequestMsg(InfoRequestMsg.GET_OVERALL_SCORE));\r\n    }\r\n\r\n    public void setGlobalscores(ArrayList scores) {\r\n        StartFrame.getInstance().setGlobalScore(scores);\r\n    }\r\n\r\n    public void setRoundScore(HashMap<String, Integer> rndscore) {\r\n        logger.info(\"setting round score\");\r\n        StartFrame.getInstance().updateRoundScoreData(rndscore);\r\n    }\r\n\r\n    public void setSessionScore(HashMap<String, Integer> rndscore) {\r\n        logger.info(\"setting session score\");\r\n        StartFrame.getInstance().updateSessionScoreData(rndscore);\r\n    }\r\n\r\n    /**\r\n     * @param i\r\n     */\r\n    public void quitRunningSession(int playerId) {\r\n        getCurrentSession().getCurrentRound().terminateRound();\r\n        sendMsg(new ClientQuitRunningSessionMsg(playerId));\r\n        currentSession = null;\r\n        StartFrame.getInstance().showGlobalLobby();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/client/BomberClientTest0.java",
		"test_prompt": "// BomberClientTest0.java\npackage client;\n\nimport java.io.IOException;\nimport java.net.Socket;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Observable;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport messages.Message;\nimport messages.global.InfoRequestMsg;\nimport messages.global.JoinSessionMsg;\nimport messages.global.MapInfo;\nimport messages.global.SessionDetailsMsg;\nimport messages.round.ClientQuitRunningSessionMsg;\nimport org.apache.log4j.Logger;\nimport client.gui.StartFrame;\nimport client.network.ClientMsgReceiver;\nimport client.network.ClientMsgSender;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BomberClient}.\n* It contains ten unit test cases for the {@link BomberClient#getInstance()} method.\n*/\nclass BomberClientTest0 {"
	},
	{
		"original_code": "// BomberClient.java\npackage client;\r\n\r\nimport java.io.IOException;\r\nimport java.net.Socket;\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Observable;\r\nimport java.util.Vector;\r\nimport javax.swing.ImageIcon;\r\nimport messages.Message;\r\nimport messages.global.InfoRequestMsg;\r\nimport messages.global.JoinSessionMsg;\r\nimport messages.global.MapInfo;\r\nimport messages.global.SessionDetailsMsg;\r\nimport messages.round.ClientQuitRunningSessionMsg;\r\nimport org.apache.log4j.Logger;\r\nimport client.gui.StartFrame;\r\nimport client.network.ClientMsgReceiver;\r\nimport client.network.ClientMsgSender;\r\n\r\n/**\r\n * This is central client class. It is responsible for globally scoped messages\r\n * and the creation of sessions.\r\n *\r\n * @author andi\r\n */\r\npublic class BomberClient extends Observable {\r\n\r\n    // for logging\r\n    private static Logger logger = Logger.getLogger(BomberClient.class);\r\n\r\n    /**\r\n     * The socket that is used to communicate with the server.\r\n     */\r\n    public Socket server;\r\n\r\n    /**\r\n     * The ip address of the server.\r\n     */\r\n    private String serverName = \"localhost\";\r\n\r\n    /**\r\n     * The port on the server to connect to.\r\n     */\r\n    private int serverPort = 6666;\r\n\r\n    /**\r\n     * The name of the player that is running this client.\r\n     */\r\n    private String playerName;\r\n\r\n    private ClientMsgReceiver msgReceiver;\r\n\r\n    private ClientMsgSender msgSender;\r\n\r\n    /**\r\n     * The id offset of this client. Generated ids will be in the range from\r\n     * idOffset to idOffset + 1000000.\r\n     */\r\n    private int idOffset = -1;\r\n\r\n    /**\r\n     * Singleton instance\r\n     */\r\n    private static BomberClient instance;\r\n\r\n    /**\r\n     * The currently used (and sole) session.\r\n     */\r\n    private ClientGameSession currentSession;\r\n\r\n    /**\r\n     * A list of sessions that are running on the server.\r\n     */\r\n    private Vector<SessionDetailsMsg> availableSessions = new Vector<SessionDetailsMsg>();\r\n\r\n    /**\r\n     * A list of maps that are availbale on the server.\r\n     */\r\n    private Vector<MapInfo> availableMaps;\r\n\r\n    private ClientGameSession requestedSession;\r\n\r\n    /**\r\n     * @return The current game session.\r\n     */\r\n    public ClientGameSession getCurrentSession() {\r\n        return currentSession;\r\n    }\r\n\r\n    /**\r\n     * Creates a new BomberClient. Use getInstance() to aquire an instance.\r\n     *\r\n     * @param playerName\r\n     *            The name of the player on this client.\r\n     */\r\n    private BomberClient(String playerName) {\r\n        this.playerName = playerName;\r\n        availableMaps = new Vector<MapInfo>();\r\n    }\r\n\r\n    /**\r\n     * Returns the singleton.\r\n     *\r\n     * @return The only BomberClient instance.\r\n     */\r\n    public static BomberClient getInstance() {\r\n        if (instance == null) {\r\n            logger.info(\"Creating BomberClient singleton instance\");\r\n            instance = new BomberClient(\"client\");\r\n        }\r\n        return instance;\r\n    }\r\n\r\n    /**\r\n     * Tries to connect to the server.\r\n     *\r\n     * @throws RuntimeException\r\n     *             Thrown when the connection attempt was not successful.\r\n     */\r\n    public boolean connectToSrv() {\r\n        try {\r\n            //System.out.println(\"Connecting...\");\r\n            logger.info(\"Establishing a connection \");\r\n            server = new Socket(serverName, serverPort);\r\n            msgSender = new ClientMsgSender(server);\r\n            msgSender.start();\r\n            msgReceiver = new ClientMsgReceiver(server, BomberClient.this);\r\n            msgReceiver.start();\r\n            msgSender.sendMsg(new InfoRequestMsg(InfoRequestMsg.GET_SESSION_LIST));\r\n            logger.info(\"connected to \" + serverName);\r\n            return true;\r\n        } catch (IOException e) {\r\n            // TODO Auto-generated catch block\r\n            // e.printStackTrace();\r\n            logger.info(\"Connection failed\");\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sends a message to the server. The passed object will be serialized and\r\n     * transmitted to the server.\r\n     *\r\n     * @param msg\r\n     *            The message to send.\r\n     */\r\n    public void sendMsg(Message msg) {\r\n        msgSender.sendMsg(msg);\r\n    }\r\n\r\n    /**\r\n     * Creates a new id that is guaranteed to be unique for this class.\r\n     *\r\n     * @return The next valid id for this class.\r\n     */\r\n    public int getNextId() {\r\n        return ++idOffset;\r\n    }\r\n\r\n    /**\r\n     * Sets the id offset.\r\n     *\r\n     * @param idOffset\r\n     *            to set\r\n     */\r\n    public void setIdOffset(int idOffset) {\r\n        this.idOffset = idOffset;\r\n    }\r\n\r\n    /**\r\n     * Sets the current session.\r\n     *\r\n     * @param The\r\n     *            ClientGameSession to set.\r\n     */\r\n    public void setCurrentSession(ClientGameSession currentSession) {\r\n        this.currentSession = currentSession;\r\n    }\r\n\r\n    /**\r\n     * Create a new session on the server. The given arguments are rolled up\r\n     * into a SessionDetailsMsg and sent to the server.\r\n     *\r\n     * @param name\r\n     *            The name for the new session.\r\n     * @param maps\r\n     *            A list of map names that will be used for this session\r\n     * @param totalPlayers\r\n     *            The total number of players.\r\n     * @param rounds\r\n     *            The number of rounds to play.\r\n     */\r\n    public void createSession(String name, List<String> maps, ImageIcon mapPreview, int totalPlayers, int rounds) {\r\n        SessionDetailsMsg sessionDetailsMsg = new SessionDetailsMsg(name, maps, mapPreview, totalPlayers, totalPlayers, rounds);\r\n        this.requestedSession = new ClientGameSession(name, maps, mapPreview, totalPlayers, rounds, idOffset);\r\n        msgSender.sendMsg(sessionDetailsMsg);\r\n    }\r\n\r\n    public void openSession() {\r\n        requestedSession.setIdOffset(idOffset);\r\n        setCurrentSession(requestedSession);\r\n        logger.info(\"opened session: \" + currentSession.getName());\r\n    }\r\n\r\n    /**\r\n     * Requests a list of active sessions on the server.\r\n     */\r\n    public void requestSessionList() {\r\n        InfoRequestMsg sessionRequest = new InfoRequestMsg(InfoRequestMsg.GET_SESSION_LIST);\r\n        sendMsg(sessionRequest);\r\n    }\r\n\r\n    /**\r\n     * Requests a list of available maps from the server.\r\n     */\r\n    public void requestMapList() {\r\n        InfoRequestMsg mapRequest = new InfoRequestMsg(InfoRequestMsg.GET_MAP_LIST);\r\n        sendMsg(mapRequest);\r\n    }\r\n\r\n    /**\r\n     * Returns a list of active sessions on the server. Invoke\r\n     * requestSessionList() to update this list.\r\n     *\r\n     * @return\r\n     */\r\n    public Vector<SessionDetailsMsg> getAvailableSessions() {\r\n        return availableSessions;\r\n    }\r\n\r\n    /**\r\n     * @param sessionInfos\r\n     */\r\n    public void setAvailableSessions(Vector<SessionDetailsMsg> sessionInfos) {\r\n        availableSessions.clear();\r\n        availableSessions.addAll(sessionInfos);\r\n        // TODO observer\r\n        StartFrame.getInstance().setAvailableSessions(availableSessions);\r\n    }\r\n\r\n    /**\r\n     * @param maps\r\n     */\r\n    public void setAvailableMaps(List<MapInfo> maps) {\r\n        availableMaps.clear();\r\n        availableMaps.addAll(maps);\r\n        // TODO observer\r\n        StartFrame.getInstance().setAvailableMaps(availableMaps);\r\n    }\r\n\r\n    /**\r\n     * @return the availableMaps\r\n     */\r\n    public Vector<MapInfo> getAvailableMaps() {\r\n        return availableMaps;\r\n    }\r\n\r\n    /**\r\n     * Creates a session from the details specified in the given\r\n     * SessionDetailMsg.\r\n     *\r\n     * @param session\r\n     *            The session to open on this client.\r\n     */\r\n    public void createSession(SessionDetailsMsg sessionDetails) {\r\n        ClientGameSession session = new ClientGameSession(sessionDetails.getGameName(), sessionDetails.getMaps(), sessionDetails.getPreview(), sessionDetails.getNrOfPlayers(), sessionDetails.getTotalRounds(), idOffset);\r\n        requestedSession = session;\r\n        JoinSessionMsg joinMsg = new JoinSessionMsg(session.getName(), playerName);\r\n        msgSender.sendMsg(joinMsg);\r\n    }\r\n\r\n    /**\r\n     * Sets the server-name\r\n     *\r\n     * @author Bj�rn\r\n     */\r\n    public void setServerName(String serverName) {\r\n        this.serverName = serverName;\r\n    }\r\n\r\n    /**\r\n     * Sets the server-port\r\n     *\r\n     * @author Bj�rn\r\n     */\r\n    public void setServerPort(int serverPort) {\r\n        this.serverPort = serverPort;\r\n    }\r\n\r\n    /**\r\n     * @param sender\r\n     * @param msg\r\n     */\r\n    public void addChatGlobal(String sender, String msg) {\r\n        logger.info(\"omg asd rofl\");\r\n        StartFrame.getInstance().addChatMessageGlobal(sender, msg);\r\n    }\r\n\r\n    /**\r\n     * @param sender\r\n     * @param msg\r\n     */\r\n    public void addChatSession(String sender, String msg) {\r\n        StartFrame.getInstance().addChatMessageSession(sender, msg);\r\n    }\r\n\r\n    public void discardSessionRequest() {\r\n        requestedSession = null;\r\n    }\r\n\r\n    /**\r\n     * Closes the current session.\r\n     */\r\n    public void closeSession() {\r\n        // TODO session highscore presentation\r\n        currentSession = null;\r\n        StartFrame sFrame = StartFrame.getInstance();\r\n        sFrame.showGlobalLobby();\r\n    }\r\n\r\n    /**\r\n     * Closes the current session.\r\n     */\r\n    public void closeSessionAndShowHighscores() {\r\n        // TODO session highscore presentation\r\n        currentSession = null;\r\n        StartFrame sFrame = StartFrame.getInstance();\r\n        sFrame.showHighscoreLobby();\r\n    }\r\n\r\n    /**\r\n     * Leave the current session.\r\n     */\r\n    public void leaveSession() {\r\n        if (currentSession != null) {\r\n            currentSession.leave();\r\n        }\r\n        currentSession = null;\r\n        StartFrame sFrame = StartFrame.getInstance();\r\n        sFrame.showGlobalLobby();\r\n    }\r\n\r\n    public void closeConnection() {\r\n        msgReceiver.closeConnection();\r\n    }\r\n\r\n    public String getPlayerName() {\r\n        return playerName;\r\n    }\r\n\r\n    public void setPlayerName(String playerName) {\r\n        this.playerName = playerName;\r\n    }\r\n\r\n    public void requestGlobalScore() {\r\n        msgSender.sendMsg(new InfoRequestMsg(InfoRequestMsg.GET_OVERALL_SCORE));\r\n    }\r\n\r\n    public void setGlobalscores(ArrayList scores) {\r\n        StartFrame.getInstance().setGlobalScore(scores);\r\n    }\r\n\r\n    public void setRoundScore(HashMap<String, Integer> rndscore) {\r\n        logger.info(\"setting round score\");\r\n        StartFrame.getInstance().updateRoundScoreData(rndscore);\r\n    }\r\n\r\n    public void setSessionScore(HashMap<String, Integer> rndscore) {\r\n        logger.info(\"setting session score\");\r\n        StartFrame.getInstance().updateSessionScoreData(rndscore);\r\n    }\r\n\r\n    /**\r\n     * @param i\r\n     */\r\n    public void quitRunningSession(int playerId) {\r\n        getCurrentSession().getCurrentRound().terminateRound();\r\n        sendMsg(new ClientQuitRunningSessionMsg(playerId));\r\n        currentSession = null;\r\n        StartFrame.getInstance().showGlobalLobby();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/client/BomberClientTest1.java",
		"test_prompt": "// BomberClientTest1.java\npackage client;\n\nimport java.io.IOException;\nimport java.net.Socket;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Observable;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport messages.Message;\nimport messages.global.InfoRequestMsg;\nimport messages.global.JoinSessionMsg;\nimport messages.global.MapInfo;\nimport messages.global.SessionDetailsMsg;\nimport messages.round.ClientQuitRunningSessionMsg;\nimport org.apache.log4j.Logger;\nimport client.gui.StartFrame;\nimport client.network.ClientMsgReceiver;\nimport client.network.ClientMsgSender;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BomberClient}.\n* It contains ten unit test cases for the {@link BomberClient#connectToSrv()} method.\n*/\nclass BomberClientTest1 {"
	},
	{
		"original_code": "// GameView.java\n/**\r\n */\r\npackage client.view;\r\n\r\nimport java.awt.Graphics2D;\r\nimport java.awt.geom.AffineTransform;\r\nimport java.util.Vector;\r\nimport org.apache.log4j.Logger;\r\n\r\n/**\r\n * @author Andi\r\n */\r\npublic class GameView {\r\n\r\n    private Vector<GameObjectView> views;\r\n\r\n    private GameCanvas gameCanvas;\r\n\r\n    private OverlayView overlayView;\r\n\r\n    private static boolean displayNames = true;\r\n\r\n    private static final Logger logger = Logger.getLogger(GameView.class);\r\n\r\n    private static final AffineTransform NEUTRAL_TF = AffineTransform.getTranslateInstance(0., 0.);\r\n\r\n    /**\r\n     * @param gameCanvas\r\n     */\r\n    public GameView(GameCanvas gameCanvas) {\r\n        super();\r\n        this.gameCanvas = gameCanvas;\r\n        this.views = new Vector<GameObjectView>();\r\n        this.overlayView = new OverlayView();\r\n    }\r\n\r\n    public void paint() {\r\n        Vector<GameObjectView> removedViews = new Vector<GameObjectView>();\r\n        for (GameObjectView view : views) {\r\n            if (PlayerView.class.isInstance(view)) {\r\n                if (!view.isVisible()) {\r\n                    removedViews.add(view);\r\n                }\r\n            }\r\n            if (PowerUpView.class.isInstance(view)) {\r\n                if (!view.isVisible()) {\r\n                    removedViews.add(view);\r\n                }\r\n            }\r\n            if (TileView.class.isInstance(view)) {\r\n                if (!view.isVisible()) {\r\n                    removedViews.add(view);\r\n                }\r\n            }\r\n            if (BombView.class.isInstance(view)) {\r\n                if (!view.isVisible()) {\r\n                    removedViews.add(view);\r\n                }\r\n            }\r\n        }\r\n        for (GameObjectView view : removedViews) {\r\n            views.remove(view);\r\n        }\r\n        Graphics2D gfx = gameCanvas.getCanvas();\r\n        // AffineTransform preTf = gfx.getTransform();\r\n        int size = views.size();\r\n        for (int i = 0; i < size; i++) {\r\n            View view = views.get(i);\r\n            view.paint(gfx);\r\n        }\r\n        overlayView.paint(gfx);\r\n        gameCanvas.update();\r\n        gfx.setTransform(NEUTRAL_TF);\r\n    }\r\n\r\n    /**\r\n     * @param gameObjectView\r\n     * @return\r\n     * @see java.util.Vector#add(java.lang.Object)\r\n     */\r\n    public boolean addGameObjectView(GameObjectView gameObjectView) {\r\n        return views.add(gameObjectView);\r\n    }\r\n\r\n    /**\r\n     * @param string\r\n     */\r\n    public void setOverlayText(String string) {\r\n        overlayView.setText(string);\r\n    }\r\n\r\n    public void toggleDisplayNames() {\r\n        if (displayNames) {\r\n            displayNames = false;\r\n        } else {\r\n            displayNames = true;\r\n        }\r\n    }\r\n\r\n    public static boolean displayNames() {\r\n        return displayNames;\r\n    }\r\n\r\n    public void resetGfx() {\r\n        Graphics2D gfx = gameCanvas.getCanvas();\r\n        gfx.setTransform(AffineTransform.getRotateInstance(0.));\r\n        gfx.clearRect(0, 0, 800, 600);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/client/view/GameViewTest0.java",
		"test_prompt": "// GameViewTest0.java\npackage client.view;\n\nimport java.awt.Graphics2D;\nimport java.awt.geom.AffineTransform;\nimport java.util.Vector;\nimport org.apache.log4j.Logger;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GameView}.\n* It contains ten unit test cases for the {@link GameView#addGameObjectView(GameObjectView)} method.\n*/\nclass GameViewTest0 {"
	},
	{
		"original_code": "// GameView.java\n/**\r\n */\r\npackage client.view;\r\n\r\nimport java.awt.Graphics2D;\r\nimport java.awt.geom.AffineTransform;\r\nimport java.util.Vector;\r\nimport org.apache.log4j.Logger;\r\n\r\n/**\r\n * @author Andi\r\n */\r\npublic class GameView {\r\n\r\n    private Vector<GameObjectView> views;\r\n\r\n    private GameCanvas gameCanvas;\r\n\r\n    private OverlayView overlayView;\r\n\r\n    private static boolean displayNames = true;\r\n\r\n    private static final Logger logger = Logger.getLogger(GameView.class);\r\n\r\n    private static final AffineTransform NEUTRAL_TF = AffineTransform.getTranslateInstance(0., 0.);\r\n\r\n    /**\r\n     * @param gameCanvas\r\n     */\r\n    public GameView(GameCanvas gameCanvas) {\r\n        super();\r\n        this.gameCanvas = gameCanvas;\r\n        this.views = new Vector<GameObjectView>();\r\n        this.overlayView = new OverlayView();\r\n    }\r\n\r\n    public void paint() {\r\n        Vector<GameObjectView> removedViews = new Vector<GameObjectView>();\r\n        for (GameObjectView view : views) {\r\n            if (PlayerView.class.isInstance(view)) {\r\n                if (!view.isVisible()) {\r\n                    removedViews.add(view);\r\n                }\r\n            }\r\n            if (PowerUpView.class.isInstance(view)) {\r\n                if (!view.isVisible()) {\r\n                    removedViews.add(view);\r\n                }\r\n            }\r\n            if (TileView.class.isInstance(view)) {\r\n                if (!view.isVisible()) {\r\n                    removedViews.add(view);\r\n                }\r\n            }\r\n            if (BombView.class.isInstance(view)) {\r\n                if (!view.isVisible()) {\r\n                    removedViews.add(view);\r\n                }\r\n            }\r\n        }\r\n        for (GameObjectView view : removedViews) {\r\n            views.remove(view);\r\n        }\r\n        Graphics2D gfx = gameCanvas.getCanvas();\r\n        // AffineTransform preTf = gfx.getTransform();\r\n        int size = views.size();\r\n        for (int i = 0; i < size; i++) {\r\n            View view = views.get(i);\r\n            view.paint(gfx);\r\n        }\r\n        overlayView.paint(gfx);\r\n        gameCanvas.update();\r\n        gfx.setTransform(NEUTRAL_TF);\r\n    }\r\n\r\n    /**\r\n     * @param gameObjectView\r\n     * @return\r\n     * @see java.util.Vector#add(java.lang.Object)\r\n     */\r\n    public boolean addGameObjectView(GameObjectView gameObjectView) {\r\n        return views.add(gameObjectView);\r\n    }\r\n\r\n    /**\r\n     * @param string\r\n     */\r\n    public void setOverlayText(String string) {\r\n        overlayView.setText(string);\r\n    }\r\n\r\n    public void toggleDisplayNames() {\r\n        if (displayNames) {\r\n            displayNames = false;\r\n        } else {\r\n            displayNames = true;\r\n        }\r\n    }\r\n\r\n    public static boolean displayNames() {\r\n        return displayNames;\r\n    }\r\n\r\n    public void resetGfx() {\r\n        Graphics2D gfx = gameCanvas.getCanvas();\r\n        gfx.setTransform(AffineTransform.getRotateInstance(0.));\r\n        gfx.clearRect(0, 0, 800, 600);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/client/view/GameViewTest1.java",
		"test_prompt": "// GameViewTest1.java\npackage client.view;\n\nimport java.awt.Graphics2D;\nimport java.awt.geom.AffineTransform;\nimport java.util.Vector;\nimport org.apache.log4j.Logger;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GameView}.\n* It contains ten unit test cases for the {@link GameView#displayNames()} method.\n*/\nclass GameViewTest1 {"
	},
	{
		"original_code": "// GameObjectView.java\n/**\r\n */\r\npackage client.view;\r\n\r\nimport common.GameObject;\r\n\r\n/**\r\n * @author Andi\r\n */\r\npublic abstract class GameObjectView extends View {\r\n\r\n    protected GameObject gameObject;\r\n\r\n    protected final GfxFactory gfxFactory;\r\n\r\n    protected boolean active = true;\r\n\r\n    protected boolean visible = true;\r\n\r\n    /**\r\n     * @param gameObject\r\n     */\r\n    public GameObjectView(GameObject gameObject, GfxFactory gfxFactory) {\r\n        super();\r\n        this.gameObject = gameObject;\r\n        this.gfxFactory = gfxFactory;\r\n    }\r\n\r\n    public boolean isActive() {\r\n        return active;\r\n    }\r\n\r\n    public GameObject getGameObject() {\r\n        return gameObject;\r\n    }\r\n\r\n    public boolean isVisible() {\r\n        return visible;\r\n    }\r\n\r\n    public void setVisible(boolean isVisible) {\r\n        this.visible = isVisible;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/client/view/GameObjectViewTest0.java",
		"test_prompt": "// GameObjectViewTest0.java\npackage client.view;\n\nimport common.GameObject;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GameObjectView}.\n* It contains ten unit test cases for the {@link GameObjectView#isActive()} method.\n*/\nclass GameObjectViewTest0 {"
	},
	{
		"original_code": "// GameObjectView.java\n/**\r\n */\r\npackage client.view;\r\n\r\nimport common.GameObject;\r\n\r\n/**\r\n * @author Andi\r\n */\r\npublic abstract class GameObjectView extends View {\r\n\r\n    protected GameObject gameObject;\r\n\r\n    protected final GfxFactory gfxFactory;\r\n\r\n    protected boolean active = true;\r\n\r\n    protected boolean visible = true;\r\n\r\n    /**\r\n     * @param gameObject\r\n     */\r\n    public GameObjectView(GameObject gameObject, GfxFactory gfxFactory) {\r\n        super();\r\n        this.gameObject = gameObject;\r\n        this.gfxFactory = gfxFactory;\r\n    }\r\n\r\n    public boolean isActive() {\r\n        return active;\r\n    }\r\n\r\n    public GameObject getGameObject() {\r\n        return gameObject;\r\n    }\r\n\r\n    public boolean isVisible() {\r\n        return visible;\r\n    }\r\n\r\n    public void setVisible(boolean isVisible) {\r\n        this.visible = isVisible;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/client/view/GameObjectViewTest1.java",
		"test_prompt": "// GameObjectViewTest1.java\npackage client.view;\n\nimport common.GameObject;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GameObjectView}.\n* It contains ten unit test cases for the {@link GameObjectView#isVisible()} method.\n*/\nclass GameObjectViewTest1 {"
	},
	{
		"original_code": "// Logging.java\npackage logging;\r\n\r\nimport java.text.MessageFormat;\r\nimport java.util.MissingResourceException;\r\nimport java.util.ResourceBundle;\r\nimport org.apache.log4j.*;\r\nimport org.apache.log4j.xml.DOMConfigurator;\r\n\r\n/*\r\n *@author  Tawatchai Siripanya************\r\n * Email dongathome@yahoo.com\r\n * Date 15.04.2008\r\n * <br>\r\n *************************************************\r\n *<p>\r\n *Usage:\r\n *</p>\r\n * ************************************************\r\n * <br>\r\n *1. import logging.*\r\n *<br>\r\n *or import logging.Logging\r\n *<br>\r\n * 2. object declaration\r\n * <br>\r\n * private static Logging logger = Logging.getInstance();  \r\n * <br> \r\n * 3. define your logging level such as INFO,WARN,ERROR ,etc.\r\n * <br>\r\n * Example:\r\n * logger.log( Level.ERROR, this, \"E002\" );\r\n *  Where \r\n * -E002 is your error code  which will be translated to English and German\r\n *  more about the error code will be provided later. *  \r\n * <br>\r\n * <br>  \r\n * more information about  logging levels please have a look at\r\n * http://supportweb.cs.bham.ac.uk/docs/tutorials/docsystem/build/tutorials/log4j/log4j.html\r\n *****************************************************/\r\npublic class Logging {\r\n\r\n    private static final String LOG4J_CONFIG_FILE = \"log4j.properties\";\r\n\r\n    private static final String MEIN_LOGGER_NAME = \"Logging\";\r\n\r\n    private static final String MESSAGES_RESBUNDLE = \"lib/messages\";\r\n\r\n    private static ResourceBundle messagesResBundle;\r\n\r\n    private static Logging meinLogger;\r\n\r\n    private static Logger log4jLogger;\r\n\r\n    /*\r\n\t *  private in order to be Singleton\r\n\t */\r\n    private Logging() {\r\n        init();\r\n    }\r\n\r\n    private synchronized void init() {\r\n        try {\r\n            DOMConfigurator.configureAndWatch(LOG4J_CONFIG_FILE, 60 * 1000);\r\n            log4jLogger = Logger.getLogger(MEIN_LOGGER_NAME);\r\n            messagesResBundle = ResourceBundle.getBundle(MESSAGES_RESBUNDLE);\r\n            log4jLogger.setResourceBundle(messagesResBundle);\r\n        } catch (MissingResourceException ex) {\r\n            System.err.println(\"Error: '\" + MESSAGES_RESBUNDLE + \"'-.properties-Data is missing!\");\r\n        } catch (Exception ex) {\r\n            System.err.println(\"error occurred while initializing the Logger\");\r\n        }\r\n    }\r\n\r\n    /*\r\n\t * Singleton-Instance\r\n\t */\r\n    public static synchronized Logging getInstance() {\r\n        if (meinLogger == null)\r\n            meinLogger = new Logging();\r\n        return meinLogger;\r\n    }\r\n\r\n    public synchronized void log(Level level, Object caller, String id) /*\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t * ,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t * String[]\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t * parms\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t */\r\n    {\r\n        MDC.put(\"clss\", caller.getClass().getName());\r\n        MDC.put(\"id\", id);\r\n        String message = id;\r\n        if (null != messagesResBundle) {\r\n            try {\r\n                message = messagesResBundle.getString(id);\r\n            } catch (MissingResourceException ex) {\r\n                /**/\r\n            }\r\n        }\r\n        /*\r\n\t\t * if( null != parms ) message = MessageFormat.format( message, parms );\r\n\t\t */\r\n        switch(level.toInt()) {\r\n            case Priority.ALL_INT:\r\n            case Priority.DEBUG_INT:\r\n                log4jLogger.debug(message);\r\n                break;\r\n            case Priority.INFO_INT:\r\n                log4jLogger.info(message);\r\n                break;\r\n            case Priority.WARN_INT:\r\n                log4jLogger.warn(message);\r\n                break;\r\n            case Priority.ERROR_INT:\r\n                log4jLogger.error(message);\r\n                break;\r\n            case Priority.FATAL_INT:\r\n                log4jLogger.fatal(message);\r\n                break;\r\n        }\r\n    }\r\n\r\n    public boolean isEnabledFor(Level level) {\r\n        return log4jLogger.isEnabledFor(level);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/logging/LoggingTest0.java",
		"test_prompt": "// LoggingTest0.java\npackage logging;\n\nimport java.text.MessageFormat;\nimport java.util.MissingResourceException;\nimport java.util.ResourceBundle;\nimport org.apache.log4j.*;\nimport org.apache.log4j.xml.DOMConfigurator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Logging}.\n* It contains ten unit test cases for the {@link Logging#getInstance()} method.\n*/\nclass LoggingTest0 {"
	},
	{
		"original_code": "// Logging.java\npackage logging;\r\n\r\nimport java.text.MessageFormat;\r\nimport java.util.MissingResourceException;\r\nimport java.util.ResourceBundle;\r\nimport org.apache.log4j.*;\r\nimport org.apache.log4j.xml.DOMConfigurator;\r\n\r\n/*\r\n *@author  Tawatchai Siripanya************\r\n * Email dongathome@yahoo.com\r\n * Date 15.04.2008\r\n * <br>\r\n *************************************************\r\n *<p>\r\n *Usage:\r\n *</p>\r\n * ************************************************\r\n * <br>\r\n *1. import logging.*\r\n *<br>\r\n *or import logging.Logging\r\n *<br>\r\n * 2. object declaration\r\n * <br>\r\n * private static Logging logger = Logging.getInstance();  \r\n * <br> \r\n * 3. define your logging level such as INFO,WARN,ERROR ,etc.\r\n * <br>\r\n * Example:\r\n * logger.log( Level.ERROR, this, \"E002\" );\r\n *  Where \r\n * -E002 is your error code  which will be translated to English and German\r\n *  more about the error code will be provided later. *  \r\n * <br>\r\n * <br>  \r\n * more information about  logging levels please have a look at\r\n * http://supportweb.cs.bham.ac.uk/docs/tutorials/docsystem/build/tutorials/log4j/log4j.html\r\n *****************************************************/\r\npublic class Logging {\r\n\r\n    private static final String LOG4J_CONFIG_FILE = \"log4j.properties\";\r\n\r\n    private static final String MEIN_LOGGER_NAME = \"Logging\";\r\n\r\n    private static final String MESSAGES_RESBUNDLE = \"lib/messages\";\r\n\r\n    private static ResourceBundle messagesResBundle;\r\n\r\n    private static Logging meinLogger;\r\n\r\n    private static Logger log4jLogger;\r\n\r\n    /*\r\n\t *  private in order to be Singleton\r\n\t */\r\n    private Logging() {\r\n        init();\r\n    }\r\n\r\n    private synchronized void init() {\r\n        try {\r\n            DOMConfigurator.configureAndWatch(LOG4J_CONFIG_FILE, 60 * 1000);\r\n            log4jLogger = Logger.getLogger(MEIN_LOGGER_NAME);\r\n            messagesResBundle = ResourceBundle.getBundle(MESSAGES_RESBUNDLE);\r\n            log4jLogger.setResourceBundle(messagesResBundle);\r\n        } catch (MissingResourceException ex) {\r\n            System.err.println(\"Error: '\" + MESSAGES_RESBUNDLE + \"'-.properties-Data is missing!\");\r\n        } catch (Exception ex) {\r\n            System.err.println(\"error occurred while initializing the Logger\");\r\n        }\r\n    }\r\n\r\n    /*\r\n\t * Singleton-Instance\r\n\t */\r\n    public static synchronized Logging getInstance() {\r\n        if (meinLogger == null)\r\n            meinLogger = new Logging();\r\n        return meinLogger;\r\n    }\r\n\r\n    public synchronized void log(Level level, Object caller, String id) /*\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t * ,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t * String[]\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t * parms\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t */\r\n    {\r\n        MDC.put(\"clss\", caller.getClass().getName());\r\n        MDC.put(\"id\", id);\r\n        String message = id;\r\n        if (null != messagesResBundle) {\r\n            try {\r\n                message = messagesResBundle.getString(id);\r\n            } catch (MissingResourceException ex) {\r\n                /**/\r\n            }\r\n        }\r\n        /*\r\n\t\t * if( null != parms ) message = MessageFormat.format( message, parms );\r\n\t\t */\r\n        switch(level.toInt()) {\r\n            case Priority.ALL_INT:\r\n            case Priority.DEBUG_INT:\r\n                log4jLogger.debug(message);\r\n                break;\r\n            case Priority.INFO_INT:\r\n                log4jLogger.info(message);\r\n                break;\r\n            case Priority.WARN_INT:\r\n                log4jLogger.warn(message);\r\n                break;\r\n            case Priority.ERROR_INT:\r\n                log4jLogger.error(message);\r\n                break;\r\n            case Priority.FATAL_INT:\r\n                log4jLogger.fatal(message);\r\n                break;\r\n        }\r\n    }\r\n\r\n    public boolean isEnabledFor(Level level) {\r\n        return log4jLogger.isEnabledFor(level);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/57_hft-bomberman/src/main/java/logging/LoggingTest1.java",
		"test_prompt": "// LoggingTest1.java\npackage logging;\n\nimport java.text.MessageFormat;\nimport java.util.MissingResourceException;\nimport java.util.ResourceBundle;\nimport org.apache.log4j.*;\nimport org.apache.log4j.xml.DOMConfigurator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Logging}.\n* It contains ten unit test cases for the {@link Logging#isEnabledFor(Level)} method.\n*/\nclass LoggingTest1 {"
	}
]