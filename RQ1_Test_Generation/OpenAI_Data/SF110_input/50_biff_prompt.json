[
	{
		"original_code": "// Scanner.java\n/*\"Pascal interpreter written in Java\" jest przeznaczony do \n interpretacji kodu napisanego w j�zyku Pascal.\nCopyright (C) 2004/2005 Bartyna Waldemar, Faderewski Marek,\nFedorczyk �ukasz, Iwanowski Wojciech.\nNiniejszy program jest wolnym oprogramowaniem; mo�esz go \nrozprowadza� dalej i/lub modyfikowa� na warunkach Powszechnej\nLicencji Publicznej GNU, wydanej przez Fundacj� Wolnego\nOprogramowania - wed�ug wersji 2-giej tej Licencji lub kt�rej�\nz p�niejszych wersji. \n\nNiniejszy program rozpowszechniany jest z nadziej�, i� b�dzie on \nu�yteczny - jednak BEZ JAKIEJKOLWIEK GWARANCJI, nawet domy�lnej \ngwarancji PRZYDATNO�CI HANDLOWEJ albo PRZYDATNO�CI DO OKRE�LONYCH \nZASTOSOWA�. W celu uzyskania bli�szych informacji - Powszechna \nLicencja Publiczna GNU. \n\nZ pewno�ci� wraz z niniejszym programem otrzyma�e� te� egzemplarz \nPowszechnej Licencji Publicznej GNU (GNU General Public License);\nje�li nie - napisz do Free Software Foundation, Inc., 675 Mass Ave,\nCambridge, MA 02139, USA.\n*/\nimport java.io.*;\nimport java.util.ArrayList;\n\npublic class Scanner {\n\n    public ArrayList lexems = new ArrayList();\n\n    // variables for validation process\n    ArrayList vars = new ArrayList();\n\n    ArrayList var_types = new ArrayList();\n\n    ArrayList var_vals = new ArrayList();\n\n    // position in Advenced Lexems Array\n    private int pos = 0;\n\n    // position during instruction evaluating\n    private int place = 0;\n\n    private int main_begin = 0;\n\n    public Scanner(String filename) throws Exception {\n        File file = new File(filename);\n        FileInputStream filein = new FileInputStream(file);\n        // array of 'lexem' objects\n        lexems = new ArrayList();\n        // current lexem\n        StringBuffer value = new StringBuffer();\n        // current type of lexem\n        byte type = 0;\n        // current line\n        int line = 1;\n        // current column\n        int column = 1;\n        // where the lexem began\n        int began = 1;\n        // where the String began\n        int sline = 1;\n        int bite = filein.read();\n        while (bite != -1) {\n            // if bite is a quotation mark\n            if (bite == 34) {\n                if (type != 0) {\n                    lexems.add(new Lexem(value, type, line, began));\n                    value = new StringBuffer();\n                }\n                if (type != 5) {\n                    type = 5;\n                    began = column;\n                    sline = line;\n                } else\n                    type = 0;\n            } else if (type == 5) {\n                value.append((char) bite);\n                if (bite == 13) {\n                    line++;\n                    column = -1;\n                }\n            } else // if bite is a digit\n            if ((bite >= 48) && (bite <= 57)) {\n                if (type == 0) {\n                    type = 1;\n                    began = column;\n                }\n                value.append((char) bite);\n            } else // if bite is a letter\n            if (((bite >= 65) && (bite <= 90)) || ((bite >= 97) && (bite <= 122))) {\n                if (type == 0) {\n                    type = 3;\n                    began = column;\n                    value.append((char) bite);\n                } else if (type == 3)\n                    value.append((char) bite);\n                else {\n                    type = 7;\n                    break;\n                }\n            } else // if bite is a sign\n            if (((bite >= 40) && (bite <= 45)) || (bite == 47) || ((bite >= 58) && (bite <= 62))) {\n                if (type != 0) {\n                    lexems.add(new Lexem(value, type, line, began));\n                    type = 0;\n                    value = new StringBuffer();\n                }\n                lexems.add(new Lexem(bite, 4, line, column));\n            } else // if bite is a dot\n            if (bite == 46)\n                if (type != 0)\n                    if (type == 3)\n                        if (((value.toString()).toUpperCase()).equals(\"END\")) {\n                            lexems.add(new Lexem(\"END.\", (byte) 3, line, began));\n                            type = 0;\n                            value = new StringBuffer();\n                        } else {\n                            type = 8;\n                            break;\n                        }\n                    else if (type == 1) {\n                        type = 2;\n                        value.append('.');\n                    } else {\n                        type = 8;\n                        break;\n                    }\n                else {\n                    type = 8;\n                    break;\n                }\n            else // if bite is a separator\n            if ((bite == 9) || (bite == 32) || (bite == 13) || (bite == 10)) {\n                if (type != 0) {\n                    lexems.add(new Lexem(value, type, line, began));\n                    type = 0;\n                    value = new StringBuffer();\n                }\n                if (bite == 13) {\n                    line++;\n                    column = -1;\n                }\n            } else // bite is not allowed character\n            {\n                type = 9;\n                break;\n            }\n            bite = filein.read();\n            if ((bite == -1) && (type == 5))\n                type = 6;\n            else if (bite == -1)\n                if (type != 0) {\n                    lexems.add(new Lexem(value, type, line, began));\n                    type = 0;\n                    value = new StringBuffer();\n                }\n            column++;\n        }\n        // error handling\n        if (type == 6)\n            System.out.println(\"ERROR: String not closed ! \" + \"line: \" + sline + \", column: \" + began);\n        else if (type == 7)\n            System.out.println(\"ERROR: letter joined with number ! \" + \"line: \" + line + \", column: \" + column);\n        else if (type == 8)\n            System.out.println(\"ERROR: dot in wrong place ! \" + \"line: \" + line + \", column: \" + column);\n        else if (type == 9)\n            System.out.println(\"ERROR: illegal character !: \" + (char) bite + \" line: \" + line + \", column: \" + column);\n        else {\n            // if everything is OK\n            //\t\t\t\t\tprintLexems(lexems);\n            // advenced scunning (father, deeper clasification)\n            ArrayList AdvL = advScanning(lexems);\n            //                \tprintAdvLexems(AdvL);\n            // validation process\n            String tmp_result = checkStructure(AdvL);\n            System.out.println(tmp_result);\n            if (tmp_result.equals(\"No errors !\")) {\n                System.out.println(\"===================\");\n                // variables initialization\n                initializeVars();\n                pos = main_begin;\n                // interpretation process\n                ArrayList ExecL = interBody(AdvL);\n                // execution\n                execute(ExecL);\n                /*    \n\tSystem.out.println(\"IAL Size = \" + ExecL.size());  \n\tfor (int i = 0; i < ExecL.size(); i++) {\n\t\tSystem.out.println(((ExecLexem)ExecL.get(i)).type);\n\t\tSystem.out.println(((ExecLexem)ExecL.get(i)).variable);\n\t\tSystem.out.println(\"If TRUE SIZE = \" + ((ExecLexem)ExecL.get(i)).\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiftrue.size());\n\t\tfor (int j = 0; j < ((ExecLexem)ExecL.get(i)).lexems.length; j++)\n\t\t\tSystem.out.println(((ExecLexem)ExecL.get(i)).lexems[j].value);\n\t} \t*/\n            }\n        }\n    }\n\n    // Scanner()\n    public void printLexems(ArrayList lex) {\n        System.out.println(\"\\nLEXEMS: \" + lex.size());\n        System.out.println(\"VALUE   TYPE   LINE   COLUMN\");\n        Object[] lexems = lex.toArray();\n        for (int i = 0; i < lexems.length; i++) {\n            Lexem lexem = (Lexem) lexems[i];\n            System.out.println(lexem.value + \"   \" + lexem.type + \"   \" + lexem.line + \"   \" + lexem.column);\n        }\n        System.out.println();\n    }\n\n    // printLexems(ArrayList)\n    public void printAdvLexems(ArrayList AdvLex) {\n        System.out.println(\"\\nLEXEMS: \" + AdvLex.size());\n        System.out.println(\"VALUE   CODE   LCATEGORY   \" + \"HCATEGORY   LINE   COLUMN\");\n        Object[] AdvLexems = AdvLex.toArray();\n        for (int i = 0; i < AdvLexems.length; i++) {\n            AdvLexem advlexem = (AdvLexem) AdvLexems[i];\n            System.out.println(advlexem.value + \"   \" + advlexem.code + \"   \" + advlexem.lcategory + \"   \" + advlexem.hcategory + \"   \" + advlexem.line + \"   \" + advlexem.column);\n        }\n        System.out.println();\n    }\n\n    // printLexems(ArrayList)\n    public ArrayList advScanning(ArrayList lexems) {\n        ArrayList AdvLexems = new ArrayList();\n        String value = \"\";\n        Codes codes = new Codes();\n        codes.fillLists();\n        Lexem lexem = null;\n        byte code = 0;\n        byte lcategory = 0;\n        byte hcategory = 0;\n        int size = lexems.size();\n        int i = 0;\n        while (i < size) {\n            lexem = (Lexem) lexems.get(i);\n            // if lexem is a word\n            if (lexem.type == codes.STRING)\n                AdvLexems.add(new AdvLexem(lexem.value, codes.STRING, codes.STRING, codes.STRING, lexem.line, lexem.column));\n            else if (lexem.type == codes.WORD) {\n                hcategory = codes.WORD;\n                code = codes.getKeywordCode(lexem.value);\n                if (code == codes.VARIABLE)\n                    lcategory = codes.VARIABLE;\n                else if ((code >= codes.AND) && (code <= codes.OR))\n                    lcategory = codes.LOPERATOR;\n                else if ((code >= codes.INTEGER) && (code <= codes.BOOLEAN))\n                    lcategory = codes.VTYPE;\n                else\n                    lcategory = codes.KEYWORD;\n                AdvLexems.add(new AdvLexem(lexem.value, code, lcategory, hcategory, lexem.line, lexem.column));\n            } else // if lexem is a sign\n            if (lexem.type == codes.SIGN) {\n                value = lexem.value;\n                ;\n                hcategory = codes.SIGN;\n                code = codes.getSignCode(lexem.value);\n                if ((code >= codes.COLON) && (code <= codes.QUOTATION)) {\n                    lcategory = codes.OOPERATOR;\n                    if (lexem.value.equals(\":\"))\n                        if ((i + 1) < size)\n                            if (((Lexem) lexems.get(i + 1)).value.equals(\"=\")) {\n                                code = codes.ASOCIATE;\n                                value = \":=\";\n                                i++;\n                            }\n                } else if ((code >= codes.E) && (code <= codes.LE)) {\n                    lcategory = codes.ROPERATOR;\n                    if (lexem.value.equals(\"<\"))\n                        if ((i + 1) < size) {\n                            if (((Lexem) lexems.get(i + 1)).value.equals(\"=\")) {\n                                code = codes.LE;\n                                value = \"<=\";\n                                i++;\n                            }\n                            if (((Lexem) lexems.get(i + 1)).value.equals(\">\")) {\n                                code = codes.NE;\n                                value = \"<>\";\n                                i++;\n                            }\n                        } else if (lexem.value.equals(\">\"))\n                            if ((i + 1) < size)\n                                if (((Lexem) lexems.get(i + 1)).value.equals(\"=\")) {\n                                    code = codes.GE;\n                                    value = \">=\";\n                                    i++;\n                                }\n                } else if ((code >= codes.PLUS) && (code <= codes.DIV)) {\n                    lcategory = codes.AOPERATOR;\n                }\n                AdvLexems.add(new AdvLexem(value, code, lcategory, hcategory, lexem.line, lexem.column));\n            } else\n                AdvLexems.add(new AdvLexem(lexem.value, lexem.type, codes.NUMBER, codes.WORD, lexem.line, lexem.column));\n            i++;\n        }\n        return AdvLexems;\n    }\n\n    // advScanning()\n    private String errorMess(String expected, AdvLexem found) {\n        return (\"expected: \" + expected + \"\\n   found: \" + found.value + \"\\n   line: \" + found.line + \"\\n   column: \" + found.column);\n    }\n\n    // errorMess()\n    private String errorMess(String expected) {\n        return (\"expected: \" + expected + \"   nothing found\");\n    }\n\n    // errorMess()\n    // checks if there is a lexem of given Code\n    private String checkC(String s, byte code, ArrayList AL) {\n        if (pos < AL.size()) {\n            AdvLexem al = (AdvLexem) AL.get(pos);\n            if (al.code != code)\n                return errorMess(s, al);\n        } else\n            return errorMess(s);\n        return \"\";\n    }\n\n    // checkC()\n    private String checkC(String s, byte code, ArrayList AL, int which) {\n        if (which < AL.size()) {\n            AdvLexem al = (AdvLexem) AL.get(which);\n            if (al.code != code)\n                return errorMess(s, al);\n        } else\n            return errorMess(s);\n        return \"\";\n    }\n\n    // checkC()\n    // checks if there is a lexem of given Lower category\n    private String checkL(String s, byte code, ArrayList AL) {\n        if (pos < AL.size()) {\n            AdvLexem al = (AdvLexem) AL.get(pos);\n            if (al.lcategory != code)\n                return errorMess(s, al);\n        } else\n            return errorMess(s);\n        return \"\";\n    }\n\n    // checkL()\n    // mmmmmmmmmmmmmmmmmmm\tVALIDATION\tmmmmmmmmmmmmmmmmmmmmmmmmmmm\n    public String checkStructure(ArrayList AL) {\n        Codes codes = new Codes();\n        codes.fillLists();\n        String result = \"\";\n        AdvLexem al;\n        int size = AL.size();\n        result = checkC(\"PROGRAM\", codes.PROGRAM, AL);\n        if (!(result.equals(\"\")))\n            return result;\n        pos++;\n        result = checkC(\"VARIABLE\", codes.VARIABLE, AL);\n        if (!(result.equals(\"\")))\n            return result;\n        pos++;\n        result = checkC(\"SEMICOLON\", codes.SEMICOLON, AL);\n        if (!(result.equals(\"\")))\n            return result;\n        pos++;\n        result = checkC(\"VAR\", codes.VAR, AL);\n        if (!(result.equals(\"\"))) {\n            result = checkC(\"VAR or BEGIN\", codes.BEGIN, AL);\n            if (!(result.equals(\"\")))\n                return result;\n        }\n        if ((((AdvLexem) AL.get(pos)).value).equals(\"VAR\")) {\n            pos++;\n            result = checkVAR(AL);\n            if (!(result.equals(\"\")))\n                return result;\n        }\n        // now we check if there is END. at the end of the program\n        if (AL.size() - 1 > pos) {\n            result = checkC(\"END.\", Codes.END_DOT, AL, AL.size() - 1);\n            if (!(result.equals(\"\")))\n                return result;\n        } else\n            return \"expected: END. at the end of program\";\n        // now we check if all VARIABLES are declared\n        for (int i = pos + 1; i < AL.size() - 2; i++) {\n            al = (AdvLexem) (AL.get(i));\n            if (al.code == Codes.VARIABLE)\n                if (!(vars.contains(al.value)))\n                    return \"cannot resolve symbol variable \" + al.value + \"\\n   line: \" + al.line + \"\\n   column: \" + al.column;\n        }\n        pos++;\n        main_begin = pos;\n        result = checkBody(AL);\n        /*\n//testing...\nSystem.out.println(\"Position = \" + pos);\nal = (AdvLexem)AL.get(pos);\nSystem.out.println(\"Lexem value = \" + al.value);\n*/\n        if (!(result.equals(\"\")))\n            return result;\n        return \"No errors !\";\n    }\n\n    // checkStructure\n    private String checkVAR(ArrayList AL) {\n        byte var_count = 0;\n        String result = \"\";\n        AdvLexem al = null;\n        // if BEGIN appears changes to TRUE\n        boolean finish_b = false;\n        // if there is no COMMA changes to TRUE\n        boolean finish_c = false;\n        while (!finish_b) {\n            result = checkC(\"BEGIN\", Codes.BEGIN, AL);\n            // if there is no BEGIN yet\n            if (!result.equals(\"\")) {\n                result = checkC(\"VARIABLE\", Codes.VARIABLE, AL);\n                // if there is a VARIABLE\n                if (!result.equals(\"\"))\n                    return result;\n                al = (AdvLexem) AL.get(pos);\n                if ((((AdvLexem) AL.get(1)).value).equals(al.value))\n                    return \"VARIABLE is already used as a neme of the program\" + \"\\n   line: \" + al.line + \"\\n   column: \" + al.column;\n                if (vars.contains(al.value))\n                    return (\"VARIABLE already declared: \" + al.value + \"\\n   line: \" + al.line + \"\\n   column: \" + al.column);\n                vars.add(al.value);\n                var_count++;\n                finish_c = false;\n                while (!finish_c) {\n                    pos++;\n                    result = checkC(\"COMMA\", Codes.COMMA, AL);\n                    if (result.equals(\"\")) {\n                        pos++;\n                        result = checkC(\"VARIABLE\", Codes.VARIABLE, AL);\n                        if (!result.equals(\"\"))\n                            return result;\n                        al = (AdvLexem) AL.get(pos);\n                        if ((((AdvLexem) AL.get(1)).value).equals(al.value))\n                            return \"VARIABLE is already used as a neme \" + \"of the program\" + \"\\n   line: \" + al.line + \"\\n   column: \" + al.column;\n                        if (vars.contains(al.value))\n                            return (\"VARIABLE already declared: \" + al.value + \"\\n   line: \" + al.line + \"\\n   column: \" + al.column);\n                        vars.add(al.value);\n                        var_count++;\n                    } else\n                        finish_c = true;\n                }\n                // while\n                result = checkC(\"COLON\", Codes.COLON, AL);\n                if (!result.equals(\"\"))\n                    return result;\n                pos++;\n                result = checkL(\"VARIABLE TYPE\", Codes.VTYPE, AL);\n                if (!result.equals(\"\"))\n                    return result;\n                byte code = ((AdvLexem) AL.get(pos)).code;\n                for (byte i = 0; i < var_count; i++) var_types.add(new Integer(code));\n                var_count = 0;\n                pos++;\n                result = checkC(\"SEMICOLON\", Codes.SEMICOLON, AL);\n                if (!result.equals(\"\"))\n                    return result;\n                pos++;\n            } else\n                finish_b = true;\n        }\n        // while\n        return \"\";\n    }\n\n    // checkVAR()\n    private String checkIASSOC(ArrayList AL) {\n        String result = \"\";\n        AdvLexem al = null;\n        // brackets count\n        byte b_count = 0;\n        // finish if no more brackets\n        boolean finish_b = false;\n        while (!finish_b) {\n            result = checkC(\"VALUE\", Codes.LBRACKET, AL);\n            if (!result.equals(\"\"))\n                finish_b = true;\n            else {\n                b_count++;\n                pos++;\n            }\n        }\n        result = checkC(\"VALUE\", Codes.MINUS, AL);\n        if (result.equals(\"\")) {\n            pos++;\n            result = checkC(\"INTEGER NUMBER\", Codes.INUMBER, AL);\n            if (result.equals(\"\")) {\n                al = (AdvLexem) AL.get(pos);\n                AL.set(pos - 1, new AdvLexem(\"-\" + al.value, al.code, al.lcategory, al.hcategory, al.line, al.column));\n                AL.remove(pos);\n            } else\n                return result;\n        } else {\n            result = checkC(\"INTEGER VALUE\", Codes.INUMBER, AL);\n            if (!result.equals(\"\")) {\n                result = checkC(\"INTEGER VARIABLE\", Codes.VARIABLE, AL);\n                if (!result.equals(\"\"))\n                    return result;\n                else {\n                    al = (AdvLexem) AL.get(pos);\n                    int tmp = vars.indexOf(al.value);\n                    if (!(((Integer) var_types.get(tmp)).equals(new Integer(Codes.INTEGER)))) {\n                        al = (AdvLexem) AL.get(pos);\n                        return \"INTEGER VARIABLE expected \" + \"\\n   found: \" + al.value + \"\\n   line: \" + al.line + \"\\n   column: \" + al.column;\n                    } else\n                        pos++;\n                }\n            } else\n                pos++;\n        }\n        finish_b = false;\n        while (!finish_b) {\n            result = checkC(\"OPERATOR\", Codes.RBRACKET, AL);\n            if (!result.equals(\"\"))\n                finish_b = true;\n            else {\n                if (b_count > 0) {\n                    b_count--;\n                    pos++;\n                } else {\n                    al = (AdvLexem) AL.get(pos);\n                    return \"RIGHT BRACKET not opened\" + \"\\n   line: \" + al.line + \"\\n   column: \" + al.column;\n                }\n            }\n        }\n        // if there is no operator\n        boolean finish_o = false;\n        while (!finish_o) {\n            result = checkL(\"ARITHMETIC OPERATOR\", Codes.AOPERATOR, AL);\n            if (!result.equals(\"\"))\n                finish_o = true;\n            else {\n                pos++;\n                finish_b = false;\n                while (!finish_b) {\n                    result = checkC(\"VALUE\", Codes.LBRACKET, AL);\n                    if (!result.equals(\"\"))\n                        finish_b = true;\n                    else {\n                        b_count++;\n                        pos++;\n                    }\n                }\n                result = checkC(\"VALUE\", Codes.MINUS, AL);\n                if (result.equals(\"\")) {\n                    pos++;\n                    result = checkC(\"INTEGER NUMBER\", Codes.INUMBER, AL);\n                    if (result.equals(\"\")) {\n                        al = (AdvLexem) AL.get(pos);\n                        AL.set(pos - 1, new AdvLexem(\"-\" + al.value, al.code, al.lcategory, al.hcategory, al.line, al.column));\n                        AL.remove(pos);\n                    } else\n                        return result;\n                } else {\n                    result = checkC(\"INTEGER VALUE\", Codes.INUMBER, AL);\n                    if (!result.equals(\"\")) {\n                        result = checkC(\"INTEGER VARIABLE\", Codes.VARIABLE, AL);\n                        if (!result.equals(\"\"))\n                            return result;\n                        else {\n                            al = (AdvLexem) AL.get(pos);\n                            int tmp = vars.indexOf(al.value);\n                            if (!(((Integer) var_types.get(tmp)).equals(new Integer(Codes.INTEGER)))) {\n                                al = (AdvLexem) AL.get(pos);\n                                return \"INTEGER VARIABLE expected \" + \"\\n   found: \" + al.value + \"\\n   line: \" + al.line + \"\\n   column: \" + al.column;\n                            } else\n                                pos++;\n                        }\n                    } else\n                        pos++;\n                }\n                finish_b = false;\n                while (!finish_b) {\n                    result = checkC(\"OPERATOR\", Codes.RBRACKET, AL);\n                    if (!result.equals(\"\"))\n                        finish_b = true;\n                    else {\n                        if (b_count > 0) {\n                            b_count--;\n                            pos++;\n                        } else {\n                            al = (AdvLexem) AL.get(pos);\n                            return \"RIGHT BRACKET not opened\" + \"\\n   line: \" + al.line + \"\\n   column: \" + al.column;\n                        }\n                    }\n                }\n            }\n        }\n        return \"\";\n    }\n\n    // checkIASSOC()\n    private String checkRASSOC(ArrayList AL) {\n        String result = \"\";\n        AdvLexem al = null;\n        // brackets count\n        byte b_count = 0;\n        // finish if no more brackets\n        boolean finish_b = false;\n        while (!finish_b) {\n            result = checkC(\"VALUE\", Codes.LBRACKET, AL);\n            if (!result.equals(\"\"))\n                finish_b = true;\n            else {\n                b_count++;\n                pos++;\n            }\n        }\n        result = checkC(\"VALUE\", Codes.MINUS, AL);\n        if (result.equals(\"\")) {\n            pos++;\n            result = checkC(\"INTEGER OR REAL NUMBER\", Codes.INUMBER, AL);\n            if ((result.equals(\"\")) || (checkC(\"\", Codes.RNUMBER, AL).equals(\"\"))) {\n                al = (AdvLexem) AL.get(pos);\n                AL.set(pos - 1, new AdvLexem(\"-\" + al.value, al.code, al.lcategory, al.hcategory, al.line, al.column));\n                AL.remove(pos);\n            } else\n                return result;\n        } else {\n            result = checkC(\"\", Codes.INUMBER, AL);\n            if (!((result.equals(\"\")) || (checkC(\"\", Codes.RNUMBER, AL).equals(\"\")))) {\n                result = checkC(\"INTEGER OR REAL VARIABLE\", Codes.VARIABLE, AL);\n                if (!result.equals(\"\"))\n                    return result;\n                else {\n                    al = (AdvLexem) AL.get(pos);\n                    int tmp = vars.indexOf(al.value);\n                    int type = ((Integer) var_types.get(tmp)).intValue();\n                    if (!((type == Codes.INTEGER) || (type == Codes.REAL))) {\n                        al = (AdvLexem) AL.get(pos);\n                        return \"INTEGER OR REAL VARIABLE expected \" + \"\\n   found: \" + al.value + \"\\n   line: \" + al.line + \"\\n   column: \" + al.column;\n                    } else\n                        pos++;\n                }\n            } else\n                pos++;\n        }\n        finish_b = false;\n        while (!finish_b) {\n            result = checkC(\"OPERATOR\", Codes.RBRACKET, AL);\n            if (!result.equals(\"\"))\n                finish_b = true;\n            else {\n                if (b_count > 0) {\n                    b_count--;\n                    pos++;\n                } else {\n                    al = (AdvLexem) AL.get(pos);\n                    return \"RIGHT BRACKET not opened\" + \"\\n   line: \" + al.line + \"\\n   column: \" + al.column;\n                }\n            }\n        }\n        // if there is no operator\n        boolean finish_o = false;\n        while (!finish_o) {\n            result = checkL(\"closing BRACKET\", Codes.AOPERATOR, AL);\n            if (!result.equals(\"\")) {\n                finish_o = true;\n                if (b_count > 0)\n                    return result;\n            } else {\n                pos++;\n                finish_b = false;\n                while (!finish_b) {\n                    result = checkC(\"VALUE\", Codes.LBRACKET, AL);\n                    if (!result.equals(\"\"))\n                        finish_b = true;\n                    else {\n                        b_count++;\n                        pos++;\n                    }\n                }\n                result = checkC(\"VALUE\", Codes.MINUS, AL);\n                if (result.equals(\"\")) {\n                    pos++;\n                    result = checkC(\"INTEGER OR REAL NUMBER\", Codes.INUMBER, AL);\n                    if ((result.equals(\"\")) || (checkC(\"\", Codes.RNUMBER, AL).equals(\"\"))) {\n                        al = (AdvLexem) AL.get(pos);\n                        AL.set(pos - 1, new AdvLexem(\"-\" + al.value, al.code, al.lcategory, al.hcategory, al.line, al.column));\n                        AL.remove(pos);\n                    } else\n                        return result;\n                } else {\n                    result = checkC(\"\", Codes.INUMBER, AL);\n                    if (!((result.equals(\"\")) || (checkC(\"\", Codes.RNUMBER, AL).equals(\"\")))) {\n                        result = checkC(\"INTEGER OR REAL VARIABLE\", Codes.VARIABLE, AL);\n                        if (!result.equals(\"\"))\n                            return result;\n                        else {\n                            al = (AdvLexem) AL.get(pos);\n                            int tmp = vars.indexOf(al.value);\n                            int type = ((Integer) var_types.get(tmp)).intValue();\n                            if (!((type == Codes.INTEGER) || (type == Codes.REAL))) {\n                                al = (AdvLexem) AL.get(pos);\n                                return \"INTEGER OR REAL VARIABLE expected \" + \"\\n   found: \" + al.value + \"\\n   line: \" + al.line + \"\\n   column: \" + al.column;\n                            } else\n                                pos++;\n                        }\n                    } else\n                        pos++;\n                }\n                finish_b = false;\n                while (!finish_b) {\n                    result = checkC(\"OPERATOR\", Codes.RBRACKET, AL);\n                    if (!result.equals(\"\"))\n                        finish_b = true;\n                    else {\n                        if (b_count > 0) {\n                            b_count--;\n                            pos++;\n                        } else {\n                            al = (AdvLexem) AL.get(pos);\n                            return \"RIGHT BRACKET not opened\" + \"\\n   line: \" + al.line + \"\\n   column: \" + al.column;\n                        }\n                    }\n                }\n            }\n        }\n        return \"\";\n    }\n\n    // checkRASSOC()\n    private String checkLEXPR(ArrayList AL) {\n        String result = \"\";\n        AdvLexem al = null;\n        // brackets count\n        byte b_count = 0;\n        boolean finish_o = false;\n        boolean finish_n = false;\n        boolean finish_b = false;\n        while (!finish_n) {\n            finish_b = false;\n            while (!finish_b) {\n                result = checkC(\"VALUE\", Codes.LBRACKET, AL);\n                if (!result.equals(\"\"))\n                    finish_b = true;\n                else {\n                    b_count++;\n                    pos++;\n                }\n            }\n            result = checkC(\"NOT\", Codes.NOT, AL);\n            if (!result.equals(\"\"))\n                finish_n = true;\n            else\n                pos++;\n        }\n        result = checkLEXPRNElem(AL);\n        if (result.equals(\"\")) {\n            result = checkL(\"RELATION OPERATOR\", Codes.ROPERATOR, AL);\n            if (!result.equals(\"\"))\n                return result;\n            else {\n                pos++;\n                result = checkLEXPRNElem(AL);\n                if (!result.equals(\"\"))\n                    return result;\n            }\n        } else {\n            result = checkLEXPRLElem(AL);\n            if (!result.equals(\"\"))\n                return result;\n        }\n        finish_b = false;\n        while (!finish_b) {\n            result = checkC(\"OPERATOR\", Codes.RBRACKET, AL);\n            if (!result.equals(\"\"))\n                finish_b = true;\n            else {\n                if (b_count > 0) {\n                    b_count--;\n                    pos++;\n                } else {\n                    al = (AdvLexem) AL.get(pos);\n                    return \"RIGHT BRACKET not opened\" + \"\\n   line: \" + al.line + \"\\n   column: \" + al.column;\n                }\n            }\n        }\n        finish_o = false;\n        while (!finish_o) {\n            result = checkL(\"closing BRACKET\", Codes.LOPERATOR, AL);\n            if (!result.equals(\"\")) {\n                finish_o = true;\n                if (b_count > 0)\n                    return result;\n            } else {\n                pos++;\n                finish_n = false;\n                while (!finish_n) {\n                    finish_b = false;\n                    while (!finish_b) {\n                        result = checkC(\"VALUE\", Codes.LBRACKET, AL);\n                        if (!result.equals(\"\"))\n                            finish_b = true;\n                        else {\n                            b_count++;\n                            pos++;\n                        }\n                    }\n                    result = checkC(\"NOT\", Codes.NOT, AL);\n                    if (!result.equals(\"\"))\n                        finish_n = true;\n                    else\n                        pos++;\n                }\n                result = checkLEXPRNElem(AL);\n                if (result.equals(\"\")) {\n                    result = checkL(\"RELATION OPERATOR\", Codes.ROPERATOR, AL);\n                    if (!result.equals(\"\"))\n                        return result;\n                    else {\n                        pos++;\n                        result = checkLEXPRNElem(AL);\n                        if (!result.equals(\"\"))\n                            return result;\n                    }\n                } else {\n                    result = checkLEXPRLElem(AL);\n                    if (!result.equals(\"\"))\n                        return result;\n                }\n                finish_b = false;\n                while (!finish_b) {\n                    result = checkC(\"OPERATOR\", Codes.RBRACKET, AL);\n                    if (!result.equals(\"\"))\n                        finish_b = true;\n                    else {\n                        if (b_count > 0) {\n                            b_count--;\n                            pos++;\n                        } else {\n                            al = (AdvLexem) AL.get(pos);\n                            return \"RIGHT BRACKET not opened\" + \"\\n   line: \" + al.line + \"\\n   column: \" + al.column;\n                        }\n                    }\n                }\n            }\n        }\n        return \"\";\n    }\n\n    // checkLEXPR()\n    private String checkWRITE(ArrayList AL) {\n        String result = \"\";\n        AdvLexem al = null;\n        result = checkC(\"LEFT BRACKET\", Codes.LBRACKET, AL);\n        if (!result.equals(\"\"))\n            return result;\n        pos++;\n        result = checkC(\"STRING or VARIABLE\", Codes.STRING, AL);\n        if (!(result.equals(\"\") || (checkC(\"\", Codes.VARIABLE, AL)).equals(\"\")))\n            return result;\n        pos++;\n        boolean finish_c = false;\n        while (!finish_c) {\n            result = checkC(\"COMMA\", Codes.COMMA, AL);\n            if (!result.equals(\"\"))\n                finish_c = true;\n            else {\n                pos++;\n                result = checkC(\"STRING or VARIABLE\", Codes.STRING, AL);\n                if (!(result.equals(\"\") || (checkC(\"\", Codes.VARIABLE, AL)).equals(\"\")))\n                    return result;\n                else\n                    pos++;\n            }\n        }\n        result = checkC(\"RIGHT BRACKET\", Codes.RBRACKET, AL);\n        if (!result.equals(\"\"))\n            return result;\n        pos++;\n        return \"\";\n    }\n\n    // checkWRITE()\n    private String checkREAD(ArrayList AL) {\n        String result = \"\";\n        AdvLexem al = null;\n        result = checkC(\"LEFT BRACKET\", Codes.LBRACKET, AL);\n        if (!result.equals(\"\"))\n            return result;\n        pos++;\n        result = checkC(\"VARIABLE\", Codes.VARIABLE, AL);\n        if (!result.equals(\"\"))\n            return result;\n        pos++;\n        result = checkC(\"RIGHT BRACKET\", Codes.RBRACKET, AL);\n        if (!result.equals(\"\"))\n            return result;\n        pos++;\n        return \"\";\n    }\n\n    // checkREAD()\n    //mmmmmmmmmmmmmmmmmm\tMAIN VALIDATOR   mmmmmmmmmmmmmmmmmmmmmmmmmmmmmm\n    private String checkBody(ArrayList AL) {\n        String result = \"\";\n        AdvLexem al = null;\n        int begins = 0;\n        while (true) {\n            al = (AdvLexem) AL.get(pos);\n            if (al.code == Codes.VARIABLE) {\n                pos++;\n                result = checkC(\"ASSOCIATE MARK\", Codes.ASOCIATE, AL);\n                if (!result.equals(\"\"))\n                    return result;\n                pos++;\n                int tmp = vars.indexOf(al.value);\n                int type = ((Integer) var_types.get(tmp)).intValue();\n                if (type == Codes.INTEGER) {\n                    result = checkIASSOC(AL);\n                    if (!result.equals(\"\"))\n                        return result;\n                } else if (type == Codes.REAL) {\n                    result = checkRASSOC(AL);\n                    if (!result.equals(\"\"))\n                        return result;\n                } else if (type == Codes.BOOLEAN) {\n                    result = checkLEXPR(AL);\n                    if (!result.equals(\"\"))\n                        return result;\n                }\n                result = checkEnding(AL);\n                if (!result.equals(\"\"))\n                    return result;\n            } else if (al.code == Codes.WRITELN) {\n                pos++;\n                result = checkWRITE(AL);\n                if (!result.equals(\"\"))\n                    return result;\n                result = checkEnding(AL);\n                if (!result.equals(\"\"))\n                    return result;\n            } else if (al.code == Codes.READLN) {\n                pos++;\n                result = checkREAD(AL);\n                if (!result.equals(\"\"))\n                    return result;\n                result = checkEnding(AL);\n                if (!result.equals(\"\"))\n                    return result;\n            } else if (al.code == Codes.WHILE) {\n                pos++;\n                result = checkLEXPR(AL);\n                if (!result.equals(\"\"))\n                    return result;\n                result = checkC(\"keyword DO\", Codes.DO, AL);\n                if (!result.equals(\"\"))\n                    return result;\n                pos++;\n                result = checkOne(AL);\n                if (!result.equals(\"\"))\n                    return result;\n            } else if (al.code == Codes.IF) {\n                pos++;\n                result = checkLEXPR(AL);\n                if (!result.equals(\"\"))\n                    return result;\n                result = checkC(\"keyword THEN\", Codes.THEN, AL);\n                if (!result.equals(\"\"))\n                    return result;\n                pos++;\n                result = checkOne(AL);\n                if (!result.equals(\"\"))\n                    return result;\n                result = checkC(\"keyword ELSE\", Codes.ELSE, AL);\n                if (result.equals(\"\")) {\n                    pos++;\n                    result = checkOne(AL);\n                    if (!result.equals(\"\"))\n                        return result;\n                }\n            } else if (al.code == Codes.BEGIN) {\n                AL.remove(pos);\n                result = checkBlock(AL);\n                if (!result.equals(\"\"))\n                    return result;\n                else {\n                    pos--;\n                    result = checkC(\"SEMICOLON\", Codes.SEMICOLON, AL);\n                    if (result.equals(\"\")) {\n                        AL.remove(pos);\n                        pos--;\n                    }\n                    AL.remove(pos);\n                }\n            } else if (al.code == Codes.END) {\n                return \"END without coresponding BEGIN\" + \"\\n   found: \" + al.value + \"\\n   line: \" + al.line + \"\\n   column: \" + al.column;\n            } else if (al.code == Codes.END_DOT) {\n                return \"\";\n            } else\n                return \"Not a statement\" + \"\\n   found: \" + al.value + \"\\n   line: \" + al.line + \"\\n   column: \" + al.column;\n        }\n    }\n\n    // checkBODY()\n    private String checkBlock(ArrayList AL) {\n        String result = \"\";\n        AdvLexem al = null;\n        int begins = 0;\n        while (true) {\n            al = (AdvLexem) AL.get(pos);\n            if (al.code == Codes.VARIABLE) {\n                pos++;\n                result = checkC(\"ASSOCIATE MARK\", Codes.ASOCIATE, AL);\n                if (!result.equals(\"\"))\n                    return result;\n                pos++;\n                int tmp = vars.indexOf(al.value);\n                int type = ((Integer) var_types.get(tmp)).intValue();\n                if (type == Codes.INTEGER) {\n                    result = checkIASSOC(AL);\n                    if (!result.equals(\"\"))\n                        return result;\n                } else if (type == Codes.REAL) {\n                    result = checkRASSOC(AL);\n                    if (!result.equals(\"\"))\n                        return result;\n                } else if (type == Codes.BOOLEAN) {\n                    result = checkLEXPR(AL);\n                    if (!result.equals(\"\"))\n                        return result;\n                }\n                result = checkEnding(AL);\n                if (!result.equals(\"\"))\n                    return result;\n            } else if (al.code == Codes.WRITELN) {\n                pos++;\n                result = checkWRITE(AL);\n                if (!result.equals(\"\"))\n                    return result;\n                result = checkEnding(AL);\n                if (!result.equals(\"\"))\n                    return result;\n            } else if (al.code == Codes.READLN) {\n                pos++;\n                result = checkREAD(AL);\n                if (!result.equals(\"\"))\n                    return result;\n                result = checkEnding(AL);\n                if (!result.equals(\"\"))\n                    return result;\n            } else if (al.code == Codes.WHILE) {\n                pos++;\n                result = checkLEXPR(AL);\n                if (!result.equals(\"\"))\n                    return result;\n                result = checkC(\"keyword DO\", Codes.DO, AL);\n                if (!result.equals(\"\"))\n                    return result;\n                pos++;\n                result = checkOne(AL);\n                if (!result.equals(\"\"))\n                    return result;\n            } else if (al.code == Codes.IF) {\n                pos++;\n                result = checkLEXPR(AL);\n                if (!result.equals(\"\"))\n                    return result;\n                result = checkC(\"keyword THEN\", Codes.THEN, AL);\n                if (!result.equals(\"\"))\n                    return result;\n                pos++;\n                result = checkOne(AL);\n                if (!result.equals(\"\"))\n                    return result;\n                result = checkC(\"keyword ELSE\", Codes.ELSE, AL);\n                if (result.equals(\"\")) {\n                    pos++;\n                    result = checkOne(AL);\n                    if (!result.equals(\"\"))\n                        return result;\n                }\n            } else if (al.code == Codes.BEGIN) {\n                pos++;\n                result = checkBlock(AL);\n                if (!result.equals(\"\"))\n                    return result;\n            } else if (al.code == Codes.END) {\n                pos++;\n                result = checkEnding(AL);\n                if (!result.equals(\"\"))\n                    return result;\n                else\n                    return \"\";\n            } else if (al.code == Codes.END_DOT) {\n                return \"END expected\" + \"\\n   line: \" + al.line + \"\\n   column: \" + al.column;\n            } else\n                return \"Not a statement\" + \"\\n   found: \" + al.value + \"\\n   line: \" + al.line + \"\\n   column: \" + al.column;\n        }\n    }\n\n    // checkBlock()\n    private String checkOne(ArrayList AL) {\n        String result = \"\";\n        AdvLexem al = null;\n        int begins = 0;\n        al = (AdvLexem) AL.get(pos);\n        if (al.code == Codes.VARIABLE) {\n            pos++;\n            result = checkC(\"ASSOCIATE MARK\", Codes.ASOCIATE, AL);\n            if (!result.equals(\"\"))\n                return result;\n            pos++;\n            int tmp = vars.indexOf(al.value);\n            int type = ((Integer) var_types.get(tmp)).intValue();\n            if (type == Codes.INTEGER) {\n                result = checkIASSOC(AL);\n                if (!result.equals(\"\"))\n                    return result;\n            } else if (type == Codes.REAL) {\n                result = checkRASSOC(AL);\n                if (!result.equals(\"\"))\n                    return result;\n            } else if (type == Codes.BOOLEAN) {\n                result = checkLEXPR(AL);\n                if (!result.equals(\"\"))\n                    return result;\n            }\n            return checkEnding(AL);\n        } else if (al.code == Codes.WRITELN) {\n            pos++;\n            result = checkWRITE(AL);\n            if (!result.equals(\"\"))\n                return result;\n            return checkEnding(AL);\n        } else if (al.code == Codes.READLN) {\n            pos++;\n            result = checkREAD(AL);\n            if (!result.equals(\"\"))\n                return result;\n            return checkEnding(AL);\n        } else if (al.code == Codes.WHILE) {\n            pos++;\n            result = checkLEXPR(AL);\n            if (!result.equals(\"\"))\n                return result;\n            result = checkC(\"keyword DO\", Codes.DO, AL);\n            if (!result.equals(\"\"))\n                return result;\n            pos++;\n            return checkOne(AL);\n        } else if (al.code == Codes.IF) {\n            pos++;\n            result = checkLEXPR(AL);\n            if (!result.equals(\"\"))\n                return result;\n            result = checkC(\"keyword THEN\", Codes.THEN, AL);\n            if (!result.equals(\"\"))\n                return result;\n            pos++;\n            result = checkOne(AL);\n            if (!result.equals(\"\"))\n                return result;\n            result = checkC(\"keyword ELSE\", Codes.ELSE, AL);\n            if (result.equals(\"\")) {\n                pos++;\n                return checkOne(AL);\n            } else\n                return \"\";\n        } else if (al.code == Codes.BEGIN) {\n            pos++;\n            return checkBlock(AL);\n        } else if (al.code == Codes.END) {\n            return \"END without coresponding BEGIN\" + \"\\n   found: \" + al.value + \"\\n   line: \" + al.line + \"\\n   column: \" + al.column;\n        } else if ((al.code == Codes.END_DOT) || (al.code == Codes.ELSE)) {\n            return \"INSTRUCTION expected\" + \"\\n   line: \" + al.line + \"\\n   column: \" + al.column;\n        } else\n            return \"Not a statement\" + \"\\n   found: \" + al.value + \"\\n   line: \" + al.line + \"\\n   column: \" + al.column;\n    }\n\n    // checkOne()\n    private String checkEnding(ArrayList AL) {\n        String result = \"\";\n        result = checkC(\"SEMICOLON\", Codes.SEMICOLON, AL);\n        if (!result.equals(\"\")) {\n            result = checkC(\"SEMICOLON\", Codes.END, AL);\n            if (!result.equals(\"\")) {\n                result = checkC(\"SEMICOLON\", Codes.ELSE, AL);\n                if (!result.equals(\"\")) {\n                    result = checkC(\"SEMICOLON\", Codes.END_DOT, AL);\n                    if (!result.equals(\"\"))\n                        return result;\n                }\n            }\n        } else\n            pos++;\n        return \"\";\n    }\n\n    // checkEnding()\n    // checks Logical EXPRexion Number Element\n    private String checkLEXPRNElem(ArrayList AL) {\n        String result = \"\";\n        AdvLexem al = null;\n        result = checkC(\"VALUE\", Codes.MINUS, AL);\n        if (result.equals(\"\")) {\n            pos++;\n            result = checkC(\"INTEGER OR REAL NUMBER\", Codes.INUMBER, AL);\n            if ((result.equals(\"\")) || (checkC(\"\", Codes.RNUMBER, AL).equals(\"\"))) {\n                al = (AdvLexem) AL.get(pos);\n                AL.set(pos - 1, new AdvLexem(\"-\" + al.value, al.code, al.lcategory, al.hcategory, al.line, al.column));\n                AL.remove(pos);\n                return \"\";\n            } else\n                return result;\n        } else {\n            result = checkC(\"\", Codes.INUMBER, AL);\n            if (!((result.equals(\"\")) || (checkC(\"\", Codes.RNUMBER, AL).equals(\"\")))) {\n                result = checkC(\"INTEGER OR REAL VARIABLE\", Codes.VARIABLE, AL);\n                if (!result.equals(\"\"))\n                    return result;\n                else {\n                    al = (AdvLexem) AL.get(pos);\n                    int tmp = vars.indexOf(al.value);\n                    int type = ((Integer) var_types.get(tmp)).intValue();\n                    if (!((type == Codes.INTEGER) || (type == Codes.REAL))) {\n                        al = (AdvLexem) AL.get(pos);\n                        return \"INTEGER OR REAL VARIABLE expected \" + \"\\n   found: \" + al.value + \"\\n   line: \" + al.line + \"\\n   column: \" + al.column;\n                    } else {\n                        pos++;\n                        return \"\";\n                    }\n                }\n            } else {\n                pos++;\n                return \"\";\n            }\n        }\n    }\n\n    // checkLEXPRNElem()\n    // checks Logical EXPRexion Logic Element\n    private String checkLEXPRLElem(ArrayList AL) {\n        String result = \"\";\n        AdvLexem al = null;\n        result = checkC(\"\", Codes.TRUE, AL);\n        if (!((result.equals(\"\")) || (checkC(\"\", Codes.FALSE, AL).equals(\"\")))) {\n            result = checkC(\"LOGICAL VALUE\", Codes.VARIABLE, AL);\n            if (!result.equals(\"\"))\n                return result;\n            else {\n                al = (AdvLexem) AL.get(pos);\n                int tmp = vars.indexOf(al.value);\n                int type = ((Integer) var_types.get(tmp)).intValue();\n                if (!(type == Codes.BOOLEAN)) {\n                    al = (AdvLexem) AL.get(pos);\n                    return \"expected: LOGICAL VALUE\" + \"\\n   found: \" + al.value + \"\\n   line: \" + al.line + \"\\n   column: \" + al.column;\n                } else {\n                    pos++;\n                    return \"\";\n                }\n            }\n        } else {\n            pos++;\n            return \"\";\n        }\n    }\n\n    // checkLEXPRLElem()\n    //mmmmmmmmmmmmmmmmmmmmmm\tINTERPRETER   mmmmmmmmmmmmmmmmmmmmmmmmmmm\n    private ArrayList interBody(ArrayList AL) {\n        ArrayList baze = new ArrayList();\n        String itype = \"\";\n        String variable = \"\";\n        int start = 0;\n        int finish = 0;\n        ArrayList iftrue = new ArrayList();\n        ArrayList ifelse = new ArrayList();\n        AdvLexem al = null;\n        while (true) {\n            al = (AdvLexem) AL.get(pos);\n            if (al.code == Codes.VARIABLE) {\n                variable = al.value;\n                pos++;\n                pos++;\n                start = pos;\n                int tmp = vars.indexOf(al.value);\n                int type = ((Integer) var_types.get(tmp)).intValue();\n                if (type == Codes.INTEGER) {\n                    checkIASSOC(AL);\n                    finish = pos - 1;\n                    itype = \"IASSOC\";\n                } else if (type == Codes.REAL) {\n                    checkRASSOC(AL);\n                    finish = pos - 1;\n                    itype = \"RASSOC\";\n                } else if (type == Codes.BOOLEAN) {\n                    checkLEXPR(AL);\n                    finish = pos - 1;\n                    itype = \"BASSOC\";\n                }\n                checkEnding(AL);\n            } else if (al.code == Codes.WRITELN) {\n                itype = \"WRITE\";\n                pos++;\n                start = pos;\n                checkWRITE(AL);\n                finish = pos - 1;\n                checkEnding(AL);\n            } else if (al.code == Codes.READLN) {\n                itype = \"READ\";\n                pos++;\n                start = pos;\n                checkREAD(AL);\n                finish = pos - 1;\n                checkEnding(AL);\n            } else if (al.code == Codes.WHILE) {\n                itype = \"WHILE\";\n                pos++;\n                start = pos;\n                checkLEXPR(AL);\n                finish = pos - 1;\n                pos++;\n                iftrue = interOne(AL);\n            } else if (al.code == Codes.IF) {\n                itype = \"IF\";\n                pos++;\n                start = pos;\n                checkLEXPR(AL);\n                finish = pos - 1;\n                pos++;\n                iftrue = interOne(AL);\n                if (checkC(\"keyword ELSE\", Codes.ELSE, AL).equals(\"\")) {\n                    pos++;\n                    ifelse = interOne(AL);\n                }\n            } else if (al.code == Codes.BEGIN) {\n                pos++;\n                return interBlock(AL);\n            } else if (al.code == Codes.END_DOT) {\n                pos++;\n                checkEnding(AL);\n                return baze;\n            }\n            baze.add(new ExecLexem(itype, variable, AL, start, finish, iftrue, ifelse));\n            iftrue = new ArrayList();\n            ifelse = new ArrayList();\n            variable = \"\";\n        }\n    }\n\n    // interBODY()\n    private ArrayList interBlock(ArrayList AL) {\n        ArrayList baze = new ArrayList();\n        String itype = \"\";\n        String variable = \"\";\n        int start = 0;\n        int finish = 0;\n        ArrayList iftrue = new ArrayList();\n        ArrayList ifelse = new ArrayList();\n        AdvLexem al = null;\n        while (true) {\n            al = (AdvLexem) AL.get(pos);\n            if (al.code == Codes.VARIABLE) {\n                variable = al.value;\n                pos++;\n                pos++;\n                start = pos;\n                int tmp = vars.indexOf(al.value);\n                int type = ((Integer) var_types.get(tmp)).intValue();\n                if (type == Codes.INTEGER) {\n                    checkIASSOC(AL);\n                    finish = pos - 1;\n                    itype = \"IASSOC\";\n                } else if (type == Codes.REAL) {\n                    checkRASSOC(AL);\n                    finish = pos - 1;\n                    itype = \"RASSOC\";\n                } else if (type == Codes.BOOLEAN) {\n                    checkLEXPR(AL);\n                    finish = pos - 1;\n                    itype = \"BASSOC\";\n                }\n                checkEnding(AL);\n            } else if (al.code == Codes.WRITELN) {\n                itype = \"WRITE\";\n                pos++;\n                start = pos;\n                checkWRITE(AL);\n                finish = pos - 1;\n                checkEnding(AL);\n            } else if (al.code == Codes.READLN) {\n                itype = \"READ\";\n                pos++;\n                start = pos;\n                checkREAD(AL);\n                finish = pos - 1;\n                checkEnding(AL);\n            } else if (al.code == Codes.WHILE) {\n                itype = \"WHILE\";\n                pos++;\n                start = pos;\n                checkLEXPR(AL);\n                finish = pos - 1;\n                pos++;\n                iftrue = interOne(AL);\n            } else if (al.code == Codes.IF) {\n                itype = \"IF\";\n                pos++;\n                start = pos;\n                checkLEXPR(AL);\n                finish = pos - 1;\n                pos++;\n                iftrue = interOne(AL);\n                if (checkC(\"keyword ELSE\", Codes.ELSE, AL).equals(\"\")) {\n                    pos++;\n                    ifelse = interOne(AL);\n                }\n            } else if (al.code == Codes.BEGIN) {\n                pos++;\n                return interBlock(AL);\n            } else if (al.code == Codes.END) {\n                pos++;\n                checkEnding(AL);\n                return baze;\n            }\n            baze.add(new ExecLexem(itype, variable, AL, start, finish, iftrue, ifelse));\n            iftrue = new ArrayList();\n            ifelse = new ArrayList();\n            variable = \"\";\n        }\n    }\n\n    // interBlock()\n    private ArrayList interOne(ArrayList AL) {\n        ArrayList baze = new ArrayList();\n        String itype = \"\";\n        String variable = \"\";\n        int start = 0;\n        int finish = 0;\n        ArrayList iftrue = new ArrayList();\n        ArrayList ifelse = new ArrayList();\n        AdvLexem al = null;\n        al = (AdvLexem) AL.get(pos);\n        if (al.code == Codes.VARIABLE) {\n            variable = al.value;\n            pos++;\n            pos++;\n            start = pos;\n            int tmp = vars.indexOf(al.value);\n            int type = ((Integer) var_types.get(tmp)).intValue();\n            if (type == Codes.INTEGER) {\n                checkIASSOC(AL);\n                finish = pos - 1;\n                itype = \"IASSOC\";\n            } else if (type == Codes.REAL) {\n                checkRASSOC(AL);\n                finish = pos - 1;\n                itype = \"RASSOC\";\n            } else if (type == Codes.BOOLEAN) {\n                checkLEXPR(AL);\n                finish = pos - 1;\n                itype = \"BASSOC\";\n            }\n            checkEnding(AL);\n        } else if (al.code == Codes.WRITELN) {\n            itype = \"WRITE\";\n            pos++;\n            start = pos;\n            checkWRITE(AL);\n            finish = pos - 1;\n            checkEnding(AL);\n        } else if (al.code == Codes.READLN) {\n            itype = \"READ\";\n            pos++;\n            start = pos;\n            checkREAD(AL);\n            finish = pos - 1;\n            checkEnding(AL);\n        } else if (al.code == Codes.WHILE) {\n            itype = \"WHILE\";\n            pos++;\n            start = pos;\n            checkLEXPR(AL);\n            finish = pos - 1;\n            pos++;\n            iftrue = interOne(AL);\n        } else if (al.code == Codes.IF) {\n            itype = \"IF\";\n            pos++;\n            start = pos;\n            checkLEXPR(AL);\n            finish = pos - 1;\n            pos++;\n            iftrue = interOne(AL);\n            if (checkC(\"keyword ELSE\", Codes.ELSE, AL).equals(\"\")) {\n                pos++;\n                ifelse = interOne(AL);\n            }\n        } else if (al.code == Codes.BEGIN) {\n            pos++;\n            return interBlock(AL);\n        }\n        baze.add(new ExecLexem(itype, variable, AL, start, finish, iftrue, ifelse));\n        return baze;\n    }\n\n    // checkOne()\n    //mmmmmmmmmmmmmmmmmmmmmmm\tEVALUATION\tmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm\n    private void initializeVars() {\n        for (int i = 0; i < var_types.size(); i++) if (((Integer) var_types.get(i)).intValue() == Codes.INTEGER)\n            var_vals.add(new Integer(0));\n        else if (((Integer) var_types.get(i)).intValue() == Codes.REAL)\n            var_vals.add(new Float(0));\n        else\n            var_vals.add(new Boolean(false));\n    }\n\n    // initializeVars()\n    private int evalInt(AdvLexem[] lex) {\n        ArrayList args = new ArrayList();\n        ArrayList oper = new ArrayList();\n        while (place < lex.length) {\n            if (lex[place].code == Codes.RBRACKET) {\n                break;\n            }\n            if (lex[place].code == Codes.INUMBER)\n                args.add(new Integer(lex[place].value));\n            else if (lex[place].code == Codes.VARIABLE) {\n                int tmp = vars.indexOf(lex[place].value);\n                args.add((Integer) var_vals.get(tmp));\n            } else if (lex[place].code == Codes.LBRACKET) {\n                place++;\n                args.add(new Integer(evalInt(lex)));\n            } else if (lex[place].lcategory == Codes.AOPERATOR)\n                oper.add(lex[place].value);\n            place++;\n        }\n        for (int i = 0; i < oper.size(); i++) if (((String) oper.get(i)).equals(\"*\")) {\n            int tmp1 = ((Integer) args.get(i)).intValue();\n            int tmp2 = ((Integer) args.get(i + 1)).intValue();\n            args.set(i, new Integer(tmp1 * tmp2));\n            args.remove(i + 1);\n            oper.remove(i);\n            i--;\n        } else if (((String) oper.get(i)).equals(\"/\")) {\n            int tmp1 = ((Integer) args.get(i)).intValue();\n            int tmp2 = ((Integer) args.get(i + 1)).intValue();\n            args.set(i, new Integer(tmp1 / tmp2));\n            args.remove(i + 1);\n            oper.remove(i);\n            i--;\n        }\n        for (int i = 0; i < oper.size(); i++) if (((String) oper.get(i)).equals(\"+\")) {\n            int tmp1 = ((Integer) args.get(i)).intValue();\n            int tmp2 = ((Integer) args.get(i + 1)).intValue();\n            args.set(i, new Integer(tmp1 + tmp2));\n            args.remove(i + 1);\n            oper.remove(i);\n            i--;\n        } else if (((String) oper.get(i)).equals(\"-\")) {\n            int tmp1 = ((Integer) args.get(i)).intValue();\n            int tmp2 = ((Integer) args.get(i + 1)).intValue();\n            args.set(i, new Integer(tmp1 - tmp2));\n            args.remove(i + 1);\n            oper.remove(i);\n            i--;\n        }\n        return ((Integer) args.get(0)).intValue();\n    }\n\n    // evalInt()\n    private float evalReal(AdvLexem[] lex) {\n        ArrayList args = new ArrayList();\n        ArrayList oper = new ArrayList();\n        while (place < lex.length) {\n            if (lex[place].code == Codes.RBRACKET) {\n                break;\n            }\n            if (lex[place].lcategory == Codes.NUMBER)\n                args.add(new Float(lex[place].value));\n            else if (lex[place].code == Codes.VARIABLE) {\n                int tmp = vars.indexOf(lex[place].value);\n                int type = ((Integer) var_types.get(tmp)).intValue();\n                if (type == Codes.INTEGER)\n                    args.add(new Float(((Integer) var_vals.get(tmp)).intValue()));\n                else\n                    args.add((Float) var_vals.get(tmp));\n            } else if (lex[place].code == Codes.LBRACKET) {\n                place++;\n                args.add(new Float(evalReal(lex)));\n            } else if (lex[place].lcategory == Codes.AOPERATOR)\n                oper.add(lex[place].value);\n            place++;\n        }\n        for (int i = 0; i < oper.size(); i++) if (((String) oper.get(i)).equals(\"*\")) {\n            float tmp1 = ((Float) args.get(i)).floatValue();\n            float tmp2 = ((Float) args.get(i + 1)).floatValue();\n            args.set(i, new Float(tmp1 * tmp2));\n            args.remove(i + 1);\n            oper.remove(i);\n            i--;\n        } else if (((String) oper.get(i)).equals(\"/\")) {\n            float tmp1 = ((Float) args.get(i)).floatValue();\n            float tmp2 = ((Float) args.get(i + 1)).floatValue();\n            args.set(i, new Float(tmp1 / tmp2));\n            args.remove(i + 1);\n            oper.remove(i);\n            i--;\n        }\n        for (int i = 0; i < oper.size(); i++) if (((String) oper.get(i)).equals(\"+\")) {\n            float tmp1 = ((Float) args.get(i)).floatValue();\n            float tmp2 = ((Float) args.get(i + 1)).floatValue();\n            args.set(i, new Float(tmp1 + tmp2));\n            args.remove(i + 1);\n            oper.remove(i);\n            i--;\n        } else if (((String) oper.get(i)).equals(\"-\")) {\n            float tmp1 = ((Float) args.get(i)).floatValue();\n            float tmp2 = ((Float) args.get(i + 1)).floatValue();\n            args.set(i, new Float(tmp1 - tmp2));\n            args.remove(i + 1);\n            oper.remove(i);\n            i--;\n        }\n        return ((Float) args.get(0)).floatValue();\n    }\n\n    // evalReal()\n    private boolean evalBool(AdvLexem[] lex) {\n        ArrayList args = new ArrayList();\n        ArrayList oper = new ArrayList();\n        ArrayList nots = new ArrayList();\n        int pointer = 0;\n        while (place < lex.length) {\n            if (lex[place].code == Codes.RBRACKET) {\n                break;\n            }\n            if (lex[place].code == Codes.VARIABLE) {\n                int tmp = vars.indexOf(lex[place].value);\n                int type = ((Integer) var_types.get(tmp)).intValue();\n                if (type == Codes.BOOLEAN)\n                    pointer = 1;\n                else\n                    pointer = 2;\n            }\n            if ((lex[place].code == Codes.TRUE) || (lex[place].code == Codes.FALSE))\n                args.add(new Boolean(lex[place].value));\n            else if (pointer == 1) {\n                int tmp = vars.indexOf(lex[place].value);\n                args.add((Boolean) var_vals.get(tmp));\n                pointer = 0;\n            } else if (lex[place].code == Codes.LBRACKET) {\n                place++;\n                args.add(new Boolean(evalBool(lex)));\n            } else if ((lex[place].code == Codes.AND) || (lex[place].code == Codes.OR))\n                oper.add(lex[place].value);\n            else if (lex[place].code == Codes.NOT)\n                nots.add(new Integer(args.size()));\n            else {\n                float tmp1 = 0;\n                float tmp2 = 0;\n                int rel = 0;\n                if (lex[place].lcategory == Codes.NUMBER)\n                    tmp1 = (new Float(lex[place].value)).floatValue();\n                else if (pointer == 2) {\n                    pointer = 0;\n                    int tmp = vars.indexOf(lex[place].value);\n                    int type = ((Integer) var_types.get(tmp)).intValue();\n                    if (type == Codes.INTEGER)\n                        tmp1 = ((Integer) var_vals.get(tmp)).intValue();\n                    else\n                        tmp1 = ((Float) var_vals.get(tmp)).floatValue();\n                }\n                place++;\n                rel = lex[place].code;\n                place++;\n                if (lex[place].lcategory == Codes.NUMBER)\n                    tmp2 = (new Float(lex[place].value)).floatValue();\n                else if (lex[place].code == Codes.VARIABLE) {\n                    int tmp = vars.indexOf(lex[place].value);\n                    int type = ((Integer) var_types.get(tmp)).intValue();\n                    if (type == Codes.INTEGER)\n                        tmp2 = ((Integer) var_vals.get(tmp)).intValue();\n                    else\n                        tmp2 = ((Float) var_vals.get(tmp)).floatValue();\n                }\n                boolean bool = false;\n                if (rel == Codes.E)\n                    bool = tmp1 == tmp2;\n                else if (rel == Codes.NE)\n                    bool = tmp1 != tmp2;\n                else if (rel == Codes.GT) {\n                    bool = tmp1 > tmp2;\n                } else if (rel == Codes.GE)\n                    bool = tmp1 >= tmp2;\n                else if (rel == Codes.LT)\n                    bool = tmp1 < tmp2;\n                else if (rel == Codes.LE)\n                    bool = tmp1 <= tmp2;\n                args.add(new Boolean(bool));\n            }\n            place++;\n        }\n        for (int i = 0; i < nots.size(); i++) {\n            int neg = ((Integer) nots.get(i)).intValue();\n            boolean temp = ((Boolean) args.get(neg)).booleanValue();\n            args.set(neg, new Boolean(!temp));\n        }\n        for (int i = 0; i < oper.size(); i++) if (((String) oper.get(i)).equals(\"AND\")) {\n            boolean tmp1 = ((Boolean) args.get(i)).booleanValue();\n            boolean tmp2 = ((Boolean) args.get(i + 1)).booleanValue();\n            args.set(i, new Boolean(tmp1 && tmp2));\n            args.remove(i + 1);\n            oper.remove(i);\n            i--;\n        }\n        for (int i = 0; i < oper.size(); i++) if (((String) oper.get(i)).equals(\"OR\")) {\n            boolean tmp1 = ((Boolean) args.get(i)).booleanValue();\n            boolean tmp2 = ((Boolean) args.get(i + 1)).booleanValue();\n            args.set(i, new Boolean(tmp1 || tmp2));\n            args.remove(i + 1);\n            oper.remove(i);\n            i--;\n        }\n        return ((Boolean) args.get(0)).booleanValue();\n    }\n\n    // evalBool()\n    //mmmmmmmmmmmmmmmmmmmmmmmmmmm\tEXECUTOR\tmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm\n    private void execute(ArrayList al) {\n        for (int i = 0; i < al.size(); i++) execLexem((ExecLexem) al.get(i));\n    }\n\n    // execute()\n    private void execLexem(ExecLexem el) {\n        if (el.type.equals(\"IASSOC\"))\n            execInt(el);\n        else if (el.type.equals(\"RASSOC\"))\n            execReal(el);\n        else if (el.type.equals(\"BASSOC\"))\n            execBool(el);\n        else if (el.type.equals(\"READ\"))\n            execRead(el);\n        else if (el.type.equals(\"WRITE\"))\n            execWrite(el);\n        else if (el.type.equals(\"WHILE\"))\n            execWhile(el);\n        else if (el.type.equals(\"IF\"))\n            execIf(el);\n    }\n\n    // execLexem()\n    private void execInt(ExecLexem el) {\n        int tmp = vars.indexOf(el.variable);\n        place = 0;\n        var_vals.set(tmp, new Integer(evalInt(el.lexems)));\n    }\n\n    // execInt()\n    private void execReal(ExecLexem el) {\n        int tmp = vars.indexOf(el.variable);\n        place = 0;\n        var_vals.set(tmp, new Float(evalReal(el.lexems)));\n    }\n\n    // execReal()\n    private void execBool(ExecLexem el) {\n        int tmp = vars.indexOf(el.variable);\n        place = 0;\n        var_vals.set(tmp, new Boolean(evalBool(el.lexems)));\n    }\n\n    // execBool()\n    private void execWhile(ExecLexem el) {\n        place = 0;\n        while (evalBool(el.lexems)) {\n            execute(el.iftrue);\n            place = 0;\n        }\n    }\n\n    // execWhile()\n    private void execIf(ExecLexem el) {\n        place = 0;\n        if (evalBool(el.lexems))\n            execute(el.iftrue);\n        else\n            execute(el.ifelse);\n    }\n\n    // execIf()\n    private void execRead(ExecLexem el) {\n        int tmp = vars.indexOf(el.lexems[1].value);\n        int type = ((Integer) var_types.get(tmp)).intValue();\n        String s = \"\";\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n            s = in.readLine();\n        } catch (Exception ex) {\n            System.out.println(\"Error during input operatiron !\");\n        }\n        if (type == Codes.INTEGER)\n            var_vals.set(tmp, new Integer(s));\n        else if (type == Codes.REAL)\n            var_vals.set(tmp, new Float(s));\n        else\n            var_vals.set(tmp, new Boolean(s));\n    }\n\n    // execRead()\n    private void execWrite(ExecLexem el) {\n        for (int i = 1; i < el.lexems.length; i = i + 2) if (el.lexems[i].code == Codes.STRING)\n            System.out.print(el.lexems[i].value);\n        else {\n            int tmp = vars.indexOf(el.lexems[i].value);\n            int type = ((Integer) var_types.get(tmp)).intValue();\n            String s = \"\";\n            if (type == Codes.INTEGER)\n                s = ((Integer) var_vals.get(tmp)).toString();\n            else if (type == Codes.REAL)\n                s = ((Float) var_vals.get(tmp)).toString();\n            else\n                s = ((Boolean) var_vals.get(tmp)).toString();\n            System.out.print(s);\n        }\n        System.out.println();\n    }\n    // execWrite()\n}\n\n// class Scanner\n//mmmmmmmmmmmmmmmmmmmm\tADDITIONAL CLASSES\tmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm\nclass Lexem {\n\n    String value;\n\n    byte type;\n\n    int line;\n\n    int column;\n\n    public Lexem(String value, byte type, int line, int column) {\n        if (type != Codes.STRING)\n            this.value = value.toUpperCase();\n        else\n            this.value = value;\n        this.type = type;\n        this.line = line;\n        this.column = column;\n    }\n\n    public Lexem(StringBuffer value, byte type, int line, int column) {\n        if (type != Codes.STRING)\n            this.value = value.toString().toUpperCase();\n        else\n            this.value = value.toString();\n        this.type = type;\n        this.line = line;\n        this.column = column;\n    }\n\n    public Lexem(int value, int type, int line, int column) {\n        char[] sign = new char[1];\n        sign[0] = (char) value;\n        this.value = new String(sign);\n        this.type = (byte) type;\n        this.line = line;\n        this.column = column;\n    }\n}\n\n// class Lexem\nclass AdvLexem {\n\n    String value;\n\n    byte code;\n\n    // lower category\n    byte lcategory;\n\n    // higher category\n    byte hcategory;\n\n    // custom category, if needed\n    byte ccategory;\n\n    int line;\n\n    int column;\n\n    public AdvLexem(String value, byte code, byte lcategory, byte hcategory, int line, int column) {\n        this.value = value;\n        this.code = code;\n        this.lcategory = lcategory;\n        this.hcategory = hcategory;\n        this.line = line;\n        this.column = column;\n    }\n    // AdvLexem()\n}\n\n// class AdvLexem\nclass ExecLexem {\n\n    // instruction type\n    String type;\n\n    // name of variable in association instruction\n    String variable;\n\n    // lexems of the given instruction\n    AdvLexem[] lexems;\n\n    ArrayList iftrue;\n\n    ArrayList ifelse;\n\n    ExecLexem(String type, String variable, ArrayList AL, int start, int finish, ArrayList iftrue, ArrayList ifelse) {\n        this.type = type;\n        this.variable = variable;\n        lexems = new AdvLexem[finish - start + 1];\n        for (int i = start, j = 0; i <= finish; i++, j++) lexems[j] = (AdvLexem) AL.get(i);\n        this.iftrue = iftrue;\n        this.ifelse = ifelse;\n    }\n    // ExecLexem()\n}\n// class ExecLexem\n",
		"id": "/EvoSuiteBenchmark/50_biff/src/main/java/Scanner_0Test.java",
		"test_prompt": "// Scanner_0Test.java\n\n\n/*\"Pascal interpreter written in Java\" jest przeznaczony do \n interpretacji kodu napisanego w j�zyku Pascal.\nCopyright (C) 2004/2005 Bartyna Waldemar, Faderewski Marek,\nFedorczyk �ukasz, Iwanowski Wojciech.\nNiniejszy program jest wolnym oprogramowaniem; mo�esz go \nrozprowadza� dalej i/lub modyfikowa� na warunkach Powszechnej\nLicencji Publicznej GNU, wydanej przez Fundacj� Wolnego\nOprogramowania - wed�ug wersji 2-giej tej Licencji lub kt�rej�\nz p�niejszych wersji. \n\nNiniejszy program rozpowszechniany jest z nadziej�, i� b�dzie on \nu�yteczny - jednak BEZ JAKIEJKOLWIEK GWARANCJI, nawet domy�lnej \ngwarancji PRZYDATNO�CI HANDLOWEJ albo PRZYDATNO�CI DO OKRE�LONYCH \nZASTOSOWA�. W celu uzyskania bli�szych informacji - Powszechna \nLicencja Publiczna GNU. \n\nZ pewno�ci� wraz z niniejszym programem otrzyma�e� te� egzemplarz \nPowszechnej Licencji Publicznej GNU (GNU General Public License);\nje�li nie - napisz do Free Software Foundation, Inc., 675 Mass Ave,\nCambridge, MA 02139, USA.\n*/\nimport java.io.*;\nimport java.util.ArrayList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Scanner}.\n* It contains ten unit test cases for the {@link Scanner#advScanning(ArrayList)} method.\n*/\nclass Scanner_0Test {"
	},
	{
		"original_code": "// Scanner.java\n/*\"Pascal interpreter written in Java\" jest przeznaczony do \n interpretacji kodu napisanego w j�zyku Pascal.\nCopyright (C) 2004/2005 Bartyna Waldemar, Faderewski Marek,\nFedorczyk �ukasz, Iwanowski Wojciech.\nNiniejszy program jest wolnym oprogramowaniem; mo�esz go \nrozprowadza� dalej i/lub modyfikowa� na warunkach Powszechnej\nLicencji Publicznej GNU, wydanej przez Fundacj� Wolnego\nOprogramowania - wed�ug wersji 2-giej tej Licencji lub kt�rej�\nz p�niejszych wersji. \n\nNiniejszy program rozpowszechniany jest z nadziej�, i� b�dzie on \nu�yteczny - jednak BEZ JAKIEJKOLWIEK GWARANCJI, nawet domy�lnej \ngwarancji PRZYDATNO�CI HANDLOWEJ albo PRZYDATNO�CI DO OKRE�LONYCH \nZASTOSOWA�. W celu uzyskania bli�szych informacji - Powszechna \nLicencja Publiczna GNU. \n\nZ pewno�ci� wraz z niniejszym programem otrzyma�e� te� egzemplarz \nPowszechnej Licencji Publicznej GNU (GNU General Public License);\nje�li nie - napisz do Free Software Foundation, Inc., 675 Mass Ave,\nCambridge, MA 02139, USA.\n*/\nimport java.io.*;\nimport java.util.ArrayList;\n\npublic class Scanner {\n\n    public ArrayList lexems = new ArrayList();\n\n    // variables for validation process\n    ArrayList vars = new ArrayList();\n\n    ArrayList var_types = new ArrayList();\n\n    ArrayList var_vals = new ArrayList();\n\n    // position in Advenced Lexems Array\n    private int pos = 0;\n\n    // position during instruction evaluating\n    private int place = 0;\n\n    private int main_begin = 0;\n\n    public Scanner(String filename) throws Exception {\n        File file = new File(filename);\n        FileInputStream filein = new FileInputStream(file);\n        // array of 'lexem' objects\n        lexems = new ArrayList();\n        // current lexem\n        StringBuffer value = new StringBuffer();\n        // current type of lexem\n        byte type = 0;\n        // current line\n        int line = 1;\n        // current column\n        int column = 1;\n        // where the lexem began\n        int began = 1;\n        // where the String began\n        int sline = 1;\n        int bite = filein.read();\n        while (bite != -1) {\n            // if bite is a quotation mark\n            if (bite == 34) {\n                if (type != 0) {\n                    lexems.add(new Lexem(value, type, line, began));\n                    value = new StringBuffer();\n                }\n                if (type != 5) {\n                    type = 5;\n                    began = column;\n                    sline = line;\n                } else\n                    type = 0;\n            } else if (type == 5) {\n                value.append((char) bite);\n                if (bite == 13) {\n                    line++;\n                    column = -1;\n                }\n            } else // if bite is a digit\n            if ((bite >= 48) && (bite <= 57)) {\n                if (type == 0) {\n                    type = 1;\n                    began = column;\n                }\n                value.append((char) bite);\n            } else // if bite is a letter\n            if (((bite >= 65) && (bite <= 90)) || ((bite >= 97) && (bite <= 122))) {\n                if (type == 0) {\n                    type = 3;\n                    began = column;\n                    value.append((char) bite);\n                } else if (type == 3)\n                    value.append((char) bite);\n                else {\n                    type = 7;\n                    break;\n                }\n            } else // if bite is a sign\n            if (((bite >= 40) && (bite <= 45)) || (bite == 47) || ((bite >= 58) && (bite <= 62))) {\n                if (type != 0) {\n                    lexems.add(new Lexem(value, type, line, began));\n                    type = 0;\n                    value = new StringBuffer();\n                }\n                lexems.add(new Lexem(bite, 4, line, column));\n            } else // if bite is a dot\n            if (bite == 46)\n                if (type != 0)\n                    if (type == 3)\n                        if (((value.toString()).toUpperCase()).equals(\"END\")) {\n                            lexems.add(new Lexem(\"END.\", (byte) 3, line, began));\n                            type = 0;\n                            value = new StringBuffer();\n                        } else {\n                            type = 8;\n                            break;\n                        }\n                    else if (type == 1) {\n                        type = 2;\n                        value.append('.');\n                    } else {\n                        type = 8;\n                        break;\n                    }\n                else {\n                    type = 8;\n                    break;\n                }\n            else // if bite is a separator\n            if ((bite == 9) || (bite == 32) || (bite == 13) || (bite == 10)) {\n                if (type != 0) {\n                    lexems.add(new Lexem(value, type, line, began));\n                    type = 0;\n                    value = new StringBuffer();\n                }\n                if (bite == 13) {\n                    line++;\n                    column = -1;\n                }\n            } else // bite is not allowed character\n            {\n                type = 9;\n                break;\n            }\n            bite = filein.read();\n            if ((bite == -1) && (type == 5))\n                type = 6;\n            else if (bite == -1)\n                if (type != 0) {\n                    lexems.add(new Lexem(value, type, line, began));\n                    type = 0;\n                    value = new StringBuffer();\n                }\n            column++;\n        }\n        // error handling\n        if (type == 6)\n            System.out.println(\"ERROR: String not closed ! \" + \"line: \" + sline + \", column: \" + began);\n        else if (type == 7)\n            System.out.println(\"ERROR: letter joined with number ! \" + \"line: \" + line + \", column: \" + column);\n        else if (type == 8)\n            System.out.println(\"ERROR: dot in wrong place ! \" + \"line: \" + line + \", column: \" + column);\n        else if (type == 9)\n            System.out.println(\"ERROR: illegal character !: \" + (char) bite + \" line: \" + line + \", column: \" + column);\n        else {\n            // if everything is OK\n            //\t\t\t\t\tprintLexems(lexems);\n            // advenced scunning (father, deeper clasification)\n            ArrayList AdvL = advScanning(lexems);\n            //                \tprintAdvLexems(AdvL);\n            // validation process\n            String tmp_result = checkStructure(AdvL);\n            System.out.println(tmp_result);\n            if (tmp_result.equals(\"No errors !\")) {\n                System.out.println(\"===================\");\n                // variables initialization\n                initializeVars();\n                pos = main_begin;\n                // interpretation process\n                ArrayList ExecL = interBody(AdvL);\n                // execution\n                execute(ExecL);\n                /*    \n\tSystem.out.println(\"IAL Size = \" + ExecL.size());  \n\tfor (int i = 0; i < ExecL.size(); i++) {\n\t\tSystem.out.println(((ExecLexem)ExecL.get(i)).type);\n\t\tSystem.out.println(((ExecLexem)ExecL.get(i)).variable);\n\t\tSystem.out.println(\"If TRUE SIZE = \" + ((ExecLexem)ExecL.get(i)).\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiftrue.size());\n\t\tfor (int j = 0; j < ((ExecLexem)ExecL.get(i)).lexems.length; j++)\n\t\t\tSystem.out.println(((ExecLexem)ExecL.get(i)).lexems[j].value);\n\t} \t*/\n            }\n        }\n    }\n\n    // Scanner()\n    public void printLexems(ArrayList lex) {\n        System.out.println(\"\\nLEXEMS: \" + lex.size());\n        System.out.println(\"VALUE   TYPE   LINE   COLUMN\");\n        Object[] lexems = lex.toArray();\n        for (int i = 0; i < lexems.length; i++) {\n            Lexem lexem = (Lexem) lexems[i];\n            System.out.println(lexem.value + \"   \" + lexem.type + \"   \" + lexem.line + \"   \" + lexem.column);\n        }\n        System.out.println();\n    }\n\n    // printLexems(ArrayList)\n    public void printAdvLexems(ArrayList AdvLex) {\n        System.out.println(\"\\nLEXEMS: \" + AdvLex.size());\n        System.out.println(\"VALUE   CODE   LCATEGORY   \" + \"HCATEGORY   LINE   COLUMN\");\n        Object[] AdvLexems = AdvLex.toArray();\n        for (int i = 0; i < AdvLexems.length; i++) {\n            AdvLexem advlexem = (AdvLexem) AdvLexems[i];\n            System.out.println(advlexem.value + \"   \" + advlexem.code + \"   \" + advlexem.lcategory + \"   \" + advlexem.hcategory + \"   \" + advlexem.line + \"   \" + advlexem.column);\n        }\n        System.out.println();\n    }\n\n    // printLexems(ArrayList)\n    public ArrayList advScanning(ArrayList lexems) {\n        ArrayList AdvLexems = new ArrayList();\n        String value = \"\";\n        Codes codes = new Codes();\n        codes.fillLists();\n        Lexem lexem = null;\n        byte code = 0;\n        byte lcategory = 0;\n        byte hcategory = 0;\n        int size = lexems.size();\n        int i = 0;\n        while (i < size) {\n            lexem = (Lexem) lexems.get(i);\n            // if lexem is a word\n            if (lexem.type == codes.STRING)\n                AdvLexems.add(new AdvLexem(lexem.value, codes.STRING, codes.STRING, codes.STRING, lexem.line, lexem.column));\n            else if (lexem.type == codes.WORD) {\n                hcategory = codes.WORD;\n                code = codes.getKeywordCode(lexem.value);\n                if (code == codes.VARIABLE)\n                    lcategory = codes.VARIABLE;\n                else if ((code >= codes.AND) && (code <= codes.OR))\n                    lcategory = codes.LOPERATOR;\n                else if ((code >= codes.INTEGER) && (code <= codes.BOOLEAN))\n                    lcategory = codes.VTYPE;\n                else\n                    lcategory = codes.KEYWORD;\n                AdvLexems.add(new AdvLexem(lexem.value, code, lcategory, hcategory, lexem.line, lexem.column));\n            } else // if lexem is a sign\n            if (lexem.type == codes.SIGN) {\n                value = lexem.value;\n                ;\n                hcategory = codes.SIGN;\n                code = codes.getSignCode(lexem.value);\n                if ((code >= codes.COLON) && (code <= codes.QUOTATION)) {\n                    lcategory = codes.OOPERATOR;\n                    if (lexem.value.equals(\":\"))\n                        if ((i + 1) < size)\n                            if (((Lexem) lexems.get(i + 1)).value.equals(\"=\")) {\n                                code = codes.ASOCIATE;\n                                value = \":=\";\n                                i++;\n                            }\n                } else if ((code >= codes.E) && (code <= codes.LE)) {\n                    lcategory = codes.ROPERATOR;\n                    if (lexem.value.equals(\"<\"))\n                        if ((i + 1) < size) {\n                            if (((Lexem) lexems.get(i + 1)).value.equals(\"=\")) {\n                                code = codes.LE;\n                                value = \"<=\";\n                                i++;\n                            }\n                            if (((Lexem) lexems.get(i + 1)).value.equals(\">\")) {\n                                code = codes.NE;\n                                value = \"<>\";\n                                i++;\n                            }\n                        } else if (lexem.value.equals(\">\"))\n                            if ((i + 1) < size)\n                                if (((Lexem) lexems.get(i + 1)).value.equals(\"=\")) {\n                                    code = codes.GE;\n                                    value = \">=\";\n                                    i++;\n                                }\n                } else if ((code >= codes.PLUS) && (code <= codes.DIV)) {\n                    lcategory = codes.AOPERATOR;\n                }\n                AdvLexems.add(new AdvLexem(value, code, lcategory, hcategory, lexem.line, lexem.column));\n            } else\n                AdvLexems.add(new AdvLexem(lexem.value, lexem.type, codes.NUMBER, codes.WORD, lexem.line, lexem.column));\n            i++;\n        }\n        return AdvLexems;\n    }\n\n    // advScanning()\n    private String errorMess(String expected, AdvLexem found) {\n        return (\"expected: \" + expected + \"\\n   found: \" + found.value + \"\\n   line: \" + found.line + \"\\n   column: \" + found.column);\n    }\n\n    // errorMess()\n    private String errorMess(String expected) {\n        return (\"expected: \" + expected + \"   nothing found\");\n    }\n\n    // errorMess()\n    // checks if there is a lexem of given Code\n    private String checkC(String s, byte code, ArrayList AL) {\n        if (pos < AL.size()) {\n            AdvLexem al = (AdvLexem) AL.get(pos);\n            if (al.code != code)\n                return errorMess(s, al);\n        } else\n            return errorMess(s);\n        return \"\";\n    }\n\n    // checkC()\n    private String checkC(String s, byte code, ArrayList AL, int which) {\n        if (which < AL.size()) {\n            AdvLexem al = (AdvLexem) AL.get(which);\n            if (al.code != code)\n                return errorMess(s, al);\n        } else\n            return errorMess(s);\n        return \"\";\n    }\n\n    // checkC()\n    // checks if there is a lexem of given Lower category\n    private String checkL(String s, byte code, ArrayList AL) {\n        if (pos < AL.size()) {\n            AdvLexem al = (AdvLexem) AL.get(pos);\n            if (al.lcategory != code)\n                return errorMess(s, al);\n        } else\n            return errorMess(s);\n        return \"\";\n    }\n\n    // checkL()\n    // mmmmmmmmmmmmmmmmmmm\tVALIDATION\tmmmmmmmmmmmmmmmmmmmmmmmmmmm\n    public String checkStructure(ArrayList AL) {\n        Codes codes = new Codes();\n        codes.fillLists();\n        String result = \"\";\n        AdvLexem al;\n        int size = AL.size();\n        result = checkC(\"PROGRAM\", codes.PROGRAM, AL);\n        if (!(result.equals(\"\")))\n            return result;\n        pos++;\n        result = checkC(\"VARIABLE\", codes.VARIABLE, AL);\n        if (!(result.equals(\"\")))\n            return result;\n        pos++;\n        result = checkC(\"SEMICOLON\", codes.SEMICOLON, AL);\n        if (!(result.equals(\"\")))\n            return result;\n        pos++;\n        result = checkC(\"VAR\", codes.VAR, AL);\n        if (!(result.equals(\"\"))) {\n            result = checkC(\"VAR or BEGIN\", codes.BEGIN, AL);\n            if (!(result.equals(\"\")))\n                return result;\n        }\n        if ((((AdvLexem) AL.get(pos)).value).equals(\"VAR\")) {\n            pos++;\n            result = checkVAR(AL);\n            if (!(result.equals(\"\")))\n                return result;\n        }\n        // now we check if there is END. at the end of the program\n        if (AL.size() - 1 > pos) {\n            result = checkC(\"END.\", Codes.END_DOT, AL, AL.size() - 1);\n            if (!(result.equals(\"\")))\n                return result;\n        } else\n            return \"expected: END. at the end of program\";\n        // now we check if all VARIABLES are declared\n        for (int i = pos + 1; i < AL.size() - 2; i++) {\n            al = (AdvLexem) (AL.get(i));\n            if (al.code == Codes.VARIABLE)\n                if (!(vars.contains(al.value)))\n                    return \"cannot resolve symbol variable \" + al.value + \"\\n   line: \" + al.line + \"\\n   column: \" + al.column;\n        }\n        pos++;\n        main_begin = pos;\n        result = checkBody(AL);\n        /*\n//testing...\nSystem.out.println(\"Position = \" + pos);\nal = (AdvLexem)AL.get(pos);\nSystem.out.println(\"Lexem value = \" + al.value);\n*/\n        if (!(result.equals(\"\")))\n            return result;\n        return \"No errors !\";\n    }\n\n    // checkStructure\n    private String checkVAR(ArrayList AL) {\n        byte var_count = 0;\n        String result = \"\";\n        AdvLexem al = null;\n        // if BEGIN appears changes to TRUE\n        boolean finish_b = false;\n        // if there is no COMMA changes to TRUE\n        boolean finish_c = false;\n        while (!finish_b) {\n            result = checkC(\"BEGIN\", Codes.BEGIN, AL);\n            // if there is no BEGIN yet\n            if (!result.equals(\"\")) {\n                result = checkC(\"VARIABLE\", Codes.VARIABLE, AL);\n                // if there is a VARIABLE\n                if (!result.equals(\"\"))\n                    return result;\n                al = (AdvLexem) AL.get(pos);\n                if ((((AdvLexem) AL.get(1)).value).equals(al.value))\n                    return \"VARIABLE is already used as a neme of the program\" + \"\\n   line: \" + al.line + \"\\n   column: \" + al.column;\n                if (vars.contains(al.value))\n                    return (\"VARIABLE already declared: \" + al.value + \"\\n   line: \" + al.line + \"\\n   column: \" + al.column);\n                vars.add(al.value);\n                var_count++;\n                finish_c = false;\n                while (!finish_c) {\n                    pos++;\n                    result = checkC(\"COMMA\", Codes.COMMA, AL);\n                    if (result.equals(\"\")) {\n                        pos++;\n                        result = checkC(\"VARIABLE\", Codes.VARIABLE, AL);\n                        if (!result.equals(\"\"))\n                            return result;\n                        al = (AdvLexem) AL.get(pos);\n                        if ((((AdvLexem) AL.get(1)).value).equals(al.value))\n                            return \"VARIABLE is already used as a neme \" + \"of the program\" + \"\\n   line: \" + al.line + \"\\n   column: \" + al.column;\n                        if (vars.contains(al.value))\n                            return (\"VARIABLE already declared: \" + al.value + \"\\n   line: \" + al.line + \"\\n   column: \" + al.column);\n                        vars.add(al.value);\n                        var_count++;\n                    } else\n                        finish_c = true;\n                }\n                // while\n                result = checkC(\"COLON\", Codes.COLON, AL);\n                if (!result.equals(\"\"))\n                    return result;\n                pos++;\n                result = checkL(\"VARIABLE TYPE\", Codes.VTYPE, AL);\n                if (!result.equals(\"\"))\n                    return result;\n                byte code = ((AdvLexem) AL.get(pos)).code;\n                for (byte i = 0; i < var_count; i++) var_types.add(new Integer(code));\n                var_count = 0;\n                pos++;\n                result = checkC(\"SEMICOLON\", Codes.SEMICOLON, AL);\n                if (!result.equals(\"\"))\n                    return result;\n                pos++;\n            } else\n                finish_b = true;\n        }\n        // while\n        return \"\";\n    }\n\n    // checkVAR()\n    private String checkIASSOC(ArrayList AL) {\n        String result = \"\";\n        AdvLexem al = null;\n        // brackets count\n        byte b_count = 0;\n        // finish if no more brackets\n        boolean finish_b = false;\n        while (!finish_b) {\n            result = checkC(\"VALUE\", Codes.LBRACKET, AL);\n            if (!result.equals(\"\"))\n                finish_b = true;\n            else {\n                b_count++;\n                pos++;\n            }\n        }\n        result = checkC(\"VALUE\", Codes.MINUS, AL);\n        if (result.equals(\"\")) {\n            pos++;\n            result = checkC(\"INTEGER NUMBER\", Codes.INUMBER, AL);\n            if (result.equals(\"\")) {\n                al = (AdvLexem) AL.get(pos);\n                AL.set(pos - 1, new AdvLexem(\"-\" + al.value, al.code, al.lcategory, al.hcategory, al.line, al.column));\n                AL.remove(pos);\n            } else\n                return result;\n        } else {\n            result = checkC(\"INTEGER VALUE\", Codes.INUMBER, AL);\n            if (!result.equals(\"\")) {\n                result = checkC(\"INTEGER VARIABLE\", Codes.VARIABLE, AL);\n                if (!result.equals(\"\"))\n                    return result;\n                else {\n                    al = (AdvLexem) AL.get(pos);\n                    int tmp = vars.indexOf(al.value);\n                    if (!(((Integer) var_types.get(tmp)).equals(new Integer(Codes.INTEGER)))) {\n                        al = (AdvLexem) AL.get(pos);\n                        return \"INTEGER VARIABLE expected \" + \"\\n   found: \" + al.value + \"\\n   line: \" + al.line + \"\\n   column: \" + al.column;\n                    } else\n                        pos++;\n                }\n            } else\n                pos++;\n        }\n        finish_b = false;\n        while (!finish_b) {\n            result = checkC(\"OPERATOR\", Codes.RBRACKET, AL);\n            if (!result.equals(\"\"))\n                finish_b = true;\n            else {\n                if (b_count > 0) {\n                    b_count--;\n                    pos++;\n                } else {\n                    al = (AdvLexem) AL.get(pos);\n                    return \"RIGHT BRACKET not opened\" + \"\\n   line: \" + al.line + \"\\n   column: \" + al.column;\n                }\n            }\n        }\n        // if there is no operator\n        boolean finish_o = false;\n        while (!finish_o) {\n            result = checkL(\"ARITHMETIC OPERATOR\", Codes.AOPERATOR, AL);\n            if (!result.equals(\"\"))\n                finish_o = true;\n            else {\n                pos++;\n                finish_b = false;\n                while (!finish_b) {\n                    result = checkC(\"VALUE\", Codes.LBRACKET, AL);\n                    if (!result.equals(\"\"))\n                        finish_b = true;\n                    else {\n                        b_count++;\n                        pos++;\n                    }\n                }\n                result = checkC(\"VALUE\", Codes.MINUS, AL);\n                if (result.equals(\"\")) {\n                    pos++;\n                    result = checkC(\"INTEGER NUMBER\", Codes.INUMBER, AL);\n                    if (result.equals(\"\")) {\n                        al = (AdvLexem) AL.get(pos);\n                        AL.set(pos - 1, new AdvLexem(\"-\" + al.value, al.code, al.lcategory, al.hcategory, al.line, al.column));\n                        AL.remove(pos);\n                    } else\n                        return result;\n                } else {\n                    result = checkC(\"INTEGER VALUE\", Codes.INUMBER, AL);\n                    if (!result.equals(\"\")) {\n                        result = checkC(\"INTEGER VARIABLE\", Codes.VARIABLE, AL);\n                        if (!result.equals(\"\"))\n                            return result;\n                        else {\n                            al = (AdvLexem) AL.get(pos);\n                            int tmp = vars.indexOf(al.value);\n                            if (!(((Integer) var_types.get(tmp)).equals(new Integer(Codes.INTEGER)))) {\n                                al = (AdvLexem) AL.get(pos);\n                                return \"INTEGER VARIABLE expected \" + \"\\n   found: \" + al.value + \"\\n   line: \" + al.line + \"\\n   column: \" + al.column;\n                            } else\n                                pos++;\n                        }\n                    } else\n                        pos++;\n                }\n                finish_b = false;\n                while (!finish_b) {\n                    result = checkC(\"OPERATOR\", Codes.RBRACKET, AL);\n                    if (!result.equals(\"\"))\n                        finish_b = true;\n                    else {\n                        if (b_count > 0) {\n                            b_count--;\n                            pos++;\n                        } else {\n                            al = (AdvLexem) AL.get(pos);\n                            return \"RIGHT BRACKET not opened\" + \"\\n   line: \" + al.line + \"\\n   column: \" + al.column;\n                        }\n                    }\n                }\n            }\n        }\n        return \"\";\n    }\n\n    // checkIASSOC()\n    private String checkRASSOC(ArrayList AL) {\n        String result = \"\";\n        AdvLexem al = null;\n        // brackets count\n        byte b_count = 0;\n        // finish if no more brackets\n        boolean finish_b = false;\n        while (!finish_b) {\n            result = checkC(\"VALUE\", Codes.LBRACKET, AL);\n            if (!result.equals(\"\"))\n                finish_b = true;\n            else {\n                b_count++;\n                pos++;\n            }\n        }\n        result = checkC(\"VALUE\", Codes.MINUS, AL);\n        if (result.equals(\"\")) {\n            pos++;\n            result = checkC(\"INTEGER OR REAL NUMBER\", Codes.INUMBER, AL);\n            if ((result.equals(\"\")) || (checkC(\"\", Codes.RNUMBER, AL).equals(\"\"))) {\n                al = (AdvLexem) AL.get(pos);\n                AL.set(pos - 1, new AdvLexem(\"-\" + al.value, al.code, al.lcategory, al.hcategory, al.line, al.column));\n                AL.remove(pos);\n            } else\n                return result;\n        } else {\n            result = checkC(\"\", Codes.INUMBER, AL);\n            if (!((result.equals(\"\")) || (checkC(\"\", Codes.RNUMBER, AL).equals(\"\")))) {\n                result = checkC(\"INTEGER OR REAL VARIABLE\", Codes.VARIABLE, AL);\n                if (!result.equals(\"\"))\n                    return result;\n                else {\n                    al = (AdvLexem) AL.get(pos);\n                    int tmp = vars.indexOf(al.value);\n                    int type = ((Integer) var_types.get(tmp)).intValue();\n                    if (!((type == Codes.INTEGER) || (type == Codes.REAL))) {\n                        al = (AdvLexem) AL.get(pos);\n                        return \"INTEGER OR REAL VARIABLE expected \" + \"\\n   found: \" + al.value + \"\\n   line: \" + al.line + \"\\n   column: \" + al.column;\n                    } else\n                        pos++;\n                }\n            } else\n                pos++;\n        }\n        finish_b = false;\n        while (!finish_b) {\n            result = checkC(\"OPERATOR\", Codes.RBRACKET, AL);\n            if (!result.equals(\"\"))\n                finish_b = true;\n            else {\n                if (b_count > 0) {\n                    b_count--;\n                    pos++;\n                } else {\n                    al = (AdvLexem) AL.get(pos);\n                    return \"RIGHT BRACKET not opened\" + \"\\n   line: \" + al.line + \"\\n   column: \" + al.column;\n                }\n            }\n        }\n        // if there is no operator\n        boolean finish_o = false;\n        while (!finish_o) {\n            result = checkL(\"closing BRACKET\", Codes.AOPERATOR, AL);\n            if (!result.equals(\"\")) {\n                finish_o = true;\n                if (b_count > 0)\n                    return result;\n            } else {\n                pos++;\n                finish_b = false;\n                while (!finish_b) {\n                    result = checkC(\"VALUE\", Codes.LBRACKET, AL);\n                    if (!result.equals(\"\"))\n                        finish_b = true;\n                    else {\n                        b_count++;\n                        pos++;\n                    }\n                }\n                result = checkC(\"VALUE\", Codes.MINUS, AL);\n                if (result.equals(\"\")) {\n                    pos++;\n                    result = checkC(\"INTEGER OR REAL NUMBER\", Codes.INUMBER, AL);\n                    if ((result.equals(\"\")) || (checkC(\"\", Codes.RNUMBER, AL).equals(\"\"))) {\n                        al = (AdvLexem) AL.get(pos);\n                        AL.set(pos - 1, new AdvLexem(\"-\" + al.value, al.code, al.lcategory, al.hcategory, al.line, al.column));\n                        AL.remove(pos);\n                    } else\n                        return result;\n                } else {\n                    result = checkC(\"\", Codes.INUMBER, AL);\n                    if (!((result.equals(\"\")) || (checkC(\"\", Codes.RNUMBER, AL).equals(\"\")))) {\n                        result = checkC(\"INTEGER OR REAL VARIABLE\", Codes.VARIABLE, AL);\n                        if (!result.equals(\"\"))\n                            return result;\n                        else {\n                            al = (AdvLexem) AL.get(pos);\n                            int tmp = vars.indexOf(al.value);\n                            int type = ((Integer) var_types.get(tmp)).intValue();\n                            if (!((type == Codes.INTEGER) || (type == Codes.REAL))) {\n                                al = (AdvLexem) AL.get(pos);\n                                return \"INTEGER OR REAL VARIABLE expected \" + \"\\n   found: \" + al.value + \"\\n   line: \" + al.line + \"\\n   column: \" + al.column;\n                            } else\n                                pos++;\n                        }\n                    } else\n                        pos++;\n                }\n                finish_b = false;\n                while (!finish_b) {\n                    result = checkC(\"OPERATOR\", Codes.RBRACKET, AL);\n                    if (!result.equals(\"\"))\n                        finish_b = true;\n                    else {\n                        if (b_count > 0) {\n                            b_count--;\n                            pos++;\n                        } else {\n                            al = (AdvLexem) AL.get(pos);\n                            return \"RIGHT BRACKET not opened\" + \"\\n   line: \" + al.line + \"\\n   column: \" + al.column;\n                        }\n                    }\n                }\n            }\n        }\n        return \"\";\n    }\n\n    // checkRASSOC()\n    private String checkLEXPR(ArrayList AL) {\n        String result = \"\";\n        AdvLexem al = null;\n        // brackets count\n        byte b_count = 0;\n        boolean finish_o = false;\n        boolean finish_n = false;\n        boolean finish_b = false;\n        while (!finish_n) {\n            finish_b = false;\n            while (!finish_b) {\n                result = checkC(\"VALUE\", Codes.LBRACKET, AL);\n                if (!result.equals(\"\"))\n                    finish_b = true;\n                else {\n                    b_count++;\n                    pos++;\n                }\n            }\n            result = checkC(\"NOT\", Codes.NOT, AL);\n            if (!result.equals(\"\"))\n                finish_n = true;\n            else\n                pos++;\n        }\n        result = checkLEXPRNElem(AL);\n        if (result.equals(\"\")) {\n            result = checkL(\"RELATION OPERATOR\", Codes.ROPERATOR, AL);\n            if (!result.equals(\"\"))\n                return result;\n            else {\n                pos++;\n                result = checkLEXPRNElem(AL);\n                if (!result.equals(\"\"))\n                    return result;\n            }\n        } else {\n            result = checkLEXPRLElem(AL);\n            if (!result.equals(\"\"))\n                return result;\n        }\n        finish_b = false;\n        while (!finish_b) {\n            result = checkC(\"OPERATOR\", Codes.RBRACKET, AL);\n            if (!result.equals(\"\"))\n                finish_b = true;\n            else {\n                if (b_count > 0) {\n                    b_count--;\n                    pos++;\n                } else {\n                    al = (AdvLexem) AL.get(pos);\n                    return \"RIGHT BRACKET not opened\" + \"\\n   line: \" + al.line + \"\\n   column: \" + al.column;\n                }\n            }\n        }\n        finish_o = false;\n        while (!finish_o) {\n            result = checkL(\"closing BRACKET\", Codes.LOPERATOR, AL);\n            if (!result.equals(\"\")) {\n                finish_o = true;\n                if (b_count > 0)\n                    return result;\n            } else {\n                pos++;\n                finish_n = false;\n                while (!finish_n) {\n                    finish_b = false;\n                    while (!finish_b) {\n                        result = checkC(\"VALUE\", Codes.LBRACKET, AL);\n                        if (!result.equals(\"\"))\n                            finish_b = true;\n                        else {\n                            b_count++;\n                            pos++;\n                        }\n                    }\n                    result = checkC(\"NOT\", Codes.NOT, AL);\n                    if (!result.equals(\"\"))\n                        finish_n = true;\n                    else\n                        pos++;\n                }\n                result = checkLEXPRNElem(AL);\n                if (result.equals(\"\")) {\n                    result = checkL(\"RELATION OPERATOR\", Codes.ROPERATOR, AL);\n                    if (!result.equals(\"\"))\n                        return result;\n                    else {\n                        pos++;\n                        result = checkLEXPRNElem(AL);\n                        if (!result.equals(\"\"))\n                            return result;\n                    }\n                } else {\n                    result = checkLEXPRLElem(AL);\n                    if (!result.equals(\"\"))\n                        return result;\n                }\n                finish_b = false;\n                while (!finish_b) {\n                    result = checkC(\"OPERATOR\", Codes.RBRACKET, AL);\n                    if (!result.equals(\"\"))\n                        finish_b = true;\n                    else {\n                        if (b_count > 0) {\n                            b_count--;\n                            pos++;\n                        } else {\n                            al = (AdvLexem) AL.get(pos);\n                            return \"RIGHT BRACKET not opened\" + \"\\n   line: \" + al.line + \"\\n   column: \" + al.column;\n                        }\n                    }\n                }\n            }\n        }\n        return \"\";\n    }\n\n    // checkLEXPR()\n    private String checkWRITE(ArrayList AL) {\n        String result = \"\";\n        AdvLexem al = null;\n        result = checkC(\"LEFT BRACKET\", Codes.LBRACKET, AL);\n        if (!result.equals(\"\"))\n            return result;\n        pos++;\n        result = checkC(\"STRING or VARIABLE\", Codes.STRING, AL);\n        if (!(result.equals(\"\") || (checkC(\"\", Codes.VARIABLE, AL)).equals(\"\")))\n            return result;\n        pos++;\n        boolean finish_c = false;\n        while (!finish_c) {\n            result = checkC(\"COMMA\", Codes.COMMA, AL);\n            if (!result.equals(\"\"))\n                finish_c = true;\n            else {\n                pos++;\n                result = checkC(\"STRING or VARIABLE\", Codes.STRING, AL);\n                if (!(result.equals(\"\") || (checkC(\"\", Codes.VARIABLE, AL)).equals(\"\")))\n                    return result;\n                else\n                    pos++;\n            }\n        }\n        result = checkC(\"RIGHT BRACKET\", Codes.RBRACKET, AL);\n        if (!result.equals(\"\"))\n            return result;\n        pos++;\n        return \"\";\n    }\n\n    // checkWRITE()\n    private String checkREAD(ArrayList AL) {\n        String result = \"\";\n        AdvLexem al = null;\n        result = checkC(\"LEFT BRACKET\", Codes.LBRACKET, AL);\n        if (!result.equals(\"\"))\n            return result;\n        pos++;\n        result = checkC(\"VARIABLE\", Codes.VARIABLE, AL);\n        if (!result.equals(\"\"))\n            return result;\n        pos++;\n        result = checkC(\"RIGHT BRACKET\", Codes.RBRACKET, AL);\n        if (!result.equals(\"\"))\n            return result;\n        pos++;\n        return \"\";\n    }\n\n    // checkREAD()\n    //mmmmmmmmmmmmmmmmmm\tMAIN VALIDATOR   mmmmmmmmmmmmmmmmmmmmmmmmmmmmmm\n    private String checkBody(ArrayList AL) {\n        String result = \"\";\n        AdvLexem al = null;\n        int begins = 0;\n        while (true) {\n            al = (AdvLexem) AL.get(pos);\n            if (al.code == Codes.VARIABLE) {\n                pos++;\n                result = checkC(\"ASSOCIATE MARK\", Codes.ASOCIATE, AL);\n                if (!result.equals(\"\"))\n                    return result;\n                pos++;\n                int tmp = vars.indexOf(al.value);\n                int type = ((Integer) var_types.get(tmp)).intValue();\n                if (type == Codes.INTEGER) {\n                    result = checkIASSOC(AL);\n                    if (!result.equals(\"\"))\n                        return result;\n                } else if (type == Codes.REAL) {\n                    result = checkRASSOC(AL);\n                    if (!result.equals(\"\"))\n                        return result;\n                } else if (type == Codes.BOOLEAN) {\n                    result = checkLEXPR(AL);\n                    if (!result.equals(\"\"))\n                        return result;\n                }\n                result = checkEnding(AL);\n                if (!result.equals(\"\"))\n                    return result;\n            } else if (al.code == Codes.WRITELN) {\n                pos++;\n                result = checkWRITE(AL);\n                if (!result.equals(\"\"))\n                    return result;\n                result = checkEnding(AL);\n                if (!result.equals(\"\"))\n                    return result;\n            } else if (al.code == Codes.READLN) {\n                pos++;\n                result = checkREAD(AL);\n                if (!result.equals(\"\"))\n                    return result;\n                result = checkEnding(AL);\n                if (!result.equals(\"\"))\n                    return result;\n            } else if (al.code == Codes.WHILE) {\n                pos++;\n                result = checkLEXPR(AL);\n                if (!result.equals(\"\"))\n                    return result;\n                result = checkC(\"keyword DO\", Codes.DO, AL);\n                if (!result.equals(\"\"))\n                    return result;\n                pos++;\n                result = checkOne(AL);\n                if (!result.equals(\"\"))\n                    return result;\n            } else if (al.code == Codes.IF) {\n                pos++;\n                result = checkLEXPR(AL);\n                if (!result.equals(\"\"))\n                    return result;\n                result = checkC(\"keyword THEN\", Codes.THEN, AL);\n                if (!result.equals(\"\"))\n                    return result;\n                pos++;\n                result = checkOne(AL);\n                if (!result.equals(\"\"))\n                    return result;\n                result = checkC(\"keyword ELSE\", Codes.ELSE, AL);\n                if (result.equals(\"\")) {\n                    pos++;\n                    result = checkOne(AL);\n                    if (!result.equals(\"\"))\n                        return result;\n                }\n            } else if (al.code == Codes.BEGIN) {\n                AL.remove(pos);\n                result = checkBlock(AL);\n                if (!result.equals(\"\"))\n                    return result;\n                else {\n                    pos--;\n                    result = checkC(\"SEMICOLON\", Codes.SEMICOLON, AL);\n                    if (result.equals(\"\")) {\n                        AL.remove(pos);\n                        pos--;\n                    }\n                    AL.remove(pos);\n                }\n            } else if (al.code == Codes.END) {\n                return \"END without coresponding BEGIN\" + \"\\n   found: \" + al.value + \"\\n   line: \" + al.line + \"\\n   column: \" + al.column;\n            } else if (al.code == Codes.END_DOT) {\n                return \"\";\n            } else\n                return \"Not a statement\" + \"\\n   found: \" + al.value + \"\\n   line: \" + al.line + \"\\n   column: \" + al.column;\n        }\n    }\n\n    // checkBODY()\n    private String checkBlock(ArrayList AL) {\n        String result = \"\";\n        AdvLexem al = null;\n        int begins = 0;\n        while (true) {\n            al = (AdvLexem) AL.get(pos);\n            if (al.code == Codes.VARIABLE) {\n                pos++;\n                result = checkC(\"ASSOCIATE MARK\", Codes.ASOCIATE, AL);\n                if (!result.equals(\"\"))\n                    return result;\n                pos++;\n                int tmp = vars.indexOf(al.value);\n                int type = ((Integer) var_types.get(tmp)).intValue();\n                if (type == Codes.INTEGER) {\n                    result = checkIASSOC(AL);\n                    if (!result.equals(\"\"))\n                        return result;\n                } else if (type == Codes.REAL) {\n                    result = checkRASSOC(AL);\n                    if (!result.equals(\"\"))\n                        return result;\n                } else if (type == Codes.BOOLEAN) {\n                    result = checkLEXPR(AL);\n                    if (!result.equals(\"\"))\n                        return result;\n                }\n                result = checkEnding(AL);\n                if (!result.equals(\"\"))\n                    return result;\n            } else if (al.code == Codes.WRITELN) {\n                pos++;\n                result = checkWRITE(AL);\n                if (!result.equals(\"\"))\n                    return result;\n                result = checkEnding(AL);\n                if (!result.equals(\"\"))\n                    return result;\n            } else if (al.code == Codes.READLN) {\n                pos++;\n                result = checkREAD(AL);\n                if (!result.equals(\"\"))\n                    return result;\n                result = checkEnding(AL);\n                if (!result.equals(\"\"))\n                    return result;\n            } else if (al.code == Codes.WHILE) {\n                pos++;\n                result = checkLEXPR(AL);\n                if (!result.equals(\"\"))\n                    return result;\n                result = checkC(\"keyword DO\", Codes.DO, AL);\n                if (!result.equals(\"\"))\n                    return result;\n                pos++;\n                result = checkOne(AL);\n                if (!result.equals(\"\"))\n                    return result;\n            } else if (al.code == Codes.IF) {\n                pos++;\n                result = checkLEXPR(AL);\n                if (!result.equals(\"\"))\n                    return result;\n                result = checkC(\"keyword THEN\", Codes.THEN, AL);\n                if (!result.equals(\"\"))\n                    return result;\n                pos++;\n                result = checkOne(AL);\n                if (!result.equals(\"\"))\n                    return result;\n                result = checkC(\"keyword ELSE\", Codes.ELSE, AL);\n                if (result.equals(\"\")) {\n                    pos++;\n                    result = checkOne(AL);\n                    if (!result.equals(\"\"))\n                        return result;\n                }\n            } else if (al.code == Codes.BEGIN) {\n                pos++;\n                result = checkBlock(AL);\n                if (!result.equals(\"\"))\n                    return result;\n            } else if (al.code == Codes.END) {\n                pos++;\n                result = checkEnding(AL);\n                if (!result.equals(\"\"))\n                    return result;\n                else\n                    return \"\";\n            } else if (al.code == Codes.END_DOT) {\n                return \"END expected\" + \"\\n   line: \" + al.line + \"\\n   column: \" + al.column;\n            } else\n                return \"Not a statement\" + \"\\n   found: \" + al.value + \"\\n   line: \" + al.line + \"\\n   column: \" + al.column;\n        }\n    }\n\n    // checkBlock()\n    private String checkOne(ArrayList AL) {\n        String result = \"\";\n        AdvLexem al = null;\n        int begins = 0;\n        al = (AdvLexem) AL.get(pos);\n        if (al.code == Codes.VARIABLE) {\n            pos++;\n            result = checkC(\"ASSOCIATE MARK\", Codes.ASOCIATE, AL);\n            if (!result.equals(\"\"))\n                return result;\n            pos++;\n            int tmp = vars.indexOf(al.value);\n            int type = ((Integer) var_types.get(tmp)).intValue();\n            if (type == Codes.INTEGER) {\n                result = checkIASSOC(AL);\n                if (!result.equals(\"\"))\n                    return result;\n            } else if (type == Codes.REAL) {\n                result = checkRASSOC(AL);\n                if (!result.equals(\"\"))\n                    return result;\n            } else if (type == Codes.BOOLEAN) {\n                result = checkLEXPR(AL);\n                if (!result.equals(\"\"))\n                    return result;\n            }\n            return checkEnding(AL);\n        } else if (al.code == Codes.WRITELN) {\n            pos++;\n            result = checkWRITE(AL);\n            if (!result.equals(\"\"))\n                return result;\n            return checkEnding(AL);\n        } else if (al.code == Codes.READLN) {\n            pos++;\n            result = checkREAD(AL);\n            if (!result.equals(\"\"))\n                return result;\n            return checkEnding(AL);\n        } else if (al.code == Codes.WHILE) {\n            pos++;\n            result = checkLEXPR(AL);\n            if (!result.equals(\"\"))\n                return result;\n            result = checkC(\"keyword DO\", Codes.DO, AL);\n            if (!result.equals(\"\"))\n                return result;\n            pos++;\n            return checkOne(AL);\n        } else if (al.code == Codes.IF) {\n            pos++;\n            result = checkLEXPR(AL);\n            if (!result.equals(\"\"))\n                return result;\n            result = checkC(\"keyword THEN\", Codes.THEN, AL);\n            if (!result.equals(\"\"))\n                return result;\n            pos++;\n            result = checkOne(AL);\n            if (!result.equals(\"\"))\n                return result;\n            result = checkC(\"keyword ELSE\", Codes.ELSE, AL);\n            if (result.equals(\"\")) {\n                pos++;\n                return checkOne(AL);\n            } else\n                return \"\";\n        } else if (al.code == Codes.BEGIN) {\n            pos++;\n            return checkBlock(AL);\n        } else if (al.code == Codes.END) {\n            return \"END without coresponding BEGIN\" + \"\\n   found: \" + al.value + \"\\n   line: \" + al.line + \"\\n   column: \" + al.column;\n        } else if ((al.code == Codes.END_DOT) || (al.code == Codes.ELSE)) {\n            return \"INSTRUCTION expected\" + \"\\n   line: \" + al.line + \"\\n   column: \" + al.column;\n        } else\n            return \"Not a statement\" + \"\\n   found: \" + al.value + \"\\n   line: \" + al.line + \"\\n   column: \" + al.column;\n    }\n\n    // checkOne()\n    private String checkEnding(ArrayList AL) {\n        String result = \"\";\n        result = checkC(\"SEMICOLON\", Codes.SEMICOLON, AL);\n        if (!result.equals(\"\")) {\n            result = checkC(\"SEMICOLON\", Codes.END, AL);\n            if (!result.equals(\"\")) {\n                result = checkC(\"SEMICOLON\", Codes.ELSE, AL);\n                if (!result.equals(\"\")) {\n                    result = checkC(\"SEMICOLON\", Codes.END_DOT, AL);\n                    if (!result.equals(\"\"))\n                        return result;\n                }\n            }\n        } else\n            pos++;\n        return \"\";\n    }\n\n    // checkEnding()\n    // checks Logical EXPRexion Number Element\n    private String checkLEXPRNElem(ArrayList AL) {\n        String result = \"\";\n        AdvLexem al = null;\n        result = checkC(\"VALUE\", Codes.MINUS, AL);\n        if (result.equals(\"\")) {\n            pos++;\n            result = checkC(\"INTEGER OR REAL NUMBER\", Codes.INUMBER, AL);\n            if ((result.equals(\"\")) || (checkC(\"\", Codes.RNUMBER, AL).equals(\"\"))) {\n                al = (AdvLexem) AL.get(pos);\n                AL.set(pos - 1, new AdvLexem(\"-\" + al.value, al.code, al.lcategory, al.hcategory, al.line, al.column));\n                AL.remove(pos);\n                return \"\";\n            } else\n                return result;\n        } else {\n            result = checkC(\"\", Codes.INUMBER, AL);\n            if (!((result.equals(\"\")) || (checkC(\"\", Codes.RNUMBER, AL).equals(\"\")))) {\n                result = checkC(\"INTEGER OR REAL VARIABLE\", Codes.VARIABLE, AL);\n                if (!result.equals(\"\"))\n                    return result;\n                else {\n                    al = (AdvLexem) AL.get(pos);\n                    int tmp = vars.indexOf(al.value);\n                    int type = ((Integer) var_types.get(tmp)).intValue();\n                    if (!((type == Codes.INTEGER) || (type == Codes.REAL))) {\n                        al = (AdvLexem) AL.get(pos);\n                        return \"INTEGER OR REAL VARIABLE expected \" + \"\\n   found: \" + al.value + \"\\n   line: \" + al.line + \"\\n   column: \" + al.column;\n                    } else {\n                        pos++;\n                        return \"\";\n                    }\n                }\n            } else {\n                pos++;\n                return \"\";\n            }\n        }\n    }\n\n    // checkLEXPRNElem()\n    // checks Logical EXPRexion Logic Element\n    private String checkLEXPRLElem(ArrayList AL) {\n        String result = \"\";\n        AdvLexem al = null;\n        result = checkC(\"\", Codes.TRUE, AL);\n        if (!((result.equals(\"\")) || (checkC(\"\", Codes.FALSE, AL).equals(\"\")))) {\n            result = checkC(\"LOGICAL VALUE\", Codes.VARIABLE, AL);\n            if (!result.equals(\"\"))\n                return result;\n            else {\n                al = (AdvLexem) AL.get(pos);\n                int tmp = vars.indexOf(al.value);\n                int type = ((Integer) var_types.get(tmp)).intValue();\n                if (!(type == Codes.BOOLEAN)) {\n                    al = (AdvLexem) AL.get(pos);\n                    return \"expected: LOGICAL VALUE\" + \"\\n   found: \" + al.value + \"\\n   line: \" + al.line + \"\\n   column: \" + al.column;\n                } else {\n                    pos++;\n                    return \"\";\n                }\n            }\n        } else {\n            pos++;\n            return \"\";\n        }\n    }\n\n    // checkLEXPRLElem()\n    //mmmmmmmmmmmmmmmmmmmmmm\tINTERPRETER   mmmmmmmmmmmmmmmmmmmmmmmmmmm\n    private ArrayList interBody(ArrayList AL) {\n        ArrayList baze = new ArrayList();\n        String itype = \"\";\n        String variable = \"\";\n        int start = 0;\n        int finish = 0;\n        ArrayList iftrue = new ArrayList();\n        ArrayList ifelse = new ArrayList();\n        AdvLexem al = null;\n        while (true) {\n            al = (AdvLexem) AL.get(pos);\n            if (al.code == Codes.VARIABLE) {\n                variable = al.value;\n                pos++;\n                pos++;\n                start = pos;\n                int tmp = vars.indexOf(al.value);\n                int type = ((Integer) var_types.get(tmp)).intValue();\n                if (type == Codes.INTEGER) {\n                    checkIASSOC(AL);\n                    finish = pos - 1;\n                    itype = \"IASSOC\";\n                } else if (type == Codes.REAL) {\n                    checkRASSOC(AL);\n                    finish = pos - 1;\n                    itype = \"RASSOC\";\n                } else if (type == Codes.BOOLEAN) {\n                    checkLEXPR(AL);\n                    finish = pos - 1;\n                    itype = \"BASSOC\";\n                }\n                checkEnding(AL);\n            } else if (al.code == Codes.WRITELN) {\n                itype = \"WRITE\";\n                pos++;\n                start = pos;\n                checkWRITE(AL);\n                finish = pos - 1;\n                checkEnding(AL);\n            } else if (al.code == Codes.READLN) {\n                itype = \"READ\";\n                pos++;\n                start = pos;\n                checkREAD(AL);\n                finish = pos - 1;\n                checkEnding(AL);\n            } else if (al.code == Codes.WHILE) {\n                itype = \"WHILE\";\n                pos++;\n                start = pos;\n                checkLEXPR(AL);\n                finish = pos - 1;\n                pos++;\n                iftrue = interOne(AL);\n            } else if (al.code == Codes.IF) {\n                itype = \"IF\";\n                pos++;\n                start = pos;\n                checkLEXPR(AL);\n                finish = pos - 1;\n                pos++;\n                iftrue = interOne(AL);\n                if (checkC(\"keyword ELSE\", Codes.ELSE, AL).equals(\"\")) {\n                    pos++;\n                    ifelse = interOne(AL);\n                }\n            } else if (al.code == Codes.BEGIN) {\n                pos++;\n                return interBlock(AL);\n            } else if (al.code == Codes.END_DOT) {\n                pos++;\n                checkEnding(AL);\n                return baze;\n            }\n            baze.add(new ExecLexem(itype, variable, AL, start, finish, iftrue, ifelse));\n            iftrue = new ArrayList();\n            ifelse = new ArrayList();\n            variable = \"\";\n        }\n    }\n\n    // interBODY()\n    private ArrayList interBlock(ArrayList AL) {\n        ArrayList baze = new ArrayList();\n        String itype = \"\";\n        String variable = \"\";\n        int start = 0;\n        int finish = 0;\n        ArrayList iftrue = new ArrayList();\n        ArrayList ifelse = new ArrayList();\n        AdvLexem al = null;\n        while (true) {\n            al = (AdvLexem) AL.get(pos);\n            if (al.code == Codes.VARIABLE) {\n                variable = al.value;\n                pos++;\n                pos++;\n                start = pos;\n                int tmp = vars.indexOf(al.value);\n                int type = ((Integer) var_types.get(tmp)).intValue();\n                if (type == Codes.INTEGER) {\n                    checkIASSOC(AL);\n                    finish = pos - 1;\n                    itype = \"IASSOC\";\n                } else if (type == Codes.REAL) {\n                    checkRASSOC(AL);\n                    finish = pos - 1;\n                    itype = \"RASSOC\";\n                } else if (type == Codes.BOOLEAN) {\n                    checkLEXPR(AL);\n                    finish = pos - 1;\n                    itype = \"BASSOC\";\n                }\n                checkEnding(AL);\n            } else if (al.code == Codes.WRITELN) {\n                itype = \"WRITE\";\n                pos++;\n                start = pos;\n                checkWRITE(AL);\n                finish = pos - 1;\n                checkEnding(AL);\n            } else if (al.code == Codes.READLN) {\n                itype = \"READ\";\n                pos++;\n                start = pos;\n                checkREAD(AL);\n                finish = pos - 1;\n                checkEnding(AL);\n            } else if (al.code == Codes.WHILE) {\n                itype = \"WHILE\";\n                pos++;\n                start = pos;\n                checkLEXPR(AL);\n                finish = pos - 1;\n                pos++;\n                iftrue = interOne(AL);\n            } else if (al.code == Codes.IF) {\n                itype = \"IF\";\n                pos++;\n                start = pos;\n                checkLEXPR(AL);\n                finish = pos - 1;\n                pos++;\n                iftrue = interOne(AL);\n                if (checkC(\"keyword ELSE\", Codes.ELSE, AL).equals(\"\")) {\n                    pos++;\n                    ifelse = interOne(AL);\n                }\n            } else if (al.code == Codes.BEGIN) {\n                pos++;\n                return interBlock(AL);\n            } else if (al.code == Codes.END) {\n                pos++;\n                checkEnding(AL);\n                return baze;\n            }\n            baze.add(new ExecLexem(itype, variable, AL, start, finish, iftrue, ifelse));\n            iftrue = new ArrayList();\n            ifelse = new ArrayList();\n            variable = \"\";\n        }\n    }\n\n    // interBlock()\n    private ArrayList interOne(ArrayList AL) {\n        ArrayList baze = new ArrayList();\n        String itype = \"\";\n        String variable = \"\";\n        int start = 0;\n        int finish = 0;\n        ArrayList iftrue = new ArrayList();\n        ArrayList ifelse = new ArrayList();\n        AdvLexem al = null;\n        al = (AdvLexem) AL.get(pos);\n        if (al.code == Codes.VARIABLE) {\n            variable = al.value;\n            pos++;\n            pos++;\n            start = pos;\n            int tmp = vars.indexOf(al.value);\n            int type = ((Integer) var_types.get(tmp)).intValue();\n            if (type == Codes.INTEGER) {\n                checkIASSOC(AL);\n                finish = pos - 1;\n                itype = \"IASSOC\";\n            } else if (type == Codes.REAL) {\n                checkRASSOC(AL);\n                finish = pos - 1;\n                itype = \"RASSOC\";\n            } else if (type == Codes.BOOLEAN) {\n                checkLEXPR(AL);\n                finish = pos - 1;\n                itype = \"BASSOC\";\n            }\n            checkEnding(AL);\n        } else if (al.code == Codes.WRITELN) {\n            itype = \"WRITE\";\n            pos++;\n            start = pos;\n            checkWRITE(AL);\n            finish = pos - 1;\n            checkEnding(AL);\n        } else if (al.code == Codes.READLN) {\n            itype = \"READ\";\n            pos++;\n            start = pos;\n            checkREAD(AL);\n            finish = pos - 1;\n            checkEnding(AL);\n        } else if (al.code == Codes.WHILE) {\n            itype = \"WHILE\";\n            pos++;\n            start = pos;\n            checkLEXPR(AL);\n            finish = pos - 1;\n            pos++;\n            iftrue = interOne(AL);\n        } else if (al.code == Codes.IF) {\n            itype = \"IF\";\n            pos++;\n            start = pos;\n            checkLEXPR(AL);\n            finish = pos - 1;\n            pos++;\n            iftrue = interOne(AL);\n            if (checkC(\"keyword ELSE\", Codes.ELSE, AL).equals(\"\")) {\n                pos++;\n                ifelse = interOne(AL);\n            }\n        } else if (al.code == Codes.BEGIN) {\n            pos++;\n            return interBlock(AL);\n        }\n        baze.add(new ExecLexem(itype, variable, AL, start, finish, iftrue, ifelse));\n        return baze;\n    }\n\n    // checkOne()\n    //mmmmmmmmmmmmmmmmmmmmmmm\tEVALUATION\tmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm\n    private void initializeVars() {\n        for (int i = 0; i < var_types.size(); i++) if (((Integer) var_types.get(i)).intValue() == Codes.INTEGER)\n            var_vals.add(new Integer(0));\n        else if (((Integer) var_types.get(i)).intValue() == Codes.REAL)\n            var_vals.add(new Float(0));\n        else\n            var_vals.add(new Boolean(false));\n    }\n\n    // initializeVars()\n    private int evalInt(AdvLexem[] lex) {\n        ArrayList args = new ArrayList();\n        ArrayList oper = new ArrayList();\n        while (place < lex.length) {\n            if (lex[place].code == Codes.RBRACKET) {\n                break;\n            }\n            if (lex[place].code == Codes.INUMBER)\n                args.add(new Integer(lex[place].value));\n            else if (lex[place].code == Codes.VARIABLE) {\n                int tmp = vars.indexOf(lex[place].value);\n                args.add((Integer) var_vals.get(tmp));\n            } else if (lex[place].code == Codes.LBRACKET) {\n                place++;\n                args.add(new Integer(evalInt(lex)));\n            } else if (lex[place].lcategory == Codes.AOPERATOR)\n                oper.add(lex[place].value);\n            place++;\n        }\n        for (int i = 0; i < oper.size(); i++) if (((String) oper.get(i)).equals(\"*\")) {\n            int tmp1 = ((Integer) args.get(i)).intValue();\n            int tmp2 = ((Integer) args.get(i + 1)).intValue();\n            args.set(i, new Integer(tmp1 * tmp2));\n            args.remove(i + 1);\n            oper.remove(i);\n            i--;\n        } else if (((String) oper.get(i)).equals(\"/\")) {\n            int tmp1 = ((Integer) args.get(i)).intValue();\n            int tmp2 = ((Integer) args.get(i + 1)).intValue();\n            args.set(i, new Integer(tmp1 / tmp2));\n            args.remove(i + 1);\n            oper.remove(i);\n            i--;\n        }\n        for (int i = 0; i < oper.size(); i++) if (((String) oper.get(i)).equals(\"+\")) {\n            int tmp1 = ((Integer) args.get(i)).intValue();\n            int tmp2 = ((Integer) args.get(i + 1)).intValue();\n            args.set(i, new Integer(tmp1 + tmp2));\n            args.remove(i + 1);\n            oper.remove(i);\n            i--;\n        } else if (((String) oper.get(i)).equals(\"-\")) {\n            int tmp1 = ((Integer) args.get(i)).intValue();\n            int tmp2 = ((Integer) args.get(i + 1)).intValue();\n            args.set(i, new Integer(tmp1 - tmp2));\n            args.remove(i + 1);\n            oper.remove(i);\n            i--;\n        }\n        return ((Integer) args.get(0)).intValue();\n    }\n\n    // evalInt()\n    private float evalReal(AdvLexem[] lex) {\n        ArrayList args = new ArrayList();\n        ArrayList oper = new ArrayList();\n        while (place < lex.length) {\n            if (lex[place].code == Codes.RBRACKET) {\n                break;\n            }\n            if (lex[place].lcategory == Codes.NUMBER)\n                args.add(new Float(lex[place].value));\n            else if (lex[place].code == Codes.VARIABLE) {\n                int tmp = vars.indexOf(lex[place].value);\n                int type = ((Integer) var_types.get(tmp)).intValue();\n                if (type == Codes.INTEGER)\n                    args.add(new Float(((Integer) var_vals.get(tmp)).intValue()));\n                else\n                    args.add((Float) var_vals.get(tmp));\n            } else if (lex[place].code == Codes.LBRACKET) {\n                place++;\n                args.add(new Float(evalReal(lex)));\n            } else if (lex[place].lcategory == Codes.AOPERATOR)\n                oper.add(lex[place].value);\n            place++;\n        }\n        for (int i = 0; i < oper.size(); i++) if (((String) oper.get(i)).equals(\"*\")) {\n            float tmp1 = ((Float) args.get(i)).floatValue();\n            float tmp2 = ((Float) args.get(i + 1)).floatValue();\n            args.set(i, new Float(tmp1 * tmp2));\n            args.remove(i + 1);\n            oper.remove(i);\n            i--;\n        } else if (((String) oper.get(i)).equals(\"/\")) {\n            float tmp1 = ((Float) args.get(i)).floatValue();\n            float tmp2 = ((Float) args.get(i + 1)).floatValue();\n            args.set(i, new Float(tmp1 / tmp2));\n            args.remove(i + 1);\n            oper.remove(i);\n            i--;\n        }\n        for (int i = 0; i < oper.size(); i++) if (((String) oper.get(i)).equals(\"+\")) {\n            float tmp1 = ((Float) args.get(i)).floatValue();\n            float tmp2 = ((Float) args.get(i + 1)).floatValue();\n            args.set(i, new Float(tmp1 + tmp2));\n            args.remove(i + 1);\n            oper.remove(i);\n            i--;\n        } else if (((String) oper.get(i)).equals(\"-\")) {\n            float tmp1 = ((Float) args.get(i)).floatValue();\n            float tmp2 = ((Float) args.get(i + 1)).floatValue();\n            args.set(i, new Float(tmp1 - tmp2));\n            args.remove(i + 1);\n            oper.remove(i);\n            i--;\n        }\n        return ((Float) args.get(0)).floatValue();\n    }\n\n    // evalReal()\n    private boolean evalBool(AdvLexem[] lex) {\n        ArrayList args = new ArrayList();\n        ArrayList oper = new ArrayList();\n        ArrayList nots = new ArrayList();\n        int pointer = 0;\n        while (place < lex.length) {\n            if (lex[place].code == Codes.RBRACKET) {\n                break;\n            }\n            if (lex[place].code == Codes.VARIABLE) {\n                int tmp = vars.indexOf(lex[place].value);\n                int type = ((Integer) var_types.get(tmp)).intValue();\n                if (type == Codes.BOOLEAN)\n                    pointer = 1;\n                else\n                    pointer = 2;\n            }\n            if ((lex[place].code == Codes.TRUE) || (lex[place].code == Codes.FALSE))\n                args.add(new Boolean(lex[place].value));\n            else if (pointer == 1) {\n                int tmp = vars.indexOf(lex[place].value);\n                args.add((Boolean) var_vals.get(tmp));\n                pointer = 0;\n            } else if (lex[place].code == Codes.LBRACKET) {\n                place++;\n                args.add(new Boolean(evalBool(lex)));\n            } else if ((lex[place].code == Codes.AND) || (lex[place].code == Codes.OR))\n                oper.add(lex[place].value);\n            else if (lex[place].code == Codes.NOT)\n                nots.add(new Integer(args.size()));\n            else {\n                float tmp1 = 0;\n                float tmp2 = 0;\n                int rel = 0;\n                if (lex[place].lcategory == Codes.NUMBER)\n                    tmp1 = (new Float(lex[place].value)).floatValue();\n                else if (pointer == 2) {\n                    pointer = 0;\n                    int tmp = vars.indexOf(lex[place].value);\n                    int type = ((Integer) var_types.get(tmp)).intValue();\n                    if (type == Codes.INTEGER)\n                        tmp1 = ((Integer) var_vals.get(tmp)).intValue();\n                    else\n                        tmp1 = ((Float) var_vals.get(tmp)).floatValue();\n                }\n                place++;\n                rel = lex[place].code;\n                place++;\n                if (lex[place].lcategory == Codes.NUMBER)\n                    tmp2 = (new Float(lex[place].value)).floatValue();\n                else if (lex[place].code == Codes.VARIABLE) {\n                    int tmp = vars.indexOf(lex[place].value);\n                    int type = ((Integer) var_types.get(tmp)).intValue();\n                    if (type == Codes.INTEGER)\n                        tmp2 = ((Integer) var_vals.get(tmp)).intValue();\n                    else\n                        tmp2 = ((Float) var_vals.get(tmp)).floatValue();\n                }\n                boolean bool = false;\n                if (rel == Codes.E)\n                    bool = tmp1 == tmp2;\n                else if (rel == Codes.NE)\n                    bool = tmp1 != tmp2;\n                else if (rel == Codes.GT) {\n                    bool = tmp1 > tmp2;\n                } else if (rel == Codes.GE)\n                    bool = tmp1 >= tmp2;\n                else if (rel == Codes.LT)\n                    bool = tmp1 < tmp2;\n                else if (rel == Codes.LE)\n                    bool = tmp1 <= tmp2;\n                args.add(new Boolean(bool));\n            }\n            place++;\n        }\n        for (int i = 0; i < nots.size(); i++) {\n            int neg = ((Integer) nots.get(i)).intValue();\n            boolean temp = ((Boolean) args.get(neg)).booleanValue();\n            args.set(neg, new Boolean(!temp));\n        }\n        for (int i = 0; i < oper.size(); i++) if (((String) oper.get(i)).equals(\"AND\")) {\n            boolean tmp1 = ((Boolean) args.get(i)).booleanValue();\n            boolean tmp2 = ((Boolean) args.get(i + 1)).booleanValue();\n            args.set(i, new Boolean(tmp1 && tmp2));\n            args.remove(i + 1);\n            oper.remove(i);\n            i--;\n        }\n        for (int i = 0; i < oper.size(); i++) if (((String) oper.get(i)).equals(\"OR\")) {\n            boolean tmp1 = ((Boolean) args.get(i)).booleanValue();\n            boolean tmp2 = ((Boolean) args.get(i + 1)).booleanValue();\n            args.set(i, new Boolean(tmp1 || tmp2));\n            args.remove(i + 1);\n            oper.remove(i);\n            i--;\n        }\n        return ((Boolean) args.get(0)).booleanValue();\n    }\n\n    // evalBool()\n    //mmmmmmmmmmmmmmmmmmmmmmmmmmm\tEXECUTOR\tmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm\n    private void execute(ArrayList al) {\n        for (int i = 0; i < al.size(); i++) execLexem((ExecLexem) al.get(i));\n    }\n\n    // execute()\n    private void execLexem(ExecLexem el) {\n        if (el.type.equals(\"IASSOC\"))\n            execInt(el);\n        else if (el.type.equals(\"RASSOC\"))\n            execReal(el);\n        else if (el.type.equals(\"BASSOC\"))\n            execBool(el);\n        else if (el.type.equals(\"READ\"))\n            execRead(el);\n        else if (el.type.equals(\"WRITE\"))\n            execWrite(el);\n        else if (el.type.equals(\"WHILE\"))\n            execWhile(el);\n        else if (el.type.equals(\"IF\"))\n            execIf(el);\n    }\n\n    // execLexem()\n    private void execInt(ExecLexem el) {\n        int tmp = vars.indexOf(el.variable);\n        place = 0;\n        var_vals.set(tmp, new Integer(evalInt(el.lexems)));\n    }\n\n    // execInt()\n    private void execReal(ExecLexem el) {\n        int tmp = vars.indexOf(el.variable);\n        place = 0;\n        var_vals.set(tmp, new Float(evalReal(el.lexems)));\n    }\n\n    // execReal()\n    private void execBool(ExecLexem el) {\n        int tmp = vars.indexOf(el.variable);\n        place = 0;\n        var_vals.set(tmp, new Boolean(evalBool(el.lexems)));\n    }\n\n    // execBool()\n    private void execWhile(ExecLexem el) {\n        place = 0;\n        while (evalBool(el.lexems)) {\n            execute(el.iftrue);\n            place = 0;\n        }\n    }\n\n    // execWhile()\n    private void execIf(ExecLexem el) {\n        place = 0;\n        if (evalBool(el.lexems))\n            execute(el.iftrue);\n        else\n            execute(el.ifelse);\n    }\n\n    // execIf()\n    private void execRead(ExecLexem el) {\n        int tmp = vars.indexOf(el.lexems[1].value);\n        int type = ((Integer) var_types.get(tmp)).intValue();\n        String s = \"\";\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n            s = in.readLine();\n        } catch (Exception ex) {\n            System.out.println(\"Error during input operatiron !\");\n        }\n        if (type == Codes.INTEGER)\n            var_vals.set(tmp, new Integer(s));\n        else if (type == Codes.REAL)\n            var_vals.set(tmp, new Float(s));\n        else\n            var_vals.set(tmp, new Boolean(s));\n    }\n\n    // execRead()\n    private void execWrite(ExecLexem el) {\n        for (int i = 1; i < el.lexems.length; i = i + 2) if (el.lexems[i].code == Codes.STRING)\n            System.out.print(el.lexems[i].value);\n        else {\n            int tmp = vars.indexOf(el.lexems[i].value);\n            int type = ((Integer) var_types.get(tmp)).intValue();\n            String s = \"\";\n            if (type == Codes.INTEGER)\n                s = ((Integer) var_vals.get(tmp)).toString();\n            else if (type == Codes.REAL)\n                s = ((Float) var_vals.get(tmp)).toString();\n            else\n                s = ((Boolean) var_vals.get(tmp)).toString();\n            System.out.print(s);\n        }\n        System.out.println();\n    }\n    // execWrite()\n}\n\n// class Scanner\n//mmmmmmmmmmmmmmmmmmmm\tADDITIONAL CLASSES\tmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm\nclass Lexem {\n\n    String value;\n\n    byte type;\n\n    int line;\n\n    int column;\n\n    public Lexem(String value, byte type, int line, int column) {\n        if (type != Codes.STRING)\n            this.value = value.toUpperCase();\n        else\n            this.value = value;\n        this.type = type;\n        this.line = line;\n        this.column = column;\n    }\n\n    public Lexem(StringBuffer value, byte type, int line, int column) {\n        if (type != Codes.STRING)\n            this.value = value.toString().toUpperCase();\n        else\n            this.value = value.toString();\n        this.type = type;\n        this.line = line;\n        this.column = column;\n    }\n\n    public Lexem(int value, int type, int line, int column) {\n        char[] sign = new char[1];\n        sign[0] = (char) value;\n        this.value = new String(sign);\n        this.type = (byte) type;\n        this.line = line;\n        this.column = column;\n    }\n}\n\n// class Lexem\nclass AdvLexem {\n\n    String value;\n\n    byte code;\n\n    // lower category\n    byte lcategory;\n\n    // higher category\n    byte hcategory;\n\n    // custom category, if needed\n    byte ccategory;\n\n    int line;\n\n    int column;\n\n    public AdvLexem(String value, byte code, byte lcategory, byte hcategory, int line, int column) {\n        this.value = value;\n        this.code = code;\n        this.lcategory = lcategory;\n        this.hcategory = hcategory;\n        this.line = line;\n        this.column = column;\n    }\n    // AdvLexem()\n}\n\n// class AdvLexem\nclass ExecLexem {\n\n    // instruction type\n    String type;\n\n    // name of variable in association instruction\n    String variable;\n\n    // lexems of the given instruction\n    AdvLexem[] lexems;\n\n    ArrayList iftrue;\n\n    ArrayList ifelse;\n\n    ExecLexem(String type, String variable, ArrayList AL, int start, int finish, ArrayList iftrue, ArrayList ifelse) {\n        this.type = type;\n        this.variable = variable;\n        lexems = new AdvLexem[finish - start + 1];\n        for (int i = start, j = 0; i <= finish; i++, j++) lexems[j] = (AdvLexem) AL.get(i);\n        this.iftrue = iftrue;\n        this.ifelse = ifelse;\n    }\n    // ExecLexem()\n}\n// class ExecLexem\n",
		"id": "/EvoSuiteBenchmark/50_biff/src/main/java/Scanner_1Test.java",
		"test_prompt": "// Scanner_1Test.java\n\n\n/*\"Pascal interpreter written in Java\" jest przeznaczony do \n interpretacji kodu napisanego w j�zyku Pascal.\nCopyright (C) 2004/2005 Bartyna Waldemar, Faderewski Marek,\nFedorczyk �ukasz, Iwanowski Wojciech.\nNiniejszy program jest wolnym oprogramowaniem; mo�esz go \nrozprowadza� dalej i/lub modyfikowa� na warunkach Powszechnej\nLicencji Publicznej GNU, wydanej przez Fundacj� Wolnego\nOprogramowania - wed�ug wersji 2-giej tej Licencji lub kt�rej�\nz p�niejszych wersji. \n\nNiniejszy program rozpowszechniany jest z nadziej�, i� b�dzie on \nu�yteczny - jednak BEZ JAKIEJKOLWIEK GWARANCJI, nawet domy�lnej \ngwarancji PRZYDATNO�CI HANDLOWEJ albo PRZYDATNO�CI DO OKRE�LONYCH \nZASTOSOWA�. W celu uzyskania bli�szych informacji - Powszechna \nLicencja Publiczna GNU. \n\nZ pewno�ci� wraz z niniejszym programem otrzyma�e� te� egzemplarz \nPowszechnej Licencji Publicznej GNU (GNU General Public License);\nje�li nie - napisz do Free Software Foundation, Inc., 675 Mass Ave,\nCambridge, MA 02139, USA.\n*/\nimport java.io.*;\nimport java.util.ArrayList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Scanner}.\n* It contains ten unit test cases for the {@link Scanner#checkStructure(ArrayList)} method.\n*/\nclass Scanner_1Test {"
	}
]