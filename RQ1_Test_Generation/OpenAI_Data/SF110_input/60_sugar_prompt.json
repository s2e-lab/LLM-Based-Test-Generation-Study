[
	{
		"original_code": "// DefaultFSPath.java\n/**\r\n * Copyright 2008 (C) Keith Bishop (bishi@users.sourceforge.net)\r\n *\r\n * All rights reserved.\r\n *\r\n * This file is part of FSPath.\r\n *\r\n * FSPath is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * FSPath is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with FSPath.  If not, see <http://www.gnu.org/licenses/>.\r\n */\r\n/*\r\n * DefaultFSPath.java\r\n *\r\n * Created on 18 September 2006, 00:25\r\n *\r\n */\r\npackage net.sf.sugar.fspath;\r\n\r\nimport java.io.File;\r\nimport java.io.IOException;\r\nimport java.text.DateFormat;\r\nimport java.text.ParseException;\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.Date;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport javax.xml.namespace.QName;\r\nimport javax.xml.parsers.DocumentBuilder;\r\nimport javax.xml.parsers.DocumentBuilderFactory;\r\nimport javax.xml.parsers.ParserConfigurationException;\r\nimport javax.xml.xpath.XPath;\r\nimport javax.xml.xpath.XPathConstants;\r\nimport javax.xml.xpath.XPathExpressionException;\r\nimport javax.xml.xpath.XPathFactory;\r\nimport net.sf.sugar.fspath.xpath.RegexFunctionResolver;\r\nimport org.w3c.dom.Attr;\r\nimport org.w3c.dom.Document;\r\nimport org.w3c.dom.Element;\r\nimport org.w3c.dom.Node;\r\nimport org.w3c.dom.NodeList;\r\n\r\n/**\r\n *  The default implementation of the FSPath interface.\r\n *  This class uses the JDK's XPath implementation as the basis for\r\n *  FSPath queries.\r\n *  On instantiation, a DOM is created of the filesystem metadata starting form the <code>rootDirectory</code>.\r\n *  This DOM can then be queried using standard XML tools.\r\n *  <br/>\r\n *  Whilst this approach has been relatively quick to implement, it is still tied to the limitations of XPath.\r\n *  Future implementations of this class are likely to implement the FSPath language fully themselves wthout relying on XPath.\r\n *  <br/>\r\n *  todo: develop some front end substitution to enable the short queries i.e. /var/www etc\r\n *\r\n * @author keith\r\n *  $Id$\r\n */\r\npublic class DefaultFSPath implements FSPath {\r\n\r\n    /**\r\n     *  Escape characters, we must escape any characters that are\r\n     *  illegal in XML attribute text.\r\n     *\r\n     *  i.e. &amp; \" < >\r\n     */\r\n    private Map escapeChars;\r\n\r\n    private DocumentBuilder documentBuilder;\r\n\r\n    private XPath xpath;\r\n\r\n    private Document dom;\r\n\r\n    /**\r\n     *  The date format used to correspond to the xs:date format i.e. yyyy-MM-dd'T'HH:mm:ss.SSS\r\n     */\r\n    private DateFormat format;\r\n\r\n    private File rootDirectory;\r\n\r\n    public DefaultFSPath() {\r\n        //used for unit test instantiation\r\n        this.xpath = XPathFactory.newInstance().newXPath();\r\n        //this.xpath.setNamespaceContext(new FSNamespaceContext());\r\n        //this effectively enables the user of our custom XPath function\r\n        //fs:match()\r\n        this.xpath.setXPathFunctionResolver(new RegexFunctionResolver());\r\n        this.escapeChars = this.createEscapeCharsMap();\r\n        this.format = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSS\");\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of DefaultFSPath, based on the directory supplied\r\n     */\r\n    public DefaultFSPath(File currentDir) {\r\n        this();\r\n        this.rootDirectory = currentDir;\r\n        //check if file is a directory\r\n        if (!currentDir.isDirectory()) {\r\n            throw new InstantiationError(\"the java.io.File specified must be a Directory\");\r\n        }\r\n        try {\r\n            this.createDocumentBuilder();\r\n            //build DOM representation\r\n            this.dom = this.buildDOM(currentDir);\r\n        } catch (ParserConfigurationException pce) {\r\n            pce.printStackTrace();\r\n            throw new InstantiationError(\"FSDom threw a ParserConfigurationException : \" + pce.getMessage());\r\n        } catch (IOException ioe) {\r\n            ioe.printStackTrace();\r\n            throw new InstantiationError(\"FSDom threw an IOException : \" + ioe.getMessage());\r\n        }\r\n    }\r\n\r\n    protected Map createEscapeCharsMap() {\r\n        Map<String, String> escapeChars = new HashMap<String, String>();\r\n        escapeChars.put(\"&\", \"&#26;\");\r\n        escapeChars.put(\"<\", \"&#3c;\");\r\n        escapeChars.put(\">\", \"&#3e;\");\r\n        escapeChars.put(\"\\\"\", \"&#22;\");\r\n        return escapeChars;\r\n    }\r\n\r\n    protected void createDocumentBuilder() throws ParserConfigurationException {\r\n        try {\r\n            this.documentBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\r\n        } catch (ParserConfigurationException pce) {\r\n            pce.printStackTrace();\r\n            throw pce;\r\n        }\r\n    }\r\n\r\n    protected Document buildDOM(File currentDir) throws IOException {\r\n        Document dom = this.documentBuilder.newDocument();\r\n        dom.appendChild(this.createChildElement(dom, currentDir));\r\n        return dom;\r\n    }\r\n\r\n    private Element createChildElement(Document dom, File currentFile) throws IOException {\r\n        Element currentElement = null;\r\n        if (currentFile.isDirectory()) {\r\n            currentElement = dom.createElement(FSPathAttributes.dir.name());\r\n            //recurse and create child elements for all its children\r\n            File[] children = currentFile.listFiles();\r\n            if (children != null) {\r\n                for (int i = 0; i < children.length; i++) {\r\n                    currentElement.appendChild(this.createChildElement(dom, children[i]));\r\n                }\r\n            }\r\n        } else {\r\n            currentElement = dom.createElement(FSPathAttributes.file.name());\r\n        }\r\n        currentElement.setAttribute(FSPathAttributes.name.name(), currentFile.getName());\r\n        currentElement.setAttribute(FSPathAttributes.absolutePath.name(), currentFile.getAbsolutePath());\r\n        //optional for speed?\r\n        currentElement.setAttribute(FSPathAttributes.canRead.name(), Boolean.toString(currentFile.canRead()));\r\n        //optional for speed?\r\n        currentElement.setAttribute(FSPathAttributes.canWrite.name(), Boolean.toString(currentFile.canWrite()));\r\n        currentElement.setAttribute(FSPathAttributes.canonicalPath.name(), currentFile.getCanonicalPath());\r\n        //optional for speed?\r\n        currentElement.setAttribute(FSPathAttributes.exists.name(), Boolean.toString(currentFile.exists()));\r\n        currentElement.setAttribute(FSPathAttributes.isAbsolute.name(), Boolean.toString(currentFile.isAbsolute()));\r\n        currentElement.setAttribute(FSPathAttributes.isDirectory.name(), Boolean.toString(currentFile.isDirectory()));\r\n        currentElement.setAttribute(FSPathAttributes.isFile.name(), Boolean.toString(currentFile.isFile()));\r\n        currentElement.setAttribute(FSPathAttributes.isHidden.name(), Boolean.toString(currentFile.isHidden()));\r\n        currentElement.setAttribute(FSPathAttributes.lastModified.name(), this.format.format(new Date(currentFile.lastModified())));\r\n        currentElement.setAttribute(FSPathAttributes.length.name(), Long.toString(currentFile.length()));\r\n        currentElement.setAttribute(FSPathAttributes.parent.name(), currentFile.getParent());\r\n        currentElement.setAttribute(FSPathAttributes.path.name(), currentFile.getPath());\r\n        return currentElement;\r\n    }\r\n\r\n    /**\r\n     *  Calls this.query(expression, XPathConstants.NODESET)\r\n     *\r\n     *  Note : This method MUST be passed an expression which returns a nodeset.\r\n     *\r\n     *  @param expression the FSPath expression to execute.\r\n     *  @returns <code>FSPathResultList</code> the FSPathResult objects contained\r\n     *  in this list will be of type <code>java.io.File</code>,\r\n     *  <code>java.lang.Double</code>, <code>java.lang.Boolean</code>,\r\n     *  <code>java.lang.String</code>\r\n     */\r\n    public FSPathResultList query(String expression) {\r\n        return this.query(expression, XPathConstants.NODESET);\r\n    }\r\n\r\n    /**\r\n     */\r\n    public FSPathResultList query(String expression, QName returnType) {\r\n        FSPathResultList results = new FSPathResultListImpl();\r\n        try {\r\n            if (XPathConstants.NODESET.equals(returnType)) {\r\n                NodeList nodelist = (NodeList) this.xpath.evaluate(expression, this.dom.getDocumentElement(), XPathConstants.NODESET);\r\n                if (nodelist.getLength() > 0) {\r\n                    for (int i = 0; i < nodelist.getLength(); i++) {\r\n                        processNode(nodelist.item(i), results);\r\n                    }\r\n                }\r\n                return results;\r\n            }\r\n            if (XPathConstants.NODE.equals(returnType)) {\r\n                Node node = (Node) this.xpath.evaluate(expression, this.dom.getDocumentElement(), XPathConstants.NODE);\r\n                processNode(node, results);\r\n                return results;\r\n            }\r\n            if (XPathConstants.BOOLEAN.equals(returnType)) {\r\n                Boolean result = (Boolean) this.xpath.evaluate(expression, this.dom.getDocumentElement(), XPathConstants.BOOLEAN);\r\n                results.add(new FSPathResult(result));\r\n                return results;\r\n            }\r\n            if (XPathConstants.NUMBER.equals(returnType)) {\r\n                Double result = (Double) this.xpath.evaluate(expression, this.dom.getDocumentElement(), XPathConstants.NUMBER);\r\n                results.add(new FSPathResult(result));\r\n                return results;\r\n            }\r\n            if (XPathConstants.STRING.equals(returnType)) {\r\n                String result = (String) this.xpath.evaluate(expression, this.dom.getDocumentElement(), XPathConstants.STRING);\r\n                results.add(new FSPathResult(result));\r\n                return results;\r\n            }\r\n        } catch (XPathExpressionException xpee) {\r\n            System.out.println(\"Invalid FSPath expression : \" + xpee.getCause().getMessage());\r\n        } catch (IllegalArgumentException iae) {\r\n            iae.printStackTrace();\r\n            System.out.println(\"IllegalArgumentException\");\r\n        } catch (ParseException pe) {\r\n            pe.printStackTrace();\r\n            System.out.println(\"ParseException\");\r\n        }\r\n        return results;\r\n    }\r\n\r\n    private void processNode(Node node, FSPathResultList results) throws XPathExpressionException, IllegalArgumentException, ParseException {\r\n        //as the only elements in our dom are files or directories we will try to\r\n        //create File objects of those nodes.\r\n        if (node.getNodeType() == Node.ELEMENT_NODE) {\r\n            String fileName = node.getAttributes().getNamedItem(FSPathAttributes.absolutePath.name()).getNodeValue();\r\n            //System.out.println(\"Filename : \" + fileName);\r\n            results.add(new FSPathResult(new File(fileName)));\r\n            return;\r\n        }\r\n        if (node.getNodeType() == Node.ATTRIBUTE_NODE) {\r\n            Attr attr = (Attr) node;\r\n            //now work out which attirutes were Dates, Longs and Strings\r\n            if (FSPathAttributes.absolutePath.name().equals(attr.getName()) | FSPathAttributes.canonicalPath.name().equals(attr.getName()) | FSPathAttributes.name.name().equals(attr.getName()) | FSPathAttributes.parent.name().equals(attr.getName()) | FSPathAttributes.path.name().equals(attr.getName())) {\r\n                results.add(new FSPathResult(attr.getValue()));\r\n                return;\r\n            }\r\n            if (FSPathAttributes.canRead.name().equals(attr.getName()) | FSPathAttributes.canWrite.name().equals(attr.getName()) | FSPathAttributes.exists.name().equals(attr.getName()) | FSPathAttributes.isAbsolute.name().equals(attr.getName()) | FSPathAttributes.isDirectory.name().equals(attr.getName()) | FSPathAttributes.isFile.name().equals(attr.getName()) | FSPathAttributes.isHidden.name().equals(attr.getName())) {\r\n                results.add(new FSPathResult(new Boolean(attr.getValue())));\r\n                return;\r\n            }\r\n            if (FSPathAttributes.lastModified.name().equals(attr.getName())) {\r\n                results.add(new FSPathResult(this.format.parse(attr.getValue())));\r\n                return;\r\n            }\r\n            if (FSPathAttributes.length.name().equals(attr.getName())) {\r\n                results.add(new FSPathResult(Double.parseDouble(attr.getValue())));\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    public File getRootDirectory() {\r\n        return this.rootDirectory;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/60_sugar/src/main/java/net/sf/sugar/fspath/DefaultFSPath_0Test.java",
		"test_prompt": "// DefaultFSPath_0Test.java\n/*\n * DefaultFSPath.java\n *\n * Created on 18 September 2006, 00:25\n *\n */\npackage net.sf.sugar.fspath;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.text.DateFormat;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Map;\nimport javax.xml.namespace.QName;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpressionException;\nimport javax.xml.xpath.XPathFactory;\nimport net.sf.sugar.fspath.xpath.RegexFunctionResolver;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DefaultFSPath}.\n* It contains ten unit test cases for the {@link DefaultFSPath#query(String)} method.\n*/\nclass DefaultFSPath_0Test {"
	},
	{
		"original_code": "// DefaultFSPath.java\n/**\r\n * Copyright 2008 (C) Keith Bishop (bishi@users.sourceforge.net)\r\n *\r\n * All rights reserved.\r\n *\r\n * This file is part of FSPath.\r\n *\r\n * FSPath is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * FSPath is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with FSPath.  If not, see <http://www.gnu.org/licenses/>.\r\n */\r\n/*\r\n * DefaultFSPath.java\r\n *\r\n * Created on 18 September 2006, 00:25\r\n *\r\n */\r\npackage net.sf.sugar.fspath;\r\n\r\nimport java.io.File;\r\nimport java.io.IOException;\r\nimport java.text.DateFormat;\r\nimport java.text.ParseException;\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.Date;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport javax.xml.namespace.QName;\r\nimport javax.xml.parsers.DocumentBuilder;\r\nimport javax.xml.parsers.DocumentBuilderFactory;\r\nimport javax.xml.parsers.ParserConfigurationException;\r\nimport javax.xml.xpath.XPath;\r\nimport javax.xml.xpath.XPathConstants;\r\nimport javax.xml.xpath.XPathExpressionException;\r\nimport javax.xml.xpath.XPathFactory;\r\nimport net.sf.sugar.fspath.xpath.RegexFunctionResolver;\r\nimport org.w3c.dom.Attr;\r\nimport org.w3c.dom.Document;\r\nimport org.w3c.dom.Element;\r\nimport org.w3c.dom.Node;\r\nimport org.w3c.dom.NodeList;\r\n\r\n/**\r\n *  The default implementation of the FSPath interface.\r\n *  This class uses the JDK's XPath implementation as the basis for\r\n *  FSPath queries.\r\n *  On instantiation, a DOM is created of the filesystem metadata starting form the <code>rootDirectory</code>.\r\n *  This DOM can then be queried using standard XML tools.\r\n *  <br/>\r\n *  Whilst this approach has been relatively quick to implement, it is still tied to the limitations of XPath.\r\n *  Future implementations of this class are likely to implement the FSPath language fully themselves wthout relying on XPath.\r\n *  <br/>\r\n *  todo: develop some front end substitution to enable the short queries i.e. /var/www etc\r\n *\r\n * @author keith\r\n *  $Id$\r\n */\r\npublic class DefaultFSPath implements FSPath {\r\n\r\n    /**\r\n     *  Escape characters, we must escape any characters that are\r\n     *  illegal in XML attribute text.\r\n     *\r\n     *  i.e. &amp; \" < >\r\n     */\r\n    private Map escapeChars;\r\n\r\n    private DocumentBuilder documentBuilder;\r\n\r\n    private XPath xpath;\r\n\r\n    private Document dom;\r\n\r\n    /**\r\n     *  The date format used to correspond to the xs:date format i.e. yyyy-MM-dd'T'HH:mm:ss.SSS\r\n     */\r\n    private DateFormat format;\r\n\r\n    private File rootDirectory;\r\n\r\n    public DefaultFSPath() {\r\n        //used for unit test instantiation\r\n        this.xpath = XPathFactory.newInstance().newXPath();\r\n        //this.xpath.setNamespaceContext(new FSNamespaceContext());\r\n        //this effectively enables the user of our custom XPath function\r\n        //fs:match()\r\n        this.xpath.setXPathFunctionResolver(new RegexFunctionResolver());\r\n        this.escapeChars = this.createEscapeCharsMap();\r\n        this.format = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSS\");\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of DefaultFSPath, based on the directory supplied\r\n     */\r\n    public DefaultFSPath(File currentDir) {\r\n        this();\r\n        this.rootDirectory = currentDir;\r\n        //check if file is a directory\r\n        if (!currentDir.isDirectory()) {\r\n            throw new InstantiationError(\"the java.io.File specified must be a Directory\");\r\n        }\r\n        try {\r\n            this.createDocumentBuilder();\r\n            //build DOM representation\r\n            this.dom = this.buildDOM(currentDir);\r\n        } catch (ParserConfigurationException pce) {\r\n            pce.printStackTrace();\r\n            throw new InstantiationError(\"FSDom threw a ParserConfigurationException : \" + pce.getMessage());\r\n        } catch (IOException ioe) {\r\n            ioe.printStackTrace();\r\n            throw new InstantiationError(\"FSDom threw an IOException : \" + ioe.getMessage());\r\n        }\r\n    }\r\n\r\n    protected Map createEscapeCharsMap() {\r\n        Map<String, String> escapeChars = new HashMap<String, String>();\r\n        escapeChars.put(\"&\", \"&#26;\");\r\n        escapeChars.put(\"<\", \"&#3c;\");\r\n        escapeChars.put(\">\", \"&#3e;\");\r\n        escapeChars.put(\"\\\"\", \"&#22;\");\r\n        return escapeChars;\r\n    }\r\n\r\n    protected void createDocumentBuilder() throws ParserConfigurationException {\r\n        try {\r\n            this.documentBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\r\n        } catch (ParserConfigurationException pce) {\r\n            pce.printStackTrace();\r\n            throw pce;\r\n        }\r\n    }\r\n\r\n    protected Document buildDOM(File currentDir) throws IOException {\r\n        Document dom = this.documentBuilder.newDocument();\r\n        dom.appendChild(this.createChildElement(dom, currentDir));\r\n        return dom;\r\n    }\r\n\r\n    private Element createChildElement(Document dom, File currentFile) throws IOException {\r\n        Element currentElement = null;\r\n        if (currentFile.isDirectory()) {\r\n            currentElement = dom.createElement(FSPathAttributes.dir.name());\r\n            //recurse and create child elements for all its children\r\n            File[] children = currentFile.listFiles();\r\n            if (children != null) {\r\n                for (int i = 0; i < children.length; i++) {\r\n                    currentElement.appendChild(this.createChildElement(dom, children[i]));\r\n                }\r\n            }\r\n        } else {\r\n            currentElement = dom.createElement(FSPathAttributes.file.name());\r\n        }\r\n        currentElement.setAttribute(FSPathAttributes.name.name(), currentFile.getName());\r\n        currentElement.setAttribute(FSPathAttributes.absolutePath.name(), currentFile.getAbsolutePath());\r\n        //optional for speed?\r\n        currentElement.setAttribute(FSPathAttributes.canRead.name(), Boolean.toString(currentFile.canRead()));\r\n        //optional for speed?\r\n        currentElement.setAttribute(FSPathAttributes.canWrite.name(), Boolean.toString(currentFile.canWrite()));\r\n        currentElement.setAttribute(FSPathAttributes.canonicalPath.name(), currentFile.getCanonicalPath());\r\n        //optional for speed?\r\n        currentElement.setAttribute(FSPathAttributes.exists.name(), Boolean.toString(currentFile.exists()));\r\n        currentElement.setAttribute(FSPathAttributes.isAbsolute.name(), Boolean.toString(currentFile.isAbsolute()));\r\n        currentElement.setAttribute(FSPathAttributes.isDirectory.name(), Boolean.toString(currentFile.isDirectory()));\r\n        currentElement.setAttribute(FSPathAttributes.isFile.name(), Boolean.toString(currentFile.isFile()));\r\n        currentElement.setAttribute(FSPathAttributes.isHidden.name(), Boolean.toString(currentFile.isHidden()));\r\n        currentElement.setAttribute(FSPathAttributes.lastModified.name(), this.format.format(new Date(currentFile.lastModified())));\r\n        currentElement.setAttribute(FSPathAttributes.length.name(), Long.toString(currentFile.length()));\r\n        currentElement.setAttribute(FSPathAttributes.parent.name(), currentFile.getParent());\r\n        currentElement.setAttribute(FSPathAttributes.path.name(), currentFile.getPath());\r\n        return currentElement;\r\n    }\r\n\r\n    /**\r\n     *  Calls this.query(expression, XPathConstants.NODESET)\r\n     *\r\n     *  Note : This method MUST be passed an expression which returns a nodeset.\r\n     *\r\n     *  @param expression the FSPath expression to execute.\r\n     *  @returns <code>FSPathResultList</code> the FSPathResult objects contained\r\n     *  in this list will be of type <code>java.io.File</code>,\r\n     *  <code>java.lang.Double</code>, <code>java.lang.Boolean</code>,\r\n     *  <code>java.lang.String</code>\r\n     */\r\n    public FSPathResultList query(String expression) {\r\n        return this.query(expression, XPathConstants.NODESET);\r\n    }\r\n\r\n    /**\r\n     */\r\n    public FSPathResultList query(String expression, QName returnType) {\r\n        FSPathResultList results = new FSPathResultListImpl();\r\n        try {\r\n            if (XPathConstants.NODESET.equals(returnType)) {\r\n                NodeList nodelist = (NodeList) this.xpath.evaluate(expression, this.dom.getDocumentElement(), XPathConstants.NODESET);\r\n                if (nodelist.getLength() > 0) {\r\n                    for (int i = 0; i < nodelist.getLength(); i++) {\r\n                        processNode(nodelist.item(i), results);\r\n                    }\r\n                }\r\n                return results;\r\n            }\r\n            if (XPathConstants.NODE.equals(returnType)) {\r\n                Node node = (Node) this.xpath.evaluate(expression, this.dom.getDocumentElement(), XPathConstants.NODE);\r\n                processNode(node, results);\r\n                return results;\r\n            }\r\n            if (XPathConstants.BOOLEAN.equals(returnType)) {\r\n                Boolean result = (Boolean) this.xpath.evaluate(expression, this.dom.getDocumentElement(), XPathConstants.BOOLEAN);\r\n                results.add(new FSPathResult(result));\r\n                return results;\r\n            }\r\n            if (XPathConstants.NUMBER.equals(returnType)) {\r\n                Double result = (Double) this.xpath.evaluate(expression, this.dom.getDocumentElement(), XPathConstants.NUMBER);\r\n                results.add(new FSPathResult(result));\r\n                return results;\r\n            }\r\n            if (XPathConstants.STRING.equals(returnType)) {\r\n                String result = (String) this.xpath.evaluate(expression, this.dom.getDocumentElement(), XPathConstants.STRING);\r\n                results.add(new FSPathResult(result));\r\n                return results;\r\n            }\r\n        } catch (XPathExpressionException xpee) {\r\n            System.out.println(\"Invalid FSPath expression : \" + xpee.getCause().getMessage());\r\n        } catch (IllegalArgumentException iae) {\r\n            iae.printStackTrace();\r\n            System.out.println(\"IllegalArgumentException\");\r\n        } catch (ParseException pe) {\r\n            pe.printStackTrace();\r\n            System.out.println(\"ParseException\");\r\n        }\r\n        return results;\r\n    }\r\n\r\n    private void processNode(Node node, FSPathResultList results) throws XPathExpressionException, IllegalArgumentException, ParseException {\r\n        //as the only elements in our dom are files or directories we will try to\r\n        //create File objects of those nodes.\r\n        if (node.getNodeType() == Node.ELEMENT_NODE) {\r\n            String fileName = node.getAttributes().getNamedItem(FSPathAttributes.absolutePath.name()).getNodeValue();\r\n            //System.out.println(\"Filename : \" + fileName);\r\n            results.add(new FSPathResult(new File(fileName)));\r\n            return;\r\n        }\r\n        if (node.getNodeType() == Node.ATTRIBUTE_NODE) {\r\n            Attr attr = (Attr) node;\r\n            //now work out which attirutes were Dates, Longs and Strings\r\n            if (FSPathAttributes.absolutePath.name().equals(attr.getName()) | FSPathAttributes.canonicalPath.name().equals(attr.getName()) | FSPathAttributes.name.name().equals(attr.getName()) | FSPathAttributes.parent.name().equals(attr.getName()) | FSPathAttributes.path.name().equals(attr.getName())) {\r\n                results.add(new FSPathResult(attr.getValue()));\r\n                return;\r\n            }\r\n            if (FSPathAttributes.canRead.name().equals(attr.getName()) | FSPathAttributes.canWrite.name().equals(attr.getName()) | FSPathAttributes.exists.name().equals(attr.getName()) | FSPathAttributes.isAbsolute.name().equals(attr.getName()) | FSPathAttributes.isDirectory.name().equals(attr.getName()) | FSPathAttributes.isFile.name().equals(attr.getName()) | FSPathAttributes.isHidden.name().equals(attr.getName())) {\r\n                results.add(new FSPathResult(new Boolean(attr.getValue())));\r\n                return;\r\n            }\r\n            if (FSPathAttributes.lastModified.name().equals(attr.getName())) {\r\n                results.add(new FSPathResult(this.format.parse(attr.getValue())));\r\n                return;\r\n            }\r\n            if (FSPathAttributes.length.name().equals(attr.getName())) {\r\n                results.add(new FSPathResult(Double.parseDouble(attr.getValue())));\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    public File getRootDirectory() {\r\n        return this.rootDirectory;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/60_sugar/src/main/java/net/sf/sugar/fspath/DefaultFSPath_1Test.java",
		"test_prompt": "// DefaultFSPath_1Test.java\n/*\r\n * DefaultFSPath.java\r\n *\r\n * Created on 18 September 2006, 00:25\r\n *\r\n */\r\npackage net.sf.sugar.fspath;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.text.DateFormat;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Map;\nimport javax.xml.namespace.QName;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpressionException;\nimport javax.xml.xpath.XPathFactory;\nimport net.sf.sugar.fspath.xpath.RegexFunctionResolver;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DefaultFSPath}.\n* It contains ten unit test cases for the {@link DefaultFSPath#query(String, QName)} method.\n*/\nclass DefaultFSPath_1Test {"
	},
	{
		"original_code": "// RegexFunctionResolver.java\n/**\n * Copyright 2008 (C) Keith Bishop (bishi@users.sourceforge.net)\n *\n * All rights reserved.\n *\n * This file is part of FSPath.\n *\n * FSPath is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * FSPath is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with FSPath.  If not, see <http://www.gnu.org/licenses/>.\n */\n/*\n * RegexFunctionResolver.java\n *\n * Created on 23 April 2008, 21:57\n *\n */\npackage net.sf.sugar.fspath.xpath;\n\nimport javax.xml.namespace.QName;\nimport javax.xml.xpath.XPathFunction;\n\n/**\n *  This class is to be passed to an XPath instance in order to allow the\n *  XPath instance to resolve calls to the function re:matches(String, String) .\n *\n *  Calls to this XPath funciton will invoke the RegexFunction XPathFunction implementation\n *  defined in this package.\n *\n *  @author kbishop\n *  @version $Id$\n */\npublic class RegexFunctionResolver implements javax.xml.xpath.XPathFunctionResolver {\n\n    private QName regexQName;\n\n    /**\n     * Creates a new instance of RegexFunctionResolver\n     */\n    public RegexFunctionResolver() {\n        this.regexQName = new QName(null, \"matches\", \"re\");\n    }\n\n    public XPathFunction resolveFunction(QName functionName, int arity) {\n        if (arity == 2 && //&& this.regexQName.getPrefix().equals(functionName.getPrefix())\n        this.regexQName.getLocalPart().equals(functionName.getLocalPart())) {\n            return new RegexFunction();\n        }\n        return null;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/60_sugar/src/main/java/net/sf/sugar/fspath/xpath/RegexFunctionResolver.java",
		"test_prompt": "// RegexFunctionResolverTest.java\n/*\n * RegexFunctionResolver.java\n *\n * Created on 23 April 2008, 21:57\n *\n */\npackage net.sf.sugar.fspath.xpath;\n\nimport javax.xml.namespace.QName;\nimport javax.xml.xpath.XPathFunction;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RegexFunctionResolver}.\n* It contains ten unit test cases for the {@link RegexFunctionResolver#resolveFunction(QName, int)} method.\n*/\nclass RegexFunctionResolverTest {"
	},
	{
		"original_code": "// RegexFunction.java\n/**\n * Copyright 2008 (C) Keith Bishop (bishi@users.sourceforge.net)\n *\n * All rights reserved.\n *\n * This file is part of FSPath.\n *\n * FSPath is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * FSPath is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with FSPath.  If not, see <http://www.gnu.org/licenses/>.\n */\n/*\n * RegexFunction.java\n *\n * Created on 23 April 2008, 22:30\n *\n */\npackage net.sf.sugar.fspath.xpath;\n\nimport java.util.List;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport javax.xml.xpath.XPathFunctionException;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\n/**\n * \tThis class enables the use of regular expressions in FSPath queries.\n *   For instance :\n *   <pre>\n *   //file[fs:matches('[0-9]{6}-[\\w]{4}\\.log')]\n *   </pre>\n *   would match files of the pattern nnnnnn-xxxx.log where n is a numerical character and x is a word character.\n *\n *  @author kbishop\n *  @version $Id$\n */\npublic class RegexFunction implements javax.xml.xpath.XPathFunction {\n\n    private Pattern mostRecentPattern;\n\n    private String mostRecentExpression;\n\n    /**\n     * Creates a new instance of RegexFunction\n     */\n    public RegexFunction() {\n    }\n\n    /**\n     */\n    public Object evaluate(List args) throws XPathFunctionException {\n        String nodeValue = this.getNodeValue(args);\n        Pattern pattern = this.getPattern(args);\n        Boolean isMatch = new Boolean(pattern.matcher(nodeValue).matches());\n        return isMatch;\n    }\n\n    protected String getNodeValue(List args) throws XPathFunctionException {\n        //we know there will be two args\n        Object o = args.get(0);\n        String nodeValue = \"\";\n        if (o instanceof String) {\n            nodeValue = (String) o;\n        } else if (o instanceof Boolean) {\n            nodeValue = o.toString();\n        } else if (o instanceof Double) {\n            nodeValue = o.toString();\n        } else if (o instanceof NodeList) {\n            nodeValue = ((Node) ((NodeList) o).item(0)).getTextContent();\n        } else {\n            throw new XPathFunctionException(\"Unable to evaluate fs:match() function, could not convert argument type\");\n        }\n        return nodeValue;\n    }\n\n    protected Pattern getPattern(List args) throws XPathFunctionException {\n        try {\n            String expression = (String) args.get(1);\n            //For situations where the expression is being applied to a large number of nodes\n            //it's desrable to only compile the pattern once.\n            if (this.mostRecentExpression == null || !(expression.equals(this.mostRecentExpression))) {\n                this.mostRecentExpression = expression;\n                Pattern pattern = Pattern.compile(this.mostRecentExpression);\n                this.mostRecentPattern = pattern;\n            }\n            return this.mostRecentPattern;\n        } catch (ClassCastException cce) {\n            throw new XPathFunctionException(\"Unable to evaluate fs:match() function, the second parameter must evaluate to a String type\");\n        } catch (PatternSyntaxException pse) {\n            throw new XPathFunctionException(\"Unable to evaluate fs:match() function, the second parameter is not a valid regex : \" + pse.getMessage());\n        }\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/60_sugar/src/main/java/net/sf/sugar/fspath/xpath/RegexFunction.java",
		"test_prompt": "// RegexFunctionTest.java\n/*\n * RegexFunction.java\n *\n * Created on 23 April 2008, 22:30\n *\n */\npackage net.sf.sugar.fspath.xpath;\n\nimport java.util.List;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport javax.xml.xpath.XPathFunctionException;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RegexFunction}.\n* It contains ten unit test cases for the {@link RegexFunction#evaluate(List)} method.\n*/\nclass RegexFunctionTest {"
	},
	{
		"original_code": "// FSPathFactory.java\n/**\n * Copyright 2008 (C) Keith Bishop (bishi@users.sourceforge.net)\n *\n * All rights reserved.\n *\n * This file is part of FSPath.\n *\n * FSPath is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * FSPath is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with FSPath.  If not, see <http://www.gnu.org/licenses/>.\n */\n/*\n * FSPathFactory.java\n *\n * Created on 06 April 2008, 17:04\n *\n *\n */\npackage net.sf.sugar.fspath;\n\nimport java.io.File;\n\n/**\n * @author kbishop\n */\npublic class FSPathFactory {\n\n    /**\n     * Creates a new instance of FSPathFactory\n     */\n    public FSPathFactory() {\n    }\n\n    /**\n     *  @returns FSPath a new DefaultFSPath instance which uses the current user directory (System.getProperty(\"user.dir\")) to search from.\n     */\n    public static FSPath newFSPath() {\n        return new DefaultFSPath(new File(System.getProperty(\"user.dir\")));\n    }\n\n    /**\n     *  @returns FSPath a new DefaultFSPath instance which uses the directory provided to search from.\n     */\n    public static FSPath newFSPath(File file) {\n        return new DefaultFSPath(file);\n    }\n\n    /**\n     *  @returns FSPath a new DefaultFSPath instance which uses the directory path String provided to search from.\n     */\n    public static FSPath newFSPath(String path) {\n        return new DefaultFSPath(new File(path));\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/60_sugar/src/main/java/net/sf/sugar/fspath/FSPathFactory_0Test.java",
		"test_prompt": "// FSPathFactory_0Test.java\n/*\n * FSPathFactory.java\n *\n * Created on 06 April 2008, 17:04\n *\n *\n */\npackage net.sf.sugar.fspath;\n\nimport java.io.File;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FSPathFactory}.\n* It contains ten unit test cases for the {@link FSPathFactory#newFSPath()} method.\n*/\nclass FSPathFactory_0Test {"
	},
	{
		"original_code": "// FSPathFactory.java\n/**\n * Copyright 2008 (C) Keith Bishop (bishi@users.sourceforge.net)\n *\n * All rights reserved.\n *\n * This file is part of FSPath.\n *\n * FSPath is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * FSPath is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with FSPath.  If not, see <http://www.gnu.org/licenses/>.\n */\n/*\n * FSPathFactory.java\n *\n * Created on 06 April 2008, 17:04\n *\n *\n */\npackage net.sf.sugar.fspath;\n\nimport java.io.File;\n\n/**\n * @author kbishop\n */\npublic class FSPathFactory {\n\n    /**\n     * Creates a new instance of FSPathFactory\n     */\n    public FSPathFactory() {\n    }\n\n    /**\n     *  @returns FSPath a new DefaultFSPath instance which uses the current user directory (System.getProperty(\"user.dir\")) to search from.\n     */\n    public static FSPath newFSPath() {\n        return new DefaultFSPath(new File(System.getProperty(\"user.dir\")));\n    }\n\n    /**\n     *  @returns FSPath a new DefaultFSPath instance which uses the directory provided to search from.\n     */\n    public static FSPath newFSPath(File file) {\n        return new DefaultFSPath(file);\n    }\n\n    /**\n     *  @returns FSPath a new DefaultFSPath instance which uses the directory path String provided to search from.\n     */\n    public static FSPath newFSPath(String path) {\n        return new DefaultFSPath(new File(path));\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/60_sugar/src/main/java/net/sf/sugar/fspath/FSPathFactory_1Test.java",
		"test_prompt": "// FSPathFactory_1Test.java\n/*\n * FSPathFactory.java\n *\n * Created on 06 April 2008, 17:04\n *\n *\n */\npackage net.sf.sugar.fspath;\n\nimport java.io.File;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FSPathFactory}.\n* It contains ten unit test cases for the {@link FSPathFactory#newFSPath(File)} method.\n*/\nclass FSPathFactory_1Test {"
	},
	{
		"original_code": "// FSPathFactory.java\n/**\n * Copyright 2008 (C) Keith Bishop (bishi@users.sourceforge.net)\n *\n * All rights reserved.\n *\n * This file is part of FSPath.\n *\n * FSPath is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * FSPath is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with FSPath.  If not, see <http://www.gnu.org/licenses/>.\n */\n/*\n * FSPathFactory.java\n *\n * Created on 06 April 2008, 17:04\n *\n *\n */\npackage net.sf.sugar.fspath;\n\nimport java.io.File;\n\n/**\n * @author kbishop\n */\npublic class FSPathFactory {\n\n    /**\n     * Creates a new instance of FSPathFactory\n     */\n    public FSPathFactory() {\n    }\n\n    /**\n     *  @returns FSPath a new DefaultFSPath instance which uses the current user directory (System.getProperty(\"user.dir\")) to search from.\n     */\n    public static FSPath newFSPath() {\n        return new DefaultFSPath(new File(System.getProperty(\"user.dir\")));\n    }\n\n    /**\n     *  @returns FSPath a new DefaultFSPath instance which uses the directory provided to search from.\n     */\n    public static FSPath newFSPath(File file) {\n        return new DefaultFSPath(file);\n    }\n\n    /**\n     *  @returns FSPath a new DefaultFSPath instance which uses the directory path String provided to search from.\n     */\n    public static FSPath newFSPath(String path) {\n        return new DefaultFSPath(new File(path));\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/60_sugar/src/main/java/net/sf/sugar/fspath/FSPathFactory_2Test.java",
		"test_prompt": "// FSPathFactory_2Test.java\n/*\n * FSPathFactory.java\n *\n * Created on 06 April 2008, 17:04\n *\n *\n */\npackage net.sf.sugar.fspath;\n\nimport java.io.File;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FSPathFactory}.\n* It contains ten unit test cases for the {@link FSPathFactory#newFSPath(String)} method.\n*/\nclass FSPathFactory_2Test {"
	},
	{
		"original_code": "// FSPathResultListImpl.java\n/**\n * Copyright 2008 (C) Keith Bishop (bishi@users.sourceforge.net)\n *\n * All rights reserved.\n *\n * This file is part of FSPath.\n *\n * FSPath is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * FSPath is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with FSPath.  If not, see <http://www.gnu.org/licenses/>.\n */\n/*\n * FSPathResultListImpl.java\n *\n * Created on 08 April 2008, 18:00\n *\n */\npackage net.sf.sugar.fspath;\n\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * @author kbishop\n * @version $Id$\n */\npublic class FSPathResultListImpl extends ArrayList<FSPathResult> implements FSPathResultList {\n\n    /**\n     * Creates a new instance of FSPathResultListImpl\n     */\n    public FSPathResultListImpl() {\n    }\n\n    /**\n     *  A convenience method for defining custom filesystem interaction\n     *  across the whole list of results.\n     *\n     *  This method loops through the results and calls the call(Result result)\n     *  method of the Callback class passed to it for each individual result.\n     *\n     *  @param Callback - a custom implementation of the Callback interface.\n     *  @throws IOException\n     */\n    public FSPathResultList each(Callback callback) throws IOException {\n        for (FSPathResult result : this) {\n            callback.call(result);\n        }\n        return this;\n    }\n\n    /**\n     *  Deletes each file contained in this FSPathResultList.\n     *  <br/>\n     *  <pre>\n     *  ************************************************************************\n     *  *               IMPORTANT !!!!!    Use with caution                    *\n     *  *   This method makes it extremely easy to trash your filesystem       *\n     *  *   Its advised that FSPath queries are tested thouroughly before use  *\n     *  *   in order to verify which files would be deleted                    *\n     *  *                                                                      *\n     *  ************************************************************************\n     *  </pre>\n     *  @returns FSPathResultModificationListImpl - all successfully deleted files<br/>\n     *  will be added as a success, and the failures will be added as failures.\n     *\n     *  @throws IOException - NOTE this method does not currently thrown an IOException\n     *  @throws OperationNotPermittedException - this exception will be thrown if<br/>\n     *  The FSPathResult objects contained in this FSPathResultList don't contain<br/>\n     *  java.io.File objects<br/>\n     *  (i.e the FSPath query was written to return Boolean, String nor numerical results).\n     */\n    public FSPathResultModificationList delete() throws IOException, OperationNotPermittedException {\n        if (!isListOfFiles()) {\n            throw new OperationNotPermittedException(\"Delete is only permitted on FSPathResult objects containing a File object\");\n        }\n        FSPathResultModificationList deletionList = new FSPathResultModificationListImpl();\n        for (FSPathResult result : this) {\n            try {\n                File file = result.getFile();\n                boolean success = file.delete();\n                if (success) {\n                    deletionList.addSuccess(result);\n                } else {\n                    deletionList.addFailure(result);\n                }\n            } catch (Exception e) {\n                //todo: log this ?\n                deletionList.addFailure(result);\n            }\n        }\n        return deletionList;\n    }\n\n    /**\n     *  This method will copy each file contained in this FSPathResultList to the\n     *  destination path supplied.\n     *\n     *  @param String - the destination path which you would like to copy files to.\n     *\n     *  @returns FSPathResultModificationListImpl - all successfully copied files\n     *  will be added as a success, and the failures will be added as failures.\n     *\n     *  @param String the absolute or realtive path of the destination Directory\n     *  @throws IOException - NOTE this is currently not thrown by this method.\n     *  @throws OperationNotPermittedException - this exception is thrown upon\n     *  the following conditions :<br/>\n     *  <br/>\n     *  1)  The FSPathResult objects contained in this FSPathResultList don't contain<br/>\n     *      java.io.File objects<br/>\n     *      (i.e the FSPath query was written to return Boolean, String nor numerical results).<br/>\n     *  2)  The directory denoted by the destination path doesn't exist.<br/>\n     *  3)  The destination path doesn't resolve to a directory.<br/>\n     *  4)  The destination path isn't writeable.<br/>\n     *  5)  The current java process doesn't have sufficient priveledges to<br/>\n     *      access the destination path.<br/>\n     */\n    public FSPathResultModificationList copy(String destinationDirPath) throws IOException, OperationNotPermittedException {\n        if (!isListOfFiles()) {\n            throw new OperationNotPermittedException(\"Copy is only permitted on FSPathResult objects containing a java.io.File object\");\n        }\n        File destinationDir = new File(destinationDirPath);\n        try {\n            if (!destinationDir.exists()) {\n                throw new OperationNotPermittedException(\"Unable to copy to a directory that doesn't exist\");\n            }\n            if (!destinationDir.isDirectory()) {\n                throw new OperationNotPermittedException(\"Destination path \" + destinationDir.getAbsolutePath() + \" does not resolve to a directory\");\n            }\n            if (!destinationDir.canWrite()) {\n                throw new OperationNotPermittedException(\"Desination path \" + destinationDir.getAbsolutePath() + \" is not writable\");\n            }\n        } catch (SecurityException se) {\n            throw new OperationNotPermittedException(\"The current process does not have sufficent priveledges to access \" + destinationDir.getAbsolutePath(), se);\n        }\n        FSPathResultModificationList results = new FSPathResultModificationListImpl();\n        for (FSPathResult result : this) {\n            File destinationFile = new File(destinationDir + result.getFile().getName());\n            try {\n                FileReader inputReader = new FileReader(result.getFile());\n                FileWriter outputReader = new FileWriter(destinationFile);\n                int charsRead = 0;\n                while ((charsRead = inputReader.read()) != -1) {\n                    outputReader.write(charsRead);\n                }\n                inputReader.close();\n                outputReader.close();\n                results.addSuccess(new FSPathResult(destinationFile));\n            } catch (Exception e) {\n                results.addFailure(new FSPathResult(destinationFile));\n            }\n        }\n        return results;\n    }\n\n    public boolean isListOfFiles() {\n        return (this.size() > 0 && this.get(0).getFile() != null);\n    }\n\n    /**\n     *  Renames each file in the FSPathResultList based on a regex match\n     *  expression and a replace expression.\n     *  <br/>\n     *  This method is designed to enable simple renaming i.e. renaming from<br/>\n     *  \"a.txt\" to \"b.txt\" but also complex renaming using regular expressions.<br/>\n     *  <br/>\n     *  Example simple renaming : <br/>\n     *  <pre>fspath.query(\"/dir[@name='logs']/file[@name='error.log']\").rename(\"error.log\", \"error.log.1\");</pre> <br/>\n     *  This would work fine for a single file but not much use for multiple files.<br/>\n     *  <br/>\n     *  Example complex renaming : <br/>\n     *  <br/>\n     *  Imagine a directory full of files with a format such as : <br/>\n     *  <pre>\n     *  appLog-01_01_2008.log.1\n     *  appLog-01_01_2008.log.2\n     *  ...\n     *  </pre>\n     *  Now imagine that we wanted to rename the files so that they end in .log but they also keep their<br/>\n     *  uniqueness (i.e. the number at the end of the file needs to move to a new position in the filename)<br/>\n     *  <br/>\n     *  The following code expression would work :<br/>\n     *  <pre>fspath.query(\"dir[@name = 'logs']/file\").rename(\"(.*)\\.log\\.([0-9]+)\", \"$1_$2.log\");</pre> <br/>\n     *  Here the matchExpression has two capturing groups, one being everything up to the '.log' in the filename, <br/>\n     *  and the other being the number after the \".log.\" .<br/>\n     *  The replace expression simply specifies that the new file name will have the text in the first capturing group,<br/>\n     *  followed by a \"_\" then the text in the second capturing group and then \".log\".\n     */\n    public FSPathResultModificationList rename(String matchExpression, String replaceExpresion) throws IOException, OperationNotPermittedException {\n        if (!isListOfFiles()) {\n            throw new OperationNotPermittedException(\"Copy is only permitted on FSPathResult objects containing a java.io.File object\");\n        }\n        Pattern pattern = Pattern.compile(matchExpression);\n        FSPathResultModificationList results = new FSPathResultModificationListImpl();\n        for (FSPathResult result : this) {\n            File origFile = null;\n            File newFile = null;\n            try {\n                origFile = result.getFile();\n                Matcher matcher = pattern.matcher(origFile.getName());\n                String newName = matcher.replaceAll(replaceExpresion);\n                newFile = new File(newName);\n                origFile.renameTo(newFile);\n                results.addSuccess(new FSPathResult(newFile));\n            } catch (Exception e) {\n                results.addFailure(new FSPathResult(newFile));\n            }\n        }\n        return results;\n    }\n\n    /**\n     *  Moves each file in the list to the specified desination path.\n     *\n     *  This method effecively calls copy() and then delete() on itself.\n     *  If any file fails to sucessfully copy, then this method 'fails fast'\n     *  and returns the results of the copy. This should prevent the situation arising\n     *  where the copied files are completely deleted.\n     *  If the copy suceeds, then it will attempt to delete the original files.\n     *\n     *  @param String - the directory path to move the files to.\n     *  @throws OperationNotPermittedException - see the comments for <code>copy</code>\n     */\n    public FSPathResultModificationList move(String destinationPath) throws IOException, OperationNotPermittedException {\n        if (!isListOfFiles()) {\n            throw new OperationNotPermittedException(\"move is only permitted on FSPathResult objects containing a java.io.File object\");\n        }\n        FSPathResultModificationList copyResults = this.copy(destinationPath);\n        //if we detect a failure then cease what we're doing and return the results so far\n        if (copyResults.hasFailures()) {\n            return copyResults;\n        }\n        //if we're happy with the copy, delete the original files,\n        //and return the results of the deletion\n        return this.delete();\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/60_sugar/src/main/java/net/sf/sugar/fspath/FSPathResultListImpl_0Test.java",
		"test_prompt": "// FSPathResultListImpl_0Test.java\n/*\n * FSPathResultListImpl.java\n *\n * Created on 08 April 2008, 18:00\n *\n */\npackage net.sf.sugar.fspath;\n\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FSPathResultListImpl}.\n* It contains ten unit test cases for the {@link FSPathResultListImpl#each(Callback)} method.\n*/\nclass FSPathResultListImpl_0Test {"
	},
	{
		"original_code": "// FSPathResultListImpl.java\n/**\n * Copyright 2008 (C) Keith Bishop (bishi@users.sourceforge.net)\n *\n * All rights reserved.\n *\n * This file is part of FSPath.\n *\n * FSPath is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * FSPath is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with FSPath.  If not, see <http://www.gnu.org/licenses/>.\n */\n/*\n * FSPathResultListImpl.java\n *\n * Created on 08 April 2008, 18:00\n *\n */\npackage net.sf.sugar.fspath;\n\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * @author kbishop\n * @version $Id$\n */\npublic class FSPathResultListImpl extends ArrayList<FSPathResult> implements FSPathResultList {\n\n    /**\n     * Creates a new instance of FSPathResultListImpl\n     */\n    public FSPathResultListImpl() {\n    }\n\n    /**\n     *  A convenience method for defining custom filesystem interaction\n     *  across the whole list of results.\n     *\n     *  This method loops through the results and calls the call(Result result)\n     *  method of the Callback class passed to it for each individual result.\n     *\n     *  @param Callback - a custom implementation of the Callback interface.\n     *  @throws IOException\n     */\n    public FSPathResultList each(Callback callback) throws IOException {\n        for (FSPathResult result : this) {\n            callback.call(result);\n        }\n        return this;\n    }\n\n    /**\n     *  Deletes each file contained in this FSPathResultList.\n     *  <br/>\n     *  <pre>\n     *  ************************************************************************\n     *  *               IMPORTANT !!!!!    Use with caution                    *\n     *  *   This method makes it extremely easy to trash your filesystem       *\n     *  *   Its advised that FSPath queries are tested thouroughly before use  *\n     *  *   in order to verify which files would be deleted                    *\n     *  *                                                                      *\n     *  ************************************************************************\n     *  </pre>\n     *  @returns FSPathResultModificationListImpl - all successfully deleted files<br/>\n     *  will be added as a success, and the failures will be added as failures.\n     *\n     *  @throws IOException - NOTE this method does not currently thrown an IOException\n     *  @throws OperationNotPermittedException - this exception will be thrown if<br/>\n     *  The FSPathResult objects contained in this FSPathResultList don't contain<br/>\n     *  java.io.File objects<br/>\n     *  (i.e the FSPath query was written to return Boolean, String nor numerical results).\n     */\n    public FSPathResultModificationList delete() throws IOException, OperationNotPermittedException {\n        if (!isListOfFiles()) {\n            throw new OperationNotPermittedException(\"Delete is only permitted on FSPathResult objects containing a File object\");\n        }\n        FSPathResultModificationList deletionList = new FSPathResultModificationListImpl();\n        for (FSPathResult result : this) {\n            try {\n                File file = result.getFile();\n                boolean success = file.delete();\n                if (success) {\n                    deletionList.addSuccess(result);\n                } else {\n                    deletionList.addFailure(result);\n                }\n            } catch (Exception e) {\n                //todo: log this ?\n                deletionList.addFailure(result);\n            }\n        }\n        return deletionList;\n    }\n\n    /**\n     *  This method will copy each file contained in this FSPathResultList to the\n     *  destination path supplied.\n     *\n     *  @param String - the destination path which you would like to copy files to.\n     *\n     *  @returns FSPathResultModificationListImpl - all successfully copied files\n     *  will be added as a success, and the failures will be added as failures.\n     *\n     *  @param String the absolute or realtive path of the destination Directory\n     *  @throws IOException - NOTE this is currently not thrown by this method.\n     *  @throws OperationNotPermittedException - this exception is thrown upon\n     *  the following conditions :<br/>\n     *  <br/>\n     *  1)  The FSPathResult objects contained in this FSPathResultList don't contain<br/>\n     *      java.io.File objects<br/>\n     *      (i.e the FSPath query was written to return Boolean, String nor numerical results).<br/>\n     *  2)  The directory denoted by the destination path doesn't exist.<br/>\n     *  3)  The destination path doesn't resolve to a directory.<br/>\n     *  4)  The destination path isn't writeable.<br/>\n     *  5)  The current java process doesn't have sufficient priveledges to<br/>\n     *      access the destination path.<br/>\n     */\n    public FSPathResultModificationList copy(String destinationDirPath) throws IOException, OperationNotPermittedException {\n        if (!isListOfFiles()) {\n            throw new OperationNotPermittedException(\"Copy is only permitted on FSPathResult objects containing a java.io.File object\");\n        }\n        File destinationDir = new File(destinationDirPath);\n        try {\n            if (!destinationDir.exists()) {\n                throw new OperationNotPermittedException(\"Unable to copy to a directory that doesn't exist\");\n            }\n            if (!destinationDir.isDirectory()) {\n                throw new OperationNotPermittedException(\"Destination path \" + destinationDir.getAbsolutePath() + \" does not resolve to a directory\");\n            }\n            if (!destinationDir.canWrite()) {\n                throw new OperationNotPermittedException(\"Desination path \" + destinationDir.getAbsolutePath() + \" is not writable\");\n            }\n        } catch (SecurityException se) {\n            throw new OperationNotPermittedException(\"The current process does not have sufficent priveledges to access \" + destinationDir.getAbsolutePath(), se);\n        }\n        FSPathResultModificationList results = new FSPathResultModificationListImpl();\n        for (FSPathResult result : this) {\n            File destinationFile = new File(destinationDir + result.getFile().getName());\n            try {\n                FileReader inputReader = new FileReader(result.getFile());\n                FileWriter outputReader = new FileWriter(destinationFile);\n                int charsRead = 0;\n                while ((charsRead = inputReader.read()) != -1) {\n                    outputReader.write(charsRead);\n                }\n                inputReader.close();\n                outputReader.close();\n                results.addSuccess(new FSPathResult(destinationFile));\n            } catch (Exception e) {\n                results.addFailure(new FSPathResult(destinationFile));\n            }\n        }\n        return results;\n    }\n\n    public boolean isListOfFiles() {\n        return (this.size() > 0 && this.get(0).getFile() != null);\n    }\n\n    /**\n     *  Renames each file in the FSPathResultList based on a regex match\n     *  expression and a replace expression.\n     *  <br/>\n     *  This method is designed to enable simple renaming i.e. renaming from<br/>\n     *  \"a.txt\" to \"b.txt\" but also complex renaming using regular expressions.<br/>\n     *  <br/>\n     *  Example simple renaming : <br/>\n     *  <pre>fspath.query(\"/dir[@name='logs']/file[@name='error.log']\").rename(\"error.log\", \"error.log.1\");</pre> <br/>\n     *  This would work fine for a single file but not much use for multiple files.<br/>\n     *  <br/>\n     *  Example complex renaming : <br/>\n     *  <br/>\n     *  Imagine a directory full of files with a format such as : <br/>\n     *  <pre>\n     *  appLog-01_01_2008.log.1\n     *  appLog-01_01_2008.log.2\n     *  ...\n     *  </pre>\n     *  Now imagine that we wanted to rename the files so that they end in .log but they also keep their<br/>\n     *  uniqueness (i.e. the number at the end of the file needs to move to a new position in the filename)<br/>\n     *  <br/>\n     *  The following code expression would work :<br/>\n     *  <pre>fspath.query(\"dir[@name = 'logs']/file\").rename(\"(.*)\\.log\\.([0-9]+)\", \"$1_$2.log\");</pre> <br/>\n     *  Here the matchExpression has two capturing groups, one being everything up to the '.log' in the filename, <br/>\n     *  and the other being the number after the \".log.\" .<br/>\n     *  The replace expression simply specifies that the new file name will have the text in the first capturing group,<br/>\n     *  followed by a \"_\" then the text in the second capturing group and then \".log\".\n     */\n    public FSPathResultModificationList rename(String matchExpression, String replaceExpresion) throws IOException, OperationNotPermittedException {\n        if (!isListOfFiles()) {\n            throw new OperationNotPermittedException(\"Copy is only permitted on FSPathResult objects containing a java.io.File object\");\n        }\n        Pattern pattern = Pattern.compile(matchExpression);\n        FSPathResultModificationList results = new FSPathResultModificationListImpl();\n        for (FSPathResult result : this) {\n            File origFile = null;\n            File newFile = null;\n            try {\n                origFile = result.getFile();\n                Matcher matcher = pattern.matcher(origFile.getName());\n                String newName = matcher.replaceAll(replaceExpresion);\n                newFile = new File(newName);\n                origFile.renameTo(newFile);\n                results.addSuccess(new FSPathResult(newFile));\n            } catch (Exception e) {\n                results.addFailure(new FSPathResult(newFile));\n            }\n        }\n        return results;\n    }\n\n    /**\n     *  Moves each file in the list to the specified desination path.\n     *\n     *  This method effecively calls copy() and then delete() on itself.\n     *  If any file fails to sucessfully copy, then this method 'fails fast'\n     *  and returns the results of the copy. This should prevent the situation arising\n     *  where the copied files are completely deleted.\n     *  If the copy suceeds, then it will attempt to delete the original files.\n     *\n     *  @param String - the directory path to move the files to.\n     *  @throws OperationNotPermittedException - see the comments for <code>copy</code>\n     */\n    public FSPathResultModificationList move(String destinationPath) throws IOException, OperationNotPermittedException {\n        if (!isListOfFiles()) {\n            throw new OperationNotPermittedException(\"move is only permitted on FSPathResult objects containing a java.io.File object\");\n        }\n        FSPathResultModificationList copyResults = this.copy(destinationPath);\n        //if we detect a failure then cease what we're doing and return the results so far\n        if (copyResults.hasFailures()) {\n            return copyResults;\n        }\n        //if we're happy with the copy, delete the original files,\n        //and return the results of the deletion\n        return this.delete();\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/60_sugar/src/main/java/net/sf/sugar/fspath/FSPathResultListImpl_1Test.java",
		"test_prompt": "// FSPathResultListImpl_1Test.java\n/*\n * FSPathResultListImpl.java\n *\n * Created on 08 April 2008, 18:00\n *\n */\npackage net.sf.sugar.fspath;\n\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FSPathResultListImpl}.\n* It contains ten unit test cases for the {@link FSPathResultListImpl#delete()} method.\n*/\nclass FSPathResultListImpl_1Test {"
	},
	{
		"original_code": "// FSPathResultListImpl.java\n/**\n * Copyright 2008 (C) Keith Bishop (bishi@users.sourceforge.net)\n *\n * All rights reserved.\n *\n * This file is part of FSPath.\n *\n * FSPath is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * FSPath is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with FSPath.  If not, see <http://www.gnu.org/licenses/>.\n */\n/*\n * FSPathResultListImpl.java\n *\n * Created on 08 April 2008, 18:00\n *\n */\npackage net.sf.sugar.fspath;\n\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * @author kbishop\n * @version $Id$\n */\npublic class FSPathResultListImpl extends ArrayList<FSPathResult> implements FSPathResultList {\n\n    /**\n     * Creates a new instance of FSPathResultListImpl\n     */\n    public FSPathResultListImpl() {\n    }\n\n    /**\n     *  A convenience method for defining custom filesystem interaction\n     *  across the whole list of results.\n     *\n     *  This method loops through the results and calls the call(Result result)\n     *  method of the Callback class passed to it for each individual result.\n     *\n     *  @param Callback - a custom implementation of the Callback interface.\n     *  @throws IOException\n     */\n    public FSPathResultList each(Callback callback) throws IOException {\n        for (FSPathResult result : this) {\n            callback.call(result);\n        }\n        return this;\n    }\n\n    /**\n     *  Deletes each file contained in this FSPathResultList.\n     *  <br/>\n     *  <pre>\n     *  ************************************************************************\n     *  *               IMPORTANT !!!!!    Use with caution                    *\n     *  *   This method makes it extremely easy to trash your filesystem       *\n     *  *   Its advised that FSPath queries are tested thouroughly before use  *\n     *  *   in order to verify which files would be deleted                    *\n     *  *                                                                      *\n     *  ************************************************************************\n     *  </pre>\n     *  @returns FSPathResultModificationListImpl - all successfully deleted files<br/>\n     *  will be added as a success, and the failures will be added as failures.\n     *\n     *  @throws IOException - NOTE this method does not currently thrown an IOException\n     *  @throws OperationNotPermittedException - this exception will be thrown if<br/>\n     *  The FSPathResult objects contained in this FSPathResultList don't contain<br/>\n     *  java.io.File objects<br/>\n     *  (i.e the FSPath query was written to return Boolean, String nor numerical results).\n     */\n    public FSPathResultModificationList delete() throws IOException, OperationNotPermittedException {\n        if (!isListOfFiles()) {\n            throw new OperationNotPermittedException(\"Delete is only permitted on FSPathResult objects containing a File object\");\n        }\n        FSPathResultModificationList deletionList = new FSPathResultModificationListImpl();\n        for (FSPathResult result : this) {\n            try {\n                File file = result.getFile();\n                boolean success = file.delete();\n                if (success) {\n                    deletionList.addSuccess(result);\n                } else {\n                    deletionList.addFailure(result);\n                }\n            } catch (Exception e) {\n                //todo: log this ?\n                deletionList.addFailure(result);\n            }\n        }\n        return deletionList;\n    }\n\n    /**\n     *  This method will copy each file contained in this FSPathResultList to the\n     *  destination path supplied.\n     *\n     *  @param String - the destination path which you would like to copy files to.\n     *\n     *  @returns FSPathResultModificationListImpl - all successfully copied files\n     *  will be added as a success, and the failures will be added as failures.\n     *\n     *  @param String the absolute or realtive path of the destination Directory\n     *  @throws IOException - NOTE this is currently not thrown by this method.\n     *  @throws OperationNotPermittedException - this exception is thrown upon\n     *  the following conditions :<br/>\n     *  <br/>\n     *  1)  The FSPathResult objects contained in this FSPathResultList don't contain<br/>\n     *      java.io.File objects<br/>\n     *      (i.e the FSPath query was written to return Boolean, String nor numerical results).<br/>\n     *  2)  The directory denoted by the destination path doesn't exist.<br/>\n     *  3)  The destination path doesn't resolve to a directory.<br/>\n     *  4)  The destination path isn't writeable.<br/>\n     *  5)  The current java process doesn't have sufficient priveledges to<br/>\n     *      access the destination path.<br/>\n     */\n    public FSPathResultModificationList copy(String destinationDirPath) throws IOException, OperationNotPermittedException {\n        if (!isListOfFiles()) {\n            throw new OperationNotPermittedException(\"Copy is only permitted on FSPathResult objects containing a java.io.File object\");\n        }\n        File destinationDir = new File(destinationDirPath);\n        try {\n            if (!destinationDir.exists()) {\n                throw new OperationNotPermittedException(\"Unable to copy to a directory that doesn't exist\");\n            }\n            if (!destinationDir.isDirectory()) {\n                throw new OperationNotPermittedException(\"Destination path \" + destinationDir.getAbsolutePath() + \" does not resolve to a directory\");\n            }\n            if (!destinationDir.canWrite()) {\n                throw new OperationNotPermittedException(\"Desination path \" + destinationDir.getAbsolutePath() + \" is not writable\");\n            }\n        } catch (SecurityException se) {\n            throw new OperationNotPermittedException(\"The current process does not have sufficent priveledges to access \" + destinationDir.getAbsolutePath(), se);\n        }\n        FSPathResultModificationList results = new FSPathResultModificationListImpl();\n        for (FSPathResult result : this) {\n            File destinationFile = new File(destinationDir + result.getFile().getName());\n            try {\n                FileReader inputReader = new FileReader(result.getFile());\n                FileWriter outputReader = new FileWriter(destinationFile);\n                int charsRead = 0;\n                while ((charsRead = inputReader.read()) != -1) {\n                    outputReader.write(charsRead);\n                }\n                inputReader.close();\n                outputReader.close();\n                results.addSuccess(new FSPathResult(destinationFile));\n            } catch (Exception e) {\n                results.addFailure(new FSPathResult(destinationFile));\n            }\n        }\n        return results;\n    }\n\n    public boolean isListOfFiles() {\n        return (this.size() > 0 && this.get(0).getFile() != null);\n    }\n\n    /**\n     *  Renames each file in the FSPathResultList based on a regex match\n     *  expression and a replace expression.\n     *  <br/>\n     *  This method is designed to enable simple renaming i.e. renaming from<br/>\n     *  \"a.txt\" to \"b.txt\" but also complex renaming using regular expressions.<br/>\n     *  <br/>\n     *  Example simple renaming : <br/>\n     *  <pre>fspath.query(\"/dir[@name='logs']/file[@name='error.log']\").rename(\"error.log\", \"error.log.1\");</pre> <br/>\n     *  This would work fine for a single file but not much use for multiple files.<br/>\n     *  <br/>\n     *  Example complex renaming : <br/>\n     *  <br/>\n     *  Imagine a directory full of files with a format such as : <br/>\n     *  <pre>\n     *  appLog-01_01_2008.log.1\n     *  appLog-01_01_2008.log.2\n     *  ...\n     *  </pre>\n     *  Now imagine that we wanted to rename the files so that they end in .log but they also keep their<br/>\n     *  uniqueness (i.e. the number at the end of the file needs to move to a new position in the filename)<br/>\n     *  <br/>\n     *  The following code expression would work :<br/>\n     *  <pre>fspath.query(\"dir[@name = 'logs']/file\").rename(\"(.*)\\.log\\.([0-9]+)\", \"$1_$2.log\");</pre> <br/>\n     *  Here the matchExpression has two capturing groups, one being everything up to the '.log' in the filename, <br/>\n     *  and the other being the number after the \".log.\" .<br/>\n     *  The replace expression simply specifies that the new file name will have the text in the first capturing group,<br/>\n     *  followed by a \"_\" then the text in the second capturing group and then \".log\".\n     */\n    public FSPathResultModificationList rename(String matchExpression, String replaceExpresion) throws IOException, OperationNotPermittedException {\n        if (!isListOfFiles()) {\n            throw new OperationNotPermittedException(\"Copy is only permitted on FSPathResult objects containing a java.io.File object\");\n        }\n        Pattern pattern = Pattern.compile(matchExpression);\n        FSPathResultModificationList results = new FSPathResultModificationListImpl();\n        for (FSPathResult result : this) {\n            File origFile = null;\n            File newFile = null;\n            try {\n                origFile = result.getFile();\n                Matcher matcher = pattern.matcher(origFile.getName());\n                String newName = matcher.replaceAll(replaceExpresion);\n                newFile = new File(newName);\n                origFile.renameTo(newFile);\n                results.addSuccess(new FSPathResult(newFile));\n            } catch (Exception e) {\n                results.addFailure(new FSPathResult(newFile));\n            }\n        }\n        return results;\n    }\n\n    /**\n     *  Moves each file in the list to the specified desination path.\n     *\n     *  This method effecively calls copy() and then delete() on itself.\n     *  If any file fails to sucessfully copy, then this method 'fails fast'\n     *  and returns the results of the copy. This should prevent the situation arising\n     *  where the copied files are completely deleted.\n     *  If the copy suceeds, then it will attempt to delete the original files.\n     *\n     *  @param String - the directory path to move the files to.\n     *  @throws OperationNotPermittedException - see the comments for <code>copy</code>\n     */\n    public FSPathResultModificationList move(String destinationPath) throws IOException, OperationNotPermittedException {\n        if (!isListOfFiles()) {\n            throw new OperationNotPermittedException(\"move is only permitted on FSPathResult objects containing a java.io.File object\");\n        }\n        FSPathResultModificationList copyResults = this.copy(destinationPath);\n        //if we detect a failure then cease what we're doing and return the results so far\n        if (copyResults.hasFailures()) {\n            return copyResults;\n        }\n        //if we're happy with the copy, delete the original files,\n        //and return the results of the deletion\n        return this.delete();\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/60_sugar/src/main/java/net/sf/sugar/fspath/FSPathResultListImpl_2Test.java",
		"test_prompt": "// FSPathResultListImpl_2Test.java\n/*\n * FSPathResultListImpl.java\n *\n * Created on 08 April 2008, 18:00\n *\n */\npackage net.sf.sugar.fspath;\n\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FSPathResultListImpl}.\n* It contains ten unit test cases for the {@link FSPathResultListImpl#copy(String)} method.\n*/\nclass FSPathResultListImpl_2Test {"
	},
	{
		"original_code": "// FSPathResultListImpl.java\n/**\n * Copyright 2008 (C) Keith Bishop (bishi@users.sourceforge.net)\n *\n * All rights reserved.\n *\n * This file is part of FSPath.\n *\n * FSPath is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * FSPath is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with FSPath.  If not, see <http://www.gnu.org/licenses/>.\n */\n/*\n * FSPathResultListImpl.java\n *\n * Created on 08 April 2008, 18:00\n *\n */\npackage net.sf.sugar.fspath;\n\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * @author kbishop\n * @version $Id$\n */\npublic class FSPathResultListImpl extends ArrayList<FSPathResult> implements FSPathResultList {\n\n    /**\n     * Creates a new instance of FSPathResultListImpl\n     */\n    public FSPathResultListImpl() {\n    }\n\n    /**\n     *  A convenience method for defining custom filesystem interaction\n     *  across the whole list of results.\n     *\n     *  This method loops through the results and calls the call(Result result)\n     *  method of the Callback class passed to it for each individual result.\n     *\n     *  @param Callback - a custom implementation of the Callback interface.\n     *  @throws IOException\n     */\n    public FSPathResultList each(Callback callback) throws IOException {\n        for (FSPathResult result : this) {\n            callback.call(result);\n        }\n        return this;\n    }\n\n    /**\n     *  Deletes each file contained in this FSPathResultList.\n     *  <br/>\n     *  <pre>\n     *  ************************************************************************\n     *  *               IMPORTANT !!!!!    Use with caution                    *\n     *  *   This method makes it extremely easy to trash your filesystem       *\n     *  *   Its advised that FSPath queries are tested thouroughly before use  *\n     *  *   in order to verify which files would be deleted                    *\n     *  *                                                                      *\n     *  ************************************************************************\n     *  </pre>\n     *  @returns FSPathResultModificationListImpl - all successfully deleted files<br/>\n     *  will be added as a success, and the failures will be added as failures.\n     *\n     *  @throws IOException - NOTE this method does not currently thrown an IOException\n     *  @throws OperationNotPermittedException - this exception will be thrown if<br/>\n     *  The FSPathResult objects contained in this FSPathResultList don't contain<br/>\n     *  java.io.File objects<br/>\n     *  (i.e the FSPath query was written to return Boolean, String nor numerical results).\n     */\n    public FSPathResultModificationList delete() throws IOException, OperationNotPermittedException {\n        if (!isListOfFiles()) {\n            throw new OperationNotPermittedException(\"Delete is only permitted on FSPathResult objects containing a File object\");\n        }\n        FSPathResultModificationList deletionList = new FSPathResultModificationListImpl();\n        for (FSPathResult result : this) {\n            try {\n                File file = result.getFile();\n                boolean success = file.delete();\n                if (success) {\n                    deletionList.addSuccess(result);\n                } else {\n                    deletionList.addFailure(result);\n                }\n            } catch (Exception e) {\n                //todo: log this ?\n                deletionList.addFailure(result);\n            }\n        }\n        return deletionList;\n    }\n\n    /**\n     *  This method will copy each file contained in this FSPathResultList to the\n     *  destination path supplied.\n     *\n     *  @param String - the destination path which you would like to copy files to.\n     *\n     *  @returns FSPathResultModificationListImpl - all successfully copied files\n     *  will be added as a success, and the failures will be added as failures.\n     *\n     *  @param String the absolute or realtive path of the destination Directory\n     *  @throws IOException - NOTE this is currently not thrown by this method.\n     *  @throws OperationNotPermittedException - this exception is thrown upon\n     *  the following conditions :<br/>\n     *  <br/>\n     *  1)  The FSPathResult objects contained in this FSPathResultList don't contain<br/>\n     *      java.io.File objects<br/>\n     *      (i.e the FSPath query was written to return Boolean, String nor numerical results).<br/>\n     *  2)  The directory denoted by the destination path doesn't exist.<br/>\n     *  3)  The destination path doesn't resolve to a directory.<br/>\n     *  4)  The destination path isn't writeable.<br/>\n     *  5)  The current java process doesn't have sufficient priveledges to<br/>\n     *      access the destination path.<br/>\n     */\n    public FSPathResultModificationList copy(String destinationDirPath) throws IOException, OperationNotPermittedException {\n        if (!isListOfFiles()) {\n            throw new OperationNotPermittedException(\"Copy is only permitted on FSPathResult objects containing a java.io.File object\");\n        }\n        File destinationDir = new File(destinationDirPath);\n        try {\n            if (!destinationDir.exists()) {\n                throw new OperationNotPermittedException(\"Unable to copy to a directory that doesn't exist\");\n            }\n            if (!destinationDir.isDirectory()) {\n                throw new OperationNotPermittedException(\"Destination path \" + destinationDir.getAbsolutePath() + \" does not resolve to a directory\");\n            }\n            if (!destinationDir.canWrite()) {\n                throw new OperationNotPermittedException(\"Desination path \" + destinationDir.getAbsolutePath() + \" is not writable\");\n            }\n        } catch (SecurityException se) {\n            throw new OperationNotPermittedException(\"The current process does not have sufficent priveledges to access \" + destinationDir.getAbsolutePath(), se);\n        }\n        FSPathResultModificationList results = new FSPathResultModificationListImpl();\n        for (FSPathResult result : this) {\n            File destinationFile = new File(destinationDir + result.getFile().getName());\n            try {\n                FileReader inputReader = new FileReader(result.getFile());\n                FileWriter outputReader = new FileWriter(destinationFile);\n                int charsRead = 0;\n                while ((charsRead = inputReader.read()) != -1) {\n                    outputReader.write(charsRead);\n                }\n                inputReader.close();\n                outputReader.close();\n                results.addSuccess(new FSPathResult(destinationFile));\n            } catch (Exception e) {\n                results.addFailure(new FSPathResult(destinationFile));\n            }\n        }\n        return results;\n    }\n\n    public boolean isListOfFiles() {\n        return (this.size() > 0 && this.get(0).getFile() != null);\n    }\n\n    /**\n     *  Renames each file in the FSPathResultList based on a regex match\n     *  expression and a replace expression.\n     *  <br/>\n     *  This method is designed to enable simple renaming i.e. renaming from<br/>\n     *  \"a.txt\" to \"b.txt\" but also complex renaming using regular expressions.<br/>\n     *  <br/>\n     *  Example simple renaming : <br/>\n     *  <pre>fspath.query(\"/dir[@name='logs']/file[@name='error.log']\").rename(\"error.log\", \"error.log.1\");</pre> <br/>\n     *  This would work fine for a single file but not much use for multiple files.<br/>\n     *  <br/>\n     *  Example complex renaming : <br/>\n     *  <br/>\n     *  Imagine a directory full of files with a format such as : <br/>\n     *  <pre>\n     *  appLog-01_01_2008.log.1\n     *  appLog-01_01_2008.log.2\n     *  ...\n     *  </pre>\n     *  Now imagine that we wanted to rename the files so that they end in .log but they also keep their<br/>\n     *  uniqueness (i.e. the number at the end of the file needs to move to a new position in the filename)<br/>\n     *  <br/>\n     *  The following code expression would work :<br/>\n     *  <pre>fspath.query(\"dir[@name = 'logs']/file\").rename(\"(.*)\\.log\\.([0-9]+)\", \"$1_$2.log\");</pre> <br/>\n     *  Here the matchExpression has two capturing groups, one being everything up to the '.log' in the filename, <br/>\n     *  and the other being the number after the \".log.\" .<br/>\n     *  The replace expression simply specifies that the new file name will have the text in the first capturing group,<br/>\n     *  followed by a \"_\" then the text in the second capturing group and then \".log\".\n     */\n    public FSPathResultModificationList rename(String matchExpression, String replaceExpresion) throws IOException, OperationNotPermittedException {\n        if (!isListOfFiles()) {\n            throw new OperationNotPermittedException(\"Copy is only permitted on FSPathResult objects containing a java.io.File object\");\n        }\n        Pattern pattern = Pattern.compile(matchExpression);\n        FSPathResultModificationList results = new FSPathResultModificationListImpl();\n        for (FSPathResult result : this) {\n            File origFile = null;\n            File newFile = null;\n            try {\n                origFile = result.getFile();\n                Matcher matcher = pattern.matcher(origFile.getName());\n                String newName = matcher.replaceAll(replaceExpresion);\n                newFile = new File(newName);\n                origFile.renameTo(newFile);\n                results.addSuccess(new FSPathResult(newFile));\n            } catch (Exception e) {\n                results.addFailure(new FSPathResult(newFile));\n            }\n        }\n        return results;\n    }\n\n    /**\n     *  Moves each file in the list to the specified desination path.\n     *\n     *  This method effecively calls copy() and then delete() on itself.\n     *  If any file fails to sucessfully copy, then this method 'fails fast'\n     *  and returns the results of the copy. This should prevent the situation arising\n     *  where the copied files are completely deleted.\n     *  If the copy suceeds, then it will attempt to delete the original files.\n     *\n     *  @param String - the directory path to move the files to.\n     *  @throws OperationNotPermittedException - see the comments for <code>copy</code>\n     */\n    public FSPathResultModificationList move(String destinationPath) throws IOException, OperationNotPermittedException {\n        if (!isListOfFiles()) {\n            throw new OperationNotPermittedException(\"move is only permitted on FSPathResult objects containing a java.io.File object\");\n        }\n        FSPathResultModificationList copyResults = this.copy(destinationPath);\n        //if we detect a failure then cease what we're doing and return the results so far\n        if (copyResults.hasFailures()) {\n            return copyResults;\n        }\n        //if we're happy with the copy, delete the original files,\n        //and return the results of the deletion\n        return this.delete();\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/60_sugar/src/main/java/net/sf/sugar/fspath/FSPathResultListImpl_3Test.java",
		"test_prompt": "// FSPathResultListImpl_3Test.java\n/*\n * FSPathResultListImpl.java\n *\n * Created on 08 April 2008, 18:00\n *\n */\npackage net.sf.sugar.fspath;\n\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FSPathResultListImpl}.\n* It contains ten unit test cases for the {@link FSPathResultListImpl#isListOfFiles()} method.\n*/\nclass FSPathResultListImpl_3Test {"
	},
	{
		"original_code": "// FSPathResultListImpl.java\n/**\n * Copyright 2008 (C) Keith Bishop (bishi@users.sourceforge.net)\n *\n * All rights reserved.\n *\n * This file is part of FSPath.\n *\n * FSPath is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * FSPath is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with FSPath.  If not, see <http://www.gnu.org/licenses/>.\n */\n/*\n * FSPathResultListImpl.java\n *\n * Created on 08 April 2008, 18:00\n *\n */\npackage net.sf.sugar.fspath;\n\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * @author kbishop\n * @version $Id$\n */\npublic class FSPathResultListImpl extends ArrayList<FSPathResult> implements FSPathResultList {\n\n    /**\n     * Creates a new instance of FSPathResultListImpl\n     */\n    public FSPathResultListImpl() {\n    }\n\n    /**\n     *  A convenience method for defining custom filesystem interaction\n     *  across the whole list of results.\n     *\n     *  This method loops through the results and calls the call(Result result)\n     *  method of the Callback class passed to it for each individual result.\n     *\n     *  @param Callback - a custom implementation of the Callback interface.\n     *  @throws IOException\n     */\n    public FSPathResultList each(Callback callback) throws IOException {\n        for (FSPathResult result : this) {\n            callback.call(result);\n        }\n        return this;\n    }\n\n    /**\n     *  Deletes each file contained in this FSPathResultList.\n     *  <br/>\n     *  <pre>\n     *  ************************************************************************\n     *  *               IMPORTANT !!!!!    Use with caution                    *\n     *  *   This method makes it extremely easy to trash your filesystem       *\n     *  *   Its advised that FSPath queries are tested thouroughly before use  *\n     *  *   in order to verify which files would be deleted                    *\n     *  *                                                                      *\n     *  ************************************************************************\n     *  </pre>\n     *  @returns FSPathResultModificationListImpl - all successfully deleted files<br/>\n     *  will be added as a success, and the failures will be added as failures.\n     *\n     *  @throws IOException - NOTE this method does not currently thrown an IOException\n     *  @throws OperationNotPermittedException - this exception will be thrown if<br/>\n     *  The FSPathResult objects contained in this FSPathResultList don't contain<br/>\n     *  java.io.File objects<br/>\n     *  (i.e the FSPath query was written to return Boolean, String nor numerical results).\n     */\n    public FSPathResultModificationList delete() throws IOException, OperationNotPermittedException {\n        if (!isListOfFiles()) {\n            throw new OperationNotPermittedException(\"Delete is only permitted on FSPathResult objects containing a File object\");\n        }\n        FSPathResultModificationList deletionList = new FSPathResultModificationListImpl();\n        for (FSPathResult result : this) {\n            try {\n                File file = result.getFile();\n                boolean success = file.delete();\n                if (success) {\n                    deletionList.addSuccess(result);\n                } else {\n                    deletionList.addFailure(result);\n                }\n            } catch (Exception e) {\n                //todo: log this ?\n                deletionList.addFailure(result);\n            }\n        }\n        return deletionList;\n    }\n\n    /**\n     *  This method will copy each file contained in this FSPathResultList to the\n     *  destination path supplied.\n     *\n     *  @param String - the destination path which you would like to copy files to.\n     *\n     *  @returns FSPathResultModificationListImpl - all successfully copied files\n     *  will be added as a success, and the failures will be added as failures.\n     *\n     *  @param String the absolute or realtive path of the destination Directory\n     *  @throws IOException - NOTE this is currently not thrown by this method.\n     *  @throws OperationNotPermittedException - this exception is thrown upon\n     *  the following conditions :<br/>\n     *  <br/>\n     *  1)  The FSPathResult objects contained in this FSPathResultList don't contain<br/>\n     *      java.io.File objects<br/>\n     *      (i.e the FSPath query was written to return Boolean, String nor numerical results).<br/>\n     *  2)  The directory denoted by the destination path doesn't exist.<br/>\n     *  3)  The destination path doesn't resolve to a directory.<br/>\n     *  4)  The destination path isn't writeable.<br/>\n     *  5)  The current java process doesn't have sufficient priveledges to<br/>\n     *      access the destination path.<br/>\n     */\n    public FSPathResultModificationList copy(String destinationDirPath) throws IOException, OperationNotPermittedException {\n        if (!isListOfFiles()) {\n            throw new OperationNotPermittedException(\"Copy is only permitted on FSPathResult objects containing a java.io.File object\");\n        }\n        File destinationDir = new File(destinationDirPath);\n        try {\n            if (!destinationDir.exists()) {\n                throw new OperationNotPermittedException(\"Unable to copy to a directory that doesn't exist\");\n            }\n            if (!destinationDir.isDirectory()) {\n                throw new OperationNotPermittedException(\"Destination path \" + destinationDir.getAbsolutePath() + \" does not resolve to a directory\");\n            }\n            if (!destinationDir.canWrite()) {\n                throw new OperationNotPermittedException(\"Desination path \" + destinationDir.getAbsolutePath() + \" is not writable\");\n            }\n        } catch (SecurityException se) {\n            throw new OperationNotPermittedException(\"The current process does not have sufficent priveledges to access \" + destinationDir.getAbsolutePath(), se);\n        }\n        FSPathResultModificationList results = new FSPathResultModificationListImpl();\n        for (FSPathResult result : this) {\n            File destinationFile = new File(destinationDir + result.getFile().getName());\n            try {\n                FileReader inputReader = new FileReader(result.getFile());\n                FileWriter outputReader = new FileWriter(destinationFile);\n                int charsRead = 0;\n                while ((charsRead = inputReader.read()) != -1) {\n                    outputReader.write(charsRead);\n                }\n                inputReader.close();\n                outputReader.close();\n                results.addSuccess(new FSPathResult(destinationFile));\n            } catch (Exception e) {\n                results.addFailure(new FSPathResult(destinationFile));\n            }\n        }\n        return results;\n    }\n\n    public boolean isListOfFiles() {\n        return (this.size() > 0 && this.get(0).getFile() != null);\n    }\n\n    /**\n     *  Renames each file in the FSPathResultList based on a regex match\n     *  expression and a replace expression.\n     *  <br/>\n     *  This method is designed to enable simple renaming i.e. renaming from<br/>\n     *  \"a.txt\" to \"b.txt\" but also complex renaming using regular expressions.<br/>\n     *  <br/>\n     *  Example simple renaming : <br/>\n     *  <pre>fspath.query(\"/dir[@name='logs']/file[@name='error.log']\").rename(\"error.log\", \"error.log.1\");</pre> <br/>\n     *  This would work fine for a single file but not much use for multiple files.<br/>\n     *  <br/>\n     *  Example complex renaming : <br/>\n     *  <br/>\n     *  Imagine a directory full of files with a format such as : <br/>\n     *  <pre>\n     *  appLog-01_01_2008.log.1\n     *  appLog-01_01_2008.log.2\n     *  ...\n     *  </pre>\n     *  Now imagine that we wanted to rename the files so that they end in .log but they also keep their<br/>\n     *  uniqueness (i.e. the number at the end of the file needs to move to a new position in the filename)<br/>\n     *  <br/>\n     *  The following code expression would work :<br/>\n     *  <pre>fspath.query(\"dir[@name = 'logs']/file\").rename(\"(.*)\\.log\\.([0-9]+)\", \"$1_$2.log\");</pre> <br/>\n     *  Here the matchExpression has two capturing groups, one being everything up to the '.log' in the filename, <br/>\n     *  and the other being the number after the \".log.\" .<br/>\n     *  The replace expression simply specifies that the new file name will have the text in the first capturing group,<br/>\n     *  followed by a \"_\" then the text in the second capturing group and then \".log\".\n     */\n    public FSPathResultModificationList rename(String matchExpression, String replaceExpresion) throws IOException, OperationNotPermittedException {\n        if (!isListOfFiles()) {\n            throw new OperationNotPermittedException(\"Copy is only permitted on FSPathResult objects containing a java.io.File object\");\n        }\n        Pattern pattern = Pattern.compile(matchExpression);\n        FSPathResultModificationList results = new FSPathResultModificationListImpl();\n        for (FSPathResult result : this) {\n            File origFile = null;\n            File newFile = null;\n            try {\n                origFile = result.getFile();\n                Matcher matcher = pattern.matcher(origFile.getName());\n                String newName = matcher.replaceAll(replaceExpresion);\n                newFile = new File(newName);\n                origFile.renameTo(newFile);\n                results.addSuccess(new FSPathResult(newFile));\n            } catch (Exception e) {\n                results.addFailure(new FSPathResult(newFile));\n            }\n        }\n        return results;\n    }\n\n    /**\n     *  Moves each file in the list to the specified desination path.\n     *\n     *  This method effecively calls copy() and then delete() on itself.\n     *  If any file fails to sucessfully copy, then this method 'fails fast'\n     *  and returns the results of the copy. This should prevent the situation arising\n     *  where the copied files are completely deleted.\n     *  If the copy suceeds, then it will attempt to delete the original files.\n     *\n     *  @param String - the directory path to move the files to.\n     *  @throws OperationNotPermittedException - see the comments for <code>copy</code>\n     */\n    public FSPathResultModificationList move(String destinationPath) throws IOException, OperationNotPermittedException {\n        if (!isListOfFiles()) {\n            throw new OperationNotPermittedException(\"move is only permitted on FSPathResult objects containing a java.io.File object\");\n        }\n        FSPathResultModificationList copyResults = this.copy(destinationPath);\n        //if we detect a failure then cease what we're doing and return the results so far\n        if (copyResults.hasFailures()) {\n            return copyResults;\n        }\n        //if we're happy with the copy, delete the original files,\n        //and return the results of the deletion\n        return this.delete();\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/60_sugar/src/main/java/net/sf/sugar/fspath/FSPathResultListImpl_4Test.java",
		"test_prompt": "// FSPathResultListImpl_4Test.java\n/*\n * FSPathResultListImpl.java\n *\n * Created on 08 April 2008, 18:00\n *\n */\npackage net.sf.sugar.fspath;\n\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FSPathResultListImpl}.\n* It contains ten unit test cases for the {@link FSPathResultListImpl#rename(String, String)} method.\n*/\nclass FSPathResultListImpl_4Test {"
	},
	{
		"original_code": "// FSPathResultListImpl.java\n/**\n * Copyright 2008 (C) Keith Bishop (bishi@users.sourceforge.net)\n *\n * All rights reserved.\n *\n * This file is part of FSPath.\n *\n * FSPath is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * FSPath is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with FSPath.  If not, see <http://www.gnu.org/licenses/>.\n */\n/*\n * FSPathResultListImpl.java\n *\n * Created on 08 April 2008, 18:00\n *\n */\npackage net.sf.sugar.fspath;\n\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * @author kbishop\n * @version $Id$\n */\npublic class FSPathResultListImpl extends ArrayList<FSPathResult> implements FSPathResultList {\n\n    /**\n     * Creates a new instance of FSPathResultListImpl\n     */\n    public FSPathResultListImpl() {\n    }\n\n    /**\n     *  A convenience method for defining custom filesystem interaction\n     *  across the whole list of results.\n     *\n     *  This method loops through the results and calls the call(Result result)\n     *  method of the Callback class passed to it for each individual result.\n     *\n     *  @param Callback - a custom implementation of the Callback interface.\n     *  @throws IOException\n     */\n    public FSPathResultList each(Callback callback) throws IOException {\n        for (FSPathResult result : this) {\n            callback.call(result);\n        }\n        return this;\n    }\n\n    /**\n     *  Deletes each file contained in this FSPathResultList.\n     *  <br/>\n     *  <pre>\n     *  ************************************************************************\n     *  *               IMPORTANT !!!!!    Use with caution                    *\n     *  *   This method makes it extremely easy to trash your filesystem       *\n     *  *   Its advised that FSPath queries are tested thouroughly before use  *\n     *  *   in order to verify which files would be deleted                    *\n     *  *                                                                      *\n     *  ************************************************************************\n     *  </pre>\n     *  @returns FSPathResultModificationListImpl - all successfully deleted files<br/>\n     *  will be added as a success, and the failures will be added as failures.\n     *\n     *  @throws IOException - NOTE this method does not currently thrown an IOException\n     *  @throws OperationNotPermittedException - this exception will be thrown if<br/>\n     *  The FSPathResult objects contained in this FSPathResultList don't contain<br/>\n     *  java.io.File objects<br/>\n     *  (i.e the FSPath query was written to return Boolean, String nor numerical results).\n     */\n    public FSPathResultModificationList delete() throws IOException, OperationNotPermittedException {\n        if (!isListOfFiles()) {\n            throw new OperationNotPermittedException(\"Delete is only permitted on FSPathResult objects containing a File object\");\n        }\n        FSPathResultModificationList deletionList = new FSPathResultModificationListImpl();\n        for (FSPathResult result : this) {\n            try {\n                File file = result.getFile();\n                boolean success = file.delete();\n                if (success) {\n                    deletionList.addSuccess(result);\n                } else {\n                    deletionList.addFailure(result);\n                }\n            } catch (Exception e) {\n                //todo: log this ?\n                deletionList.addFailure(result);\n            }\n        }\n        return deletionList;\n    }\n\n    /**\n     *  This method will copy each file contained in this FSPathResultList to the\n     *  destination path supplied.\n     *\n     *  @param String - the destination path which you would like to copy files to.\n     *\n     *  @returns FSPathResultModificationListImpl - all successfully copied files\n     *  will be added as a success, and the failures will be added as failures.\n     *\n     *  @param String the absolute or realtive path of the destination Directory\n     *  @throws IOException - NOTE this is currently not thrown by this method.\n     *  @throws OperationNotPermittedException - this exception is thrown upon\n     *  the following conditions :<br/>\n     *  <br/>\n     *  1)  The FSPathResult objects contained in this FSPathResultList don't contain<br/>\n     *      java.io.File objects<br/>\n     *      (i.e the FSPath query was written to return Boolean, String nor numerical results).<br/>\n     *  2)  The directory denoted by the destination path doesn't exist.<br/>\n     *  3)  The destination path doesn't resolve to a directory.<br/>\n     *  4)  The destination path isn't writeable.<br/>\n     *  5)  The current java process doesn't have sufficient priveledges to<br/>\n     *      access the destination path.<br/>\n     */\n    public FSPathResultModificationList copy(String destinationDirPath) throws IOException, OperationNotPermittedException {\n        if (!isListOfFiles()) {\n            throw new OperationNotPermittedException(\"Copy is only permitted on FSPathResult objects containing a java.io.File object\");\n        }\n        File destinationDir = new File(destinationDirPath);\n        try {\n            if (!destinationDir.exists()) {\n                throw new OperationNotPermittedException(\"Unable to copy to a directory that doesn't exist\");\n            }\n            if (!destinationDir.isDirectory()) {\n                throw new OperationNotPermittedException(\"Destination path \" + destinationDir.getAbsolutePath() + \" does not resolve to a directory\");\n            }\n            if (!destinationDir.canWrite()) {\n                throw new OperationNotPermittedException(\"Desination path \" + destinationDir.getAbsolutePath() + \" is not writable\");\n            }\n        } catch (SecurityException se) {\n            throw new OperationNotPermittedException(\"The current process does not have sufficent priveledges to access \" + destinationDir.getAbsolutePath(), se);\n        }\n        FSPathResultModificationList results = new FSPathResultModificationListImpl();\n        for (FSPathResult result : this) {\n            File destinationFile = new File(destinationDir + result.getFile().getName());\n            try {\n                FileReader inputReader = new FileReader(result.getFile());\n                FileWriter outputReader = new FileWriter(destinationFile);\n                int charsRead = 0;\n                while ((charsRead = inputReader.read()) != -1) {\n                    outputReader.write(charsRead);\n                }\n                inputReader.close();\n                outputReader.close();\n                results.addSuccess(new FSPathResult(destinationFile));\n            } catch (Exception e) {\n                results.addFailure(new FSPathResult(destinationFile));\n            }\n        }\n        return results;\n    }\n\n    public boolean isListOfFiles() {\n        return (this.size() > 0 && this.get(0).getFile() != null);\n    }\n\n    /**\n     *  Renames each file in the FSPathResultList based on a regex match\n     *  expression and a replace expression.\n     *  <br/>\n     *  This method is designed to enable simple renaming i.e. renaming from<br/>\n     *  \"a.txt\" to \"b.txt\" but also complex renaming using regular expressions.<br/>\n     *  <br/>\n     *  Example simple renaming : <br/>\n     *  <pre>fspath.query(\"/dir[@name='logs']/file[@name='error.log']\").rename(\"error.log\", \"error.log.1\");</pre> <br/>\n     *  This would work fine for a single file but not much use for multiple files.<br/>\n     *  <br/>\n     *  Example complex renaming : <br/>\n     *  <br/>\n     *  Imagine a directory full of files with a format such as : <br/>\n     *  <pre>\n     *  appLog-01_01_2008.log.1\n     *  appLog-01_01_2008.log.2\n     *  ...\n     *  </pre>\n     *  Now imagine that we wanted to rename the files so that they end in .log but they also keep their<br/>\n     *  uniqueness (i.e. the number at the end of the file needs to move to a new position in the filename)<br/>\n     *  <br/>\n     *  The following code expression would work :<br/>\n     *  <pre>fspath.query(\"dir[@name = 'logs']/file\").rename(\"(.*)\\.log\\.([0-9]+)\", \"$1_$2.log\");</pre> <br/>\n     *  Here the matchExpression has two capturing groups, one being everything up to the '.log' in the filename, <br/>\n     *  and the other being the number after the \".log.\" .<br/>\n     *  The replace expression simply specifies that the new file name will have the text in the first capturing group,<br/>\n     *  followed by a \"_\" then the text in the second capturing group and then \".log\".\n     */\n    public FSPathResultModificationList rename(String matchExpression, String replaceExpresion) throws IOException, OperationNotPermittedException {\n        if (!isListOfFiles()) {\n            throw new OperationNotPermittedException(\"Copy is only permitted on FSPathResult objects containing a java.io.File object\");\n        }\n        Pattern pattern = Pattern.compile(matchExpression);\n        FSPathResultModificationList results = new FSPathResultModificationListImpl();\n        for (FSPathResult result : this) {\n            File origFile = null;\n            File newFile = null;\n            try {\n                origFile = result.getFile();\n                Matcher matcher = pattern.matcher(origFile.getName());\n                String newName = matcher.replaceAll(replaceExpresion);\n                newFile = new File(newName);\n                origFile.renameTo(newFile);\n                results.addSuccess(new FSPathResult(newFile));\n            } catch (Exception e) {\n                results.addFailure(new FSPathResult(newFile));\n            }\n        }\n        return results;\n    }\n\n    /**\n     *  Moves each file in the list to the specified desination path.\n     *\n     *  This method effecively calls copy() and then delete() on itself.\n     *  If any file fails to sucessfully copy, then this method 'fails fast'\n     *  and returns the results of the copy. This should prevent the situation arising\n     *  where the copied files are completely deleted.\n     *  If the copy suceeds, then it will attempt to delete the original files.\n     *\n     *  @param String - the directory path to move the files to.\n     *  @throws OperationNotPermittedException - see the comments for <code>copy</code>\n     */\n    public FSPathResultModificationList move(String destinationPath) throws IOException, OperationNotPermittedException {\n        if (!isListOfFiles()) {\n            throw new OperationNotPermittedException(\"move is only permitted on FSPathResult objects containing a java.io.File object\");\n        }\n        FSPathResultModificationList copyResults = this.copy(destinationPath);\n        //if we detect a failure then cease what we're doing and return the results so far\n        if (copyResults.hasFailures()) {\n            return copyResults;\n        }\n        //if we're happy with the copy, delete the original files,\n        //and return the results of the deletion\n        return this.delete();\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/60_sugar/src/main/java/net/sf/sugar/fspath/FSPathResultListImpl_5Test.java",
		"test_prompt": "// FSPathResultListImpl_5Test.java\n/*\n * FSPathResultListImpl.java\n *\n * Created on 08 April 2008, 18:00\n *\n */\npackage net.sf.sugar.fspath;\n\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FSPathResultListImpl}.\n* It contains ten unit test cases for the {@link FSPathResultListImpl#move(String)} method.\n*/\nclass FSPathResultListImpl_5Test {"
	},
	{
		"original_code": "// Prompt.java\n/**\n * Copyright 2008 (C) Keith Bishop (bishi@users.sourceforge.net)\n *\n * All rights reserved.\n *\n * This file is part of FSPath.\n *\n * FSPath is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * FSPath is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with FSPath.  If not, see <http://www.gnu.org/licenses/>.\n */\n/*\n * Prompt.java\n *\n * Created on 24 April 2008, 22:15\n *\n */\npackage net.sf.sugar.fspath.cli;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\n\n/**\n * @author kbishop\n * @version $Id$\n */\nclass Prompt {\n\n    private String promptText;\n\n    private BufferedReader in;\n\n    private PrintStream out;\n\n    private PrintStream err;\n\n    /**\n     * Creates a new instance of Prompt\n     */\n    public Prompt(InputStream in, PrintStream out, PrintStream err) {\n        this.out = out;\n        this.err = err;\n        this.in = new BufferedReader(new InputStreamReader(in));\n    }\n\n    public String readLine() throws IOException {\n        out.print(promptText);\n        out.flush();\n        return in.readLine();\n    }\n\n    public String getPromptText() {\n        return promptText;\n    }\n\n    public void setPromptText(String promptText) {\n        this.promptText = promptText;\n    }\n\n    public void close() {\n        try {\n            in.close();\n        } catch (IOException ioe) {\n            ioe.printStackTrace(err);\n        }\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/60_sugar/src/main/java/net/sf/sugar/fspath/cli/Prompt.java",
		"test_prompt": "// PromptTest.java\n/*\n * Prompt.java\n *\n * Created on 24 April 2008, 22:15\n *\n */\npackage net.sf.sugar.fspath.cli;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Prompt}.\n* It contains ten unit test cases for the {@link Prompt#readLine()} method.\n*/\nclass PromptTest {"
	},
	{
		"original_code": "// FSPathResultModificationListImpl.java\n/**\n * Copyright 2008 (C) Keith Bishop (bishi@users.sourceforge.net)\n *\n * All rights reserved.\n *\n * This file is part of FSPath.\n *\n * FSPath is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * FSPath is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with FSPath.  If not, see <http://www.gnu.org/licenses/>.\n */\n/*\n * FSPathResultModificationListImpl.java\n *\n * Created on 08 April 2008, 18:33\n *\n */\npackage net.sf.sugar.fspath;\n\nimport java.util.LinkedList;\n\n/**\n * @author kbishop\n * @version $Id$\n */\npublic class FSPathResultModificationListImpl extends LinkedList<FSPathResult> implements FSPathResultModificationList {\n\n    private FSPathResult firstSuccess;\n\n    private FSPathResult firstFailure;\n\n    /**\n     * Creates a new instance of FSPathResultModificationListImpl\n     */\n    public FSPathResultModificationListImpl() {\n    }\n\n    public FSPathResultModificationList onFailure(Callback callback) {\n        for (FSPathResult result : this.getFailures()) {\n            callback.call(result);\n        }\n        return this;\n    }\n\n    public boolean hasFailures() {\n        return (this.firstFailure != null);\n    }\n\n    public FSPathResultList getSuccesses() {\n        FSPathResultList successes = new FSPathResultListImpl();\n        if (this.firstSuccess != null) {\n            int index = this.indexOf(this.firstSuccess);\n            successes.addAll(this.subList(0, index + 1));\n        }\n        return successes;\n    }\n\n    public FSPathResultList getFailures() {\n        FSPathResultList failures = new FSPathResultListImpl();\n        if (this.firstFailure != null) {\n            int index = this.indexOf(this.firstFailure);\n            failures.addAll(this.subList(index, this.size()));\n        }\n        return failures;\n    }\n\n    public void addSuccess(FSPathResult successResult) {\n        if (this.firstSuccess == null) {\n            this.firstSuccess = successResult;\n        }\n        this.addFirst(successResult);\n    }\n\n    public void addFailure(FSPathResult failureResult) {\n        if (this.firstFailure == null) {\n            this.firstFailure = failureResult;\n        }\n        this.addLast(failureResult);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/60_sugar/src/main/java/net/sf/sugar/fspath/FSPathResultModificationListImpl_0Test.java",
		"test_prompt": "// FSPathResultModificationListImpl_0Test.java\n/*\n * FSPathResultModificationListImpl.java\n *\n * Created on 08 April 2008, 18:33\n *\n */\npackage net.sf.sugar.fspath;\n\nimport java.util.LinkedList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FSPathResultModificationListImpl}.\n* It contains ten unit test cases for the {@link FSPathResultModificationListImpl#onFailure(Callback)} method.\n*/\nclass FSPathResultModificationListImpl_0Test {"
	},
	{
		"original_code": "// FSPathResultModificationListImpl.java\n/**\n * Copyright 2008 (C) Keith Bishop (bishi@users.sourceforge.net)\n *\n * All rights reserved.\n *\n * This file is part of FSPath.\n *\n * FSPath is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * FSPath is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with FSPath.  If not, see <http://www.gnu.org/licenses/>.\n */\n/*\n * FSPathResultModificationListImpl.java\n *\n * Created on 08 April 2008, 18:33\n *\n */\npackage net.sf.sugar.fspath;\n\nimport java.util.LinkedList;\n\n/**\n * @author kbishop\n * @version $Id$\n */\npublic class FSPathResultModificationListImpl extends LinkedList<FSPathResult> implements FSPathResultModificationList {\n\n    private FSPathResult firstSuccess;\n\n    private FSPathResult firstFailure;\n\n    /**\n     * Creates a new instance of FSPathResultModificationListImpl\n     */\n    public FSPathResultModificationListImpl() {\n    }\n\n    public FSPathResultModificationList onFailure(Callback callback) {\n        for (FSPathResult result : this.getFailures()) {\n            callback.call(result);\n        }\n        return this;\n    }\n\n    public boolean hasFailures() {\n        return (this.firstFailure != null);\n    }\n\n    public FSPathResultList getSuccesses() {\n        FSPathResultList successes = new FSPathResultListImpl();\n        if (this.firstSuccess != null) {\n            int index = this.indexOf(this.firstSuccess);\n            successes.addAll(this.subList(0, index + 1));\n        }\n        return successes;\n    }\n\n    public FSPathResultList getFailures() {\n        FSPathResultList failures = new FSPathResultListImpl();\n        if (this.firstFailure != null) {\n            int index = this.indexOf(this.firstFailure);\n            failures.addAll(this.subList(index, this.size()));\n        }\n        return failures;\n    }\n\n    public void addSuccess(FSPathResult successResult) {\n        if (this.firstSuccess == null) {\n            this.firstSuccess = successResult;\n        }\n        this.addFirst(successResult);\n    }\n\n    public void addFailure(FSPathResult failureResult) {\n        if (this.firstFailure == null) {\n            this.firstFailure = failureResult;\n        }\n        this.addLast(failureResult);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/60_sugar/src/main/java/net/sf/sugar/fspath/FSPathResultModificationListImpl_1Test.java",
		"test_prompt": "// FSPathResultModificationListImpl_1Test.java\n/*\n * FSPathResultModificationListImpl.java\n *\n * Created on 08 April 2008, 18:33\n *\n */\npackage net.sf.sugar.fspath;\n\nimport java.util.LinkedList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FSPathResultModificationListImpl}.\n* It contains ten unit test cases for the {@link FSPathResultModificationListImpl#hasFailures()} method.\n*/\nclass FSPathResultModificationListImpl_1Test {"
	},
	{
		"original_code": "// LocalReference.java\npackage net.sf.sugar.scl;\r\n\r\nimport org.w3c.dom.Element;\r\n\r\n/**\r\n * Created by IntelliJ IDEA.\r\n * User: kbishop\r\n * Date: 07-Sep-2008\r\n * Time: 21:21:04\r\n */\r\npublic class LocalReference {\r\n\r\n    private boolean resolved;\r\n\r\n    private Element parentElement;\r\n\r\n    private String xPathQuery;\r\n\r\n    public boolean isResolved() {\r\n        return resolved;\r\n    }\r\n\r\n    public void setResolved() {\r\n        this.resolved = true;\r\n    }\r\n\r\n    public Element getParentElement() {\r\n        return parentElement;\r\n    }\r\n\r\n    public void setParentElement(Element parentElement) {\r\n        this.parentElement = parentElement;\r\n    }\r\n\r\n    public String getXPathQuery() {\r\n        return xPathQuery;\r\n    }\r\n\r\n    public void setXPathQuery(String xPathQuery) {\r\n        this.xPathQuery = xPathQuery;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/60_sugar/src/main/java/net/sf/sugar/scl/LocalReference.java",
		"test_prompt": "// LocalReferenceTest.java\npackage net.sf.sugar.scl;\n\nimport org.w3c.dom.Element;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link LocalReference}.\n* It contains ten unit test cases for the {@link LocalReference#isResolved()} method.\n*/\nclass LocalReferenceTest {"
	},
	{
		"original_code": "// SCLParser.java\n// $ANTLR 3.3 Nov 30, 2010 12:46:29 net/sf/sugar/scl/SCL.g 2013-06-10 17:15:03\npackage net.sf.sugar.scl;\n\nimport static net.sf.sugar.scl.PathConversionUtils.convertToXPath;\nimport static net.sf.sugar.scl.PathConversionUtils.processDotDelimitedPath;\nimport java.net.URI;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Element;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathFactory;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpressionException;\nimport org.antlr.runtime.*;\nimport java.util.Stack;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class SCLParser extends Parser {\n\n    public static final String[] tokenNames = new String[] { \"<invalid>\", \"<EOR>\", \"<DOWN>\", \"<UP>\", \"VALID_NAME_CHARS\", \"OPEN_NESTING\", \"CLOSE_NESTING\", \"ASSIGNMENT_OP\", \"STRING_LITERAL\", \"START_INCLUDE\", \"AS_KEYWORD\", \"END_INCLUDE\", \"START_UNPARSED_INCLUDE\", \"REF_CHAR\", \"WS\", \"QUOTE\", \"STRING_SEQUENCE_CHAR\", \"COMMENT\", \"LINE_COMMENT\", \"'.'\" };\n\n    public static final int EOF = -1;\n\n    public static final int T__19 = 19;\n\n    public static final int VALID_NAME_CHARS = 4;\n\n    public static final int OPEN_NESTING = 5;\n\n    public static final int CLOSE_NESTING = 6;\n\n    public static final int ASSIGNMENT_OP = 7;\n\n    public static final int STRING_LITERAL = 8;\n\n    public static final int START_INCLUDE = 9;\n\n    public static final int AS_KEYWORD = 10;\n\n    public static final int END_INCLUDE = 11;\n\n    public static final int START_UNPARSED_INCLUDE = 12;\n\n    public static final int REF_CHAR = 13;\n\n    public static final int WS = 14;\n\n    public static final int QUOTE = 15;\n\n    public static final int STRING_SEQUENCE_CHAR = 16;\n\n    public static final int COMMENT = 17;\n\n    public static final int LINE_COMMENT = 18;\n\n    // delegates\n    // delegators\n    public SCLParser(TokenStream input) {\n        this(input, new RecognizerSharedState());\n    }\n\n    public SCLParser(TokenStream input, RecognizerSharedState state) {\n        super(input, state);\n    }\n\n    public String[] getTokenNames() {\n        return SCLParser.tokenNames;\n    }\n\n    public String getGrammarFileName() {\n        return \"net/sf/sugar/scl/SCL.g\";\n    }\n\n    public static final String SCL_ROOT_ELEMENT = \"scl\";\n\n    private URI rootSCLFile;\n\n    private Document doc;\n\n    private Stack<Element> elements = new Stack<Element>();\n\n    private XPath xpath = XPathFactory.newInstance().newXPath();\n\n    private IncludeProcessor includeProcessor;\n\n    private static LocalReferenceProcessor localReferenceProcessor;\n\n    private List<LocalReference> localRefs = new ArrayList<LocalReference>();\n\n    private int namespaceSteps;\n\n    {\n        try {\n            doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n            Element rootElement = doc.createElement(SCL_ROOT_ELEMENT);\n            doc.appendChild(rootElement);\n            this.elements.push(rootElement);\n        } catch (ParserConfigurationException pce) {\n            pce.printStackTrace();\n        }\n    }\n\n    protected Element addChildElement(Element element, String child) {\n        Element childElement = this.doc.createElement(child);\n        element.appendChild(childElement);\n        return childElement;\n    }\n\n    protected Element addChildElements(Element currentElement, String compositePath) {\n        return processDotDelimitedPath(currentElement, compositePath);\n    }\n\n    protected void addAttribute(Element currentElement, String attributeName, String attributeValue) {\n        Element childElement = this.doc.createElement(attributeName);\n        childElement.setTextContent(attributeValue);\n        currentElement.appendChild(childElement);\n    }\n\n    protected void loadIncludeValue(Element parentElement, String propertyName, String includeLocation, String xPathExpression) throws IncludeException {\n        this.includeProcessor.prepareIncludeValue(parentElement, propertyName, includeLocation, this.rootSCLFile, xPathExpression);\n    }\n\n    protected void loadInclude(Element parentElement, String includeLocation) throws IncludeException {\n        this.includeProcessor.prepareInclude(parentElement, includeLocation, this.rootSCLFile);\n    }\n\n    protected void loadIncludeNodes(Element parentElement, String includeLocation, String xPathExpression) throws IncludeException {\n        this.includeProcessor.prepareInclude(parentElement, includeLocation, this.rootSCLFile, xPathExpression);\n    }\n\n    protected void loadUnparsedInclude(Element parentElement, String propertyName, String includeLocation) throws IncludeException {\n        this.includeProcessor.loadUnparsedInclude(parentElement, propertyName, includeLocation, this.rootSCLFile);\n    }\n\n    protected void prepareLocalRefTree(final Element parentElement, final String xPathExpression) {\n        LocalReference localRef = new LocalReference() {\n\n            {\n                setParentElement(parentElement);\n                setXPathQuery(xPathExpression);\n            }\n        };\n        this.localRefs.add(localRef);\n    }\n\n    protected void prepareLocalRef(final Element parentElement, final String attributeName, final String xPathExpression) {\n        LocalAttributeReference localRef = new LocalAttributeReference() {\n\n            {\n                setParentElement(parentElement);\n                setXPathQuery(xPathExpression);\n                setAttributeName(attributeName);\n            }\n        };\n        this.localRefs.add(localRef);\n    }\n\n    public void setRootSCLFile(URI rootSCLFile) {\n        this.rootSCLFile = rootSCLFile;\n    }\n\n    public URI getRootSCLFile() {\n        return this.rootSCLFile;\n    }\n\n    public Document getRootDocument() {\n        return this.doc;\n    }\n\n    public void setIncludeProcessor(IncludeProcessor includeProcessor) {\n        this.includeProcessor = includeProcessor;\n    }\n\n    public IncludeProcessor getIncludeProcessor() {\n        return this.includeProcessor;\n    }\n\n    public void setLocalReferenceProcessor(LocalReferenceProcessor processor) {\n        localReferenceProcessor = processor;\n    }\n\n    public LocalReferenceProcessor getLocalReferenceProcessor() {\n        return localReferenceProcessor;\n    }\n\n    public List<LocalReference> getLocalRefs() {\n        return this.localRefs;\n    }\n\n    public String sanitiseText(String rawText) {\n        String unquotedText = stripQuotes(rawText);\n        return normaliseEscapeChars(unquotedText);\n    }\n\n    private String stripQuotes(String quotedText) {\n        return quotedText.substring(1, quotedText.length() - 1);\n    }\n\n    private String normaliseEscapeChars(String text) {\n        return text.replace(\"\\\\\\\\\", \"\\\\\").replace(\"\\\\\\\"\", \"\\\"\");\n    }\n\n    // $ANTLR start \"scl\"\n    // net/sf/sugar/scl/SCL.g:152:1: scl returns [Document properties] : statementSeq ;\n    public final Document scl() throws RecognitionException {\n        Document properties = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:153:6: ( statementSeq )\n            // net/sf/sugar/scl/SCL.g:153:8: statementSeq\n            {\n                pushFollow(FOLLOW_statementSeq_in_scl44);\n                statementSeq();\n                state._fsp--;\n                try {\n                    this.includeProcessor.resolveIncludes(this.doc);\n                    localReferenceProcessor.processLocalReferences(this.localRefs);\n                } catch (IncludeException ie) {\n                    ie.printStackTrace();\n                } catch (LocalReferenceException lre) {\n                    lre.printStackTrace();\n                }\n                properties = doc;\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return properties;\n    }\n\n    // $ANTLR end \"scl\"\n    // $ANTLR start \"statementSeq\"\n    // net/sf/sugar/scl/SCL.g:168:1: statementSeq : ( statement )+ ;\n    public final void statementSeq() throws RecognitionException {\n        try {\n            // net/sf/sugar/scl/SCL.g:168:15: ( ( statement )+ )\n            // net/sf/sugar/scl/SCL.g:168:17: ( statement )+\n            {\n                // net/sf/sugar/scl/SCL.g:168:17: ( statement )+\n                int cnt1 = 0;\n                loop1: do {\n                    int alt1 = 2;\n                    switch(input.LA(1)) {\n                        case VALID_NAME_CHARS:\n                        case START_INCLUDE:\n                        case REF_CHAR:\n                            {\n                                alt1 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt1) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:168:17: statement\n                            {\n                                pushFollow(FOLLOW_statement_in_statementSeq61);\n                                statement();\n                                state._fsp--;\n                            }\n                            break;\n                        default:\n                            if (cnt1 >= 1)\n                                break loop1;\n                            EarlyExitException eee = new EarlyExitException(1, input);\n                            throw eee;\n                    }\n                    cnt1++;\n                } while (true);\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"statementSeq\"\n    // $ANTLR start \"statement\"\n    // net/sf/sugar/scl/SCL.g:170:1: statement : ( namespaceDecl | assignment | includeTree | t= localRefTree );\n    public final void statement() throws RecognitionException {\n        String t = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:170:13: ( namespaceDecl | assignment | includeTree | t= localRefTree )\n            int alt2 = 4;\n            alt2 = dfa2.predict(input);\n            switch(alt2) {\n                case 1:\n                    // net/sf/sugar/scl/SCL.g:170:15: namespaceDecl\n                    {\n                        pushFollow(FOLLOW_namespaceDecl_in_statement73);\n                        namespaceDecl();\n                        state._fsp--;\n                    }\n                    break;\n                case 2:\n                    // net/sf/sugar/scl/SCL.g:171:9: assignment\n                    {\n                        pushFollow(FOLLOW_assignment_in_statement84);\n                        assignment();\n                        state._fsp--;\n                    }\n                    break;\n                case 3:\n                    // net/sf/sugar/scl/SCL.g:172:9: includeTree\n                    {\n                        pushFollow(FOLLOW_includeTree_in_statement95);\n                        includeTree();\n                        state._fsp--;\n                    }\n                    break;\n                case 4:\n                    // net/sf/sugar/scl/SCL.g:173:9: t= localRefTree\n                    {\n                        pushFollow(FOLLOW_localRefTree_in_statement108);\n                        t = localRefTree();\n                        state._fsp--;\n                        prepareLocalRefTree(this.elements.peek(), t);\n                    }\n                    break;\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"statement\"\n    // $ANTLR start \"namespaceDecl\"\n    // net/sf/sugar/scl/SCL.g:177:1: namespaceDecl : namespaceName namespaceBody ;\n    public final void namespaceDecl() throws RecognitionException {\n        try {\n            // net/sf/sugar/scl/SCL.g:177:16: ( namespaceName namespaceBody )\n            // net/sf/sugar/scl/SCL.g:177:18: namespaceName namespaceBody\n            {\n                pushFollow(FOLLOW_namespaceName_in_namespaceDecl120);\n                namespaceName();\n                state._fsp--;\n                pushFollow(FOLLOW_namespaceBody_in_namespaceDecl122);\n                namespaceBody();\n                state._fsp--;\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"namespaceDecl\"\n    public static class namespaceName_return extends ParserRuleReturnScope {\n    }\n\n    // $ANTLR start \"namespaceName\"\n    // net/sf/sugar/scl/SCL.g:179:1: namespaceName : ( varName | compositeNamespaceName );\n    public final SCLParser.namespaceName_return namespaceName() throws RecognitionException {\n        SCLParser.namespaceName_return retval = new SCLParser.namespaceName_return();\n        retval.start = input.LT(1);\n        SCLParser.compositeNamespaceName_return compositeNamespaceName1 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:179:16: ( varName | compositeNamespaceName )\n            int alt3 = 2;\n            alt3 = dfa3.predict(input);\n            switch(alt3) {\n                case 1:\n                    // net/sf/sugar/scl/SCL.g:179:18: varName\n                    {\n                        pushFollow(FOLLOW_varName_in_namespaceName132);\n                        varName();\n                        state._fsp--;\n                        this.elements.push(addChildElement(this.elements.peek(), input.toString(retval.start, input.LT(-1))));\n                    }\n                    break;\n                case 2:\n                    // net/sf/sugar/scl/SCL.g:180:9: compositeNamespaceName\n                    {\n                        pushFollow(FOLLOW_compositeNamespaceName_in_namespaceName145);\n                        compositeNamespaceName1 = compositeNamespaceName();\n                        state._fsp--;\n                        this.elements.push(addChildElements(this.elements.peek(), (compositeNamespaceName1 != null ? input.toString(compositeNamespaceName1.start, compositeNamespaceName1.stop) : null)));\n                    }\n                    break;\n            }\n            retval.stop = input.LT(-1);\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return retval;\n    }\n\n    // $ANTLR end \"namespaceName\"\n    public static class compositeNamespaceName_return extends ParserRuleReturnScope {\n    }\n\n    // $ANTLR start \"compositeNamespaceName\"\n    // net/sf/sugar/scl/SCL.g:182:1: compositeNamespaceName : ( VALID_NAME_CHARS )+ ( '.' ( VALID_NAME_CHARS )+ )+ ;\n    public final SCLParser.compositeNamespaceName_return compositeNamespaceName() throws RecognitionException {\n        SCLParser.compositeNamespaceName_return retval = new SCLParser.compositeNamespaceName_return();\n        retval.start = input.LT(1);\n        try {\n            // net/sf/sugar/scl/SCL.g:182:24: ( ( VALID_NAME_CHARS )+ ( '.' ( VALID_NAME_CHARS )+ )+ )\n            // net/sf/sugar/scl/SCL.g:182:28: ( VALID_NAME_CHARS )+ ( '.' ( VALID_NAME_CHARS )+ )+\n            {\n                // net/sf/sugar/scl/SCL.g:182:28: ( VALID_NAME_CHARS )+\n                int cnt4 = 0;\n                loop4: do {\n                    int alt4 = 2;\n                    switch(input.LA(1)) {\n                        case VALID_NAME_CHARS:\n                            {\n                                alt4 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt4) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:182:28: VALID_NAME_CHARS\n                            {\n                                match(input, VALID_NAME_CHARS, FOLLOW_VALID_NAME_CHARS_in_compositeNamespaceName160);\n                            }\n                            break;\n                        default:\n                            if (cnt4 >= 1)\n                                break loop4;\n                            EarlyExitException eee = new EarlyExitException(4, input);\n                            throw eee;\n                    }\n                    cnt4++;\n                } while (true);\n                // net/sf/sugar/scl/SCL.g:182:46: ( '.' ( VALID_NAME_CHARS )+ )+\n                int cnt6 = 0;\n                loop6: do {\n                    int alt6 = 2;\n                    switch(input.LA(1)) {\n                        case 19:\n                            {\n                                alt6 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt6) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:182:47: '.' ( VALID_NAME_CHARS )+\n                            {\n                                match(input, 19, FOLLOW_19_in_compositeNamespaceName164);\n                                // net/sf/sugar/scl/SCL.g:182:51: ( VALID_NAME_CHARS )+\n                                int cnt5 = 0;\n                                loop5: do {\n                                    int alt5 = 2;\n                                    switch(input.LA(1)) {\n                                        case VALID_NAME_CHARS:\n                                            {\n                                                alt5 = 1;\n                                            }\n                                            break;\n                                    }\n                                    switch(alt5) {\n                                        case 1:\n                                            // net/sf/sugar/scl/SCL.g:182:51: VALID_NAME_CHARS\n                                            {\n                                                match(input, VALID_NAME_CHARS, FOLLOW_VALID_NAME_CHARS_in_compositeNamespaceName166);\n                                            }\n                                            break;\n                                        default:\n                                            if (cnt5 >= 1)\n                                                break loop5;\n                                            EarlyExitException eee = new EarlyExitException(5, input);\n                                            throw eee;\n                                    }\n                                    cnt5++;\n                                } while (true);\n                            }\n                            break;\n                        default:\n                            if (cnt6 >= 1)\n                                break loop6;\n                            EarlyExitException eee = new EarlyExitException(6, input);\n                            throw eee;\n                    }\n                    cnt6++;\n                } while (true);\n            }\n            retval.stop = input.LT(-1);\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return retval;\n    }\n\n    // $ANTLR end \"compositeNamespaceName\"\n    // $ANTLR start \"namespaceBody\"\n    // net/sf/sugar/scl/SCL.g:184:1: namespaceBody : OPEN_NESTING ( statement )* CLOSE_NESTING ;\n    public final void namespaceBody() throws RecognitionException {\n        try {\n            // net/sf/sugar/scl/SCL.g:184:16: ( OPEN_NESTING ( statement )* CLOSE_NESTING )\n            // net/sf/sugar/scl/SCL.g:184:18: OPEN_NESTING ( statement )* CLOSE_NESTING\n            {\n                match(input, OPEN_NESTING, FOLLOW_OPEN_NESTING_in_namespaceBody181);\n                // net/sf/sugar/scl/SCL.g:184:31: ( statement )*\n                loop7: do {\n                    int alt7 = 2;\n                    switch(input.LA(1)) {\n                        case VALID_NAME_CHARS:\n                        case START_INCLUDE:\n                        case REF_CHAR:\n                            {\n                                alt7 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt7) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:184:32: statement\n                            {\n                                pushFollow(FOLLOW_statement_in_namespaceBody184);\n                                statement();\n                                state._fsp--;\n                            }\n                            break;\n                        default:\n                            break loop7;\n                    }\n                } while (true);\n                match(input, CLOSE_NESTING, FOLLOW_CLOSE_NESTING_in_namespaceBody188);\n                this.elements.pop();\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"namespaceBody\"\n    // $ANTLR start \"assignment\"\n    // net/sf/sugar/scl/SCL.g:188:1: assignment : varName ASSIGNMENT_OP ( varValue | includeValue | v= unparsedIncludeValue | r= localReference ) ;\n    public final void assignment() throws RecognitionException {\n        String v = null;\n        String r = null;\n        SCLParser.varName_return varName2 = null;\n        SCLParser.varValue_return varValue3 = null;\n        SCLParser.includeValue_return includeValue4 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:188:14: ( varName ASSIGNMENT_OP ( varValue | includeValue | v= unparsedIncludeValue | r= localReference ) )\n            // net/sf/sugar/scl/SCL.g:188:16: varName ASSIGNMENT_OP ( varValue | includeValue | v= unparsedIncludeValue | r= localReference )\n            {\n                pushFollow(FOLLOW_varName_in_assignment201);\n                varName2 = varName();\n                state._fsp--;\n                match(input, ASSIGNMENT_OP, FOLLOW_ASSIGNMENT_OP_in_assignment203);\n                // net/sf/sugar/scl/SCL.g:188:38: ( varValue | includeValue | v= unparsedIncludeValue | r= localReference )\n                int alt8 = 4;\n                switch(input.LA(1)) {\n                    case STRING_LITERAL:\n                        {\n                            alt8 = 1;\n                        }\n                        break;\n                    case START_INCLUDE:\n                        {\n                            alt8 = 2;\n                        }\n                        break;\n                    case START_UNPARSED_INCLUDE:\n                        {\n                            alt8 = 3;\n                        }\n                        break;\n                    case REF_CHAR:\n                        {\n                            alt8 = 4;\n                        }\n                        break;\n                    default:\n                        NoViableAltException nvae = new NoViableAltException(\"\", 8, 0, input);\n                        throw nvae;\n                }\n                switch(alt8) {\n                    case 1:\n                        // net/sf/sugar/scl/SCL.g:188:39: varValue\n                        {\n                            pushFollow(FOLLOW_varValue_in_assignment206);\n                            varValue3 = varValue();\n                            state._fsp--;\n                            addAttribute(this.elements.peek(), (varName2 != null ? input.toString(varName2.start, varName2.stop) : null), sanitiseText((varValue3 != null ? input.toString(varValue3.start, varValue3.stop) : null)));\n                        }\n                        break;\n                    case 2:\n                        // net/sf/sugar/scl/SCL.g:194:14: includeValue\n                        {\n                            pushFollow(FOLLOW_includeValue_in_assignment230);\n                            includeValue4 = includeValue();\n                            state._fsp--;\n                            try {\n                                this.loadIncludeValue(this.elements.peek(), (varName2 != null ? input.toString(varName2.start, varName2.stop) : null), sanitiseText((includeValue4 != null ? includeValue4.includeLocation : null)), sanitiseText((includeValue4 != null ? includeValue4.xPathQuery : null)));\n                            } catch (IncludeException ie) {\n                                ie.printStackTrace();\n                                System.out.println(ie);\n                            }\n                        }\n                        break;\n                    case 3:\n                        // net/sf/sugar/scl/SCL.g:205:12: v= unparsedIncludeValue\n                        {\n                            pushFollow(FOLLOW_unparsedIncludeValue_in_assignment247);\n                            v = unparsedIncludeValue();\n                            state._fsp--;\n                            try {\n                                this.loadUnparsedInclude(this.elements.peek(), (varName2 != null ? input.toString(varName2.start, varName2.stop) : null), v);\n                            } catch (IncludeException ie) {\n                                ie.printStackTrace();\n                            }\n                        }\n                        break;\n                    case 4:\n                        // net/sf/sugar/scl/SCL.g:212:15: r= localReference\n                        {\n                            pushFollow(FOLLOW_localReference_in_assignment267);\n                            r = localReference();\n                            state._fsp--;\n                            //todo : handle empty values, also handle non numeric, date and boolean return types\n                            prepareLocalRef(this.elements.peek(), (varName2 != null ? input.toString(varName2.start, varName2.stop) : null), r);\n                        }\n                        break;\n                }\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"assignment\"\n    public static class varName_return extends ParserRuleReturnScope {\n    }\n\n    // $ANTLR start \"varName\"\n    // net/sf/sugar/scl/SCL.g:218:1: varName : ( VALID_NAME_CHARS )+ ;\n    public final SCLParser.varName_return varName() throws RecognitionException {\n        SCLParser.varName_return retval = new SCLParser.varName_return();\n        retval.start = input.LT(1);\n        try {\n            // net/sf/sugar/scl/SCL.g:218:12: ( ( VALID_NAME_CHARS )+ )\n            // net/sf/sugar/scl/SCL.g:218:14: ( VALID_NAME_CHARS )+\n            {\n                // net/sf/sugar/scl/SCL.g:218:14: ( VALID_NAME_CHARS )+\n                int cnt9 = 0;\n                loop9: do {\n                    int alt9 = 2;\n                    switch(input.LA(1)) {\n                        case VALID_NAME_CHARS:\n                            {\n                                alt9 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt9) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:218:14: VALID_NAME_CHARS\n                            {\n                                match(input, VALID_NAME_CHARS, FOLLOW_VALID_NAME_CHARS_in_varName298);\n                            }\n                            break;\n                        default:\n                            if (cnt9 >= 1)\n                                break loop9;\n                            EarlyExitException eee = new EarlyExitException(9, input);\n                            throw eee;\n                    }\n                    cnt9++;\n                } while (true);\n            }\n            retval.stop = input.LT(-1);\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return retval;\n    }\n\n    // $ANTLR end \"varName\"\n    public static class varValue_return extends ParserRuleReturnScope {\n    }\n\n    // $ANTLR start \"varValue\"\n    // net/sf/sugar/scl/SCL.g:220:1: varValue : STRING_LITERAL ;\n    public final SCLParser.varValue_return varValue() throws RecognitionException {\n        SCLParser.varValue_return retval = new SCLParser.varValue_return();\n        retval.start = input.LT(1);\n        try {\n            // net/sf/sugar/scl/SCL.g:220:13: ( STRING_LITERAL )\n            // net/sf/sugar/scl/SCL.g:220:15: STRING_LITERAL\n            {\n                match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_varValue312);\n            }\n            retval.stop = input.LT(-1);\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return retval;\n    }\n\n    // $ANTLR end \"varValue\"\n    public static class includeValue_return extends ParserRuleReturnScope {\n\n        public String includeLocation;\n\n        public String xPathQuery;\n    }\n\n    // $ANTLR start \"includeValue\"\n    // net/sf/sugar/scl/SCL.g:223:1: includeValue returns [String includeLocation, String xPathQuery] : START_INCLUDE s1= STRING_LITERAL AS_KEYWORD s2= STRING_LITERAL END_INCLUDE ;\n    public final SCLParser.includeValue_return includeValue() throws RecognitionException {\n        SCLParser.includeValue_return retval = new SCLParser.includeValue_return();\n        retval.start = input.LT(1);\n        Token s1 = null;\n        Token s2 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:224:6: ( START_INCLUDE s1= STRING_LITERAL AS_KEYWORD s2= STRING_LITERAL END_INCLUDE )\n            // net/sf/sugar/scl/SCL.g:224:8: START_INCLUDE s1= STRING_LITERAL AS_KEYWORD s2= STRING_LITERAL END_INCLUDE\n            {\n                match(input, START_INCLUDE, FOLLOW_START_INCLUDE_in_includeValue334);\n                s1 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_includeValue338);\n                match(input, AS_KEYWORD, FOLLOW_AS_KEYWORD_in_includeValue340);\n                s2 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_includeValue344);\n                match(input, END_INCLUDE, FOLLOW_END_INCLUDE_in_includeValue346);\n                retval.includeLocation = (s1 != null ? s1.getText() : null);\n                retval.xPathQuery = (s2 != null ? s2.getText() : null);\n            }\n            retval.stop = input.LT(-1);\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return retval;\n    }\n\n    // $ANTLR end \"includeValue\"\n    // $ANTLR start \"unparsedIncludeValue\"\n    // net/sf/sugar/scl/SCL.g:229:1: unparsedIncludeValue returns [String includeLocation] : START_UNPARSED_INCLUDE s1= STRING_LITERAL END_INCLUDE ;\n    public final String unparsedIncludeValue() throws RecognitionException {\n        String includeLocation = null;\n        Token s1 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:230:6: ( START_UNPARSED_INCLUDE s1= STRING_LITERAL END_INCLUDE )\n            // net/sf/sugar/scl/SCL.g:230:8: START_UNPARSED_INCLUDE s1= STRING_LITERAL END_INCLUDE\n            {\n                match(input, START_UNPARSED_INCLUDE, FOLLOW_START_UNPARSED_INCLUDE_in_unparsedIncludeValue373);\n                s1 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_unparsedIncludeValue377);\n                match(input, END_INCLUDE, FOLLOW_END_INCLUDE_in_unparsedIncludeValue379);\n                includeLocation = stripQuotes(s1.getText());\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return includeLocation;\n    }\n\n    // $ANTLR end \"unparsedIncludeValue\"\n    // $ANTLR start \"includeTree\"\n    // net/sf/sugar/scl/SCL.g:234:1: includeTree : START_INCLUDE s1= STRING_LITERAL ( AS_KEYWORD s2= STRING_LITERAL )? END_INCLUDE ;\n    public final void includeTree() throws RecognitionException {\n        Token s1 = null;\n        Token s2 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:234:15: ( START_INCLUDE s1= STRING_LITERAL ( AS_KEYWORD s2= STRING_LITERAL )? END_INCLUDE )\n            // net/sf/sugar/scl/SCL.g:234:17: START_INCLUDE s1= STRING_LITERAL ( AS_KEYWORD s2= STRING_LITERAL )? END_INCLUDE\n            {\n                match(input, START_INCLUDE, FOLLOW_START_INCLUDE_in_includeTree399);\n                s1 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_includeTree403);\n                // net/sf/sugar/scl/SCL.g:234:49: ( AS_KEYWORD s2= STRING_LITERAL )?\n                int alt10 = 2;\n                switch(input.LA(1)) {\n                    case AS_KEYWORD:\n                        {\n                            alt10 = 1;\n                        }\n                        break;\n                }\n                switch(alt10) {\n                    case 1:\n                        // net/sf/sugar/scl/SCL.g:234:50: AS_KEYWORD s2= STRING_LITERAL\n                        {\n                            match(input, AS_KEYWORD, FOLLOW_AS_KEYWORD_in_includeTree406);\n                            s2 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_includeTree410);\n                        }\n                        break;\n                }\n                match(input, END_INCLUDE, FOLLOW_END_INCLUDE_in_includeTree414);\n                try {\n                    if (s2 == null || \"\".equals(s2)) {\n                        this.loadInclude(this.elements.peek(), sanitiseText(s1.getText()));\n                    } else {\n                        this.loadIncludeNodes(this.elements.peek(), sanitiseText(s1.getText()), sanitiseText(s2.getText()));\n                    }\n                } catch (IncludeException ie) {\n                    ie.printStackTrace();\n                }\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"includeTree\"\n    // $ANTLR start \"localRefTree\"\n    // net/sf/sugar/scl/SCL.g:250:1: localRefTree returns [String xPathQuery] : r= localReference ;\n    public final String localRefTree() throws RecognitionException {\n        String xPathQuery = null;\n        String r = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:251:7: (r= localReference )\n            // net/sf/sugar/scl/SCL.g:251:10: r= localReference\n            {\n                pushFollow(FOLLOW_localReference_in_localRefTree442);\n                r = localReference();\n                state._fsp--;\n                xPathQuery = r;\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return xPathQuery;\n    }\n\n    // $ANTLR end \"localRefTree\"\n    // $ANTLR start \"localReference\"\n    // net/sf/sugar/scl/SCL.g:253:1: localReference returns [String resolvedValue] : REF_CHAR ( WS )* STRING_LITERAL ;\n    public final String localReference() throws RecognitionException {\n        String resolvedValue = null;\n        Token STRING_LITERAL5 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:254:7: ( REF_CHAR ( WS )* STRING_LITERAL )\n            // net/sf/sugar/scl/SCL.g:254:10: REF_CHAR ( WS )* STRING_LITERAL\n            {\n                match(input, REF_CHAR, FOLLOW_REF_CHAR_in_localReference475);\n                // net/sf/sugar/scl/SCL.g:254:19: ( WS )*\n                loop11: do {\n                    int alt11 = 2;\n                    switch(input.LA(1)) {\n                        case WS:\n                            {\n                                alt11 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt11) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:254:19: WS\n                            {\n                                match(input, WS, FOLLOW_WS_in_localReference477);\n                            }\n                            break;\n                        default:\n                            break loop11;\n                    }\n                } while (true);\n                STRING_LITERAL5 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_localReference480);\n                resolvedValue = sanitiseText((STRING_LITERAL5 != null ? STRING_LITERAL5.getText() : null));\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return resolvedValue;\n    }\n\n    // $ANTLR end \"localReference\"\n    // Delegated rules\n    protected DFA2 dfa2 = new DFA2(this);\n\n    protected DFA3 dfa3 = new DFA3(this);\n\n    static final String DFA2_eotS = \"\\6\\uffff\";\n\n    static final String DFA2_eofS = \"\\6\\uffff\";\n\n    static final String DFA2_minS = \"\\2\\4\\4\\uffff\";\n\n    static final String DFA2_maxS = \"\\1\\15\\1\\23\\4\\uffff\";\n\n    static final String DFA2_acceptS = \"\\2\\uffff\\1\\3\\1\\4\\1\\1\\1\\2\";\n\n    static final String DFA2_specialS = \"\\6\\uffff}>\";\n\n    static final String[] DFA2_transitionS = { \"\\1\\1\\4\\uffff\\1\\2\\3\\uffff\\1\\3\", \"\\1\\1\\1\\4\\1\\uffff\\1\\5\\13\\uffff\\1\\4\", \"\", \"\", \"\", \"\" };\n\n    static final short[] DFA2_eot = DFA.unpackEncodedString(DFA2_eotS);\n\n    static final short[] DFA2_eof = DFA.unpackEncodedString(DFA2_eofS);\n\n    static final char[] DFA2_min = DFA.unpackEncodedStringToUnsignedChars(DFA2_minS);\n\n    static final char[] DFA2_max = DFA.unpackEncodedStringToUnsignedChars(DFA2_maxS);\n\n    static final short[] DFA2_accept = DFA.unpackEncodedString(DFA2_acceptS);\n\n    static final short[] DFA2_special = DFA.unpackEncodedString(DFA2_specialS);\n\n    static final short[][] DFA2_transition;\n\n    static {\n        int numStates = DFA2_transitionS.length;\n        DFA2_transition = new short[numStates][];\n        for (int i = 0; i < numStates; i++) {\n            DFA2_transition[i] = DFA.unpackEncodedString(DFA2_transitionS[i]);\n        }\n    }\n\n    class DFA2 extends DFA {\n\n        public DFA2(BaseRecognizer recognizer) {\n            this.recognizer = recognizer;\n            this.decisionNumber = 2;\n            this.eot = DFA2_eot;\n            this.eof = DFA2_eof;\n            this.min = DFA2_min;\n            this.max = DFA2_max;\n            this.accept = DFA2_accept;\n            this.special = DFA2_special;\n            this.transition = DFA2_transition;\n        }\n\n        public String getDescription() {\n            return \"170:1: statement : ( namespaceDecl | assignment | includeTree | t= localRefTree );\";\n        }\n    }\n\n    static final String DFA3_eotS = \"\\4\\uffff\";\n\n    static final String DFA3_eofS = \"\\4\\uffff\";\n\n    static final String DFA3_minS = \"\\2\\4\\2\\uffff\";\n\n    static final String DFA3_maxS = \"\\1\\4\\1\\23\\2\\uffff\";\n\n    static final String DFA3_acceptS = \"\\2\\uffff\\1\\1\\1\\2\";\n\n    static final String DFA3_specialS = \"\\4\\uffff}>\";\n\n    static final String[] DFA3_transitionS = { \"\\1\\1\", \"\\1\\1\\1\\2\\15\\uffff\\1\\3\", \"\", \"\" };\n\n    static final short[] DFA3_eot = DFA.unpackEncodedString(DFA3_eotS);\n\n    static final short[] DFA3_eof = DFA.unpackEncodedString(DFA3_eofS);\n\n    static final char[] DFA3_min = DFA.unpackEncodedStringToUnsignedChars(DFA3_minS);\n\n    static final char[] DFA3_max = DFA.unpackEncodedStringToUnsignedChars(DFA3_maxS);\n\n    static final short[] DFA3_accept = DFA.unpackEncodedString(DFA3_acceptS);\n\n    static final short[] DFA3_special = DFA.unpackEncodedString(DFA3_specialS);\n\n    static final short[][] DFA3_transition;\n\n    static {\n        int numStates = DFA3_transitionS.length;\n        DFA3_transition = new short[numStates][];\n        for (int i = 0; i < numStates; i++) {\n            DFA3_transition[i] = DFA.unpackEncodedString(DFA3_transitionS[i]);\n        }\n    }\n\n    class DFA3 extends DFA {\n\n        public DFA3(BaseRecognizer recognizer) {\n            this.recognizer = recognizer;\n            this.decisionNumber = 3;\n            this.eot = DFA3_eot;\n            this.eof = DFA3_eof;\n            this.min = DFA3_min;\n            this.max = DFA3_max;\n            this.accept = DFA3_accept;\n            this.special = DFA3_special;\n            this.transition = DFA3_transition;\n        }\n\n        public String getDescription() {\n            return \"179:1: namespaceName : ( varName | compositeNamespaceName );\";\n        }\n    }\n\n    public static final BitSet FOLLOW_statementSeq_in_scl44 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_statement_in_statementSeq61 = new BitSet(new long[] { 0x0000000000002212L });\n\n    public static final BitSet FOLLOW_namespaceDecl_in_statement73 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_assignment_in_statement84 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_includeTree_in_statement95 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_localRefTree_in_statement108 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_namespaceName_in_namespaceDecl120 = new BitSet(new long[] { 0x0000000000000020L });\n\n    public static final BitSet FOLLOW_namespaceBody_in_namespaceDecl122 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_varName_in_namespaceName132 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_compositeNamespaceName_in_namespaceName145 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_VALID_NAME_CHARS_in_compositeNamespaceName160 = new BitSet(new long[] { 0x0000000000080010L });\n\n    public static final BitSet FOLLOW_19_in_compositeNamespaceName164 = new BitSet(new long[] { 0x0000000000000010L });\n\n    public static final BitSet FOLLOW_VALID_NAME_CHARS_in_compositeNamespaceName166 = new BitSet(new long[] { 0x0000000000080012L });\n\n    public static final BitSet FOLLOW_OPEN_NESTING_in_namespaceBody181 = new BitSet(new long[] { 0x0000000000002250L });\n\n    public static final BitSet FOLLOW_statement_in_namespaceBody184 = new BitSet(new long[] { 0x0000000000002250L });\n\n    public static final BitSet FOLLOW_CLOSE_NESTING_in_namespaceBody188 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_varName_in_assignment201 = new BitSet(new long[] { 0x0000000000000080L });\n\n    public static final BitSet FOLLOW_ASSIGNMENT_OP_in_assignment203 = new BitSet(new long[] { 0x0000000000003310L });\n\n    public static final BitSet FOLLOW_varValue_in_assignment206 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_includeValue_in_assignment230 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_unparsedIncludeValue_in_assignment247 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_localReference_in_assignment267 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_VALID_NAME_CHARS_in_varName298 = new BitSet(new long[] { 0x0000000000000012L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_varValue312 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_START_INCLUDE_in_includeValue334 = new BitSet(new long[] { 0x0000000000000100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_includeValue338 = new BitSet(new long[] { 0x0000000000000400L });\n\n    public static final BitSet FOLLOW_AS_KEYWORD_in_includeValue340 = new BitSet(new long[] { 0x0000000000000100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_includeValue344 = new BitSet(new long[] { 0x0000000000000800L });\n\n    public static final BitSet FOLLOW_END_INCLUDE_in_includeValue346 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_START_UNPARSED_INCLUDE_in_unparsedIncludeValue373 = new BitSet(new long[] { 0x0000000000000100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_unparsedIncludeValue377 = new BitSet(new long[] { 0x0000000000000800L });\n\n    public static final BitSet FOLLOW_END_INCLUDE_in_unparsedIncludeValue379 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_START_INCLUDE_in_includeTree399 = new BitSet(new long[] { 0x0000000000000100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_includeTree403 = new BitSet(new long[] { 0x0000000000000C00L });\n\n    public static final BitSet FOLLOW_AS_KEYWORD_in_includeTree406 = new BitSet(new long[] { 0x0000000000000100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_includeTree410 = new BitSet(new long[] { 0x0000000000000800L });\n\n    public static final BitSet FOLLOW_END_INCLUDE_in_includeTree414 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_localReference_in_localRefTree442 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_REF_CHAR_in_localReference475 = new BitSet(new long[] { 0x0000000000004100L });\n\n    public static final BitSet FOLLOW_WS_in_localReference477 = new BitSet(new long[] { 0x0000000000004100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_localReference480 = new BitSet(new long[] { 0x0000000000000002L });\n}\n",
		"id": "/EvoSuiteBenchmark/60_sugar/src/main/java/net/sf/sugar/scl/SCLParser_0Test.java",
		"test_prompt": "// SCLParser_0Test.java\npackage net.sf.sugar.scl;\n\nimport static net.sf.sugar.scl.PathConversionUtils.convertToXPath;\nimport static net.sf.sugar.scl.PathConversionUtils.processDotDelimitedPath;\nimport java.net.URI;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Element;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathFactory;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpressionException;\nimport org.antlr.runtime.*;\nimport java.util.Stack;\nimport java.util.List;\nimport java.util.ArrayList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SCLParser}.\n* It contains ten unit test cases for the {@link SCLParser#sanitiseText(String)} method.\n*/\nclass SCLParser_0Test {"
	},
	{
		"original_code": "// SCLParser.java\n// $ANTLR 3.3 Nov 30, 2010 12:46:29 net/sf/sugar/scl/SCL.g 2013-06-10 17:15:03\npackage net.sf.sugar.scl;\n\nimport static net.sf.sugar.scl.PathConversionUtils.convertToXPath;\nimport static net.sf.sugar.scl.PathConversionUtils.processDotDelimitedPath;\nimport java.net.URI;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Element;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathFactory;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpressionException;\nimport org.antlr.runtime.*;\nimport java.util.Stack;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class SCLParser extends Parser {\n\n    public static final String[] tokenNames = new String[] { \"<invalid>\", \"<EOR>\", \"<DOWN>\", \"<UP>\", \"VALID_NAME_CHARS\", \"OPEN_NESTING\", \"CLOSE_NESTING\", \"ASSIGNMENT_OP\", \"STRING_LITERAL\", \"START_INCLUDE\", \"AS_KEYWORD\", \"END_INCLUDE\", \"START_UNPARSED_INCLUDE\", \"REF_CHAR\", \"WS\", \"QUOTE\", \"STRING_SEQUENCE_CHAR\", \"COMMENT\", \"LINE_COMMENT\", \"'.'\" };\n\n    public static final int EOF = -1;\n\n    public static final int T__19 = 19;\n\n    public static final int VALID_NAME_CHARS = 4;\n\n    public static final int OPEN_NESTING = 5;\n\n    public static final int CLOSE_NESTING = 6;\n\n    public static final int ASSIGNMENT_OP = 7;\n\n    public static final int STRING_LITERAL = 8;\n\n    public static final int START_INCLUDE = 9;\n\n    public static final int AS_KEYWORD = 10;\n\n    public static final int END_INCLUDE = 11;\n\n    public static final int START_UNPARSED_INCLUDE = 12;\n\n    public static final int REF_CHAR = 13;\n\n    public static final int WS = 14;\n\n    public static final int QUOTE = 15;\n\n    public static final int STRING_SEQUENCE_CHAR = 16;\n\n    public static final int COMMENT = 17;\n\n    public static final int LINE_COMMENT = 18;\n\n    // delegates\n    // delegators\n    public SCLParser(TokenStream input) {\n        this(input, new RecognizerSharedState());\n    }\n\n    public SCLParser(TokenStream input, RecognizerSharedState state) {\n        super(input, state);\n    }\n\n    public String[] getTokenNames() {\n        return SCLParser.tokenNames;\n    }\n\n    public String getGrammarFileName() {\n        return \"net/sf/sugar/scl/SCL.g\";\n    }\n\n    public static final String SCL_ROOT_ELEMENT = \"scl\";\n\n    private URI rootSCLFile;\n\n    private Document doc;\n\n    private Stack<Element> elements = new Stack<Element>();\n\n    private XPath xpath = XPathFactory.newInstance().newXPath();\n\n    private IncludeProcessor includeProcessor;\n\n    private static LocalReferenceProcessor localReferenceProcessor;\n\n    private List<LocalReference> localRefs = new ArrayList<LocalReference>();\n\n    private int namespaceSteps;\n\n    {\n        try {\n            doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n            Element rootElement = doc.createElement(SCL_ROOT_ELEMENT);\n            doc.appendChild(rootElement);\n            this.elements.push(rootElement);\n        } catch (ParserConfigurationException pce) {\n            pce.printStackTrace();\n        }\n    }\n\n    protected Element addChildElement(Element element, String child) {\n        Element childElement = this.doc.createElement(child);\n        element.appendChild(childElement);\n        return childElement;\n    }\n\n    protected Element addChildElements(Element currentElement, String compositePath) {\n        return processDotDelimitedPath(currentElement, compositePath);\n    }\n\n    protected void addAttribute(Element currentElement, String attributeName, String attributeValue) {\n        Element childElement = this.doc.createElement(attributeName);\n        childElement.setTextContent(attributeValue);\n        currentElement.appendChild(childElement);\n    }\n\n    protected void loadIncludeValue(Element parentElement, String propertyName, String includeLocation, String xPathExpression) throws IncludeException {\n        this.includeProcessor.prepareIncludeValue(parentElement, propertyName, includeLocation, this.rootSCLFile, xPathExpression);\n    }\n\n    protected void loadInclude(Element parentElement, String includeLocation) throws IncludeException {\n        this.includeProcessor.prepareInclude(parentElement, includeLocation, this.rootSCLFile);\n    }\n\n    protected void loadIncludeNodes(Element parentElement, String includeLocation, String xPathExpression) throws IncludeException {\n        this.includeProcessor.prepareInclude(parentElement, includeLocation, this.rootSCLFile, xPathExpression);\n    }\n\n    protected void loadUnparsedInclude(Element parentElement, String propertyName, String includeLocation) throws IncludeException {\n        this.includeProcessor.loadUnparsedInclude(parentElement, propertyName, includeLocation, this.rootSCLFile);\n    }\n\n    protected void prepareLocalRefTree(final Element parentElement, final String xPathExpression) {\n        LocalReference localRef = new LocalReference() {\n\n            {\n                setParentElement(parentElement);\n                setXPathQuery(xPathExpression);\n            }\n        };\n        this.localRefs.add(localRef);\n    }\n\n    protected void prepareLocalRef(final Element parentElement, final String attributeName, final String xPathExpression) {\n        LocalAttributeReference localRef = new LocalAttributeReference() {\n\n            {\n                setParentElement(parentElement);\n                setXPathQuery(xPathExpression);\n                setAttributeName(attributeName);\n            }\n        };\n        this.localRefs.add(localRef);\n    }\n\n    public void setRootSCLFile(URI rootSCLFile) {\n        this.rootSCLFile = rootSCLFile;\n    }\n\n    public URI getRootSCLFile() {\n        return this.rootSCLFile;\n    }\n\n    public Document getRootDocument() {\n        return this.doc;\n    }\n\n    public void setIncludeProcessor(IncludeProcessor includeProcessor) {\n        this.includeProcessor = includeProcessor;\n    }\n\n    public IncludeProcessor getIncludeProcessor() {\n        return this.includeProcessor;\n    }\n\n    public void setLocalReferenceProcessor(LocalReferenceProcessor processor) {\n        localReferenceProcessor = processor;\n    }\n\n    public LocalReferenceProcessor getLocalReferenceProcessor() {\n        return localReferenceProcessor;\n    }\n\n    public List<LocalReference> getLocalRefs() {\n        return this.localRefs;\n    }\n\n    public String sanitiseText(String rawText) {\n        String unquotedText = stripQuotes(rawText);\n        return normaliseEscapeChars(unquotedText);\n    }\n\n    private String stripQuotes(String quotedText) {\n        return quotedText.substring(1, quotedText.length() - 1);\n    }\n\n    private String normaliseEscapeChars(String text) {\n        return text.replace(\"\\\\\\\\\", \"\\\\\").replace(\"\\\\\\\"\", \"\\\"\");\n    }\n\n    // $ANTLR start \"scl\"\n    // net/sf/sugar/scl/SCL.g:152:1: scl returns [Document properties] : statementSeq ;\n    public final Document scl() throws RecognitionException {\n        Document properties = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:153:6: ( statementSeq )\n            // net/sf/sugar/scl/SCL.g:153:8: statementSeq\n            {\n                pushFollow(FOLLOW_statementSeq_in_scl44);\n                statementSeq();\n                state._fsp--;\n                try {\n                    this.includeProcessor.resolveIncludes(this.doc);\n                    localReferenceProcessor.processLocalReferences(this.localRefs);\n                } catch (IncludeException ie) {\n                    ie.printStackTrace();\n                } catch (LocalReferenceException lre) {\n                    lre.printStackTrace();\n                }\n                properties = doc;\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return properties;\n    }\n\n    // $ANTLR end \"scl\"\n    // $ANTLR start \"statementSeq\"\n    // net/sf/sugar/scl/SCL.g:168:1: statementSeq : ( statement )+ ;\n    public final void statementSeq() throws RecognitionException {\n        try {\n            // net/sf/sugar/scl/SCL.g:168:15: ( ( statement )+ )\n            // net/sf/sugar/scl/SCL.g:168:17: ( statement )+\n            {\n                // net/sf/sugar/scl/SCL.g:168:17: ( statement )+\n                int cnt1 = 0;\n                loop1: do {\n                    int alt1 = 2;\n                    switch(input.LA(1)) {\n                        case VALID_NAME_CHARS:\n                        case START_INCLUDE:\n                        case REF_CHAR:\n                            {\n                                alt1 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt1) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:168:17: statement\n                            {\n                                pushFollow(FOLLOW_statement_in_statementSeq61);\n                                statement();\n                                state._fsp--;\n                            }\n                            break;\n                        default:\n                            if (cnt1 >= 1)\n                                break loop1;\n                            EarlyExitException eee = new EarlyExitException(1, input);\n                            throw eee;\n                    }\n                    cnt1++;\n                } while (true);\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"statementSeq\"\n    // $ANTLR start \"statement\"\n    // net/sf/sugar/scl/SCL.g:170:1: statement : ( namespaceDecl | assignment | includeTree | t= localRefTree );\n    public final void statement() throws RecognitionException {\n        String t = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:170:13: ( namespaceDecl | assignment | includeTree | t= localRefTree )\n            int alt2 = 4;\n            alt2 = dfa2.predict(input);\n            switch(alt2) {\n                case 1:\n                    // net/sf/sugar/scl/SCL.g:170:15: namespaceDecl\n                    {\n                        pushFollow(FOLLOW_namespaceDecl_in_statement73);\n                        namespaceDecl();\n                        state._fsp--;\n                    }\n                    break;\n                case 2:\n                    // net/sf/sugar/scl/SCL.g:171:9: assignment\n                    {\n                        pushFollow(FOLLOW_assignment_in_statement84);\n                        assignment();\n                        state._fsp--;\n                    }\n                    break;\n                case 3:\n                    // net/sf/sugar/scl/SCL.g:172:9: includeTree\n                    {\n                        pushFollow(FOLLOW_includeTree_in_statement95);\n                        includeTree();\n                        state._fsp--;\n                    }\n                    break;\n                case 4:\n                    // net/sf/sugar/scl/SCL.g:173:9: t= localRefTree\n                    {\n                        pushFollow(FOLLOW_localRefTree_in_statement108);\n                        t = localRefTree();\n                        state._fsp--;\n                        prepareLocalRefTree(this.elements.peek(), t);\n                    }\n                    break;\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"statement\"\n    // $ANTLR start \"namespaceDecl\"\n    // net/sf/sugar/scl/SCL.g:177:1: namespaceDecl : namespaceName namespaceBody ;\n    public final void namespaceDecl() throws RecognitionException {\n        try {\n            // net/sf/sugar/scl/SCL.g:177:16: ( namespaceName namespaceBody )\n            // net/sf/sugar/scl/SCL.g:177:18: namespaceName namespaceBody\n            {\n                pushFollow(FOLLOW_namespaceName_in_namespaceDecl120);\n                namespaceName();\n                state._fsp--;\n                pushFollow(FOLLOW_namespaceBody_in_namespaceDecl122);\n                namespaceBody();\n                state._fsp--;\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"namespaceDecl\"\n    public static class namespaceName_return extends ParserRuleReturnScope {\n    }\n\n    // $ANTLR start \"namespaceName\"\n    // net/sf/sugar/scl/SCL.g:179:1: namespaceName : ( varName | compositeNamespaceName );\n    public final SCLParser.namespaceName_return namespaceName() throws RecognitionException {\n        SCLParser.namespaceName_return retval = new SCLParser.namespaceName_return();\n        retval.start = input.LT(1);\n        SCLParser.compositeNamespaceName_return compositeNamespaceName1 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:179:16: ( varName | compositeNamespaceName )\n            int alt3 = 2;\n            alt3 = dfa3.predict(input);\n            switch(alt3) {\n                case 1:\n                    // net/sf/sugar/scl/SCL.g:179:18: varName\n                    {\n                        pushFollow(FOLLOW_varName_in_namespaceName132);\n                        varName();\n                        state._fsp--;\n                        this.elements.push(addChildElement(this.elements.peek(), input.toString(retval.start, input.LT(-1))));\n                    }\n                    break;\n                case 2:\n                    // net/sf/sugar/scl/SCL.g:180:9: compositeNamespaceName\n                    {\n                        pushFollow(FOLLOW_compositeNamespaceName_in_namespaceName145);\n                        compositeNamespaceName1 = compositeNamespaceName();\n                        state._fsp--;\n                        this.elements.push(addChildElements(this.elements.peek(), (compositeNamespaceName1 != null ? input.toString(compositeNamespaceName1.start, compositeNamespaceName1.stop) : null)));\n                    }\n                    break;\n            }\n            retval.stop = input.LT(-1);\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return retval;\n    }\n\n    // $ANTLR end \"namespaceName\"\n    public static class compositeNamespaceName_return extends ParserRuleReturnScope {\n    }\n\n    // $ANTLR start \"compositeNamespaceName\"\n    // net/sf/sugar/scl/SCL.g:182:1: compositeNamespaceName : ( VALID_NAME_CHARS )+ ( '.' ( VALID_NAME_CHARS )+ )+ ;\n    public final SCLParser.compositeNamespaceName_return compositeNamespaceName() throws RecognitionException {\n        SCLParser.compositeNamespaceName_return retval = new SCLParser.compositeNamespaceName_return();\n        retval.start = input.LT(1);\n        try {\n            // net/sf/sugar/scl/SCL.g:182:24: ( ( VALID_NAME_CHARS )+ ( '.' ( VALID_NAME_CHARS )+ )+ )\n            // net/sf/sugar/scl/SCL.g:182:28: ( VALID_NAME_CHARS )+ ( '.' ( VALID_NAME_CHARS )+ )+\n            {\n                // net/sf/sugar/scl/SCL.g:182:28: ( VALID_NAME_CHARS )+\n                int cnt4 = 0;\n                loop4: do {\n                    int alt4 = 2;\n                    switch(input.LA(1)) {\n                        case VALID_NAME_CHARS:\n                            {\n                                alt4 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt4) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:182:28: VALID_NAME_CHARS\n                            {\n                                match(input, VALID_NAME_CHARS, FOLLOW_VALID_NAME_CHARS_in_compositeNamespaceName160);\n                            }\n                            break;\n                        default:\n                            if (cnt4 >= 1)\n                                break loop4;\n                            EarlyExitException eee = new EarlyExitException(4, input);\n                            throw eee;\n                    }\n                    cnt4++;\n                } while (true);\n                // net/sf/sugar/scl/SCL.g:182:46: ( '.' ( VALID_NAME_CHARS )+ )+\n                int cnt6 = 0;\n                loop6: do {\n                    int alt6 = 2;\n                    switch(input.LA(1)) {\n                        case 19:\n                            {\n                                alt6 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt6) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:182:47: '.' ( VALID_NAME_CHARS )+\n                            {\n                                match(input, 19, FOLLOW_19_in_compositeNamespaceName164);\n                                // net/sf/sugar/scl/SCL.g:182:51: ( VALID_NAME_CHARS )+\n                                int cnt5 = 0;\n                                loop5: do {\n                                    int alt5 = 2;\n                                    switch(input.LA(1)) {\n                                        case VALID_NAME_CHARS:\n                                            {\n                                                alt5 = 1;\n                                            }\n                                            break;\n                                    }\n                                    switch(alt5) {\n                                        case 1:\n                                            // net/sf/sugar/scl/SCL.g:182:51: VALID_NAME_CHARS\n                                            {\n                                                match(input, VALID_NAME_CHARS, FOLLOW_VALID_NAME_CHARS_in_compositeNamespaceName166);\n                                            }\n                                            break;\n                                        default:\n                                            if (cnt5 >= 1)\n                                                break loop5;\n                                            EarlyExitException eee = new EarlyExitException(5, input);\n                                            throw eee;\n                                    }\n                                    cnt5++;\n                                } while (true);\n                            }\n                            break;\n                        default:\n                            if (cnt6 >= 1)\n                                break loop6;\n                            EarlyExitException eee = new EarlyExitException(6, input);\n                            throw eee;\n                    }\n                    cnt6++;\n                } while (true);\n            }\n            retval.stop = input.LT(-1);\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return retval;\n    }\n\n    // $ANTLR end \"compositeNamespaceName\"\n    // $ANTLR start \"namespaceBody\"\n    // net/sf/sugar/scl/SCL.g:184:1: namespaceBody : OPEN_NESTING ( statement )* CLOSE_NESTING ;\n    public final void namespaceBody() throws RecognitionException {\n        try {\n            // net/sf/sugar/scl/SCL.g:184:16: ( OPEN_NESTING ( statement )* CLOSE_NESTING )\n            // net/sf/sugar/scl/SCL.g:184:18: OPEN_NESTING ( statement )* CLOSE_NESTING\n            {\n                match(input, OPEN_NESTING, FOLLOW_OPEN_NESTING_in_namespaceBody181);\n                // net/sf/sugar/scl/SCL.g:184:31: ( statement )*\n                loop7: do {\n                    int alt7 = 2;\n                    switch(input.LA(1)) {\n                        case VALID_NAME_CHARS:\n                        case START_INCLUDE:\n                        case REF_CHAR:\n                            {\n                                alt7 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt7) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:184:32: statement\n                            {\n                                pushFollow(FOLLOW_statement_in_namespaceBody184);\n                                statement();\n                                state._fsp--;\n                            }\n                            break;\n                        default:\n                            break loop7;\n                    }\n                } while (true);\n                match(input, CLOSE_NESTING, FOLLOW_CLOSE_NESTING_in_namespaceBody188);\n                this.elements.pop();\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"namespaceBody\"\n    // $ANTLR start \"assignment\"\n    // net/sf/sugar/scl/SCL.g:188:1: assignment : varName ASSIGNMENT_OP ( varValue | includeValue | v= unparsedIncludeValue | r= localReference ) ;\n    public final void assignment() throws RecognitionException {\n        String v = null;\n        String r = null;\n        SCLParser.varName_return varName2 = null;\n        SCLParser.varValue_return varValue3 = null;\n        SCLParser.includeValue_return includeValue4 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:188:14: ( varName ASSIGNMENT_OP ( varValue | includeValue | v= unparsedIncludeValue | r= localReference ) )\n            // net/sf/sugar/scl/SCL.g:188:16: varName ASSIGNMENT_OP ( varValue | includeValue | v= unparsedIncludeValue | r= localReference )\n            {\n                pushFollow(FOLLOW_varName_in_assignment201);\n                varName2 = varName();\n                state._fsp--;\n                match(input, ASSIGNMENT_OP, FOLLOW_ASSIGNMENT_OP_in_assignment203);\n                // net/sf/sugar/scl/SCL.g:188:38: ( varValue | includeValue | v= unparsedIncludeValue | r= localReference )\n                int alt8 = 4;\n                switch(input.LA(1)) {\n                    case STRING_LITERAL:\n                        {\n                            alt8 = 1;\n                        }\n                        break;\n                    case START_INCLUDE:\n                        {\n                            alt8 = 2;\n                        }\n                        break;\n                    case START_UNPARSED_INCLUDE:\n                        {\n                            alt8 = 3;\n                        }\n                        break;\n                    case REF_CHAR:\n                        {\n                            alt8 = 4;\n                        }\n                        break;\n                    default:\n                        NoViableAltException nvae = new NoViableAltException(\"\", 8, 0, input);\n                        throw nvae;\n                }\n                switch(alt8) {\n                    case 1:\n                        // net/sf/sugar/scl/SCL.g:188:39: varValue\n                        {\n                            pushFollow(FOLLOW_varValue_in_assignment206);\n                            varValue3 = varValue();\n                            state._fsp--;\n                            addAttribute(this.elements.peek(), (varName2 != null ? input.toString(varName2.start, varName2.stop) : null), sanitiseText((varValue3 != null ? input.toString(varValue3.start, varValue3.stop) : null)));\n                        }\n                        break;\n                    case 2:\n                        // net/sf/sugar/scl/SCL.g:194:14: includeValue\n                        {\n                            pushFollow(FOLLOW_includeValue_in_assignment230);\n                            includeValue4 = includeValue();\n                            state._fsp--;\n                            try {\n                                this.loadIncludeValue(this.elements.peek(), (varName2 != null ? input.toString(varName2.start, varName2.stop) : null), sanitiseText((includeValue4 != null ? includeValue4.includeLocation : null)), sanitiseText((includeValue4 != null ? includeValue4.xPathQuery : null)));\n                            } catch (IncludeException ie) {\n                                ie.printStackTrace();\n                                System.out.println(ie);\n                            }\n                        }\n                        break;\n                    case 3:\n                        // net/sf/sugar/scl/SCL.g:205:12: v= unparsedIncludeValue\n                        {\n                            pushFollow(FOLLOW_unparsedIncludeValue_in_assignment247);\n                            v = unparsedIncludeValue();\n                            state._fsp--;\n                            try {\n                                this.loadUnparsedInclude(this.elements.peek(), (varName2 != null ? input.toString(varName2.start, varName2.stop) : null), v);\n                            } catch (IncludeException ie) {\n                                ie.printStackTrace();\n                            }\n                        }\n                        break;\n                    case 4:\n                        // net/sf/sugar/scl/SCL.g:212:15: r= localReference\n                        {\n                            pushFollow(FOLLOW_localReference_in_assignment267);\n                            r = localReference();\n                            state._fsp--;\n                            //todo : handle empty values, also handle non numeric, date and boolean return types\n                            prepareLocalRef(this.elements.peek(), (varName2 != null ? input.toString(varName2.start, varName2.stop) : null), r);\n                        }\n                        break;\n                }\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"assignment\"\n    public static class varName_return extends ParserRuleReturnScope {\n    }\n\n    // $ANTLR start \"varName\"\n    // net/sf/sugar/scl/SCL.g:218:1: varName : ( VALID_NAME_CHARS )+ ;\n    public final SCLParser.varName_return varName() throws RecognitionException {\n        SCLParser.varName_return retval = new SCLParser.varName_return();\n        retval.start = input.LT(1);\n        try {\n            // net/sf/sugar/scl/SCL.g:218:12: ( ( VALID_NAME_CHARS )+ )\n            // net/sf/sugar/scl/SCL.g:218:14: ( VALID_NAME_CHARS )+\n            {\n                // net/sf/sugar/scl/SCL.g:218:14: ( VALID_NAME_CHARS )+\n                int cnt9 = 0;\n                loop9: do {\n                    int alt9 = 2;\n                    switch(input.LA(1)) {\n                        case VALID_NAME_CHARS:\n                            {\n                                alt9 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt9) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:218:14: VALID_NAME_CHARS\n                            {\n                                match(input, VALID_NAME_CHARS, FOLLOW_VALID_NAME_CHARS_in_varName298);\n                            }\n                            break;\n                        default:\n                            if (cnt9 >= 1)\n                                break loop9;\n                            EarlyExitException eee = new EarlyExitException(9, input);\n                            throw eee;\n                    }\n                    cnt9++;\n                } while (true);\n            }\n            retval.stop = input.LT(-1);\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return retval;\n    }\n\n    // $ANTLR end \"varName\"\n    public static class varValue_return extends ParserRuleReturnScope {\n    }\n\n    // $ANTLR start \"varValue\"\n    // net/sf/sugar/scl/SCL.g:220:1: varValue : STRING_LITERAL ;\n    public final SCLParser.varValue_return varValue() throws RecognitionException {\n        SCLParser.varValue_return retval = new SCLParser.varValue_return();\n        retval.start = input.LT(1);\n        try {\n            // net/sf/sugar/scl/SCL.g:220:13: ( STRING_LITERAL )\n            // net/sf/sugar/scl/SCL.g:220:15: STRING_LITERAL\n            {\n                match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_varValue312);\n            }\n            retval.stop = input.LT(-1);\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return retval;\n    }\n\n    // $ANTLR end \"varValue\"\n    public static class includeValue_return extends ParserRuleReturnScope {\n\n        public String includeLocation;\n\n        public String xPathQuery;\n    }\n\n    // $ANTLR start \"includeValue\"\n    // net/sf/sugar/scl/SCL.g:223:1: includeValue returns [String includeLocation, String xPathQuery] : START_INCLUDE s1= STRING_LITERAL AS_KEYWORD s2= STRING_LITERAL END_INCLUDE ;\n    public final SCLParser.includeValue_return includeValue() throws RecognitionException {\n        SCLParser.includeValue_return retval = new SCLParser.includeValue_return();\n        retval.start = input.LT(1);\n        Token s1 = null;\n        Token s2 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:224:6: ( START_INCLUDE s1= STRING_LITERAL AS_KEYWORD s2= STRING_LITERAL END_INCLUDE )\n            // net/sf/sugar/scl/SCL.g:224:8: START_INCLUDE s1= STRING_LITERAL AS_KEYWORD s2= STRING_LITERAL END_INCLUDE\n            {\n                match(input, START_INCLUDE, FOLLOW_START_INCLUDE_in_includeValue334);\n                s1 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_includeValue338);\n                match(input, AS_KEYWORD, FOLLOW_AS_KEYWORD_in_includeValue340);\n                s2 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_includeValue344);\n                match(input, END_INCLUDE, FOLLOW_END_INCLUDE_in_includeValue346);\n                retval.includeLocation = (s1 != null ? s1.getText() : null);\n                retval.xPathQuery = (s2 != null ? s2.getText() : null);\n            }\n            retval.stop = input.LT(-1);\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return retval;\n    }\n\n    // $ANTLR end \"includeValue\"\n    // $ANTLR start \"unparsedIncludeValue\"\n    // net/sf/sugar/scl/SCL.g:229:1: unparsedIncludeValue returns [String includeLocation] : START_UNPARSED_INCLUDE s1= STRING_LITERAL END_INCLUDE ;\n    public final String unparsedIncludeValue() throws RecognitionException {\n        String includeLocation = null;\n        Token s1 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:230:6: ( START_UNPARSED_INCLUDE s1= STRING_LITERAL END_INCLUDE )\n            // net/sf/sugar/scl/SCL.g:230:8: START_UNPARSED_INCLUDE s1= STRING_LITERAL END_INCLUDE\n            {\n                match(input, START_UNPARSED_INCLUDE, FOLLOW_START_UNPARSED_INCLUDE_in_unparsedIncludeValue373);\n                s1 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_unparsedIncludeValue377);\n                match(input, END_INCLUDE, FOLLOW_END_INCLUDE_in_unparsedIncludeValue379);\n                includeLocation = stripQuotes(s1.getText());\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return includeLocation;\n    }\n\n    // $ANTLR end \"unparsedIncludeValue\"\n    // $ANTLR start \"includeTree\"\n    // net/sf/sugar/scl/SCL.g:234:1: includeTree : START_INCLUDE s1= STRING_LITERAL ( AS_KEYWORD s2= STRING_LITERAL )? END_INCLUDE ;\n    public final void includeTree() throws RecognitionException {\n        Token s1 = null;\n        Token s2 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:234:15: ( START_INCLUDE s1= STRING_LITERAL ( AS_KEYWORD s2= STRING_LITERAL )? END_INCLUDE )\n            // net/sf/sugar/scl/SCL.g:234:17: START_INCLUDE s1= STRING_LITERAL ( AS_KEYWORD s2= STRING_LITERAL )? END_INCLUDE\n            {\n                match(input, START_INCLUDE, FOLLOW_START_INCLUDE_in_includeTree399);\n                s1 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_includeTree403);\n                // net/sf/sugar/scl/SCL.g:234:49: ( AS_KEYWORD s2= STRING_LITERAL )?\n                int alt10 = 2;\n                switch(input.LA(1)) {\n                    case AS_KEYWORD:\n                        {\n                            alt10 = 1;\n                        }\n                        break;\n                }\n                switch(alt10) {\n                    case 1:\n                        // net/sf/sugar/scl/SCL.g:234:50: AS_KEYWORD s2= STRING_LITERAL\n                        {\n                            match(input, AS_KEYWORD, FOLLOW_AS_KEYWORD_in_includeTree406);\n                            s2 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_includeTree410);\n                        }\n                        break;\n                }\n                match(input, END_INCLUDE, FOLLOW_END_INCLUDE_in_includeTree414);\n                try {\n                    if (s2 == null || \"\".equals(s2)) {\n                        this.loadInclude(this.elements.peek(), sanitiseText(s1.getText()));\n                    } else {\n                        this.loadIncludeNodes(this.elements.peek(), sanitiseText(s1.getText()), sanitiseText(s2.getText()));\n                    }\n                } catch (IncludeException ie) {\n                    ie.printStackTrace();\n                }\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"includeTree\"\n    // $ANTLR start \"localRefTree\"\n    // net/sf/sugar/scl/SCL.g:250:1: localRefTree returns [String xPathQuery] : r= localReference ;\n    public final String localRefTree() throws RecognitionException {\n        String xPathQuery = null;\n        String r = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:251:7: (r= localReference )\n            // net/sf/sugar/scl/SCL.g:251:10: r= localReference\n            {\n                pushFollow(FOLLOW_localReference_in_localRefTree442);\n                r = localReference();\n                state._fsp--;\n                xPathQuery = r;\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return xPathQuery;\n    }\n\n    // $ANTLR end \"localRefTree\"\n    // $ANTLR start \"localReference\"\n    // net/sf/sugar/scl/SCL.g:253:1: localReference returns [String resolvedValue] : REF_CHAR ( WS )* STRING_LITERAL ;\n    public final String localReference() throws RecognitionException {\n        String resolvedValue = null;\n        Token STRING_LITERAL5 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:254:7: ( REF_CHAR ( WS )* STRING_LITERAL )\n            // net/sf/sugar/scl/SCL.g:254:10: REF_CHAR ( WS )* STRING_LITERAL\n            {\n                match(input, REF_CHAR, FOLLOW_REF_CHAR_in_localReference475);\n                // net/sf/sugar/scl/SCL.g:254:19: ( WS )*\n                loop11: do {\n                    int alt11 = 2;\n                    switch(input.LA(1)) {\n                        case WS:\n                            {\n                                alt11 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt11) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:254:19: WS\n                            {\n                                match(input, WS, FOLLOW_WS_in_localReference477);\n                            }\n                            break;\n                        default:\n                            break loop11;\n                    }\n                } while (true);\n                STRING_LITERAL5 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_localReference480);\n                resolvedValue = sanitiseText((STRING_LITERAL5 != null ? STRING_LITERAL5.getText() : null));\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return resolvedValue;\n    }\n\n    // $ANTLR end \"localReference\"\n    // Delegated rules\n    protected DFA2 dfa2 = new DFA2(this);\n\n    protected DFA3 dfa3 = new DFA3(this);\n\n    static final String DFA2_eotS = \"\\6\\uffff\";\n\n    static final String DFA2_eofS = \"\\6\\uffff\";\n\n    static final String DFA2_minS = \"\\2\\4\\4\\uffff\";\n\n    static final String DFA2_maxS = \"\\1\\15\\1\\23\\4\\uffff\";\n\n    static final String DFA2_acceptS = \"\\2\\uffff\\1\\3\\1\\4\\1\\1\\1\\2\";\n\n    static final String DFA2_specialS = \"\\6\\uffff}>\";\n\n    static final String[] DFA2_transitionS = { \"\\1\\1\\4\\uffff\\1\\2\\3\\uffff\\1\\3\", \"\\1\\1\\1\\4\\1\\uffff\\1\\5\\13\\uffff\\1\\4\", \"\", \"\", \"\", \"\" };\n\n    static final short[] DFA2_eot = DFA.unpackEncodedString(DFA2_eotS);\n\n    static final short[] DFA2_eof = DFA.unpackEncodedString(DFA2_eofS);\n\n    static final char[] DFA2_min = DFA.unpackEncodedStringToUnsignedChars(DFA2_minS);\n\n    static final char[] DFA2_max = DFA.unpackEncodedStringToUnsignedChars(DFA2_maxS);\n\n    static final short[] DFA2_accept = DFA.unpackEncodedString(DFA2_acceptS);\n\n    static final short[] DFA2_special = DFA.unpackEncodedString(DFA2_specialS);\n\n    static final short[][] DFA2_transition;\n\n    static {\n        int numStates = DFA2_transitionS.length;\n        DFA2_transition = new short[numStates][];\n        for (int i = 0; i < numStates; i++) {\n            DFA2_transition[i] = DFA.unpackEncodedString(DFA2_transitionS[i]);\n        }\n    }\n\n    class DFA2 extends DFA {\n\n        public DFA2(BaseRecognizer recognizer) {\n            this.recognizer = recognizer;\n            this.decisionNumber = 2;\n            this.eot = DFA2_eot;\n            this.eof = DFA2_eof;\n            this.min = DFA2_min;\n            this.max = DFA2_max;\n            this.accept = DFA2_accept;\n            this.special = DFA2_special;\n            this.transition = DFA2_transition;\n        }\n\n        public String getDescription() {\n            return \"170:1: statement : ( namespaceDecl | assignment | includeTree | t= localRefTree );\";\n        }\n    }\n\n    static final String DFA3_eotS = \"\\4\\uffff\";\n\n    static final String DFA3_eofS = \"\\4\\uffff\";\n\n    static final String DFA3_minS = \"\\2\\4\\2\\uffff\";\n\n    static final String DFA3_maxS = \"\\1\\4\\1\\23\\2\\uffff\";\n\n    static final String DFA3_acceptS = \"\\2\\uffff\\1\\1\\1\\2\";\n\n    static final String DFA3_specialS = \"\\4\\uffff}>\";\n\n    static final String[] DFA3_transitionS = { \"\\1\\1\", \"\\1\\1\\1\\2\\15\\uffff\\1\\3\", \"\", \"\" };\n\n    static final short[] DFA3_eot = DFA.unpackEncodedString(DFA3_eotS);\n\n    static final short[] DFA3_eof = DFA.unpackEncodedString(DFA3_eofS);\n\n    static final char[] DFA3_min = DFA.unpackEncodedStringToUnsignedChars(DFA3_minS);\n\n    static final char[] DFA3_max = DFA.unpackEncodedStringToUnsignedChars(DFA3_maxS);\n\n    static final short[] DFA3_accept = DFA.unpackEncodedString(DFA3_acceptS);\n\n    static final short[] DFA3_special = DFA.unpackEncodedString(DFA3_specialS);\n\n    static final short[][] DFA3_transition;\n\n    static {\n        int numStates = DFA3_transitionS.length;\n        DFA3_transition = new short[numStates][];\n        for (int i = 0; i < numStates; i++) {\n            DFA3_transition[i] = DFA.unpackEncodedString(DFA3_transitionS[i]);\n        }\n    }\n\n    class DFA3 extends DFA {\n\n        public DFA3(BaseRecognizer recognizer) {\n            this.recognizer = recognizer;\n            this.decisionNumber = 3;\n            this.eot = DFA3_eot;\n            this.eof = DFA3_eof;\n            this.min = DFA3_min;\n            this.max = DFA3_max;\n            this.accept = DFA3_accept;\n            this.special = DFA3_special;\n            this.transition = DFA3_transition;\n        }\n\n        public String getDescription() {\n            return \"179:1: namespaceName : ( varName | compositeNamespaceName );\";\n        }\n    }\n\n    public static final BitSet FOLLOW_statementSeq_in_scl44 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_statement_in_statementSeq61 = new BitSet(new long[] { 0x0000000000002212L });\n\n    public static final BitSet FOLLOW_namespaceDecl_in_statement73 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_assignment_in_statement84 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_includeTree_in_statement95 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_localRefTree_in_statement108 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_namespaceName_in_namespaceDecl120 = new BitSet(new long[] { 0x0000000000000020L });\n\n    public static final BitSet FOLLOW_namespaceBody_in_namespaceDecl122 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_varName_in_namespaceName132 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_compositeNamespaceName_in_namespaceName145 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_VALID_NAME_CHARS_in_compositeNamespaceName160 = new BitSet(new long[] { 0x0000000000080010L });\n\n    public static final BitSet FOLLOW_19_in_compositeNamespaceName164 = new BitSet(new long[] { 0x0000000000000010L });\n\n    public static final BitSet FOLLOW_VALID_NAME_CHARS_in_compositeNamespaceName166 = new BitSet(new long[] { 0x0000000000080012L });\n\n    public static final BitSet FOLLOW_OPEN_NESTING_in_namespaceBody181 = new BitSet(new long[] { 0x0000000000002250L });\n\n    public static final BitSet FOLLOW_statement_in_namespaceBody184 = new BitSet(new long[] { 0x0000000000002250L });\n\n    public static final BitSet FOLLOW_CLOSE_NESTING_in_namespaceBody188 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_varName_in_assignment201 = new BitSet(new long[] { 0x0000000000000080L });\n\n    public static final BitSet FOLLOW_ASSIGNMENT_OP_in_assignment203 = new BitSet(new long[] { 0x0000000000003310L });\n\n    public static final BitSet FOLLOW_varValue_in_assignment206 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_includeValue_in_assignment230 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_unparsedIncludeValue_in_assignment247 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_localReference_in_assignment267 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_VALID_NAME_CHARS_in_varName298 = new BitSet(new long[] { 0x0000000000000012L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_varValue312 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_START_INCLUDE_in_includeValue334 = new BitSet(new long[] { 0x0000000000000100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_includeValue338 = new BitSet(new long[] { 0x0000000000000400L });\n\n    public static final BitSet FOLLOW_AS_KEYWORD_in_includeValue340 = new BitSet(new long[] { 0x0000000000000100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_includeValue344 = new BitSet(new long[] { 0x0000000000000800L });\n\n    public static final BitSet FOLLOW_END_INCLUDE_in_includeValue346 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_START_UNPARSED_INCLUDE_in_unparsedIncludeValue373 = new BitSet(new long[] { 0x0000000000000100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_unparsedIncludeValue377 = new BitSet(new long[] { 0x0000000000000800L });\n\n    public static final BitSet FOLLOW_END_INCLUDE_in_unparsedIncludeValue379 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_START_INCLUDE_in_includeTree399 = new BitSet(new long[] { 0x0000000000000100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_includeTree403 = new BitSet(new long[] { 0x0000000000000C00L });\n\n    public static final BitSet FOLLOW_AS_KEYWORD_in_includeTree406 = new BitSet(new long[] { 0x0000000000000100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_includeTree410 = new BitSet(new long[] { 0x0000000000000800L });\n\n    public static final BitSet FOLLOW_END_INCLUDE_in_includeTree414 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_localReference_in_localRefTree442 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_REF_CHAR_in_localReference475 = new BitSet(new long[] { 0x0000000000004100L });\n\n    public static final BitSet FOLLOW_WS_in_localReference477 = new BitSet(new long[] { 0x0000000000004100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_localReference480 = new BitSet(new long[] { 0x0000000000000002L });\n}\n",
		"id": "/EvoSuiteBenchmark/60_sugar/src/main/java/net/sf/sugar/scl/SCLParser_1Test.java",
		"test_prompt": "// SCLParser_1Test.java\npackage net.sf.sugar.scl;\n\nimport static net.sf.sugar.scl.PathConversionUtils.convertToXPath;\nimport static net.sf.sugar.scl.PathConversionUtils.processDotDelimitedPath;\nimport java.net.URI;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Element;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathFactory;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpressionException;\nimport org.antlr.runtime.*;\nimport java.util.Stack;\nimport java.util.List;\nimport java.util.ArrayList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SCLParser}.\n* It contains ten unit test cases for the {@link SCLParser#scl()} method.\n*/\nclass SCLParser_1Test {"
	},
	{
		"original_code": "// SCLParser.java\n// $ANTLR 3.3 Nov 30, 2010 12:46:29 net/sf/sugar/scl/SCL.g 2013-06-10 17:15:03\npackage net.sf.sugar.scl;\n\nimport static net.sf.sugar.scl.PathConversionUtils.convertToXPath;\nimport static net.sf.sugar.scl.PathConversionUtils.processDotDelimitedPath;\nimport java.net.URI;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Element;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathFactory;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpressionException;\nimport org.antlr.runtime.*;\nimport java.util.Stack;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class SCLParser extends Parser {\n\n    public static final String[] tokenNames = new String[] { \"<invalid>\", \"<EOR>\", \"<DOWN>\", \"<UP>\", \"VALID_NAME_CHARS\", \"OPEN_NESTING\", \"CLOSE_NESTING\", \"ASSIGNMENT_OP\", \"STRING_LITERAL\", \"START_INCLUDE\", \"AS_KEYWORD\", \"END_INCLUDE\", \"START_UNPARSED_INCLUDE\", \"REF_CHAR\", \"WS\", \"QUOTE\", \"STRING_SEQUENCE_CHAR\", \"COMMENT\", \"LINE_COMMENT\", \"'.'\" };\n\n    public static final int EOF = -1;\n\n    public static final int T__19 = 19;\n\n    public static final int VALID_NAME_CHARS = 4;\n\n    public static final int OPEN_NESTING = 5;\n\n    public static final int CLOSE_NESTING = 6;\n\n    public static final int ASSIGNMENT_OP = 7;\n\n    public static final int STRING_LITERAL = 8;\n\n    public static final int START_INCLUDE = 9;\n\n    public static final int AS_KEYWORD = 10;\n\n    public static final int END_INCLUDE = 11;\n\n    public static final int START_UNPARSED_INCLUDE = 12;\n\n    public static final int REF_CHAR = 13;\n\n    public static final int WS = 14;\n\n    public static final int QUOTE = 15;\n\n    public static final int STRING_SEQUENCE_CHAR = 16;\n\n    public static final int COMMENT = 17;\n\n    public static final int LINE_COMMENT = 18;\n\n    // delegates\n    // delegators\n    public SCLParser(TokenStream input) {\n        this(input, new RecognizerSharedState());\n    }\n\n    public SCLParser(TokenStream input, RecognizerSharedState state) {\n        super(input, state);\n    }\n\n    public String[] getTokenNames() {\n        return SCLParser.tokenNames;\n    }\n\n    public String getGrammarFileName() {\n        return \"net/sf/sugar/scl/SCL.g\";\n    }\n\n    public static final String SCL_ROOT_ELEMENT = \"scl\";\n\n    private URI rootSCLFile;\n\n    private Document doc;\n\n    private Stack<Element> elements = new Stack<Element>();\n\n    private XPath xpath = XPathFactory.newInstance().newXPath();\n\n    private IncludeProcessor includeProcessor;\n\n    private static LocalReferenceProcessor localReferenceProcessor;\n\n    private List<LocalReference> localRefs = new ArrayList<LocalReference>();\n\n    private int namespaceSteps;\n\n    {\n        try {\n            doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n            Element rootElement = doc.createElement(SCL_ROOT_ELEMENT);\n            doc.appendChild(rootElement);\n            this.elements.push(rootElement);\n        } catch (ParserConfigurationException pce) {\n            pce.printStackTrace();\n        }\n    }\n\n    protected Element addChildElement(Element element, String child) {\n        Element childElement = this.doc.createElement(child);\n        element.appendChild(childElement);\n        return childElement;\n    }\n\n    protected Element addChildElements(Element currentElement, String compositePath) {\n        return processDotDelimitedPath(currentElement, compositePath);\n    }\n\n    protected void addAttribute(Element currentElement, String attributeName, String attributeValue) {\n        Element childElement = this.doc.createElement(attributeName);\n        childElement.setTextContent(attributeValue);\n        currentElement.appendChild(childElement);\n    }\n\n    protected void loadIncludeValue(Element parentElement, String propertyName, String includeLocation, String xPathExpression) throws IncludeException {\n        this.includeProcessor.prepareIncludeValue(parentElement, propertyName, includeLocation, this.rootSCLFile, xPathExpression);\n    }\n\n    protected void loadInclude(Element parentElement, String includeLocation) throws IncludeException {\n        this.includeProcessor.prepareInclude(parentElement, includeLocation, this.rootSCLFile);\n    }\n\n    protected void loadIncludeNodes(Element parentElement, String includeLocation, String xPathExpression) throws IncludeException {\n        this.includeProcessor.prepareInclude(parentElement, includeLocation, this.rootSCLFile, xPathExpression);\n    }\n\n    protected void loadUnparsedInclude(Element parentElement, String propertyName, String includeLocation) throws IncludeException {\n        this.includeProcessor.loadUnparsedInclude(parentElement, propertyName, includeLocation, this.rootSCLFile);\n    }\n\n    protected void prepareLocalRefTree(final Element parentElement, final String xPathExpression) {\n        LocalReference localRef = new LocalReference() {\n\n            {\n                setParentElement(parentElement);\n                setXPathQuery(xPathExpression);\n            }\n        };\n        this.localRefs.add(localRef);\n    }\n\n    protected void prepareLocalRef(final Element parentElement, final String attributeName, final String xPathExpression) {\n        LocalAttributeReference localRef = new LocalAttributeReference() {\n\n            {\n                setParentElement(parentElement);\n                setXPathQuery(xPathExpression);\n                setAttributeName(attributeName);\n            }\n        };\n        this.localRefs.add(localRef);\n    }\n\n    public void setRootSCLFile(URI rootSCLFile) {\n        this.rootSCLFile = rootSCLFile;\n    }\n\n    public URI getRootSCLFile() {\n        return this.rootSCLFile;\n    }\n\n    public Document getRootDocument() {\n        return this.doc;\n    }\n\n    public void setIncludeProcessor(IncludeProcessor includeProcessor) {\n        this.includeProcessor = includeProcessor;\n    }\n\n    public IncludeProcessor getIncludeProcessor() {\n        return this.includeProcessor;\n    }\n\n    public void setLocalReferenceProcessor(LocalReferenceProcessor processor) {\n        localReferenceProcessor = processor;\n    }\n\n    public LocalReferenceProcessor getLocalReferenceProcessor() {\n        return localReferenceProcessor;\n    }\n\n    public List<LocalReference> getLocalRefs() {\n        return this.localRefs;\n    }\n\n    public String sanitiseText(String rawText) {\n        String unquotedText = stripQuotes(rawText);\n        return normaliseEscapeChars(unquotedText);\n    }\n\n    private String stripQuotes(String quotedText) {\n        return quotedText.substring(1, quotedText.length() - 1);\n    }\n\n    private String normaliseEscapeChars(String text) {\n        return text.replace(\"\\\\\\\\\", \"\\\\\").replace(\"\\\\\\\"\", \"\\\"\");\n    }\n\n    // $ANTLR start \"scl\"\n    // net/sf/sugar/scl/SCL.g:152:1: scl returns [Document properties] : statementSeq ;\n    public final Document scl() throws RecognitionException {\n        Document properties = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:153:6: ( statementSeq )\n            // net/sf/sugar/scl/SCL.g:153:8: statementSeq\n            {\n                pushFollow(FOLLOW_statementSeq_in_scl44);\n                statementSeq();\n                state._fsp--;\n                try {\n                    this.includeProcessor.resolveIncludes(this.doc);\n                    localReferenceProcessor.processLocalReferences(this.localRefs);\n                } catch (IncludeException ie) {\n                    ie.printStackTrace();\n                } catch (LocalReferenceException lre) {\n                    lre.printStackTrace();\n                }\n                properties = doc;\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return properties;\n    }\n\n    // $ANTLR end \"scl\"\n    // $ANTLR start \"statementSeq\"\n    // net/sf/sugar/scl/SCL.g:168:1: statementSeq : ( statement )+ ;\n    public final void statementSeq() throws RecognitionException {\n        try {\n            // net/sf/sugar/scl/SCL.g:168:15: ( ( statement )+ )\n            // net/sf/sugar/scl/SCL.g:168:17: ( statement )+\n            {\n                // net/sf/sugar/scl/SCL.g:168:17: ( statement )+\n                int cnt1 = 0;\n                loop1: do {\n                    int alt1 = 2;\n                    switch(input.LA(1)) {\n                        case VALID_NAME_CHARS:\n                        case START_INCLUDE:\n                        case REF_CHAR:\n                            {\n                                alt1 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt1) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:168:17: statement\n                            {\n                                pushFollow(FOLLOW_statement_in_statementSeq61);\n                                statement();\n                                state._fsp--;\n                            }\n                            break;\n                        default:\n                            if (cnt1 >= 1)\n                                break loop1;\n                            EarlyExitException eee = new EarlyExitException(1, input);\n                            throw eee;\n                    }\n                    cnt1++;\n                } while (true);\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"statementSeq\"\n    // $ANTLR start \"statement\"\n    // net/sf/sugar/scl/SCL.g:170:1: statement : ( namespaceDecl | assignment | includeTree | t= localRefTree );\n    public final void statement() throws RecognitionException {\n        String t = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:170:13: ( namespaceDecl | assignment | includeTree | t= localRefTree )\n            int alt2 = 4;\n            alt2 = dfa2.predict(input);\n            switch(alt2) {\n                case 1:\n                    // net/sf/sugar/scl/SCL.g:170:15: namespaceDecl\n                    {\n                        pushFollow(FOLLOW_namespaceDecl_in_statement73);\n                        namespaceDecl();\n                        state._fsp--;\n                    }\n                    break;\n                case 2:\n                    // net/sf/sugar/scl/SCL.g:171:9: assignment\n                    {\n                        pushFollow(FOLLOW_assignment_in_statement84);\n                        assignment();\n                        state._fsp--;\n                    }\n                    break;\n                case 3:\n                    // net/sf/sugar/scl/SCL.g:172:9: includeTree\n                    {\n                        pushFollow(FOLLOW_includeTree_in_statement95);\n                        includeTree();\n                        state._fsp--;\n                    }\n                    break;\n                case 4:\n                    // net/sf/sugar/scl/SCL.g:173:9: t= localRefTree\n                    {\n                        pushFollow(FOLLOW_localRefTree_in_statement108);\n                        t = localRefTree();\n                        state._fsp--;\n                        prepareLocalRefTree(this.elements.peek(), t);\n                    }\n                    break;\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"statement\"\n    // $ANTLR start \"namespaceDecl\"\n    // net/sf/sugar/scl/SCL.g:177:1: namespaceDecl : namespaceName namespaceBody ;\n    public final void namespaceDecl() throws RecognitionException {\n        try {\n            // net/sf/sugar/scl/SCL.g:177:16: ( namespaceName namespaceBody )\n            // net/sf/sugar/scl/SCL.g:177:18: namespaceName namespaceBody\n            {\n                pushFollow(FOLLOW_namespaceName_in_namespaceDecl120);\n                namespaceName();\n                state._fsp--;\n                pushFollow(FOLLOW_namespaceBody_in_namespaceDecl122);\n                namespaceBody();\n                state._fsp--;\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"namespaceDecl\"\n    public static class namespaceName_return extends ParserRuleReturnScope {\n    }\n\n    // $ANTLR start \"namespaceName\"\n    // net/sf/sugar/scl/SCL.g:179:1: namespaceName : ( varName | compositeNamespaceName );\n    public final SCLParser.namespaceName_return namespaceName() throws RecognitionException {\n        SCLParser.namespaceName_return retval = new SCLParser.namespaceName_return();\n        retval.start = input.LT(1);\n        SCLParser.compositeNamespaceName_return compositeNamespaceName1 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:179:16: ( varName | compositeNamespaceName )\n            int alt3 = 2;\n            alt3 = dfa3.predict(input);\n            switch(alt3) {\n                case 1:\n                    // net/sf/sugar/scl/SCL.g:179:18: varName\n                    {\n                        pushFollow(FOLLOW_varName_in_namespaceName132);\n                        varName();\n                        state._fsp--;\n                        this.elements.push(addChildElement(this.elements.peek(), input.toString(retval.start, input.LT(-1))));\n                    }\n                    break;\n                case 2:\n                    // net/sf/sugar/scl/SCL.g:180:9: compositeNamespaceName\n                    {\n                        pushFollow(FOLLOW_compositeNamespaceName_in_namespaceName145);\n                        compositeNamespaceName1 = compositeNamespaceName();\n                        state._fsp--;\n                        this.elements.push(addChildElements(this.elements.peek(), (compositeNamespaceName1 != null ? input.toString(compositeNamespaceName1.start, compositeNamespaceName1.stop) : null)));\n                    }\n                    break;\n            }\n            retval.stop = input.LT(-1);\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return retval;\n    }\n\n    // $ANTLR end \"namespaceName\"\n    public static class compositeNamespaceName_return extends ParserRuleReturnScope {\n    }\n\n    // $ANTLR start \"compositeNamespaceName\"\n    // net/sf/sugar/scl/SCL.g:182:1: compositeNamespaceName : ( VALID_NAME_CHARS )+ ( '.' ( VALID_NAME_CHARS )+ )+ ;\n    public final SCLParser.compositeNamespaceName_return compositeNamespaceName() throws RecognitionException {\n        SCLParser.compositeNamespaceName_return retval = new SCLParser.compositeNamespaceName_return();\n        retval.start = input.LT(1);\n        try {\n            // net/sf/sugar/scl/SCL.g:182:24: ( ( VALID_NAME_CHARS )+ ( '.' ( VALID_NAME_CHARS )+ )+ )\n            // net/sf/sugar/scl/SCL.g:182:28: ( VALID_NAME_CHARS )+ ( '.' ( VALID_NAME_CHARS )+ )+\n            {\n                // net/sf/sugar/scl/SCL.g:182:28: ( VALID_NAME_CHARS )+\n                int cnt4 = 0;\n                loop4: do {\n                    int alt4 = 2;\n                    switch(input.LA(1)) {\n                        case VALID_NAME_CHARS:\n                            {\n                                alt4 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt4) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:182:28: VALID_NAME_CHARS\n                            {\n                                match(input, VALID_NAME_CHARS, FOLLOW_VALID_NAME_CHARS_in_compositeNamespaceName160);\n                            }\n                            break;\n                        default:\n                            if (cnt4 >= 1)\n                                break loop4;\n                            EarlyExitException eee = new EarlyExitException(4, input);\n                            throw eee;\n                    }\n                    cnt4++;\n                } while (true);\n                // net/sf/sugar/scl/SCL.g:182:46: ( '.' ( VALID_NAME_CHARS )+ )+\n                int cnt6 = 0;\n                loop6: do {\n                    int alt6 = 2;\n                    switch(input.LA(1)) {\n                        case 19:\n                            {\n                                alt6 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt6) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:182:47: '.' ( VALID_NAME_CHARS )+\n                            {\n                                match(input, 19, FOLLOW_19_in_compositeNamespaceName164);\n                                // net/sf/sugar/scl/SCL.g:182:51: ( VALID_NAME_CHARS )+\n                                int cnt5 = 0;\n                                loop5: do {\n                                    int alt5 = 2;\n                                    switch(input.LA(1)) {\n                                        case VALID_NAME_CHARS:\n                                            {\n                                                alt5 = 1;\n                                            }\n                                            break;\n                                    }\n                                    switch(alt5) {\n                                        case 1:\n                                            // net/sf/sugar/scl/SCL.g:182:51: VALID_NAME_CHARS\n                                            {\n                                                match(input, VALID_NAME_CHARS, FOLLOW_VALID_NAME_CHARS_in_compositeNamespaceName166);\n                                            }\n                                            break;\n                                        default:\n                                            if (cnt5 >= 1)\n                                                break loop5;\n                                            EarlyExitException eee = new EarlyExitException(5, input);\n                                            throw eee;\n                                    }\n                                    cnt5++;\n                                } while (true);\n                            }\n                            break;\n                        default:\n                            if (cnt6 >= 1)\n                                break loop6;\n                            EarlyExitException eee = new EarlyExitException(6, input);\n                            throw eee;\n                    }\n                    cnt6++;\n                } while (true);\n            }\n            retval.stop = input.LT(-1);\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return retval;\n    }\n\n    // $ANTLR end \"compositeNamespaceName\"\n    // $ANTLR start \"namespaceBody\"\n    // net/sf/sugar/scl/SCL.g:184:1: namespaceBody : OPEN_NESTING ( statement )* CLOSE_NESTING ;\n    public final void namespaceBody() throws RecognitionException {\n        try {\n            // net/sf/sugar/scl/SCL.g:184:16: ( OPEN_NESTING ( statement )* CLOSE_NESTING )\n            // net/sf/sugar/scl/SCL.g:184:18: OPEN_NESTING ( statement )* CLOSE_NESTING\n            {\n                match(input, OPEN_NESTING, FOLLOW_OPEN_NESTING_in_namespaceBody181);\n                // net/sf/sugar/scl/SCL.g:184:31: ( statement )*\n                loop7: do {\n                    int alt7 = 2;\n                    switch(input.LA(1)) {\n                        case VALID_NAME_CHARS:\n                        case START_INCLUDE:\n                        case REF_CHAR:\n                            {\n                                alt7 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt7) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:184:32: statement\n                            {\n                                pushFollow(FOLLOW_statement_in_namespaceBody184);\n                                statement();\n                                state._fsp--;\n                            }\n                            break;\n                        default:\n                            break loop7;\n                    }\n                } while (true);\n                match(input, CLOSE_NESTING, FOLLOW_CLOSE_NESTING_in_namespaceBody188);\n                this.elements.pop();\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"namespaceBody\"\n    // $ANTLR start \"assignment\"\n    // net/sf/sugar/scl/SCL.g:188:1: assignment : varName ASSIGNMENT_OP ( varValue | includeValue | v= unparsedIncludeValue | r= localReference ) ;\n    public final void assignment() throws RecognitionException {\n        String v = null;\n        String r = null;\n        SCLParser.varName_return varName2 = null;\n        SCLParser.varValue_return varValue3 = null;\n        SCLParser.includeValue_return includeValue4 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:188:14: ( varName ASSIGNMENT_OP ( varValue | includeValue | v= unparsedIncludeValue | r= localReference ) )\n            // net/sf/sugar/scl/SCL.g:188:16: varName ASSIGNMENT_OP ( varValue | includeValue | v= unparsedIncludeValue | r= localReference )\n            {\n                pushFollow(FOLLOW_varName_in_assignment201);\n                varName2 = varName();\n                state._fsp--;\n                match(input, ASSIGNMENT_OP, FOLLOW_ASSIGNMENT_OP_in_assignment203);\n                // net/sf/sugar/scl/SCL.g:188:38: ( varValue | includeValue | v= unparsedIncludeValue | r= localReference )\n                int alt8 = 4;\n                switch(input.LA(1)) {\n                    case STRING_LITERAL:\n                        {\n                            alt8 = 1;\n                        }\n                        break;\n                    case START_INCLUDE:\n                        {\n                            alt8 = 2;\n                        }\n                        break;\n                    case START_UNPARSED_INCLUDE:\n                        {\n                            alt8 = 3;\n                        }\n                        break;\n                    case REF_CHAR:\n                        {\n                            alt8 = 4;\n                        }\n                        break;\n                    default:\n                        NoViableAltException nvae = new NoViableAltException(\"\", 8, 0, input);\n                        throw nvae;\n                }\n                switch(alt8) {\n                    case 1:\n                        // net/sf/sugar/scl/SCL.g:188:39: varValue\n                        {\n                            pushFollow(FOLLOW_varValue_in_assignment206);\n                            varValue3 = varValue();\n                            state._fsp--;\n                            addAttribute(this.elements.peek(), (varName2 != null ? input.toString(varName2.start, varName2.stop) : null), sanitiseText((varValue3 != null ? input.toString(varValue3.start, varValue3.stop) : null)));\n                        }\n                        break;\n                    case 2:\n                        // net/sf/sugar/scl/SCL.g:194:14: includeValue\n                        {\n                            pushFollow(FOLLOW_includeValue_in_assignment230);\n                            includeValue4 = includeValue();\n                            state._fsp--;\n                            try {\n                                this.loadIncludeValue(this.elements.peek(), (varName2 != null ? input.toString(varName2.start, varName2.stop) : null), sanitiseText((includeValue4 != null ? includeValue4.includeLocation : null)), sanitiseText((includeValue4 != null ? includeValue4.xPathQuery : null)));\n                            } catch (IncludeException ie) {\n                                ie.printStackTrace();\n                                System.out.println(ie);\n                            }\n                        }\n                        break;\n                    case 3:\n                        // net/sf/sugar/scl/SCL.g:205:12: v= unparsedIncludeValue\n                        {\n                            pushFollow(FOLLOW_unparsedIncludeValue_in_assignment247);\n                            v = unparsedIncludeValue();\n                            state._fsp--;\n                            try {\n                                this.loadUnparsedInclude(this.elements.peek(), (varName2 != null ? input.toString(varName2.start, varName2.stop) : null), v);\n                            } catch (IncludeException ie) {\n                                ie.printStackTrace();\n                            }\n                        }\n                        break;\n                    case 4:\n                        // net/sf/sugar/scl/SCL.g:212:15: r= localReference\n                        {\n                            pushFollow(FOLLOW_localReference_in_assignment267);\n                            r = localReference();\n                            state._fsp--;\n                            //todo : handle empty values, also handle non numeric, date and boolean return types\n                            prepareLocalRef(this.elements.peek(), (varName2 != null ? input.toString(varName2.start, varName2.stop) : null), r);\n                        }\n                        break;\n                }\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"assignment\"\n    public static class varName_return extends ParserRuleReturnScope {\n    }\n\n    // $ANTLR start \"varName\"\n    // net/sf/sugar/scl/SCL.g:218:1: varName : ( VALID_NAME_CHARS )+ ;\n    public final SCLParser.varName_return varName() throws RecognitionException {\n        SCLParser.varName_return retval = new SCLParser.varName_return();\n        retval.start = input.LT(1);\n        try {\n            // net/sf/sugar/scl/SCL.g:218:12: ( ( VALID_NAME_CHARS )+ )\n            // net/sf/sugar/scl/SCL.g:218:14: ( VALID_NAME_CHARS )+\n            {\n                // net/sf/sugar/scl/SCL.g:218:14: ( VALID_NAME_CHARS )+\n                int cnt9 = 0;\n                loop9: do {\n                    int alt9 = 2;\n                    switch(input.LA(1)) {\n                        case VALID_NAME_CHARS:\n                            {\n                                alt9 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt9) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:218:14: VALID_NAME_CHARS\n                            {\n                                match(input, VALID_NAME_CHARS, FOLLOW_VALID_NAME_CHARS_in_varName298);\n                            }\n                            break;\n                        default:\n                            if (cnt9 >= 1)\n                                break loop9;\n                            EarlyExitException eee = new EarlyExitException(9, input);\n                            throw eee;\n                    }\n                    cnt9++;\n                } while (true);\n            }\n            retval.stop = input.LT(-1);\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return retval;\n    }\n\n    // $ANTLR end \"varName\"\n    public static class varValue_return extends ParserRuleReturnScope {\n    }\n\n    // $ANTLR start \"varValue\"\n    // net/sf/sugar/scl/SCL.g:220:1: varValue : STRING_LITERAL ;\n    public final SCLParser.varValue_return varValue() throws RecognitionException {\n        SCLParser.varValue_return retval = new SCLParser.varValue_return();\n        retval.start = input.LT(1);\n        try {\n            // net/sf/sugar/scl/SCL.g:220:13: ( STRING_LITERAL )\n            // net/sf/sugar/scl/SCL.g:220:15: STRING_LITERAL\n            {\n                match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_varValue312);\n            }\n            retval.stop = input.LT(-1);\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return retval;\n    }\n\n    // $ANTLR end \"varValue\"\n    public static class includeValue_return extends ParserRuleReturnScope {\n\n        public String includeLocation;\n\n        public String xPathQuery;\n    }\n\n    // $ANTLR start \"includeValue\"\n    // net/sf/sugar/scl/SCL.g:223:1: includeValue returns [String includeLocation, String xPathQuery] : START_INCLUDE s1= STRING_LITERAL AS_KEYWORD s2= STRING_LITERAL END_INCLUDE ;\n    public final SCLParser.includeValue_return includeValue() throws RecognitionException {\n        SCLParser.includeValue_return retval = new SCLParser.includeValue_return();\n        retval.start = input.LT(1);\n        Token s1 = null;\n        Token s2 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:224:6: ( START_INCLUDE s1= STRING_LITERAL AS_KEYWORD s2= STRING_LITERAL END_INCLUDE )\n            // net/sf/sugar/scl/SCL.g:224:8: START_INCLUDE s1= STRING_LITERAL AS_KEYWORD s2= STRING_LITERAL END_INCLUDE\n            {\n                match(input, START_INCLUDE, FOLLOW_START_INCLUDE_in_includeValue334);\n                s1 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_includeValue338);\n                match(input, AS_KEYWORD, FOLLOW_AS_KEYWORD_in_includeValue340);\n                s2 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_includeValue344);\n                match(input, END_INCLUDE, FOLLOW_END_INCLUDE_in_includeValue346);\n                retval.includeLocation = (s1 != null ? s1.getText() : null);\n                retval.xPathQuery = (s2 != null ? s2.getText() : null);\n            }\n            retval.stop = input.LT(-1);\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return retval;\n    }\n\n    // $ANTLR end \"includeValue\"\n    // $ANTLR start \"unparsedIncludeValue\"\n    // net/sf/sugar/scl/SCL.g:229:1: unparsedIncludeValue returns [String includeLocation] : START_UNPARSED_INCLUDE s1= STRING_LITERAL END_INCLUDE ;\n    public final String unparsedIncludeValue() throws RecognitionException {\n        String includeLocation = null;\n        Token s1 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:230:6: ( START_UNPARSED_INCLUDE s1= STRING_LITERAL END_INCLUDE )\n            // net/sf/sugar/scl/SCL.g:230:8: START_UNPARSED_INCLUDE s1= STRING_LITERAL END_INCLUDE\n            {\n                match(input, START_UNPARSED_INCLUDE, FOLLOW_START_UNPARSED_INCLUDE_in_unparsedIncludeValue373);\n                s1 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_unparsedIncludeValue377);\n                match(input, END_INCLUDE, FOLLOW_END_INCLUDE_in_unparsedIncludeValue379);\n                includeLocation = stripQuotes(s1.getText());\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return includeLocation;\n    }\n\n    // $ANTLR end \"unparsedIncludeValue\"\n    // $ANTLR start \"includeTree\"\n    // net/sf/sugar/scl/SCL.g:234:1: includeTree : START_INCLUDE s1= STRING_LITERAL ( AS_KEYWORD s2= STRING_LITERAL )? END_INCLUDE ;\n    public final void includeTree() throws RecognitionException {\n        Token s1 = null;\n        Token s2 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:234:15: ( START_INCLUDE s1= STRING_LITERAL ( AS_KEYWORD s2= STRING_LITERAL )? END_INCLUDE )\n            // net/sf/sugar/scl/SCL.g:234:17: START_INCLUDE s1= STRING_LITERAL ( AS_KEYWORD s2= STRING_LITERAL )? END_INCLUDE\n            {\n                match(input, START_INCLUDE, FOLLOW_START_INCLUDE_in_includeTree399);\n                s1 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_includeTree403);\n                // net/sf/sugar/scl/SCL.g:234:49: ( AS_KEYWORD s2= STRING_LITERAL )?\n                int alt10 = 2;\n                switch(input.LA(1)) {\n                    case AS_KEYWORD:\n                        {\n                            alt10 = 1;\n                        }\n                        break;\n                }\n                switch(alt10) {\n                    case 1:\n                        // net/sf/sugar/scl/SCL.g:234:50: AS_KEYWORD s2= STRING_LITERAL\n                        {\n                            match(input, AS_KEYWORD, FOLLOW_AS_KEYWORD_in_includeTree406);\n                            s2 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_includeTree410);\n                        }\n                        break;\n                }\n                match(input, END_INCLUDE, FOLLOW_END_INCLUDE_in_includeTree414);\n                try {\n                    if (s2 == null || \"\".equals(s2)) {\n                        this.loadInclude(this.elements.peek(), sanitiseText(s1.getText()));\n                    } else {\n                        this.loadIncludeNodes(this.elements.peek(), sanitiseText(s1.getText()), sanitiseText(s2.getText()));\n                    }\n                } catch (IncludeException ie) {\n                    ie.printStackTrace();\n                }\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"includeTree\"\n    // $ANTLR start \"localRefTree\"\n    // net/sf/sugar/scl/SCL.g:250:1: localRefTree returns [String xPathQuery] : r= localReference ;\n    public final String localRefTree() throws RecognitionException {\n        String xPathQuery = null;\n        String r = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:251:7: (r= localReference )\n            // net/sf/sugar/scl/SCL.g:251:10: r= localReference\n            {\n                pushFollow(FOLLOW_localReference_in_localRefTree442);\n                r = localReference();\n                state._fsp--;\n                xPathQuery = r;\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return xPathQuery;\n    }\n\n    // $ANTLR end \"localRefTree\"\n    // $ANTLR start \"localReference\"\n    // net/sf/sugar/scl/SCL.g:253:1: localReference returns [String resolvedValue] : REF_CHAR ( WS )* STRING_LITERAL ;\n    public final String localReference() throws RecognitionException {\n        String resolvedValue = null;\n        Token STRING_LITERAL5 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:254:7: ( REF_CHAR ( WS )* STRING_LITERAL )\n            // net/sf/sugar/scl/SCL.g:254:10: REF_CHAR ( WS )* STRING_LITERAL\n            {\n                match(input, REF_CHAR, FOLLOW_REF_CHAR_in_localReference475);\n                // net/sf/sugar/scl/SCL.g:254:19: ( WS )*\n                loop11: do {\n                    int alt11 = 2;\n                    switch(input.LA(1)) {\n                        case WS:\n                            {\n                                alt11 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt11) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:254:19: WS\n                            {\n                                match(input, WS, FOLLOW_WS_in_localReference477);\n                            }\n                            break;\n                        default:\n                            break loop11;\n                    }\n                } while (true);\n                STRING_LITERAL5 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_localReference480);\n                resolvedValue = sanitiseText((STRING_LITERAL5 != null ? STRING_LITERAL5.getText() : null));\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return resolvedValue;\n    }\n\n    // $ANTLR end \"localReference\"\n    // Delegated rules\n    protected DFA2 dfa2 = new DFA2(this);\n\n    protected DFA3 dfa3 = new DFA3(this);\n\n    static final String DFA2_eotS = \"\\6\\uffff\";\n\n    static final String DFA2_eofS = \"\\6\\uffff\";\n\n    static final String DFA2_minS = \"\\2\\4\\4\\uffff\";\n\n    static final String DFA2_maxS = \"\\1\\15\\1\\23\\4\\uffff\";\n\n    static final String DFA2_acceptS = \"\\2\\uffff\\1\\3\\1\\4\\1\\1\\1\\2\";\n\n    static final String DFA2_specialS = \"\\6\\uffff}>\";\n\n    static final String[] DFA2_transitionS = { \"\\1\\1\\4\\uffff\\1\\2\\3\\uffff\\1\\3\", \"\\1\\1\\1\\4\\1\\uffff\\1\\5\\13\\uffff\\1\\4\", \"\", \"\", \"\", \"\" };\n\n    static final short[] DFA2_eot = DFA.unpackEncodedString(DFA2_eotS);\n\n    static final short[] DFA2_eof = DFA.unpackEncodedString(DFA2_eofS);\n\n    static final char[] DFA2_min = DFA.unpackEncodedStringToUnsignedChars(DFA2_minS);\n\n    static final char[] DFA2_max = DFA.unpackEncodedStringToUnsignedChars(DFA2_maxS);\n\n    static final short[] DFA2_accept = DFA.unpackEncodedString(DFA2_acceptS);\n\n    static final short[] DFA2_special = DFA.unpackEncodedString(DFA2_specialS);\n\n    static final short[][] DFA2_transition;\n\n    static {\n        int numStates = DFA2_transitionS.length;\n        DFA2_transition = new short[numStates][];\n        for (int i = 0; i < numStates; i++) {\n            DFA2_transition[i] = DFA.unpackEncodedString(DFA2_transitionS[i]);\n        }\n    }\n\n    class DFA2 extends DFA {\n\n        public DFA2(BaseRecognizer recognizer) {\n            this.recognizer = recognizer;\n            this.decisionNumber = 2;\n            this.eot = DFA2_eot;\n            this.eof = DFA2_eof;\n            this.min = DFA2_min;\n            this.max = DFA2_max;\n            this.accept = DFA2_accept;\n            this.special = DFA2_special;\n            this.transition = DFA2_transition;\n        }\n\n        public String getDescription() {\n            return \"170:1: statement : ( namespaceDecl | assignment | includeTree | t= localRefTree );\";\n        }\n    }\n\n    static final String DFA3_eotS = \"\\4\\uffff\";\n\n    static final String DFA3_eofS = \"\\4\\uffff\";\n\n    static final String DFA3_minS = \"\\2\\4\\2\\uffff\";\n\n    static final String DFA3_maxS = \"\\1\\4\\1\\23\\2\\uffff\";\n\n    static final String DFA3_acceptS = \"\\2\\uffff\\1\\1\\1\\2\";\n\n    static final String DFA3_specialS = \"\\4\\uffff}>\";\n\n    static final String[] DFA3_transitionS = { \"\\1\\1\", \"\\1\\1\\1\\2\\15\\uffff\\1\\3\", \"\", \"\" };\n\n    static final short[] DFA3_eot = DFA.unpackEncodedString(DFA3_eotS);\n\n    static final short[] DFA3_eof = DFA.unpackEncodedString(DFA3_eofS);\n\n    static final char[] DFA3_min = DFA.unpackEncodedStringToUnsignedChars(DFA3_minS);\n\n    static final char[] DFA3_max = DFA.unpackEncodedStringToUnsignedChars(DFA3_maxS);\n\n    static final short[] DFA3_accept = DFA.unpackEncodedString(DFA3_acceptS);\n\n    static final short[] DFA3_special = DFA.unpackEncodedString(DFA3_specialS);\n\n    static final short[][] DFA3_transition;\n\n    static {\n        int numStates = DFA3_transitionS.length;\n        DFA3_transition = new short[numStates][];\n        for (int i = 0; i < numStates; i++) {\n            DFA3_transition[i] = DFA.unpackEncodedString(DFA3_transitionS[i]);\n        }\n    }\n\n    class DFA3 extends DFA {\n\n        public DFA3(BaseRecognizer recognizer) {\n            this.recognizer = recognizer;\n            this.decisionNumber = 3;\n            this.eot = DFA3_eot;\n            this.eof = DFA3_eof;\n            this.min = DFA3_min;\n            this.max = DFA3_max;\n            this.accept = DFA3_accept;\n            this.special = DFA3_special;\n            this.transition = DFA3_transition;\n        }\n\n        public String getDescription() {\n            return \"179:1: namespaceName : ( varName | compositeNamespaceName );\";\n        }\n    }\n\n    public static final BitSet FOLLOW_statementSeq_in_scl44 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_statement_in_statementSeq61 = new BitSet(new long[] { 0x0000000000002212L });\n\n    public static final BitSet FOLLOW_namespaceDecl_in_statement73 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_assignment_in_statement84 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_includeTree_in_statement95 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_localRefTree_in_statement108 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_namespaceName_in_namespaceDecl120 = new BitSet(new long[] { 0x0000000000000020L });\n\n    public static final BitSet FOLLOW_namespaceBody_in_namespaceDecl122 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_varName_in_namespaceName132 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_compositeNamespaceName_in_namespaceName145 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_VALID_NAME_CHARS_in_compositeNamespaceName160 = new BitSet(new long[] { 0x0000000000080010L });\n\n    public static final BitSet FOLLOW_19_in_compositeNamespaceName164 = new BitSet(new long[] { 0x0000000000000010L });\n\n    public static final BitSet FOLLOW_VALID_NAME_CHARS_in_compositeNamespaceName166 = new BitSet(new long[] { 0x0000000000080012L });\n\n    public static final BitSet FOLLOW_OPEN_NESTING_in_namespaceBody181 = new BitSet(new long[] { 0x0000000000002250L });\n\n    public static final BitSet FOLLOW_statement_in_namespaceBody184 = new BitSet(new long[] { 0x0000000000002250L });\n\n    public static final BitSet FOLLOW_CLOSE_NESTING_in_namespaceBody188 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_varName_in_assignment201 = new BitSet(new long[] { 0x0000000000000080L });\n\n    public static final BitSet FOLLOW_ASSIGNMENT_OP_in_assignment203 = new BitSet(new long[] { 0x0000000000003310L });\n\n    public static final BitSet FOLLOW_varValue_in_assignment206 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_includeValue_in_assignment230 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_unparsedIncludeValue_in_assignment247 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_localReference_in_assignment267 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_VALID_NAME_CHARS_in_varName298 = new BitSet(new long[] { 0x0000000000000012L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_varValue312 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_START_INCLUDE_in_includeValue334 = new BitSet(new long[] { 0x0000000000000100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_includeValue338 = new BitSet(new long[] { 0x0000000000000400L });\n\n    public static final BitSet FOLLOW_AS_KEYWORD_in_includeValue340 = new BitSet(new long[] { 0x0000000000000100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_includeValue344 = new BitSet(new long[] { 0x0000000000000800L });\n\n    public static final BitSet FOLLOW_END_INCLUDE_in_includeValue346 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_START_UNPARSED_INCLUDE_in_unparsedIncludeValue373 = new BitSet(new long[] { 0x0000000000000100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_unparsedIncludeValue377 = new BitSet(new long[] { 0x0000000000000800L });\n\n    public static final BitSet FOLLOW_END_INCLUDE_in_unparsedIncludeValue379 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_START_INCLUDE_in_includeTree399 = new BitSet(new long[] { 0x0000000000000100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_includeTree403 = new BitSet(new long[] { 0x0000000000000C00L });\n\n    public static final BitSet FOLLOW_AS_KEYWORD_in_includeTree406 = new BitSet(new long[] { 0x0000000000000100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_includeTree410 = new BitSet(new long[] { 0x0000000000000800L });\n\n    public static final BitSet FOLLOW_END_INCLUDE_in_includeTree414 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_localReference_in_localRefTree442 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_REF_CHAR_in_localReference475 = new BitSet(new long[] { 0x0000000000004100L });\n\n    public static final BitSet FOLLOW_WS_in_localReference477 = new BitSet(new long[] { 0x0000000000004100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_localReference480 = new BitSet(new long[] { 0x0000000000000002L });\n}\n",
		"id": "/EvoSuiteBenchmark/60_sugar/src/main/java/net/sf/sugar/scl/SCLParser_2Test.java",
		"test_prompt": "// SCLParser_2Test.java\npackage net.sf.sugar.scl;\n\nimport static net.sf.sugar.scl.PathConversionUtils.convertToXPath;\nimport static net.sf.sugar.scl.PathConversionUtils.processDotDelimitedPath;\nimport java.net.URI;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Element;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathFactory;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpressionException;\nimport org.antlr.runtime.*;\nimport java.util.Stack;\nimport java.util.List;\nimport java.util.ArrayList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SCLParser}.\n* It contains ten unit test cases for the {@link SCLParser#namespaceName()} method.\n*/\nclass SCLParser_2Test {"
	},
	{
		"original_code": "// SCLParser.java\n// $ANTLR 3.3 Nov 30, 2010 12:46:29 net/sf/sugar/scl/SCL.g 2013-06-10 17:15:03\npackage net.sf.sugar.scl;\n\nimport static net.sf.sugar.scl.PathConversionUtils.convertToXPath;\nimport static net.sf.sugar.scl.PathConversionUtils.processDotDelimitedPath;\nimport java.net.URI;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Element;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathFactory;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpressionException;\nimport org.antlr.runtime.*;\nimport java.util.Stack;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class SCLParser extends Parser {\n\n    public static final String[] tokenNames = new String[] { \"<invalid>\", \"<EOR>\", \"<DOWN>\", \"<UP>\", \"VALID_NAME_CHARS\", \"OPEN_NESTING\", \"CLOSE_NESTING\", \"ASSIGNMENT_OP\", \"STRING_LITERAL\", \"START_INCLUDE\", \"AS_KEYWORD\", \"END_INCLUDE\", \"START_UNPARSED_INCLUDE\", \"REF_CHAR\", \"WS\", \"QUOTE\", \"STRING_SEQUENCE_CHAR\", \"COMMENT\", \"LINE_COMMENT\", \"'.'\" };\n\n    public static final int EOF = -1;\n\n    public static final int T__19 = 19;\n\n    public static final int VALID_NAME_CHARS = 4;\n\n    public static final int OPEN_NESTING = 5;\n\n    public static final int CLOSE_NESTING = 6;\n\n    public static final int ASSIGNMENT_OP = 7;\n\n    public static final int STRING_LITERAL = 8;\n\n    public static final int START_INCLUDE = 9;\n\n    public static final int AS_KEYWORD = 10;\n\n    public static final int END_INCLUDE = 11;\n\n    public static final int START_UNPARSED_INCLUDE = 12;\n\n    public static final int REF_CHAR = 13;\n\n    public static final int WS = 14;\n\n    public static final int QUOTE = 15;\n\n    public static final int STRING_SEQUENCE_CHAR = 16;\n\n    public static final int COMMENT = 17;\n\n    public static final int LINE_COMMENT = 18;\n\n    // delegates\n    // delegators\n    public SCLParser(TokenStream input) {\n        this(input, new RecognizerSharedState());\n    }\n\n    public SCLParser(TokenStream input, RecognizerSharedState state) {\n        super(input, state);\n    }\n\n    public String[] getTokenNames() {\n        return SCLParser.tokenNames;\n    }\n\n    public String getGrammarFileName() {\n        return \"net/sf/sugar/scl/SCL.g\";\n    }\n\n    public static final String SCL_ROOT_ELEMENT = \"scl\";\n\n    private URI rootSCLFile;\n\n    private Document doc;\n\n    private Stack<Element> elements = new Stack<Element>();\n\n    private XPath xpath = XPathFactory.newInstance().newXPath();\n\n    private IncludeProcessor includeProcessor;\n\n    private static LocalReferenceProcessor localReferenceProcessor;\n\n    private List<LocalReference> localRefs = new ArrayList<LocalReference>();\n\n    private int namespaceSteps;\n\n    {\n        try {\n            doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n            Element rootElement = doc.createElement(SCL_ROOT_ELEMENT);\n            doc.appendChild(rootElement);\n            this.elements.push(rootElement);\n        } catch (ParserConfigurationException pce) {\n            pce.printStackTrace();\n        }\n    }\n\n    protected Element addChildElement(Element element, String child) {\n        Element childElement = this.doc.createElement(child);\n        element.appendChild(childElement);\n        return childElement;\n    }\n\n    protected Element addChildElements(Element currentElement, String compositePath) {\n        return processDotDelimitedPath(currentElement, compositePath);\n    }\n\n    protected void addAttribute(Element currentElement, String attributeName, String attributeValue) {\n        Element childElement = this.doc.createElement(attributeName);\n        childElement.setTextContent(attributeValue);\n        currentElement.appendChild(childElement);\n    }\n\n    protected void loadIncludeValue(Element parentElement, String propertyName, String includeLocation, String xPathExpression) throws IncludeException {\n        this.includeProcessor.prepareIncludeValue(parentElement, propertyName, includeLocation, this.rootSCLFile, xPathExpression);\n    }\n\n    protected void loadInclude(Element parentElement, String includeLocation) throws IncludeException {\n        this.includeProcessor.prepareInclude(parentElement, includeLocation, this.rootSCLFile);\n    }\n\n    protected void loadIncludeNodes(Element parentElement, String includeLocation, String xPathExpression) throws IncludeException {\n        this.includeProcessor.prepareInclude(parentElement, includeLocation, this.rootSCLFile, xPathExpression);\n    }\n\n    protected void loadUnparsedInclude(Element parentElement, String propertyName, String includeLocation) throws IncludeException {\n        this.includeProcessor.loadUnparsedInclude(parentElement, propertyName, includeLocation, this.rootSCLFile);\n    }\n\n    protected void prepareLocalRefTree(final Element parentElement, final String xPathExpression) {\n        LocalReference localRef = new LocalReference() {\n\n            {\n                setParentElement(parentElement);\n                setXPathQuery(xPathExpression);\n            }\n        };\n        this.localRefs.add(localRef);\n    }\n\n    protected void prepareLocalRef(final Element parentElement, final String attributeName, final String xPathExpression) {\n        LocalAttributeReference localRef = new LocalAttributeReference() {\n\n            {\n                setParentElement(parentElement);\n                setXPathQuery(xPathExpression);\n                setAttributeName(attributeName);\n            }\n        };\n        this.localRefs.add(localRef);\n    }\n\n    public void setRootSCLFile(URI rootSCLFile) {\n        this.rootSCLFile = rootSCLFile;\n    }\n\n    public URI getRootSCLFile() {\n        return this.rootSCLFile;\n    }\n\n    public Document getRootDocument() {\n        return this.doc;\n    }\n\n    public void setIncludeProcessor(IncludeProcessor includeProcessor) {\n        this.includeProcessor = includeProcessor;\n    }\n\n    public IncludeProcessor getIncludeProcessor() {\n        return this.includeProcessor;\n    }\n\n    public void setLocalReferenceProcessor(LocalReferenceProcessor processor) {\n        localReferenceProcessor = processor;\n    }\n\n    public LocalReferenceProcessor getLocalReferenceProcessor() {\n        return localReferenceProcessor;\n    }\n\n    public List<LocalReference> getLocalRefs() {\n        return this.localRefs;\n    }\n\n    public String sanitiseText(String rawText) {\n        String unquotedText = stripQuotes(rawText);\n        return normaliseEscapeChars(unquotedText);\n    }\n\n    private String stripQuotes(String quotedText) {\n        return quotedText.substring(1, quotedText.length() - 1);\n    }\n\n    private String normaliseEscapeChars(String text) {\n        return text.replace(\"\\\\\\\\\", \"\\\\\").replace(\"\\\\\\\"\", \"\\\"\");\n    }\n\n    // $ANTLR start \"scl\"\n    // net/sf/sugar/scl/SCL.g:152:1: scl returns [Document properties] : statementSeq ;\n    public final Document scl() throws RecognitionException {\n        Document properties = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:153:6: ( statementSeq )\n            // net/sf/sugar/scl/SCL.g:153:8: statementSeq\n            {\n                pushFollow(FOLLOW_statementSeq_in_scl44);\n                statementSeq();\n                state._fsp--;\n                try {\n                    this.includeProcessor.resolveIncludes(this.doc);\n                    localReferenceProcessor.processLocalReferences(this.localRefs);\n                } catch (IncludeException ie) {\n                    ie.printStackTrace();\n                } catch (LocalReferenceException lre) {\n                    lre.printStackTrace();\n                }\n                properties = doc;\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return properties;\n    }\n\n    // $ANTLR end \"scl\"\n    // $ANTLR start \"statementSeq\"\n    // net/sf/sugar/scl/SCL.g:168:1: statementSeq : ( statement )+ ;\n    public final void statementSeq() throws RecognitionException {\n        try {\n            // net/sf/sugar/scl/SCL.g:168:15: ( ( statement )+ )\n            // net/sf/sugar/scl/SCL.g:168:17: ( statement )+\n            {\n                // net/sf/sugar/scl/SCL.g:168:17: ( statement )+\n                int cnt1 = 0;\n                loop1: do {\n                    int alt1 = 2;\n                    switch(input.LA(1)) {\n                        case VALID_NAME_CHARS:\n                        case START_INCLUDE:\n                        case REF_CHAR:\n                            {\n                                alt1 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt1) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:168:17: statement\n                            {\n                                pushFollow(FOLLOW_statement_in_statementSeq61);\n                                statement();\n                                state._fsp--;\n                            }\n                            break;\n                        default:\n                            if (cnt1 >= 1)\n                                break loop1;\n                            EarlyExitException eee = new EarlyExitException(1, input);\n                            throw eee;\n                    }\n                    cnt1++;\n                } while (true);\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"statementSeq\"\n    // $ANTLR start \"statement\"\n    // net/sf/sugar/scl/SCL.g:170:1: statement : ( namespaceDecl | assignment | includeTree | t= localRefTree );\n    public final void statement() throws RecognitionException {\n        String t = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:170:13: ( namespaceDecl | assignment | includeTree | t= localRefTree )\n            int alt2 = 4;\n            alt2 = dfa2.predict(input);\n            switch(alt2) {\n                case 1:\n                    // net/sf/sugar/scl/SCL.g:170:15: namespaceDecl\n                    {\n                        pushFollow(FOLLOW_namespaceDecl_in_statement73);\n                        namespaceDecl();\n                        state._fsp--;\n                    }\n                    break;\n                case 2:\n                    // net/sf/sugar/scl/SCL.g:171:9: assignment\n                    {\n                        pushFollow(FOLLOW_assignment_in_statement84);\n                        assignment();\n                        state._fsp--;\n                    }\n                    break;\n                case 3:\n                    // net/sf/sugar/scl/SCL.g:172:9: includeTree\n                    {\n                        pushFollow(FOLLOW_includeTree_in_statement95);\n                        includeTree();\n                        state._fsp--;\n                    }\n                    break;\n                case 4:\n                    // net/sf/sugar/scl/SCL.g:173:9: t= localRefTree\n                    {\n                        pushFollow(FOLLOW_localRefTree_in_statement108);\n                        t = localRefTree();\n                        state._fsp--;\n                        prepareLocalRefTree(this.elements.peek(), t);\n                    }\n                    break;\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"statement\"\n    // $ANTLR start \"namespaceDecl\"\n    // net/sf/sugar/scl/SCL.g:177:1: namespaceDecl : namespaceName namespaceBody ;\n    public final void namespaceDecl() throws RecognitionException {\n        try {\n            // net/sf/sugar/scl/SCL.g:177:16: ( namespaceName namespaceBody )\n            // net/sf/sugar/scl/SCL.g:177:18: namespaceName namespaceBody\n            {\n                pushFollow(FOLLOW_namespaceName_in_namespaceDecl120);\n                namespaceName();\n                state._fsp--;\n                pushFollow(FOLLOW_namespaceBody_in_namespaceDecl122);\n                namespaceBody();\n                state._fsp--;\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"namespaceDecl\"\n    public static class namespaceName_return extends ParserRuleReturnScope {\n    }\n\n    // $ANTLR start \"namespaceName\"\n    // net/sf/sugar/scl/SCL.g:179:1: namespaceName : ( varName | compositeNamespaceName );\n    public final SCLParser.namespaceName_return namespaceName() throws RecognitionException {\n        SCLParser.namespaceName_return retval = new SCLParser.namespaceName_return();\n        retval.start = input.LT(1);\n        SCLParser.compositeNamespaceName_return compositeNamespaceName1 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:179:16: ( varName | compositeNamespaceName )\n            int alt3 = 2;\n            alt3 = dfa3.predict(input);\n            switch(alt3) {\n                case 1:\n                    // net/sf/sugar/scl/SCL.g:179:18: varName\n                    {\n                        pushFollow(FOLLOW_varName_in_namespaceName132);\n                        varName();\n                        state._fsp--;\n                        this.elements.push(addChildElement(this.elements.peek(), input.toString(retval.start, input.LT(-1))));\n                    }\n                    break;\n                case 2:\n                    // net/sf/sugar/scl/SCL.g:180:9: compositeNamespaceName\n                    {\n                        pushFollow(FOLLOW_compositeNamespaceName_in_namespaceName145);\n                        compositeNamespaceName1 = compositeNamespaceName();\n                        state._fsp--;\n                        this.elements.push(addChildElements(this.elements.peek(), (compositeNamespaceName1 != null ? input.toString(compositeNamespaceName1.start, compositeNamespaceName1.stop) : null)));\n                    }\n                    break;\n            }\n            retval.stop = input.LT(-1);\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return retval;\n    }\n\n    // $ANTLR end \"namespaceName\"\n    public static class compositeNamespaceName_return extends ParserRuleReturnScope {\n    }\n\n    // $ANTLR start \"compositeNamespaceName\"\n    // net/sf/sugar/scl/SCL.g:182:1: compositeNamespaceName : ( VALID_NAME_CHARS )+ ( '.' ( VALID_NAME_CHARS )+ )+ ;\n    public final SCLParser.compositeNamespaceName_return compositeNamespaceName() throws RecognitionException {\n        SCLParser.compositeNamespaceName_return retval = new SCLParser.compositeNamespaceName_return();\n        retval.start = input.LT(1);\n        try {\n            // net/sf/sugar/scl/SCL.g:182:24: ( ( VALID_NAME_CHARS )+ ( '.' ( VALID_NAME_CHARS )+ )+ )\n            // net/sf/sugar/scl/SCL.g:182:28: ( VALID_NAME_CHARS )+ ( '.' ( VALID_NAME_CHARS )+ )+\n            {\n                // net/sf/sugar/scl/SCL.g:182:28: ( VALID_NAME_CHARS )+\n                int cnt4 = 0;\n                loop4: do {\n                    int alt4 = 2;\n                    switch(input.LA(1)) {\n                        case VALID_NAME_CHARS:\n                            {\n                                alt4 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt4) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:182:28: VALID_NAME_CHARS\n                            {\n                                match(input, VALID_NAME_CHARS, FOLLOW_VALID_NAME_CHARS_in_compositeNamespaceName160);\n                            }\n                            break;\n                        default:\n                            if (cnt4 >= 1)\n                                break loop4;\n                            EarlyExitException eee = new EarlyExitException(4, input);\n                            throw eee;\n                    }\n                    cnt4++;\n                } while (true);\n                // net/sf/sugar/scl/SCL.g:182:46: ( '.' ( VALID_NAME_CHARS )+ )+\n                int cnt6 = 0;\n                loop6: do {\n                    int alt6 = 2;\n                    switch(input.LA(1)) {\n                        case 19:\n                            {\n                                alt6 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt6) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:182:47: '.' ( VALID_NAME_CHARS )+\n                            {\n                                match(input, 19, FOLLOW_19_in_compositeNamespaceName164);\n                                // net/sf/sugar/scl/SCL.g:182:51: ( VALID_NAME_CHARS )+\n                                int cnt5 = 0;\n                                loop5: do {\n                                    int alt5 = 2;\n                                    switch(input.LA(1)) {\n                                        case VALID_NAME_CHARS:\n                                            {\n                                                alt5 = 1;\n                                            }\n                                            break;\n                                    }\n                                    switch(alt5) {\n                                        case 1:\n                                            // net/sf/sugar/scl/SCL.g:182:51: VALID_NAME_CHARS\n                                            {\n                                                match(input, VALID_NAME_CHARS, FOLLOW_VALID_NAME_CHARS_in_compositeNamespaceName166);\n                                            }\n                                            break;\n                                        default:\n                                            if (cnt5 >= 1)\n                                                break loop5;\n                                            EarlyExitException eee = new EarlyExitException(5, input);\n                                            throw eee;\n                                    }\n                                    cnt5++;\n                                } while (true);\n                            }\n                            break;\n                        default:\n                            if (cnt6 >= 1)\n                                break loop6;\n                            EarlyExitException eee = new EarlyExitException(6, input);\n                            throw eee;\n                    }\n                    cnt6++;\n                } while (true);\n            }\n            retval.stop = input.LT(-1);\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return retval;\n    }\n\n    // $ANTLR end \"compositeNamespaceName\"\n    // $ANTLR start \"namespaceBody\"\n    // net/sf/sugar/scl/SCL.g:184:1: namespaceBody : OPEN_NESTING ( statement )* CLOSE_NESTING ;\n    public final void namespaceBody() throws RecognitionException {\n        try {\n            // net/sf/sugar/scl/SCL.g:184:16: ( OPEN_NESTING ( statement )* CLOSE_NESTING )\n            // net/sf/sugar/scl/SCL.g:184:18: OPEN_NESTING ( statement )* CLOSE_NESTING\n            {\n                match(input, OPEN_NESTING, FOLLOW_OPEN_NESTING_in_namespaceBody181);\n                // net/sf/sugar/scl/SCL.g:184:31: ( statement )*\n                loop7: do {\n                    int alt7 = 2;\n                    switch(input.LA(1)) {\n                        case VALID_NAME_CHARS:\n                        case START_INCLUDE:\n                        case REF_CHAR:\n                            {\n                                alt7 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt7) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:184:32: statement\n                            {\n                                pushFollow(FOLLOW_statement_in_namespaceBody184);\n                                statement();\n                                state._fsp--;\n                            }\n                            break;\n                        default:\n                            break loop7;\n                    }\n                } while (true);\n                match(input, CLOSE_NESTING, FOLLOW_CLOSE_NESTING_in_namespaceBody188);\n                this.elements.pop();\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"namespaceBody\"\n    // $ANTLR start \"assignment\"\n    // net/sf/sugar/scl/SCL.g:188:1: assignment : varName ASSIGNMENT_OP ( varValue | includeValue | v= unparsedIncludeValue | r= localReference ) ;\n    public final void assignment() throws RecognitionException {\n        String v = null;\n        String r = null;\n        SCLParser.varName_return varName2 = null;\n        SCLParser.varValue_return varValue3 = null;\n        SCLParser.includeValue_return includeValue4 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:188:14: ( varName ASSIGNMENT_OP ( varValue | includeValue | v= unparsedIncludeValue | r= localReference ) )\n            // net/sf/sugar/scl/SCL.g:188:16: varName ASSIGNMENT_OP ( varValue | includeValue | v= unparsedIncludeValue | r= localReference )\n            {\n                pushFollow(FOLLOW_varName_in_assignment201);\n                varName2 = varName();\n                state._fsp--;\n                match(input, ASSIGNMENT_OP, FOLLOW_ASSIGNMENT_OP_in_assignment203);\n                // net/sf/sugar/scl/SCL.g:188:38: ( varValue | includeValue | v= unparsedIncludeValue | r= localReference )\n                int alt8 = 4;\n                switch(input.LA(1)) {\n                    case STRING_LITERAL:\n                        {\n                            alt8 = 1;\n                        }\n                        break;\n                    case START_INCLUDE:\n                        {\n                            alt8 = 2;\n                        }\n                        break;\n                    case START_UNPARSED_INCLUDE:\n                        {\n                            alt8 = 3;\n                        }\n                        break;\n                    case REF_CHAR:\n                        {\n                            alt8 = 4;\n                        }\n                        break;\n                    default:\n                        NoViableAltException nvae = new NoViableAltException(\"\", 8, 0, input);\n                        throw nvae;\n                }\n                switch(alt8) {\n                    case 1:\n                        // net/sf/sugar/scl/SCL.g:188:39: varValue\n                        {\n                            pushFollow(FOLLOW_varValue_in_assignment206);\n                            varValue3 = varValue();\n                            state._fsp--;\n                            addAttribute(this.elements.peek(), (varName2 != null ? input.toString(varName2.start, varName2.stop) : null), sanitiseText((varValue3 != null ? input.toString(varValue3.start, varValue3.stop) : null)));\n                        }\n                        break;\n                    case 2:\n                        // net/sf/sugar/scl/SCL.g:194:14: includeValue\n                        {\n                            pushFollow(FOLLOW_includeValue_in_assignment230);\n                            includeValue4 = includeValue();\n                            state._fsp--;\n                            try {\n                                this.loadIncludeValue(this.elements.peek(), (varName2 != null ? input.toString(varName2.start, varName2.stop) : null), sanitiseText((includeValue4 != null ? includeValue4.includeLocation : null)), sanitiseText((includeValue4 != null ? includeValue4.xPathQuery : null)));\n                            } catch (IncludeException ie) {\n                                ie.printStackTrace();\n                                System.out.println(ie);\n                            }\n                        }\n                        break;\n                    case 3:\n                        // net/sf/sugar/scl/SCL.g:205:12: v= unparsedIncludeValue\n                        {\n                            pushFollow(FOLLOW_unparsedIncludeValue_in_assignment247);\n                            v = unparsedIncludeValue();\n                            state._fsp--;\n                            try {\n                                this.loadUnparsedInclude(this.elements.peek(), (varName2 != null ? input.toString(varName2.start, varName2.stop) : null), v);\n                            } catch (IncludeException ie) {\n                                ie.printStackTrace();\n                            }\n                        }\n                        break;\n                    case 4:\n                        // net/sf/sugar/scl/SCL.g:212:15: r= localReference\n                        {\n                            pushFollow(FOLLOW_localReference_in_assignment267);\n                            r = localReference();\n                            state._fsp--;\n                            //todo : handle empty values, also handle non numeric, date and boolean return types\n                            prepareLocalRef(this.elements.peek(), (varName2 != null ? input.toString(varName2.start, varName2.stop) : null), r);\n                        }\n                        break;\n                }\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"assignment\"\n    public static class varName_return extends ParserRuleReturnScope {\n    }\n\n    // $ANTLR start \"varName\"\n    // net/sf/sugar/scl/SCL.g:218:1: varName : ( VALID_NAME_CHARS )+ ;\n    public final SCLParser.varName_return varName() throws RecognitionException {\n        SCLParser.varName_return retval = new SCLParser.varName_return();\n        retval.start = input.LT(1);\n        try {\n            // net/sf/sugar/scl/SCL.g:218:12: ( ( VALID_NAME_CHARS )+ )\n            // net/sf/sugar/scl/SCL.g:218:14: ( VALID_NAME_CHARS )+\n            {\n                // net/sf/sugar/scl/SCL.g:218:14: ( VALID_NAME_CHARS )+\n                int cnt9 = 0;\n                loop9: do {\n                    int alt9 = 2;\n                    switch(input.LA(1)) {\n                        case VALID_NAME_CHARS:\n                            {\n                                alt9 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt9) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:218:14: VALID_NAME_CHARS\n                            {\n                                match(input, VALID_NAME_CHARS, FOLLOW_VALID_NAME_CHARS_in_varName298);\n                            }\n                            break;\n                        default:\n                            if (cnt9 >= 1)\n                                break loop9;\n                            EarlyExitException eee = new EarlyExitException(9, input);\n                            throw eee;\n                    }\n                    cnt9++;\n                } while (true);\n            }\n            retval.stop = input.LT(-1);\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return retval;\n    }\n\n    // $ANTLR end \"varName\"\n    public static class varValue_return extends ParserRuleReturnScope {\n    }\n\n    // $ANTLR start \"varValue\"\n    // net/sf/sugar/scl/SCL.g:220:1: varValue : STRING_LITERAL ;\n    public final SCLParser.varValue_return varValue() throws RecognitionException {\n        SCLParser.varValue_return retval = new SCLParser.varValue_return();\n        retval.start = input.LT(1);\n        try {\n            // net/sf/sugar/scl/SCL.g:220:13: ( STRING_LITERAL )\n            // net/sf/sugar/scl/SCL.g:220:15: STRING_LITERAL\n            {\n                match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_varValue312);\n            }\n            retval.stop = input.LT(-1);\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return retval;\n    }\n\n    // $ANTLR end \"varValue\"\n    public static class includeValue_return extends ParserRuleReturnScope {\n\n        public String includeLocation;\n\n        public String xPathQuery;\n    }\n\n    // $ANTLR start \"includeValue\"\n    // net/sf/sugar/scl/SCL.g:223:1: includeValue returns [String includeLocation, String xPathQuery] : START_INCLUDE s1= STRING_LITERAL AS_KEYWORD s2= STRING_LITERAL END_INCLUDE ;\n    public final SCLParser.includeValue_return includeValue() throws RecognitionException {\n        SCLParser.includeValue_return retval = new SCLParser.includeValue_return();\n        retval.start = input.LT(1);\n        Token s1 = null;\n        Token s2 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:224:6: ( START_INCLUDE s1= STRING_LITERAL AS_KEYWORD s2= STRING_LITERAL END_INCLUDE )\n            // net/sf/sugar/scl/SCL.g:224:8: START_INCLUDE s1= STRING_LITERAL AS_KEYWORD s2= STRING_LITERAL END_INCLUDE\n            {\n                match(input, START_INCLUDE, FOLLOW_START_INCLUDE_in_includeValue334);\n                s1 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_includeValue338);\n                match(input, AS_KEYWORD, FOLLOW_AS_KEYWORD_in_includeValue340);\n                s2 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_includeValue344);\n                match(input, END_INCLUDE, FOLLOW_END_INCLUDE_in_includeValue346);\n                retval.includeLocation = (s1 != null ? s1.getText() : null);\n                retval.xPathQuery = (s2 != null ? s2.getText() : null);\n            }\n            retval.stop = input.LT(-1);\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return retval;\n    }\n\n    // $ANTLR end \"includeValue\"\n    // $ANTLR start \"unparsedIncludeValue\"\n    // net/sf/sugar/scl/SCL.g:229:1: unparsedIncludeValue returns [String includeLocation] : START_UNPARSED_INCLUDE s1= STRING_LITERAL END_INCLUDE ;\n    public final String unparsedIncludeValue() throws RecognitionException {\n        String includeLocation = null;\n        Token s1 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:230:6: ( START_UNPARSED_INCLUDE s1= STRING_LITERAL END_INCLUDE )\n            // net/sf/sugar/scl/SCL.g:230:8: START_UNPARSED_INCLUDE s1= STRING_LITERAL END_INCLUDE\n            {\n                match(input, START_UNPARSED_INCLUDE, FOLLOW_START_UNPARSED_INCLUDE_in_unparsedIncludeValue373);\n                s1 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_unparsedIncludeValue377);\n                match(input, END_INCLUDE, FOLLOW_END_INCLUDE_in_unparsedIncludeValue379);\n                includeLocation = stripQuotes(s1.getText());\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return includeLocation;\n    }\n\n    // $ANTLR end \"unparsedIncludeValue\"\n    // $ANTLR start \"includeTree\"\n    // net/sf/sugar/scl/SCL.g:234:1: includeTree : START_INCLUDE s1= STRING_LITERAL ( AS_KEYWORD s2= STRING_LITERAL )? END_INCLUDE ;\n    public final void includeTree() throws RecognitionException {\n        Token s1 = null;\n        Token s2 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:234:15: ( START_INCLUDE s1= STRING_LITERAL ( AS_KEYWORD s2= STRING_LITERAL )? END_INCLUDE )\n            // net/sf/sugar/scl/SCL.g:234:17: START_INCLUDE s1= STRING_LITERAL ( AS_KEYWORD s2= STRING_LITERAL )? END_INCLUDE\n            {\n                match(input, START_INCLUDE, FOLLOW_START_INCLUDE_in_includeTree399);\n                s1 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_includeTree403);\n                // net/sf/sugar/scl/SCL.g:234:49: ( AS_KEYWORD s2= STRING_LITERAL )?\n                int alt10 = 2;\n                switch(input.LA(1)) {\n                    case AS_KEYWORD:\n                        {\n                            alt10 = 1;\n                        }\n                        break;\n                }\n                switch(alt10) {\n                    case 1:\n                        // net/sf/sugar/scl/SCL.g:234:50: AS_KEYWORD s2= STRING_LITERAL\n                        {\n                            match(input, AS_KEYWORD, FOLLOW_AS_KEYWORD_in_includeTree406);\n                            s2 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_includeTree410);\n                        }\n                        break;\n                }\n                match(input, END_INCLUDE, FOLLOW_END_INCLUDE_in_includeTree414);\n                try {\n                    if (s2 == null || \"\".equals(s2)) {\n                        this.loadInclude(this.elements.peek(), sanitiseText(s1.getText()));\n                    } else {\n                        this.loadIncludeNodes(this.elements.peek(), sanitiseText(s1.getText()), sanitiseText(s2.getText()));\n                    }\n                } catch (IncludeException ie) {\n                    ie.printStackTrace();\n                }\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"includeTree\"\n    // $ANTLR start \"localRefTree\"\n    // net/sf/sugar/scl/SCL.g:250:1: localRefTree returns [String xPathQuery] : r= localReference ;\n    public final String localRefTree() throws RecognitionException {\n        String xPathQuery = null;\n        String r = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:251:7: (r= localReference )\n            // net/sf/sugar/scl/SCL.g:251:10: r= localReference\n            {\n                pushFollow(FOLLOW_localReference_in_localRefTree442);\n                r = localReference();\n                state._fsp--;\n                xPathQuery = r;\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return xPathQuery;\n    }\n\n    // $ANTLR end \"localRefTree\"\n    // $ANTLR start \"localReference\"\n    // net/sf/sugar/scl/SCL.g:253:1: localReference returns [String resolvedValue] : REF_CHAR ( WS )* STRING_LITERAL ;\n    public final String localReference() throws RecognitionException {\n        String resolvedValue = null;\n        Token STRING_LITERAL5 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:254:7: ( REF_CHAR ( WS )* STRING_LITERAL )\n            // net/sf/sugar/scl/SCL.g:254:10: REF_CHAR ( WS )* STRING_LITERAL\n            {\n                match(input, REF_CHAR, FOLLOW_REF_CHAR_in_localReference475);\n                // net/sf/sugar/scl/SCL.g:254:19: ( WS )*\n                loop11: do {\n                    int alt11 = 2;\n                    switch(input.LA(1)) {\n                        case WS:\n                            {\n                                alt11 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt11) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:254:19: WS\n                            {\n                                match(input, WS, FOLLOW_WS_in_localReference477);\n                            }\n                            break;\n                        default:\n                            break loop11;\n                    }\n                } while (true);\n                STRING_LITERAL5 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_localReference480);\n                resolvedValue = sanitiseText((STRING_LITERAL5 != null ? STRING_LITERAL5.getText() : null));\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return resolvedValue;\n    }\n\n    // $ANTLR end \"localReference\"\n    // Delegated rules\n    protected DFA2 dfa2 = new DFA2(this);\n\n    protected DFA3 dfa3 = new DFA3(this);\n\n    static final String DFA2_eotS = \"\\6\\uffff\";\n\n    static final String DFA2_eofS = \"\\6\\uffff\";\n\n    static final String DFA2_minS = \"\\2\\4\\4\\uffff\";\n\n    static final String DFA2_maxS = \"\\1\\15\\1\\23\\4\\uffff\";\n\n    static final String DFA2_acceptS = \"\\2\\uffff\\1\\3\\1\\4\\1\\1\\1\\2\";\n\n    static final String DFA2_specialS = \"\\6\\uffff}>\";\n\n    static final String[] DFA2_transitionS = { \"\\1\\1\\4\\uffff\\1\\2\\3\\uffff\\1\\3\", \"\\1\\1\\1\\4\\1\\uffff\\1\\5\\13\\uffff\\1\\4\", \"\", \"\", \"\", \"\" };\n\n    static final short[] DFA2_eot = DFA.unpackEncodedString(DFA2_eotS);\n\n    static final short[] DFA2_eof = DFA.unpackEncodedString(DFA2_eofS);\n\n    static final char[] DFA2_min = DFA.unpackEncodedStringToUnsignedChars(DFA2_minS);\n\n    static final char[] DFA2_max = DFA.unpackEncodedStringToUnsignedChars(DFA2_maxS);\n\n    static final short[] DFA2_accept = DFA.unpackEncodedString(DFA2_acceptS);\n\n    static final short[] DFA2_special = DFA.unpackEncodedString(DFA2_specialS);\n\n    static final short[][] DFA2_transition;\n\n    static {\n        int numStates = DFA2_transitionS.length;\n        DFA2_transition = new short[numStates][];\n        for (int i = 0; i < numStates; i++) {\n            DFA2_transition[i] = DFA.unpackEncodedString(DFA2_transitionS[i]);\n        }\n    }\n\n    class DFA2 extends DFA {\n\n        public DFA2(BaseRecognizer recognizer) {\n            this.recognizer = recognizer;\n            this.decisionNumber = 2;\n            this.eot = DFA2_eot;\n            this.eof = DFA2_eof;\n            this.min = DFA2_min;\n            this.max = DFA2_max;\n            this.accept = DFA2_accept;\n            this.special = DFA2_special;\n            this.transition = DFA2_transition;\n        }\n\n        public String getDescription() {\n            return \"170:1: statement : ( namespaceDecl | assignment | includeTree | t= localRefTree );\";\n        }\n    }\n\n    static final String DFA3_eotS = \"\\4\\uffff\";\n\n    static final String DFA3_eofS = \"\\4\\uffff\";\n\n    static final String DFA3_minS = \"\\2\\4\\2\\uffff\";\n\n    static final String DFA3_maxS = \"\\1\\4\\1\\23\\2\\uffff\";\n\n    static final String DFA3_acceptS = \"\\2\\uffff\\1\\1\\1\\2\";\n\n    static final String DFA3_specialS = \"\\4\\uffff}>\";\n\n    static final String[] DFA3_transitionS = { \"\\1\\1\", \"\\1\\1\\1\\2\\15\\uffff\\1\\3\", \"\", \"\" };\n\n    static final short[] DFA3_eot = DFA.unpackEncodedString(DFA3_eotS);\n\n    static final short[] DFA3_eof = DFA.unpackEncodedString(DFA3_eofS);\n\n    static final char[] DFA3_min = DFA.unpackEncodedStringToUnsignedChars(DFA3_minS);\n\n    static final char[] DFA3_max = DFA.unpackEncodedStringToUnsignedChars(DFA3_maxS);\n\n    static final short[] DFA3_accept = DFA.unpackEncodedString(DFA3_acceptS);\n\n    static final short[] DFA3_special = DFA.unpackEncodedString(DFA3_specialS);\n\n    static final short[][] DFA3_transition;\n\n    static {\n        int numStates = DFA3_transitionS.length;\n        DFA3_transition = new short[numStates][];\n        for (int i = 0; i < numStates; i++) {\n            DFA3_transition[i] = DFA.unpackEncodedString(DFA3_transitionS[i]);\n        }\n    }\n\n    class DFA3 extends DFA {\n\n        public DFA3(BaseRecognizer recognizer) {\n            this.recognizer = recognizer;\n            this.decisionNumber = 3;\n            this.eot = DFA3_eot;\n            this.eof = DFA3_eof;\n            this.min = DFA3_min;\n            this.max = DFA3_max;\n            this.accept = DFA3_accept;\n            this.special = DFA3_special;\n            this.transition = DFA3_transition;\n        }\n\n        public String getDescription() {\n            return \"179:1: namespaceName : ( varName | compositeNamespaceName );\";\n        }\n    }\n\n    public static final BitSet FOLLOW_statementSeq_in_scl44 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_statement_in_statementSeq61 = new BitSet(new long[] { 0x0000000000002212L });\n\n    public static final BitSet FOLLOW_namespaceDecl_in_statement73 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_assignment_in_statement84 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_includeTree_in_statement95 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_localRefTree_in_statement108 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_namespaceName_in_namespaceDecl120 = new BitSet(new long[] { 0x0000000000000020L });\n\n    public static final BitSet FOLLOW_namespaceBody_in_namespaceDecl122 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_varName_in_namespaceName132 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_compositeNamespaceName_in_namespaceName145 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_VALID_NAME_CHARS_in_compositeNamespaceName160 = new BitSet(new long[] { 0x0000000000080010L });\n\n    public static final BitSet FOLLOW_19_in_compositeNamespaceName164 = new BitSet(new long[] { 0x0000000000000010L });\n\n    public static final BitSet FOLLOW_VALID_NAME_CHARS_in_compositeNamespaceName166 = new BitSet(new long[] { 0x0000000000080012L });\n\n    public static final BitSet FOLLOW_OPEN_NESTING_in_namespaceBody181 = new BitSet(new long[] { 0x0000000000002250L });\n\n    public static final BitSet FOLLOW_statement_in_namespaceBody184 = new BitSet(new long[] { 0x0000000000002250L });\n\n    public static final BitSet FOLLOW_CLOSE_NESTING_in_namespaceBody188 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_varName_in_assignment201 = new BitSet(new long[] { 0x0000000000000080L });\n\n    public static final BitSet FOLLOW_ASSIGNMENT_OP_in_assignment203 = new BitSet(new long[] { 0x0000000000003310L });\n\n    public static final BitSet FOLLOW_varValue_in_assignment206 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_includeValue_in_assignment230 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_unparsedIncludeValue_in_assignment247 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_localReference_in_assignment267 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_VALID_NAME_CHARS_in_varName298 = new BitSet(new long[] { 0x0000000000000012L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_varValue312 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_START_INCLUDE_in_includeValue334 = new BitSet(new long[] { 0x0000000000000100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_includeValue338 = new BitSet(new long[] { 0x0000000000000400L });\n\n    public static final BitSet FOLLOW_AS_KEYWORD_in_includeValue340 = new BitSet(new long[] { 0x0000000000000100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_includeValue344 = new BitSet(new long[] { 0x0000000000000800L });\n\n    public static final BitSet FOLLOW_END_INCLUDE_in_includeValue346 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_START_UNPARSED_INCLUDE_in_unparsedIncludeValue373 = new BitSet(new long[] { 0x0000000000000100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_unparsedIncludeValue377 = new BitSet(new long[] { 0x0000000000000800L });\n\n    public static final BitSet FOLLOW_END_INCLUDE_in_unparsedIncludeValue379 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_START_INCLUDE_in_includeTree399 = new BitSet(new long[] { 0x0000000000000100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_includeTree403 = new BitSet(new long[] { 0x0000000000000C00L });\n\n    public static final BitSet FOLLOW_AS_KEYWORD_in_includeTree406 = new BitSet(new long[] { 0x0000000000000100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_includeTree410 = new BitSet(new long[] { 0x0000000000000800L });\n\n    public static final BitSet FOLLOW_END_INCLUDE_in_includeTree414 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_localReference_in_localRefTree442 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_REF_CHAR_in_localReference475 = new BitSet(new long[] { 0x0000000000004100L });\n\n    public static final BitSet FOLLOW_WS_in_localReference477 = new BitSet(new long[] { 0x0000000000004100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_localReference480 = new BitSet(new long[] { 0x0000000000000002L });\n}\n",
		"id": "/EvoSuiteBenchmark/60_sugar/src/main/java/net/sf/sugar/scl/SCLParser_3Test.java",
		"test_prompt": "// SCLParser_3Test.java\npackage net.sf.sugar.scl;\n\nimport static net.sf.sugar.scl.PathConversionUtils.convertToXPath;\nimport static net.sf.sugar.scl.PathConversionUtils.processDotDelimitedPath;\nimport java.net.URI;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Element;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathFactory;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpressionException;\nimport org.antlr.runtime.*;\nimport java.util.Stack;\nimport java.util.List;\nimport java.util.ArrayList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SCLParser}.\n* It contains ten unit test cases for the {@link SCLParser#compositeNamespaceName()} method.\n*/\nclass SCLParser_3Test {"
	},
	{
		"original_code": "// SCLParser.java\n// $ANTLR 3.3 Nov 30, 2010 12:46:29 net/sf/sugar/scl/SCL.g 2013-06-10 17:15:03\npackage net.sf.sugar.scl;\n\nimport static net.sf.sugar.scl.PathConversionUtils.convertToXPath;\nimport static net.sf.sugar.scl.PathConversionUtils.processDotDelimitedPath;\nimport java.net.URI;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Element;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathFactory;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpressionException;\nimport org.antlr.runtime.*;\nimport java.util.Stack;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class SCLParser extends Parser {\n\n    public static final String[] tokenNames = new String[] { \"<invalid>\", \"<EOR>\", \"<DOWN>\", \"<UP>\", \"VALID_NAME_CHARS\", \"OPEN_NESTING\", \"CLOSE_NESTING\", \"ASSIGNMENT_OP\", \"STRING_LITERAL\", \"START_INCLUDE\", \"AS_KEYWORD\", \"END_INCLUDE\", \"START_UNPARSED_INCLUDE\", \"REF_CHAR\", \"WS\", \"QUOTE\", \"STRING_SEQUENCE_CHAR\", \"COMMENT\", \"LINE_COMMENT\", \"'.'\" };\n\n    public static final int EOF = -1;\n\n    public static final int T__19 = 19;\n\n    public static final int VALID_NAME_CHARS = 4;\n\n    public static final int OPEN_NESTING = 5;\n\n    public static final int CLOSE_NESTING = 6;\n\n    public static final int ASSIGNMENT_OP = 7;\n\n    public static final int STRING_LITERAL = 8;\n\n    public static final int START_INCLUDE = 9;\n\n    public static final int AS_KEYWORD = 10;\n\n    public static final int END_INCLUDE = 11;\n\n    public static final int START_UNPARSED_INCLUDE = 12;\n\n    public static final int REF_CHAR = 13;\n\n    public static final int WS = 14;\n\n    public static final int QUOTE = 15;\n\n    public static final int STRING_SEQUENCE_CHAR = 16;\n\n    public static final int COMMENT = 17;\n\n    public static final int LINE_COMMENT = 18;\n\n    // delegates\n    // delegators\n    public SCLParser(TokenStream input) {\n        this(input, new RecognizerSharedState());\n    }\n\n    public SCLParser(TokenStream input, RecognizerSharedState state) {\n        super(input, state);\n    }\n\n    public String[] getTokenNames() {\n        return SCLParser.tokenNames;\n    }\n\n    public String getGrammarFileName() {\n        return \"net/sf/sugar/scl/SCL.g\";\n    }\n\n    public static final String SCL_ROOT_ELEMENT = \"scl\";\n\n    private URI rootSCLFile;\n\n    private Document doc;\n\n    private Stack<Element> elements = new Stack<Element>();\n\n    private XPath xpath = XPathFactory.newInstance().newXPath();\n\n    private IncludeProcessor includeProcessor;\n\n    private static LocalReferenceProcessor localReferenceProcessor;\n\n    private List<LocalReference> localRefs = new ArrayList<LocalReference>();\n\n    private int namespaceSteps;\n\n    {\n        try {\n            doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n            Element rootElement = doc.createElement(SCL_ROOT_ELEMENT);\n            doc.appendChild(rootElement);\n            this.elements.push(rootElement);\n        } catch (ParserConfigurationException pce) {\n            pce.printStackTrace();\n        }\n    }\n\n    protected Element addChildElement(Element element, String child) {\n        Element childElement = this.doc.createElement(child);\n        element.appendChild(childElement);\n        return childElement;\n    }\n\n    protected Element addChildElements(Element currentElement, String compositePath) {\n        return processDotDelimitedPath(currentElement, compositePath);\n    }\n\n    protected void addAttribute(Element currentElement, String attributeName, String attributeValue) {\n        Element childElement = this.doc.createElement(attributeName);\n        childElement.setTextContent(attributeValue);\n        currentElement.appendChild(childElement);\n    }\n\n    protected void loadIncludeValue(Element parentElement, String propertyName, String includeLocation, String xPathExpression) throws IncludeException {\n        this.includeProcessor.prepareIncludeValue(parentElement, propertyName, includeLocation, this.rootSCLFile, xPathExpression);\n    }\n\n    protected void loadInclude(Element parentElement, String includeLocation) throws IncludeException {\n        this.includeProcessor.prepareInclude(parentElement, includeLocation, this.rootSCLFile);\n    }\n\n    protected void loadIncludeNodes(Element parentElement, String includeLocation, String xPathExpression) throws IncludeException {\n        this.includeProcessor.prepareInclude(parentElement, includeLocation, this.rootSCLFile, xPathExpression);\n    }\n\n    protected void loadUnparsedInclude(Element parentElement, String propertyName, String includeLocation) throws IncludeException {\n        this.includeProcessor.loadUnparsedInclude(parentElement, propertyName, includeLocation, this.rootSCLFile);\n    }\n\n    protected void prepareLocalRefTree(final Element parentElement, final String xPathExpression) {\n        LocalReference localRef = new LocalReference() {\n\n            {\n                setParentElement(parentElement);\n                setXPathQuery(xPathExpression);\n            }\n        };\n        this.localRefs.add(localRef);\n    }\n\n    protected void prepareLocalRef(final Element parentElement, final String attributeName, final String xPathExpression) {\n        LocalAttributeReference localRef = new LocalAttributeReference() {\n\n            {\n                setParentElement(parentElement);\n                setXPathQuery(xPathExpression);\n                setAttributeName(attributeName);\n            }\n        };\n        this.localRefs.add(localRef);\n    }\n\n    public void setRootSCLFile(URI rootSCLFile) {\n        this.rootSCLFile = rootSCLFile;\n    }\n\n    public URI getRootSCLFile() {\n        return this.rootSCLFile;\n    }\n\n    public Document getRootDocument() {\n        return this.doc;\n    }\n\n    public void setIncludeProcessor(IncludeProcessor includeProcessor) {\n        this.includeProcessor = includeProcessor;\n    }\n\n    public IncludeProcessor getIncludeProcessor() {\n        return this.includeProcessor;\n    }\n\n    public void setLocalReferenceProcessor(LocalReferenceProcessor processor) {\n        localReferenceProcessor = processor;\n    }\n\n    public LocalReferenceProcessor getLocalReferenceProcessor() {\n        return localReferenceProcessor;\n    }\n\n    public List<LocalReference> getLocalRefs() {\n        return this.localRefs;\n    }\n\n    public String sanitiseText(String rawText) {\n        String unquotedText = stripQuotes(rawText);\n        return normaliseEscapeChars(unquotedText);\n    }\n\n    private String stripQuotes(String quotedText) {\n        return quotedText.substring(1, quotedText.length() - 1);\n    }\n\n    private String normaliseEscapeChars(String text) {\n        return text.replace(\"\\\\\\\\\", \"\\\\\").replace(\"\\\\\\\"\", \"\\\"\");\n    }\n\n    // $ANTLR start \"scl\"\n    // net/sf/sugar/scl/SCL.g:152:1: scl returns [Document properties] : statementSeq ;\n    public final Document scl() throws RecognitionException {\n        Document properties = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:153:6: ( statementSeq )\n            // net/sf/sugar/scl/SCL.g:153:8: statementSeq\n            {\n                pushFollow(FOLLOW_statementSeq_in_scl44);\n                statementSeq();\n                state._fsp--;\n                try {\n                    this.includeProcessor.resolveIncludes(this.doc);\n                    localReferenceProcessor.processLocalReferences(this.localRefs);\n                } catch (IncludeException ie) {\n                    ie.printStackTrace();\n                } catch (LocalReferenceException lre) {\n                    lre.printStackTrace();\n                }\n                properties = doc;\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return properties;\n    }\n\n    // $ANTLR end \"scl\"\n    // $ANTLR start \"statementSeq\"\n    // net/sf/sugar/scl/SCL.g:168:1: statementSeq : ( statement )+ ;\n    public final void statementSeq() throws RecognitionException {\n        try {\n            // net/sf/sugar/scl/SCL.g:168:15: ( ( statement )+ )\n            // net/sf/sugar/scl/SCL.g:168:17: ( statement )+\n            {\n                // net/sf/sugar/scl/SCL.g:168:17: ( statement )+\n                int cnt1 = 0;\n                loop1: do {\n                    int alt1 = 2;\n                    switch(input.LA(1)) {\n                        case VALID_NAME_CHARS:\n                        case START_INCLUDE:\n                        case REF_CHAR:\n                            {\n                                alt1 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt1) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:168:17: statement\n                            {\n                                pushFollow(FOLLOW_statement_in_statementSeq61);\n                                statement();\n                                state._fsp--;\n                            }\n                            break;\n                        default:\n                            if (cnt1 >= 1)\n                                break loop1;\n                            EarlyExitException eee = new EarlyExitException(1, input);\n                            throw eee;\n                    }\n                    cnt1++;\n                } while (true);\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"statementSeq\"\n    // $ANTLR start \"statement\"\n    // net/sf/sugar/scl/SCL.g:170:1: statement : ( namespaceDecl | assignment | includeTree | t= localRefTree );\n    public final void statement() throws RecognitionException {\n        String t = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:170:13: ( namespaceDecl | assignment | includeTree | t= localRefTree )\n            int alt2 = 4;\n            alt2 = dfa2.predict(input);\n            switch(alt2) {\n                case 1:\n                    // net/sf/sugar/scl/SCL.g:170:15: namespaceDecl\n                    {\n                        pushFollow(FOLLOW_namespaceDecl_in_statement73);\n                        namespaceDecl();\n                        state._fsp--;\n                    }\n                    break;\n                case 2:\n                    // net/sf/sugar/scl/SCL.g:171:9: assignment\n                    {\n                        pushFollow(FOLLOW_assignment_in_statement84);\n                        assignment();\n                        state._fsp--;\n                    }\n                    break;\n                case 3:\n                    // net/sf/sugar/scl/SCL.g:172:9: includeTree\n                    {\n                        pushFollow(FOLLOW_includeTree_in_statement95);\n                        includeTree();\n                        state._fsp--;\n                    }\n                    break;\n                case 4:\n                    // net/sf/sugar/scl/SCL.g:173:9: t= localRefTree\n                    {\n                        pushFollow(FOLLOW_localRefTree_in_statement108);\n                        t = localRefTree();\n                        state._fsp--;\n                        prepareLocalRefTree(this.elements.peek(), t);\n                    }\n                    break;\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"statement\"\n    // $ANTLR start \"namespaceDecl\"\n    // net/sf/sugar/scl/SCL.g:177:1: namespaceDecl : namespaceName namespaceBody ;\n    public final void namespaceDecl() throws RecognitionException {\n        try {\n            // net/sf/sugar/scl/SCL.g:177:16: ( namespaceName namespaceBody )\n            // net/sf/sugar/scl/SCL.g:177:18: namespaceName namespaceBody\n            {\n                pushFollow(FOLLOW_namespaceName_in_namespaceDecl120);\n                namespaceName();\n                state._fsp--;\n                pushFollow(FOLLOW_namespaceBody_in_namespaceDecl122);\n                namespaceBody();\n                state._fsp--;\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"namespaceDecl\"\n    public static class namespaceName_return extends ParserRuleReturnScope {\n    }\n\n    // $ANTLR start \"namespaceName\"\n    // net/sf/sugar/scl/SCL.g:179:1: namespaceName : ( varName | compositeNamespaceName );\n    public final SCLParser.namespaceName_return namespaceName() throws RecognitionException {\n        SCLParser.namespaceName_return retval = new SCLParser.namespaceName_return();\n        retval.start = input.LT(1);\n        SCLParser.compositeNamespaceName_return compositeNamespaceName1 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:179:16: ( varName | compositeNamespaceName )\n            int alt3 = 2;\n            alt3 = dfa3.predict(input);\n            switch(alt3) {\n                case 1:\n                    // net/sf/sugar/scl/SCL.g:179:18: varName\n                    {\n                        pushFollow(FOLLOW_varName_in_namespaceName132);\n                        varName();\n                        state._fsp--;\n                        this.elements.push(addChildElement(this.elements.peek(), input.toString(retval.start, input.LT(-1))));\n                    }\n                    break;\n                case 2:\n                    // net/sf/sugar/scl/SCL.g:180:9: compositeNamespaceName\n                    {\n                        pushFollow(FOLLOW_compositeNamespaceName_in_namespaceName145);\n                        compositeNamespaceName1 = compositeNamespaceName();\n                        state._fsp--;\n                        this.elements.push(addChildElements(this.elements.peek(), (compositeNamespaceName1 != null ? input.toString(compositeNamespaceName1.start, compositeNamespaceName1.stop) : null)));\n                    }\n                    break;\n            }\n            retval.stop = input.LT(-1);\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return retval;\n    }\n\n    // $ANTLR end \"namespaceName\"\n    public static class compositeNamespaceName_return extends ParserRuleReturnScope {\n    }\n\n    // $ANTLR start \"compositeNamespaceName\"\n    // net/sf/sugar/scl/SCL.g:182:1: compositeNamespaceName : ( VALID_NAME_CHARS )+ ( '.' ( VALID_NAME_CHARS )+ )+ ;\n    public final SCLParser.compositeNamespaceName_return compositeNamespaceName() throws RecognitionException {\n        SCLParser.compositeNamespaceName_return retval = new SCLParser.compositeNamespaceName_return();\n        retval.start = input.LT(1);\n        try {\n            // net/sf/sugar/scl/SCL.g:182:24: ( ( VALID_NAME_CHARS )+ ( '.' ( VALID_NAME_CHARS )+ )+ )\n            // net/sf/sugar/scl/SCL.g:182:28: ( VALID_NAME_CHARS )+ ( '.' ( VALID_NAME_CHARS )+ )+\n            {\n                // net/sf/sugar/scl/SCL.g:182:28: ( VALID_NAME_CHARS )+\n                int cnt4 = 0;\n                loop4: do {\n                    int alt4 = 2;\n                    switch(input.LA(1)) {\n                        case VALID_NAME_CHARS:\n                            {\n                                alt4 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt4) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:182:28: VALID_NAME_CHARS\n                            {\n                                match(input, VALID_NAME_CHARS, FOLLOW_VALID_NAME_CHARS_in_compositeNamespaceName160);\n                            }\n                            break;\n                        default:\n                            if (cnt4 >= 1)\n                                break loop4;\n                            EarlyExitException eee = new EarlyExitException(4, input);\n                            throw eee;\n                    }\n                    cnt4++;\n                } while (true);\n                // net/sf/sugar/scl/SCL.g:182:46: ( '.' ( VALID_NAME_CHARS )+ )+\n                int cnt6 = 0;\n                loop6: do {\n                    int alt6 = 2;\n                    switch(input.LA(1)) {\n                        case 19:\n                            {\n                                alt6 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt6) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:182:47: '.' ( VALID_NAME_CHARS )+\n                            {\n                                match(input, 19, FOLLOW_19_in_compositeNamespaceName164);\n                                // net/sf/sugar/scl/SCL.g:182:51: ( VALID_NAME_CHARS )+\n                                int cnt5 = 0;\n                                loop5: do {\n                                    int alt5 = 2;\n                                    switch(input.LA(1)) {\n                                        case VALID_NAME_CHARS:\n                                            {\n                                                alt5 = 1;\n                                            }\n                                            break;\n                                    }\n                                    switch(alt5) {\n                                        case 1:\n                                            // net/sf/sugar/scl/SCL.g:182:51: VALID_NAME_CHARS\n                                            {\n                                                match(input, VALID_NAME_CHARS, FOLLOW_VALID_NAME_CHARS_in_compositeNamespaceName166);\n                                            }\n                                            break;\n                                        default:\n                                            if (cnt5 >= 1)\n                                                break loop5;\n                                            EarlyExitException eee = new EarlyExitException(5, input);\n                                            throw eee;\n                                    }\n                                    cnt5++;\n                                } while (true);\n                            }\n                            break;\n                        default:\n                            if (cnt6 >= 1)\n                                break loop6;\n                            EarlyExitException eee = new EarlyExitException(6, input);\n                            throw eee;\n                    }\n                    cnt6++;\n                } while (true);\n            }\n            retval.stop = input.LT(-1);\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return retval;\n    }\n\n    // $ANTLR end \"compositeNamespaceName\"\n    // $ANTLR start \"namespaceBody\"\n    // net/sf/sugar/scl/SCL.g:184:1: namespaceBody : OPEN_NESTING ( statement )* CLOSE_NESTING ;\n    public final void namespaceBody() throws RecognitionException {\n        try {\n            // net/sf/sugar/scl/SCL.g:184:16: ( OPEN_NESTING ( statement )* CLOSE_NESTING )\n            // net/sf/sugar/scl/SCL.g:184:18: OPEN_NESTING ( statement )* CLOSE_NESTING\n            {\n                match(input, OPEN_NESTING, FOLLOW_OPEN_NESTING_in_namespaceBody181);\n                // net/sf/sugar/scl/SCL.g:184:31: ( statement )*\n                loop7: do {\n                    int alt7 = 2;\n                    switch(input.LA(1)) {\n                        case VALID_NAME_CHARS:\n                        case START_INCLUDE:\n                        case REF_CHAR:\n                            {\n                                alt7 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt7) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:184:32: statement\n                            {\n                                pushFollow(FOLLOW_statement_in_namespaceBody184);\n                                statement();\n                                state._fsp--;\n                            }\n                            break;\n                        default:\n                            break loop7;\n                    }\n                } while (true);\n                match(input, CLOSE_NESTING, FOLLOW_CLOSE_NESTING_in_namespaceBody188);\n                this.elements.pop();\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"namespaceBody\"\n    // $ANTLR start \"assignment\"\n    // net/sf/sugar/scl/SCL.g:188:1: assignment : varName ASSIGNMENT_OP ( varValue | includeValue | v= unparsedIncludeValue | r= localReference ) ;\n    public final void assignment() throws RecognitionException {\n        String v = null;\n        String r = null;\n        SCLParser.varName_return varName2 = null;\n        SCLParser.varValue_return varValue3 = null;\n        SCLParser.includeValue_return includeValue4 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:188:14: ( varName ASSIGNMENT_OP ( varValue | includeValue | v= unparsedIncludeValue | r= localReference ) )\n            // net/sf/sugar/scl/SCL.g:188:16: varName ASSIGNMENT_OP ( varValue | includeValue | v= unparsedIncludeValue | r= localReference )\n            {\n                pushFollow(FOLLOW_varName_in_assignment201);\n                varName2 = varName();\n                state._fsp--;\n                match(input, ASSIGNMENT_OP, FOLLOW_ASSIGNMENT_OP_in_assignment203);\n                // net/sf/sugar/scl/SCL.g:188:38: ( varValue | includeValue | v= unparsedIncludeValue | r= localReference )\n                int alt8 = 4;\n                switch(input.LA(1)) {\n                    case STRING_LITERAL:\n                        {\n                            alt8 = 1;\n                        }\n                        break;\n                    case START_INCLUDE:\n                        {\n                            alt8 = 2;\n                        }\n                        break;\n                    case START_UNPARSED_INCLUDE:\n                        {\n                            alt8 = 3;\n                        }\n                        break;\n                    case REF_CHAR:\n                        {\n                            alt8 = 4;\n                        }\n                        break;\n                    default:\n                        NoViableAltException nvae = new NoViableAltException(\"\", 8, 0, input);\n                        throw nvae;\n                }\n                switch(alt8) {\n                    case 1:\n                        // net/sf/sugar/scl/SCL.g:188:39: varValue\n                        {\n                            pushFollow(FOLLOW_varValue_in_assignment206);\n                            varValue3 = varValue();\n                            state._fsp--;\n                            addAttribute(this.elements.peek(), (varName2 != null ? input.toString(varName2.start, varName2.stop) : null), sanitiseText((varValue3 != null ? input.toString(varValue3.start, varValue3.stop) : null)));\n                        }\n                        break;\n                    case 2:\n                        // net/sf/sugar/scl/SCL.g:194:14: includeValue\n                        {\n                            pushFollow(FOLLOW_includeValue_in_assignment230);\n                            includeValue4 = includeValue();\n                            state._fsp--;\n                            try {\n                                this.loadIncludeValue(this.elements.peek(), (varName2 != null ? input.toString(varName2.start, varName2.stop) : null), sanitiseText((includeValue4 != null ? includeValue4.includeLocation : null)), sanitiseText((includeValue4 != null ? includeValue4.xPathQuery : null)));\n                            } catch (IncludeException ie) {\n                                ie.printStackTrace();\n                                System.out.println(ie);\n                            }\n                        }\n                        break;\n                    case 3:\n                        // net/sf/sugar/scl/SCL.g:205:12: v= unparsedIncludeValue\n                        {\n                            pushFollow(FOLLOW_unparsedIncludeValue_in_assignment247);\n                            v = unparsedIncludeValue();\n                            state._fsp--;\n                            try {\n                                this.loadUnparsedInclude(this.elements.peek(), (varName2 != null ? input.toString(varName2.start, varName2.stop) : null), v);\n                            } catch (IncludeException ie) {\n                                ie.printStackTrace();\n                            }\n                        }\n                        break;\n                    case 4:\n                        // net/sf/sugar/scl/SCL.g:212:15: r= localReference\n                        {\n                            pushFollow(FOLLOW_localReference_in_assignment267);\n                            r = localReference();\n                            state._fsp--;\n                            //todo : handle empty values, also handle non numeric, date and boolean return types\n                            prepareLocalRef(this.elements.peek(), (varName2 != null ? input.toString(varName2.start, varName2.stop) : null), r);\n                        }\n                        break;\n                }\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"assignment\"\n    public static class varName_return extends ParserRuleReturnScope {\n    }\n\n    // $ANTLR start \"varName\"\n    // net/sf/sugar/scl/SCL.g:218:1: varName : ( VALID_NAME_CHARS )+ ;\n    public final SCLParser.varName_return varName() throws RecognitionException {\n        SCLParser.varName_return retval = new SCLParser.varName_return();\n        retval.start = input.LT(1);\n        try {\n            // net/sf/sugar/scl/SCL.g:218:12: ( ( VALID_NAME_CHARS )+ )\n            // net/sf/sugar/scl/SCL.g:218:14: ( VALID_NAME_CHARS )+\n            {\n                // net/sf/sugar/scl/SCL.g:218:14: ( VALID_NAME_CHARS )+\n                int cnt9 = 0;\n                loop9: do {\n                    int alt9 = 2;\n                    switch(input.LA(1)) {\n                        case VALID_NAME_CHARS:\n                            {\n                                alt9 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt9) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:218:14: VALID_NAME_CHARS\n                            {\n                                match(input, VALID_NAME_CHARS, FOLLOW_VALID_NAME_CHARS_in_varName298);\n                            }\n                            break;\n                        default:\n                            if (cnt9 >= 1)\n                                break loop9;\n                            EarlyExitException eee = new EarlyExitException(9, input);\n                            throw eee;\n                    }\n                    cnt9++;\n                } while (true);\n            }\n            retval.stop = input.LT(-1);\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return retval;\n    }\n\n    // $ANTLR end \"varName\"\n    public static class varValue_return extends ParserRuleReturnScope {\n    }\n\n    // $ANTLR start \"varValue\"\n    // net/sf/sugar/scl/SCL.g:220:1: varValue : STRING_LITERAL ;\n    public final SCLParser.varValue_return varValue() throws RecognitionException {\n        SCLParser.varValue_return retval = new SCLParser.varValue_return();\n        retval.start = input.LT(1);\n        try {\n            // net/sf/sugar/scl/SCL.g:220:13: ( STRING_LITERAL )\n            // net/sf/sugar/scl/SCL.g:220:15: STRING_LITERAL\n            {\n                match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_varValue312);\n            }\n            retval.stop = input.LT(-1);\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return retval;\n    }\n\n    // $ANTLR end \"varValue\"\n    public static class includeValue_return extends ParserRuleReturnScope {\n\n        public String includeLocation;\n\n        public String xPathQuery;\n    }\n\n    // $ANTLR start \"includeValue\"\n    // net/sf/sugar/scl/SCL.g:223:1: includeValue returns [String includeLocation, String xPathQuery] : START_INCLUDE s1= STRING_LITERAL AS_KEYWORD s2= STRING_LITERAL END_INCLUDE ;\n    public final SCLParser.includeValue_return includeValue() throws RecognitionException {\n        SCLParser.includeValue_return retval = new SCLParser.includeValue_return();\n        retval.start = input.LT(1);\n        Token s1 = null;\n        Token s2 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:224:6: ( START_INCLUDE s1= STRING_LITERAL AS_KEYWORD s2= STRING_LITERAL END_INCLUDE )\n            // net/sf/sugar/scl/SCL.g:224:8: START_INCLUDE s1= STRING_LITERAL AS_KEYWORD s2= STRING_LITERAL END_INCLUDE\n            {\n                match(input, START_INCLUDE, FOLLOW_START_INCLUDE_in_includeValue334);\n                s1 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_includeValue338);\n                match(input, AS_KEYWORD, FOLLOW_AS_KEYWORD_in_includeValue340);\n                s2 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_includeValue344);\n                match(input, END_INCLUDE, FOLLOW_END_INCLUDE_in_includeValue346);\n                retval.includeLocation = (s1 != null ? s1.getText() : null);\n                retval.xPathQuery = (s2 != null ? s2.getText() : null);\n            }\n            retval.stop = input.LT(-1);\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return retval;\n    }\n\n    // $ANTLR end \"includeValue\"\n    // $ANTLR start \"unparsedIncludeValue\"\n    // net/sf/sugar/scl/SCL.g:229:1: unparsedIncludeValue returns [String includeLocation] : START_UNPARSED_INCLUDE s1= STRING_LITERAL END_INCLUDE ;\n    public final String unparsedIncludeValue() throws RecognitionException {\n        String includeLocation = null;\n        Token s1 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:230:6: ( START_UNPARSED_INCLUDE s1= STRING_LITERAL END_INCLUDE )\n            // net/sf/sugar/scl/SCL.g:230:8: START_UNPARSED_INCLUDE s1= STRING_LITERAL END_INCLUDE\n            {\n                match(input, START_UNPARSED_INCLUDE, FOLLOW_START_UNPARSED_INCLUDE_in_unparsedIncludeValue373);\n                s1 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_unparsedIncludeValue377);\n                match(input, END_INCLUDE, FOLLOW_END_INCLUDE_in_unparsedIncludeValue379);\n                includeLocation = stripQuotes(s1.getText());\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return includeLocation;\n    }\n\n    // $ANTLR end \"unparsedIncludeValue\"\n    // $ANTLR start \"includeTree\"\n    // net/sf/sugar/scl/SCL.g:234:1: includeTree : START_INCLUDE s1= STRING_LITERAL ( AS_KEYWORD s2= STRING_LITERAL )? END_INCLUDE ;\n    public final void includeTree() throws RecognitionException {\n        Token s1 = null;\n        Token s2 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:234:15: ( START_INCLUDE s1= STRING_LITERAL ( AS_KEYWORD s2= STRING_LITERAL )? END_INCLUDE )\n            // net/sf/sugar/scl/SCL.g:234:17: START_INCLUDE s1= STRING_LITERAL ( AS_KEYWORD s2= STRING_LITERAL )? END_INCLUDE\n            {\n                match(input, START_INCLUDE, FOLLOW_START_INCLUDE_in_includeTree399);\n                s1 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_includeTree403);\n                // net/sf/sugar/scl/SCL.g:234:49: ( AS_KEYWORD s2= STRING_LITERAL )?\n                int alt10 = 2;\n                switch(input.LA(1)) {\n                    case AS_KEYWORD:\n                        {\n                            alt10 = 1;\n                        }\n                        break;\n                }\n                switch(alt10) {\n                    case 1:\n                        // net/sf/sugar/scl/SCL.g:234:50: AS_KEYWORD s2= STRING_LITERAL\n                        {\n                            match(input, AS_KEYWORD, FOLLOW_AS_KEYWORD_in_includeTree406);\n                            s2 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_includeTree410);\n                        }\n                        break;\n                }\n                match(input, END_INCLUDE, FOLLOW_END_INCLUDE_in_includeTree414);\n                try {\n                    if (s2 == null || \"\".equals(s2)) {\n                        this.loadInclude(this.elements.peek(), sanitiseText(s1.getText()));\n                    } else {\n                        this.loadIncludeNodes(this.elements.peek(), sanitiseText(s1.getText()), sanitiseText(s2.getText()));\n                    }\n                } catch (IncludeException ie) {\n                    ie.printStackTrace();\n                }\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"includeTree\"\n    // $ANTLR start \"localRefTree\"\n    // net/sf/sugar/scl/SCL.g:250:1: localRefTree returns [String xPathQuery] : r= localReference ;\n    public final String localRefTree() throws RecognitionException {\n        String xPathQuery = null;\n        String r = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:251:7: (r= localReference )\n            // net/sf/sugar/scl/SCL.g:251:10: r= localReference\n            {\n                pushFollow(FOLLOW_localReference_in_localRefTree442);\n                r = localReference();\n                state._fsp--;\n                xPathQuery = r;\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return xPathQuery;\n    }\n\n    // $ANTLR end \"localRefTree\"\n    // $ANTLR start \"localReference\"\n    // net/sf/sugar/scl/SCL.g:253:1: localReference returns [String resolvedValue] : REF_CHAR ( WS )* STRING_LITERAL ;\n    public final String localReference() throws RecognitionException {\n        String resolvedValue = null;\n        Token STRING_LITERAL5 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:254:7: ( REF_CHAR ( WS )* STRING_LITERAL )\n            // net/sf/sugar/scl/SCL.g:254:10: REF_CHAR ( WS )* STRING_LITERAL\n            {\n                match(input, REF_CHAR, FOLLOW_REF_CHAR_in_localReference475);\n                // net/sf/sugar/scl/SCL.g:254:19: ( WS )*\n                loop11: do {\n                    int alt11 = 2;\n                    switch(input.LA(1)) {\n                        case WS:\n                            {\n                                alt11 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt11) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:254:19: WS\n                            {\n                                match(input, WS, FOLLOW_WS_in_localReference477);\n                            }\n                            break;\n                        default:\n                            break loop11;\n                    }\n                } while (true);\n                STRING_LITERAL5 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_localReference480);\n                resolvedValue = sanitiseText((STRING_LITERAL5 != null ? STRING_LITERAL5.getText() : null));\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return resolvedValue;\n    }\n\n    // $ANTLR end \"localReference\"\n    // Delegated rules\n    protected DFA2 dfa2 = new DFA2(this);\n\n    protected DFA3 dfa3 = new DFA3(this);\n\n    static final String DFA2_eotS = \"\\6\\uffff\";\n\n    static final String DFA2_eofS = \"\\6\\uffff\";\n\n    static final String DFA2_minS = \"\\2\\4\\4\\uffff\";\n\n    static final String DFA2_maxS = \"\\1\\15\\1\\23\\4\\uffff\";\n\n    static final String DFA2_acceptS = \"\\2\\uffff\\1\\3\\1\\4\\1\\1\\1\\2\";\n\n    static final String DFA2_specialS = \"\\6\\uffff}>\";\n\n    static final String[] DFA2_transitionS = { \"\\1\\1\\4\\uffff\\1\\2\\3\\uffff\\1\\3\", \"\\1\\1\\1\\4\\1\\uffff\\1\\5\\13\\uffff\\1\\4\", \"\", \"\", \"\", \"\" };\n\n    static final short[] DFA2_eot = DFA.unpackEncodedString(DFA2_eotS);\n\n    static final short[] DFA2_eof = DFA.unpackEncodedString(DFA2_eofS);\n\n    static final char[] DFA2_min = DFA.unpackEncodedStringToUnsignedChars(DFA2_minS);\n\n    static final char[] DFA2_max = DFA.unpackEncodedStringToUnsignedChars(DFA2_maxS);\n\n    static final short[] DFA2_accept = DFA.unpackEncodedString(DFA2_acceptS);\n\n    static final short[] DFA2_special = DFA.unpackEncodedString(DFA2_specialS);\n\n    static final short[][] DFA2_transition;\n\n    static {\n        int numStates = DFA2_transitionS.length;\n        DFA2_transition = new short[numStates][];\n        for (int i = 0; i < numStates; i++) {\n            DFA2_transition[i] = DFA.unpackEncodedString(DFA2_transitionS[i]);\n        }\n    }\n\n    class DFA2 extends DFA {\n\n        public DFA2(BaseRecognizer recognizer) {\n            this.recognizer = recognizer;\n            this.decisionNumber = 2;\n            this.eot = DFA2_eot;\n            this.eof = DFA2_eof;\n            this.min = DFA2_min;\n            this.max = DFA2_max;\n            this.accept = DFA2_accept;\n            this.special = DFA2_special;\n            this.transition = DFA2_transition;\n        }\n\n        public String getDescription() {\n            return \"170:1: statement : ( namespaceDecl | assignment | includeTree | t= localRefTree );\";\n        }\n    }\n\n    static final String DFA3_eotS = \"\\4\\uffff\";\n\n    static final String DFA3_eofS = \"\\4\\uffff\";\n\n    static final String DFA3_minS = \"\\2\\4\\2\\uffff\";\n\n    static final String DFA3_maxS = \"\\1\\4\\1\\23\\2\\uffff\";\n\n    static final String DFA3_acceptS = \"\\2\\uffff\\1\\1\\1\\2\";\n\n    static final String DFA3_specialS = \"\\4\\uffff}>\";\n\n    static final String[] DFA3_transitionS = { \"\\1\\1\", \"\\1\\1\\1\\2\\15\\uffff\\1\\3\", \"\", \"\" };\n\n    static final short[] DFA3_eot = DFA.unpackEncodedString(DFA3_eotS);\n\n    static final short[] DFA3_eof = DFA.unpackEncodedString(DFA3_eofS);\n\n    static final char[] DFA3_min = DFA.unpackEncodedStringToUnsignedChars(DFA3_minS);\n\n    static final char[] DFA3_max = DFA.unpackEncodedStringToUnsignedChars(DFA3_maxS);\n\n    static final short[] DFA3_accept = DFA.unpackEncodedString(DFA3_acceptS);\n\n    static final short[] DFA3_special = DFA.unpackEncodedString(DFA3_specialS);\n\n    static final short[][] DFA3_transition;\n\n    static {\n        int numStates = DFA3_transitionS.length;\n        DFA3_transition = new short[numStates][];\n        for (int i = 0; i < numStates; i++) {\n            DFA3_transition[i] = DFA.unpackEncodedString(DFA3_transitionS[i]);\n        }\n    }\n\n    class DFA3 extends DFA {\n\n        public DFA3(BaseRecognizer recognizer) {\n            this.recognizer = recognizer;\n            this.decisionNumber = 3;\n            this.eot = DFA3_eot;\n            this.eof = DFA3_eof;\n            this.min = DFA3_min;\n            this.max = DFA3_max;\n            this.accept = DFA3_accept;\n            this.special = DFA3_special;\n            this.transition = DFA3_transition;\n        }\n\n        public String getDescription() {\n            return \"179:1: namespaceName : ( varName | compositeNamespaceName );\";\n        }\n    }\n\n    public static final BitSet FOLLOW_statementSeq_in_scl44 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_statement_in_statementSeq61 = new BitSet(new long[] { 0x0000000000002212L });\n\n    public static final BitSet FOLLOW_namespaceDecl_in_statement73 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_assignment_in_statement84 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_includeTree_in_statement95 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_localRefTree_in_statement108 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_namespaceName_in_namespaceDecl120 = new BitSet(new long[] { 0x0000000000000020L });\n\n    public static final BitSet FOLLOW_namespaceBody_in_namespaceDecl122 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_varName_in_namespaceName132 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_compositeNamespaceName_in_namespaceName145 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_VALID_NAME_CHARS_in_compositeNamespaceName160 = new BitSet(new long[] { 0x0000000000080010L });\n\n    public static final BitSet FOLLOW_19_in_compositeNamespaceName164 = new BitSet(new long[] { 0x0000000000000010L });\n\n    public static final BitSet FOLLOW_VALID_NAME_CHARS_in_compositeNamespaceName166 = new BitSet(new long[] { 0x0000000000080012L });\n\n    public static final BitSet FOLLOW_OPEN_NESTING_in_namespaceBody181 = new BitSet(new long[] { 0x0000000000002250L });\n\n    public static final BitSet FOLLOW_statement_in_namespaceBody184 = new BitSet(new long[] { 0x0000000000002250L });\n\n    public static final BitSet FOLLOW_CLOSE_NESTING_in_namespaceBody188 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_varName_in_assignment201 = new BitSet(new long[] { 0x0000000000000080L });\n\n    public static final BitSet FOLLOW_ASSIGNMENT_OP_in_assignment203 = new BitSet(new long[] { 0x0000000000003310L });\n\n    public static final BitSet FOLLOW_varValue_in_assignment206 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_includeValue_in_assignment230 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_unparsedIncludeValue_in_assignment247 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_localReference_in_assignment267 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_VALID_NAME_CHARS_in_varName298 = new BitSet(new long[] { 0x0000000000000012L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_varValue312 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_START_INCLUDE_in_includeValue334 = new BitSet(new long[] { 0x0000000000000100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_includeValue338 = new BitSet(new long[] { 0x0000000000000400L });\n\n    public static final BitSet FOLLOW_AS_KEYWORD_in_includeValue340 = new BitSet(new long[] { 0x0000000000000100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_includeValue344 = new BitSet(new long[] { 0x0000000000000800L });\n\n    public static final BitSet FOLLOW_END_INCLUDE_in_includeValue346 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_START_UNPARSED_INCLUDE_in_unparsedIncludeValue373 = new BitSet(new long[] { 0x0000000000000100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_unparsedIncludeValue377 = new BitSet(new long[] { 0x0000000000000800L });\n\n    public static final BitSet FOLLOW_END_INCLUDE_in_unparsedIncludeValue379 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_START_INCLUDE_in_includeTree399 = new BitSet(new long[] { 0x0000000000000100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_includeTree403 = new BitSet(new long[] { 0x0000000000000C00L });\n\n    public static final BitSet FOLLOW_AS_KEYWORD_in_includeTree406 = new BitSet(new long[] { 0x0000000000000100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_includeTree410 = new BitSet(new long[] { 0x0000000000000800L });\n\n    public static final BitSet FOLLOW_END_INCLUDE_in_includeTree414 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_localReference_in_localRefTree442 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_REF_CHAR_in_localReference475 = new BitSet(new long[] { 0x0000000000004100L });\n\n    public static final BitSet FOLLOW_WS_in_localReference477 = new BitSet(new long[] { 0x0000000000004100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_localReference480 = new BitSet(new long[] { 0x0000000000000002L });\n}\n",
		"id": "/EvoSuiteBenchmark/60_sugar/src/main/java/net/sf/sugar/scl/SCLParser_4Test.java",
		"test_prompt": "// SCLParser_4Test.java\npackage net.sf.sugar.scl;\n\nimport static net.sf.sugar.scl.PathConversionUtils.convertToXPath;\nimport static net.sf.sugar.scl.PathConversionUtils.processDotDelimitedPath;\nimport java.net.URI;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Element;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathFactory;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpressionException;\nimport org.antlr.runtime.*;\nimport java.util.Stack;\nimport java.util.List;\nimport java.util.ArrayList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SCLParser}.\n* It contains ten unit test cases for the {@link SCLParser#varName()} method.\n*/\nclass SCLParser_4Test {"
	},
	{
		"original_code": "// SCLParser.java\n// $ANTLR 3.3 Nov 30, 2010 12:46:29 net/sf/sugar/scl/SCL.g 2013-06-10 17:15:03\npackage net.sf.sugar.scl;\n\nimport static net.sf.sugar.scl.PathConversionUtils.convertToXPath;\nimport static net.sf.sugar.scl.PathConversionUtils.processDotDelimitedPath;\nimport java.net.URI;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Element;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathFactory;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpressionException;\nimport org.antlr.runtime.*;\nimport java.util.Stack;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class SCLParser extends Parser {\n\n    public static final String[] tokenNames = new String[] { \"<invalid>\", \"<EOR>\", \"<DOWN>\", \"<UP>\", \"VALID_NAME_CHARS\", \"OPEN_NESTING\", \"CLOSE_NESTING\", \"ASSIGNMENT_OP\", \"STRING_LITERAL\", \"START_INCLUDE\", \"AS_KEYWORD\", \"END_INCLUDE\", \"START_UNPARSED_INCLUDE\", \"REF_CHAR\", \"WS\", \"QUOTE\", \"STRING_SEQUENCE_CHAR\", \"COMMENT\", \"LINE_COMMENT\", \"'.'\" };\n\n    public static final int EOF = -1;\n\n    public static final int T__19 = 19;\n\n    public static final int VALID_NAME_CHARS = 4;\n\n    public static final int OPEN_NESTING = 5;\n\n    public static final int CLOSE_NESTING = 6;\n\n    public static final int ASSIGNMENT_OP = 7;\n\n    public static final int STRING_LITERAL = 8;\n\n    public static final int START_INCLUDE = 9;\n\n    public static final int AS_KEYWORD = 10;\n\n    public static final int END_INCLUDE = 11;\n\n    public static final int START_UNPARSED_INCLUDE = 12;\n\n    public static final int REF_CHAR = 13;\n\n    public static final int WS = 14;\n\n    public static final int QUOTE = 15;\n\n    public static final int STRING_SEQUENCE_CHAR = 16;\n\n    public static final int COMMENT = 17;\n\n    public static final int LINE_COMMENT = 18;\n\n    // delegates\n    // delegators\n    public SCLParser(TokenStream input) {\n        this(input, new RecognizerSharedState());\n    }\n\n    public SCLParser(TokenStream input, RecognizerSharedState state) {\n        super(input, state);\n    }\n\n    public String[] getTokenNames() {\n        return SCLParser.tokenNames;\n    }\n\n    public String getGrammarFileName() {\n        return \"net/sf/sugar/scl/SCL.g\";\n    }\n\n    public static final String SCL_ROOT_ELEMENT = \"scl\";\n\n    private URI rootSCLFile;\n\n    private Document doc;\n\n    private Stack<Element> elements = new Stack<Element>();\n\n    private XPath xpath = XPathFactory.newInstance().newXPath();\n\n    private IncludeProcessor includeProcessor;\n\n    private static LocalReferenceProcessor localReferenceProcessor;\n\n    private List<LocalReference> localRefs = new ArrayList<LocalReference>();\n\n    private int namespaceSteps;\n\n    {\n        try {\n            doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n            Element rootElement = doc.createElement(SCL_ROOT_ELEMENT);\n            doc.appendChild(rootElement);\n            this.elements.push(rootElement);\n        } catch (ParserConfigurationException pce) {\n            pce.printStackTrace();\n        }\n    }\n\n    protected Element addChildElement(Element element, String child) {\n        Element childElement = this.doc.createElement(child);\n        element.appendChild(childElement);\n        return childElement;\n    }\n\n    protected Element addChildElements(Element currentElement, String compositePath) {\n        return processDotDelimitedPath(currentElement, compositePath);\n    }\n\n    protected void addAttribute(Element currentElement, String attributeName, String attributeValue) {\n        Element childElement = this.doc.createElement(attributeName);\n        childElement.setTextContent(attributeValue);\n        currentElement.appendChild(childElement);\n    }\n\n    protected void loadIncludeValue(Element parentElement, String propertyName, String includeLocation, String xPathExpression) throws IncludeException {\n        this.includeProcessor.prepareIncludeValue(parentElement, propertyName, includeLocation, this.rootSCLFile, xPathExpression);\n    }\n\n    protected void loadInclude(Element parentElement, String includeLocation) throws IncludeException {\n        this.includeProcessor.prepareInclude(parentElement, includeLocation, this.rootSCLFile);\n    }\n\n    protected void loadIncludeNodes(Element parentElement, String includeLocation, String xPathExpression) throws IncludeException {\n        this.includeProcessor.prepareInclude(parentElement, includeLocation, this.rootSCLFile, xPathExpression);\n    }\n\n    protected void loadUnparsedInclude(Element parentElement, String propertyName, String includeLocation) throws IncludeException {\n        this.includeProcessor.loadUnparsedInclude(parentElement, propertyName, includeLocation, this.rootSCLFile);\n    }\n\n    protected void prepareLocalRefTree(final Element parentElement, final String xPathExpression) {\n        LocalReference localRef = new LocalReference() {\n\n            {\n                setParentElement(parentElement);\n                setXPathQuery(xPathExpression);\n            }\n        };\n        this.localRefs.add(localRef);\n    }\n\n    protected void prepareLocalRef(final Element parentElement, final String attributeName, final String xPathExpression) {\n        LocalAttributeReference localRef = new LocalAttributeReference() {\n\n            {\n                setParentElement(parentElement);\n                setXPathQuery(xPathExpression);\n                setAttributeName(attributeName);\n            }\n        };\n        this.localRefs.add(localRef);\n    }\n\n    public void setRootSCLFile(URI rootSCLFile) {\n        this.rootSCLFile = rootSCLFile;\n    }\n\n    public URI getRootSCLFile() {\n        return this.rootSCLFile;\n    }\n\n    public Document getRootDocument() {\n        return this.doc;\n    }\n\n    public void setIncludeProcessor(IncludeProcessor includeProcessor) {\n        this.includeProcessor = includeProcessor;\n    }\n\n    public IncludeProcessor getIncludeProcessor() {\n        return this.includeProcessor;\n    }\n\n    public void setLocalReferenceProcessor(LocalReferenceProcessor processor) {\n        localReferenceProcessor = processor;\n    }\n\n    public LocalReferenceProcessor getLocalReferenceProcessor() {\n        return localReferenceProcessor;\n    }\n\n    public List<LocalReference> getLocalRefs() {\n        return this.localRefs;\n    }\n\n    public String sanitiseText(String rawText) {\n        String unquotedText = stripQuotes(rawText);\n        return normaliseEscapeChars(unquotedText);\n    }\n\n    private String stripQuotes(String quotedText) {\n        return quotedText.substring(1, quotedText.length() - 1);\n    }\n\n    private String normaliseEscapeChars(String text) {\n        return text.replace(\"\\\\\\\\\", \"\\\\\").replace(\"\\\\\\\"\", \"\\\"\");\n    }\n\n    // $ANTLR start \"scl\"\n    // net/sf/sugar/scl/SCL.g:152:1: scl returns [Document properties] : statementSeq ;\n    public final Document scl() throws RecognitionException {\n        Document properties = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:153:6: ( statementSeq )\n            // net/sf/sugar/scl/SCL.g:153:8: statementSeq\n            {\n                pushFollow(FOLLOW_statementSeq_in_scl44);\n                statementSeq();\n                state._fsp--;\n                try {\n                    this.includeProcessor.resolveIncludes(this.doc);\n                    localReferenceProcessor.processLocalReferences(this.localRefs);\n                } catch (IncludeException ie) {\n                    ie.printStackTrace();\n                } catch (LocalReferenceException lre) {\n                    lre.printStackTrace();\n                }\n                properties = doc;\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return properties;\n    }\n\n    // $ANTLR end \"scl\"\n    // $ANTLR start \"statementSeq\"\n    // net/sf/sugar/scl/SCL.g:168:1: statementSeq : ( statement )+ ;\n    public final void statementSeq() throws RecognitionException {\n        try {\n            // net/sf/sugar/scl/SCL.g:168:15: ( ( statement )+ )\n            // net/sf/sugar/scl/SCL.g:168:17: ( statement )+\n            {\n                // net/sf/sugar/scl/SCL.g:168:17: ( statement )+\n                int cnt1 = 0;\n                loop1: do {\n                    int alt1 = 2;\n                    switch(input.LA(1)) {\n                        case VALID_NAME_CHARS:\n                        case START_INCLUDE:\n                        case REF_CHAR:\n                            {\n                                alt1 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt1) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:168:17: statement\n                            {\n                                pushFollow(FOLLOW_statement_in_statementSeq61);\n                                statement();\n                                state._fsp--;\n                            }\n                            break;\n                        default:\n                            if (cnt1 >= 1)\n                                break loop1;\n                            EarlyExitException eee = new EarlyExitException(1, input);\n                            throw eee;\n                    }\n                    cnt1++;\n                } while (true);\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"statementSeq\"\n    // $ANTLR start \"statement\"\n    // net/sf/sugar/scl/SCL.g:170:1: statement : ( namespaceDecl | assignment | includeTree | t= localRefTree );\n    public final void statement() throws RecognitionException {\n        String t = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:170:13: ( namespaceDecl | assignment | includeTree | t= localRefTree )\n            int alt2 = 4;\n            alt2 = dfa2.predict(input);\n            switch(alt2) {\n                case 1:\n                    // net/sf/sugar/scl/SCL.g:170:15: namespaceDecl\n                    {\n                        pushFollow(FOLLOW_namespaceDecl_in_statement73);\n                        namespaceDecl();\n                        state._fsp--;\n                    }\n                    break;\n                case 2:\n                    // net/sf/sugar/scl/SCL.g:171:9: assignment\n                    {\n                        pushFollow(FOLLOW_assignment_in_statement84);\n                        assignment();\n                        state._fsp--;\n                    }\n                    break;\n                case 3:\n                    // net/sf/sugar/scl/SCL.g:172:9: includeTree\n                    {\n                        pushFollow(FOLLOW_includeTree_in_statement95);\n                        includeTree();\n                        state._fsp--;\n                    }\n                    break;\n                case 4:\n                    // net/sf/sugar/scl/SCL.g:173:9: t= localRefTree\n                    {\n                        pushFollow(FOLLOW_localRefTree_in_statement108);\n                        t = localRefTree();\n                        state._fsp--;\n                        prepareLocalRefTree(this.elements.peek(), t);\n                    }\n                    break;\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"statement\"\n    // $ANTLR start \"namespaceDecl\"\n    // net/sf/sugar/scl/SCL.g:177:1: namespaceDecl : namespaceName namespaceBody ;\n    public final void namespaceDecl() throws RecognitionException {\n        try {\n            // net/sf/sugar/scl/SCL.g:177:16: ( namespaceName namespaceBody )\n            // net/sf/sugar/scl/SCL.g:177:18: namespaceName namespaceBody\n            {\n                pushFollow(FOLLOW_namespaceName_in_namespaceDecl120);\n                namespaceName();\n                state._fsp--;\n                pushFollow(FOLLOW_namespaceBody_in_namespaceDecl122);\n                namespaceBody();\n                state._fsp--;\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"namespaceDecl\"\n    public static class namespaceName_return extends ParserRuleReturnScope {\n    }\n\n    // $ANTLR start \"namespaceName\"\n    // net/sf/sugar/scl/SCL.g:179:1: namespaceName : ( varName | compositeNamespaceName );\n    public final SCLParser.namespaceName_return namespaceName() throws RecognitionException {\n        SCLParser.namespaceName_return retval = new SCLParser.namespaceName_return();\n        retval.start = input.LT(1);\n        SCLParser.compositeNamespaceName_return compositeNamespaceName1 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:179:16: ( varName | compositeNamespaceName )\n            int alt3 = 2;\n            alt3 = dfa3.predict(input);\n            switch(alt3) {\n                case 1:\n                    // net/sf/sugar/scl/SCL.g:179:18: varName\n                    {\n                        pushFollow(FOLLOW_varName_in_namespaceName132);\n                        varName();\n                        state._fsp--;\n                        this.elements.push(addChildElement(this.elements.peek(), input.toString(retval.start, input.LT(-1))));\n                    }\n                    break;\n                case 2:\n                    // net/sf/sugar/scl/SCL.g:180:9: compositeNamespaceName\n                    {\n                        pushFollow(FOLLOW_compositeNamespaceName_in_namespaceName145);\n                        compositeNamespaceName1 = compositeNamespaceName();\n                        state._fsp--;\n                        this.elements.push(addChildElements(this.elements.peek(), (compositeNamespaceName1 != null ? input.toString(compositeNamespaceName1.start, compositeNamespaceName1.stop) : null)));\n                    }\n                    break;\n            }\n            retval.stop = input.LT(-1);\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return retval;\n    }\n\n    // $ANTLR end \"namespaceName\"\n    public static class compositeNamespaceName_return extends ParserRuleReturnScope {\n    }\n\n    // $ANTLR start \"compositeNamespaceName\"\n    // net/sf/sugar/scl/SCL.g:182:1: compositeNamespaceName : ( VALID_NAME_CHARS )+ ( '.' ( VALID_NAME_CHARS )+ )+ ;\n    public final SCLParser.compositeNamespaceName_return compositeNamespaceName() throws RecognitionException {\n        SCLParser.compositeNamespaceName_return retval = new SCLParser.compositeNamespaceName_return();\n        retval.start = input.LT(1);\n        try {\n            // net/sf/sugar/scl/SCL.g:182:24: ( ( VALID_NAME_CHARS )+ ( '.' ( VALID_NAME_CHARS )+ )+ )\n            // net/sf/sugar/scl/SCL.g:182:28: ( VALID_NAME_CHARS )+ ( '.' ( VALID_NAME_CHARS )+ )+\n            {\n                // net/sf/sugar/scl/SCL.g:182:28: ( VALID_NAME_CHARS )+\n                int cnt4 = 0;\n                loop4: do {\n                    int alt4 = 2;\n                    switch(input.LA(1)) {\n                        case VALID_NAME_CHARS:\n                            {\n                                alt4 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt4) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:182:28: VALID_NAME_CHARS\n                            {\n                                match(input, VALID_NAME_CHARS, FOLLOW_VALID_NAME_CHARS_in_compositeNamespaceName160);\n                            }\n                            break;\n                        default:\n                            if (cnt4 >= 1)\n                                break loop4;\n                            EarlyExitException eee = new EarlyExitException(4, input);\n                            throw eee;\n                    }\n                    cnt4++;\n                } while (true);\n                // net/sf/sugar/scl/SCL.g:182:46: ( '.' ( VALID_NAME_CHARS )+ )+\n                int cnt6 = 0;\n                loop6: do {\n                    int alt6 = 2;\n                    switch(input.LA(1)) {\n                        case 19:\n                            {\n                                alt6 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt6) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:182:47: '.' ( VALID_NAME_CHARS )+\n                            {\n                                match(input, 19, FOLLOW_19_in_compositeNamespaceName164);\n                                // net/sf/sugar/scl/SCL.g:182:51: ( VALID_NAME_CHARS )+\n                                int cnt5 = 0;\n                                loop5: do {\n                                    int alt5 = 2;\n                                    switch(input.LA(1)) {\n                                        case VALID_NAME_CHARS:\n                                            {\n                                                alt5 = 1;\n                                            }\n                                            break;\n                                    }\n                                    switch(alt5) {\n                                        case 1:\n                                            // net/sf/sugar/scl/SCL.g:182:51: VALID_NAME_CHARS\n                                            {\n                                                match(input, VALID_NAME_CHARS, FOLLOW_VALID_NAME_CHARS_in_compositeNamespaceName166);\n                                            }\n                                            break;\n                                        default:\n                                            if (cnt5 >= 1)\n                                                break loop5;\n                                            EarlyExitException eee = new EarlyExitException(5, input);\n                                            throw eee;\n                                    }\n                                    cnt5++;\n                                } while (true);\n                            }\n                            break;\n                        default:\n                            if (cnt6 >= 1)\n                                break loop6;\n                            EarlyExitException eee = new EarlyExitException(6, input);\n                            throw eee;\n                    }\n                    cnt6++;\n                } while (true);\n            }\n            retval.stop = input.LT(-1);\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return retval;\n    }\n\n    // $ANTLR end \"compositeNamespaceName\"\n    // $ANTLR start \"namespaceBody\"\n    // net/sf/sugar/scl/SCL.g:184:1: namespaceBody : OPEN_NESTING ( statement )* CLOSE_NESTING ;\n    public final void namespaceBody() throws RecognitionException {\n        try {\n            // net/sf/sugar/scl/SCL.g:184:16: ( OPEN_NESTING ( statement )* CLOSE_NESTING )\n            // net/sf/sugar/scl/SCL.g:184:18: OPEN_NESTING ( statement )* CLOSE_NESTING\n            {\n                match(input, OPEN_NESTING, FOLLOW_OPEN_NESTING_in_namespaceBody181);\n                // net/sf/sugar/scl/SCL.g:184:31: ( statement )*\n                loop7: do {\n                    int alt7 = 2;\n                    switch(input.LA(1)) {\n                        case VALID_NAME_CHARS:\n                        case START_INCLUDE:\n                        case REF_CHAR:\n                            {\n                                alt7 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt7) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:184:32: statement\n                            {\n                                pushFollow(FOLLOW_statement_in_namespaceBody184);\n                                statement();\n                                state._fsp--;\n                            }\n                            break;\n                        default:\n                            break loop7;\n                    }\n                } while (true);\n                match(input, CLOSE_NESTING, FOLLOW_CLOSE_NESTING_in_namespaceBody188);\n                this.elements.pop();\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"namespaceBody\"\n    // $ANTLR start \"assignment\"\n    // net/sf/sugar/scl/SCL.g:188:1: assignment : varName ASSIGNMENT_OP ( varValue | includeValue | v= unparsedIncludeValue | r= localReference ) ;\n    public final void assignment() throws RecognitionException {\n        String v = null;\n        String r = null;\n        SCLParser.varName_return varName2 = null;\n        SCLParser.varValue_return varValue3 = null;\n        SCLParser.includeValue_return includeValue4 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:188:14: ( varName ASSIGNMENT_OP ( varValue | includeValue | v= unparsedIncludeValue | r= localReference ) )\n            // net/sf/sugar/scl/SCL.g:188:16: varName ASSIGNMENT_OP ( varValue | includeValue | v= unparsedIncludeValue | r= localReference )\n            {\n                pushFollow(FOLLOW_varName_in_assignment201);\n                varName2 = varName();\n                state._fsp--;\n                match(input, ASSIGNMENT_OP, FOLLOW_ASSIGNMENT_OP_in_assignment203);\n                // net/sf/sugar/scl/SCL.g:188:38: ( varValue | includeValue | v= unparsedIncludeValue | r= localReference )\n                int alt8 = 4;\n                switch(input.LA(1)) {\n                    case STRING_LITERAL:\n                        {\n                            alt8 = 1;\n                        }\n                        break;\n                    case START_INCLUDE:\n                        {\n                            alt8 = 2;\n                        }\n                        break;\n                    case START_UNPARSED_INCLUDE:\n                        {\n                            alt8 = 3;\n                        }\n                        break;\n                    case REF_CHAR:\n                        {\n                            alt8 = 4;\n                        }\n                        break;\n                    default:\n                        NoViableAltException nvae = new NoViableAltException(\"\", 8, 0, input);\n                        throw nvae;\n                }\n                switch(alt8) {\n                    case 1:\n                        // net/sf/sugar/scl/SCL.g:188:39: varValue\n                        {\n                            pushFollow(FOLLOW_varValue_in_assignment206);\n                            varValue3 = varValue();\n                            state._fsp--;\n                            addAttribute(this.elements.peek(), (varName2 != null ? input.toString(varName2.start, varName2.stop) : null), sanitiseText((varValue3 != null ? input.toString(varValue3.start, varValue3.stop) : null)));\n                        }\n                        break;\n                    case 2:\n                        // net/sf/sugar/scl/SCL.g:194:14: includeValue\n                        {\n                            pushFollow(FOLLOW_includeValue_in_assignment230);\n                            includeValue4 = includeValue();\n                            state._fsp--;\n                            try {\n                                this.loadIncludeValue(this.elements.peek(), (varName2 != null ? input.toString(varName2.start, varName2.stop) : null), sanitiseText((includeValue4 != null ? includeValue4.includeLocation : null)), sanitiseText((includeValue4 != null ? includeValue4.xPathQuery : null)));\n                            } catch (IncludeException ie) {\n                                ie.printStackTrace();\n                                System.out.println(ie);\n                            }\n                        }\n                        break;\n                    case 3:\n                        // net/sf/sugar/scl/SCL.g:205:12: v= unparsedIncludeValue\n                        {\n                            pushFollow(FOLLOW_unparsedIncludeValue_in_assignment247);\n                            v = unparsedIncludeValue();\n                            state._fsp--;\n                            try {\n                                this.loadUnparsedInclude(this.elements.peek(), (varName2 != null ? input.toString(varName2.start, varName2.stop) : null), v);\n                            } catch (IncludeException ie) {\n                                ie.printStackTrace();\n                            }\n                        }\n                        break;\n                    case 4:\n                        // net/sf/sugar/scl/SCL.g:212:15: r= localReference\n                        {\n                            pushFollow(FOLLOW_localReference_in_assignment267);\n                            r = localReference();\n                            state._fsp--;\n                            //todo : handle empty values, also handle non numeric, date and boolean return types\n                            prepareLocalRef(this.elements.peek(), (varName2 != null ? input.toString(varName2.start, varName2.stop) : null), r);\n                        }\n                        break;\n                }\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"assignment\"\n    public static class varName_return extends ParserRuleReturnScope {\n    }\n\n    // $ANTLR start \"varName\"\n    // net/sf/sugar/scl/SCL.g:218:1: varName : ( VALID_NAME_CHARS )+ ;\n    public final SCLParser.varName_return varName() throws RecognitionException {\n        SCLParser.varName_return retval = new SCLParser.varName_return();\n        retval.start = input.LT(1);\n        try {\n            // net/sf/sugar/scl/SCL.g:218:12: ( ( VALID_NAME_CHARS )+ )\n            // net/sf/sugar/scl/SCL.g:218:14: ( VALID_NAME_CHARS )+\n            {\n                // net/sf/sugar/scl/SCL.g:218:14: ( VALID_NAME_CHARS )+\n                int cnt9 = 0;\n                loop9: do {\n                    int alt9 = 2;\n                    switch(input.LA(1)) {\n                        case VALID_NAME_CHARS:\n                            {\n                                alt9 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt9) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:218:14: VALID_NAME_CHARS\n                            {\n                                match(input, VALID_NAME_CHARS, FOLLOW_VALID_NAME_CHARS_in_varName298);\n                            }\n                            break;\n                        default:\n                            if (cnt9 >= 1)\n                                break loop9;\n                            EarlyExitException eee = new EarlyExitException(9, input);\n                            throw eee;\n                    }\n                    cnt9++;\n                } while (true);\n            }\n            retval.stop = input.LT(-1);\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return retval;\n    }\n\n    // $ANTLR end \"varName\"\n    public static class varValue_return extends ParserRuleReturnScope {\n    }\n\n    // $ANTLR start \"varValue\"\n    // net/sf/sugar/scl/SCL.g:220:1: varValue : STRING_LITERAL ;\n    public final SCLParser.varValue_return varValue() throws RecognitionException {\n        SCLParser.varValue_return retval = new SCLParser.varValue_return();\n        retval.start = input.LT(1);\n        try {\n            // net/sf/sugar/scl/SCL.g:220:13: ( STRING_LITERAL )\n            // net/sf/sugar/scl/SCL.g:220:15: STRING_LITERAL\n            {\n                match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_varValue312);\n            }\n            retval.stop = input.LT(-1);\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return retval;\n    }\n\n    // $ANTLR end \"varValue\"\n    public static class includeValue_return extends ParserRuleReturnScope {\n\n        public String includeLocation;\n\n        public String xPathQuery;\n    }\n\n    // $ANTLR start \"includeValue\"\n    // net/sf/sugar/scl/SCL.g:223:1: includeValue returns [String includeLocation, String xPathQuery] : START_INCLUDE s1= STRING_LITERAL AS_KEYWORD s2= STRING_LITERAL END_INCLUDE ;\n    public final SCLParser.includeValue_return includeValue() throws RecognitionException {\n        SCLParser.includeValue_return retval = new SCLParser.includeValue_return();\n        retval.start = input.LT(1);\n        Token s1 = null;\n        Token s2 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:224:6: ( START_INCLUDE s1= STRING_LITERAL AS_KEYWORD s2= STRING_LITERAL END_INCLUDE )\n            // net/sf/sugar/scl/SCL.g:224:8: START_INCLUDE s1= STRING_LITERAL AS_KEYWORD s2= STRING_LITERAL END_INCLUDE\n            {\n                match(input, START_INCLUDE, FOLLOW_START_INCLUDE_in_includeValue334);\n                s1 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_includeValue338);\n                match(input, AS_KEYWORD, FOLLOW_AS_KEYWORD_in_includeValue340);\n                s2 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_includeValue344);\n                match(input, END_INCLUDE, FOLLOW_END_INCLUDE_in_includeValue346);\n                retval.includeLocation = (s1 != null ? s1.getText() : null);\n                retval.xPathQuery = (s2 != null ? s2.getText() : null);\n            }\n            retval.stop = input.LT(-1);\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return retval;\n    }\n\n    // $ANTLR end \"includeValue\"\n    // $ANTLR start \"unparsedIncludeValue\"\n    // net/sf/sugar/scl/SCL.g:229:1: unparsedIncludeValue returns [String includeLocation] : START_UNPARSED_INCLUDE s1= STRING_LITERAL END_INCLUDE ;\n    public final String unparsedIncludeValue() throws RecognitionException {\n        String includeLocation = null;\n        Token s1 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:230:6: ( START_UNPARSED_INCLUDE s1= STRING_LITERAL END_INCLUDE )\n            // net/sf/sugar/scl/SCL.g:230:8: START_UNPARSED_INCLUDE s1= STRING_LITERAL END_INCLUDE\n            {\n                match(input, START_UNPARSED_INCLUDE, FOLLOW_START_UNPARSED_INCLUDE_in_unparsedIncludeValue373);\n                s1 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_unparsedIncludeValue377);\n                match(input, END_INCLUDE, FOLLOW_END_INCLUDE_in_unparsedIncludeValue379);\n                includeLocation = stripQuotes(s1.getText());\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return includeLocation;\n    }\n\n    // $ANTLR end \"unparsedIncludeValue\"\n    // $ANTLR start \"includeTree\"\n    // net/sf/sugar/scl/SCL.g:234:1: includeTree : START_INCLUDE s1= STRING_LITERAL ( AS_KEYWORD s2= STRING_LITERAL )? END_INCLUDE ;\n    public final void includeTree() throws RecognitionException {\n        Token s1 = null;\n        Token s2 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:234:15: ( START_INCLUDE s1= STRING_LITERAL ( AS_KEYWORD s2= STRING_LITERAL )? END_INCLUDE )\n            // net/sf/sugar/scl/SCL.g:234:17: START_INCLUDE s1= STRING_LITERAL ( AS_KEYWORD s2= STRING_LITERAL )? END_INCLUDE\n            {\n                match(input, START_INCLUDE, FOLLOW_START_INCLUDE_in_includeTree399);\n                s1 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_includeTree403);\n                // net/sf/sugar/scl/SCL.g:234:49: ( AS_KEYWORD s2= STRING_LITERAL )?\n                int alt10 = 2;\n                switch(input.LA(1)) {\n                    case AS_KEYWORD:\n                        {\n                            alt10 = 1;\n                        }\n                        break;\n                }\n                switch(alt10) {\n                    case 1:\n                        // net/sf/sugar/scl/SCL.g:234:50: AS_KEYWORD s2= STRING_LITERAL\n                        {\n                            match(input, AS_KEYWORD, FOLLOW_AS_KEYWORD_in_includeTree406);\n                            s2 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_includeTree410);\n                        }\n                        break;\n                }\n                match(input, END_INCLUDE, FOLLOW_END_INCLUDE_in_includeTree414);\n                try {\n                    if (s2 == null || \"\".equals(s2)) {\n                        this.loadInclude(this.elements.peek(), sanitiseText(s1.getText()));\n                    } else {\n                        this.loadIncludeNodes(this.elements.peek(), sanitiseText(s1.getText()), sanitiseText(s2.getText()));\n                    }\n                } catch (IncludeException ie) {\n                    ie.printStackTrace();\n                }\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"includeTree\"\n    // $ANTLR start \"localRefTree\"\n    // net/sf/sugar/scl/SCL.g:250:1: localRefTree returns [String xPathQuery] : r= localReference ;\n    public final String localRefTree() throws RecognitionException {\n        String xPathQuery = null;\n        String r = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:251:7: (r= localReference )\n            // net/sf/sugar/scl/SCL.g:251:10: r= localReference\n            {\n                pushFollow(FOLLOW_localReference_in_localRefTree442);\n                r = localReference();\n                state._fsp--;\n                xPathQuery = r;\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return xPathQuery;\n    }\n\n    // $ANTLR end \"localRefTree\"\n    // $ANTLR start \"localReference\"\n    // net/sf/sugar/scl/SCL.g:253:1: localReference returns [String resolvedValue] : REF_CHAR ( WS )* STRING_LITERAL ;\n    public final String localReference() throws RecognitionException {\n        String resolvedValue = null;\n        Token STRING_LITERAL5 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:254:7: ( REF_CHAR ( WS )* STRING_LITERAL )\n            // net/sf/sugar/scl/SCL.g:254:10: REF_CHAR ( WS )* STRING_LITERAL\n            {\n                match(input, REF_CHAR, FOLLOW_REF_CHAR_in_localReference475);\n                // net/sf/sugar/scl/SCL.g:254:19: ( WS )*\n                loop11: do {\n                    int alt11 = 2;\n                    switch(input.LA(1)) {\n                        case WS:\n                            {\n                                alt11 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt11) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:254:19: WS\n                            {\n                                match(input, WS, FOLLOW_WS_in_localReference477);\n                            }\n                            break;\n                        default:\n                            break loop11;\n                    }\n                } while (true);\n                STRING_LITERAL5 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_localReference480);\n                resolvedValue = sanitiseText((STRING_LITERAL5 != null ? STRING_LITERAL5.getText() : null));\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return resolvedValue;\n    }\n\n    // $ANTLR end \"localReference\"\n    // Delegated rules\n    protected DFA2 dfa2 = new DFA2(this);\n\n    protected DFA3 dfa3 = new DFA3(this);\n\n    static final String DFA2_eotS = \"\\6\\uffff\";\n\n    static final String DFA2_eofS = \"\\6\\uffff\";\n\n    static final String DFA2_minS = \"\\2\\4\\4\\uffff\";\n\n    static final String DFA2_maxS = \"\\1\\15\\1\\23\\4\\uffff\";\n\n    static final String DFA2_acceptS = \"\\2\\uffff\\1\\3\\1\\4\\1\\1\\1\\2\";\n\n    static final String DFA2_specialS = \"\\6\\uffff}>\";\n\n    static final String[] DFA2_transitionS = { \"\\1\\1\\4\\uffff\\1\\2\\3\\uffff\\1\\3\", \"\\1\\1\\1\\4\\1\\uffff\\1\\5\\13\\uffff\\1\\4\", \"\", \"\", \"\", \"\" };\n\n    static final short[] DFA2_eot = DFA.unpackEncodedString(DFA2_eotS);\n\n    static final short[] DFA2_eof = DFA.unpackEncodedString(DFA2_eofS);\n\n    static final char[] DFA2_min = DFA.unpackEncodedStringToUnsignedChars(DFA2_minS);\n\n    static final char[] DFA2_max = DFA.unpackEncodedStringToUnsignedChars(DFA2_maxS);\n\n    static final short[] DFA2_accept = DFA.unpackEncodedString(DFA2_acceptS);\n\n    static final short[] DFA2_special = DFA.unpackEncodedString(DFA2_specialS);\n\n    static final short[][] DFA2_transition;\n\n    static {\n        int numStates = DFA2_transitionS.length;\n        DFA2_transition = new short[numStates][];\n        for (int i = 0; i < numStates; i++) {\n            DFA2_transition[i] = DFA.unpackEncodedString(DFA2_transitionS[i]);\n        }\n    }\n\n    class DFA2 extends DFA {\n\n        public DFA2(BaseRecognizer recognizer) {\n            this.recognizer = recognizer;\n            this.decisionNumber = 2;\n            this.eot = DFA2_eot;\n            this.eof = DFA2_eof;\n            this.min = DFA2_min;\n            this.max = DFA2_max;\n            this.accept = DFA2_accept;\n            this.special = DFA2_special;\n            this.transition = DFA2_transition;\n        }\n\n        public String getDescription() {\n            return \"170:1: statement : ( namespaceDecl | assignment | includeTree | t= localRefTree );\";\n        }\n    }\n\n    static final String DFA3_eotS = \"\\4\\uffff\";\n\n    static final String DFA3_eofS = \"\\4\\uffff\";\n\n    static final String DFA3_minS = \"\\2\\4\\2\\uffff\";\n\n    static final String DFA3_maxS = \"\\1\\4\\1\\23\\2\\uffff\";\n\n    static final String DFA3_acceptS = \"\\2\\uffff\\1\\1\\1\\2\";\n\n    static final String DFA3_specialS = \"\\4\\uffff}>\";\n\n    static final String[] DFA3_transitionS = { \"\\1\\1\", \"\\1\\1\\1\\2\\15\\uffff\\1\\3\", \"\", \"\" };\n\n    static final short[] DFA3_eot = DFA.unpackEncodedString(DFA3_eotS);\n\n    static final short[] DFA3_eof = DFA.unpackEncodedString(DFA3_eofS);\n\n    static final char[] DFA3_min = DFA.unpackEncodedStringToUnsignedChars(DFA3_minS);\n\n    static final char[] DFA3_max = DFA.unpackEncodedStringToUnsignedChars(DFA3_maxS);\n\n    static final short[] DFA3_accept = DFA.unpackEncodedString(DFA3_acceptS);\n\n    static final short[] DFA3_special = DFA.unpackEncodedString(DFA3_specialS);\n\n    static final short[][] DFA3_transition;\n\n    static {\n        int numStates = DFA3_transitionS.length;\n        DFA3_transition = new short[numStates][];\n        for (int i = 0; i < numStates; i++) {\n            DFA3_transition[i] = DFA.unpackEncodedString(DFA3_transitionS[i]);\n        }\n    }\n\n    class DFA3 extends DFA {\n\n        public DFA3(BaseRecognizer recognizer) {\n            this.recognizer = recognizer;\n            this.decisionNumber = 3;\n            this.eot = DFA3_eot;\n            this.eof = DFA3_eof;\n            this.min = DFA3_min;\n            this.max = DFA3_max;\n            this.accept = DFA3_accept;\n            this.special = DFA3_special;\n            this.transition = DFA3_transition;\n        }\n\n        public String getDescription() {\n            return \"179:1: namespaceName : ( varName | compositeNamespaceName );\";\n        }\n    }\n\n    public static final BitSet FOLLOW_statementSeq_in_scl44 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_statement_in_statementSeq61 = new BitSet(new long[] { 0x0000000000002212L });\n\n    public static final BitSet FOLLOW_namespaceDecl_in_statement73 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_assignment_in_statement84 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_includeTree_in_statement95 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_localRefTree_in_statement108 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_namespaceName_in_namespaceDecl120 = new BitSet(new long[] { 0x0000000000000020L });\n\n    public static final BitSet FOLLOW_namespaceBody_in_namespaceDecl122 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_varName_in_namespaceName132 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_compositeNamespaceName_in_namespaceName145 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_VALID_NAME_CHARS_in_compositeNamespaceName160 = new BitSet(new long[] { 0x0000000000080010L });\n\n    public static final BitSet FOLLOW_19_in_compositeNamespaceName164 = new BitSet(new long[] { 0x0000000000000010L });\n\n    public static final BitSet FOLLOW_VALID_NAME_CHARS_in_compositeNamespaceName166 = new BitSet(new long[] { 0x0000000000080012L });\n\n    public static final BitSet FOLLOW_OPEN_NESTING_in_namespaceBody181 = new BitSet(new long[] { 0x0000000000002250L });\n\n    public static final BitSet FOLLOW_statement_in_namespaceBody184 = new BitSet(new long[] { 0x0000000000002250L });\n\n    public static final BitSet FOLLOW_CLOSE_NESTING_in_namespaceBody188 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_varName_in_assignment201 = new BitSet(new long[] { 0x0000000000000080L });\n\n    public static final BitSet FOLLOW_ASSIGNMENT_OP_in_assignment203 = new BitSet(new long[] { 0x0000000000003310L });\n\n    public static final BitSet FOLLOW_varValue_in_assignment206 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_includeValue_in_assignment230 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_unparsedIncludeValue_in_assignment247 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_localReference_in_assignment267 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_VALID_NAME_CHARS_in_varName298 = new BitSet(new long[] { 0x0000000000000012L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_varValue312 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_START_INCLUDE_in_includeValue334 = new BitSet(new long[] { 0x0000000000000100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_includeValue338 = new BitSet(new long[] { 0x0000000000000400L });\n\n    public static final BitSet FOLLOW_AS_KEYWORD_in_includeValue340 = new BitSet(new long[] { 0x0000000000000100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_includeValue344 = new BitSet(new long[] { 0x0000000000000800L });\n\n    public static final BitSet FOLLOW_END_INCLUDE_in_includeValue346 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_START_UNPARSED_INCLUDE_in_unparsedIncludeValue373 = new BitSet(new long[] { 0x0000000000000100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_unparsedIncludeValue377 = new BitSet(new long[] { 0x0000000000000800L });\n\n    public static final BitSet FOLLOW_END_INCLUDE_in_unparsedIncludeValue379 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_START_INCLUDE_in_includeTree399 = new BitSet(new long[] { 0x0000000000000100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_includeTree403 = new BitSet(new long[] { 0x0000000000000C00L });\n\n    public static final BitSet FOLLOW_AS_KEYWORD_in_includeTree406 = new BitSet(new long[] { 0x0000000000000100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_includeTree410 = new BitSet(new long[] { 0x0000000000000800L });\n\n    public static final BitSet FOLLOW_END_INCLUDE_in_includeTree414 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_localReference_in_localRefTree442 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_REF_CHAR_in_localReference475 = new BitSet(new long[] { 0x0000000000004100L });\n\n    public static final BitSet FOLLOW_WS_in_localReference477 = new BitSet(new long[] { 0x0000000000004100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_localReference480 = new BitSet(new long[] { 0x0000000000000002L });\n}\n",
		"id": "/EvoSuiteBenchmark/60_sugar/src/main/java/net/sf/sugar/scl/SCLParser_5Test.java",
		"test_prompt": "// SCLParser_5Test.java\npackage net.sf.sugar.scl;\n\nimport static net.sf.sugar.scl.PathConversionUtils.convertToXPath;\nimport static net.sf.sugar.scl.PathConversionUtils.processDotDelimitedPath;\nimport java.net.URI;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Element;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathFactory;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpressionException;\nimport org.antlr.runtime.*;\nimport java.util.Stack;\nimport java.util.List;\nimport java.util.ArrayList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SCLParser}.\n* It contains ten unit test cases for the {@link SCLParser#varValue()} method.\n*/\nclass SCLParser_5Test {"
	},
	{
		"original_code": "// SCLParser.java\n// $ANTLR 3.3 Nov 30, 2010 12:46:29 net/sf/sugar/scl/SCL.g 2013-06-10 17:15:03\npackage net.sf.sugar.scl;\n\nimport static net.sf.sugar.scl.PathConversionUtils.convertToXPath;\nimport static net.sf.sugar.scl.PathConversionUtils.processDotDelimitedPath;\nimport java.net.URI;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Element;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathFactory;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpressionException;\nimport org.antlr.runtime.*;\nimport java.util.Stack;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class SCLParser extends Parser {\n\n    public static final String[] tokenNames = new String[] { \"<invalid>\", \"<EOR>\", \"<DOWN>\", \"<UP>\", \"VALID_NAME_CHARS\", \"OPEN_NESTING\", \"CLOSE_NESTING\", \"ASSIGNMENT_OP\", \"STRING_LITERAL\", \"START_INCLUDE\", \"AS_KEYWORD\", \"END_INCLUDE\", \"START_UNPARSED_INCLUDE\", \"REF_CHAR\", \"WS\", \"QUOTE\", \"STRING_SEQUENCE_CHAR\", \"COMMENT\", \"LINE_COMMENT\", \"'.'\" };\n\n    public static final int EOF = -1;\n\n    public static final int T__19 = 19;\n\n    public static final int VALID_NAME_CHARS = 4;\n\n    public static final int OPEN_NESTING = 5;\n\n    public static final int CLOSE_NESTING = 6;\n\n    public static final int ASSIGNMENT_OP = 7;\n\n    public static final int STRING_LITERAL = 8;\n\n    public static final int START_INCLUDE = 9;\n\n    public static final int AS_KEYWORD = 10;\n\n    public static final int END_INCLUDE = 11;\n\n    public static final int START_UNPARSED_INCLUDE = 12;\n\n    public static final int REF_CHAR = 13;\n\n    public static final int WS = 14;\n\n    public static final int QUOTE = 15;\n\n    public static final int STRING_SEQUENCE_CHAR = 16;\n\n    public static final int COMMENT = 17;\n\n    public static final int LINE_COMMENT = 18;\n\n    // delegates\n    // delegators\n    public SCLParser(TokenStream input) {\n        this(input, new RecognizerSharedState());\n    }\n\n    public SCLParser(TokenStream input, RecognizerSharedState state) {\n        super(input, state);\n    }\n\n    public String[] getTokenNames() {\n        return SCLParser.tokenNames;\n    }\n\n    public String getGrammarFileName() {\n        return \"net/sf/sugar/scl/SCL.g\";\n    }\n\n    public static final String SCL_ROOT_ELEMENT = \"scl\";\n\n    private URI rootSCLFile;\n\n    private Document doc;\n\n    private Stack<Element> elements = new Stack<Element>();\n\n    private XPath xpath = XPathFactory.newInstance().newXPath();\n\n    private IncludeProcessor includeProcessor;\n\n    private static LocalReferenceProcessor localReferenceProcessor;\n\n    private List<LocalReference> localRefs = new ArrayList<LocalReference>();\n\n    private int namespaceSteps;\n\n    {\n        try {\n            doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n            Element rootElement = doc.createElement(SCL_ROOT_ELEMENT);\n            doc.appendChild(rootElement);\n            this.elements.push(rootElement);\n        } catch (ParserConfigurationException pce) {\n            pce.printStackTrace();\n        }\n    }\n\n    protected Element addChildElement(Element element, String child) {\n        Element childElement = this.doc.createElement(child);\n        element.appendChild(childElement);\n        return childElement;\n    }\n\n    protected Element addChildElements(Element currentElement, String compositePath) {\n        return processDotDelimitedPath(currentElement, compositePath);\n    }\n\n    protected void addAttribute(Element currentElement, String attributeName, String attributeValue) {\n        Element childElement = this.doc.createElement(attributeName);\n        childElement.setTextContent(attributeValue);\n        currentElement.appendChild(childElement);\n    }\n\n    protected void loadIncludeValue(Element parentElement, String propertyName, String includeLocation, String xPathExpression) throws IncludeException {\n        this.includeProcessor.prepareIncludeValue(parentElement, propertyName, includeLocation, this.rootSCLFile, xPathExpression);\n    }\n\n    protected void loadInclude(Element parentElement, String includeLocation) throws IncludeException {\n        this.includeProcessor.prepareInclude(parentElement, includeLocation, this.rootSCLFile);\n    }\n\n    protected void loadIncludeNodes(Element parentElement, String includeLocation, String xPathExpression) throws IncludeException {\n        this.includeProcessor.prepareInclude(parentElement, includeLocation, this.rootSCLFile, xPathExpression);\n    }\n\n    protected void loadUnparsedInclude(Element parentElement, String propertyName, String includeLocation) throws IncludeException {\n        this.includeProcessor.loadUnparsedInclude(parentElement, propertyName, includeLocation, this.rootSCLFile);\n    }\n\n    protected void prepareLocalRefTree(final Element parentElement, final String xPathExpression) {\n        LocalReference localRef = new LocalReference() {\n\n            {\n                setParentElement(parentElement);\n                setXPathQuery(xPathExpression);\n            }\n        };\n        this.localRefs.add(localRef);\n    }\n\n    protected void prepareLocalRef(final Element parentElement, final String attributeName, final String xPathExpression) {\n        LocalAttributeReference localRef = new LocalAttributeReference() {\n\n            {\n                setParentElement(parentElement);\n                setXPathQuery(xPathExpression);\n                setAttributeName(attributeName);\n            }\n        };\n        this.localRefs.add(localRef);\n    }\n\n    public void setRootSCLFile(URI rootSCLFile) {\n        this.rootSCLFile = rootSCLFile;\n    }\n\n    public URI getRootSCLFile() {\n        return this.rootSCLFile;\n    }\n\n    public Document getRootDocument() {\n        return this.doc;\n    }\n\n    public void setIncludeProcessor(IncludeProcessor includeProcessor) {\n        this.includeProcessor = includeProcessor;\n    }\n\n    public IncludeProcessor getIncludeProcessor() {\n        return this.includeProcessor;\n    }\n\n    public void setLocalReferenceProcessor(LocalReferenceProcessor processor) {\n        localReferenceProcessor = processor;\n    }\n\n    public LocalReferenceProcessor getLocalReferenceProcessor() {\n        return localReferenceProcessor;\n    }\n\n    public List<LocalReference> getLocalRefs() {\n        return this.localRefs;\n    }\n\n    public String sanitiseText(String rawText) {\n        String unquotedText = stripQuotes(rawText);\n        return normaliseEscapeChars(unquotedText);\n    }\n\n    private String stripQuotes(String quotedText) {\n        return quotedText.substring(1, quotedText.length() - 1);\n    }\n\n    private String normaliseEscapeChars(String text) {\n        return text.replace(\"\\\\\\\\\", \"\\\\\").replace(\"\\\\\\\"\", \"\\\"\");\n    }\n\n    // $ANTLR start \"scl\"\n    // net/sf/sugar/scl/SCL.g:152:1: scl returns [Document properties] : statementSeq ;\n    public final Document scl() throws RecognitionException {\n        Document properties = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:153:6: ( statementSeq )\n            // net/sf/sugar/scl/SCL.g:153:8: statementSeq\n            {\n                pushFollow(FOLLOW_statementSeq_in_scl44);\n                statementSeq();\n                state._fsp--;\n                try {\n                    this.includeProcessor.resolveIncludes(this.doc);\n                    localReferenceProcessor.processLocalReferences(this.localRefs);\n                } catch (IncludeException ie) {\n                    ie.printStackTrace();\n                } catch (LocalReferenceException lre) {\n                    lre.printStackTrace();\n                }\n                properties = doc;\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return properties;\n    }\n\n    // $ANTLR end \"scl\"\n    // $ANTLR start \"statementSeq\"\n    // net/sf/sugar/scl/SCL.g:168:1: statementSeq : ( statement )+ ;\n    public final void statementSeq() throws RecognitionException {\n        try {\n            // net/sf/sugar/scl/SCL.g:168:15: ( ( statement )+ )\n            // net/sf/sugar/scl/SCL.g:168:17: ( statement )+\n            {\n                // net/sf/sugar/scl/SCL.g:168:17: ( statement )+\n                int cnt1 = 0;\n                loop1: do {\n                    int alt1 = 2;\n                    switch(input.LA(1)) {\n                        case VALID_NAME_CHARS:\n                        case START_INCLUDE:\n                        case REF_CHAR:\n                            {\n                                alt1 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt1) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:168:17: statement\n                            {\n                                pushFollow(FOLLOW_statement_in_statementSeq61);\n                                statement();\n                                state._fsp--;\n                            }\n                            break;\n                        default:\n                            if (cnt1 >= 1)\n                                break loop1;\n                            EarlyExitException eee = new EarlyExitException(1, input);\n                            throw eee;\n                    }\n                    cnt1++;\n                } while (true);\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"statementSeq\"\n    // $ANTLR start \"statement\"\n    // net/sf/sugar/scl/SCL.g:170:1: statement : ( namespaceDecl | assignment | includeTree | t= localRefTree );\n    public final void statement() throws RecognitionException {\n        String t = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:170:13: ( namespaceDecl | assignment | includeTree | t= localRefTree )\n            int alt2 = 4;\n            alt2 = dfa2.predict(input);\n            switch(alt2) {\n                case 1:\n                    // net/sf/sugar/scl/SCL.g:170:15: namespaceDecl\n                    {\n                        pushFollow(FOLLOW_namespaceDecl_in_statement73);\n                        namespaceDecl();\n                        state._fsp--;\n                    }\n                    break;\n                case 2:\n                    // net/sf/sugar/scl/SCL.g:171:9: assignment\n                    {\n                        pushFollow(FOLLOW_assignment_in_statement84);\n                        assignment();\n                        state._fsp--;\n                    }\n                    break;\n                case 3:\n                    // net/sf/sugar/scl/SCL.g:172:9: includeTree\n                    {\n                        pushFollow(FOLLOW_includeTree_in_statement95);\n                        includeTree();\n                        state._fsp--;\n                    }\n                    break;\n                case 4:\n                    // net/sf/sugar/scl/SCL.g:173:9: t= localRefTree\n                    {\n                        pushFollow(FOLLOW_localRefTree_in_statement108);\n                        t = localRefTree();\n                        state._fsp--;\n                        prepareLocalRefTree(this.elements.peek(), t);\n                    }\n                    break;\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"statement\"\n    // $ANTLR start \"namespaceDecl\"\n    // net/sf/sugar/scl/SCL.g:177:1: namespaceDecl : namespaceName namespaceBody ;\n    public final void namespaceDecl() throws RecognitionException {\n        try {\n            // net/sf/sugar/scl/SCL.g:177:16: ( namespaceName namespaceBody )\n            // net/sf/sugar/scl/SCL.g:177:18: namespaceName namespaceBody\n            {\n                pushFollow(FOLLOW_namespaceName_in_namespaceDecl120);\n                namespaceName();\n                state._fsp--;\n                pushFollow(FOLLOW_namespaceBody_in_namespaceDecl122);\n                namespaceBody();\n                state._fsp--;\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"namespaceDecl\"\n    public static class namespaceName_return extends ParserRuleReturnScope {\n    }\n\n    // $ANTLR start \"namespaceName\"\n    // net/sf/sugar/scl/SCL.g:179:1: namespaceName : ( varName | compositeNamespaceName );\n    public final SCLParser.namespaceName_return namespaceName() throws RecognitionException {\n        SCLParser.namespaceName_return retval = new SCLParser.namespaceName_return();\n        retval.start = input.LT(1);\n        SCLParser.compositeNamespaceName_return compositeNamespaceName1 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:179:16: ( varName | compositeNamespaceName )\n            int alt3 = 2;\n            alt3 = dfa3.predict(input);\n            switch(alt3) {\n                case 1:\n                    // net/sf/sugar/scl/SCL.g:179:18: varName\n                    {\n                        pushFollow(FOLLOW_varName_in_namespaceName132);\n                        varName();\n                        state._fsp--;\n                        this.elements.push(addChildElement(this.elements.peek(), input.toString(retval.start, input.LT(-1))));\n                    }\n                    break;\n                case 2:\n                    // net/sf/sugar/scl/SCL.g:180:9: compositeNamespaceName\n                    {\n                        pushFollow(FOLLOW_compositeNamespaceName_in_namespaceName145);\n                        compositeNamespaceName1 = compositeNamespaceName();\n                        state._fsp--;\n                        this.elements.push(addChildElements(this.elements.peek(), (compositeNamespaceName1 != null ? input.toString(compositeNamespaceName1.start, compositeNamespaceName1.stop) : null)));\n                    }\n                    break;\n            }\n            retval.stop = input.LT(-1);\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return retval;\n    }\n\n    // $ANTLR end \"namespaceName\"\n    public static class compositeNamespaceName_return extends ParserRuleReturnScope {\n    }\n\n    // $ANTLR start \"compositeNamespaceName\"\n    // net/sf/sugar/scl/SCL.g:182:1: compositeNamespaceName : ( VALID_NAME_CHARS )+ ( '.' ( VALID_NAME_CHARS )+ )+ ;\n    public final SCLParser.compositeNamespaceName_return compositeNamespaceName() throws RecognitionException {\n        SCLParser.compositeNamespaceName_return retval = new SCLParser.compositeNamespaceName_return();\n        retval.start = input.LT(1);\n        try {\n            // net/sf/sugar/scl/SCL.g:182:24: ( ( VALID_NAME_CHARS )+ ( '.' ( VALID_NAME_CHARS )+ )+ )\n            // net/sf/sugar/scl/SCL.g:182:28: ( VALID_NAME_CHARS )+ ( '.' ( VALID_NAME_CHARS )+ )+\n            {\n                // net/sf/sugar/scl/SCL.g:182:28: ( VALID_NAME_CHARS )+\n                int cnt4 = 0;\n                loop4: do {\n                    int alt4 = 2;\n                    switch(input.LA(1)) {\n                        case VALID_NAME_CHARS:\n                            {\n                                alt4 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt4) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:182:28: VALID_NAME_CHARS\n                            {\n                                match(input, VALID_NAME_CHARS, FOLLOW_VALID_NAME_CHARS_in_compositeNamespaceName160);\n                            }\n                            break;\n                        default:\n                            if (cnt4 >= 1)\n                                break loop4;\n                            EarlyExitException eee = new EarlyExitException(4, input);\n                            throw eee;\n                    }\n                    cnt4++;\n                } while (true);\n                // net/sf/sugar/scl/SCL.g:182:46: ( '.' ( VALID_NAME_CHARS )+ )+\n                int cnt6 = 0;\n                loop6: do {\n                    int alt6 = 2;\n                    switch(input.LA(1)) {\n                        case 19:\n                            {\n                                alt6 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt6) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:182:47: '.' ( VALID_NAME_CHARS )+\n                            {\n                                match(input, 19, FOLLOW_19_in_compositeNamespaceName164);\n                                // net/sf/sugar/scl/SCL.g:182:51: ( VALID_NAME_CHARS )+\n                                int cnt5 = 0;\n                                loop5: do {\n                                    int alt5 = 2;\n                                    switch(input.LA(1)) {\n                                        case VALID_NAME_CHARS:\n                                            {\n                                                alt5 = 1;\n                                            }\n                                            break;\n                                    }\n                                    switch(alt5) {\n                                        case 1:\n                                            // net/sf/sugar/scl/SCL.g:182:51: VALID_NAME_CHARS\n                                            {\n                                                match(input, VALID_NAME_CHARS, FOLLOW_VALID_NAME_CHARS_in_compositeNamespaceName166);\n                                            }\n                                            break;\n                                        default:\n                                            if (cnt5 >= 1)\n                                                break loop5;\n                                            EarlyExitException eee = new EarlyExitException(5, input);\n                                            throw eee;\n                                    }\n                                    cnt5++;\n                                } while (true);\n                            }\n                            break;\n                        default:\n                            if (cnt6 >= 1)\n                                break loop6;\n                            EarlyExitException eee = new EarlyExitException(6, input);\n                            throw eee;\n                    }\n                    cnt6++;\n                } while (true);\n            }\n            retval.stop = input.LT(-1);\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return retval;\n    }\n\n    // $ANTLR end \"compositeNamespaceName\"\n    // $ANTLR start \"namespaceBody\"\n    // net/sf/sugar/scl/SCL.g:184:1: namespaceBody : OPEN_NESTING ( statement )* CLOSE_NESTING ;\n    public final void namespaceBody() throws RecognitionException {\n        try {\n            // net/sf/sugar/scl/SCL.g:184:16: ( OPEN_NESTING ( statement )* CLOSE_NESTING )\n            // net/sf/sugar/scl/SCL.g:184:18: OPEN_NESTING ( statement )* CLOSE_NESTING\n            {\n                match(input, OPEN_NESTING, FOLLOW_OPEN_NESTING_in_namespaceBody181);\n                // net/sf/sugar/scl/SCL.g:184:31: ( statement )*\n                loop7: do {\n                    int alt7 = 2;\n                    switch(input.LA(1)) {\n                        case VALID_NAME_CHARS:\n                        case START_INCLUDE:\n                        case REF_CHAR:\n                            {\n                                alt7 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt7) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:184:32: statement\n                            {\n                                pushFollow(FOLLOW_statement_in_namespaceBody184);\n                                statement();\n                                state._fsp--;\n                            }\n                            break;\n                        default:\n                            break loop7;\n                    }\n                } while (true);\n                match(input, CLOSE_NESTING, FOLLOW_CLOSE_NESTING_in_namespaceBody188);\n                this.elements.pop();\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"namespaceBody\"\n    // $ANTLR start \"assignment\"\n    // net/sf/sugar/scl/SCL.g:188:1: assignment : varName ASSIGNMENT_OP ( varValue | includeValue | v= unparsedIncludeValue | r= localReference ) ;\n    public final void assignment() throws RecognitionException {\n        String v = null;\n        String r = null;\n        SCLParser.varName_return varName2 = null;\n        SCLParser.varValue_return varValue3 = null;\n        SCLParser.includeValue_return includeValue4 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:188:14: ( varName ASSIGNMENT_OP ( varValue | includeValue | v= unparsedIncludeValue | r= localReference ) )\n            // net/sf/sugar/scl/SCL.g:188:16: varName ASSIGNMENT_OP ( varValue | includeValue | v= unparsedIncludeValue | r= localReference )\n            {\n                pushFollow(FOLLOW_varName_in_assignment201);\n                varName2 = varName();\n                state._fsp--;\n                match(input, ASSIGNMENT_OP, FOLLOW_ASSIGNMENT_OP_in_assignment203);\n                // net/sf/sugar/scl/SCL.g:188:38: ( varValue | includeValue | v= unparsedIncludeValue | r= localReference )\n                int alt8 = 4;\n                switch(input.LA(1)) {\n                    case STRING_LITERAL:\n                        {\n                            alt8 = 1;\n                        }\n                        break;\n                    case START_INCLUDE:\n                        {\n                            alt8 = 2;\n                        }\n                        break;\n                    case START_UNPARSED_INCLUDE:\n                        {\n                            alt8 = 3;\n                        }\n                        break;\n                    case REF_CHAR:\n                        {\n                            alt8 = 4;\n                        }\n                        break;\n                    default:\n                        NoViableAltException nvae = new NoViableAltException(\"\", 8, 0, input);\n                        throw nvae;\n                }\n                switch(alt8) {\n                    case 1:\n                        // net/sf/sugar/scl/SCL.g:188:39: varValue\n                        {\n                            pushFollow(FOLLOW_varValue_in_assignment206);\n                            varValue3 = varValue();\n                            state._fsp--;\n                            addAttribute(this.elements.peek(), (varName2 != null ? input.toString(varName2.start, varName2.stop) : null), sanitiseText((varValue3 != null ? input.toString(varValue3.start, varValue3.stop) : null)));\n                        }\n                        break;\n                    case 2:\n                        // net/sf/sugar/scl/SCL.g:194:14: includeValue\n                        {\n                            pushFollow(FOLLOW_includeValue_in_assignment230);\n                            includeValue4 = includeValue();\n                            state._fsp--;\n                            try {\n                                this.loadIncludeValue(this.elements.peek(), (varName2 != null ? input.toString(varName2.start, varName2.stop) : null), sanitiseText((includeValue4 != null ? includeValue4.includeLocation : null)), sanitiseText((includeValue4 != null ? includeValue4.xPathQuery : null)));\n                            } catch (IncludeException ie) {\n                                ie.printStackTrace();\n                                System.out.println(ie);\n                            }\n                        }\n                        break;\n                    case 3:\n                        // net/sf/sugar/scl/SCL.g:205:12: v= unparsedIncludeValue\n                        {\n                            pushFollow(FOLLOW_unparsedIncludeValue_in_assignment247);\n                            v = unparsedIncludeValue();\n                            state._fsp--;\n                            try {\n                                this.loadUnparsedInclude(this.elements.peek(), (varName2 != null ? input.toString(varName2.start, varName2.stop) : null), v);\n                            } catch (IncludeException ie) {\n                                ie.printStackTrace();\n                            }\n                        }\n                        break;\n                    case 4:\n                        // net/sf/sugar/scl/SCL.g:212:15: r= localReference\n                        {\n                            pushFollow(FOLLOW_localReference_in_assignment267);\n                            r = localReference();\n                            state._fsp--;\n                            //todo : handle empty values, also handle non numeric, date and boolean return types\n                            prepareLocalRef(this.elements.peek(), (varName2 != null ? input.toString(varName2.start, varName2.stop) : null), r);\n                        }\n                        break;\n                }\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"assignment\"\n    public static class varName_return extends ParserRuleReturnScope {\n    }\n\n    // $ANTLR start \"varName\"\n    // net/sf/sugar/scl/SCL.g:218:1: varName : ( VALID_NAME_CHARS )+ ;\n    public final SCLParser.varName_return varName() throws RecognitionException {\n        SCLParser.varName_return retval = new SCLParser.varName_return();\n        retval.start = input.LT(1);\n        try {\n            // net/sf/sugar/scl/SCL.g:218:12: ( ( VALID_NAME_CHARS )+ )\n            // net/sf/sugar/scl/SCL.g:218:14: ( VALID_NAME_CHARS )+\n            {\n                // net/sf/sugar/scl/SCL.g:218:14: ( VALID_NAME_CHARS )+\n                int cnt9 = 0;\n                loop9: do {\n                    int alt9 = 2;\n                    switch(input.LA(1)) {\n                        case VALID_NAME_CHARS:\n                            {\n                                alt9 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt9) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:218:14: VALID_NAME_CHARS\n                            {\n                                match(input, VALID_NAME_CHARS, FOLLOW_VALID_NAME_CHARS_in_varName298);\n                            }\n                            break;\n                        default:\n                            if (cnt9 >= 1)\n                                break loop9;\n                            EarlyExitException eee = new EarlyExitException(9, input);\n                            throw eee;\n                    }\n                    cnt9++;\n                } while (true);\n            }\n            retval.stop = input.LT(-1);\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return retval;\n    }\n\n    // $ANTLR end \"varName\"\n    public static class varValue_return extends ParserRuleReturnScope {\n    }\n\n    // $ANTLR start \"varValue\"\n    // net/sf/sugar/scl/SCL.g:220:1: varValue : STRING_LITERAL ;\n    public final SCLParser.varValue_return varValue() throws RecognitionException {\n        SCLParser.varValue_return retval = new SCLParser.varValue_return();\n        retval.start = input.LT(1);\n        try {\n            // net/sf/sugar/scl/SCL.g:220:13: ( STRING_LITERAL )\n            // net/sf/sugar/scl/SCL.g:220:15: STRING_LITERAL\n            {\n                match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_varValue312);\n            }\n            retval.stop = input.LT(-1);\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return retval;\n    }\n\n    // $ANTLR end \"varValue\"\n    public static class includeValue_return extends ParserRuleReturnScope {\n\n        public String includeLocation;\n\n        public String xPathQuery;\n    }\n\n    // $ANTLR start \"includeValue\"\n    // net/sf/sugar/scl/SCL.g:223:1: includeValue returns [String includeLocation, String xPathQuery] : START_INCLUDE s1= STRING_LITERAL AS_KEYWORD s2= STRING_LITERAL END_INCLUDE ;\n    public final SCLParser.includeValue_return includeValue() throws RecognitionException {\n        SCLParser.includeValue_return retval = new SCLParser.includeValue_return();\n        retval.start = input.LT(1);\n        Token s1 = null;\n        Token s2 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:224:6: ( START_INCLUDE s1= STRING_LITERAL AS_KEYWORD s2= STRING_LITERAL END_INCLUDE )\n            // net/sf/sugar/scl/SCL.g:224:8: START_INCLUDE s1= STRING_LITERAL AS_KEYWORD s2= STRING_LITERAL END_INCLUDE\n            {\n                match(input, START_INCLUDE, FOLLOW_START_INCLUDE_in_includeValue334);\n                s1 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_includeValue338);\n                match(input, AS_KEYWORD, FOLLOW_AS_KEYWORD_in_includeValue340);\n                s2 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_includeValue344);\n                match(input, END_INCLUDE, FOLLOW_END_INCLUDE_in_includeValue346);\n                retval.includeLocation = (s1 != null ? s1.getText() : null);\n                retval.xPathQuery = (s2 != null ? s2.getText() : null);\n            }\n            retval.stop = input.LT(-1);\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return retval;\n    }\n\n    // $ANTLR end \"includeValue\"\n    // $ANTLR start \"unparsedIncludeValue\"\n    // net/sf/sugar/scl/SCL.g:229:1: unparsedIncludeValue returns [String includeLocation] : START_UNPARSED_INCLUDE s1= STRING_LITERAL END_INCLUDE ;\n    public final String unparsedIncludeValue() throws RecognitionException {\n        String includeLocation = null;\n        Token s1 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:230:6: ( START_UNPARSED_INCLUDE s1= STRING_LITERAL END_INCLUDE )\n            // net/sf/sugar/scl/SCL.g:230:8: START_UNPARSED_INCLUDE s1= STRING_LITERAL END_INCLUDE\n            {\n                match(input, START_UNPARSED_INCLUDE, FOLLOW_START_UNPARSED_INCLUDE_in_unparsedIncludeValue373);\n                s1 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_unparsedIncludeValue377);\n                match(input, END_INCLUDE, FOLLOW_END_INCLUDE_in_unparsedIncludeValue379);\n                includeLocation = stripQuotes(s1.getText());\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return includeLocation;\n    }\n\n    // $ANTLR end \"unparsedIncludeValue\"\n    // $ANTLR start \"includeTree\"\n    // net/sf/sugar/scl/SCL.g:234:1: includeTree : START_INCLUDE s1= STRING_LITERAL ( AS_KEYWORD s2= STRING_LITERAL )? END_INCLUDE ;\n    public final void includeTree() throws RecognitionException {\n        Token s1 = null;\n        Token s2 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:234:15: ( START_INCLUDE s1= STRING_LITERAL ( AS_KEYWORD s2= STRING_LITERAL )? END_INCLUDE )\n            // net/sf/sugar/scl/SCL.g:234:17: START_INCLUDE s1= STRING_LITERAL ( AS_KEYWORD s2= STRING_LITERAL )? END_INCLUDE\n            {\n                match(input, START_INCLUDE, FOLLOW_START_INCLUDE_in_includeTree399);\n                s1 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_includeTree403);\n                // net/sf/sugar/scl/SCL.g:234:49: ( AS_KEYWORD s2= STRING_LITERAL )?\n                int alt10 = 2;\n                switch(input.LA(1)) {\n                    case AS_KEYWORD:\n                        {\n                            alt10 = 1;\n                        }\n                        break;\n                }\n                switch(alt10) {\n                    case 1:\n                        // net/sf/sugar/scl/SCL.g:234:50: AS_KEYWORD s2= STRING_LITERAL\n                        {\n                            match(input, AS_KEYWORD, FOLLOW_AS_KEYWORD_in_includeTree406);\n                            s2 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_includeTree410);\n                        }\n                        break;\n                }\n                match(input, END_INCLUDE, FOLLOW_END_INCLUDE_in_includeTree414);\n                try {\n                    if (s2 == null || \"\".equals(s2)) {\n                        this.loadInclude(this.elements.peek(), sanitiseText(s1.getText()));\n                    } else {\n                        this.loadIncludeNodes(this.elements.peek(), sanitiseText(s1.getText()), sanitiseText(s2.getText()));\n                    }\n                } catch (IncludeException ie) {\n                    ie.printStackTrace();\n                }\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"includeTree\"\n    // $ANTLR start \"localRefTree\"\n    // net/sf/sugar/scl/SCL.g:250:1: localRefTree returns [String xPathQuery] : r= localReference ;\n    public final String localRefTree() throws RecognitionException {\n        String xPathQuery = null;\n        String r = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:251:7: (r= localReference )\n            // net/sf/sugar/scl/SCL.g:251:10: r= localReference\n            {\n                pushFollow(FOLLOW_localReference_in_localRefTree442);\n                r = localReference();\n                state._fsp--;\n                xPathQuery = r;\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return xPathQuery;\n    }\n\n    // $ANTLR end \"localRefTree\"\n    // $ANTLR start \"localReference\"\n    // net/sf/sugar/scl/SCL.g:253:1: localReference returns [String resolvedValue] : REF_CHAR ( WS )* STRING_LITERAL ;\n    public final String localReference() throws RecognitionException {\n        String resolvedValue = null;\n        Token STRING_LITERAL5 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:254:7: ( REF_CHAR ( WS )* STRING_LITERAL )\n            // net/sf/sugar/scl/SCL.g:254:10: REF_CHAR ( WS )* STRING_LITERAL\n            {\n                match(input, REF_CHAR, FOLLOW_REF_CHAR_in_localReference475);\n                // net/sf/sugar/scl/SCL.g:254:19: ( WS )*\n                loop11: do {\n                    int alt11 = 2;\n                    switch(input.LA(1)) {\n                        case WS:\n                            {\n                                alt11 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt11) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:254:19: WS\n                            {\n                                match(input, WS, FOLLOW_WS_in_localReference477);\n                            }\n                            break;\n                        default:\n                            break loop11;\n                    }\n                } while (true);\n                STRING_LITERAL5 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_localReference480);\n                resolvedValue = sanitiseText((STRING_LITERAL5 != null ? STRING_LITERAL5.getText() : null));\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return resolvedValue;\n    }\n\n    // $ANTLR end \"localReference\"\n    // Delegated rules\n    protected DFA2 dfa2 = new DFA2(this);\n\n    protected DFA3 dfa3 = new DFA3(this);\n\n    static final String DFA2_eotS = \"\\6\\uffff\";\n\n    static final String DFA2_eofS = \"\\6\\uffff\";\n\n    static final String DFA2_minS = \"\\2\\4\\4\\uffff\";\n\n    static final String DFA2_maxS = \"\\1\\15\\1\\23\\4\\uffff\";\n\n    static final String DFA2_acceptS = \"\\2\\uffff\\1\\3\\1\\4\\1\\1\\1\\2\";\n\n    static final String DFA2_specialS = \"\\6\\uffff}>\";\n\n    static final String[] DFA2_transitionS = { \"\\1\\1\\4\\uffff\\1\\2\\3\\uffff\\1\\3\", \"\\1\\1\\1\\4\\1\\uffff\\1\\5\\13\\uffff\\1\\4\", \"\", \"\", \"\", \"\" };\n\n    static final short[] DFA2_eot = DFA.unpackEncodedString(DFA2_eotS);\n\n    static final short[] DFA2_eof = DFA.unpackEncodedString(DFA2_eofS);\n\n    static final char[] DFA2_min = DFA.unpackEncodedStringToUnsignedChars(DFA2_minS);\n\n    static final char[] DFA2_max = DFA.unpackEncodedStringToUnsignedChars(DFA2_maxS);\n\n    static final short[] DFA2_accept = DFA.unpackEncodedString(DFA2_acceptS);\n\n    static final short[] DFA2_special = DFA.unpackEncodedString(DFA2_specialS);\n\n    static final short[][] DFA2_transition;\n\n    static {\n        int numStates = DFA2_transitionS.length;\n        DFA2_transition = new short[numStates][];\n        for (int i = 0; i < numStates; i++) {\n            DFA2_transition[i] = DFA.unpackEncodedString(DFA2_transitionS[i]);\n        }\n    }\n\n    class DFA2 extends DFA {\n\n        public DFA2(BaseRecognizer recognizer) {\n            this.recognizer = recognizer;\n            this.decisionNumber = 2;\n            this.eot = DFA2_eot;\n            this.eof = DFA2_eof;\n            this.min = DFA2_min;\n            this.max = DFA2_max;\n            this.accept = DFA2_accept;\n            this.special = DFA2_special;\n            this.transition = DFA2_transition;\n        }\n\n        public String getDescription() {\n            return \"170:1: statement : ( namespaceDecl | assignment | includeTree | t= localRefTree );\";\n        }\n    }\n\n    static final String DFA3_eotS = \"\\4\\uffff\";\n\n    static final String DFA3_eofS = \"\\4\\uffff\";\n\n    static final String DFA3_minS = \"\\2\\4\\2\\uffff\";\n\n    static final String DFA3_maxS = \"\\1\\4\\1\\23\\2\\uffff\";\n\n    static final String DFA3_acceptS = \"\\2\\uffff\\1\\1\\1\\2\";\n\n    static final String DFA3_specialS = \"\\4\\uffff}>\";\n\n    static final String[] DFA3_transitionS = { \"\\1\\1\", \"\\1\\1\\1\\2\\15\\uffff\\1\\3\", \"\", \"\" };\n\n    static final short[] DFA3_eot = DFA.unpackEncodedString(DFA3_eotS);\n\n    static final short[] DFA3_eof = DFA.unpackEncodedString(DFA3_eofS);\n\n    static final char[] DFA3_min = DFA.unpackEncodedStringToUnsignedChars(DFA3_minS);\n\n    static final char[] DFA3_max = DFA.unpackEncodedStringToUnsignedChars(DFA3_maxS);\n\n    static final short[] DFA3_accept = DFA.unpackEncodedString(DFA3_acceptS);\n\n    static final short[] DFA3_special = DFA.unpackEncodedString(DFA3_specialS);\n\n    static final short[][] DFA3_transition;\n\n    static {\n        int numStates = DFA3_transitionS.length;\n        DFA3_transition = new short[numStates][];\n        for (int i = 0; i < numStates; i++) {\n            DFA3_transition[i] = DFA.unpackEncodedString(DFA3_transitionS[i]);\n        }\n    }\n\n    class DFA3 extends DFA {\n\n        public DFA3(BaseRecognizer recognizer) {\n            this.recognizer = recognizer;\n            this.decisionNumber = 3;\n            this.eot = DFA3_eot;\n            this.eof = DFA3_eof;\n            this.min = DFA3_min;\n            this.max = DFA3_max;\n            this.accept = DFA3_accept;\n            this.special = DFA3_special;\n            this.transition = DFA3_transition;\n        }\n\n        public String getDescription() {\n            return \"179:1: namespaceName : ( varName | compositeNamespaceName );\";\n        }\n    }\n\n    public static final BitSet FOLLOW_statementSeq_in_scl44 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_statement_in_statementSeq61 = new BitSet(new long[] { 0x0000000000002212L });\n\n    public static final BitSet FOLLOW_namespaceDecl_in_statement73 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_assignment_in_statement84 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_includeTree_in_statement95 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_localRefTree_in_statement108 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_namespaceName_in_namespaceDecl120 = new BitSet(new long[] { 0x0000000000000020L });\n\n    public static final BitSet FOLLOW_namespaceBody_in_namespaceDecl122 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_varName_in_namespaceName132 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_compositeNamespaceName_in_namespaceName145 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_VALID_NAME_CHARS_in_compositeNamespaceName160 = new BitSet(new long[] { 0x0000000000080010L });\n\n    public static final BitSet FOLLOW_19_in_compositeNamespaceName164 = new BitSet(new long[] { 0x0000000000000010L });\n\n    public static final BitSet FOLLOW_VALID_NAME_CHARS_in_compositeNamespaceName166 = new BitSet(new long[] { 0x0000000000080012L });\n\n    public static final BitSet FOLLOW_OPEN_NESTING_in_namespaceBody181 = new BitSet(new long[] { 0x0000000000002250L });\n\n    public static final BitSet FOLLOW_statement_in_namespaceBody184 = new BitSet(new long[] { 0x0000000000002250L });\n\n    public static final BitSet FOLLOW_CLOSE_NESTING_in_namespaceBody188 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_varName_in_assignment201 = new BitSet(new long[] { 0x0000000000000080L });\n\n    public static final BitSet FOLLOW_ASSIGNMENT_OP_in_assignment203 = new BitSet(new long[] { 0x0000000000003310L });\n\n    public static final BitSet FOLLOW_varValue_in_assignment206 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_includeValue_in_assignment230 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_unparsedIncludeValue_in_assignment247 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_localReference_in_assignment267 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_VALID_NAME_CHARS_in_varName298 = new BitSet(new long[] { 0x0000000000000012L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_varValue312 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_START_INCLUDE_in_includeValue334 = new BitSet(new long[] { 0x0000000000000100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_includeValue338 = new BitSet(new long[] { 0x0000000000000400L });\n\n    public static final BitSet FOLLOW_AS_KEYWORD_in_includeValue340 = new BitSet(new long[] { 0x0000000000000100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_includeValue344 = new BitSet(new long[] { 0x0000000000000800L });\n\n    public static final BitSet FOLLOW_END_INCLUDE_in_includeValue346 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_START_UNPARSED_INCLUDE_in_unparsedIncludeValue373 = new BitSet(new long[] { 0x0000000000000100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_unparsedIncludeValue377 = new BitSet(new long[] { 0x0000000000000800L });\n\n    public static final BitSet FOLLOW_END_INCLUDE_in_unparsedIncludeValue379 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_START_INCLUDE_in_includeTree399 = new BitSet(new long[] { 0x0000000000000100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_includeTree403 = new BitSet(new long[] { 0x0000000000000C00L });\n\n    public static final BitSet FOLLOW_AS_KEYWORD_in_includeTree406 = new BitSet(new long[] { 0x0000000000000100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_includeTree410 = new BitSet(new long[] { 0x0000000000000800L });\n\n    public static final BitSet FOLLOW_END_INCLUDE_in_includeTree414 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_localReference_in_localRefTree442 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_REF_CHAR_in_localReference475 = new BitSet(new long[] { 0x0000000000004100L });\n\n    public static final BitSet FOLLOW_WS_in_localReference477 = new BitSet(new long[] { 0x0000000000004100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_localReference480 = new BitSet(new long[] { 0x0000000000000002L });\n}\n",
		"id": "/EvoSuiteBenchmark/60_sugar/src/main/java/net/sf/sugar/scl/SCLParser_6Test.java",
		"test_prompt": "// SCLParser_6Test.java\npackage net.sf.sugar.scl;\n\nimport static net.sf.sugar.scl.PathConversionUtils.convertToXPath;\nimport static net.sf.sugar.scl.PathConversionUtils.processDotDelimitedPath;\nimport java.net.URI;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Element;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathFactory;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpressionException;\nimport org.antlr.runtime.*;\nimport java.util.Stack;\nimport java.util.List;\nimport java.util.ArrayList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SCLParser}.\n* It contains ten unit test cases for the {@link SCLParser#includeValue()} method.\n*/\nclass SCLParser_6Test {"
	},
	{
		"original_code": "// SCLParser.java\n// $ANTLR 3.3 Nov 30, 2010 12:46:29 net/sf/sugar/scl/SCL.g 2013-06-10 17:15:03\npackage net.sf.sugar.scl;\n\nimport static net.sf.sugar.scl.PathConversionUtils.convertToXPath;\nimport static net.sf.sugar.scl.PathConversionUtils.processDotDelimitedPath;\nimport java.net.URI;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Element;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathFactory;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpressionException;\nimport org.antlr.runtime.*;\nimport java.util.Stack;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class SCLParser extends Parser {\n\n    public static final String[] tokenNames = new String[] { \"<invalid>\", \"<EOR>\", \"<DOWN>\", \"<UP>\", \"VALID_NAME_CHARS\", \"OPEN_NESTING\", \"CLOSE_NESTING\", \"ASSIGNMENT_OP\", \"STRING_LITERAL\", \"START_INCLUDE\", \"AS_KEYWORD\", \"END_INCLUDE\", \"START_UNPARSED_INCLUDE\", \"REF_CHAR\", \"WS\", \"QUOTE\", \"STRING_SEQUENCE_CHAR\", \"COMMENT\", \"LINE_COMMENT\", \"'.'\" };\n\n    public static final int EOF = -1;\n\n    public static final int T__19 = 19;\n\n    public static final int VALID_NAME_CHARS = 4;\n\n    public static final int OPEN_NESTING = 5;\n\n    public static final int CLOSE_NESTING = 6;\n\n    public static final int ASSIGNMENT_OP = 7;\n\n    public static final int STRING_LITERAL = 8;\n\n    public static final int START_INCLUDE = 9;\n\n    public static final int AS_KEYWORD = 10;\n\n    public static final int END_INCLUDE = 11;\n\n    public static final int START_UNPARSED_INCLUDE = 12;\n\n    public static final int REF_CHAR = 13;\n\n    public static final int WS = 14;\n\n    public static final int QUOTE = 15;\n\n    public static final int STRING_SEQUENCE_CHAR = 16;\n\n    public static final int COMMENT = 17;\n\n    public static final int LINE_COMMENT = 18;\n\n    // delegates\n    // delegators\n    public SCLParser(TokenStream input) {\n        this(input, new RecognizerSharedState());\n    }\n\n    public SCLParser(TokenStream input, RecognizerSharedState state) {\n        super(input, state);\n    }\n\n    public String[] getTokenNames() {\n        return SCLParser.tokenNames;\n    }\n\n    public String getGrammarFileName() {\n        return \"net/sf/sugar/scl/SCL.g\";\n    }\n\n    public static final String SCL_ROOT_ELEMENT = \"scl\";\n\n    private URI rootSCLFile;\n\n    private Document doc;\n\n    private Stack<Element> elements = new Stack<Element>();\n\n    private XPath xpath = XPathFactory.newInstance().newXPath();\n\n    private IncludeProcessor includeProcessor;\n\n    private static LocalReferenceProcessor localReferenceProcessor;\n\n    private List<LocalReference> localRefs = new ArrayList<LocalReference>();\n\n    private int namespaceSteps;\n\n    {\n        try {\n            doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n            Element rootElement = doc.createElement(SCL_ROOT_ELEMENT);\n            doc.appendChild(rootElement);\n            this.elements.push(rootElement);\n        } catch (ParserConfigurationException pce) {\n            pce.printStackTrace();\n        }\n    }\n\n    protected Element addChildElement(Element element, String child) {\n        Element childElement = this.doc.createElement(child);\n        element.appendChild(childElement);\n        return childElement;\n    }\n\n    protected Element addChildElements(Element currentElement, String compositePath) {\n        return processDotDelimitedPath(currentElement, compositePath);\n    }\n\n    protected void addAttribute(Element currentElement, String attributeName, String attributeValue) {\n        Element childElement = this.doc.createElement(attributeName);\n        childElement.setTextContent(attributeValue);\n        currentElement.appendChild(childElement);\n    }\n\n    protected void loadIncludeValue(Element parentElement, String propertyName, String includeLocation, String xPathExpression) throws IncludeException {\n        this.includeProcessor.prepareIncludeValue(parentElement, propertyName, includeLocation, this.rootSCLFile, xPathExpression);\n    }\n\n    protected void loadInclude(Element parentElement, String includeLocation) throws IncludeException {\n        this.includeProcessor.prepareInclude(parentElement, includeLocation, this.rootSCLFile);\n    }\n\n    protected void loadIncludeNodes(Element parentElement, String includeLocation, String xPathExpression) throws IncludeException {\n        this.includeProcessor.prepareInclude(parentElement, includeLocation, this.rootSCLFile, xPathExpression);\n    }\n\n    protected void loadUnparsedInclude(Element parentElement, String propertyName, String includeLocation) throws IncludeException {\n        this.includeProcessor.loadUnparsedInclude(parentElement, propertyName, includeLocation, this.rootSCLFile);\n    }\n\n    protected void prepareLocalRefTree(final Element parentElement, final String xPathExpression) {\n        LocalReference localRef = new LocalReference() {\n\n            {\n                setParentElement(parentElement);\n                setXPathQuery(xPathExpression);\n            }\n        };\n        this.localRefs.add(localRef);\n    }\n\n    protected void prepareLocalRef(final Element parentElement, final String attributeName, final String xPathExpression) {\n        LocalAttributeReference localRef = new LocalAttributeReference() {\n\n            {\n                setParentElement(parentElement);\n                setXPathQuery(xPathExpression);\n                setAttributeName(attributeName);\n            }\n        };\n        this.localRefs.add(localRef);\n    }\n\n    public void setRootSCLFile(URI rootSCLFile) {\n        this.rootSCLFile = rootSCLFile;\n    }\n\n    public URI getRootSCLFile() {\n        return this.rootSCLFile;\n    }\n\n    public Document getRootDocument() {\n        return this.doc;\n    }\n\n    public void setIncludeProcessor(IncludeProcessor includeProcessor) {\n        this.includeProcessor = includeProcessor;\n    }\n\n    public IncludeProcessor getIncludeProcessor() {\n        return this.includeProcessor;\n    }\n\n    public void setLocalReferenceProcessor(LocalReferenceProcessor processor) {\n        localReferenceProcessor = processor;\n    }\n\n    public LocalReferenceProcessor getLocalReferenceProcessor() {\n        return localReferenceProcessor;\n    }\n\n    public List<LocalReference> getLocalRefs() {\n        return this.localRefs;\n    }\n\n    public String sanitiseText(String rawText) {\n        String unquotedText = stripQuotes(rawText);\n        return normaliseEscapeChars(unquotedText);\n    }\n\n    private String stripQuotes(String quotedText) {\n        return quotedText.substring(1, quotedText.length() - 1);\n    }\n\n    private String normaliseEscapeChars(String text) {\n        return text.replace(\"\\\\\\\\\", \"\\\\\").replace(\"\\\\\\\"\", \"\\\"\");\n    }\n\n    // $ANTLR start \"scl\"\n    // net/sf/sugar/scl/SCL.g:152:1: scl returns [Document properties] : statementSeq ;\n    public final Document scl() throws RecognitionException {\n        Document properties = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:153:6: ( statementSeq )\n            // net/sf/sugar/scl/SCL.g:153:8: statementSeq\n            {\n                pushFollow(FOLLOW_statementSeq_in_scl44);\n                statementSeq();\n                state._fsp--;\n                try {\n                    this.includeProcessor.resolveIncludes(this.doc);\n                    localReferenceProcessor.processLocalReferences(this.localRefs);\n                } catch (IncludeException ie) {\n                    ie.printStackTrace();\n                } catch (LocalReferenceException lre) {\n                    lre.printStackTrace();\n                }\n                properties = doc;\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return properties;\n    }\n\n    // $ANTLR end \"scl\"\n    // $ANTLR start \"statementSeq\"\n    // net/sf/sugar/scl/SCL.g:168:1: statementSeq : ( statement )+ ;\n    public final void statementSeq() throws RecognitionException {\n        try {\n            // net/sf/sugar/scl/SCL.g:168:15: ( ( statement )+ )\n            // net/sf/sugar/scl/SCL.g:168:17: ( statement )+\n            {\n                // net/sf/sugar/scl/SCL.g:168:17: ( statement )+\n                int cnt1 = 0;\n                loop1: do {\n                    int alt1 = 2;\n                    switch(input.LA(1)) {\n                        case VALID_NAME_CHARS:\n                        case START_INCLUDE:\n                        case REF_CHAR:\n                            {\n                                alt1 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt1) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:168:17: statement\n                            {\n                                pushFollow(FOLLOW_statement_in_statementSeq61);\n                                statement();\n                                state._fsp--;\n                            }\n                            break;\n                        default:\n                            if (cnt1 >= 1)\n                                break loop1;\n                            EarlyExitException eee = new EarlyExitException(1, input);\n                            throw eee;\n                    }\n                    cnt1++;\n                } while (true);\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"statementSeq\"\n    // $ANTLR start \"statement\"\n    // net/sf/sugar/scl/SCL.g:170:1: statement : ( namespaceDecl | assignment | includeTree | t= localRefTree );\n    public final void statement() throws RecognitionException {\n        String t = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:170:13: ( namespaceDecl | assignment | includeTree | t= localRefTree )\n            int alt2 = 4;\n            alt2 = dfa2.predict(input);\n            switch(alt2) {\n                case 1:\n                    // net/sf/sugar/scl/SCL.g:170:15: namespaceDecl\n                    {\n                        pushFollow(FOLLOW_namespaceDecl_in_statement73);\n                        namespaceDecl();\n                        state._fsp--;\n                    }\n                    break;\n                case 2:\n                    // net/sf/sugar/scl/SCL.g:171:9: assignment\n                    {\n                        pushFollow(FOLLOW_assignment_in_statement84);\n                        assignment();\n                        state._fsp--;\n                    }\n                    break;\n                case 3:\n                    // net/sf/sugar/scl/SCL.g:172:9: includeTree\n                    {\n                        pushFollow(FOLLOW_includeTree_in_statement95);\n                        includeTree();\n                        state._fsp--;\n                    }\n                    break;\n                case 4:\n                    // net/sf/sugar/scl/SCL.g:173:9: t= localRefTree\n                    {\n                        pushFollow(FOLLOW_localRefTree_in_statement108);\n                        t = localRefTree();\n                        state._fsp--;\n                        prepareLocalRefTree(this.elements.peek(), t);\n                    }\n                    break;\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"statement\"\n    // $ANTLR start \"namespaceDecl\"\n    // net/sf/sugar/scl/SCL.g:177:1: namespaceDecl : namespaceName namespaceBody ;\n    public final void namespaceDecl() throws RecognitionException {\n        try {\n            // net/sf/sugar/scl/SCL.g:177:16: ( namespaceName namespaceBody )\n            // net/sf/sugar/scl/SCL.g:177:18: namespaceName namespaceBody\n            {\n                pushFollow(FOLLOW_namespaceName_in_namespaceDecl120);\n                namespaceName();\n                state._fsp--;\n                pushFollow(FOLLOW_namespaceBody_in_namespaceDecl122);\n                namespaceBody();\n                state._fsp--;\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"namespaceDecl\"\n    public static class namespaceName_return extends ParserRuleReturnScope {\n    }\n\n    // $ANTLR start \"namespaceName\"\n    // net/sf/sugar/scl/SCL.g:179:1: namespaceName : ( varName | compositeNamespaceName );\n    public final SCLParser.namespaceName_return namespaceName() throws RecognitionException {\n        SCLParser.namespaceName_return retval = new SCLParser.namespaceName_return();\n        retval.start = input.LT(1);\n        SCLParser.compositeNamespaceName_return compositeNamespaceName1 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:179:16: ( varName | compositeNamespaceName )\n            int alt3 = 2;\n            alt3 = dfa3.predict(input);\n            switch(alt3) {\n                case 1:\n                    // net/sf/sugar/scl/SCL.g:179:18: varName\n                    {\n                        pushFollow(FOLLOW_varName_in_namespaceName132);\n                        varName();\n                        state._fsp--;\n                        this.elements.push(addChildElement(this.elements.peek(), input.toString(retval.start, input.LT(-1))));\n                    }\n                    break;\n                case 2:\n                    // net/sf/sugar/scl/SCL.g:180:9: compositeNamespaceName\n                    {\n                        pushFollow(FOLLOW_compositeNamespaceName_in_namespaceName145);\n                        compositeNamespaceName1 = compositeNamespaceName();\n                        state._fsp--;\n                        this.elements.push(addChildElements(this.elements.peek(), (compositeNamespaceName1 != null ? input.toString(compositeNamespaceName1.start, compositeNamespaceName1.stop) : null)));\n                    }\n                    break;\n            }\n            retval.stop = input.LT(-1);\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return retval;\n    }\n\n    // $ANTLR end \"namespaceName\"\n    public static class compositeNamespaceName_return extends ParserRuleReturnScope {\n    }\n\n    // $ANTLR start \"compositeNamespaceName\"\n    // net/sf/sugar/scl/SCL.g:182:1: compositeNamespaceName : ( VALID_NAME_CHARS )+ ( '.' ( VALID_NAME_CHARS )+ )+ ;\n    public final SCLParser.compositeNamespaceName_return compositeNamespaceName() throws RecognitionException {\n        SCLParser.compositeNamespaceName_return retval = new SCLParser.compositeNamespaceName_return();\n        retval.start = input.LT(1);\n        try {\n            // net/sf/sugar/scl/SCL.g:182:24: ( ( VALID_NAME_CHARS )+ ( '.' ( VALID_NAME_CHARS )+ )+ )\n            // net/sf/sugar/scl/SCL.g:182:28: ( VALID_NAME_CHARS )+ ( '.' ( VALID_NAME_CHARS )+ )+\n            {\n                // net/sf/sugar/scl/SCL.g:182:28: ( VALID_NAME_CHARS )+\n                int cnt4 = 0;\n                loop4: do {\n                    int alt4 = 2;\n                    switch(input.LA(1)) {\n                        case VALID_NAME_CHARS:\n                            {\n                                alt4 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt4) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:182:28: VALID_NAME_CHARS\n                            {\n                                match(input, VALID_NAME_CHARS, FOLLOW_VALID_NAME_CHARS_in_compositeNamespaceName160);\n                            }\n                            break;\n                        default:\n                            if (cnt4 >= 1)\n                                break loop4;\n                            EarlyExitException eee = new EarlyExitException(4, input);\n                            throw eee;\n                    }\n                    cnt4++;\n                } while (true);\n                // net/sf/sugar/scl/SCL.g:182:46: ( '.' ( VALID_NAME_CHARS )+ )+\n                int cnt6 = 0;\n                loop6: do {\n                    int alt6 = 2;\n                    switch(input.LA(1)) {\n                        case 19:\n                            {\n                                alt6 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt6) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:182:47: '.' ( VALID_NAME_CHARS )+\n                            {\n                                match(input, 19, FOLLOW_19_in_compositeNamespaceName164);\n                                // net/sf/sugar/scl/SCL.g:182:51: ( VALID_NAME_CHARS )+\n                                int cnt5 = 0;\n                                loop5: do {\n                                    int alt5 = 2;\n                                    switch(input.LA(1)) {\n                                        case VALID_NAME_CHARS:\n                                            {\n                                                alt5 = 1;\n                                            }\n                                            break;\n                                    }\n                                    switch(alt5) {\n                                        case 1:\n                                            // net/sf/sugar/scl/SCL.g:182:51: VALID_NAME_CHARS\n                                            {\n                                                match(input, VALID_NAME_CHARS, FOLLOW_VALID_NAME_CHARS_in_compositeNamespaceName166);\n                                            }\n                                            break;\n                                        default:\n                                            if (cnt5 >= 1)\n                                                break loop5;\n                                            EarlyExitException eee = new EarlyExitException(5, input);\n                                            throw eee;\n                                    }\n                                    cnt5++;\n                                } while (true);\n                            }\n                            break;\n                        default:\n                            if (cnt6 >= 1)\n                                break loop6;\n                            EarlyExitException eee = new EarlyExitException(6, input);\n                            throw eee;\n                    }\n                    cnt6++;\n                } while (true);\n            }\n            retval.stop = input.LT(-1);\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return retval;\n    }\n\n    // $ANTLR end \"compositeNamespaceName\"\n    // $ANTLR start \"namespaceBody\"\n    // net/sf/sugar/scl/SCL.g:184:1: namespaceBody : OPEN_NESTING ( statement )* CLOSE_NESTING ;\n    public final void namespaceBody() throws RecognitionException {\n        try {\n            // net/sf/sugar/scl/SCL.g:184:16: ( OPEN_NESTING ( statement )* CLOSE_NESTING )\n            // net/sf/sugar/scl/SCL.g:184:18: OPEN_NESTING ( statement )* CLOSE_NESTING\n            {\n                match(input, OPEN_NESTING, FOLLOW_OPEN_NESTING_in_namespaceBody181);\n                // net/sf/sugar/scl/SCL.g:184:31: ( statement )*\n                loop7: do {\n                    int alt7 = 2;\n                    switch(input.LA(1)) {\n                        case VALID_NAME_CHARS:\n                        case START_INCLUDE:\n                        case REF_CHAR:\n                            {\n                                alt7 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt7) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:184:32: statement\n                            {\n                                pushFollow(FOLLOW_statement_in_namespaceBody184);\n                                statement();\n                                state._fsp--;\n                            }\n                            break;\n                        default:\n                            break loop7;\n                    }\n                } while (true);\n                match(input, CLOSE_NESTING, FOLLOW_CLOSE_NESTING_in_namespaceBody188);\n                this.elements.pop();\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"namespaceBody\"\n    // $ANTLR start \"assignment\"\n    // net/sf/sugar/scl/SCL.g:188:1: assignment : varName ASSIGNMENT_OP ( varValue | includeValue | v= unparsedIncludeValue | r= localReference ) ;\n    public final void assignment() throws RecognitionException {\n        String v = null;\n        String r = null;\n        SCLParser.varName_return varName2 = null;\n        SCLParser.varValue_return varValue3 = null;\n        SCLParser.includeValue_return includeValue4 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:188:14: ( varName ASSIGNMENT_OP ( varValue | includeValue | v= unparsedIncludeValue | r= localReference ) )\n            // net/sf/sugar/scl/SCL.g:188:16: varName ASSIGNMENT_OP ( varValue | includeValue | v= unparsedIncludeValue | r= localReference )\n            {\n                pushFollow(FOLLOW_varName_in_assignment201);\n                varName2 = varName();\n                state._fsp--;\n                match(input, ASSIGNMENT_OP, FOLLOW_ASSIGNMENT_OP_in_assignment203);\n                // net/sf/sugar/scl/SCL.g:188:38: ( varValue | includeValue | v= unparsedIncludeValue | r= localReference )\n                int alt8 = 4;\n                switch(input.LA(1)) {\n                    case STRING_LITERAL:\n                        {\n                            alt8 = 1;\n                        }\n                        break;\n                    case START_INCLUDE:\n                        {\n                            alt8 = 2;\n                        }\n                        break;\n                    case START_UNPARSED_INCLUDE:\n                        {\n                            alt8 = 3;\n                        }\n                        break;\n                    case REF_CHAR:\n                        {\n                            alt8 = 4;\n                        }\n                        break;\n                    default:\n                        NoViableAltException nvae = new NoViableAltException(\"\", 8, 0, input);\n                        throw nvae;\n                }\n                switch(alt8) {\n                    case 1:\n                        // net/sf/sugar/scl/SCL.g:188:39: varValue\n                        {\n                            pushFollow(FOLLOW_varValue_in_assignment206);\n                            varValue3 = varValue();\n                            state._fsp--;\n                            addAttribute(this.elements.peek(), (varName2 != null ? input.toString(varName2.start, varName2.stop) : null), sanitiseText((varValue3 != null ? input.toString(varValue3.start, varValue3.stop) : null)));\n                        }\n                        break;\n                    case 2:\n                        // net/sf/sugar/scl/SCL.g:194:14: includeValue\n                        {\n                            pushFollow(FOLLOW_includeValue_in_assignment230);\n                            includeValue4 = includeValue();\n                            state._fsp--;\n                            try {\n                                this.loadIncludeValue(this.elements.peek(), (varName2 != null ? input.toString(varName2.start, varName2.stop) : null), sanitiseText((includeValue4 != null ? includeValue4.includeLocation : null)), sanitiseText((includeValue4 != null ? includeValue4.xPathQuery : null)));\n                            } catch (IncludeException ie) {\n                                ie.printStackTrace();\n                                System.out.println(ie);\n                            }\n                        }\n                        break;\n                    case 3:\n                        // net/sf/sugar/scl/SCL.g:205:12: v= unparsedIncludeValue\n                        {\n                            pushFollow(FOLLOW_unparsedIncludeValue_in_assignment247);\n                            v = unparsedIncludeValue();\n                            state._fsp--;\n                            try {\n                                this.loadUnparsedInclude(this.elements.peek(), (varName2 != null ? input.toString(varName2.start, varName2.stop) : null), v);\n                            } catch (IncludeException ie) {\n                                ie.printStackTrace();\n                            }\n                        }\n                        break;\n                    case 4:\n                        // net/sf/sugar/scl/SCL.g:212:15: r= localReference\n                        {\n                            pushFollow(FOLLOW_localReference_in_assignment267);\n                            r = localReference();\n                            state._fsp--;\n                            //todo : handle empty values, also handle non numeric, date and boolean return types\n                            prepareLocalRef(this.elements.peek(), (varName2 != null ? input.toString(varName2.start, varName2.stop) : null), r);\n                        }\n                        break;\n                }\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"assignment\"\n    public static class varName_return extends ParserRuleReturnScope {\n    }\n\n    // $ANTLR start \"varName\"\n    // net/sf/sugar/scl/SCL.g:218:1: varName : ( VALID_NAME_CHARS )+ ;\n    public final SCLParser.varName_return varName() throws RecognitionException {\n        SCLParser.varName_return retval = new SCLParser.varName_return();\n        retval.start = input.LT(1);\n        try {\n            // net/sf/sugar/scl/SCL.g:218:12: ( ( VALID_NAME_CHARS )+ )\n            // net/sf/sugar/scl/SCL.g:218:14: ( VALID_NAME_CHARS )+\n            {\n                // net/sf/sugar/scl/SCL.g:218:14: ( VALID_NAME_CHARS )+\n                int cnt9 = 0;\n                loop9: do {\n                    int alt9 = 2;\n                    switch(input.LA(1)) {\n                        case VALID_NAME_CHARS:\n                            {\n                                alt9 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt9) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:218:14: VALID_NAME_CHARS\n                            {\n                                match(input, VALID_NAME_CHARS, FOLLOW_VALID_NAME_CHARS_in_varName298);\n                            }\n                            break;\n                        default:\n                            if (cnt9 >= 1)\n                                break loop9;\n                            EarlyExitException eee = new EarlyExitException(9, input);\n                            throw eee;\n                    }\n                    cnt9++;\n                } while (true);\n            }\n            retval.stop = input.LT(-1);\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return retval;\n    }\n\n    // $ANTLR end \"varName\"\n    public static class varValue_return extends ParserRuleReturnScope {\n    }\n\n    // $ANTLR start \"varValue\"\n    // net/sf/sugar/scl/SCL.g:220:1: varValue : STRING_LITERAL ;\n    public final SCLParser.varValue_return varValue() throws RecognitionException {\n        SCLParser.varValue_return retval = new SCLParser.varValue_return();\n        retval.start = input.LT(1);\n        try {\n            // net/sf/sugar/scl/SCL.g:220:13: ( STRING_LITERAL )\n            // net/sf/sugar/scl/SCL.g:220:15: STRING_LITERAL\n            {\n                match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_varValue312);\n            }\n            retval.stop = input.LT(-1);\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return retval;\n    }\n\n    // $ANTLR end \"varValue\"\n    public static class includeValue_return extends ParserRuleReturnScope {\n\n        public String includeLocation;\n\n        public String xPathQuery;\n    }\n\n    // $ANTLR start \"includeValue\"\n    // net/sf/sugar/scl/SCL.g:223:1: includeValue returns [String includeLocation, String xPathQuery] : START_INCLUDE s1= STRING_LITERAL AS_KEYWORD s2= STRING_LITERAL END_INCLUDE ;\n    public final SCLParser.includeValue_return includeValue() throws RecognitionException {\n        SCLParser.includeValue_return retval = new SCLParser.includeValue_return();\n        retval.start = input.LT(1);\n        Token s1 = null;\n        Token s2 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:224:6: ( START_INCLUDE s1= STRING_LITERAL AS_KEYWORD s2= STRING_LITERAL END_INCLUDE )\n            // net/sf/sugar/scl/SCL.g:224:8: START_INCLUDE s1= STRING_LITERAL AS_KEYWORD s2= STRING_LITERAL END_INCLUDE\n            {\n                match(input, START_INCLUDE, FOLLOW_START_INCLUDE_in_includeValue334);\n                s1 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_includeValue338);\n                match(input, AS_KEYWORD, FOLLOW_AS_KEYWORD_in_includeValue340);\n                s2 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_includeValue344);\n                match(input, END_INCLUDE, FOLLOW_END_INCLUDE_in_includeValue346);\n                retval.includeLocation = (s1 != null ? s1.getText() : null);\n                retval.xPathQuery = (s2 != null ? s2.getText() : null);\n            }\n            retval.stop = input.LT(-1);\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return retval;\n    }\n\n    // $ANTLR end \"includeValue\"\n    // $ANTLR start \"unparsedIncludeValue\"\n    // net/sf/sugar/scl/SCL.g:229:1: unparsedIncludeValue returns [String includeLocation] : START_UNPARSED_INCLUDE s1= STRING_LITERAL END_INCLUDE ;\n    public final String unparsedIncludeValue() throws RecognitionException {\n        String includeLocation = null;\n        Token s1 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:230:6: ( START_UNPARSED_INCLUDE s1= STRING_LITERAL END_INCLUDE )\n            // net/sf/sugar/scl/SCL.g:230:8: START_UNPARSED_INCLUDE s1= STRING_LITERAL END_INCLUDE\n            {\n                match(input, START_UNPARSED_INCLUDE, FOLLOW_START_UNPARSED_INCLUDE_in_unparsedIncludeValue373);\n                s1 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_unparsedIncludeValue377);\n                match(input, END_INCLUDE, FOLLOW_END_INCLUDE_in_unparsedIncludeValue379);\n                includeLocation = stripQuotes(s1.getText());\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return includeLocation;\n    }\n\n    // $ANTLR end \"unparsedIncludeValue\"\n    // $ANTLR start \"includeTree\"\n    // net/sf/sugar/scl/SCL.g:234:1: includeTree : START_INCLUDE s1= STRING_LITERAL ( AS_KEYWORD s2= STRING_LITERAL )? END_INCLUDE ;\n    public final void includeTree() throws RecognitionException {\n        Token s1 = null;\n        Token s2 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:234:15: ( START_INCLUDE s1= STRING_LITERAL ( AS_KEYWORD s2= STRING_LITERAL )? END_INCLUDE )\n            // net/sf/sugar/scl/SCL.g:234:17: START_INCLUDE s1= STRING_LITERAL ( AS_KEYWORD s2= STRING_LITERAL )? END_INCLUDE\n            {\n                match(input, START_INCLUDE, FOLLOW_START_INCLUDE_in_includeTree399);\n                s1 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_includeTree403);\n                // net/sf/sugar/scl/SCL.g:234:49: ( AS_KEYWORD s2= STRING_LITERAL )?\n                int alt10 = 2;\n                switch(input.LA(1)) {\n                    case AS_KEYWORD:\n                        {\n                            alt10 = 1;\n                        }\n                        break;\n                }\n                switch(alt10) {\n                    case 1:\n                        // net/sf/sugar/scl/SCL.g:234:50: AS_KEYWORD s2= STRING_LITERAL\n                        {\n                            match(input, AS_KEYWORD, FOLLOW_AS_KEYWORD_in_includeTree406);\n                            s2 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_includeTree410);\n                        }\n                        break;\n                }\n                match(input, END_INCLUDE, FOLLOW_END_INCLUDE_in_includeTree414);\n                try {\n                    if (s2 == null || \"\".equals(s2)) {\n                        this.loadInclude(this.elements.peek(), sanitiseText(s1.getText()));\n                    } else {\n                        this.loadIncludeNodes(this.elements.peek(), sanitiseText(s1.getText()), sanitiseText(s2.getText()));\n                    }\n                } catch (IncludeException ie) {\n                    ie.printStackTrace();\n                }\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"includeTree\"\n    // $ANTLR start \"localRefTree\"\n    // net/sf/sugar/scl/SCL.g:250:1: localRefTree returns [String xPathQuery] : r= localReference ;\n    public final String localRefTree() throws RecognitionException {\n        String xPathQuery = null;\n        String r = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:251:7: (r= localReference )\n            // net/sf/sugar/scl/SCL.g:251:10: r= localReference\n            {\n                pushFollow(FOLLOW_localReference_in_localRefTree442);\n                r = localReference();\n                state._fsp--;\n                xPathQuery = r;\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return xPathQuery;\n    }\n\n    // $ANTLR end \"localRefTree\"\n    // $ANTLR start \"localReference\"\n    // net/sf/sugar/scl/SCL.g:253:1: localReference returns [String resolvedValue] : REF_CHAR ( WS )* STRING_LITERAL ;\n    public final String localReference() throws RecognitionException {\n        String resolvedValue = null;\n        Token STRING_LITERAL5 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:254:7: ( REF_CHAR ( WS )* STRING_LITERAL )\n            // net/sf/sugar/scl/SCL.g:254:10: REF_CHAR ( WS )* STRING_LITERAL\n            {\n                match(input, REF_CHAR, FOLLOW_REF_CHAR_in_localReference475);\n                // net/sf/sugar/scl/SCL.g:254:19: ( WS )*\n                loop11: do {\n                    int alt11 = 2;\n                    switch(input.LA(1)) {\n                        case WS:\n                            {\n                                alt11 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt11) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:254:19: WS\n                            {\n                                match(input, WS, FOLLOW_WS_in_localReference477);\n                            }\n                            break;\n                        default:\n                            break loop11;\n                    }\n                } while (true);\n                STRING_LITERAL5 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_localReference480);\n                resolvedValue = sanitiseText((STRING_LITERAL5 != null ? STRING_LITERAL5.getText() : null));\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return resolvedValue;\n    }\n\n    // $ANTLR end \"localReference\"\n    // Delegated rules\n    protected DFA2 dfa2 = new DFA2(this);\n\n    protected DFA3 dfa3 = new DFA3(this);\n\n    static final String DFA2_eotS = \"\\6\\uffff\";\n\n    static final String DFA2_eofS = \"\\6\\uffff\";\n\n    static final String DFA2_minS = \"\\2\\4\\4\\uffff\";\n\n    static final String DFA2_maxS = \"\\1\\15\\1\\23\\4\\uffff\";\n\n    static final String DFA2_acceptS = \"\\2\\uffff\\1\\3\\1\\4\\1\\1\\1\\2\";\n\n    static final String DFA2_specialS = \"\\6\\uffff}>\";\n\n    static final String[] DFA2_transitionS = { \"\\1\\1\\4\\uffff\\1\\2\\3\\uffff\\1\\3\", \"\\1\\1\\1\\4\\1\\uffff\\1\\5\\13\\uffff\\1\\4\", \"\", \"\", \"\", \"\" };\n\n    static final short[] DFA2_eot = DFA.unpackEncodedString(DFA2_eotS);\n\n    static final short[] DFA2_eof = DFA.unpackEncodedString(DFA2_eofS);\n\n    static final char[] DFA2_min = DFA.unpackEncodedStringToUnsignedChars(DFA2_minS);\n\n    static final char[] DFA2_max = DFA.unpackEncodedStringToUnsignedChars(DFA2_maxS);\n\n    static final short[] DFA2_accept = DFA.unpackEncodedString(DFA2_acceptS);\n\n    static final short[] DFA2_special = DFA.unpackEncodedString(DFA2_specialS);\n\n    static final short[][] DFA2_transition;\n\n    static {\n        int numStates = DFA2_transitionS.length;\n        DFA2_transition = new short[numStates][];\n        for (int i = 0; i < numStates; i++) {\n            DFA2_transition[i] = DFA.unpackEncodedString(DFA2_transitionS[i]);\n        }\n    }\n\n    class DFA2 extends DFA {\n\n        public DFA2(BaseRecognizer recognizer) {\n            this.recognizer = recognizer;\n            this.decisionNumber = 2;\n            this.eot = DFA2_eot;\n            this.eof = DFA2_eof;\n            this.min = DFA2_min;\n            this.max = DFA2_max;\n            this.accept = DFA2_accept;\n            this.special = DFA2_special;\n            this.transition = DFA2_transition;\n        }\n\n        public String getDescription() {\n            return \"170:1: statement : ( namespaceDecl | assignment | includeTree | t= localRefTree );\";\n        }\n    }\n\n    static final String DFA3_eotS = \"\\4\\uffff\";\n\n    static final String DFA3_eofS = \"\\4\\uffff\";\n\n    static final String DFA3_minS = \"\\2\\4\\2\\uffff\";\n\n    static final String DFA3_maxS = \"\\1\\4\\1\\23\\2\\uffff\";\n\n    static final String DFA3_acceptS = \"\\2\\uffff\\1\\1\\1\\2\";\n\n    static final String DFA3_specialS = \"\\4\\uffff}>\";\n\n    static final String[] DFA3_transitionS = { \"\\1\\1\", \"\\1\\1\\1\\2\\15\\uffff\\1\\3\", \"\", \"\" };\n\n    static final short[] DFA3_eot = DFA.unpackEncodedString(DFA3_eotS);\n\n    static final short[] DFA3_eof = DFA.unpackEncodedString(DFA3_eofS);\n\n    static final char[] DFA3_min = DFA.unpackEncodedStringToUnsignedChars(DFA3_minS);\n\n    static final char[] DFA3_max = DFA.unpackEncodedStringToUnsignedChars(DFA3_maxS);\n\n    static final short[] DFA3_accept = DFA.unpackEncodedString(DFA3_acceptS);\n\n    static final short[] DFA3_special = DFA.unpackEncodedString(DFA3_specialS);\n\n    static final short[][] DFA3_transition;\n\n    static {\n        int numStates = DFA3_transitionS.length;\n        DFA3_transition = new short[numStates][];\n        for (int i = 0; i < numStates; i++) {\n            DFA3_transition[i] = DFA.unpackEncodedString(DFA3_transitionS[i]);\n        }\n    }\n\n    class DFA3 extends DFA {\n\n        public DFA3(BaseRecognizer recognizer) {\n            this.recognizer = recognizer;\n            this.decisionNumber = 3;\n            this.eot = DFA3_eot;\n            this.eof = DFA3_eof;\n            this.min = DFA3_min;\n            this.max = DFA3_max;\n            this.accept = DFA3_accept;\n            this.special = DFA3_special;\n            this.transition = DFA3_transition;\n        }\n\n        public String getDescription() {\n            return \"179:1: namespaceName : ( varName | compositeNamespaceName );\";\n        }\n    }\n\n    public static final BitSet FOLLOW_statementSeq_in_scl44 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_statement_in_statementSeq61 = new BitSet(new long[] { 0x0000000000002212L });\n\n    public static final BitSet FOLLOW_namespaceDecl_in_statement73 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_assignment_in_statement84 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_includeTree_in_statement95 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_localRefTree_in_statement108 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_namespaceName_in_namespaceDecl120 = new BitSet(new long[] { 0x0000000000000020L });\n\n    public static final BitSet FOLLOW_namespaceBody_in_namespaceDecl122 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_varName_in_namespaceName132 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_compositeNamespaceName_in_namespaceName145 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_VALID_NAME_CHARS_in_compositeNamespaceName160 = new BitSet(new long[] { 0x0000000000080010L });\n\n    public static final BitSet FOLLOW_19_in_compositeNamespaceName164 = new BitSet(new long[] { 0x0000000000000010L });\n\n    public static final BitSet FOLLOW_VALID_NAME_CHARS_in_compositeNamespaceName166 = new BitSet(new long[] { 0x0000000000080012L });\n\n    public static final BitSet FOLLOW_OPEN_NESTING_in_namespaceBody181 = new BitSet(new long[] { 0x0000000000002250L });\n\n    public static final BitSet FOLLOW_statement_in_namespaceBody184 = new BitSet(new long[] { 0x0000000000002250L });\n\n    public static final BitSet FOLLOW_CLOSE_NESTING_in_namespaceBody188 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_varName_in_assignment201 = new BitSet(new long[] { 0x0000000000000080L });\n\n    public static final BitSet FOLLOW_ASSIGNMENT_OP_in_assignment203 = new BitSet(new long[] { 0x0000000000003310L });\n\n    public static final BitSet FOLLOW_varValue_in_assignment206 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_includeValue_in_assignment230 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_unparsedIncludeValue_in_assignment247 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_localReference_in_assignment267 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_VALID_NAME_CHARS_in_varName298 = new BitSet(new long[] { 0x0000000000000012L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_varValue312 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_START_INCLUDE_in_includeValue334 = new BitSet(new long[] { 0x0000000000000100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_includeValue338 = new BitSet(new long[] { 0x0000000000000400L });\n\n    public static final BitSet FOLLOW_AS_KEYWORD_in_includeValue340 = new BitSet(new long[] { 0x0000000000000100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_includeValue344 = new BitSet(new long[] { 0x0000000000000800L });\n\n    public static final BitSet FOLLOW_END_INCLUDE_in_includeValue346 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_START_UNPARSED_INCLUDE_in_unparsedIncludeValue373 = new BitSet(new long[] { 0x0000000000000100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_unparsedIncludeValue377 = new BitSet(new long[] { 0x0000000000000800L });\n\n    public static final BitSet FOLLOW_END_INCLUDE_in_unparsedIncludeValue379 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_START_INCLUDE_in_includeTree399 = new BitSet(new long[] { 0x0000000000000100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_includeTree403 = new BitSet(new long[] { 0x0000000000000C00L });\n\n    public static final BitSet FOLLOW_AS_KEYWORD_in_includeTree406 = new BitSet(new long[] { 0x0000000000000100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_includeTree410 = new BitSet(new long[] { 0x0000000000000800L });\n\n    public static final BitSet FOLLOW_END_INCLUDE_in_includeTree414 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_localReference_in_localRefTree442 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_REF_CHAR_in_localReference475 = new BitSet(new long[] { 0x0000000000004100L });\n\n    public static final BitSet FOLLOW_WS_in_localReference477 = new BitSet(new long[] { 0x0000000000004100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_localReference480 = new BitSet(new long[] { 0x0000000000000002L });\n}\n",
		"id": "/EvoSuiteBenchmark/60_sugar/src/main/java/net/sf/sugar/scl/SCLParser_7Test.java",
		"test_prompt": "// SCLParser_7Test.java\npackage net.sf.sugar.scl;\n\nimport static net.sf.sugar.scl.PathConversionUtils.convertToXPath;\nimport static net.sf.sugar.scl.PathConversionUtils.processDotDelimitedPath;\nimport java.net.URI;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Element;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathFactory;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpressionException;\nimport org.antlr.runtime.*;\nimport java.util.Stack;\nimport java.util.List;\nimport java.util.ArrayList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SCLParser}.\n* It contains ten unit test cases for the {@link SCLParser#unparsedIncludeValue()} method.\n*/\nclass SCLParser_7Test {"
	},
	{
		"original_code": "// SCLParser.java\n// $ANTLR 3.3 Nov 30, 2010 12:46:29 net/sf/sugar/scl/SCL.g 2013-06-10 17:15:03\npackage net.sf.sugar.scl;\n\nimport static net.sf.sugar.scl.PathConversionUtils.convertToXPath;\nimport static net.sf.sugar.scl.PathConversionUtils.processDotDelimitedPath;\nimport java.net.URI;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Element;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathFactory;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpressionException;\nimport org.antlr.runtime.*;\nimport java.util.Stack;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class SCLParser extends Parser {\n\n    public static final String[] tokenNames = new String[] { \"<invalid>\", \"<EOR>\", \"<DOWN>\", \"<UP>\", \"VALID_NAME_CHARS\", \"OPEN_NESTING\", \"CLOSE_NESTING\", \"ASSIGNMENT_OP\", \"STRING_LITERAL\", \"START_INCLUDE\", \"AS_KEYWORD\", \"END_INCLUDE\", \"START_UNPARSED_INCLUDE\", \"REF_CHAR\", \"WS\", \"QUOTE\", \"STRING_SEQUENCE_CHAR\", \"COMMENT\", \"LINE_COMMENT\", \"'.'\" };\n\n    public static final int EOF = -1;\n\n    public static final int T__19 = 19;\n\n    public static final int VALID_NAME_CHARS = 4;\n\n    public static final int OPEN_NESTING = 5;\n\n    public static final int CLOSE_NESTING = 6;\n\n    public static final int ASSIGNMENT_OP = 7;\n\n    public static final int STRING_LITERAL = 8;\n\n    public static final int START_INCLUDE = 9;\n\n    public static final int AS_KEYWORD = 10;\n\n    public static final int END_INCLUDE = 11;\n\n    public static final int START_UNPARSED_INCLUDE = 12;\n\n    public static final int REF_CHAR = 13;\n\n    public static final int WS = 14;\n\n    public static final int QUOTE = 15;\n\n    public static final int STRING_SEQUENCE_CHAR = 16;\n\n    public static final int COMMENT = 17;\n\n    public static final int LINE_COMMENT = 18;\n\n    // delegates\n    // delegators\n    public SCLParser(TokenStream input) {\n        this(input, new RecognizerSharedState());\n    }\n\n    public SCLParser(TokenStream input, RecognizerSharedState state) {\n        super(input, state);\n    }\n\n    public String[] getTokenNames() {\n        return SCLParser.tokenNames;\n    }\n\n    public String getGrammarFileName() {\n        return \"net/sf/sugar/scl/SCL.g\";\n    }\n\n    public static final String SCL_ROOT_ELEMENT = \"scl\";\n\n    private URI rootSCLFile;\n\n    private Document doc;\n\n    private Stack<Element> elements = new Stack<Element>();\n\n    private XPath xpath = XPathFactory.newInstance().newXPath();\n\n    private IncludeProcessor includeProcessor;\n\n    private static LocalReferenceProcessor localReferenceProcessor;\n\n    private List<LocalReference> localRefs = new ArrayList<LocalReference>();\n\n    private int namespaceSteps;\n\n    {\n        try {\n            doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n            Element rootElement = doc.createElement(SCL_ROOT_ELEMENT);\n            doc.appendChild(rootElement);\n            this.elements.push(rootElement);\n        } catch (ParserConfigurationException pce) {\n            pce.printStackTrace();\n        }\n    }\n\n    protected Element addChildElement(Element element, String child) {\n        Element childElement = this.doc.createElement(child);\n        element.appendChild(childElement);\n        return childElement;\n    }\n\n    protected Element addChildElements(Element currentElement, String compositePath) {\n        return processDotDelimitedPath(currentElement, compositePath);\n    }\n\n    protected void addAttribute(Element currentElement, String attributeName, String attributeValue) {\n        Element childElement = this.doc.createElement(attributeName);\n        childElement.setTextContent(attributeValue);\n        currentElement.appendChild(childElement);\n    }\n\n    protected void loadIncludeValue(Element parentElement, String propertyName, String includeLocation, String xPathExpression) throws IncludeException {\n        this.includeProcessor.prepareIncludeValue(parentElement, propertyName, includeLocation, this.rootSCLFile, xPathExpression);\n    }\n\n    protected void loadInclude(Element parentElement, String includeLocation) throws IncludeException {\n        this.includeProcessor.prepareInclude(parentElement, includeLocation, this.rootSCLFile);\n    }\n\n    protected void loadIncludeNodes(Element parentElement, String includeLocation, String xPathExpression) throws IncludeException {\n        this.includeProcessor.prepareInclude(parentElement, includeLocation, this.rootSCLFile, xPathExpression);\n    }\n\n    protected void loadUnparsedInclude(Element parentElement, String propertyName, String includeLocation) throws IncludeException {\n        this.includeProcessor.loadUnparsedInclude(parentElement, propertyName, includeLocation, this.rootSCLFile);\n    }\n\n    protected void prepareLocalRefTree(final Element parentElement, final String xPathExpression) {\n        LocalReference localRef = new LocalReference() {\n\n            {\n                setParentElement(parentElement);\n                setXPathQuery(xPathExpression);\n            }\n        };\n        this.localRefs.add(localRef);\n    }\n\n    protected void prepareLocalRef(final Element parentElement, final String attributeName, final String xPathExpression) {\n        LocalAttributeReference localRef = new LocalAttributeReference() {\n\n            {\n                setParentElement(parentElement);\n                setXPathQuery(xPathExpression);\n                setAttributeName(attributeName);\n            }\n        };\n        this.localRefs.add(localRef);\n    }\n\n    public void setRootSCLFile(URI rootSCLFile) {\n        this.rootSCLFile = rootSCLFile;\n    }\n\n    public URI getRootSCLFile() {\n        return this.rootSCLFile;\n    }\n\n    public Document getRootDocument() {\n        return this.doc;\n    }\n\n    public void setIncludeProcessor(IncludeProcessor includeProcessor) {\n        this.includeProcessor = includeProcessor;\n    }\n\n    public IncludeProcessor getIncludeProcessor() {\n        return this.includeProcessor;\n    }\n\n    public void setLocalReferenceProcessor(LocalReferenceProcessor processor) {\n        localReferenceProcessor = processor;\n    }\n\n    public LocalReferenceProcessor getLocalReferenceProcessor() {\n        return localReferenceProcessor;\n    }\n\n    public List<LocalReference> getLocalRefs() {\n        return this.localRefs;\n    }\n\n    public String sanitiseText(String rawText) {\n        String unquotedText = stripQuotes(rawText);\n        return normaliseEscapeChars(unquotedText);\n    }\n\n    private String stripQuotes(String quotedText) {\n        return quotedText.substring(1, quotedText.length() - 1);\n    }\n\n    private String normaliseEscapeChars(String text) {\n        return text.replace(\"\\\\\\\\\", \"\\\\\").replace(\"\\\\\\\"\", \"\\\"\");\n    }\n\n    // $ANTLR start \"scl\"\n    // net/sf/sugar/scl/SCL.g:152:1: scl returns [Document properties] : statementSeq ;\n    public final Document scl() throws RecognitionException {\n        Document properties = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:153:6: ( statementSeq )\n            // net/sf/sugar/scl/SCL.g:153:8: statementSeq\n            {\n                pushFollow(FOLLOW_statementSeq_in_scl44);\n                statementSeq();\n                state._fsp--;\n                try {\n                    this.includeProcessor.resolveIncludes(this.doc);\n                    localReferenceProcessor.processLocalReferences(this.localRefs);\n                } catch (IncludeException ie) {\n                    ie.printStackTrace();\n                } catch (LocalReferenceException lre) {\n                    lre.printStackTrace();\n                }\n                properties = doc;\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return properties;\n    }\n\n    // $ANTLR end \"scl\"\n    // $ANTLR start \"statementSeq\"\n    // net/sf/sugar/scl/SCL.g:168:1: statementSeq : ( statement )+ ;\n    public final void statementSeq() throws RecognitionException {\n        try {\n            // net/sf/sugar/scl/SCL.g:168:15: ( ( statement )+ )\n            // net/sf/sugar/scl/SCL.g:168:17: ( statement )+\n            {\n                // net/sf/sugar/scl/SCL.g:168:17: ( statement )+\n                int cnt1 = 0;\n                loop1: do {\n                    int alt1 = 2;\n                    switch(input.LA(1)) {\n                        case VALID_NAME_CHARS:\n                        case START_INCLUDE:\n                        case REF_CHAR:\n                            {\n                                alt1 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt1) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:168:17: statement\n                            {\n                                pushFollow(FOLLOW_statement_in_statementSeq61);\n                                statement();\n                                state._fsp--;\n                            }\n                            break;\n                        default:\n                            if (cnt1 >= 1)\n                                break loop1;\n                            EarlyExitException eee = new EarlyExitException(1, input);\n                            throw eee;\n                    }\n                    cnt1++;\n                } while (true);\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"statementSeq\"\n    // $ANTLR start \"statement\"\n    // net/sf/sugar/scl/SCL.g:170:1: statement : ( namespaceDecl | assignment | includeTree | t= localRefTree );\n    public final void statement() throws RecognitionException {\n        String t = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:170:13: ( namespaceDecl | assignment | includeTree | t= localRefTree )\n            int alt2 = 4;\n            alt2 = dfa2.predict(input);\n            switch(alt2) {\n                case 1:\n                    // net/sf/sugar/scl/SCL.g:170:15: namespaceDecl\n                    {\n                        pushFollow(FOLLOW_namespaceDecl_in_statement73);\n                        namespaceDecl();\n                        state._fsp--;\n                    }\n                    break;\n                case 2:\n                    // net/sf/sugar/scl/SCL.g:171:9: assignment\n                    {\n                        pushFollow(FOLLOW_assignment_in_statement84);\n                        assignment();\n                        state._fsp--;\n                    }\n                    break;\n                case 3:\n                    // net/sf/sugar/scl/SCL.g:172:9: includeTree\n                    {\n                        pushFollow(FOLLOW_includeTree_in_statement95);\n                        includeTree();\n                        state._fsp--;\n                    }\n                    break;\n                case 4:\n                    // net/sf/sugar/scl/SCL.g:173:9: t= localRefTree\n                    {\n                        pushFollow(FOLLOW_localRefTree_in_statement108);\n                        t = localRefTree();\n                        state._fsp--;\n                        prepareLocalRefTree(this.elements.peek(), t);\n                    }\n                    break;\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"statement\"\n    // $ANTLR start \"namespaceDecl\"\n    // net/sf/sugar/scl/SCL.g:177:1: namespaceDecl : namespaceName namespaceBody ;\n    public final void namespaceDecl() throws RecognitionException {\n        try {\n            // net/sf/sugar/scl/SCL.g:177:16: ( namespaceName namespaceBody )\n            // net/sf/sugar/scl/SCL.g:177:18: namespaceName namespaceBody\n            {\n                pushFollow(FOLLOW_namespaceName_in_namespaceDecl120);\n                namespaceName();\n                state._fsp--;\n                pushFollow(FOLLOW_namespaceBody_in_namespaceDecl122);\n                namespaceBody();\n                state._fsp--;\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"namespaceDecl\"\n    public static class namespaceName_return extends ParserRuleReturnScope {\n    }\n\n    // $ANTLR start \"namespaceName\"\n    // net/sf/sugar/scl/SCL.g:179:1: namespaceName : ( varName | compositeNamespaceName );\n    public final SCLParser.namespaceName_return namespaceName() throws RecognitionException {\n        SCLParser.namespaceName_return retval = new SCLParser.namespaceName_return();\n        retval.start = input.LT(1);\n        SCLParser.compositeNamespaceName_return compositeNamespaceName1 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:179:16: ( varName | compositeNamespaceName )\n            int alt3 = 2;\n            alt3 = dfa3.predict(input);\n            switch(alt3) {\n                case 1:\n                    // net/sf/sugar/scl/SCL.g:179:18: varName\n                    {\n                        pushFollow(FOLLOW_varName_in_namespaceName132);\n                        varName();\n                        state._fsp--;\n                        this.elements.push(addChildElement(this.elements.peek(), input.toString(retval.start, input.LT(-1))));\n                    }\n                    break;\n                case 2:\n                    // net/sf/sugar/scl/SCL.g:180:9: compositeNamespaceName\n                    {\n                        pushFollow(FOLLOW_compositeNamespaceName_in_namespaceName145);\n                        compositeNamespaceName1 = compositeNamespaceName();\n                        state._fsp--;\n                        this.elements.push(addChildElements(this.elements.peek(), (compositeNamespaceName1 != null ? input.toString(compositeNamespaceName1.start, compositeNamespaceName1.stop) : null)));\n                    }\n                    break;\n            }\n            retval.stop = input.LT(-1);\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return retval;\n    }\n\n    // $ANTLR end \"namespaceName\"\n    public static class compositeNamespaceName_return extends ParserRuleReturnScope {\n    }\n\n    // $ANTLR start \"compositeNamespaceName\"\n    // net/sf/sugar/scl/SCL.g:182:1: compositeNamespaceName : ( VALID_NAME_CHARS )+ ( '.' ( VALID_NAME_CHARS )+ )+ ;\n    public final SCLParser.compositeNamespaceName_return compositeNamespaceName() throws RecognitionException {\n        SCLParser.compositeNamespaceName_return retval = new SCLParser.compositeNamespaceName_return();\n        retval.start = input.LT(1);\n        try {\n            // net/sf/sugar/scl/SCL.g:182:24: ( ( VALID_NAME_CHARS )+ ( '.' ( VALID_NAME_CHARS )+ )+ )\n            // net/sf/sugar/scl/SCL.g:182:28: ( VALID_NAME_CHARS )+ ( '.' ( VALID_NAME_CHARS )+ )+\n            {\n                // net/sf/sugar/scl/SCL.g:182:28: ( VALID_NAME_CHARS )+\n                int cnt4 = 0;\n                loop4: do {\n                    int alt4 = 2;\n                    switch(input.LA(1)) {\n                        case VALID_NAME_CHARS:\n                            {\n                                alt4 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt4) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:182:28: VALID_NAME_CHARS\n                            {\n                                match(input, VALID_NAME_CHARS, FOLLOW_VALID_NAME_CHARS_in_compositeNamespaceName160);\n                            }\n                            break;\n                        default:\n                            if (cnt4 >= 1)\n                                break loop4;\n                            EarlyExitException eee = new EarlyExitException(4, input);\n                            throw eee;\n                    }\n                    cnt4++;\n                } while (true);\n                // net/sf/sugar/scl/SCL.g:182:46: ( '.' ( VALID_NAME_CHARS )+ )+\n                int cnt6 = 0;\n                loop6: do {\n                    int alt6 = 2;\n                    switch(input.LA(1)) {\n                        case 19:\n                            {\n                                alt6 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt6) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:182:47: '.' ( VALID_NAME_CHARS )+\n                            {\n                                match(input, 19, FOLLOW_19_in_compositeNamespaceName164);\n                                // net/sf/sugar/scl/SCL.g:182:51: ( VALID_NAME_CHARS )+\n                                int cnt5 = 0;\n                                loop5: do {\n                                    int alt5 = 2;\n                                    switch(input.LA(1)) {\n                                        case VALID_NAME_CHARS:\n                                            {\n                                                alt5 = 1;\n                                            }\n                                            break;\n                                    }\n                                    switch(alt5) {\n                                        case 1:\n                                            // net/sf/sugar/scl/SCL.g:182:51: VALID_NAME_CHARS\n                                            {\n                                                match(input, VALID_NAME_CHARS, FOLLOW_VALID_NAME_CHARS_in_compositeNamespaceName166);\n                                            }\n                                            break;\n                                        default:\n                                            if (cnt5 >= 1)\n                                                break loop5;\n                                            EarlyExitException eee = new EarlyExitException(5, input);\n                                            throw eee;\n                                    }\n                                    cnt5++;\n                                } while (true);\n                            }\n                            break;\n                        default:\n                            if (cnt6 >= 1)\n                                break loop6;\n                            EarlyExitException eee = new EarlyExitException(6, input);\n                            throw eee;\n                    }\n                    cnt6++;\n                } while (true);\n            }\n            retval.stop = input.LT(-1);\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return retval;\n    }\n\n    // $ANTLR end \"compositeNamespaceName\"\n    // $ANTLR start \"namespaceBody\"\n    // net/sf/sugar/scl/SCL.g:184:1: namespaceBody : OPEN_NESTING ( statement )* CLOSE_NESTING ;\n    public final void namespaceBody() throws RecognitionException {\n        try {\n            // net/sf/sugar/scl/SCL.g:184:16: ( OPEN_NESTING ( statement )* CLOSE_NESTING )\n            // net/sf/sugar/scl/SCL.g:184:18: OPEN_NESTING ( statement )* CLOSE_NESTING\n            {\n                match(input, OPEN_NESTING, FOLLOW_OPEN_NESTING_in_namespaceBody181);\n                // net/sf/sugar/scl/SCL.g:184:31: ( statement )*\n                loop7: do {\n                    int alt7 = 2;\n                    switch(input.LA(1)) {\n                        case VALID_NAME_CHARS:\n                        case START_INCLUDE:\n                        case REF_CHAR:\n                            {\n                                alt7 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt7) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:184:32: statement\n                            {\n                                pushFollow(FOLLOW_statement_in_namespaceBody184);\n                                statement();\n                                state._fsp--;\n                            }\n                            break;\n                        default:\n                            break loop7;\n                    }\n                } while (true);\n                match(input, CLOSE_NESTING, FOLLOW_CLOSE_NESTING_in_namespaceBody188);\n                this.elements.pop();\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"namespaceBody\"\n    // $ANTLR start \"assignment\"\n    // net/sf/sugar/scl/SCL.g:188:1: assignment : varName ASSIGNMENT_OP ( varValue | includeValue | v= unparsedIncludeValue | r= localReference ) ;\n    public final void assignment() throws RecognitionException {\n        String v = null;\n        String r = null;\n        SCLParser.varName_return varName2 = null;\n        SCLParser.varValue_return varValue3 = null;\n        SCLParser.includeValue_return includeValue4 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:188:14: ( varName ASSIGNMENT_OP ( varValue | includeValue | v= unparsedIncludeValue | r= localReference ) )\n            // net/sf/sugar/scl/SCL.g:188:16: varName ASSIGNMENT_OP ( varValue | includeValue | v= unparsedIncludeValue | r= localReference )\n            {\n                pushFollow(FOLLOW_varName_in_assignment201);\n                varName2 = varName();\n                state._fsp--;\n                match(input, ASSIGNMENT_OP, FOLLOW_ASSIGNMENT_OP_in_assignment203);\n                // net/sf/sugar/scl/SCL.g:188:38: ( varValue | includeValue | v= unparsedIncludeValue | r= localReference )\n                int alt8 = 4;\n                switch(input.LA(1)) {\n                    case STRING_LITERAL:\n                        {\n                            alt8 = 1;\n                        }\n                        break;\n                    case START_INCLUDE:\n                        {\n                            alt8 = 2;\n                        }\n                        break;\n                    case START_UNPARSED_INCLUDE:\n                        {\n                            alt8 = 3;\n                        }\n                        break;\n                    case REF_CHAR:\n                        {\n                            alt8 = 4;\n                        }\n                        break;\n                    default:\n                        NoViableAltException nvae = new NoViableAltException(\"\", 8, 0, input);\n                        throw nvae;\n                }\n                switch(alt8) {\n                    case 1:\n                        // net/sf/sugar/scl/SCL.g:188:39: varValue\n                        {\n                            pushFollow(FOLLOW_varValue_in_assignment206);\n                            varValue3 = varValue();\n                            state._fsp--;\n                            addAttribute(this.elements.peek(), (varName2 != null ? input.toString(varName2.start, varName2.stop) : null), sanitiseText((varValue3 != null ? input.toString(varValue3.start, varValue3.stop) : null)));\n                        }\n                        break;\n                    case 2:\n                        // net/sf/sugar/scl/SCL.g:194:14: includeValue\n                        {\n                            pushFollow(FOLLOW_includeValue_in_assignment230);\n                            includeValue4 = includeValue();\n                            state._fsp--;\n                            try {\n                                this.loadIncludeValue(this.elements.peek(), (varName2 != null ? input.toString(varName2.start, varName2.stop) : null), sanitiseText((includeValue4 != null ? includeValue4.includeLocation : null)), sanitiseText((includeValue4 != null ? includeValue4.xPathQuery : null)));\n                            } catch (IncludeException ie) {\n                                ie.printStackTrace();\n                                System.out.println(ie);\n                            }\n                        }\n                        break;\n                    case 3:\n                        // net/sf/sugar/scl/SCL.g:205:12: v= unparsedIncludeValue\n                        {\n                            pushFollow(FOLLOW_unparsedIncludeValue_in_assignment247);\n                            v = unparsedIncludeValue();\n                            state._fsp--;\n                            try {\n                                this.loadUnparsedInclude(this.elements.peek(), (varName2 != null ? input.toString(varName2.start, varName2.stop) : null), v);\n                            } catch (IncludeException ie) {\n                                ie.printStackTrace();\n                            }\n                        }\n                        break;\n                    case 4:\n                        // net/sf/sugar/scl/SCL.g:212:15: r= localReference\n                        {\n                            pushFollow(FOLLOW_localReference_in_assignment267);\n                            r = localReference();\n                            state._fsp--;\n                            //todo : handle empty values, also handle non numeric, date and boolean return types\n                            prepareLocalRef(this.elements.peek(), (varName2 != null ? input.toString(varName2.start, varName2.stop) : null), r);\n                        }\n                        break;\n                }\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"assignment\"\n    public static class varName_return extends ParserRuleReturnScope {\n    }\n\n    // $ANTLR start \"varName\"\n    // net/sf/sugar/scl/SCL.g:218:1: varName : ( VALID_NAME_CHARS )+ ;\n    public final SCLParser.varName_return varName() throws RecognitionException {\n        SCLParser.varName_return retval = new SCLParser.varName_return();\n        retval.start = input.LT(1);\n        try {\n            // net/sf/sugar/scl/SCL.g:218:12: ( ( VALID_NAME_CHARS )+ )\n            // net/sf/sugar/scl/SCL.g:218:14: ( VALID_NAME_CHARS )+\n            {\n                // net/sf/sugar/scl/SCL.g:218:14: ( VALID_NAME_CHARS )+\n                int cnt9 = 0;\n                loop9: do {\n                    int alt9 = 2;\n                    switch(input.LA(1)) {\n                        case VALID_NAME_CHARS:\n                            {\n                                alt9 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt9) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:218:14: VALID_NAME_CHARS\n                            {\n                                match(input, VALID_NAME_CHARS, FOLLOW_VALID_NAME_CHARS_in_varName298);\n                            }\n                            break;\n                        default:\n                            if (cnt9 >= 1)\n                                break loop9;\n                            EarlyExitException eee = new EarlyExitException(9, input);\n                            throw eee;\n                    }\n                    cnt9++;\n                } while (true);\n            }\n            retval.stop = input.LT(-1);\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return retval;\n    }\n\n    // $ANTLR end \"varName\"\n    public static class varValue_return extends ParserRuleReturnScope {\n    }\n\n    // $ANTLR start \"varValue\"\n    // net/sf/sugar/scl/SCL.g:220:1: varValue : STRING_LITERAL ;\n    public final SCLParser.varValue_return varValue() throws RecognitionException {\n        SCLParser.varValue_return retval = new SCLParser.varValue_return();\n        retval.start = input.LT(1);\n        try {\n            // net/sf/sugar/scl/SCL.g:220:13: ( STRING_LITERAL )\n            // net/sf/sugar/scl/SCL.g:220:15: STRING_LITERAL\n            {\n                match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_varValue312);\n            }\n            retval.stop = input.LT(-1);\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return retval;\n    }\n\n    // $ANTLR end \"varValue\"\n    public static class includeValue_return extends ParserRuleReturnScope {\n\n        public String includeLocation;\n\n        public String xPathQuery;\n    }\n\n    // $ANTLR start \"includeValue\"\n    // net/sf/sugar/scl/SCL.g:223:1: includeValue returns [String includeLocation, String xPathQuery] : START_INCLUDE s1= STRING_LITERAL AS_KEYWORD s2= STRING_LITERAL END_INCLUDE ;\n    public final SCLParser.includeValue_return includeValue() throws RecognitionException {\n        SCLParser.includeValue_return retval = new SCLParser.includeValue_return();\n        retval.start = input.LT(1);\n        Token s1 = null;\n        Token s2 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:224:6: ( START_INCLUDE s1= STRING_LITERAL AS_KEYWORD s2= STRING_LITERAL END_INCLUDE )\n            // net/sf/sugar/scl/SCL.g:224:8: START_INCLUDE s1= STRING_LITERAL AS_KEYWORD s2= STRING_LITERAL END_INCLUDE\n            {\n                match(input, START_INCLUDE, FOLLOW_START_INCLUDE_in_includeValue334);\n                s1 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_includeValue338);\n                match(input, AS_KEYWORD, FOLLOW_AS_KEYWORD_in_includeValue340);\n                s2 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_includeValue344);\n                match(input, END_INCLUDE, FOLLOW_END_INCLUDE_in_includeValue346);\n                retval.includeLocation = (s1 != null ? s1.getText() : null);\n                retval.xPathQuery = (s2 != null ? s2.getText() : null);\n            }\n            retval.stop = input.LT(-1);\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return retval;\n    }\n\n    // $ANTLR end \"includeValue\"\n    // $ANTLR start \"unparsedIncludeValue\"\n    // net/sf/sugar/scl/SCL.g:229:1: unparsedIncludeValue returns [String includeLocation] : START_UNPARSED_INCLUDE s1= STRING_LITERAL END_INCLUDE ;\n    public final String unparsedIncludeValue() throws RecognitionException {\n        String includeLocation = null;\n        Token s1 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:230:6: ( START_UNPARSED_INCLUDE s1= STRING_LITERAL END_INCLUDE )\n            // net/sf/sugar/scl/SCL.g:230:8: START_UNPARSED_INCLUDE s1= STRING_LITERAL END_INCLUDE\n            {\n                match(input, START_UNPARSED_INCLUDE, FOLLOW_START_UNPARSED_INCLUDE_in_unparsedIncludeValue373);\n                s1 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_unparsedIncludeValue377);\n                match(input, END_INCLUDE, FOLLOW_END_INCLUDE_in_unparsedIncludeValue379);\n                includeLocation = stripQuotes(s1.getText());\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return includeLocation;\n    }\n\n    // $ANTLR end \"unparsedIncludeValue\"\n    // $ANTLR start \"includeTree\"\n    // net/sf/sugar/scl/SCL.g:234:1: includeTree : START_INCLUDE s1= STRING_LITERAL ( AS_KEYWORD s2= STRING_LITERAL )? END_INCLUDE ;\n    public final void includeTree() throws RecognitionException {\n        Token s1 = null;\n        Token s2 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:234:15: ( START_INCLUDE s1= STRING_LITERAL ( AS_KEYWORD s2= STRING_LITERAL )? END_INCLUDE )\n            // net/sf/sugar/scl/SCL.g:234:17: START_INCLUDE s1= STRING_LITERAL ( AS_KEYWORD s2= STRING_LITERAL )? END_INCLUDE\n            {\n                match(input, START_INCLUDE, FOLLOW_START_INCLUDE_in_includeTree399);\n                s1 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_includeTree403);\n                // net/sf/sugar/scl/SCL.g:234:49: ( AS_KEYWORD s2= STRING_LITERAL )?\n                int alt10 = 2;\n                switch(input.LA(1)) {\n                    case AS_KEYWORD:\n                        {\n                            alt10 = 1;\n                        }\n                        break;\n                }\n                switch(alt10) {\n                    case 1:\n                        // net/sf/sugar/scl/SCL.g:234:50: AS_KEYWORD s2= STRING_LITERAL\n                        {\n                            match(input, AS_KEYWORD, FOLLOW_AS_KEYWORD_in_includeTree406);\n                            s2 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_includeTree410);\n                        }\n                        break;\n                }\n                match(input, END_INCLUDE, FOLLOW_END_INCLUDE_in_includeTree414);\n                try {\n                    if (s2 == null || \"\".equals(s2)) {\n                        this.loadInclude(this.elements.peek(), sanitiseText(s1.getText()));\n                    } else {\n                        this.loadIncludeNodes(this.elements.peek(), sanitiseText(s1.getText()), sanitiseText(s2.getText()));\n                    }\n                } catch (IncludeException ie) {\n                    ie.printStackTrace();\n                }\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"includeTree\"\n    // $ANTLR start \"localRefTree\"\n    // net/sf/sugar/scl/SCL.g:250:1: localRefTree returns [String xPathQuery] : r= localReference ;\n    public final String localRefTree() throws RecognitionException {\n        String xPathQuery = null;\n        String r = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:251:7: (r= localReference )\n            // net/sf/sugar/scl/SCL.g:251:10: r= localReference\n            {\n                pushFollow(FOLLOW_localReference_in_localRefTree442);\n                r = localReference();\n                state._fsp--;\n                xPathQuery = r;\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return xPathQuery;\n    }\n\n    // $ANTLR end \"localRefTree\"\n    // $ANTLR start \"localReference\"\n    // net/sf/sugar/scl/SCL.g:253:1: localReference returns [String resolvedValue] : REF_CHAR ( WS )* STRING_LITERAL ;\n    public final String localReference() throws RecognitionException {\n        String resolvedValue = null;\n        Token STRING_LITERAL5 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:254:7: ( REF_CHAR ( WS )* STRING_LITERAL )\n            // net/sf/sugar/scl/SCL.g:254:10: REF_CHAR ( WS )* STRING_LITERAL\n            {\n                match(input, REF_CHAR, FOLLOW_REF_CHAR_in_localReference475);\n                // net/sf/sugar/scl/SCL.g:254:19: ( WS )*\n                loop11: do {\n                    int alt11 = 2;\n                    switch(input.LA(1)) {\n                        case WS:\n                            {\n                                alt11 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt11) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:254:19: WS\n                            {\n                                match(input, WS, FOLLOW_WS_in_localReference477);\n                            }\n                            break;\n                        default:\n                            break loop11;\n                    }\n                } while (true);\n                STRING_LITERAL5 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_localReference480);\n                resolvedValue = sanitiseText((STRING_LITERAL5 != null ? STRING_LITERAL5.getText() : null));\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return resolvedValue;\n    }\n\n    // $ANTLR end \"localReference\"\n    // Delegated rules\n    protected DFA2 dfa2 = new DFA2(this);\n\n    protected DFA3 dfa3 = new DFA3(this);\n\n    static final String DFA2_eotS = \"\\6\\uffff\";\n\n    static final String DFA2_eofS = \"\\6\\uffff\";\n\n    static final String DFA2_minS = \"\\2\\4\\4\\uffff\";\n\n    static final String DFA2_maxS = \"\\1\\15\\1\\23\\4\\uffff\";\n\n    static final String DFA2_acceptS = \"\\2\\uffff\\1\\3\\1\\4\\1\\1\\1\\2\";\n\n    static final String DFA2_specialS = \"\\6\\uffff}>\";\n\n    static final String[] DFA2_transitionS = { \"\\1\\1\\4\\uffff\\1\\2\\3\\uffff\\1\\3\", \"\\1\\1\\1\\4\\1\\uffff\\1\\5\\13\\uffff\\1\\4\", \"\", \"\", \"\", \"\" };\n\n    static final short[] DFA2_eot = DFA.unpackEncodedString(DFA2_eotS);\n\n    static final short[] DFA2_eof = DFA.unpackEncodedString(DFA2_eofS);\n\n    static final char[] DFA2_min = DFA.unpackEncodedStringToUnsignedChars(DFA2_minS);\n\n    static final char[] DFA2_max = DFA.unpackEncodedStringToUnsignedChars(DFA2_maxS);\n\n    static final short[] DFA2_accept = DFA.unpackEncodedString(DFA2_acceptS);\n\n    static final short[] DFA2_special = DFA.unpackEncodedString(DFA2_specialS);\n\n    static final short[][] DFA2_transition;\n\n    static {\n        int numStates = DFA2_transitionS.length;\n        DFA2_transition = new short[numStates][];\n        for (int i = 0; i < numStates; i++) {\n            DFA2_transition[i] = DFA.unpackEncodedString(DFA2_transitionS[i]);\n        }\n    }\n\n    class DFA2 extends DFA {\n\n        public DFA2(BaseRecognizer recognizer) {\n            this.recognizer = recognizer;\n            this.decisionNumber = 2;\n            this.eot = DFA2_eot;\n            this.eof = DFA2_eof;\n            this.min = DFA2_min;\n            this.max = DFA2_max;\n            this.accept = DFA2_accept;\n            this.special = DFA2_special;\n            this.transition = DFA2_transition;\n        }\n\n        public String getDescription() {\n            return \"170:1: statement : ( namespaceDecl | assignment | includeTree | t= localRefTree );\";\n        }\n    }\n\n    static final String DFA3_eotS = \"\\4\\uffff\";\n\n    static final String DFA3_eofS = \"\\4\\uffff\";\n\n    static final String DFA3_minS = \"\\2\\4\\2\\uffff\";\n\n    static final String DFA3_maxS = \"\\1\\4\\1\\23\\2\\uffff\";\n\n    static final String DFA3_acceptS = \"\\2\\uffff\\1\\1\\1\\2\";\n\n    static final String DFA3_specialS = \"\\4\\uffff}>\";\n\n    static final String[] DFA3_transitionS = { \"\\1\\1\", \"\\1\\1\\1\\2\\15\\uffff\\1\\3\", \"\", \"\" };\n\n    static final short[] DFA3_eot = DFA.unpackEncodedString(DFA3_eotS);\n\n    static final short[] DFA3_eof = DFA.unpackEncodedString(DFA3_eofS);\n\n    static final char[] DFA3_min = DFA.unpackEncodedStringToUnsignedChars(DFA3_minS);\n\n    static final char[] DFA3_max = DFA.unpackEncodedStringToUnsignedChars(DFA3_maxS);\n\n    static final short[] DFA3_accept = DFA.unpackEncodedString(DFA3_acceptS);\n\n    static final short[] DFA3_special = DFA.unpackEncodedString(DFA3_specialS);\n\n    static final short[][] DFA3_transition;\n\n    static {\n        int numStates = DFA3_transitionS.length;\n        DFA3_transition = new short[numStates][];\n        for (int i = 0; i < numStates; i++) {\n            DFA3_transition[i] = DFA.unpackEncodedString(DFA3_transitionS[i]);\n        }\n    }\n\n    class DFA3 extends DFA {\n\n        public DFA3(BaseRecognizer recognizer) {\n            this.recognizer = recognizer;\n            this.decisionNumber = 3;\n            this.eot = DFA3_eot;\n            this.eof = DFA3_eof;\n            this.min = DFA3_min;\n            this.max = DFA3_max;\n            this.accept = DFA3_accept;\n            this.special = DFA3_special;\n            this.transition = DFA3_transition;\n        }\n\n        public String getDescription() {\n            return \"179:1: namespaceName : ( varName | compositeNamespaceName );\";\n        }\n    }\n\n    public static final BitSet FOLLOW_statementSeq_in_scl44 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_statement_in_statementSeq61 = new BitSet(new long[] { 0x0000000000002212L });\n\n    public static final BitSet FOLLOW_namespaceDecl_in_statement73 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_assignment_in_statement84 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_includeTree_in_statement95 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_localRefTree_in_statement108 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_namespaceName_in_namespaceDecl120 = new BitSet(new long[] { 0x0000000000000020L });\n\n    public static final BitSet FOLLOW_namespaceBody_in_namespaceDecl122 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_varName_in_namespaceName132 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_compositeNamespaceName_in_namespaceName145 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_VALID_NAME_CHARS_in_compositeNamespaceName160 = new BitSet(new long[] { 0x0000000000080010L });\n\n    public static final BitSet FOLLOW_19_in_compositeNamespaceName164 = new BitSet(new long[] { 0x0000000000000010L });\n\n    public static final BitSet FOLLOW_VALID_NAME_CHARS_in_compositeNamespaceName166 = new BitSet(new long[] { 0x0000000000080012L });\n\n    public static final BitSet FOLLOW_OPEN_NESTING_in_namespaceBody181 = new BitSet(new long[] { 0x0000000000002250L });\n\n    public static final BitSet FOLLOW_statement_in_namespaceBody184 = new BitSet(new long[] { 0x0000000000002250L });\n\n    public static final BitSet FOLLOW_CLOSE_NESTING_in_namespaceBody188 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_varName_in_assignment201 = new BitSet(new long[] { 0x0000000000000080L });\n\n    public static final BitSet FOLLOW_ASSIGNMENT_OP_in_assignment203 = new BitSet(new long[] { 0x0000000000003310L });\n\n    public static final BitSet FOLLOW_varValue_in_assignment206 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_includeValue_in_assignment230 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_unparsedIncludeValue_in_assignment247 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_localReference_in_assignment267 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_VALID_NAME_CHARS_in_varName298 = new BitSet(new long[] { 0x0000000000000012L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_varValue312 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_START_INCLUDE_in_includeValue334 = new BitSet(new long[] { 0x0000000000000100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_includeValue338 = new BitSet(new long[] { 0x0000000000000400L });\n\n    public static final BitSet FOLLOW_AS_KEYWORD_in_includeValue340 = new BitSet(new long[] { 0x0000000000000100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_includeValue344 = new BitSet(new long[] { 0x0000000000000800L });\n\n    public static final BitSet FOLLOW_END_INCLUDE_in_includeValue346 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_START_UNPARSED_INCLUDE_in_unparsedIncludeValue373 = new BitSet(new long[] { 0x0000000000000100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_unparsedIncludeValue377 = new BitSet(new long[] { 0x0000000000000800L });\n\n    public static final BitSet FOLLOW_END_INCLUDE_in_unparsedIncludeValue379 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_START_INCLUDE_in_includeTree399 = new BitSet(new long[] { 0x0000000000000100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_includeTree403 = new BitSet(new long[] { 0x0000000000000C00L });\n\n    public static final BitSet FOLLOW_AS_KEYWORD_in_includeTree406 = new BitSet(new long[] { 0x0000000000000100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_includeTree410 = new BitSet(new long[] { 0x0000000000000800L });\n\n    public static final BitSet FOLLOW_END_INCLUDE_in_includeTree414 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_localReference_in_localRefTree442 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_REF_CHAR_in_localReference475 = new BitSet(new long[] { 0x0000000000004100L });\n\n    public static final BitSet FOLLOW_WS_in_localReference477 = new BitSet(new long[] { 0x0000000000004100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_localReference480 = new BitSet(new long[] { 0x0000000000000002L });\n}\n",
		"id": "/EvoSuiteBenchmark/60_sugar/src/main/java/net/sf/sugar/scl/SCLParser_8Test.java",
		"test_prompt": "// SCLParser_8Test.java\npackage net.sf.sugar.scl;\n\nimport static net.sf.sugar.scl.PathConversionUtils.convertToXPath;\nimport static net.sf.sugar.scl.PathConversionUtils.processDotDelimitedPath;\nimport java.net.URI;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Element;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathFactory;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpressionException;\nimport org.antlr.runtime.*;\nimport java.util.Stack;\nimport java.util.List;\nimport java.util.ArrayList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SCLParser}.\n* It contains ten unit test cases for the {@link SCLParser#localRefTree()} method.\n*/\nclass SCLParser_8Test {"
	},
	{
		"original_code": "// SCLParser.java\n// $ANTLR 3.3 Nov 30, 2010 12:46:29 net/sf/sugar/scl/SCL.g 2013-06-10 17:15:03\npackage net.sf.sugar.scl;\n\nimport static net.sf.sugar.scl.PathConversionUtils.convertToXPath;\nimport static net.sf.sugar.scl.PathConversionUtils.processDotDelimitedPath;\nimport java.net.URI;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Element;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathFactory;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpressionException;\nimport org.antlr.runtime.*;\nimport java.util.Stack;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class SCLParser extends Parser {\n\n    public static final String[] tokenNames = new String[] { \"<invalid>\", \"<EOR>\", \"<DOWN>\", \"<UP>\", \"VALID_NAME_CHARS\", \"OPEN_NESTING\", \"CLOSE_NESTING\", \"ASSIGNMENT_OP\", \"STRING_LITERAL\", \"START_INCLUDE\", \"AS_KEYWORD\", \"END_INCLUDE\", \"START_UNPARSED_INCLUDE\", \"REF_CHAR\", \"WS\", \"QUOTE\", \"STRING_SEQUENCE_CHAR\", \"COMMENT\", \"LINE_COMMENT\", \"'.'\" };\n\n    public static final int EOF = -1;\n\n    public static final int T__19 = 19;\n\n    public static final int VALID_NAME_CHARS = 4;\n\n    public static final int OPEN_NESTING = 5;\n\n    public static final int CLOSE_NESTING = 6;\n\n    public static final int ASSIGNMENT_OP = 7;\n\n    public static final int STRING_LITERAL = 8;\n\n    public static final int START_INCLUDE = 9;\n\n    public static final int AS_KEYWORD = 10;\n\n    public static final int END_INCLUDE = 11;\n\n    public static final int START_UNPARSED_INCLUDE = 12;\n\n    public static final int REF_CHAR = 13;\n\n    public static final int WS = 14;\n\n    public static final int QUOTE = 15;\n\n    public static final int STRING_SEQUENCE_CHAR = 16;\n\n    public static final int COMMENT = 17;\n\n    public static final int LINE_COMMENT = 18;\n\n    // delegates\n    // delegators\n    public SCLParser(TokenStream input) {\n        this(input, new RecognizerSharedState());\n    }\n\n    public SCLParser(TokenStream input, RecognizerSharedState state) {\n        super(input, state);\n    }\n\n    public String[] getTokenNames() {\n        return SCLParser.tokenNames;\n    }\n\n    public String getGrammarFileName() {\n        return \"net/sf/sugar/scl/SCL.g\";\n    }\n\n    public static final String SCL_ROOT_ELEMENT = \"scl\";\n\n    private URI rootSCLFile;\n\n    private Document doc;\n\n    private Stack<Element> elements = new Stack<Element>();\n\n    private XPath xpath = XPathFactory.newInstance().newXPath();\n\n    private IncludeProcessor includeProcessor;\n\n    private static LocalReferenceProcessor localReferenceProcessor;\n\n    private List<LocalReference> localRefs = new ArrayList<LocalReference>();\n\n    private int namespaceSteps;\n\n    {\n        try {\n            doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n            Element rootElement = doc.createElement(SCL_ROOT_ELEMENT);\n            doc.appendChild(rootElement);\n            this.elements.push(rootElement);\n        } catch (ParserConfigurationException pce) {\n            pce.printStackTrace();\n        }\n    }\n\n    protected Element addChildElement(Element element, String child) {\n        Element childElement = this.doc.createElement(child);\n        element.appendChild(childElement);\n        return childElement;\n    }\n\n    protected Element addChildElements(Element currentElement, String compositePath) {\n        return processDotDelimitedPath(currentElement, compositePath);\n    }\n\n    protected void addAttribute(Element currentElement, String attributeName, String attributeValue) {\n        Element childElement = this.doc.createElement(attributeName);\n        childElement.setTextContent(attributeValue);\n        currentElement.appendChild(childElement);\n    }\n\n    protected void loadIncludeValue(Element parentElement, String propertyName, String includeLocation, String xPathExpression) throws IncludeException {\n        this.includeProcessor.prepareIncludeValue(parentElement, propertyName, includeLocation, this.rootSCLFile, xPathExpression);\n    }\n\n    protected void loadInclude(Element parentElement, String includeLocation) throws IncludeException {\n        this.includeProcessor.prepareInclude(parentElement, includeLocation, this.rootSCLFile);\n    }\n\n    protected void loadIncludeNodes(Element parentElement, String includeLocation, String xPathExpression) throws IncludeException {\n        this.includeProcessor.prepareInclude(parentElement, includeLocation, this.rootSCLFile, xPathExpression);\n    }\n\n    protected void loadUnparsedInclude(Element parentElement, String propertyName, String includeLocation) throws IncludeException {\n        this.includeProcessor.loadUnparsedInclude(parentElement, propertyName, includeLocation, this.rootSCLFile);\n    }\n\n    protected void prepareLocalRefTree(final Element parentElement, final String xPathExpression) {\n        LocalReference localRef = new LocalReference() {\n\n            {\n                setParentElement(parentElement);\n                setXPathQuery(xPathExpression);\n            }\n        };\n        this.localRefs.add(localRef);\n    }\n\n    protected void prepareLocalRef(final Element parentElement, final String attributeName, final String xPathExpression) {\n        LocalAttributeReference localRef = new LocalAttributeReference() {\n\n            {\n                setParentElement(parentElement);\n                setXPathQuery(xPathExpression);\n                setAttributeName(attributeName);\n            }\n        };\n        this.localRefs.add(localRef);\n    }\n\n    public void setRootSCLFile(URI rootSCLFile) {\n        this.rootSCLFile = rootSCLFile;\n    }\n\n    public URI getRootSCLFile() {\n        return this.rootSCLFile;\n    }\n\n    public Document getRootDocument() {\n        return this.doc;\n    }\n\n    public void setIncludeProcessor(IncludeProcessor includeProcessor) {\n        this.includeProcessor = includeProcessor;\n    }\n\n    public IncludeProcessor getIncludeProcessor() {\n        return this.includeProcessor;\n    }\n\n    public void setLocalReferenceProcessor(LocalReferenceProcessor processor) {\n        localReferenceProcessor = processor;\n    }\n\n    public LocalReferenceProcessor getLocalReferenceProcessor() {\n        return localReferenceProcessor;\n    }\n\n    public List<LocalReference> getLocalRefs() {\n        return this.localRefs;\n    }\n\n    public String sanitiseText(String rawText) {\n        String unquotedText = stripQuotes(rawText);\n        return normaliseEscapeChars(unquotedText);\n    }\n\n    private String stripQuotes(String quotedText) {\n        return quotedText.substring(1, quotedText.length() - 1);\n    }\n\n    private String normaliseEscapeChars(String text) {\n        return text.replace(\"\\\\\\\\\", \"\\\\\").replace(\"\\\\\\\"\", \"\\\"\");\n    }\n\n    // $ANTLR start \"scl\"\n    // net/sf/sugar/scl/SCL.g:152:1: scl returns [Document properties] : statementSeq ;\n    public final Document scl() throws RecognitionException {\n        Document properties = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:153:6: ( statementSeq )\n            // net/sf/sugar/scl/SCL.g:153:8: statementSeq\n            {\n                pushFollow(FOLLOW_statementSeq_in_scl44);\n                statementSeq();\n                state._fsp--;\n                try {\n                    this.includeProcessor.resolveIncludes(this.doc);\n                    localReferenceProcessor.processLocalReferences(this.localRefs);\n                } catch (IncludeException ie) {\n                    ie.printStackTrace();\n                } catch (LocalReferenceException lre) {\n                    lre.printStackTrace();\n                }\n                properties = doc;\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return properties;\n    }\n\n    // $ANTLR end \"scl\"\n    // $ANTLR start \"statementSeq\"\n    // net/sf/sugar/scl/SCL.g:168:1: statementSeq : ( statement )+ ;\n    public final void statementSeq() throws RecognitionException {\n        try {\n            // net/sf/sugar/scl/SCL.g:168:15: ( ( statement )+ )\n            // net/sf/sugar/scl/SCL.g:168:17: ( statement )+\n            {\n                // net/sf/sugar/scl/SCL.g:168:17: ( statement )+\n                int cnt1 = 0;\n                loop1: do {\n                    int alt1 = 2;\n                    switch(input.LA(1)) {\n                        case VALID_NAME_CHARS:\n                        case START_INCLUDE:\n                        case REF_CHAR:\n                            {\n                                alt1 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt1) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:168:17: statement\n                            {\n                                pushFollow(FOLLOW_statement_in_statementSeq61);\n                                statement();\n                                state._fsp--;\n                            }\n                            break;\n                        default:\n                            if (cnt1 >= 1)\n                                break loop1;\n                            EarlyExitException eee = new EarlyExitException(1, input);\n                            throw eee;\n                    }\n                    cnt1++;\n                } while (true);\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"statementSeq\"\n    // $ANTLR start \"statement\"\n    // net/sf/sugar/scl/SCL.g:170:1: statement : ( namespaceDecl | assignment | includeTree | t= localRefTree );\n    public final void statement() throws RecognitionException {\n        String t = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:170:13: ( namespaceDecl | assignment | includeTree | t= localRefTree )\n            int alt2 = 4;\n            alt2 = dfa2.predict(input);\n            switch(alt2) {\n                case 1:\n                    // net/sf/sugar/scl/SCL.g:170:15: namespaceDecl\n                    {\n                        pushFollow(FOLLOW_namespaceDecl_in_statement73);\n                        namespaceDecl();\n                        state._fsp--;\n                    }\n                    break;\n                case 2:\n                    // net/sf/sugar/scl/SCL.g:171:9: assignment\n                    {\n                        pushFollow(FOLLOW_assignment_in_statement84);\n                        assignment();\n                        state._fsp--;\n                    }\n                    break;\n                case 3:\n                    // net/sf/sugar/scl/SCL.g:172:9: includeTree\n                    {\n                        pushFollow(FOLLOW_includeTree_in_statement95);\n                        includeTree();\n                        state._fsp--;\n                    }\n                    break;\n                case 4:\n                    // net/sf/sugar/scl/SCL.g:173:9: t= localRefTree\n                    {\n                        pushFollow(FOLLOW_localRefTree_in_statement108);\n                        t = localRefTree();\n                        state._fsp--;\n                        prepareLocalRefTree(this.elements.peek(), t);\n                    }\n                    break;\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"statement\"\n    // $ANTLR start \"namespaceDecl\"\n    // net/sf/sugar/scl/SCL.g:177:1: namespaceDecl : namespaceName namespaceBody ;\n    public final void namespaceDecl() throws RecognitionException {\n        try {\n            // net/sf/sugar/scl/SCL.g:177:16: ( namespaceName namespaceBody )\n            // net/sf/sugar/scl/SCL.g:177:18: namespaceName namespaceBody\n            {\n                pushFollow(FOLLOW_namespaceName_in_namespaceDecl120);\n                namespaceName();\n                state._fsp--;\n                pushFollow(FOLLOW_namespaceBody_in_namespaceDecl122);\n                namespaceBody();\n                state._fsp--;\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"namespaceDecl\"\n    public static class namespaceName_return extends ParserRuleReturnScope {\n    }\n\n    // $ANTLR start \"namespaceName\"\n    // net/sf/sugar/scl/SCL.g:179:1: namespaceName : ( varName | compositeNamespaceName );\n    public final SCLParser.namespaceName_return namespaceName() throws RecognitionException {\n        SCLParser.namespaceName_return retval = new SCLParser.namespaceName_return();\n        retval.start = input.LT(1);\n        SCLParser.compositeNamespaceName_return compositeNamespaceName1 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:179:16: ( varName | compositeNamespaceName )\n            int alt3 = 2;\n            alt3 = dfa3.predict(input);\n            switch(alt3) {\n                case 1:\n                    // net/sf/sugar/scl/SCL.g:179:18: varName\n                    {\n                        pushFollow(FOLLOW_varName_in_namespaceName132);\n                        varName();\n                        state._fsp--;\n                        this.elements.push(addChildElement(this.elements.peek(), input.toString(retval.start, input.LT(-1))));\n                    }\n                    break;\n                case 2:\n                    // net/sf/sugar/scl/SCL.g:180:9: compositeNamespaceName\n                    {\n                        pushFollow(FOLLOW_compositeNamespaceName_in_namespaceName145);\n                        compositeNamespaceName1 = compositeNamespaceName();\n                        state._fsp--;\n                        this.elements.push(addChildElements(this.elements.peek(), (compositeNamespaceName1 != null ? input.toString(compositeNamespaceName1.start, compositeNamespaceName1.stop) : null)));\n                    }\n                    break;\n            }\n            retval.stop = input.LT(-1);\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return retval;\n    }\n\n    // $ANTLR end \"namespaceName\"\n    public static class compositeNamespaceName_return extends ParserRuleReturnScope {\n    }\n\n    // $ANTLR start \"compositeNamespaceName\"\n    // net/sf/sugar/scl/SCL.g:182:1: compositeNamespaceName : ( VALID_NAME_CHARS )+ ( '.' ( VALID_NAME_CHARS )+ )+ ;\n    public final SCLParser.compositeNamespaceName_return compositeNamespaceName() throws RecognitionException {\n        SCLParser.compositeNamespaceName_return retval = new SCLParser.compositeNamespaceName_return();\n        retval.start = input.LT(1);\n        try {\n            // net/sf/sugar/scl/SCL.g:182:24: ( ( VALID_NAME_CHARS )+ ( '.' ( VALID_NAME_CHARS )+ )+ )\n            // net/sf/sugar/scl/SCL.g:182:28: ( VALID_NAME_CHARS )+ ( '.' ( VALID_NAME_CHARS )+ )+\n            {\n                // net/sf/sugar/scl/SCL.g:182:28: ( VALID_NAME_CHARS )+\n                int cnt4 = 0;\n                loop4: do {\n                    int alt4 = 2;\n                    switch(input.LA(1)) {\n                        case VALID_NAME_CHARS:\n                            {\n                                alt4 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt4) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:182:28: VALID_NAME_CHARS\n                            {\n                                match(input, VALID_NAME_CHARS, FOLLOW_VALID_NAME_CHARS_in_compositeNamespaceName160);\n                            }\n                            break;\n                        default:\n                            if (cnt4 >= 1)\n                                break loop4;\n                            EarlyExitException eee = new EarlyExitException(4, input);\n                            throw eee;\n                    }\n                    cnt4++;\n                } while (true);\n                // net/sf/sugar/scl/SCL.g:182:46: ( '.' ( VALID_NAME_CHARS )+ )+\n                int cnt6 = 0;\n                loop6: do {\n                    int alt6 = 2;\n                    switch(input.LA(1)) {\n                        case 19:\n                            {\n                                alt6 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt6) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:182:47: '.' ( VALID_NAME_CHARS )+\n                            {\n                                match(input, 19, FOLLOW_19_in_compositeNamespaceName164);\n                                // net/sf/sugar/scl/SCL.g:182:51: ( VALID_NAME_CHARS )+\n                                int cnt5 = 0;\n                                loop5: do {\n                                    int alt5 = 2;\n                                    switch(input.LA(1)) {\n                                        case VALID_NAME_CHARS:\n                                            {\n                                                alt5 = 1;\n                                            }\n                                            break;\n                                    }\n                                    switch(alt5) {\n                                        case 1:\n                                            // net/sf/sugar/scl/SCL.g:182:51: VALID_NAME_CHARS\n                                            {\n                                                match(input, VALID_NAME_CHARS, FOLLOW_VALID_NAME_CHARS_in_compositeNamespaceName166);\n                                            }\n                                            break;\n                                        default:\n                                            if (cnt5 >= 1)\n                                                break loop5;\n                                            EarlyExitException eee = new EarlyExitException(5, input);\n                                            throw eee;\n                                    }\n                                    cnt5++;\n                                } while (true);\n                            }\n                            break;\n                        default:\n                            if (cnt6 >= 1)\n                                break loop6;\n                            EarlyExitException eee = new EarlyExitException(6, input);\n                            throw eee;\n                    }\n                    cnt6++;\n                } while (true);\n            }\n            retval.stop = input.LT(-1);\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return retval;\n    }\n\n    // $ANTLR end \"compositeNamespaceName\"\n    // $ANTLR start \"namespaceBody\"\n    // net/sf/sugar/scl/SCL.g:184:1: namespaceBody : OPEN_NESTING ( statement )* CLOSE_NESTING ;\n    public final void namespaceBody() throws RecognitionException {\n        try {\n            // net/sf/sugar/scl/SCL.g:184:16: ( OPEN_NESTING ( statement )* CLOSE_NESTING )\n            // net/sf/sugar/scl/SCL.g:184:18: OPEN_NESTING ( statement )* CLOSE_NESTING\n            {\n                match(input, OPEN_NESTING, FOLLOW_OPEN_NESTING_in_namespaceBody181);\n                // net/sf/sugar/scl/SCL.g:184:31: ( statement )*\n                loop7: do {\n                    int alt7 = 2;\n                    switch(input.LA(1)) {\n                        case VALID_NAME_CHARS:\n                        case START_INCLUDE:\n                        case REF_CHAR:\n                            {\n                                alt7 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt7) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:184:32: statement\n                            {\n                                pushFollow(FOLLOW_statement_in_namespaceBody184);\n                                statement();\n                                state._fsp--;\n                            }\n                            break;\n                        default:\n                            break loop7;\n                    }\n                } while (true);\n                match(input, CLOSE_NESTING, FOLLOW_CLOSE_NESTING_in_namespaceBody188);\n                this.elements.pop();\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"namespaceBody\"\n    // $ANTLR start \"assignment\"\n    // net/sf/sugar/scl/SCL.g:188:1: assignment : varName ASSIGNMENT_OP ( varValue | includeValue | v= unparsedIncludeValue | r= localReference ) ;\n    public final void assignment() throws RecognitionException {\n        String v = null;\n        String r = null;\n        SCLParser.varName_return varName2 = null;\n        SCLParser.varValue_return varValue3 = null;\n        SCLParser.includeValue_return includeValue4 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:188:14: ( varName ASSIGNMENT_OP ( varValue | includeValue | v= unparsedIncludeValue | r= localReference ) )\n            // net/sf/sugar/scl/SCL.g:188:16: varName ASSIGNMENT_OP ( varValue | includeValue | v= unparsedIncludeValue | r= localReference )\n            {\n                pushFollow(FOLLOW_varName_in_assignment201);\n                varName2 = varName();\n                state._fsp--;\n                match(input, ASSIGNMENT_OP, FOLLOW_ASSIGNMENT_OP_in_assignment203);\n                // net/sf/sugar/scl/SCL.g:188:38: ( varValue | includeValue | v= unparsedIncludeValue | r= localReference )\n                int alt8 = 4;\n                switch(input.LA(1)) {\n                    case STRING_LITERAL:\n                        {\n                            alt8 = 1;\n                        }\n                        break;\n                    case START_INCLUDE:\n                        {\n                            alt8 = 2;\n                        }\n                        break;\n                    case START_UNPARSED_INCLUDE:\n                        {\n                            alt8 = 3;\n                        }\n                        break;\n                    case REF_CHAR:\n                        {\n                            alt8 = 4;\n                        }\n                        break;\n                    default:\n                        NoViableAltException nvae = new NoViableAltException(\"\", 8, 0, input);\n                        throw nvae;\n                }\n                switch(alt8) {\n                    case 1:\n                        // net/sf/sugar/scl/SCL.g:188:39: varValue\n                        {\n                            pushFollow(FOLLOW_varValue_in_assignment206);\n                            varValue3 = varValue();\n                            state._fsp--;\n                            addAttribute(this.elements.peek(), (varName2 != null ? input.toString(varName2.start, varName2.stop) : null), sanitiseText((varValue3 != null ? input.toString(varValue3.start, varValue3.stop) : null)));\n                        }\n                        break;\n                    case 2:\n                        // net/sf/sugar/scl/SCL.g:194:14: includeValue\n                        {\n                            pushFollow(FOLLOW_includeValue_in_assignment230);\n                            includeValue4 = includeValue();\n                            state._fsp--;\n                            try {\n                                this.loadIncludeValue(this.elements.peek(), (varName2 != null ? input.toString(varName2.start, varName2.stop) : null), sanitiseText((includeValue4 != null ? includeValue4.includeLocation : null)), sanitiseText((includeValue4 != null ? includeValue4.xPathQuery : null)));\n                            } catch (IncludeException ie) {\n                                ie.printStackTrace();\n                                System.out.println(ie);\n                            }\n                        }\n                        break;\n                    case 3:\n                        // net/sf/sugar/scl/SCL.g:205:12: v= unparsedIncludeValue\n                        {\n                            pushFollow(FOLLOW_unparsedIncludeValue_in_assignment247);\n                            v = unparsedIncludeValue();\n                            state._fsp--;\n                            try {\n                                this.loadUnparsedInclude(this.elements.peek(), (varName2 != null ? input.toString(varName2.start, varName2.stop) : null), v);\n                            } catch (IncludeException ie) {\n                                ie.printStackTrace();\n                            }\n                        }\n                        break;\n                    case 4:\n                        // net/sf/sugar/scl/SCL.g:212:15: r= localReference\n                        {\n                            pushFollow(FOLLOW_localReference_in_assignment267);\n                            r = localReference();\n                            state._fsp--;\n                            //todo : handle empty values, also handle non numeric, date and boolean return types\n                            prepareLocalRef(this.elements.peek(), (varName2 != null ? input.toString(varName2.start, varName2.stop) : null), r);\n                        }\n                        break;\n                }\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"assignment\"\n    public static class varName_return extends ParserRuleReturnScope {\n    }\n\n    // $ANTLR start \"varName\"\n    // net/sf/sugar/scl/SCL.g:218:1: varName : ( VALID_NAME_CHARS )+ ;\n    public final SCLParser.varName_return varName() throws RecognitionException {\n        SCLParser.varName_return retval = new SCLParser.varName_return();\n        retval.start = input.LT(1);\n        try {\n            // net/sf/sugar/scl/SCL.g:218:12: ( ( VALID_NAME_CHARS )+ )\n            // net/sf/sugar/scl/SCL.g:218:14: ( VALID_NAME_CHARS )+\n            {\n                // net/sf/sugar/scl/SCL.g:218:14: ( VALID_NAME_CHARS )+\n                int cnt9 = 0;\n                loop9: do {\n                    int alt9 = 2;\n                    switch(input.LA(1)) {\n                        case VALID_NAME_CHARS:\n                            {\n                                alt9 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt9) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:218:14: VALID_NAME_CHARS\n                            {\n                                match(input, VALID_NAME_CHARS, FOLLOW_VALID_NAME_CHARS_in_varName298);\n                            }\n                            break;\n                        default:\n                            if (cnt9 >= 1)\n                                break loop9;\n                            EarlyExitException eee = new EarlyExitException(9, input);\n                            throw eee;\n                    }\n                    cnt9++;\n                } while (true);\n            }\n            retval.stop = input.LT(-1);\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return retval;\n    }\n\n    // $ANTLR end \"varName\"\n    public static class varValue_return extends ParserRuleReturnScope {\n    }\n\n    // $ANTLR start \"varValue\"\n    // net/sf/sugar/scl/SCL.g:220:1: varValue : STRING_LITERAL ;\n    public final SCLParser.varValue_return varValue() throws RecognitionException {\n        SCLParser.varValue_return retval = new SCLParser.varValue_return();\n        retval.start = input.LT(1);\n        try {\n            // net/sf/sugar/scl/SCL.g:220:13: ( STRING_LITERAL )\n            // net/sf/sugar/scl/SCL.g:220:15: STRING_LITERAL\n            {\n                match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_varValue312);\n            }\n            retval.stop = input.LT(-1);\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return retval;\n    }\n\n    // $ANTLR end \"varValue\"\n    public static class includeValue_return extends ParserRuleReturnScope {\n\n        public String includeLocation;\n\n        public String xPathQuery;\n    }\n\n    // $ANTLR start \"includeValue\"\n    // net/sf/sugar/scl/SCL.g:223:1: includeValue returns [String includeLocation, String xPathQuery] : START_INCLUDE s1= STRING_LITERAL AS_KEYWORD s2= STRING_LITERAL END_INCLUDE ;\n    public final SCLParser.includeValue_return includeValue() throws RecognitionException {\n        SCLParser.includeValue_return retval = new SCLParser.includeValue_return();\n        retval.start = input.LT(1);\n        Token s1 = null;\n        Token s2 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:224:6: ( START_INCLUDE s1= STRING_LITERAL AS_KEYWORD s2= STRING_LITERAL END_INCLUDE )\n            // net/sf/sugar/scl/SCL.g:224:8: START_INCLUDE s1= STRING_LITERAL AS_KEYWORD s2= STRING_LITERAL END_INCLUDE\n            {\n                match(input, START_INCLUDE, FOLLOW_START_INCLUDE_in_includeValue334);\n                s1 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_includeValue338);\n                match(input, AS_KEYWORD, FOLLOW_AS_KEYWORD_in_includeValue340);\n                s2 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_includeValue344);\n                match(input, END_INCLUDE, FOLLOW_END_INCLUDE_in_includeValue346);\n                retval.includeLocation = (s1 != null ? s1.getText() : null);\n                retval.xPathQuery = (s2 != null ? s2.getText() : null);\n            }\n            retval.stop = input.LT(-1);\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return retval;\n    }\n\n    // $ANTLR end \"includeValue\"\n    // $ANTLR start \"unparsedIncludeValue\"\n    // net/sf/sugar/scl/SCL.g:229:1: unparsedIncludeValue returns [String includeLocation] : START_UNPARSED_INCLUDE s1= STRING_LITERAL END_INCLUDE ;\n    public final String unparsedIncludeValue() throws RecognitionException {\n        String includeLocation = null;\n        Token s1 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:230:6: ( START_UNPARSED_INCLUDE s1= STRING_LITERAL END_INCLUDE )\n            // net/sf/sugar/scl/SCL.g:230:8: START_UNPARSED_INCLUDE s1= STRING_LITERAL END_INCLUDE\n            {\n                match(input, START_UNPARSED_INCLUDE, FOLLOW_START_UNPARSED_INCLUDE_in_unparsedIncludeValue373);\n                s1 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_unparsedIncludeValue377);\n                match(input, END_INCLUDE, FOLLOW_END_INCLUDE_in_unparsedIncludeValue379);\n                includeLocation = stripQuotes(s1.getText());\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return includeLocation;\n    }\n\n    // $ANTLR end \"unparsedIncludeValue\"\n    // $ANTLR start \"includeTree\"\n    // net/sf/sugar/scl/SCL.g:234:1: includeTree : START_INCLUDE s1= STRING_LITERAL ( AS_KEYWORD s2= STRING_LITERAL )? END_INCLUDE ;\n    public final void includeTree() throws RecognitionException {\n        Token s1 = null;\n        Token s2 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:234:15: ( START_INCLUDE s1= STRING_LITERAL ( AS_KEYWORD s2= STRING_LITERAL )? END_INCLUDE )\n            // net/sf/sugar/scl/SCL.g:234:17: START_INCLUDE s1= STRING_LITERAL ( AS_KEYWORD s2= STRING_LITERAL )? END_INCLUDE\n            {\n                match(input, START_INCLUDE, FOLLOW_START_INCLUDE_in_includeTree399);\n                s1 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_includeTree403);\n                // net/sf/sugar/scl/SCL.g:234:49: ( AS_KEYWORD s2= STRING_LITERAL )?\n                int alt10 = 2;\n                switch(input.LA(1)) {\n                    case AS_KEYWORD:\n                        {\n                            alt10 = 1;\n                        }\n                        break;\n                }\n                switch(alt10) {\n                    case 1:\n                        // net/sf/sugar/scl/SCL.g:234:50: AS_KEYWORD s2= STRING_LITERAL\n                        {\n                            match(input, AS_KEYWORD, FOLLOW_AS_KEYWORD_in_includeTree406);\n                            s2 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_includeTree410);\n                        }\n                        break;\n                }\n                match(input, END_INCLUDE, FOLLOW_END_INCLUDE_in_includeTree414);\n                try {\n                    if (s2 == null || \"\".equals(s2)) {\n                        this.loadInclude(this.elements.peek(), sanitiseText(s1.getText()));\n                    } else {\n                        this.loadIncludeNodes(this.elements.peek(), sanitiseText(s1.getText()), sanitiseText(s2.getText()));\n                    }\n                } catch (IncludeException ie) {\n                    ie.printStackTrace();\n                }\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return;\n    }\n\n    // $ANTLR end \"includeTree\"\n    // $ANTLR start \"localRefTree\"\n    // net/sf/sugar/scl/SCL.g:250:1: localRefTree returns [String xPathQuery] : r= localReference ;\n    public final String localRefTree() throws RecognitionException {\n        String xPathQuery = null;\n        String r = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:251:7: (r= localReference )\n            // net/sf/sugar/scl/SCL.g:251:10: r= localReference\n            {\n                pushFollow(FOLLOW_localReference_in_localRefTree442);\n                r = localReference();\n                state._fsp--;\n                xPathQuery = r;\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return xPathQuery;\n    }\n\n    // $ANTLR end \"localRefTree\"\n    // $ANTLR start \"localReference\"\n    // net/sf/sugar/scl/SCL.g:253:1: localReference returns [String resolvedValue] : REF_CHAR ( WS )* STRING_LITERAL ;\n    public final String localReference() throws RecognitionException {\n        String resolvedValue = null;\n        Token STRING_LITERAL5 = null;\n        try {\n            // net/sf/sugar/scl/SCL.g:254:7: ( REF_CHAR ( WS )* STRING_LITERAL )\n            // net/sf/sugar/scl/SCL.g:254:10: REF_CHAR ( WS )* STRING_LITERAL\n            {\n                match(input, REF_CHAR, FOLLOW_REF_CHAR_in_localReference475);\n                // net/sf/sugar/scl/SCL.g:254:19: ( WS )*\n                loop11: do {\n                    int alt11 = 2;\n                    switch(input.LA(1)) {\n                        case WS:\n                            {\n                                alt11 = 1;\n                            }\n                            break;\n                    }\n                    switch(alt11) {\n                        case 1:\n                            // net/sf/sugar/scl/SCL.g:254:19: WS\n                            {\n                                match(input, WS, FOLLOW_WS_in_localReference477);\n                            }\n                            break;\n                        default:\n                            break loop11;\n                    }\n                } while (true);\n                STRING_LITERAL5 = (Token) match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_localReference480);\n                resolvedValue = sanitiseText((STRING_LITERAL5 != null ? STRING_LITERAL5.getText() : null));\n            }\n        } catch (RecognitionException re) {\n            reportError(re);\n            recover(input, re);\n        } finally {\n        }\n        return resolvedValue;\n    }\n\n    // $ANTLR end \"localReference\"\n    // Delegated rules\n    protected DFA2 dfa2 = new DFA2(this);\n\n    protected DFA3 dfa3 = new DFA3(this);\n\n    static final String DFA2_eotS = \"\\6\\uffff\";\n\n    static final String DFA2_eofS = \"\\6\\uffff\";\n\n    static final String DFA2_minS = \"\\2\\4\\4\\uffff\";\n\n    static final String DFA2_maxS = \"\\1\\15\\1\\23\\4\\uffff\";\n\n    static final String DFA2_acceptS = \"\\2\\uffff\\1\\3\\1\\4\\1\\1\\1\\2\";\n\n    static final String DFA2_specialS = \"\\6\\uffff}>\";\n\n    static final String[] DFA2_transitionS = { \"\\1\\1\\4\\uffff\\1\\2\\3\\uffff\\1\\3\", \"\\1\\1\\1\\4\\1\\uffff\\1\\5\\13\\uffff\\1\\4\", \"\", \"\", \"\", \"\" };\n\n    static final short[] DFA2_eot = DFA.unpackEncodedString(DFA2_eotS);\n\n    static final short[] DFA2_eof = DFA.unpackEncodedString(DFA2_eofS);\n\n    static final char[] DFA2_min = DFA.unpackEncodedStringToUnsignedChars(DFA2_minS);\n\n    static final char[] DFA2_max = DFA.unpackEncodedStringToUnsignedChars(DFA2_maxS);\n\n    static final short[] DFA2_accept = DFA.unpackEncodedString(DFA2_acceptS);\n\n    static final short[] DFA2_special = DFA.unpackEncodedString(DFA2_specialS);\n\n    static final short[][] DFA2_transition;\n\n    static {\n        int numStates = DFA2_transitionS.length;\n        DFA2_transition = new short[numStates][];\n        for (int i = 0; i < numStates; i++) {\n            DFA2_transition[i] = DFA.unpackEncodedString(DFA2_transitionS[i]);\n        }\n    }\n\n    class DFA2 extends DFA {\n\n        public DFA2(BaseRecognizer recognizer) {\n            this.recognizer = recognizer;\n            this.decisionNumber = 2;\n            this.eot = DFA2_eot;\n            this.eof = DFA2_eof;\n            this.min = DFA2_min;\n            this.max = DFA2_max;\n            this.accept = DFA2_accept;\n            this.special = DFA2_special;\n            this.transition = DFA2_transition;\n        }\n\n        public String getDescription() {\n            return \"170:1: statement : ( namespaceDecl | assignment | includeTree | t= localRefTree );\";\n        }\n    }\n\n    static final String DFA3_eotS = \"\\4\\uffff\";\n\n    static final String DFA3_eofS = \"\\4\\uffff\";\n\n    static final String DFA3_minS = \"\\2\\4\\2\\uffff\";\n\n    static final String DFA3_maxS = \"\\1\\4\\1\\23\\2\\uffff\";\n\n    static final String DFA3_acceptS = \"\\2\\uffff\\1\\1\\1\\2\";\n\n    static final String DFA3_specialS = \"\\4\\uffff}>\";\n\n    static final String[] DFA3_transitionS = { \"\\1\\1\", \"\\1\\1\\1\\2\\15\\uffff\\1\\3\", \"\", \"\" };\n\n    static final short[] DFA3_eot = DFA.unpackEncodedString(DFA3_eotS);\n\n    static final short[] DFA3_eof = DFA.unpackEncodedString(DFA3_eofS);\n\n    static final char[] DFA3_min = DFA.unpackEncodedStringToUnsignedChars(DFA3_minS);\n\n    static final char[] DFA3_max = DFA.unpackEncodedStringToUnsignedChars(DFA3_maxS);\n\n    static final short[] DFA3_accept = DFA.unpackEncodedString(DFA3_acceptS);\n\n    static final short[] DFA3_special = DFA.unpackEncodedString(DFA3_specialS);\n\n    static final short[][] DFA3_transition;\n\n    static {\n        int numStates = DFA3_transitionS.length;\n        DFA3_transition = new short[numStates][];\n        for (int i = 0; i < numStates; i++) {\n            DFA3_transition[i] = DFA.unpackEncodedString(DFA3_transitionS[i]);\n        }\n    }\n\n    class DFA3 extends DFA {\n\n        public DFA3(BaseRecognizer recognizer) {\n            this.recognizer = recognizer;\n            this.decisionNumber = 3;\n            this.eot = DFA3_eot;\n            this.eof = DFA3_eof;\n            this.min = DFA3_min;\n            this.max = DFA3_max;\n            this.accept = DFA3_accept;\n            this.special = DFA3_special;\n            this.transition = DFA3_transition;\n        }\n\n        public String getDescription() {\n            return \"179:1: namespaceName : ( varName | compositeNamespaceName );\";\n        }\n    }\n\n    public static final BitSet FOLLOW_statementSeq_in_scl44 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_statement_in_statementSeq61 = new BitSet(new long[] { 0x0000000000002212L });\n\n    public static final BitSet FOLLOW_namespaceDecl_in_statement73 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_assignment_in_statement84 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_includeTree_in_statement95 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_localRefTree_in_statement108 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_namespaceName_in_namespaceDecl120 = new BitSet(new long[] { 0x0000000000000020L });\n\n    public static final BitSet FOLLOW_namespaceBody_in_namespaceDecl122 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_varName_in_namespaceName132 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_compositeNamespaceName_in_namespaceName145 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_VALID_NAME_CHARS_in_compositeNamespaceName160 = new BitSet(new long[] { 0x0000000000080010L });\n\n    public static final BitSet FOLLOW_19_in_compositeNamespaceName164 = new BitSet(new long[] { 0x0000000000000010L });\n\n    public static final BitSet FOLLOW_VALID_NAME_CHARS_in_compositeNamespaceName166 = new BitSet(new long[] { 0x0000000000080012L });\n\n    public static final BitSet FOLLOW_OPEN_NESTING_in_namespaceBody181 = new BitSet(new long[] { 0x0000000000002250L });\n\n    public static final BitSet FOLLOW_statement_in_namespaceBody184 = new BitSet(new long[] { 0x0000000000002250L });\n\n    public static final BitSet FOLLOW_CLOSE_NESTING_in_namespaceBody188 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_varName_in_assignment201 = new BitSet(new long[] { 0x0000000000000080L });\n\n    public static final BitSet FOLLOW_ASSIGNMENT_OP_in_assignment203 = new BitSet(new long[] { 0x0000000000003310L });\n\n    public static final BitSet FOLLOW_varValue_in_assignment206 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_includeValue_in_assignment230 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_unparsedIncludeValue_in_assignment247 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_localReference_in_assignment267 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_VALID_NAME_CHARS_in_varName298 = new BitSet(new long[] { 0x0000000000000012L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_varValue312 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_START_INCLUDE_in_includeValue334 = new BitSet(new long[] { 0x0000000000000100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_includeValue338 = new BitSet(new long[] { 0x0000000000000400L });\n\n    public static final BitSet FOLLOW_AS_KEYWORD_in_includeValue340 = new BitSet(new long[] { 0x0000000000000100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_includeValue344 = new BitSet(new long[] { 0x0000000000000800L });\n\n    public static final BitSet FOLLOW_END_INCLUDE_in_includeValue346 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_START_UNPARSED_INCLUDE_in_unparsedIncludeValue373 = new BitSet(new long[] { 0x0000000000000100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_unparsedIncludeValue377 = new BitSet(new long[] { 0x0000000000000800L });\n\n    public static final BitSet FOLLOW_END_INCLUDE_in_unparsedIncludeValue379 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_START_INCLUDE_in_includeTree399 = new BitSet(new long[] { 0x0000000000000100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_includeTree403 = new BitSet(new long[] { 0x0000000000000C00L });\n\n    public static final BitSet FOLLOW_AS_KEYWORD_in_includeTree406 = new BitSet(new long[] { 0x0000000000000100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_includeTree410 = new BitSet(new long[] { 0x0000000000000800L });\n\n    public static final BitSet FOLLOW_END_INCLUDE_in_includeTree414 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_localReference_in_localRefTree442 = new BitSet(new long[] { 0x0000000000000002L });\n\n    public static final BitSet FOLLOW_REF_CHAR_in_localReference475 = new BitSet(new long[] { 0x0000000000004100L });\n\n    public static final BitSet FOLLOW_WS_in_localReference477 = new BitSet(new long[] { 0x0000000000004100L });\n\n    public static final BitSet FOLLOW_STRING_LITERAL_in_localReference480 = new BitSet(new long[] { 0x0000000000000002L });\n}\n",
		"id": "/EvoSuiteBenchmark/60_sugar/src/main/java/net/sf/sugar/scl/SCLParser_9Test.java",
		"test_prompt": "// SCLParser_9Test.java\npackage net.sf.sugar.scl;\n\nimport static net.sf.sugar.scl.PathConversionUtils.convertToXPath;\nimport static net.sf.sugar.scl.PathConversionUtils.processDotDelimitedPath;\nimport java.net.URI;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Element;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathFactory;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpressionException;\nimport org.antlr.runtime.*;\nimport java.util.Stack;\nimport java.util.List;\nimport java.util.ArrayList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SCLParser}.\n* It contains ten unit test cases for the {@link SCLParser#localReference()} method.\n*/\nclass SCLParser_9Test {"
	},
	{
		"original_code": "// Include.java\npackage net.sf.sugar.scl;\r\n\r\nimport org.w3c.dom.Element;\r\nimport java.net.URI;\r\n\r\n/**\r\n * Created by IntelliJ IDEA.\r\n * User: kbishop\r\n * Date: 30-Aug-2008\r\n * Time: 23:40:12\r\n */\r\npublic class Include {\r\n\r\n    private boolean fullyResolved;\r\n\r\n    private URI parentURI;\r\n\r\n    private URI includeURI;\r\n\r\n    private Element parentElement;\r\n\r\n    private IncludeHolder includeHolder;\r\n\r\n    public boolean isFullyResolved() {\r\n        return fullyResolved;\r\n    }\r\n\r\n    public void setFullyResolved() {\r\n        this.fullyResolved = true;\r\n    }\r\n\r\n    public URI getParentURI() {\r\n        return parentURI;\r\n    }\r\n\r\n    public void setParentURI(URI parentIncludeURI) {\r\n        this.parentURI = parentIncludeURI;\r\n    }\r\n\r\n    public URI getIncludeURI() {\r\n        return includeURI;\r\n    }\r\n\r\n    public void setIncludeURI(URI includeURI) {\r\n        this.includeURI = includeURI;\r\n    }\r\n\r\n    public Element getParentElement() {\r\n        return parentElement;\r\n    }\r\n\r\n    public void setParentElement(Element parentElement) {\r\n        this.parentElement = parentElement;\r\n    }\r\n\r\n    public IncludeHolder getIncludeHolder() {\r\n        return includeHolder;\r\n    }\r\n\r\n    public void setIncludeHolder(IncludeHolder includeHolder) {\r\n        this.includeHolder = includeHolder;\r\n    }\r\n\r\n    public String toString() {\r\n        return \"Include{\" + \"fullyResolved=\" + fullyResolved + \", parentURI=\" + parentURI + \", includeURI=\" + includeURI + \", parentElement=\" + parentElement + \", includeHolder=\" + includeHolder + '}';\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/60_sugar/src/main/java/net/sf/sugar/scl/Include.java",
		"test_prompt": "// IncludeTest.java\npackage net.sf.sugar.scl;\n\nimport org.w3c.dom.Element;\nimport java.net.URI;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Include}.\n* It contains ten unit test cases for the {@link Include#isFullyResolved()} method.\n*/\nclass IncludeTest {"
	},
	{
		"original_code": "// SCLProperties.java\npackage net.sf.sugar.scl;\r\n\r\nimport static net.sf.sugar.scl.PathConversionUtils.convertToXPath;\r\nimport org.antlr.runtime.ANTLRInputStream;\r\nimport org.antlr.runtime.ANTLRReaderStream;\r\nimport org.antlr.runtime.CommonTokenStream;\r\nimport org.w3c.dom.*;\r\nimport javax.xml.xpath.XPath;\r\nimport javax.xml.xpath.XPathConstants;\r\nimport javax.xml.xpath.XPathExpressionException;\r\nimport javax.xml.xpath.XPathFactory;\r\nimport java.io.*;\r\nimport java.net.URI;\r\nimport java.util.*;\r\n\r\n/**\r\n * SCLProperties is java.util.Map implementation which reads SCL (Simple Configuration Language) files.\r\n * It is intended to be an alternative to the standard Java Properties file format, and provides the ability to\r\n * create properties files using a simple nested structure that makes the file more manageable and readable.\r\n * <p/>\r\n * <pre>\r\n * a {\r\n *   b: \"value for b\"\r\n *   c: \"value for c\"\r\n *   d {\r\n *     e: \"value for e\"\r\n *   } //single line comment\r\n * }\r\n * </pre>\r\n * User: kbishop\r\n * Date: 20-Jul-2008\r\n * Time: 00:59:48\r\n */\r\npublic class SCLProperties implements Map<String, String> {\r\n\r\n    private Document doc;\r\n\r\n    private final String allTextNodesExpr = \"//*[count(./*) = 0]\";\r\n\r\n    private static final String DEFAULT_ENCODING = \"UTF-8\";\r\n\r\n    public SCLProperties(String filename) throws SCLParseException, FileNotFoundException {\r\n        this.load(new File(filename));\r\n    }\r\n\r\n    public SCLProperties(File sclFile) throws SCLParseException, FileNotFoundException {\r\n        this.load(sclFile);\r\n    }\r\n\r\n    //    public SCLProperties(InputStream inputStream) throws SCLParseException {\r\n    //        this();\r\n    //        this.load(inputStream);\r\n    //    }\r\n    public SCLProperties(Reader reader) throws SCLParseException {\r\n        this.load(reader);\r\n    }\r\n\r\n    public void load(File file) throws SCLParseException, FileNotFoundException {\r\n        InputStream is = new FileInputStream(file);\r\n        this.load(is, file.toURI());\r\n    }\r\n\r\n    public void load(InputStream inputStream, URI rootSCLFileLocation) throws SCLParseException {\r\n        this.doc = doParse(inputStream, rootSCLFileLocation);\r\n    }\r\n\r\n    public void load(Reader reader) throws SCLParseException {\r\n        this.doc = doParse(reader);\r\n    }\r\n\r\n    private static Document doParse(InputStream inputStream, URI rootSCLFileLocation) throws SCLParseException {\r\n        try {\r\n            SCLLexer lexer = new SCLLexer(new ANTLRInputStream(inputStream, DEFAULT_ENCODING));\r\n            CommonTokenStream tokens = new CommonTokenStream(lexer);\r\n            SCLParser parser = new SCLParser(tokens);\r\n            parser.setRootSCLFile(rootSCLFileLocation);\r\n            parser.setIncludeProcessor(new DefaultIncludeProcessor(rootSCLFileLocation, parser.getRootDocument()));\r\n            parser.setLocalReferenceProcessor(new DefaultLocalReferenceProcessor());\r\n            return parser.scl();\r\n        } catch (Exception e) {\r\n            throw new SCLParseException(\"SCLParser unable to parse input\", e);\r\n        }\r\n    }\r\n\r\n    private static Document doParse(Reader reader) throws SCLParseException {\r\n        try {\r\n            SCLLexer lexer = new SCLLexer(new ANTLRReaderStream(reader));\r\n            CommonTokenStream tokens = new CommonTokenStream(lexer);\r\n            SCLParser parser = new SCLParser(tokens);\r\n            return parser.scl();\r\n        } catch (Exception e) {\r\n            throw new SCLParseException(\"SCLParser unable to parse input\", e);\r\n        }\r\n    }\r\n\r\n    public int size() {\r\n        try {\r\n            return ((Double) getXPath().evaluate(\"count(\" + allTextNodesExpr + \")\", this.doc, XPathConstants.NUMBER)).intValue();\r\n        } catch (XPathExpressionException xpee) {\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    public boolean isEmpty() {\r\n        return this.size() < 1;\r\n    }\r\n\r\n    public boolean containsKey(Object key) {\r\n        String xpr = convertToXPath((String) key);\r\n        try {\r\n            return (Boolean) getXPath().evaluate(\"count(\" + xpr + \") > 0\", this.doc, XPathConstants.BOOLEAN);\r\n        } catch (XPathExpressionException e) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public boolean containsValue(Object value) {\r\n        try {\r\n            return (Boolean) getXPath().evaluate(allTextNodesExpr + \" = '\" + (String) value + \"'\", this.doc, XPathConstants.BOOLEAN);\r\n        } catch (XPathExpressionException e) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public String get(Object key) {\r\n        String xpr = convertToXPath((String) key);\r\n        try {\r\n            String result = (String) getXPath().evaluate(xpr + \"/text()\", this.doc, XPathConstants.STRING);\r\n            return result.equals(\"\") ? null : result;\r\n        } catch (XPathExpressionException e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public String put(String key, final String value) {\r\n        String[] elements = key.split(\"\\\\.\");\r\n        int step = 0;\r\n        return this.createNode(elements, step, value, doc.getDocumentElement());\r\n    }\r\n\r\n    @SuppressWarnings({ \"AssignmentToMethodParameter\" })\r\n    private String createNode(String[] pathElements, int step, String value, Element currentElement) {\r\n        NodeList children = currentElement.getElementsByTagName(pathElements[step]);\r\n        Element nextElement;\r\n        if (children.getLength() < 1) {\r\n            nextElement = this.doc.createElement(pathElements[step]);\r\n            currentElement.appendChild(nextElement);\r\n        } else {\r\n            //XXX we're assuming a constraint on SCL that node names are unique, amoung siblings\r\n            nextElement = (Element) children.item(0);\r\n        }\r\n        if (step == (pathElements.length - 1)) {\r\n            String originalValue = (nextElement.getTextContent() != null && !\"\".equals(nextElement.getTextContent())) ? nextElement.getTextContent() : value;\r\n            nextElement.setTextContent(value);\r\n            return originalValue;\r\n        }\r\n        return createNode(pathElements, ++step, value, nextElement);\r\n    }\r\n\r\n    public String remove(Object key) {\r\n        String xprr = convertToXPath((String) key);\r\n        Element element;\r\n        try {\r\n            element = (Element) getXPath().evaluate(xprr, this.doc, XPathConstants.NODE);\r\n            if (element != null) {\r\n                Node parent = element.getParentNode();\r\n                StringBuffer path = new StringBuffer();\r\n                buildPropertyFullPath(element, path);\r\n                parent.removeChild(element);\r\n                return path.toString();\r\n            }\r\n            return null;\r\n        } catch (XPathExpressionException e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public void putAll(Map<? extends String, ? extends String> m) {\r\n        //todo\r\n    }\r\n\r\n    public void clear() {\r\n        NodeList childNodes = this.doc.getChildNodes();\r\n        for (int i = 0; i < childNodes.getLength(); i++) {\r\n            this.doc.removeChild(childNodes.item(i));\r\n        }\r\n    }\r\n\r\n    public Set<String> keySet() {\r\n        NodeList nodes = this.getAttributes(this.doc);\r\n        Set<String> keySet = new HashSet<String>();\r\n        if (nodes != null) {\r\n            for (int i = 0; i < nodes.getLength(); i++) {\r\n                Node currentNode = (Element) nodes.item(i);\r\n                StringBuffer path = new StringBuffer(currentNode.getNodeName());\r\n                buildPropertyFullPath(currentNode, path);\r\n                keySet.add(path.toString());\r\n            }\r\n        }\r\n        return keySet;\r\n    }\r\n\r\n    private void buildPropertyFullPath(Node currentNode, StringBuffer path) {\r\n        currentNode = currentNode.getParentNode();\r\n        while (!currentNode.getNodeName().equals(\"scl\")) {\r\n            path.insert(0, currentNode.getNodeName() + \".\");\r\n            currentNode = currentNode.getParentNode();\r\n        }\r\n    }\r\n\r\n    public Collection<String> values() {\r\n        NodeList nodes = this.getAttributes(this.doc);\r\n        Collection<String> values = new HashSet<String>();\r\n        if (nodes != null) {\r\n            for (int i = 0; i < nodes.getLength(); i++) {\r\n                values.add(nodes.item(i).getNodeValue());\r\n            }\r\n        }\r\n        return values;\r\n    }\r\n\r\n    public Set<Entry<String, String>> entrySet() {\r\n        NodeList nodes = this.getAttributes(this.doc);\r\n        Set<Entry<String, String>> entrySet = new HashSet<Entry<String, String>>();\r\n        if (nodes != null) {\r\n            for (int i = 0; i < nodes.getLength(); i++) {\r\n                Node node = (Element) nodes.item(i);\r\n                StringBuffer path = new StringBuffer(node.getNodeName());\r\n                this.buildPropertyFullPath(node, path);\r\n                entrySet.add(new AbstractMap.SimpleEntry<String, String>(path.toString(), node.getTextContent()));\r\n            }\r\n        }\r\n        return entrySet;\r\n    }\r\n\r\n    protected NodeList getAttributes(Document doc) {\r\n        try {\r\n            return (NodeList) getXPath().evaluate(allTextNodesExpr, doc, XPathConstants.NODESET);\r\n        } catch (XPathExpressionException e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    private XPath getXPath() {\r\n        return XPathFactory.newInstance().newXPath();\r\n    }\r\n\r\n    public String toString() {\r\n        return this.entrySet().toString();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/60_sugar/src/main/java/net/sf/sugar/scl/SCLProperties_0Test.java",
		"test_prompt": "// SCLProperties_0Test.java\npackage net.sf.sugar.scl;\n\nimport static net.sf.sugar.scl.PathConversionUtils.convertToXPath;\nimport org.antlr.runtime.ANTLRInputStream;\nimport org.antlr.runtime.ANTLRReaderStream;\nimport org.antlr.runtime.CommonTokenStream;\nimport org.w3c.dom.*;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpressionException;\nimport javax.xml.xpath.XPathFactory;\nimport java.io.*;\nimport java.net.URI;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SCLProperties}.\n* It contains ten unit test cases for the {@link SCLProperties#size()} method.\n*/\nclass SCLProperties_0Test {"
	},
	{
		"original_code": "// SCLProperties.java\npackage net.sf.sugar.scl;\r\n\r\nimport static net.sf.sugar.scl.PathConversionUtils.convertToXPath;\r\nimport org.antlr.runtime.ANTLRInputStream;\r\nimport org.antlr.runtime.ANTLRReaderStream;\r\nimport org.antlr.runtime.CommonTokenStream;\r\nimport org.w3c.dom.*;\r\nimport javax.xml.xpath.XPath;\r\nimport javax.xml.xpath.XPathConstants;\r\nimport javax.xml.xpath.XPathExpressionException;\r\nimport javax.xml.xpath.XPathFactory;\r\nimport java.io.*;\r\nimport java.net.URI;\r\nimport java.util.*;\r\n\r\n/**\r\n * SCLProperties is java.util.Map implementation which reads SCL (Simple Configuration Language) files.\r\n * It is intended to be an alternative to the standard Java Properties file format, and provides the ability to\r\n * create properties files using a simple nested structure that makes the file more manageable and readable.\r\n * <p/>\r\n * <pre>\r\n * a {\r\n *   b: \"value for b\"\r\n *   c: \"value for c\"\r\n *   d {\r\n *     e: \"value for e\"\r\n *   } //single line comment\r\n * }\r\n * </pre>\r\n * User: kbishop\r\n * Date: 20-Jul-2008\r\n * Time: 00:59:48\r\n */\r\npublic class SCLProperties implements Map<String, String> {\r\n\r\n    private Document doc;\r\n\r\n    private final String allTextNodesExpr = \"//*[count(./*) = 0]\";\r\n\r\n    private static final String DEFAULT_ENCODING = \"UTF-8\";\r\n\r\n    public SCLProperties(String filename) throws SCLParseException, FileNotFoundException {\r\n        this.load(new File(filename));\r\n    }\r\n\r\n    public SCLProperties(File sclFile) throws SCLParseException, FileNotFoundException {\r\n        this.load(sclFile);\r\n    }\r\n\r\n    //    public SCLProperties(InputStream inputStream) throws SCLParseException {\r\n    //        this();\r\n    //        this.load(inputStream);\r\n    //    }\r\n    public SCLProperties(Reader reader) throws SCLParseException {\r\n        this.load(reader);\r\n    }\r\n\r\n    public void load(File file) throws SCLParseException, FileNotFoundException {\r\n        InputStream is = new FileInputStream(file);\r\n        this.load(is, file.toURI());\r\n    }\r\n\r\n    public void load(InputStream inputStream, URI rootSCLFileLocation) throws SCLParseException {\r\n        this.doc = doParse(inputStream, rootSCLFileLocation);\r\n    }\r\n\r\n    public void load(Reader reader) throws SCLParseException {\r\n        this.doc = doParse(reader);\r\n    }\r\n\r\n    private static Document doParse(InputStream inputStream, URI rootSCLFileLocation) throws SCLParseException {\r\n        try {\r\n            SCLLexer lexer = new SCLLexer(new ANTLRInputStream(inputStream, DEFAULT_ENCODING));\r\n            CommonTokenStream tokens = new CommonTokenStream(lexer);\r\n            SCLParser parser = new SCLParser(tokens);\r\n            parser.setRootSCLFile(rootSCLFileLocation);\r\n            parser.setIncludeProcessor(new DefaultIncludeProcessor(rootSCLFileLocation, parser.getRootDocument()));\r\n            parser.setLocalReferenceProcessor(new DefaultLocalReferenceProcessor());\r\n            return parser.scl();\r\n        } catch (Exception e) {\r\n            throw new SCLParseException(\"SCLParser unable to parse input\", e);\r\n        }\r\n    }\r\n\r\n    private static Document doParse(Reader reader) throws SCLParseException {\r\n        try {\r\n            SCLLexer lexer = new SCLLexer(new ANTLRReaderStream(reader));\r\n            CommonTokenStream tokens = new CommonTokenStream(lexer);\r\n            SCLParser parser = new SCLParser(tokens);\r\n            return parser.scl();\r\n        } catch (Exception e) {\r\n            throw new SCLParseException(\"SCLParser unable to parse input\", e);\r\n        }\r\n    }\r\n\r\n    public int size() {\r\n        try {\r\n            return ((Double) getXPath().evaluate(\"count(\" + allTextNodesExpr + \")\", this.doc, XPathConstants.NUMBER)).intValue();\r\n        } catch (XPathExpressionException xpee) {\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    public boolean isEmpty() {\r\n        return this.size() < 1;\r\n    }\r\n\r\n    public boolean containsKey(Object key) {\r\n        String xpr = convertToXPath((String) key);\r\n        try {\r\n            return (Boolean) getXPath().evaluate(\"count(\" + xpr + \") > 0\", this.doc, XPathConstants.BOOLEAN);\r\n        } catch (XPathExpressionException e) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public boolean containsValue(Object value) {\r\n        try {\r\n            return (Boolean) getXPath().evaluate(allTextNodesExpr + \" = '\" + (String) value + \"'\", this.doc, XPathConstants.BOOLEAN);\r\n        } catch (XPathExpressionException e) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public String get(Object key) {\r\n        String xpr = convertToXPath((String) key);\r\n        try {\r\n            String result = (String) getXPath().evaluate(xpr + \"/text()\", this.doc, XPathConstants.STRING);\r\n            return result.equals(\"\") ? null : result;\r\n        } catch (XPathExpressionException e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public String put(String key, final String value) {\r\n        String[] elements = key.split(\"\\\\.\");\r\n        int step = 0;\r\n        return this.createNode(elements, step, value, doc.getDocumentElement());\r\n    }\r\n\r\n    @SuppressWarnings({ \"AssignmentToMethodParameter\" })\r\n    private String createNode(String[] pathElements, int step, String value, Element currentElement) {\r\n        NodeList children = currentElement.getElementsByTagName(pathElements[step]);\r\n        Element nextElement;\r\n        if (children.getLength() < 1) {\r\n            nextElement = this.doc.createElement(pathElements[step]);\r\n            currentElement.appendChild(nextElement);\r\n        } else {\r\n            //XXX we're assuming a constraint on SCL that node names are unique, amoung siblings\r\n            nextElement = (Element) children.item(0);\r\n        }\r\n        if (step == (pathElements.length - 1)) {\r\n            String originalValue = (nextElement.getTextContent() != null && !\"\".equals(nextElement.getTextContent())) ? nextElement.getTextContent() : value;\r\n            nextElement.setTextContent(value);\r\n            return originalValue;\r\n        }\r\n        return createNode(pathElements, ++step, value, nextElement);\r\n    }\r\n\r\n    public String remove(Object key) {\r\n        String xprr = convertToXPath((String) key);\r\n        Element element;\r\n        try {\r\n            element = (Element) getXPath().evaluate(xprr, this.doc, XPathConstants.NODE);\r\n            if (element != null) {\r\n                Node parent = element.getParentNode();\r\n                StringBuffer path = new StringBuffer();\r\n                buildPropertyFullPath(element, path);\r\n                parent.removeChild(element);\r\n                return path.toString();\r\n            }\r\n            return null;\r\n        } catch (XPathExpressionException e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public void putAll(Map<? extends String, ? extends String> m) {\r\n        //todo\r\n    }\r\n\r\n    public void clear() {\r\n        NodeList childNodes = this.doc.getChildNodes();\r\n        for (int i = 0; i < childNodes.getLength(); i++) {\r\n            this.doc.removeChild(childNodes.item(i));\r\n        }\r\n    }\r\n\r\n    public Set<String> keySet() {\r\n        NodeList nodes = this.getAttributes(this.doc);\r\n        Set<String> keySet = new HashSet<String>();\r\n        if (nodes != null) {\r\n            for (int i = 0; i < nodes.getLength(); i++) {\r\n                Node currentNode = (Element) nodes.item(i);\r\n                StringBuffer path = new StringBuffer(currentNode.getNodeName());\r\n                buildPropertyFullPath(currentNode, path);\r\n                keySet.add(path.toString());\r\n            }\r\n        }\r\n        return keySet;\r\n    }\r\n\r\n    private void buildPropertyFullPath(Node currentNode, StringBuffer path) {\r\n        currentNode = currentNode.getParentNode();\r\n        while (!currentNode.getNodeName().equals(\"scl\")) {\r\n            path.insert(0, currentNode.getNodeName() + \".\");\r\n            currentNode = currentNode.getParentNode();\r\n        }\r\n    }\r\n\r\n    public Collection<String> values() {\r\n        NodeList nodes = this.getAttributes(this.doc);\r\n        Collection<String> values = new HashSet<String>();\r\n        if (nodes != null) {\r\n            for (int i = 0; i < nodes.getLength(); i++) {\r\n                values.add(nodes.item(i).getNodeValue());\r\n            }\r\n        }\r\n        return values;\r\n    }\r\n\r\n    public Set<Entry<String, String>> entrySet() {\r\n        NodeList nodes = this.getAttributes(this.doc);\r\n        Set<Entry<String, String>> entrySet = new HashSet<Entry<String, String>>();\r\n        if (nodes != null) {\r\n            for (int i = 0; i < nodes.getLength(); i++) {\r\n                Node node = (Element) nodes.item(i);\r\n                StringBuffer path = new StringBuffer(node.getNodeName());\r\n                this.buildPropertyFullPath(node, path);\r\n                entrySet.add(new AbstractMap.SimpleEntry<String, String>(path.toString(), node.getTextContent()));\r\n            }\r\n        }\r\n        return entrySet;\r\n    }\r\n\r\n    protected NodeList getAttributes(Document doc) {\r\n        try {\r\n            return (NodeList) getXPath().evaluate(allTextNodesExpr, doc, XPathConstants.NODESET);\r\n        } catch (XPathExpressionException e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    private XPath getXPath() {\r\n        return XPathFactory.newInstance().newXPath();\r\n    }\r\n\r\n    public String toString() {\r\n        return this.entrySet().toString();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/60_sugar/src/main/java/net/sf/sugar/scl/SCLProperties_1Test.java",
		"test_prompt": "// SCLProperties_1Test.java\npackage net.sf.sugar.scl;\n\nimport static net.sf.sugar.scl.PathConversionUtils.convertToXPath;\nimport org.antlr.runtime.ANTLRInputStream;\nimport org.antlr.runtime.ANTLRReaderStream;\nimport org.antlr.runtime.CommonTokenStream;\nimport org.w3c.dom.*;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpressionException;\nimport javax.xml.xpath.XPathFactory;\nimport java.io.*;\nimport java.net.URI;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SCLProperties}.\n* It contains ten unit test cases for the {@link SCLProperties#isEmpty()} method.\n*/\nclass SCLProperties_1Test {"
	},
	{
		"original_code": "// SCLProperties.java\npackage net.sf.sugar.scl;\r\n\r\nimport static net.sf.sugar.scl.PathConversionUtils.convertToXPath;\r\nimport org.antlr.runtime.ANTLRInputStream;\r\nimport org.antlr.runtime.ANTLRReaderStream;\r\nimport org.antlr.runtime.CommonTokenStream;\r\nimport org.w3c.dom.*;\r\nimport javax.xml.xpath.XPath;\r\nimport javax.xml.xpath.XPathConstants;\r\nimport javax.xml.xpath.XPathExpressionException;\r\nimport javax.xml.xpath.XPathFactory;\r\nimport java.io.*;\r\nimport java.net.URI;\r\nimport java.util.*;\r\n\r\n/**\r\n * SCLProperties is java.util.Map implementation which reads SCL (Simple Configuration Language) files.\r\n * It is intended to be an alternative to the standard Java Properties file format, and provides the ability to\r\n * create properties files using a simple nested structure that makes the file more manageable and readable.\r\n * <p/>\r\n * <pre>\r\n * a {\r\n *   b: \"value for b\"\r\n *   c: \"value for c\"\r\n *   d {\r\n *     e: \"value for e\"\r\n *   } //single line comment\r\n * }\r\n * </pre>\r\n * User: kbishop\r\n * Date: 20-Jul-2008\r\n * Time: 00:59:48\r\n */\r\npublic class SCLProperties implements Map<String, String> {\r\n\r\n    private Document doc;\r\n\r\n    private final String allTextNodesExpr = \"//*[count(./*) = 0]\";\r\n\r\n    private static final String DEFAULT_ENCODING = \"UTF-8\";\r\n\r\n    public SCLProperties(String filename) throws SCLParseException, FileNotFoundException {\r\n        this.load(new File(filename));\r\n    }\r\n\r\n    public SCLProperties(File sclFile) throws SCLParseException, FileNotFoundException {\r\n        this.load(sclFile);\r\n    }\r\n\r\n    //    public SCLProperties(InputStream inputStream) throws SCLParseException {\r\n    //        this();\r\n    //        this.load(inputStream);\r\n    //    }\r\n    public SCLProperties(Reader reader) throws SCLParseException {\r\n        this.load(reader);\r\n    }\r\n\r\n    public void load(File file) throws SCLParseException, FileNotFoundException {\r\n        InputStream is = new FileInputStream(file);\r\n        this.load(is, file.toURI());\r\n    }\r\n\r\n    public void load(InputStream inputStream, URI rootSCLFileLocation) throws SCLParseException {\r\n        this.doc = doParse(inputStream, rootSCLFileLocation);\r\n    }\r\n\r\n    public void load(Reader reader) throws SCLParseException {\r\n        this.doc = doParse(reader);\r\n    }\r\n\r\n    private static Document doParse(InputStream inputStream, URI rootSCLFileLocation) throws SCLParseException {\r\n        try {\r\n            SCLLexer lexer = new SCLLexer(new ANTLRInputStream(inputStream, DEFAULT_ENCODING));\r\n            CommonTokenStream tokens = new CommonTokenStream(lexer);\r\n            SCLParser parser = new SCLParser(tokens);\r\n            parser.setRootSCLFile(rootSCLFileLocation);\r\n            parser.setIncludeProcessor(new DefaultIncludeProcessor(rootSCLFileLocation, parser.getRootDocument()));\r\n            parser.setLocalReferenceProcessor(new DefaultLocalReferenceProcessor());\r\n            return parser.scl();\r\n        } catch (Exception e) {\r\n            throw new SCLParseException(\"SCLParser unable to parse input\", e);\r\n        }\r\n    }\r\n\r\n    private static Document doParse(Reader reader) throws SCLParseException {\r\n        try {\r\n            SCLLexer lexer = new SCLLexer(new ANTLRReaderStream(reader));\r\n            CommonTokenStream tokens = new CommonTokenStream(lexer);\r\n            SCLParser parser = new SCLParser(tokens);\r\n            return parser.scl();\r\n        } catch (Exception e) {\r\n            throw new SCLParseException(\"SCLParser unable to parse input\", e);\r\n        }\r\n    }\r\n\r\n    public int size() {\r\n        try {\r\n            return ((Double) getXPath().evaluate(\"count(\" + allTextNodesExpr + \")\", this.doc, XPathConstants.NUMBER)).intValue();\r\n        } catch (XPathExpressionException xpee) {\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    public boolean isEmpty() {\r\n        return this.size() < 1;\r\n    }\r\n\r\n    public boolean containsKey(Object key) {\r\n        String xpr = convertToXPath((String) key);\r\n        try {\r\n            return (Boolean) getXPath().evaluate(\"count(\" + xpr + \") > 0\", this.doc, XPathConstants.BOOLEAN);\r\n        } catch (XPathExpressionException e) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public boolean containsValue(Object value) {\r\n        try {\r\n            return (Boolean) getXPath().evaluate(allTextNodesExpr + \" = '\" + (String) value + \"'\", this.doc, XPathConstants.BOOLEAN);\r\n        } catch (XPathExpressionException e) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public String get(Object key) {\r\n        String xpr = convertToXPath((String) key);\r\n        try {\r\n            String result = (String) getXPath().evaluate(xpr + \"/text()\", this.doc, XPathConstants.STRING);\r\n            return result.equals(\"\") ? null : result;\r\n        } catch (XPathExpressionException e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public String put(String key, final String value) {\r\n        String[] elements = key.split(\"\\\\.\");\r\n        int step = 0;\r\n        return this.createNode(elements, step, value, doc.getDocumentElement());\r\n    }\r\n\r\n    @SuppressWarnings({ \"AssignmentToMethodParameter\" })\r\n    private String createNode(String[] pathElements, int step, String value, Element currentElement) {\r\n        NodeList children = currentElement.getElementsByTagName(pathElements[step]);\r\n        Element nextElement;\r\n        if (children.getLength() < 1) {\r\n            nextElement = this.doc.createElement(pathElements[step]);\r\n            currentElement.appendChild(nextElement);\r\n        } else {\r\n            //XXX we're assuming a constraint on SCL that node names are unique, amoung siblings\r\n            nextElement = (Element) children.item(0);\r\n        }\r\n        if (step == (pathElements.length - 1)) {\r\n            String originalValue = (nextElement.getTextContent() != null && !\"\".equals(nextElement.getTextContent())) ? nextElement.getTextContent() : value;\r\n            nextElement.setTextContent(value);\r\n            return originalValue;\r\n        }\r\n        return createNode(pathElements, ++step, value, nextElement);\r\n    }\r\n\r\n    public String remove(Object key) {\r\n        String xprr = convertToXPath((String) key);\r\n        Element element;\r\n        try {\r\n            element = (Element) getXPath().evaluate(xprr, this.doc, XPathConstants.NODE);\r\n            if (element != null) {\r\n                Node parent = element.getParentNode();\r\n                StringBuffer path = new StringBuffer();\r\n                buildPropertyFullPath(element, path);\r\n                parent.removeChild(element);\r\n                return path.toString();\r\n            }\r\n            return null;\r\n        } catch (XPathExpressionException e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public void putAll(Map<? extends String, ? extends String> m) {\r\n        //todo\r\n    }\r\n\r\n    public void clear() {\r\n        NodeList childNodes = this.doc.getChildNodes();\r\n        for (int i = 0; i < childNodes.getLength(); i++) {\r\n            this.doc.removeChild(childNodes.item(i));\r\n        }\r\n    }\r\n\r\n    public Set<String> keySet() {\r\n        NodeList nodes = this.getAttributes(this.doc);\r\n        Set<String> keySet = new HashSet<String>();\r\n        if (nodes != null) {\r\n            for (int i = 0; i < nodes.getLength(); i++) {\r\n                Node currentNode = (Element) nodes.item(i);\r\n                StringBuffer path = new StringBuffer(currentNode.getNodeName());\r\n                buildPropertyFullPath(currentNode, path);\r\n                keySet.add(path.toString());\r\n            }\r\n        }\r\n        return keySet;\r\n    }\r\n\r\n    private void buildPropertyFullPath(Node currentNode, StringBuffer path) {\r\n        currentNode = currentNode.getParentNode();\r\n        while (!currentNode.getNodeName().equals(\"scl\")) {\r\n            path.insert(0, currentNode.getNodeName() + \".\");\r\n            currentNode = currentNode.getParentNode();\r\n        }\r\n    }\r\n\r\n    public Collection<String> values() {\r\n        NodeList nodes = this.getAttributes(this.doc);\r\n        Collection<String> values = new HashSet<String>();\r\n        if (nodes != null) {\r\n            for (int i = 0; i < nodes.getLength(); i++) {\r\n                values.add(nodes.item(i).getNodeValue());\r\n            }\r\n        }\r\n        return values;\r\n    }\r\n\r\n    public Set<Entry<String, String>> entrySet() {\r\n        NodeList nodes = this.getAttributes(this.doc);\r\n        Set<Entry<String, String>> entrySet = new HashSet<Entry<String, String>>();\r\n        if (nodes != null) {\r\n            for (int i = 0; i < nodes.getLength(); i++) {\r\n                Node node = (Element) nodes.item(i);\r\n                StringBuffer path = new StringBuffer(node.getNodeName());\r\n                this.buildPropertyFullPath(node, path);\r\n                entrySet.add(new AbstractMap.SimpleEntry<String, String>(path.toString(), node.getTextContent()));\r\n            }\r\n        }\r\n        return entrySet;\r\n    }\r\n\r\n    protected NodeList getAttributes(Document doc) {\r\n        try {\r\n            return (NodeList) getXPath().evaluate(allTextNodesExpr, doc, XPathConstants.NODESET);\r\n        } catch (XPathExpressionException e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    private XPath getXPath() {\r\n        return XPathFactory.newInstance().newXPath();\r\n    }\r\n\r\n    public String toString() {\r\n        return this.entrySet().toString();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/60_sugar/src/main/java/net/sf/sugar/scl/SCLProperties_2Test.java",
		"test_prompt": "// SCLProperties_2Test.java\npackage net.sf.sugar.scl;\n\nimport static net.sf.sugar.scl.PathConversionUtils.convertToXPath;\nimport org.antlr.runtime.ANTLRInputStream;\nimport org.antlr.runtime.ANTLRReaderStream;\nimport org.antlr.runtime.CommonTokenStream;\nimport org.w3c.dom.*;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpressionException;\nimport javax.xml.xpath.XPathFactory;\nimport java.io.*;\nimport java.net.URI;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SCLProperties}.\n* It contains ten unit test cases for the {@link SCLProperties#containsKey(Object)} method.\n*/\nclass SCLProperties_2Test {"
	},
	{
		"original_code": "// SCLProperties.java\npackage net.sf.sugar.scl;\r\n\r\nimport static net.sf.sugar.scl.PathConversionUtils.convertToXPath;\r\nimport org.antlr.runtime.ANTLRInputStream;\r\nimport org.antlr.runtime.ANTLRReaderStream;\r\nimport org.antlr.runtime.CommonTokenStream;\r\nimport org.w3c.dom.*;\r\nimport javax.xml.xpath.XPath;\r\nimport javax.xml.xpath.XPathConstants;\r\nimport javax.xml.xpath.XPathExpressionException;\r\nimport javax.xml.xpath.XPathFactory;\r\nimport java.io.*;\r\nimport java.net.URI;\r\nimport java.util.*;\r\n\r\n/**\r\n * SCLProperties is java.util.Map implementation which reads SCL (Simple Configuration Language) files.\r\n * It is intended to be an alternative to the standard Java Properties file format, and provides the ability to\r\n * create properties files using a simple nested structure that makes the file more manageable and readable.\r\n * <p/>\r\n * <pre>\r\n * a {\r\n *   b: \"value for b\"\r\n *   c: \"value for c\"\r\n *   d {\r\n *     e: \"value for e\"\r\n *   } //single line comment\r\n * }\r\n * </pre>\r\n * User: kbishop\r\n * Date: 20-Jul-2008\r\n * Time: 00:59:48\r\n */\r\npublic class SCLProperties implements Map<String, String> {\r\n\r\n    private Document doc;\r\n\r\n    private final String allTextNodesExpr = \"//*[count(./*) = 0]\";\r\n\r\n    private static final String DEFAULT_ENCODING = \"UTF-8\";\r\n\r\n    public SCLProperties(String filename) throws SCLParseException, FileNotFoundException {\r\n        this.load(new File(filename));\r\n    }\r\n\r\n    public SCLProperties(File sclFile) throws SCLParseException, FileNotFoundException {\r\n        this.load(sclFile);\r\n    }\r\n\r\n    //    public SCLProperties(InputStream inputStream) throws SCLParseException {\r\n    //        this();\r\n    //        this.load(inputStream);\r\n    //    }\r\n    public SCLProperties(Reader reader) throws SCLParseException {\r\n        this.load(reader);\r\n    }\r\n\r\n    public void load(File file) throws SCLParseException, FileNotFoundException {\r\n        InputStream is = new FileInputStream(file);\r\n        this.load(is, file.toURI());\r\n    }\r\n\r\n    public void load(InputStream inputStream, URI rootSCLFileLocation) throws SCLParseException {\r\n        this.doc = doParse(inputStream, rootSCLFileLocation);\r\n    }\r\n\r\n    public void load(Reader reader) throws SCLParseException {\r\n        this.doc = doParse(reader);\r\n    }\r\n\r\n    private static Document doParse(InputStream inputStream, URI rootSCLFileLocation) throws SCLParseException {\r\n        try {\r\n            SCLLexer lexer = new SCLLexer(new ANTLRInputStream(inputStream, DEFAULT_ENCODING));\r\n            CommonTokenStream tokens = new CommonTokenStream(lexer);\r\n            SCLParser parser = new SCLParser(tokens);\r\n            parser.setRootSCLFile(rootSCLFileLocation);\r\n            parser.setIncludeProcessor(new DefaultIncludeProcessor(rootSCLFileLocation, parser.getRootDocument()));\r\n            parser.setLocalReferenceProcessor(new DefaultLocalReferenceProcessor());\r\n            return parser.scl();\r\n        } catch (Exception e) {\r\n            throw new SCLParseException(\"SCLParser unable to parse input\", e);\r\n        }\r\n    }\r\n\r\n    private static Document doParse(Reader reader) throws SCLParseException {\r\n        try {\r\n            SCLLexer lexer = new SCLLexer(new ANTLRReaderStream(reader));\r\n            CommonTokenStream tokens = new CommonTokenStream(lexer);\r\n            SCLParser parser = new SCLParser(tokens);\r\n            return parser.scl();\r\n        } catch (Exception e) {\r\n            throw new SCLParseException(\"SCLParser unable to parse input\", e);\r\n        }\r\n    }\r\n\r\n    public int size() {\r\n        try {\r\n            return ((Double) getXPath().evaluate(\"count(\" + allTextNodesExpr + \")\", this.doc, XPathConstants.NUMBER)).intValue();\r\n        } catch (XPathExpressionException xpee) {\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    public boolean isEmpty() {\r\n        return this.size() < 1;\r\n    }\r\n\r\n    public boolean containsKey(Object key) {\r\n        String xpr = convertToXPath((String) key);\r\n        try {\r\n            return (Boolean) getXPath().evaluate(\"count(\" + xpr + \") > 0\", this.doc, XPathConstants.BOOLEAN);\r\n        } catch (XPathExpressionException e) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public boolean containsValue(Object value) {\r\n        try {\r\n            return (Boolean) getXPath().evaluate(allTextNodesExpr + \" = '\" + (String) value + \"'\", this.doc, XPathConstants.BOOLEAN);\r\n        } catch (XPathExpressionException e) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public String get(Object key) {\r\n        String xpr = convertToXPath((String) key);\r\n        try {\r\n            String result = (String) getXPath().evaluate(xpr + \"/text()\", this.doc, XPathConstants.STRING);\r\n            return result.equals(\"\") ? null : result;\r\n        } catch (XPathExpressionException e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public String put(String key, final String value) {\r\n        String[] elements = key.split(\"\\\\.\");\r\n        int step = 0;\r\n        return this.createNode(elements, step, value, doc.getDocumentElement());\r\n    }\r\n\r\n    @SuppressWarnings({ \"AssignmentToMethodParameter\" })\r\n    private String createNode(String[] pathElements, int step, String value, Element currentElement) {\r\n        NodeList children = currentElement.getElementsByTagName(pathElements[step]);\r\n        Element nextElement;\r\n        if (children.getLength() < 1) {\r\n            nextElement = this.doc.createElement(pathElements[step]);\r\n            currentElement.appendChild(nextElement);\r\n        } else {\r\n            //XXX we're assuming a constraint on SCL that node names are unique, amoung siblings\r\n            nextElement = (Element) children.item(0);\r\n        }\r\n        if (step == (pathElements.length - 1)) {\r\n            String originalValue = (nextElement.getTextContent() != null && !\"\".equals(nextElement.getTextContent())) ? nextElement.getTextContent() : value;\r\n            nextElement.setTextContent(value);\r\n            return originalValue;\r\n        }\r\n        return createNode(pathElements, ++step, value, nextElement);\r\n    }\r\n\r\n    public String remove(Object key) {\r\n        String xprr = convertToXPath((String) key);\r\n        Element element;\r\n        try {\r\n            element = (Element) getXPath().evaluate(xprr, this.doc, XPathConstants.NODE);\r\n            if (element != null) {\r\n                Node parent = element.getParentNode();\r\n                StringBuffer path = new StringBuffer();\r\n                buildPropertyFullPath(element, path);\r\n                parent.removeChild(element);\r\n                return path.toString();\r\n            }\r\n            return null;\r\n        } catch (XPathExpressionException e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public void putAll(Map<? extends String, ? extends String> m) {\r\n        //todo\r\n    }\r\n\r\n    public void clear() {\r\n        NodeList childNodes = this.doc.getChildNodes();\r\n        for (int i = 0; i < childNodes.getLength(); i++) {\r\n            this.doc.removeChild(childNodes.item(i));\r\n        }\r\n    }\r\n\r\n    public Set<String> keySet() {\r\n        NodeList nodes = this.getAttributes(this.doc);\r\n        Set<String> keySet = new HashSet<String>();\r\n        if (nodes != null) {\r\n            for (int i = 0; i < nodes.getLength(); i++) {\r\n                Node currentNode = (Element) nodes.item(i);\r\n                StringBuffer path = new StringBuffer(currentNode.getNodeName());\r\n                buildPropertyFullPath(currentNode, path);\r\n                keySet.add(path.toString());\r\n            }\r\n        }\r\n        return keySet;\r\n    }\r\n\r\n    private void buildPropertyFullPath(Node currentNode, StringBuffer path) {\r\n        currentNode = currentNode.getParentNode();\r\n        while (!currentNode.getNodeName().equals(\"scl\")) {\r\n            path.insert(0, currentNode.getNodeName() + \".\");\r\n            currentNode = currentNode.getParentNode();\r\n        }\r\n    }\r\n\r\n    public Collection<String> values() {\r\n        NodeList nodes = this.getAttributes(this.doc);\r\n        Collection<String> values = new HashSet<String>();\r\n        if (nodes != null) {\r\n            for (int i = 0; i < nodes.getLength(); i++) {\r\n                values.add(nodes.item(i).getNodeValue());\r\n            }\r\n        }\r\n        return values;\r\n    }\r\n\r\n    public Set<Entry<String, String>> entrySet() {\r\n        NodeList nodes = this.getAttributes(this.doc);\r\n        Set<Entry<String, String>> entrySet = new HashSet<Entry<String, String>>();\r\n        if (nodes != null) {\r\n            for (int i = 0; i < nodes.getLength(); i++) {\r\n                Node node = (Element) nodes.item(i);\r\n                StringBuffer path = new StringBuffer(node.getNodeName());\r\n                this.buildPropertyFullPath(node, path);\r\n                entrySet.add(new AbstractMap.SimpleEntry<String, String>(path.toString(), node.getTextContent()));\r\n            }\r\n        }\r\n        return entrySet;\r\n    }\r\n\r\n    protected NodeList getAttributes(Document doc) {\r\n        try {\r\n            return (NodeList) getXPath().evaluate(allTextNodesExpr, doc, XPathConstants.NODESET);\r\n        } catch (XPathExpressionException e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    private XPath getXPath() {\r\n        return XPathFactory.newInstance().newXPath();\r\n    }\r\n\r\n    public String toString() {\r\n        return this.entrySet().toString();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/60_sugar/src/main/java/net/sf/sugar/scl/SCLProperties_3Test.java",
		"test_prompt": "// SCLProperties_3Test.java\npackage net.sf.sugar.scl;\n\nimport static net.sf.sugar.scl.PathConversionUtils.convertToXPath;\nimport org.antlr.runtime.ANTLRInputStream;\nimport org.antlr.runtime.ANTLRReaderStream;\nimport org.antlr.runtime.CommonTokenStream;\nimport org.w3c.dom.*;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpressionException;\nimport javax.xml.xpath.XPathFactory;\nimport java.io.*;\nimport java.net.URI;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SCLProperties}.\n* It contains ten unit test cases for the {@link SCLProperties#containsValue(Object)} method.\n*/\nclass SCLProperties_3Test {"
	},
	{
		"original_code": "// SCLProperties.java\npackage net.sf.sugar.scl;\r\n\r\nimport static net.sf.sugar.scl.PathConversionUtils.convertToXPath;\r\nimport org.antlr.runtime.ANTLRInputStream;\r\nimport org.antlr.runtime.ANTLRReaderStream;\r\nimport org.antlr.runtime.CommonTokenStream;\r\nimport org.w3c.dom.*;\r\nimport javax.xml.xpath.XPath;\r\nimport javax.xml.xpath.XPathConstants;\r\nimport javax.xml.xpath.XPathExpressionException;\r\nimport javax.xml.xpath.XPathFactory;\r\nimport java.io.*;\r\nimport java.net.URI;\r\nimport java.util.*;\r\n\r\n/**\r\n * SCLProperties is java.util.Map implementation which reads SCL (Simple Configuration Language) files.\r\n * It is intended to be an alternative to the standard Java Properties file format, and provides the ability to\r\n * create properties files using a simple nested structure that makes the file more manageable and readable.\r\n * <p/>\r\n * <pre>\r\n * a {\r\n *   b: \"value for b\"\r\n *   c: \"value for c\"\r\n *   d {\r\n *     e: \"value for e\"\r\n *   } //single line comment\r\n * }\r\n * </pre>\r\n * User: kbishop\r\n * Date: 20-Jul-2008\r\n * Time: 00:59:48\r\n */\r\npublic class SCLProperties implements Map<String, String> {\r\n\r\n    private Document doc;\r\n\r\n    private final String allTextNodesExpr = \"//*[count(./*) = 0]\";\r\n\r\n    private static final String DEFAULT_ENCODING = \"UTF-8\";\r\n\r\n    public SCLProperties(String filename) throws SCLParseException, FileNotFoundException {\r\n        this.load(new File(filename));\r\n    }\r\n\r\n    public SCLProperties(File sclFile) throws SCLParseException, FileNotFoundException {\r\n        this.load(sclFile);\r\n    }\r\n\r\n    //    public SCLProperties(InputStream inputStream) throws SCLParseException {\r\n    //        this();\r\n    //        this.load(inputStream);\r\n    //    }\r\n    public SCLProperties(Reader reader) throws SCLParseException {\r\n        this.load(reader);\r\n    }\r\n\r\n    public void load(File file) throws SCLParseException, FileNotFoundException {\r\n        InputStream is = new FileInputStream(file);\r\n        this.load(is, file.toURI());\r\n    }\r\n\r\n    public void load(InputStream inputStream, URI rootSCLFileLocation) throws SCLParseException {\r\n        this.doc = doParse(inputStream, rootSCLFileLocation);\r\n    }\r\n\r\n    public void load(Reader reader) throws SCLParseException {\r\n        this.doc = doParse(reader);\r\n    }\r\n\r\n    private static Document doParse(InputStream inputStream, URI rootSCLFileLocation) throws SCLParseException {\r\n        try {\r\n            SCLLexer lexer = new SCLLexer(new ANTLRInputStream(inputStream, DEFAULT_ENCODING));\r\n            CommonTokenStream tokens = new CommonTokenStream(lexer);\r\n            SCLParser parser = new SCLParser(tokens);\r\n            parser.setRootSCLFile(rootSCLFileLocation);\r\n            parser.setIncludeProcessor(new DefaultIncludeProcessor(rootSCLFileLocation, parser.getRootDocument()));\r\n            parser.setLocalReferenceProcessor(new DefaultLocalReferenceProcessor());\r\n            return parser.scl();\r\n        } catch (Exception e) {\r\n            throw new SCLParseException(\"SCLParser unable to parse input\", e);\r\n        }\r\n    }\r\n\r\n    private static Document doParse(Reader reader) throws SCLParseException {\r\n        try {\r\n            SCLLexer lexer = new SCLLexer(new ANTLRReaderStream(reader));\r\n            CommonTokenStream tokens = new CommonTokenStream(lexer);\r\n            SCLParser parser = new SCLParser(tokens);\r\n            return parser.scl();\r\n        } catch (Exception e) {\r\n            throw new SCLParseException(\"SCLParser unable to parse input\", e);\r\n        }\r\n    }\r\n\r\n    public int size() {\r\n        try {\r\n            return ((Double) getXPath().evaluate(\"count(\" + allTextNodesExpr + \")\", this.doc, XPathConstants.NUMBER)).intValue();\r\n        } catch (XPathExpressionException xpee) {\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    public boolean isEmpty() {\r\n        return this.size() < 1;\r\n    }\r\n\r\n    public boolean containsKey(Object key) {\r\n        String xpr = convertToXPath((String) key);\r\n        try {\r\n            return (Boolean) getXPath().evaluate(\"count(\" + xpr + \") > 0\", this.doc, XPathConstants.BOOLEAN);\r\n        } catch (XPathExpressionException e) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public boolean containsValue(Object value) {\r\n        try {\r\n            return (Boolean) getXPath().evaluate(allTextNodesExpr + \" = '\" + (String) value + \"'\", this.doc, XPathConstants.BOOLEAN);\r\n        } catch (XPathExpressionException e) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public String get(Object key) {\r\n        String xpr = convertToXPath((String) key);\r\n        try {\r\n            String result = (String) getXPath().evaluate(xpr + \"/text()\", this.doc, XPathConstants.STRING);\r\n            return result.equals(\"\") ? null : result;\r\n        } catch (XPathExpressionException e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public String put(String key, final String value) {\r\n        String[] elements = key.split(\"\\\\.\");\r\n        int step = 0;\r\n        return this.createNode(elements, step, value, doc.getDocumentElement());\r\n    }\r\n\r\n    @SuppressWarnings({ \"AssignmentToMethodParameter\" })\r\n    private String createNode(String[] pathElements, int step, String value, Element currentElement) {\r\n        NodeList children = currentElement.getElementsByTagName(pathElements[step]);\r\n        Element nextElement;\r\n        if (children.getLength() < 1) {\r\n            nextElement = this.doc.createElement(pathElements[step]);\r\n            currentElement.appendChild(nextElement);\r\n        } else {\r\n            //XXX we're assuming a constraint on SCL that node names are unique, amoung siblings\r\n            nextElement = (Element) children.item(0);\r\n        }\r\n        if (step == (pathElements.length - 1)) {\r\n            String originalValue = (nextElement.getTextContent() != null && !\"\".equals(nextElement.getTextContent())) ? nextElement.getTextContent() : value;\r\n            nextElement.setTextContent(value);\r\n            return originalValue;\r\n        }\r\n        return createNode(pathElements, ++step, value, nextElement);\r\n    }\r\n\r\n    public String remove(Object key) {\r\n        String xprr = convertToXPath((String) key);\r\n        Element element;\r\n        try {\r\n            element = (Element) getXPath().evaluate(xprr, this.doc, XPathConstants.NODE);\r\n            if (element != null) {\r\n                Node parent = element.getParentNode();\r\n                StringBuffer path = new StringBuffer();\r\n                buildPropertyFullPath(element, path);\r\n                parent.removeChild(element);\r\n                return path.toString();\r\n            }\r\n            return null;\r\n        } catch (XPathExpressionException e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public void putAll(Map<? extends String, ? extends String> m) {\r\n        //todo\r\n    }\r\n\r\n    public void clear() {\r\n        NodeList childNodes = this.doc.getChildNodes();\r\n        for (int i = 0; i < childNodes.getLength(); i++) {\r\n            this.doc.removeChild(childNodes.item(i));\r\n        }\r\n    }\r\n\r\n    public Set<String> keySet() {\r\n        NodeList nodes = this.getAttributes(this.doc);\r\n        Set<String> keySet = new HashSet<String>();\r\n        if (nodes != null) {\r\n            for (int i = 0; i < nodes.getLength(); i++) {\r\n                Node currentNode = (Element) nodes.item(i);\r\n                StringBuffer path = new StringBuffer(currentNode.getNodeName());\r\n                buildPropertyFullPath(currentNode, path);\r\n                keySet.add(path.toString());\r\n            }\r\n        }\r\n        return keySet;\r\n    }\r\n\r\n    private void buildPropertyFullPath(Node currentNode, StringBuffer path) {\r\n        currentNode = currentNode.getParentNode();\r\n        while (!currentNode.getNodeName().equals(\"scl\")) {\r\n            path.insert(0, currentNode.getNodeName() + \".\");\r\n            currentNode = currentNode.getParentNode();\r\n        }\r\n    }\r\n\r\n    public Collection<String> values() {\r\n        NodeList nodes = this.getAttributes(this.doc);\r\n        Collection<String> values = new HashSet<String>();\r\n        if (nodes != null) {\r\n            for (int i = 0; i < nodes.getLength(); i++) {\r\n                values.add(nodes.item(i).getNodeValue());\r\n            }\r\n        }\r\n        return values;\r\n    }\r\n\r\n    public Set<Entry<String, String>> entrySet() {\r\n        NodeList nodes = this.getAttributes(this.doc);\r\n        Set<Entry<String, String>> entrySet = new HashSet<Entry<String, String>>();\r\n        if (nodes != null) {\r\n            for (int i = 0; i < nodes.getLength(); i++) {\r\n                Node node = (Element) nodes.item(i);\r\n                StringBuffer path = new StringBuffer(node.getNodeName());\r\n                this.buildPropertyFullPath(node, path);\r\n                entrySet.add(new AbstractMap.SimpleEntry<String, String>(path.toString(), node.getTextContent()));\r\n            }\r\n        }\r\n        return entrySet;\r\n    }\r\n\r\n    protected NodeList getAttributes(Document doc) {\r\n        try {\r\n            return (NodeList) getXPath().evaluate(allTextNodesExpr, doc, XPathConstants.NODESET);\r\n        } catch (XPathExpressionException e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    private XPath getXPath() {\r\n        return XPathFactory.newInstance().newXPath();\r\n    }\r\n\r\n    public String toString() {\r\n        return this.entrySet().toString();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/60_sugar/src/main/java/net/sf/sugar/scl/SCLProperties_4Test.java",
		"test_prompt": "// SCLProperties_4Test.java\npackage net.sf.sugar.scl;\n\nimport static net.sf.sugar.scl.PathConversionUtils.convertToXPath;\nimport org.antlr.runtime.ANTLRInputStream;\nimport org.antlr.runtime.ANTLRReaderStream;\nimport org.antlr.runtime.CommonTokenStream;\nimport org.w3c.dom.*;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpressionException;\nimport javax.xml.xpath.XPathFactory;\nimport java.io.*;\nimport java.net.URI;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SCLProperties}.\n* It contains ten unit test cases for the {@link SCLProperties#put(String, String)} method.\n*/\nclass SCLProperties_4Test {"
	},
	{
		"original_code": "// SCLProperties.java\npackage net.sf.sugar.scl;\r\n\r\nimport static net.sf.sugar.scl.PathConversionUtils.convertToXPath;\r\nimport org.antlr.runtime.ANTLRInputStream;\r\nimport org.antlr.runtime.ANTLRReaderStream;\r\nimport org.antlr.runtime.CommonTokenStream;\r\nimport org.w3c.dom.*;\r\nimport javax.xml.xpath.XPath;\r\nimport javax.xml.xpath.XPathConstants;\r\nimport javax.xml.xpath.XPathExpressionException;\r\nimport javax.xml.xpath.XPathFactory;\r\nimport java.io.*;\r\nimport java.net.URI;\r\nimport java.util.*;\r\n\r\n/**\r\n * SCLProperties is java.util.Map implementation which reads SCL (Simple Configuration Language) files.\r\n * It is intended to be an alternative to the standard Java Properties file format, and provides the ability to\r\n * create properties files using a simple nested structure that makes the file more manageable and readable.\r\n * <p/>\r\n * <pre>\r\n * a {\r\n *   b: \"value for b\"\r\n *   c: \"value for c\"\r\n *   d {\r\n *     e: \"value for e\"\r\n *   } //single line comment\r\n * }\r\n * </pre>\r\n * User: kbishop\r\n * Date: 20-Jul-2008\r\n * Time: 00:59:48\r\n */\r\npublic class SCLProperties implements Map<String, String> {\r\n\r\n    private Document doc;\r\n\r\n    private final String allTextNodesExpr = \"//*[count(./*) = 0]\";\r\n\r\n    private static final String DEFAULT_ENCODING = \"UTF-8\";\r\n\r\n    public SCLProperties(String filename) throws SCLParseException, FileNotFoundException {\r\n        this.load(new File(filename));\r\n    }\r\n\r\n    public SCLProperties(File sclFile) throws SCLParseException, FileNotFoundException {\r\n        this.load(sclFile);\r\n    }\r\n\r\n    //    public SCLProperties(InputStream inputStream) throws SCLParseException {\r\n    //        this();\r\n    //        this.load(inputStream);\r\n    //    }\r\n    public SCLProperties(Reader reader) throws SCLParseException {\r\n        this.load(reader);\r\n    }\r\n\r\n    public void load(File file) throws SCLParseException, FileNotFoundException {\r\n        InputStream is = new FileInputStream(file);\r\n        this.load(is, file.toURI());\r\n    }\r\n\r\n    public void load(InputStream inputStream, URI rootSCLFileLocation) throws SCLParseException {\r\n        this.doc = doParse(inputStream, rootSCLFileLocation);\r\n    }\r\n\r\n    public void load(Reader reader) throws SCLParseException {\r\n        this.doc = doParse(reader);\r\n    }\r\n\r\n    private static Document doParse(InputStream inputStream, URI rootSCLFileLocation) throws SCLParseException {\r\n        try {\r\n            SCLLexer lexer = new SCLLexer(new ANTLRInputStream(inputStream, DEFAULT_ENCODING));\r\n            CommonTokenStream tokens = new CommonTokenStream(lexer);\r\n            SCLParser parser = new SCLParser(tokens);\r\n            parser.setRootSCLFile(rootSCLFileLocation);\r\n            parser.setIncludeProcessor(new DefaultIncludeProcessor(rootSCLFileLocation, parser.getRootDocument()));\r\n            parser.setLocalReferenceProcessor(new DefaultLocalReferenceProcessor());\r\n            return parser.scl();\r\n        } catch (Exception e) {\r\n            throw new SCLParseException(\"SCLParser unable to parse input\", e);\r\n        }\r\n    }\r\n\r\n    private static Document doParse(Reader reader) throws SCLParseException {\r\n        try {\r\n            SCLLexer lexer = new SCLLexer(new ANTLRReaderStream(reader));\r\n            CommonTokenStream tokens = new CommonTokenStream(lexer);\r\n            SCLParser parser = new SCLParser(tokens);\r\n            return parser.scl();\r\n        } catch (Exception e) {\r\n            throw new SCLParseException(\"SCLParser unable to parse input\", e);\r\n        }\r\n    }\r\n\r\n    public int size() {\r\n        try {\r\n            return ((Double) getXPath().evaluate(\"count(\" + allTextNodesExpr + \")\", this.doc, XPathConstants.NUMBER)).intValue();\r\n        } catch (XPathExpressionException xpee) {\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    public boolean isEmpty() {\r\n        return this.size() < 1;\r\n    }\r\n\r\n    public boolean containsKey(Object key) {\r\n        String xpr = convertToXPath((String) key);\r\n        try {\r\n            return (Boolean) getXPath().evaluate(\"count(\" + xpr + \") > 0\", this.doc, XPathConstants.BOOLEAN);\r\n        } catch (XPathExpressionException e) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public boolean containsValue(Object value) {\r\n        try {\r\n            return (Boolean) getXPath().evaluate(allTextNodesExpr + \" = '\" + (String) value + \"'\", this.doc, XPathConstants.BOOLEAN);\r\n        } catch (XPathExpressionException e) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public String get(Object key) {\r\n        String xpr = convertToXPath((String) key);\r\n        try {\r\n            String result = (String) getXPath().evaluate(xpr + \"/text()\", this.doc, XPathConstants.STRING);\r\n            return result.equals(\"\") ? null : result;\r\n        } catch (XPathExpressionException e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public String put(String key, final String value) {\r\n        String[] elements = key.split(\"\\\\.\");\r\n        int step = 0;\r\n        return this.createNode(elements, step, value, doc.getDocumentElement());\r\n    }\r\n\r\n    @SuppressWarnings({ \"AssignmentToMethodParameter\" })\r\n    private String createNode(String[] pathElements, int step, String value, Element currentElement) {\r\n        NodeList children = currentElement.getElementsByTagName(pathElements[step]);\r\n        Element nextElement;\r\n        if (children.getLength() < 1) {\r\n            nextElement = this.doc.createElement(pathElements[step]);\r\n            currentElement.appendChild(nextElement);\r\n        } else {\r\n            //XXX we're assuming a constraint on SCL that node names are unique, amoung siblings\r\n            nextElement = (Element) children.item(0);\r\n        }\r\n        if (step == (pathElements.length - 1)) {\r\n            String originalValue = (nextElement.getTextContent() != null && !\"\".equals(nextElement.getTextContent())) ? nextElement.getTextContent() : value;\r\n            nextElement.setTextContent(value);\r\n            return originalValue;\r\n        }\r\n        return createNode(pathElements, ++step, value, nextElement);\r\n    }\r\n\r\n    public String remove(Object key) {\r\n        String xprr = convertToXPath((String) key);\r\n        Element element;\r\n        try {\r\n            element = (Element) getXPath().evaluate(xprr, this.doc, XPathConstants.NODE);\r\n            if (element != null) {\r\n                Node parent = element.getParentNode();\r\n                StringBuffer path = new StringBuffer();\r\n                buildPropertyFullPath(element, path);\r\n                parent.removeChild(element);\r\n                return path.toString();\r\n            }\r\n            return null;\r\n        } catch (XPathExpressionException e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public void putAll(Map<? extends String, ? extends String> m) {\r\n        //todo\r\n    }\r\n\r\n    public void clear() {\r\n        NodeList childNodes = this.doc.getChildNodes();\r\n        for (int i = 0; i < childNodes.getLength(); i++) {\r\n            this.doc.removeChild(childNodes.item(i));\r\n        }\r\n    }\r\n\r\n    public Set<String> keySet() {\r\n        NodeList nodes = this.getAttributes(this.doc);\r\n        Set<String> keySet = new HashSet<String>();\r\n        if (nodes != null) {\r\n            for (int i = 0; i < nodes.getLength(); i++) {\r\n                Node currentNode = (Element) nodes.item(i);\r\n                StringBuffer path = new StringBuffer(currentNode.getNodeName());\r\n                buildPropertyFullPath(currentNode, path);\r\n                keySet.add(path.toString());\r\n            }\r\n        }\r\n        return keySet;\r\n    }\r\n\r\n    private void buildPropertyFullPath(Node currentNode, StringBuffer path) {\r\n        currentNode = currentNode.getParentNode();\r\n        while (!currentNode.getNodeName().equals(\"scl\")) {\r\n            path.insert(0, currentNode.getNodeName() + \".\");\r\n            currentNode = currentNode.getParentNode();\r\n        }\r\n    }\r\n\r\n    public Collection<String> values() {\r\n        NodeList nodes = this.getAttributes(this.doc);\r\n        Collection<String> values = new HashSet<String>();\r\n        if (nodes != null) {\r\n            for (int i = 0; i < nodes.getLength(); i++) {\r\n                values.add(nodes.item(i).getNodeValue());\r\n            }\r\n        }\r\n        return values;\r\n    }\r\n\r\n    public Set<Entry<String, String>> entrySet() {\r\n        NodeList nodes = this.getAttributes(this.doc);\r\n        Set<Entry<String, String>> entrySet = new HashSet<Entry<String, String>>();\r\n        if (nodes != null) {\r\n            for (int i = 0; i < nodes.getLength(); i++) {\r\n                Node node = (Element) nodes.item(i);\r\n                StringBuffer path = new StringBuffer(node.getNodeName());\r\n                this.buildPropertyFullPath(node, path);\r\n                entrySet.add(new AbstractMap.SimpleEntry<String, String>(path.toString(), node.getTextContent()));\r\n            }\r\n        }\r\n        return entrySet;\r\n    }\r\n\r\n    protected NodeList getAttributes(Document doc) {\r\n        try {\r\n            return (NodeList) getXPath().evaluate(allTextNodesExpr, doc, XPathConstants.NODESET);\r\n        } catch (XPathExpressionException e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    private XPath getXPath() {\r\n        return XPathFactory.newInstance().newXPath();\r\n    }\r\n\r\n    public String toString() {\r\n        return this.entrySet().toString();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/60_sugar/src/main/java/net/sf/sugar/scl/SCLProperties_5Test.java",
		"test_prompt": "// SCLProperties_5Test.java\npackage net.sf.sugar.scl;\n\nimport static net.sf.sugar.scl.PathConversionUtils.convertToXPath;\nimport org.antlr.runtime.ANTLRInputStream;\nimport org.antlr.runtime.ANTLRReaderStream;\nimport org.antlr.runtime.CommonTokenStream;\nimport org.w3c.dom.*;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpressionException;\nimport javax.xml.xpath.XPathFactory;\nimport java.io.*;\nimport java.net.URI;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SCLProperties}.\n* It contains ten unit test cases for the {@link SCLProperties#remove(Object)} method.\n*/\nclass SCLProperties_5Test {"
	},
	{
		"original_code": "// SCLProperties.java\npackage net.sf.sugar.scl;\r\n\r\nimport static net.sf.sugar.scl.PathConversionUtils.convertToXPath;\r\nimport org.antlr.runtime.ANTLRInputStream;\r\nimport org.antlr.runtime.ANTLRReaderStream;\r\nimport org.antlr.runtime.CommonTokenStream;\r\nimport org.w3c.dom.*;\r\nimport javax.xml.xpath.XPath;\r\nimport javax.xml.xpath.XPathConstants;\r\nimport javax.xml.xpath.XPathExpressionException;\r\nimport javax.xml.xpath.XPathFactory;\r\nimport java.io.*;\r\nimport java.net.URI;\r\nimport java.util.*;\r\n\r\n/**\r\n * SCLProperties is java.util.Map implementation which reads SCL (Simple Configuration Language) files.\r\n * It is intended to be an alternative to the standard Java Properties file format, and provides the ability to\r\n * create properties files using a simple nested structure that makes the file more manageable and readable.\r\n * <p/>\r\n * <pre>\r\n * a {\r\n *   b: \"value for b\"\r\n *   c: \"value for c\"\r\n *   d {\r\n *     e: \"value for e\"\r\n *   } //single line comment\r\n * }\r\n * </pre>\r\n * User: kbishop\r\n * Date: 20-Jul-2008\r\n * Time: 00:59:48\r\n */\r\npublic class SCLProperties implements Map<String, String> {\r\n\r\n    private Document doc;\r\n\r\n    private final String allTextNodesExpr = \"//*[count(./*) = 0]\";\r\n\r\n    private static final String DEFAULT_ENCODING = \"UTF-8\";\r\n\r\n    public SCLProperties(String filename) throws SCLParseException, FileNotFoundException {\r\n        this.load(new File(filename));\r\n    }\r\n\r\n    public SCLProperties(File sclFile) throws SCLParseException, FileNotFoundException {\r\n        this.load(sclFile);\r\n    }\r\n\r\n    //    public SCLProperties(InputStream inputStream) throws SCLParseException {\r\n    //        this();\r\n    //        this.load(inputStream);\r\n    //    }\r\n    public SCLProperties(Reader reader) throws SCLParseException {\r\n        this.load(reader);\r\n    }\r\n\r\n    public void load(File file) throws SCLParseException, FileNotFoundException {\r\n        InputStream is = new FileInputStream(file);\r\n        this.load(is, file.toURI());\r\n    }\r\n\r\n    public void load(InputStream inputStream, URI rootSCLFileLocation) throws SCLParseException {\r\n        this.doc = doParse(inputStream, rootSCLFileLocation);\r\n    }\r\n\r\n    public void load(Reader reader) throws SCLParseException {\r\n        this.doc = doParse(reader);\r\n    }\r\n\r\n    private static Document doParse(InputStream inputStream, URI rootSCLFileLocation) throws SCLParseException {\r\n        try {\r\n            SCLLexer lexer = new SCLLexer(new ANTLRInputStream(inputStream, DEFAULT_ENCODING));\r\n            CommonTokenStream tokens = new CommonTokenStream(lexer);\r\n            SCLParser parser = new SCLParser(tokens);\r\n            parser.setRootSCLFile(rootSCLFileLocation);\r\n            parser.setIncludeProcessor(new DefaultIncludeProcessor(rootSCLFileLocation, parser.getRootDocument()));\r\n            parser.setLocalReferenceProcessor(new DefaultLocalReferenceProcessor());\r\n            return parser.scl();\r\n        } catch (Exception e) {\r\n            throw new SCLParseException(\"SCLParser unable to parse input\", e);\r\n        }\r\n    }\r\n\r\n    private static Document doParse(Reader reader) throws SCLParseException {\r\n        try {\r\n            SCLLexer lexer = new SCLLexer(new ANTLRReaderStream(reader));\r\n            CommonTokenStream tokens = new CommonTokenStream(lexer);\r\n            SCLParser parser = new SCLParser(tokens);\r\n            return parser.scl();\r\n        } catch (Exception e) {\r\n            throw new SCLParseException(\"SCLParser unable to parse input\", e);\r\n        }\r\n    }\r\n\r\n    public int size() {\r\n        try {\r\n            return ((Double) getXPath().evaluate(\"count(\" + allTextNodesExpr + \")\", this.doc, XPathConstants.NUMBER)).intValue();\r\n        } catch (XPathExpressionException xpee) {\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    public boolean isEmpty() {\r\n        return this.size() < 1;\r\n    }\r\n\r\n    public boolean containsKey(Object key) {\r\n        String xpr = convertToXPath((String) key);\r\n        try {\r\n            return (Boolean) getXPath().evaluate(\"count(\" + xpr + \") > 0\", this.doc, XPathConstants.BOOLEAN);\r\n        } catch (XPathExpressionException e) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public boolean containsValue(Object value) {\r\n        try {\r\n            return (Boolean) getXPath().evaluate(allTextNodesExpr + \" = '\" + (String) value + \"'\", this.doc, XPathConstants.BOOLEAN);\r\n        } catch (XPathExpressionException e) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public String get(Object key) {\r\n        String xpr = convertToXPath((String) key);\r\n        try {\r\n            String result = (String) getXPath().evaluate(xpr + \"/text()\", this.doc, XPathConstants.STRING);\r\n            return result.equals(\"\") ? null : result;\r\n        } catch (XPathExpressionException e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public String put(String key, final String value) {\r\n        String[] elements = key.split(\"\\\\.\");\r\n        int step = 0;\r\n        return this.createNode(elements, step, value, doc.getDocumentElement());\r\n    }\r\n\r\n    @SuppressWarnings({ \"AssignmentToMethodParameter\" })\r\n    private String createNode(String[] pathElements, int step, String value, Element currentElement) {\r\n        NodeList children = currentElement.getElementsByTagName(pathElements[step]);\r\n        Element nextElement;\r\n        if (children.getLength() < 1) {\r\n            nextElement = this.doc.createElement(pathElements[step]);\r\n            currentElement.appendChild(nextElement);\r\n        } else {\r\n            //XXX we're assuming a constraint on SCL that node names are unique, amoung siblings\r\n            nextElement = (Element) children.item(0);\r\n        }\r\n        if (step == (pathElements.length - 1)) {\r\n            String originalValue = (nextElement.getTextContent() != null && !\"\".equals(nextElement.getTextContent())) ? nextElement.getTextContent() : value;\r\n            nextElement.setTextContent(value);\r\n            return originalValue;\r\n        }\r\n        return createNode(pathElements, ++step, value, nextElement);\r\n    }\r\n\r\n    public String remove(Object key) {\r\n        String xprr = convertToXPath((String) key);\r\n        Element element;\r\n        try {\r\n            element = (Element) getXPath().evaluate(xprr, this.doc, XPathConstants.NODE);\r\n            if (element != null) {\r\n                Node parent = element.getParentNode();\r\n                StringBuffer path = new StringBuffer();\r\n                buildPropertyFullPath(element, path);\r\n                parent.removeChild(element);\r\n                return path.toString();\r\n            }\r\n            return null;\r\n        } catch (XPathExpressionException e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public void putAll(Map<? extends String, ? extends String> m) {\r\n        //todo\r\n    }\r\n\r\n    public void clear() {\r\n        NodeList childNodes = this.doc.getChildNodes();\r\n        for (int i = 0; i < childNodes.getLength(); i++) {\r\n            this.doc.removeChild(childNodes.item(i));\r\n        }\r\n    }\r\n\r\n    public Set<String> keySet() {\r\n        NodeList nodes = this.getAttributes(this.doc);\r\n        Set<String> keySet = new HashSet<String>();\r\n        if (nodes != null) {\r\n            for (int i = 0; i < nodes.getLength(); i++) {\r\n                Node currentNode = (Element) nodes.item(i);\r\n                StringBuffer path = new StringBuffer(currentNode.getNodeName());\r\n                buildPropertyFullPath(currentNode, path);\r\n                keySet.add(path.toString());\r\n            }\r\n        }\r\n        return keySet;\r\n    }\r\n\r\n    private void buildPropertyFullPath(Node currentNode, StringBuffer path) {\r\n        currentNode = currentNode.getParentNode();\r\n        while (!currentNode.getNodeName().equals(\"scl\")) {\r\n            path.insert(0, currentNode.getNodeName() + \".\");\r\n            currentNode = currentNode.getParentNode();\r\n        }\r\n    }\r\n\r\n    public Collection<String> values() {\r\n        NodeList nodes = this.getAttributes(this.doc);\r\n        Collection<String> values = new HashSet<String>();\r\n        if (nodes != null) {\r\n            for (int i = 0; i < nodes.getLength(); i++) {\r\n                values.add(nodes.item(i).getNodeValue());\r\n            }\r\n        }\r\n        return values;\r\n    }\r\n\r\n    public Set<Entry<String, String>> entrySet() {\r\n        NodeList nodes = this.getAttributes(this.doc);\r\n        Set<Entry<String, String>> entrySet = new HashSet<Entry<String, String>>();\r\n        if (nodes != null) {\r\n            for (int i = 0; i < nodes.getLength(); i++) {\r\n                Node node = (Element) nodes.item(i);\r\n                StringBuffer path = new StringBuffer(node.getNodeName());\r\n                this.buildPropertyFullPath(node, path);\r\n                entrySet.add(new AbstractMap.SimpleEntry<String, String>(path.toString(), node.getTextContent()));\r\n            }\r\n        }\r\n        return entrySet;\r\n    }\r\n\r\n    protected NodeList getAttributes(Document doc) {\r\n        try {\r\n            return (NodeList) getXPath().evaluate(allTextNodesExpr, doc, XPathConstants.NODESET);\r\n        } catch (XPathExpressionException e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    private XPath getXPath() {\r\n        return XPathFactory.newInstance().newXPath();\r\n    }\r\n\r\n    public String toString() {\r\n        return this.entrySet().toString();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/60_sugar/src/main/java/net/sf/sugar/scl/SCLProperties_6Test.java",
		"test_prompt": "// SCLProperties_6Test.java\npackage net.sf.sugar.scl;\n\nimport static net.sf.sugar.scl.PathConversionUtils.convertToXPath;\nimport org.antlr.runtime.ANTLRInputStream;\nimport org.antlr.runtime.ANTLRReaderStream;\nimport org.antlr.runtime.CommonTokenStream;\nimport org.w3c.dom.*;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpressionException;\nimport javax.xml.xpath.XPathFactory;\nimport java.io.*;\nimport java.net.URI;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SCLProperties}.\n* It contains ten unit test cases for the {@link SCLProperties#keySet()} method.\n*/\nclass SCLProperties_6Test {"
	},
	{
		"original_code": "// SCLProperties.java\npackage net.sf.sugar.scl;\r\n\r\nimport static net.sf.sugar.scl.PathConversionUtils.convertToXPath;\r\nimport org.antlr.runtime.ANTLRInputStream;\r\nimport org.antlr.runtime.ANTLRReaderStream;\r\nimport org.antlr.runtime.CommonTokenStream;\r\nimport org.w3c.dom.*;\r\nimport javax.xml.xpath.XPath;\r\nimport javax.xml.xpath.XPathConstants;\r\nimport javax.xml.xpath.XPathExpressionException;\r\nimport javax.xml.xpath.XPathFactory;\r\nimport java.io.*;\r\nimport java.net.URI;\r\nimport java.util.*;\r\n\r\n/**\r\n * SCLProperties is java.util.Map implementation which reads SCL (Simple Configuration Language) files.\r\n * It is intended to be an alternative to the standard Java Properties file format, and provides the ability to\r\n * create properties files using a simple nested structure that makes the file more manageable and readable.\r\n * <p/>\r\n * <pre>\r\n * a {\r\n *   b: \"value for b\"\r\n *   c: \"value for c\"\r\n *   d {\r\n *     e: \"value for e\"\r\n *   } //single line comment\r\n * }\r\n * </pre>\r\n * User: kbishop\r\n * Date: 20-Jul-2008\r\n * Time: 00:59:48\r\n */\r\npublic class SCLProperties implements Map<String, String> {\r\n\r\n    private Document doc;\r\n\r\n    private final String allTextNodesExpr = \"//*[count(./*) = 0]\";\r\n\r\n    private static final String DEFAULT_ENCODING = \"UTF-8\";\r\n\r\n    public SCLProperties(String filename) throws SCLParseException, FileNotFoundException {\r\n        this.load(new File(filename));\r\n    }\r\n\r\n    public SCLProperties(File sclFile) throws SCLParseException, FileNotFoundException {\r\n        this.load(sclFile);\r\n    }\r\n\r\n    //    public SCLProperties(InputStream inputStream) throws SCLParseException {\r\n    //        this();\r\n    //        this.load(inputStream);\r\n    //    }\r\n    public SCLProperties(Reader reader) throws SCLParseException {\r\n        this.load(reader);\r\n    }\r\n\r\n    public void load(File file) throws SCLParseException, FileNotFoundException {\r\n        InputStream is = new FileInputStream(file);\r\n        this.load(is, file.toURI());\r\n    }\r\n\r\n    public void load(InputStream inputStream, URI rootSCLFileLocation) throws SCLParseException {\r\n        this.doc = doParse(inputStream, rootSCLFileLocation);\r\n    }\r\n\r\n    public void load(Reader reader) throws SCLParseException {\r\n        this.doc = doParse(reader);\r\n    }\r\n\r\n    private static Document doParse(InputStream inputStream, URI rootSCLFileLocation) throws SCLParseException {\r\n        try {\r\n            SCLLexer lexer = new SCLLexer(new ANTLRInputStream(inputStream, DEFAULT_ENCODING));\r\n            CommonTokenStream tokens = new CommonTokenStream(lexer);\r\n            SCLParser parser = new SCLParser(tokens);\r\n            parser.setRootSCLFile(rootSCLFileLocation);\r\n            parser.setIncludeProcessor(new DefaultIncludeProcessor(rootSCLFileLocation, parser.getRootDocument()));\r\n            parser.setLocalReferenceProcessor(new DefaultLocalReferenceProcessor());\r\n            return parser.scl();\r\n        } catch (Exception e) {\r\n            throw new SCLParseException(\"SCLParser unable to parse input\", e);\r\n        }\r\n    }\r\n\r\n    private static Document doParse(Reader reader) throws SCLParseException {\r\n        try {\r\n            SCLLexer lexer = new SCLLexer(new ANTLRReaderStream(reader));\r\n            CommonTokenStream tokens = new CommonTokenStream(lexer);\r\n            SCLParser parser = new SCLParser(tokens);\r\n            return parser.scl();\r\n        } catch (Exception e) {\r\n            throw new SCLParseException(\"SCLParser unable to parse input\", e);\r\n        }\r\n    }\r\n\r\n    public int size() {\r\n        try {\r\n            return ((Double) getXPath().evaluate(\"count(\" + allTextNodesExpr + \")\", this.doc, XPathConstants.NUMBER)).intValue();\r\n        } catch (XPathExpressionException xpee) {\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    public boolean isEmpty() {\r\n        return this.size() < 1;\r\n    }\r\n\r\n    public boolean containsKey(Object key) {\r\n        String xpr = convertToXPath((String) key);\r\n        try {\r\n            return (Boolean) getXPath().evaluate(\"count(\" + xpr + \") > 0\", this.doc, XPathConstants.BOOLEAN);\r\n        } catch (XPathExpressionException e) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public boolean containsValue(Object value) {\r\n        try {\r\n            return (Boolean) getXPath().evaluate(allTextNodesExpr + \" = '\" + (String) value + \"'\", this.doc, XPathConstants.BOOLEAN);\r\n        } catch (XPathExpressionException e) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public String get(Object key) {\r\n        String xpr = convertToXPath((String) key);\r\n        try {\r\n            String result = (String) getXPath().evaluate(xpr + \"/text()\", this.doc, XPathConstants.STRING);\r\n            return result.equals(\"\") ? null : result;\r\n        } catch (XPathExpressionException e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public String put(String key, final String value) {\r\n        String[] elements = key.split(\"\\\\.\");\r\n        int step = 0;\r\n        return this.createNode(elements, step, value, doc.getDocumentElement());\r\n    }\r\n\r\n    @SuppressWarnings({ \"AssignmentToMethodParameter\" })\r\n    private String createNode(String[] pathElements, int step, String value, Element currentElement) {\r\n        NodeList children = currentElement.getElementsByTagName(pathElements[step]);\r\n        Element nextElement;\r\n        if (children.getLength() < 1) {\r\n            nextElement = this.doc.createElement(pathElements[step]);\r\n            currentElement.appendChild(nextElement);\r\n        } else {\r\n            //XXX we're assuming a constraint on SCL that node names are unique, amoung siblings\r\n            nextElement = (Element) children.item(0);\r\n        }\r\n        if (step == (pathElements.length - 1)) {\r\n            String originalValue = (nextElement.getTextContent() != null && !\"\".equals(nextElement.getTextContent())) ? nextElement.getTextContent() : value;\r\n            nextElement.setTextContent(value);\r\n            return originalValue;\r\n        }\r\n        return createNode(pathElements, ++step, value, nextElement);\r\n    }\r\n\r\n    public String remove(Object key) {\r\n        String xprr = convertToXPath((String) key);\r\n        Element element;\r\n        try {\r\n            element = (Element) getXPath().evaluate(xprr, this.doc, XPathConstants.NODE);\r\n            if (element != null) {\r\n                Node parent = element.getParentNode();\r\n                StringBuffer path = new StringBuffer();\r\n                buildPropertyFullPath(element, path);\r\n                parent.removeChild(element);\r\n                return path.toString();\r\n            }\r\n            return null;\r\n        } catch (XPathExpressionException e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public void putAll(Map<? extends String, ? extends String> m) {\r\n        //todo\r\n    }\r\n\r\n    public void clear() {\r\n        NodeList childNodes = this.doc.getChildNodes();\r\n        for (int i = 0; i < childNodes.getLength(); i++) {\r\n            this.doc.removeChild(childNodes.item(i));\r\n        }\r\n    }\r\n\r\n    public Set<String> keySet() {\r\n        NodeList nodes = this.getAttributes(this.doc);\r\n        Set<String> keySet = new HashSet<String>();\r\n        if (nodes != null) {\r\n            for (int i = 0; i < nodes.getLength(); i++) {\r\n                Node currentNode = (Element) nodes.item(i);\r\n                StringBuffer path = new StringBuffer(currentNode.getNodeName());\r\n                buildPropertyFullPath(currentNode, path);\r\n                keySet.add(path.toString());\r\n            }\r\n        }\r\n        return keySet;\r\n    }\r\n\r\n    private void buildPropertyFullPath(Node currentNode, StringBuffer path) {\r\n        currentNode = currentNode.getParentNode();\r\n        while (!currentNode.getNodeName().equals(\"scl\")) {\r\n            path.insert(0, currentNode.getNodeName() + \".\");\r\n            currentNode = currentNode.getParentNode();\r\n        }\r\n    }\r\n\r\n    public Collection<String> values() {\r\n        NodeList nodes = this.getAttributes(this.doc);\r\n        Collection<String> values = new HashSet<String>();\r\n        if (nodes != null) {\r\n            for (int i = 0; i < nodes.getLength(); i++) {\r\n                values.add(nodes.item(i).getNodeValue());\r\n            }\r\n        }\r\n        return values;\r\n    }\r\n\r\n    public Set<Entry<String, String>> entrySet() {\r\n        NodeList nodes = this.getAttributes(this.doc);\r\n        Set<Entry<String, String>> entrySet = new HashSet<Entry<String, String>>();\r\n        if (nodes != null) {\r\n            for (int i = 0; i < nodes.getLength(); i++) {\r\n                Node node = (Element) nodes.item(i);\r\n                StringBuffer path = new StringBuffer(node.getNodeName());\r\n                this.buildPropertyFullPath(node, path);\r\n                entrySet.add(new AbstractMap.SimpleEntry<String, String>(path.toString(), node.getTextContent()));\r\n            }\r\n        }\r\n        return entrySet;\r\n    }\r\n\r\n    protected NodeList getAttributes(Document doc) {\r\n        try {\r\n            return (NodeList) getXPath().evaluate(allTextNodesExpr, doc, XPathConstants.NODESET);\r\n        } catch (XPathExpressionException e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    private XPath getXPath() {\r\n        return XPathFactory.newInstance().newXPath();\r\n    }\r\n\r\n    public String toString() {\r\n        return this.entrySet().toString();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/60_sugar/src/main/java/net/sf/sugar/scl/SCLProperties_7Test.java",
		"test_prompt": "// SCLProperties_7Test.java\npackage net.sf.sugar.scl;\n\nimport static net.sf.sugar.scl.PathConversionUtils.convertToXPath;\nimport org.antlr.runtime.ANTLRInputStream;\nimport org.antlr.runtime.ANTLRReaderStream;\nimport org.antlr.runtime.CommonTokenStream;\nimport org.w3c.dom.*;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpressionException;\nimport javax.xml.xpath.XPathFactory;\nimport java.io.*;\nimport java.net.URI;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SCLProperties}.\n* It contains ten unit test cases for the {@link SCLProperties#values()} method.\n*/\nclass SCLProperties_7Test {"
	},
	{
		"original_code": "// SCLProperties.java\npackage net.sf.sugar.scl;\r\n\r\nimport static net.sf.sugar.scl.PathConversionUtils.convertToXPath;\r\nimport org.antlr.runtime.ANTLRInputStream;\r\nimport org.antlr.runtime.ANTLRReaderStream;\r\nimport org.antlr.runtime.CommonTokenStream;\r\nimport org.w3c.dom.*;\r\nimport javax.xml.xpath.XPath;\r\nimport javax.xml.xpath.XPathConstants;\r\nimport javax.xml.xpath.XPathExpressionException;\r\nimport javax.xml.xpath.XPathFactory;\r\nimport java.io.*;\r\nimport java.net.URI;\r\nimport java.util.*;\r\n\r\n/**\r\n * SCLProperties is java.util.Map implementation which reads SCL (Simple Configuration Language) files.\r\n * It is intended to be an alternative to the standard Java Properties file format, and provides the ability to\r\n * create properties files using a simple nested structure that makes the file more manageable and readable.\r\n * <p/>\r\n * <pre>\r\n * a {\r\n *   b: \"value for b\"\r\n *   c: \"value for c\"\r\n *   d {\r\n *     e: \"value for e\"\r\n *   } //single line comment\r\n * }\r\n * </pre>\r\n * User: kbishop\r\n * Date: 20-Jul-2008\r\n * Time: 00:59:48\r\n */\r\npublic class SCLProperties implements Map<String, String> {\r\n\r\n    private Document doc;\r\n\r\n    private final String allTextNodesExpr = \"//*[count(./*) = 0]\";\r\n\r\n    private static final String DEFAULT_ENCODING = \"UTF-8\";\r\n\r\n    public SCLProperties(String filename) throws SCLParseException, FileNotFoundException {\r\n        this.load(new File(filename));\r\n    }\r\n\r\n    public SCLProperties(File sclFile) throws SCLParseException, FileNotFoundException {\r\n        this.load(sclFile);\r\n    }\r\n\r\n    //    public SCLProperties(InputStream inputStream) throws SCLParseException {\r\n    //        this();\r\n    //        this.load(inputStream);\r\n    //    }\r\n    public SCLProperties(Reader reader) throws SCLParseException {\r\n        this.load(reader);\r\n    }\r\n\r\n    public void load(File file) throws SCLParseException, FileNotFoundException {\r\n        InputStream is = new FileInputStream(file);\r\n        this.load(is, file.toURI());\r\n    }\r\n\r\n    public void load(InputStream inputStream, URI rootSCLFileLocation) throws SCLParseException {\r\n        this.doc = doParse(inputStream, rootSCLFileLocation);\r\n    }\r\n\r\n    public void load(Reader reader) throws SCLParseException {\r\n        this.doc = doParse(reader);\r\n    }\r\n\r\n    private static Document doParse(InputStream inputStream, URI rootSCLFileLocation) throws SCLParseException {\r\n        try {\r\n            SCLLexer lexer = new SCLLexer(new ANTLRInputStream(inputStream, DEFAULT_ENCODING));\r\n            CommonTokenStream tokens = new CommonTokenStream(lexer);\r\n            SCLParser parser = new SCLParser(tokens);\r\n            parser.setRootSCLFile(rootSCLFileLocation);\r\n            parser.setIncludeProcessor(new DefaultIncludeProcessor(rootSCLFileLocation, parser.getRootDocument()));\r\n            parser.setLocalReferenceProcessor(new DefaultLocalReferenceProcessor());\r\n            return parser.scl();\r\n        } catch (Exception e) {\r\n            throw new SCLParseException(\"SCLParser unable to parse input\", e);\r\n        }\r\n    }\r\n\r\n    private static Document doParse(Reader reader) throws SCLParseException {\r\n        try {\r\n            SCLLexer lexer = new SCLLexer(new ANTLRReaderStream(reader));\r\n            CommonTokenStream tokens = new CommonTokenStream(lexer);\r\n            SCLParser parser = new SCLParser(tokens);\r\n            return parser.scl();\r\n        } catch (Exception e) {\r\n            throw new SCLParseException(\"SCLParser unable to parse input\", e);\r\n        }\r\n    }\r\n\r\n    public int size() {\r\n        try {\r\n            return ((Double) getXPath().evaluate(\"count(\" + allTextNodesExpr + \")\", this.doc, XPathConstants.NUMBER)).intValue();\r\n        } catch (XPathExpressionException xpee) {\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    public boolean isEmpty() {\r\n        return this.size() < 1;\r\n    }\r\n\r\n    public boolean containsKey(Object key) {\r\n        String xpr = convertToXPath((String) key);\r\n        try {\r\n            return (Boolean) getXPath().evaluate(\"count(\" + xpr + \") > 0\", this.doc, XPathConstants.BOOLEAN);\r\n        } catch (XPathExpressionException e) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public boolean containsValue(Object value) {\r\n        try {\r\n            return (Boolean) getXPath().evaluate(allTextNodesExpr + \" = '\" + (String) value + \"'\", this.doc, XPathConstants.BOOLEAN);\r\n        } catch (XPathExpressionException e) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public String get(Object key) {\r\n        String xpr = convertToXPath((String) key);\r\n        try {\r\n            String result = (String) getXPath().evaluate(xpr + \"/text()\", this.doc, XPathConstants.STRING);\r\n            return result.equals(\"\") ? null : result;\r\n        } catch (XPathExpressionException e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public String put(String key, final String value) {\r\n        String[] elements = key.split(\"\\\\.\");\r\n        int step = 0;\r\n        return this.createNode(elements, step, value, doc.getDocumentElement());\r\n    }\r\n\r\n    @SuppressWarnings({ \"AssignmentToMethodParameter\" })\r\n    private String createNode(String[] pathElements, int step, String value, Element currentElement) {\r\n        NodeList children = currentElement.getElementsByTagName(pathElements[step]);\r\n        Element nextElement;\r\n        if (children.getLength() < 1) {\r\n            nextElement = this.doc.createElement(pathElements[step]);\r\n            currentElement.appendChild(nextElement);\r\n        } else {\r\n            //XXX we're assuming a constraint on SCL that node names are unique, amoung siblings\r\n            nextElement = (Element) children.item(0);\r\n        }\r\n        if (step == (pathElements.length - 1)) {\r\n            String originalValue = (nextElement.getTextContent() != null && !\"\".equals(nextElement.getTextContent())) ? nextElement.getTextContent() : value;\r\n            nextElement.setTextContent(value);\r\n            return originalValue;\r\n        }\r\n        return createNode(pathElements, ++step, value, nextElement);\r\n    }\r\n\r\n    public String remove(Object key) {\r\n        String xprr = convertToXPath((String) key);\r\n        Element element;\r\n        try {\r\n            element = (Element) getXPath().evaluate(xprr, this.doc, XPathConstants.NODE);\r\n            if (element != null) {\r\n                Node parent = element.getParentNode();\r\n                StringBuffer path = new StringBuffer();\r\n                buildPropertyFullPath(element, path);\r\n                parent.removeChild(element);\r\n                return path.toString();\r\n            }\r\n            return null;\r\n        } catch (XPathExpressionException e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public void putAll(Map<? extends String, ? extends String> m) {\r\n        //todo\r\n    }\r\n\r\n    public void clear() {\r\n        NodeList childNodes = this.doc.getChildNodes();\r\n        for (int i = 0; i < childNodes.getLength(); i++) {\r\n            this.doc.removeChild(childNodes.item(i));\r\n        }\r\n    }\r\n\r\n    public Set<String> keySet() {\r\n        NodeList nodes = this.getAttributes(this.doc);\r\n        Set<String> keySet = new HashSet<String>();\r\n        if (nodes != null) {\r\n            for (int i = 0; i < nodes.getLength(); i++) {\r\n                Node currentNode = (Element) nodes.item(i);\r\n                StringBuffer path = new StringBuffer(currentNode.getNodeName());\r\n                buildPropertyFullPath(currentNode, path);\r\n                keySet.add(path.toString());\r\n            }\r\n        }\r\n        return keySet;\r\n    }\r\n\r\n    private void buildPropertyFullPath(Node currentNode, StringBuffer path) {\r\n        currentNode = currentNode.getParentNode();\r\n        while (!currentNode.getNodeName().equals(\"scl\")) {\r\n            path.insert(0, currentNode.getNodeName() + \".\");\r\n            currentNode = currentNode.getParentNode();\r\n        }\r\n    }\r\n\r\n    public Collection<String> values() {\r\n        NodeList nodes = this.getAttributes(this.doc);\r\n        Collection<String> values = new HashSet<String>();\r\n        if (nodes != null) {\r\n            for (int i = 0; i < nodes.getLength(); i++) {\r\n                values.add(nodes.item(i).getNodeValue());\r\n            }\r\n        }\r\n        return values;\r\n    }\r\n\r\n    public Set<Entry<String, String>> entrySet() {\r\n        NodeList nodes = this.getAttributes(this.doc);\r\n        Set<Entry<String, String>> entrySet = new HashSet<Entry<String, String>>();\r\n        if (nodes != null) {\r\n            for (int i = 0; i < nodes.getLength(); i++) {\r\n                Node node = (Element) nodes.item(i);\r\n                StringBuffer path = new StringBuffer(node.getNodeName());\r\n                this.buildPropertyFullPath(node, path);\r\n                entrySet.add(new AbstractMap.SimpleEntry<String, String>(path.toString(), node.getTextContent()));\r\n            }\r\n        }\r\n        return entrySet;\r\n    }\r\n\r\n    protected NodeList getAttributes(Document doc) {\r\n        try {\r\n            return (NodeList) getXPath().evaluate(allTextNodesExpr, doc, XPathConstants.NODESET);\r\n        } catch (XPathExpressionException e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    private XPath getXPath() {\r\n        return XPathFactory.newInstance().newXPath();\r\n    }\r\n\r\n    public String toString() {\r\n        return this.entrySet().toString();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/60_sugar/src/main/java/net/sf/sugar/scl/SCLProperties_8Test.java",
		"test_prompt": "// SCLProperties_8Test.java\npackage net.sf.sugar.scl;\n\nimport static net.sf.sugar.scl.PathConversionUtils.convertToXPath;\nimport org.antlr.runtime.ANTLRInputStream;\nimport org.antlr.runtime.ANTLRReaderStream;\nimport org.antlr.runtime.CommonTokenStream;\nimport org.w3c.dom.*;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpressionException;\nimport javax.xml.xpath.XPathFactory;\nimport java.io.*;\nimport java.net.URI;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SCLProperties}.\n* It contains ten unit test cases for the {@link SCLProperties#entrySet()} method.\n*/\nclass SCLProperties_8Test {"
	}
]