[
	{
		"original_code": "// ArgsParser.java\n/* dcParseArgs - Java library to simplify args[] handling\n * \n * Copyright (C) 2008 Roland Koller <roland@devcity.de>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 3.0 of the License, or (at your option) any later version.\n * \n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public \n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage de.devcity.parseargs;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport de.devcity.parseargs.arguments.ParameterArgument;\nimport de.devcity.parseargs.arguments.StringArgument;\nimport de.devcity.parseargs.arguments.SwitchArgument;\n\npublic class ArgsParser {\n\n    public static final String SHORT_ARGUMENT_INDICATOR = \"-\";\n\n    public static final String LONG_ARGUMENT_INDICATOR = \"--\";\n\n    private String[] args;\n\n    /* A copy of the original args array */\n    private String[] innerArgs;\n\n    /* A working copy where every already parsed part is deleted or overwritten with null */\n    public ArgsParser() {\n        super();\n    }\n\n    public ArgsParser(String[] args) {\n        super();\n        this.setArgs(args);\n    }\n\n    public int getArgsCount() {\n        return args.length;\n    }\n\n    public String[] getArgs() {\n        return args;\n    }\n\n    public void setArgs(String[] args) {\n        if (args == null)\n            throw new NullPointerException(\"args[] cannot be null.\");\n        this.args = new String[args.length];\n        this.innerArgs = new String[args.length];\n        for (int i = 0; i < args.length; ++i) {\n            this.args[i] = args[i];\n            this.innerArgs[i] = args[i];\n        }\n    }\n\n    public int getArgsLeftCount() {\n        int result = 0;\n        for (int i = 0; i < innerArgs.length; ++i) if (innerArgs[i] != null)\n            result++;\n        return result;\n    }\n\n    public SwitchArgument parseSwitchArgument(String key) {\n        boolean isLongKey = (key.length() > 1);\n        if (isLongKey) {\n            String searchFor = LONG_ARGUMENT_INDICATOR + key;\n            for (int i = 0; i < args.length; ++i) {\n                if (innerArgs[i] != null) {\n                    if (innerArgs[i].equals(searchFor)) {\n                        innerArgs[i] = null;\n                        return new SwitchArgument(i, key, true);\n                    }\n                }\n            }\n        } else {\n            int index;\n            for (int i = 0; i < args.length; ++i) {\n                if (innerArgs[i] != null) {\n                    if (innerArgs[i].length() > 1 && innerArgs[i].startsWith(SHORT_ARGUMENT_INDICATOR) && (!innerArgs[i].startsWith(LONG_ARGUMENT_INDICATOR))) {\n                        index = innerArgs[i].lastIndexOf(key);\n                        if (index > 0) {\n                            String before = innerArgs[i].substring(0, index);\n                            String after = innerArgs[i].substring(index + 1, innerArgs[i].length());\n                            innerArgs[i] = before + after;\n                            if (innerArgs[i].replace(SHORT_ARGUMENT_INDICATOR, \" \").trim().length() == 0)\n                                innerArgs[i] = null;\n                            return new SwitchArgument(i, key, true);\n                        }\n                    }\n                }\n            }\n        }\n        return new SwitchArgument(-1, key, false);\n    }\n\n    public ParameterArgument parseParameterArgument(String key) {\n        boolean isLongKey = (key.length() > 1);\n        if (isLongKey) {\n            String searchFor = LONG_ARGUMENT_INDICATOR + key;\n            for (int i = 0; i < innerArgs.length; ++i) {\n                if (innerArgs[i] != null) {\n                    if (innerArgs[i].equals(searchFor)) {\n                        if ((innerArgs.length > (i + 1)) && (innerArgs[i] != null) && (innerArgs[i + 1] != null)) {\n                            String value = innerArgs[i + 1];\n                            innerArgs[i] = null;\n                            innerArgs[i + 1] = null;\n                            return new ParameterArgument(i, key, value);\n                        } else {\n                            /*\n\t\t\t\t\t\t\t * End of a argument list despite an anticipated parameter (or parameter has already been parsed as an argument.\n\t\t\t\t\t\t\t */\n                            return null;\n                        }\n                    }\n                }\n            }\n        } else {\n            int index;\n            for (int i = 0; i < args.length; ++i) {\n                if (innerArgs[i] != null) {\n                    if (innerArgs[i].length() > 1 && (innerArgs[i].startsWith(SHORT_ARGUMENT_INDICATOR)) && (!innerArgs[i].startsWith(LONG_ARGUMENT_INDICATOR))) {\n                        index = innerArgs[i].indexOf(key);\n                        if (index > 0) {\n                            if ((index + 1) == innerArgs[i].length()) {\n                                /*\n\t\t\t\t\t\t\t\t * Last element of a short argument list. So a parameter - if there is any - has to be in the next element\n\t\t\t\t\t\t\t\t * of args[].\n\t\t\t\t\t\t\t\t */\n                                if ((innerArgs.length > (i + 1)) && (innerArgs[i] != null) && (innerArgs[i + 1]) != null) {\n                                    String before = innerArgs[i].substring(0, index);\n                                    String after = innerArgs[i].substring(index + 1, innerArgs[i].length());\n                                    innerArgs[i] = before + after;\n                                    if (innerArgs[i].replace(SHORT_ARGUMENT_INDICATOR, \" \").trim().length() == 0)\n                                        innerArgs[i] = null;\n                                    String value = innerArgs[i + 1];\n                                    innerArgs[i + 1] = null;\n                                    return new ParameterArgument(i, key, value);\n                                } else {\n                                    /*\n\t\t\t\t\t\t\t\t\t * End of a argument list despite an anticipated parameter (or parameter has already been parsed as an\n\t\t\t\t\t\t\t\t\t * argument.\n\t\t\t\t\t\t\t\t\t */\n                                    return null;\n                                }\n                            } else {\n                                /*\n\t\t\t\t\t\t\t\t * Not the last element of a short argument list. So the parameter is everything that follows the index\n\t\t\t\t\t\t\t\t */\n                                String before = innerArgs[i].substring(0, index);\n                                String value = innerArgs[i].substring(index + 1, innerArgs[i].length());\n                                innerArgs[i] = before;\n                                if (innerArgs[i].replace(SHORT_ARGUMENT_INDICATOR, \" \").trim().length() == 0)\n                                    innerArgs[i] = null;\n                                return new ParameterArgument(i, key, value);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        /* nothing found... */\n        return null;\n    }\n\n    public List<StringArgument> parseStringArgument() {\n        List<StringArgument> result = new ArrayList<StringArgument>();\n        for (int i = 0; i < args.length; ++i) {\n            if (innerArgs[i] != null) {\n                result.add(new StringArgument(i, innerArgs[i]));\n                innerArgs[i] = null;\n            }\n        }\n        return result;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/90_dcparseargs/src/main/java/de/devcity/parseargs/ArgsParser_0Test.java",
		"test_prompt": "// ArgsParser_0Test.java\npackage de.devcity.parseargs;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport de.devcity.parseargs.arguments.ParameterArgument;\nimport de.devcity.parseargs.arguments.StringArgument;\nimport de.devcity.parseargs.arguments.SwitchArgument;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ArgsParser}.\n* It contains ten unit test cases for the {@link ArgsParser#parseSwitchArgument(String)} method.\n*/\nclass ArgsParser_0Test {"
	},
	{
		"original_code": "// ArgsParser.java\n/* dcParseArgs - Java library to simplify args[] handling\n * \n * Copyright (C) 2008 Roland Koller <roland@devcity.de>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 3.0 of the License, or (at your option) any later version.\n * \n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public \n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage de.devcity.parseargs;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport de.devcity.parseargs.arguments.ParameterArgument;\nimport de.devcity.parseargs.arguments.StringArgument;\nimport de.devcity.parseargs.arguments.SwitchArgument;\n\npublic class ArgsParser {\n\n    public static final String SHORT_ARGUMENT_INDICATOR = \"-\";\n\n    public static final String LONG_ARGUMENT_INDICATOR = \"--\";\n\n    private String[] args;\n\n    /* A copy of the original args array */\n    private String[] innerArgs;\n\n    /* A working copy where every already parsed part is deleted or overwritten with null */\n    public ArgsParser() {\n        super();\n    }\n\n    public ArgsParser(String[] args) {\n        super();\n        this.setArgs(args);\n    }\n\n    public int getArgsCount() {\n        return args.length;\n    }\n\n    public String[] getArgs() {\n        return args;\n    }\n\n    public void setArgs(String[] args) {\n        if (args == null)\n            throw new NullPointerException(\"args[] cannot be null.\");\n        this.args = new String[args.length];\n        this.innerArgs = new String[args.length];\n        for (int i = 0; i < args.length; ++i) {\n            this.args[i] = args[i];\n            this.innerArgs[i] = args[i];\n        }\n    }\n\n    public int getArgsLeftCount() {\n        int result = 0;\n        for (int i = 0; i < innerArgs.length; ++i) if (innerArgs[i] != null)\n            result++;\n        return result;\n    }\n\n    public SwitchArgument parseSwitchArgument(String key) {\n        boolean isLongKey = (key.length() > 1);\n        if (isLongKey) {\n            String searchFor = LONG_ARGUMENT_INDICATOR + key;\n            for (int i = 0; i < args.length; ++i) {\n                if (innerArgs[i] != null) {\n                    if (innerArgs[i].equals(searchFor)) {\n                        innerArgs[i] = null;\n                        return new SwitchArgument(i, key, true);\n                    }\n                }\n            }\n        } else {\n            int index;\n            for (int i = 0; i < args.length; ++i) {\n                if (innerArgs[i] != null) {\n                    if (innerArgs[i].length() > 1 && innerArgs[i].startsWith(SHORT_ARGUMENT_INDICATOR) && (!innerArgs[i].startsWith(LONG_ARGUMENT_INDICATOR))) {\n                        index = innerArgs[i].lastIndexOf(key);\n                        if (index > 0) {\n                            String before = innerArgs[i].substring(0, index);\n                            String after = innerArgs[i].substring(index + 1, innerArgs[i].length());\n                            innerArgs[i] = before + after;\n                            if (innerArgs[i].replace(SHORT_ARGUMENT_INDICATOR, \" \").trim().length() == 0)\n                                innerArgs[i] = null;\n                            return new SwitchArgument(i, key, true);\n                        }\n                    }\n                }\n            }\n        }\n        return new SwitchArgument(-1, key, false);\n    }\n\n    public ParameterArgument parseParameterArgument(String key) {\n        boolean isLongKey = (key.length() > 1);\n        if (isLongKey) {\n            String searchFor = LONG_ARGUMENT_INDICATOR + key;\n            for (int i = 0; i < innerArgs.length; ++i) {\n                if (innerArgs[i] != null) {\n                    if (innerArgs[i].equals(searchFor)) {\n                        if ((innerArgs.length > (i + 1)) && (innerArgs[i] != null) && (innerArgs[i + 1] != null)) {\n                            String value = innerArgs[i + 1];\n                            innerArgs[i] = null;\n                            innerArgs[i + 1] = null;\n                            return new ParameterArgument(i, key, value);\n                        } else {\n                            /*\n\t\t\t\t\t\t\t * End of a argument list despite an anticipated parameter (or parameter has already been parsed as an argument.\n\t\t\t\t\t\t\t */\n                            return null;\n                        }\n                    }\n                }\n            }\n        } else {\n            int index;\n            for (int i = 0; i < args.length; ++i) {\n                if (innerArgs[i] != null) {\n                    if (innerArgs[i].length() > 1 && (innerArgs[i].startsWith(SHORT_ARGUMENT_INDICATOR)) && (!innerArgs[i].startsWith(LONG_ARGUMENT_INDICATOR))) {\n                        index = innerArgs[i].indexOf(key);\n                        if (index > 0) {\n                            if ((index + 1) == innerArgs[i].length()) {\n                                /*\n\t\t\t\t\t\t\t\t * Last element of a short argument list. So a parameter - if there is any - has to be in the next element\n\t\t\t\t\t\t\t\t * of args[].\n\t\t\t\t\t\t\t\t */\n                                if ((innerArgs.length > (i + 1)) && (innerArgs[i] != null) && (innerArgs[i + 1]) != null) {\n                                    String before = innerArgs[i].substring(0, index);\n                                    String after = innerArgs[i].substring(index + 1, innerArgs[i].length());\n                                    innerArgs[i] = before + after;\n                                    if (innerArgs[i].replace(SHORT_ARGUMENT_INDICATOR, \" \").trim().length() == 0)\n                                        innerArgs[i] = null;\n                                    String value = innerArgs[i + 1];\n                                    innerArgs[i + 1] = null;\n                                    return new ParameterArgument(i, key, value);\n                                } else {\n                                    /*\n\t\t\t\t\t\t\t\t\t * End of a argument list despite an anticipated parameter (or parameter has already been parsed as an\n\t\t\t\t\t\t\t\t\t * argument.\n\t\t\t\t\t\t\t\t\t */\n                                    return null;\n                                }\n                            } else {\n                                /*\n\t\t\t\t\t\t\t\t * Not the last element of a short argument list. So the parameter is everything that follows the index\n\t\t\t\t\t\t\t\t */\n                                String before = innerArgs[i].substring(0, index);\n                                String value = innerArgs[i].substring(index + 1, innerArgs[i].length());\n                                innerArgs[i] = before;\n                                if (innerArgs[i].replace(SHORT_ARGUMENT_INDICATOR, \" \").trim().length() == 0)\n                                    innerArgs[i] = null;\n                                return new ParameterArgument(i, key, value);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        /* nothing found... */\n        return null;\n    }\n\n    public List<StringArgument> parseStringArgument() {\n        List<StringArgument> result = new ArrayList<StringArgument>();\n        for (int i = 0; i < args.length; ++i) {\n            if (innerArgs[i] != null) {\n                result.add(new StringArgument(i, innerArgs[i]));\n                innerArgs[i] = null;\n            }\n        }\n        return result;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/90_dcparseargs/src/main/java/de/devcity/parseargs/ArgsParser_1Test.java",
		"test_prompt": "// ArgsParser_1Test.java\npackage de.devcity.parseargs;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport de.devcity.parseargs.arguments.ParameterArgument;\nimport de.devcity.parseargs.arguments.StringArgument;\nimport de.devcity.parseargs.arguments.SwitchArgument;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ArgsParser}.\n* It contains ten unit test cases for the {@link ArgsParser#parseParameterArgument(String)} method.\n*/\nclass ArgsParser_1Test {"
	},
	{
		"original_code": "// ArgsParser.java\n/* dcParseArgs - Java library to simplify args[] handling\n * \n * Copyright (C) 2008 Roland Koller <roland@devcity.de>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 3.0 of the License, or (at your option) any later version.\n * \n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public \n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage de.devcity.parseargs;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport de.devcity.parseargs.arguments.ParameterArgument;\nimport de.devcity.parseargs.arguments.StringArgument;\nimport de.devcity.parseargs.arguments.SwitchArgument;\n\npublic class ArgsParser {\n\n    public static final String SHORT_ARGUMENT_INDICATOR = \"-\";\n\n    public static final String LONG_ARGUMENT_INDICATOR = \"--\";\n\n    private String[] args;\n\n    /* A copy of the original args array */\n    private String[] innerArgs;\n\n    /* A working copy where every already parsed part is deleted or overwritten with null */\n    public ArgsParser() {\n        super();\n    }\n\n    public ArgsParser(String[] args) {\n        super();\n        this.setArgs(args);\n    }\n\n    public int getArgsCount() {\n        return args.length;\n    }\n\n    public String[] getArgs() {\n        return args;\n    }\n\n    public void setArgs(String[] args) {\n        if (args == null)\n            throw new NullPointerException(\"args[] cannot be null.\");\n        this.args = new String[args.length];\n        this.innerArgs = new String[args.length];\n        for (int i = 0; i < args.length; ++i) {\n            this.args[i] = args[i];\n            this.innerArgs[i] = args[i];\n        }\n    }\n\n    public int getArgsLeftCount() {\n        int result = 0;\n        for (int i = 0; i < innerArgs.length; ++i) if (innerArgs[i] != null)\n            result++;\n        return result;\n    }\n\n    public SwitchArgument parseSwitchArgument(String key) {\n        boolean isLongKey = (key.length() > 1);\n        if (isLongKey) {\n            String searchFor = LONG_ARGUMENT_INDICATOR + key;\n            for (int i = 0; i < args.length; ++i) {\n                if (innerArgs[i] != null) {\n                    if (innerArgs[i].equals(searchFor)) {\n                        innerArgs[i] = null;\n                        return new SwitchArgument(i, key, true);\n                    }\n                }\n            }\n        } else {\n            int index;\n            for (int i = 0; i < args.length; ++i) {\n                if (innerArgs[i] != null) {\n                    if (innerArgs[i].length() > 1 && innerArgs[i].startsWith(SHORT_ARGUMENT_INDICATOR) && (!innerArgs[i].startsWith(LONG_ARGUMENT_INDICATOR))) {\n                        index = innerArgs[i].lastIndexOf(key);\n                        if (index > 0) {\n                            String before = innerArgs[i].substring(0, index);\n                            String after = innerArgs[i].substring(index + 1, innerArgs[i].length());\n                            innerArgs[i] = before + after;\n                            if (innerArgs[i].replace(SHORT_ARGUMENT_INDICATOR, \" \").trim().length() == 0)\n                                innerArgs[i] = null;\n                            return new SwitchArgument(i, key, true);\n                        }\n                    }\n                }\n            }\n        }\n        return new SwitchArgument(-1, key, false);\n    }\n\n    public ParameterArgument parseParameterArgument(String key) {\n        boolean isLongKey = (key.length() > 1);\n        if (isLongKey) {\n            String searchFor = LONG_ARGUMENT_INDICATOR + key;\n            for (int i = 0; i < innerArgs.length; ++i) {\n                if (innerArgs[i] != null) {\n                    if (innerArgs[i].equals(searchFor)) {\n                        if ((innerArgs.length > (i + 1)) && (innerArgs[i] != null) && (innerArgs[i + 1] != null)) {\n                            String value = innerArgs[i + 1];\n                            innerArgs[i] = null;\n                            innerArgs[i + 1] = null;\n                            return new ParameterArgument(i, key, value);\n                        } else {\n                            /*\n\t\t\t\t\t\t\t * End of a argument list despite an anticipated parameter (or parameter has already been parsed as an argument.\n\t\t\t\t\t\t\t */\n                            return null;\n                        }\n                    }\n                }\n            }\n        } else {\n            int index;\n            for (int i = 0; i < args.length; ++i) {\n                if (innerArgs[i] != null) {\n                    if (innerArgs[i].length() > 1 && (innerArgs[i].startsWith(SHORT_ARGUMENT_INDICATOR)) && (!innerArgs[i].startsWith(LONG_ARGUMENT_INDICATOR))) {\n                        index = innerArgs[i].indexOf(key);\n                        if (index > 0) {\n                            if ((index + 1) == innerArgs[i].length()) {\n                                /*\n\t\t\t\t\t\t\t\t * Last element of a short argument list. So a parameter - if there is any - has to be in the next element\n\t\t\t\t\t\t\t\t * of args[].\n\t\t\t\t\t\t\t\t */\n                                if ((innerArgs.length > (i + 1)) && (innerArgs[i] != null) && (innerArgs[i + 1]) != null) {\n                                    String before = innerArgs[i].substring(0, index);\n                                    String after = innerArgs[i].substring(index + 1, innerArgs[i].length());\n                                    innerArgs[i] = before + after;\n                                    if (innerArgs[i].replace(SHORT_ARGUMENT_INDICATOR, \" \").trim().length() == 0)\n                                        innerArgs[i] = null;\n                                    String value = innerArgs[i + 1];\n                                    innerArgs[i + 1] = null;\n                                    return new ParameterArgument(i, key, value);\n                                } else {\n                                    /*\n\t\t\t\t\t\t\t\t\t * End of a argument list despite an anticipated parameter (or parameter has already been parsed as an\n\t\t\t\t\t\t\t\t\t * argument.\n\t\t\t\t\t\t\t\t\t */\n                                    return null;\n                                }\n                            } else {\n                                /*\n\t\t\t\t\t\t\t\t * Not the last element of a short argument list. So the parameter is everything that follows the index\n\t\t\t\t\t\t\t\t */\n                                String before = innerArgs[i].substring(0, index);\n                                String value = innerArgs[i].substring(index + 1, innerArgs[i].length());\n                                innerArgs[i] = before;\n                                if (innerArgs[i].replace(SHORT_ARGUMENT_INDICATOR, \" \").trim().length() == 0)\n                                    innerArgs[i] = null;\n                                return new ParameterArgument(i, key, value);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        /* nothing found... */\n        return null;\n    }\n\n    public List<StringArgument> parseStringArgument() {\n        List<StringArgument> result = new ArrayList<StringArgument>();\n        for (int i = 0; i < args.length; ++i) {\n            if (innerArgs[i] != null) {\n                result.add(new StringArgument(i, innerArgs[i]));\n                innerArgs[i] = null;\n            }\n        }\n        return result;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/90_dcparseargs/src/main/java/de/devcity/parseargs/ArgsParser_2Test.java",
		"test_prompt": "// ArgsParser_2Test.java\npackage de.devcity.parseargs;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport de.devcity.parseargs.arguments.ParameterArgument;\nimport de.devcity.parseargs.arguments.StringArgument;\nimport de.devcity.parseargs.arguments.SwitchArgument;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ArgsParser}.\n* It contains ten unit test cases for the {@link ArgsParser#parseStringArgument()} method.\n*/\nclass ArgsParser_2Test {"
	},
	{
		"original_code": "// Argument.java\n/* dcParseArgs - Java library to simplify args[] handling\n * \n * Copyright (C) 2008 Roland Koller <roland@devcity.de>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 3.0 of the License, or (at your option) any later version.\n * \n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public \n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage de.devcity.parseargs.arguments;\n\npublic class Argument implements Comparable<Argument> {\n\n    int position;\n\n    public Argument(int position) {\n        this.position = position;\n    }\n\n    public int getPosition() {\n        return position;\n    }\n\n    public int compareTo(Argument arg0) {\n        return position - arg0.getPosition();\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/90_dcparseargs/src/main/java/de/devcity/parseargs/arguments/Argument.java",
		"test_prompt": "// ArgumentTest.java\npackage de.devcity.parseargs.arguments;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Argument}.\n* It contains ten unit test cases for the {@link Argument#compareTo(Argument)} method.\n*/\nclass ArgumentTest {"
	},
	{
		"original_code": "// SwitchArgument.java\n/* dcParseArgs - Java library to simplify args[] handling\n * \n * Copyright (C) 2008 Roland Koller <roland@devcity.de>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 3.0 of the License, or (at your option) any later version.\n * \n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public \n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage de.devcity.parseargs.arguments;\n\npublic class SwitchArgument extends KeyArgument {\n\n    private boolean isSet;\n\n    public SwitchArgument(int position, String key, boolean isSet) {\n        super(position, key);\n        this.isSet = isSet;\n    }\n\n    public boolean isSet() {\n        return isSet;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/90_dcparseargs/src/main/java/de/devcity/parseargs/arguments/SwitchArgument.java",
		"test_prompt": "// SwitchArgumentTest.java\npackage de.devcity.parseargs.arguments;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SwitchArgument}.\n* It contains ten unit test cases for the {@link SwitchArgument#isSet()} method.\n*/\nclass SwitchArgumentTest {"
	}
]