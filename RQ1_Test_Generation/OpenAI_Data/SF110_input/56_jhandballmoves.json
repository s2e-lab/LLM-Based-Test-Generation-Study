[
	{
		"original_code": "// Resources.java\npackage visu.handball.moves.resources;\n\nimport java.util.MissingResourceException;\nimport java.util.ResourceBundle;\nimport java.util.Scanner;\nimport java.util.regex.Pattern;\n\npublic class Resources {\n\n    //$NON-NLS-1$\n    private static final String BUNDLE_NAME = \"visu.handball.moves.resources.Resources\";\n\n    private static final ResourceBundle RESOURCE_BUNDLE = ResourceBundle.getBundle(BUNDLE_NAME);\n\n    private Resources() {\n    }\n\n    public static String getString(String key) {\n        try {\n            return RESOURCE_BUNDLE.getString(key);\n        } catch (MissingResourceException e) {\n            return '!' + key + '!';\n        }\n    }\n\n    public static String getString(String key, String[] params) {\n        try {\n            String value = RESOURCE_BUNDLE.getString(key);\n            Pattern pattern = Pattern.compile(\"\\\\{[0-9]?[0-9]\\\\}\");\n            Scanner scanner = new Scanner(value);\n            scanner.useDelimiter(pattern);\n            int index = 0;\n            StringBuffer buffer = new StringBuffer();\n            while (scanner.hasNext()) {\n                buffer.append(scanner.next());\n                buffer.append((index < params.length) ? params[index] : \"\");\n                index++;\n            }\n            return buffer.toString();\n        } catch (MissingResourceException e) {\n            return '!' + key + '!';\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/resources/ResourcesTest0.java",
		"test_prompt": "// ResourcesTest0.java\npackage visu.handball.moves.resources;\n\nimport java.util.MissingResourceException;\nimport java.util.ResourceBundle;\nimport java.util.Scanner;\nimport java.util.regex.Pattern;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Resources}.\n* It contains ten unit test cases for the {@link Resources#getString(String)} method.\n*/\nclass ResourcesTest0 {"
	},
	{
		"original_code": "// Resources.java\npackage visu.handball.moves.resources;\n\nimport java.util.MissingResourceException;\nimport java.util.ResourceBundle;\nimport java.util.Scanner;\nimport java.util.regex.Pattern;\n\npublic class Resources {\n\n    //$NON-NLS-1$\n    private static final String BUNDLE_NAME = \"visu.handball.moves.resources.Resources\";\n\n    private static final ResourceBundle RESOURCE_BUNDLE = ResourceBundle.getBundle(BUNDLE_NAME);\n\n    private Resources() {\n    }\n\n    public static String getString(String key) {\n        try {\n            return RESOURCE_BUNDLE.getString(key);\n        } catch (MissingResourceException e) {\n            return '!' + key + '!';\n        }\n    }\n\n    public static String getString(String key, String[] params) {\n        try {\n            String value = RESOURCE_BUNDLE.getString(key);\n            Pattern pattern = Pattern.compile(\"\\\\{[0-9]?[0-9]\\\\}\");\n            Scanner scanner = new Scanner(value);\n            scanner.useDelimiter(pattern);\n            int index = 0;\n            StringBuffer buffer = new StringBuffer();\n            while (scanner.hasNext()) {\n                buffer.append(scanner.next());\n                buffer.append((index < params.length) ? params[index] : \"\");\n                index++;\n            }\n            return buffer.toString();\n        } catch (MissingResourceException e) {\n            return '!' + key + '!';\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/resources/ResourcesTest1.java",
		"test_prompt": "// ResourcesTest1.java\npackage visu.handball.moves.resources;\n\nimport java.util.MissingResourceException;\nimport java.util.ResourceBundle;\nimport java.util.Scanner;\nimport java.util.regex.Pattern;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Resources}.\n* It contains ten unit test cases for the {@link Resources#getString(String, String[])} method.\n*/\nclass ResourcesTest1 {"
	},
	{
		"original_code": "// HandballModelWriter.java\n/*\r\n * Created on 03.05.2007\r\n * Created by Thomas Halm\r\n * Copyright (C) 2007 Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.xml;\r\n\r\nimport java.io.File;\r\nimport java.io.FileNotFoundException;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\nimport org.jdom.DocType;\r\nimport org.jdom.Document;\r\nimport org.jdom.Element;\r\nimport org.jdom.output.Format;\r\nimport org.jdom.output.XMLOutputter;\r\nimport visu.handball.moves.Main;\r\nimport visu.handball.moves.model.HandballModel;\r\nimport visu.handball.moves.model.MoveEvent;\r\nimport visu.handball.moves.model.PassEvent;\r\nimport visu.handball.moves.model.player.Player;\r\n\r\npublic class HandballModelWriter {\r\n\r\n    private static HandballModelWriter instance = null;\r\n\r\n    private File outputFile;\r\n\r\n    private HandballModel model;\r\n\r\n    private HandballModelWriter() {\r\n    }\r\n\r\n    private void setModel(HandballModel model) {\r\n        this.model = model;\r\n    }\r\n\r\n    private void setOutputFile(File outputFile) {\r\n        this.outputFile = outputFile;\r\n    }\r\n\r\n    public void writeToXml() {\r\n        if (outputFile == null || model == null) {\r\n            return;\r\n        }\r\n        if (outputFile.exists()) {\r\n            outputFile.delete();\r\n        }\r\n        Element root = new Element(\"jHandballMoves\");\r\n        root.setAttribute(\"version\", Main.getVersion());\r\n        Element modelElement = new Element(\"moveModel\");\r\n        modelElement.setAttribute(\"name\", model.getMoveName());\r\n        root.addContent(modelElement);\r\n        //defenders mit id speichern\r\n        savePlayers(modelElement, \"defenders\", \"defender\", model.getDefenders());\r\n        //attackers mit id speichern\r\n        savePlayers(modelElement, \"attackers\", \"attacker\", model.getOffenders());\r\n        //events speichern\r\n        List<MoveEvent> events = model.getEvents();\r\n        Element eventsElement = new Element(\"events\");\r\n        for (Iterator<MoveEvent> iter = events.iterator(); iter.hasNext(); ) {\r\n            MoveEvent event = iter.next();\r\n            Element eventElement = null;\r\n            if (event instanceof PassEvent) {\r\n                PassEvent pass = (PassEvent) event;\r\n                eventElement = new Element(\"pass\");\r\n                String receiver = null;\r\n                if (!pass.isGoalPass()) {\r\n                    receiver = String.valueOf(pass.getDestinationPlayer().hashCode());\r\n                } else {\r\n                    receiver = \"goal\";\r\n                }\r\n                eventElement.setAttribute(\"receiverId\", receiver);\r\n            } else {\r\n                eventElement = new Element(\"move\");\r\n                eventElement.setAttribute(\"controllX\", String.valueOf(event.getControlPointX()));\r\n                eventElement.setAttribute(\"controllY\", String.valueOf(event.getControlPointY()));\r\n            }\r\n            eventElement.setAttribute(\"destX\", String.valueOf(event.getDestinationX()));\r\n            eventElement.setAttribute(\"destY\", String.valueOf(event.getDestinationY()));\r\n            eventElement.setAttribute(\"sequence\", String.valueOf(event.getSequenceNr()));\r\n            eventElement.setAttribute(\"delay\", String.valueOf(event.getDelay()));\r\n            eventElement.setAttribute(\"playerId\", String.valueOf(event.getPlayer().hashCode()));\r\n            eventsElement.addContent(eventElement);\r\n        }\r\n        modelElement.addContent(eventsElement);\r\n        //firstballowner\r\n        Element ballOwnerElement = new Element(\"ballOwner\");\r\n        ballOwnerElement.setAttribute(\"playerId\", String.valueOf(model.getFirstBallOwner() != null ? model.getFirstBallOwner().hashCode() : \"none\"));\r\n        modelElement.addContent(ballOwnerElement);\r\n        //state, actualevent, ballOwner, ball brauchen nicht gespeichert werden, da initial das erste\r\n        //Event geladen werden soll (Zustand \"Bearbeiten\")\r\n        //comment speichern\r\n        Element comment = new Element(\"comment\");\r\n        comment.addContent(model.getComment());\r\n        modelElement.addContent(comment);\r\n        Document document = new Document(root);\r\n        DocType type = new DocType(\"jHandballMoves\", \"jhandballmoves.sourceforge.net\", \"jhandballmoves.dtd\");\r\n        document.setDocType(type);\r\n        XMLOutputter outputter = new XMLOutputter(Format.getPrettyFormat());\r\n        try {\r\n            outputter.output(document, new FileOutputStream(outputFile));\r\n        } catch (FileNotFoundException e) {\r\n            // TODO Auto-generated catch block\r\n            e.printStackTrace();\r\n        } catch (IOException e) {\r\n            // TODO Auto-generated catch block\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    private void savePlayers(Element parent, String listElementName, String playerElementName, List<? extends Player> players) {\r\n        Element playersElement = new Element(listElementName);\r\n        for (Iterator iter = players.iterator(); iter.hasNext(); ) {\r\n            Player player = (Player) iter.next();\r\n            Element playerElement = new Element(playerElementName);\r\n            playerElement.setAttribute(\"id\", String.valueOf(player.hashCode()));\r\n            playerElement.setAttribute(\"startX\", String.valueOf(player.getStart_x()));\r\n            playerElement.setAttribute(\"startY\", String.valueOf(player.getStart_y()));\r\n            //current muss nicht gespeichert werden da beim Laden Ausgangsposition angezeigt werden soll\r\n            playersElement.addContent(playerElement);\r\n        }\r\n        parent.addContent(playersElement);\r\n    }\r\n\r\n    public static HandballModelWriter getInstance(File outputFile, HandballModel model) {\r\n        if (instance == null) {\r\n            instance = new HandballModelWriter();\r\n        }\r\n        instance.setOutputFile(outputFile);\r\n        instance.setModel(model);\r\n        return instance;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/xml/HandballModelWriterTest.java",
		"test_prompt": "// HandballModelWriterTest.java\npackage visu.handball.moves.xml;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.jdom.DocType;\nimport org.jdom.Document;\nimport org.jdom.Element;\nimport org.jdom.output.Format;\nimport org.jdom.output.XMLOutputter;\nimport visu.handball.moves.Main;\nimport visu.handball.moves.model.HandballModel;\nimport visu.handball.moves.model.MoveEvent;\nimport visu.handball.moves.model.PassEvent;\nimport visu.handball.moves.model.player.Player;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HandballModelWriter}.\n* It contains ten unit test cases for the {@link HandballModelWriter#getInstance(File, HandballModel)} method.\n*/\nclass HandballModelWriterTest {"
	},
	{
		"original_code": "// HandballModelReader.java\n/*\r\n * Created on 03.05.2007\r\n * Created by Thomas Halm\r\n * Copyright (C) 2007 Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.xml;\r\n\r\nimport java.io.File;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.util.HashMap;\r\nimport java.util.Iterator;\r\nimport java.util.Map;\r\nimport javax.swing.JOptionPane;\r\nimport org.jdom.Document;\r\nimport org.jdom.Element;\r\nimport org.jdom.input.SAXBuilder;\r\nimport org.xml.sax.EntityResolver;\r\nimport org.xml.sax.InputSource;\r\nimport org.xml.sax.SAXException;\r\nimport visu.handball.moves.Main;\r\nimport visu.handball.moves.model.HandballModel;\r\nimport visu.handball.moves.model.MoveEvent;\r\nimport visu.handball.moves.model.PassEvent;\r\nimport visu.handball.moves.model.player.Defender;\r\nimport visu.handball.moves.model.player.Offender;\r\nimport visu.handball.moves.model.player.Player;\r\n\r\npublic class HandballModelReader {\r\n\r\n    private static HandballModelReader instance = null;\r\n\r\n    private InputStream inputStream;\r\n\r\n    private File inputFile;\r\n\r\n    private HandballModelReader() {\r\n    }\r\n\r\n    public static HandballModelReader getInstance(File inputFile) {\r\n        if (instance == null) {\r\n            instance = new HandballModelReader();\r\n        }\r\n        instance.setInputFile(inputFile);\r\n        instance.setInputStream(null);\r\n        return instance;\r\n    }\r\n\r\n    public static HandballModelReader getInstance(InputStream inputStream) {\r\n        if (instance == null) {\r\n            instance = new HandballModelReader();\r\n        }\r\n        instance.setInputStream(inputStream);\r\n        instance.setInputFile(null);\r\n        return instance;\r\n    }\r\n\r\n    public File getInputFile() {\r\n        return inputFile;\r\n    }\r\n\r\n    public void setInputFile(File inputFile) {\r\n        this.inputFile = inputFile;\r\n    }\r\n\r\n    public HandballModel readFromXml() {\r\n        HandballModel model = new HandballModel();\r\n        model.initModel();\r\n        Document doc = null;\r\n        SAXBuilder sb = new SAXBuilder();\r\n        sb.setEntityResolver(new EntityResolver() {\r\n\r\n            public InputSource resolveEntity(String publicId, String systemId) throws SAXException, IOException {\r\n                if (publicId.equals(\"jhandballmoves.sourceforge.net\")) {\r\n                    return new InputSource(Main.getResource(\"xml/dtd/jhandballmoves.dtd\").openStream());\r\n                }\r\n                return null;\r\n            }\r\n        });\r\n        sb.setValidation(true);\r\n        try {\r\n            if (inputStream != null) {\r\n                doc = sb.build(inputStream);\r\n            } else {\r\n                doc = sb.build(inputFile);\r\n            }\r\n        } catch (Exception e) {\r\n            JOptionPane.showMessageDialog(Main.getWindow(), \"Fehler beim Laden der XML-Datei\\n\" + e.getLocalizedMessage(), \"Laden fehlgeschlagen\", JOptionPane.ERROR_MESSAGE);\r\n        }\r\n        if (doc != null) {\r\n            Element root = doc.getRootElement();\r\n            // TODO Versions-Test z.B. >= 1.0.5\r\n            Element moveModel = root.getChild(\"moveModel\");\r\n            model.setMoveName(moveModel.getAttributeValue(\"name\"));\r\n            Map<String, Player> map = new HashMap<String, Player>();\r\n            // Defenders laden\r\n            Element defenders = moveModel.getChild(\"defenders\");\r\n            for (Iterator iter = defenders.getChildren(\"defender\").iterator(); iter.hasNext(); ) {\r\n                Element element = (Element) iter.next();\r\n                int startX = Integer.valueOf(element.getAttributeValue(\"startX\"));\r\n                int startY = Integer.valueOf(element.getAttributeValue(\"startY\"));\r\n                Defender def = new Defender(startX, startY);\r\n                map.put(element.getAttributeValue(\"id\"), def);\r\n                model.getDefenders().add(def);\r\n            }\r\n            // Attackers laden\r\n            Element attackers = moveModel.getChild(\"attackers\");\r\n            for (Iterator iter = attackers.getChildren(\"attacker\").iterator(); iter.hasNext(); ) {\r\n                Element element = (Element) iter.next();\r\n                int startX = Integer.valueOf(element.getAttributeValue(\"startX\"));\r\n                int startY = Integer.valueOf(element.getAttributeValue(\"startY\"));\r\n                Offender attacker = new Offender(startX, startY);\r\n                map.put(element.getAttributeValue(\"id\"), attacker);\r\n                model.getOffenders().add(attacker);\r\n            }\r\n            // Events laden\r\n            Element events = moveModel.getChild(\"events\");\r\n            for (Iterator iter = events.getChildren().iterator(); iter.hasNext(); ) {\r\n                Element element = (Element) iter.next();\r\n                Player player = map.get(element.getAttributeValue(\"playerId\"));\r\n                int seq = Integer.valueOf(element.getAttributeValue(\"sequence\"));\r\n                int delay = Integer.valueOf(element.getAttributeValue(\"delay\"));\r\n                MoveEvent event = null;\r\n                if (element.getName().equals(\"pass\")) {\r\n                    // Passevent laden\r\n                    event = new PassEvent(player, seq, delay);\r\n                    if (element.getAttributeValue(\"receiverId\").equals(\"goal\")) {\r\n                        ((PassEvent) event).setGoalPass(true);\r\n                    } else {\r\n                        Offender off = (Offender) map.get(element.getAttributeValue(\"receiverId\"));\r\n                        ((PassEvent) event).setDestinationPlayer(off, false);\r\n                        event.setDestinationPoint(off.getCurrent_x(), off.getCurrent_y(), false);\r\n                    }\r\n                } else if (element.getName().equals(\"move\")) {\r\n                    // Laufevent laden\r\n                    event = new MoveEvent(player, seq, delay);\r\n                    int controlX = Integer.valueOf(element.getAttributeValue(\"controllX\"));\r\n                    int controlY = Integer.valueOf(element.getAttributeValue(\"controllY\"));\r\n                    event.setControlPoint(controlX, controlY, false);\r\n                }\r\n                int destX = Integer.valueOf(element.getAttributeValue(\"destX\"));\r\n                int destY = Integer.valueOf(element.getAttributeValue(\"destY\"));\r\n                event.setDestinationPoint(destX, destY, false);\r\n                model.addMoveEvent(event);\r\n            }\r\n            Element firstOwner = moveModel.getChild(\"ballOwner\");\r\n            if (!firstOwner.getAttributeValue(\"playerId\").equals(\"none\")) {\r\n                model.setFirstBallOwner((Offender) map.get(firstOwner.getAttributeValue(\"playerId\")));\r\n            }\r\n            Element comment = moveModel.getChild(\"comment\");\r\n            model.setComment(comment.getText());\r\n            model.setState(HandballModel.State.EDIT);\r\n            if (model.getEvents().size() > 0) {\r\n                model.setActualMoveEvent(model.getEvents().get(0));\r\n            }\r\n        }\r\n        return model;\r\n    }\r\n\r\n    public InputStream getInputStream() {\r\n        return inputStream;\r\n    }\r\n\r\n    public void setInputStream(InputStream inputStream) {\r\n        this.inputStream = inputStream;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/xml/HandballModelReaderTest0.java",
		"test_prompt": "// HandballModelReaderTest0.java\npackage visu.handball.moves.xml;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport javax.swing.JOptionPane;\nimport org.jdom.Document;\nimport org.jdom.Element;\nimport org.jdom.input.SAXBuilder;\nimport org.xml.sax.EntityResolver;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport visu.handball.moves.Main;\nimport visu.handball.moves.model.HandballModel;\nimport visu.handball.moves.model.MoveEvent;\nimport visu.handball.moves.model.PassEvent;\nimport visu.handball.moves.model.player.Defender;\nimport visu.handball.moves.model.player.Offender;\nimport visu.handball.moves.model.player.Player;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HandballModelReader}.\n* It contains ten unit test cases for the {@link HandballModelReader#getInstance(File)} method.\n*/\nclass HandballModelReaderTest0 {"
	},
	{
		"original_code": "// HandballModelReader.java\n/*\r\n * Created on 03.05.2007\r\n * Created by Thomas Halm\r\n * Copyright (C) 2007 Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.xml;\r\n\r\nimport java.io.File;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.util.HashMap;\r\nimport java.util.Iterator;\r\nimport java.util.Map;\r\nimport javax.swing.JOptionPane;\r\nimport org.jdom.Document;\r\nimport org.jdom.Element;\r\nimport org.jdom.input.SAXBuilder;\r\nimport org.xml.sax.EntityResolver;\r\nimport org.xml.sax.InputSource;\r\nimport org.xml.sax.SAXException;\r\nimport visu.handball.moves.Main;\r\nimport visu.handball.moves.model.HandballModel;\r\nimport visu.handball.moves.model.MoveEvent;\r\nimport visu.handball.moves.model.PassEvent;\r\nimport visu.handball.moves.model.player.Defender;\r\nimport visu.handball.moves.model.player.Offender;\r\nimport visu.handball.moves.model.player.Player;\r\n\r\npublic class HandballModelReader {\r\n\r\n    private static HandballModelReader instance = null;\r\n\r\n    private InputStream inputStream;\r\n\r\n    private File inputFile;\r\n\r\n    private HandballModelReader() {\r\n    }\r\n\r\n    public static HandballModelReader getInstance(File inputFile) {\r\n        if (instance == null) {\r\n            instance = new HandballModelReader();\r\n        }\r\n        instance.setInputFile(inputFile);\r\n        instance.setInputStream(null);\r\n        return instance;\r\n    }\r\n\r\n    public static HandballModelReader getInstance(InputStream inputStream) {\r\n        if (instance == null) {\r\n            instance = new HandballModelReader();\r\n        }\r\n        instance.setInputStream(inputStream);\r\n        instance.setInputFile(null);\r\n        return instance;\r\n    }\r\n\r\n    public File getInputFile() {\r\n        return inputFile;\r\n    }\r\n\r\n    public void setInputFile(File inputFile) {\r\n        this.inputFile = inputFile;\r\n    }\r\n\r\n    public HandballModel readFromXml() {\r\n        HandballModel model = new HandballModel();\r\n        model.initModel();\r\n        Document doc = null;\r\n        SAXBuilder sb = new SAXBuilder();\r\n        sb.setEntityResolver(new EntityResolver() {\r\n\r\n            public InputSource resolveEntity(String publicId, String systemId) throws SAXException, IOException {\r\n                if (publicId.equals(\"jhandballmoves.sourceforge.net\")) {\r\n                    return new InputSource(Main.getResource(\"xml/dtd/jhandballmoves.dtd\").openStream());\r\n                }\r\n                return null;\r\n            }\r\n        });\r\n        sb.setValidation(true);\r\n        try {\r\n            if (inputStream != null) {\r\n                doc = sb.build(inputStream);\r\n            } else {\r\n                doc = sb.build(inputFile);\r\n            }\r\n        } catch (Exception e) {\r\n            JOptionPane.showMessageDialog(Main.getWindow(), \"Fehler beim Laden der XML-Datei\\n\" + e.getLocalizedMessage(), \"Laden fehlgeschlagen\", JOptionPane.ERROR_MESSAGE);\r\n        }\r\n        if (doc != null) {\r\n            Element root = doc.getRootElement();\r\n            // TODO Versions-Test z.B. >= 1.0.5\r\n            Element moveModel = root.getChild(\"moveModel\");\r\n            model.setMoveName(moveModel.getAttributeValue(\"name\"));\r\n            Map<String, Player> map = new HashMap<String, Player>();\r\n            // Defenders laden\r\n            Element defenders = moveModel.getChild(\"defenders\");\r\n            for (Iterator iter = defenders.getChildren(\"defender\").iterator(); iter.hasNext(); ) {\r\n                Element element = (Element) iter.next();\r\n                int startX = Integer.valueOf(element.getAttributeValue(\"startX\"));\r\n                int startY = Integer.valueOf(element.getAttributeValue(\"startY\"));\r\n                Defender def = new Defender(startX, startY);\r\n                map.put(element.getAttributeValue(\"id\"), def);\r\n                model.getDefenders().add(def);\r\n            }\r\n            // Attackers laden\r\n            Element attackers = moveModel.getChild(\"attackers\");\r\n            for (Iterator iter = attackers.getChildren(\"attacker\").iterator(); iter.hasNext(); ) {\r\n                Element element = (Element) iter.next();\r\n                int startX = Integer.valueOf(element.getAttributeValue(\"startX\"));\r\n                int startY = Integer.valueOf(element.getAttributeValue(\"startY\"));\r\n                Offender attacker = new Offender(startX, startY);\r\n                map.put(element.getAttributeValue(\"id\"), attacker);\r\n                model.getOffenders().add(attacker);\r\n            }\r\n            // Events laden\r\n            Element events = moveModel.getChild(\"events\");\r\n            for (Iterator iter = events.getChildren().iterator(); iter.hasNext(); ) {\r\n                Element element = (Element) iter.next();\r\n                Player player = map.get(element.getAttributeValue(\"playerId\"));\r\n                int seq = Integer.valueOf(element.getAttributeValue(\"sequence\"));\r\n                int delay = Integer.valueOf(element.getAttributeValue(\"delay\"));\r\n                MoveEvent event = null;\r\n                if (element.getName().equals(\"pass\")) {\r\n                    // Passevent laden\r\n                    event = new PassEvent(player, seq, delay);\r\n                    if (element.getAttributeValue(\"receiverId\").equals(\"goal\")) {\r\n                        ((PassEvent) event).setGoalPass(true);\r\n                    } else {\r\n                        Offender off = (Offender) map.get(element.getAttributeValue(\"receiverId\"));\r\n                        ((PassEvent) event).setDestinationPlayer(off, false);\r\n                        event.setDestinationPoint(off.getCurrent_x(), off.getCurrent_y(), false);\r\n                    }\r\n                } else if (element.getName().equals(\"move\")) {\r\n                    // Laufevent laden\r\n                    event = new MoveEvent(player, seq, delay);\r\n                    int controlX = Integer.valueOf(element.getAttributeValue(\"controllX\"));\r\n                    int controlY = Integer.valueOf(element.getAttributeValue(\"controllY\"));\r\n                    event.setControlPoint(controlX, controlY, false);\r\n                }\r\n                int destX = Integer.valueOf(element.getAttributeValue(\"destX\"));\r\n                int destY = Integer.valueOf(element.getAttributeValue(\"destY\"));\r\n                event.setDestinationPoint(destX, destY, false);\r\n                model.addMoveEvent(event);\r\n            }\r\n            Element firstOwner = moveModel.getChild(\"ballOwner\");\r\n            if (!firstOwner.getAttributeValue(\"playerId\").equals(\"none\")) {\r\n                model.setFirstBallOwner((Offender) map.get(firstOwner.getAttributeValue(\"playerId\")));\r\n            }\r\n            Element comment = moveModel.getChild(\"comment\");\r\n            model.setComment(comment.getText());\r\n            model.setState(HandballModel.State.EDIT);\r\n            if (model.getEvents().size() > 0) {\r\n                model.setActualMoveEvent(model.getEvents().get(0));\r\n            }\r\n        }\r\n        return model;\r\n    }\r\n\r\n    public InputStream getInputStream() {\r\n        return inputStream;\r\n    }\r\n\r\n    public void setInputStream(InputStream inputStream) {\r\n        this.inputStream = inputStream;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/xml/HandballModelReaderTest1.java",
		"test_prompt": "// HandballModelReaderTest1.java\npackage visu.handball.moves.xml;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport javax.swing.JOptionPane;\nimport org.jdom.Document;\nimport org.jdom.Element;\nimport org.jdom.input.SAXBuilder;\nimport org.xml.sax.EntityResolver;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport visu.handball.moves.Main;\nimport visu.handball.moves.model.HandballModel;\nimport visu.handball.moves.model.MoveEvent;\nimport visu.handball.moves.model.PassEvent;\nimport visu.handball.moves.model.player.Defender;\nimport visu.handball.moves.model.player.Offender;\nimport visu.handball.moves.model.player.Player;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HandballModelReader}.\n* It contains ten unit test cases for the {@link HandballModelReader#getInstance(InputStream)} method.\n*/\nclass HandballModelReaderTest1 {"
	},
	{
		"original_code": "// HandballModelReader.java\n/*\r\n * Created on 03.05.2007\r\n * Created by Thomas Halm\r\n * Copyright (C) 2007 Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.xml;\r\n\r\nimport java.io.File;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.util.HashMap;\r\nimport java.util.Iterator;\r\nimport java.util.Map;\r\nimport javax.swing.JOptionPane;\r\nimport org.jdom.Document;\r\nimport org.jdom.Element;\r\nimport org.jdom.input.SAXBuilder;\r\nimport org.xml.sax.EntityResolver;\r\nimport org.xml.sax.InputSource;\r\nimport org.xml.sax.SAXException;\r\nimport visu.handball.moves.Main;\r\nimport visu.handball.moves.model.HandballModel;\r\nimport visu.handball.moves.model.MoveEvent;\r\nimport visu.handball.moves.model.PassEvent;\r\nimport visu.handball.moves.model.player.Defender;\r\nimport visu.handball.moves.model.player.Offender;\r\nimport visu.handball.moves.model.player.Player;\r\n\r\npublic class HandballModelReader {\r\n\r\n    private static HandballModelReader instance = null;\r\n\r\n    private InputStream inputStream;\r\n\r\n    private File inputFile;\r\n\r\n    private HandballModelReader() {\r\n    }\r\n\r\n    public static HandballModelReader getInstance(File inputFile) {\r\n        if (instance == null) {\r\n            instance = new HandballModelReader();\r\n        }\r\n        instance.setInputFile(inputFile);\r\n        instance.setInputStream(null);\r\n        return instance;\r\n    }\r\n\r\n    public static HandballModelReader getInstance(InputStream inputStream) {\r\n        if (instance == null) {\r\n            instance = new HandballModelReader();\r\n        }\r\n        instance.setInputStream(inputStream);\r\n        instance.setInputFile(null);\r\n        return instance;\r\n    }\r\n\r\n    public File getInputFile() {\r\n        return inputFile;\r\n    }\r\n\r\n    public void setInputFile(File inputFile) {\r\n        this.inputFile = inputFile;\r\n    }\r\n\r\n    public HandballModel readFromXml() {\r\n        HandballModel model = new HandballModel();\r\n        model.initModel();\r\n        Document doc = null;\r\n        SAXBuilder sb = new SAXBuilder();\r\n        sb.setEntityResolver(new EntityResolver() {\r\n\r\n            public InputSource resolveEntity(String publicId, String systemId) throws SAXException, IOException {\r\n                if (publicId.equals(\"jhandballmoves.sourceforge.net\")) {\r\n                    return new InputSource(Main.getResource(\"xml/dtd/jhandballmoves.dtd\").openStream());\r\n                }\r\n                return null;\r\n            }\r\n        });\r\n        sb.setValidation(true);\r\n        try {\r\n            if (inputStream != null) {\r\n                doc = sb.build(inputStream);\r\n            } else {\r\n                doc = sb.build(inputFile);\r\n            }\r\n        } catch (Exception e) {\r\n            JOptionPane.showMessageDialog(Main.getWindow(), \"Fehler beim Laden der XML-Datei\\n\" + e.getLocalizedMessage(), \"Laden fehlgeschlagen\", JOptionPane.ERROR_MESSAGE);\r\n        }\r\n        if (doc != null) {\r\n            Element root = doc.getRootElement();\r\n            // TODO Versions-Test z.B. >= 1.0.5\r\n            Element moveModel = root.getChild(\"moveModel\");\r\n            model.setMoveName(moveModel.getAttributeValue(\"name\"));\r\n            Map<String, Player> map = new HashMap<String, Player>();\r\n            // Defenders laden\r\n            Element defenders = moveModel.getChild(\"defenders\");\r\n            for (Iterator iter = defenders.getChildren(\"defender\").iterator(); iter.hasNext(); ) {\r\n                Element element = (Element) iter.next();\r\n                int startX = Integer.valueOf(element.getAttributeValue(\"startX\"));\r\n                int startY = Integer.valueOf(element.getAttributeValue(\"startY\"));\r\n                Defender def = new Defender(startX, startY);\r\n                map.put(element.getAttributeValue(\"id\"), def);\r\n                model.getDefenders().add(def);\r\n            }\r\n            // Attackers laden\r\n            Element attackers = moveModel.getChild(\"attackers\");\r\n            for (Iterator iter = attackers.getChildren(\"attacker\").iterator(); iter.hasNext(); ) {\r\n                Element element = (Element) iter.next();\r\n                int startX = Integer.valueOf(element.getAttributeValue(\"startX\"));\r\n                int startY = Integer.valueOf(element.getAttributeValue(\"startY\"));\r\n                Offender attacker = new Offender(startX, startY);\r\n                map.put(element.getAttributeValue(\"id\"), attacker);\r\n                model.getOffenders().add(attacker);\r\n            }\r\n            // Events laden\r\n            Element events = moveModel.getChild(\"events\");\r\n            for (Iterator iter = events.getChildren().iterator(); iter.hasNext(); ) {\r\n                Element element = (Element) iter.next();\r\n                Player player = map.get(element.getAttributeValue(\"playerId\"));\r\n                int seq = Integer.valueOf(element.getAttributeValue(\"sequence\"));\r\n                int delay = Integer.valueOf(element.getAttributeValue(\"delay\"));\r\n                MoveEvent event = null;\r\n                if (element.getName().equals(\"pass\")) {\r\n                    // Passevent laden\r\n                    event = new PassEvent(player, seq, delay);\r\n                    if (element.getAttributeValue(\"receiverId\").equals(\"goal\")) {\r\n                        ((PassEvent) event).setGoalPass(true);\r\n                    } else {\r\n                        Offender off = (Offender) map.get(element.getAttributeValue(\"receiverId\"));\r\n                        ((PassEvent) event).setDestinationPlayer(off, false);\r\n                        event.setDestinationPoint(off.getCurrent_x(), off.getCurrent_y(), false);\r\n                    }\r\n                } else if (element.getName().equals(\"move\")) {\r\n                    // Laufevent laden\r\n                    event = new MoveEvent(player, seq, delay);\r\n                    int controlX = Integer.valueOf(element.getAttributeValue(\"controllX\"));\r\n                    int controlY = Integer.valueOf(element.getAttributeValue(\"controllY\"));\r\n                    event.setControlPoint(controlX, controlY, false);\r\n                }\r\n                int destX = Integer.valueOf(element.getAttributeValue(\"destX\"));\r\n                int destY = Integer.valueOf(element.getAttributeValue(\"destY\"));\r\n                event.setDestinationPoint(destX, destY, false);\r\n                model.addMoveEvent(event);\r\n            }\r\n            Element firstOwner = moveModel.getChild(\"ballOwner\");\r\n            if (!firstOwner.getAttributeValue(\"playerId\").equals(\"none\")) {\r\n                model.setFirstBallOwner((Offender) map.get(firstOwner.getAttributeValue(\"playerId\")));\r\n            }\r\n            Element comment = moveModel.getChild(\"comment\");\r\n            model.setComment(comment.getText());\r\n            model.setState(HandballModel.State.EDIT);\r\n            if (model.getEvents().size() > 0) {\r\n                model.setActualMoveEvent(model.getEvents().get(0));\r\n            }\r\n        }\r\n        return model;\r\n    }\r\n\r\n    public InputStream getInputStream() {\r\n        return inputStream;\r\n    }\r\n\r\n    public void setInputStream(InputStream inputStream) {\r\n        this.inputStream = inputStream;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/xml/HandballModelReaderTest2.java",
		"test_prompt": "// HandballModelReaderTest2.java\npackage visu.handball.moves.xml;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport javax.swing.JOptionPane;\nimport org.jdom.Document;\nimport org.jdom.Element;\nimport org.jdom.input.SAXBuilder;\nimport org.xml.sax.EntityResolver;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport visu.handball.moves.Main;\nimport visu.handball.moves.model.HandballModel;\nimport visu.handball.moves.model.MoveEvent;\nimport visu.handball.moves.model.PassEvent;\nimport visu.handball.moves.model.player.Defender;\nimport visu.handball.moves.model.player.Offender;\nimport visu.handball.moves.model.player.Player;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HandballModelReader}.\n* It contains ten unit test cases for the {@link HandballModelReader#readFromXml()} method.\n*/\nclass HandballModelReaderTest2 {"
	},
	{
		"original_code": "// HandballFileFilter.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.controller;\r\n\r\nimport java.io.File;\r\nimport javax.swing.filechooser.FileFilter;\r\n\r\npublic class HandballFileFilter extends FileFilter {\r\n\r\n    public static final String EXTENSION_SERIALISATION = \".hbf\";\r\n\r\n    public static final String EXTENSION_XML = \".xml\";\r\n\r\n    public boolean accept(File f) {\r\n        return f.isDirectory() || f.getName().toLowerCase().endsWith(EXTENSION_SERIALISATION) || f.getName().toLowerCase().endsWith(EXTENSION_XML);\r\n    }\r\n\r\n    public String getDescription() {\r\n        return \"Handball-Dateien\";\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/controller/HandballFileFilterTest.java",
		"test_prompt": "// HandballFileFilterTest.java\npackage visu.handball.moves.controller;\n\nimport java.io.File;\nimport javax.swing.filechooser.FileFilter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HandballFileFilter}.\n* It contains ten unit test cases for the {@link HandballFileFilter#accept(File)} method.\n*/\nclass HandballFileFilterTest {"
	},
	{
		"original_code": "// JMenuHelper.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.controller;\r\n\r\nimport java.awt.event.*;\r\nimport javax.swing.*;\r\n\r\npublic class JMenuHelper {\r\n\r\n    /**\r\n     * Add an element to the menubar.\r\n     *\r\n     * @param menuBar a JMenuBar\r\n     * @param s a String\r\n     *\r\n     * @return added JMenu\r\n     */\r\n    public static JMenu addMenuBarItem(JMenuBar menuBar, String s) {\r\n        JMenu menu;\r\n        /**\r\n         * Suche nach '_' und nimm das nächste Zeichen als Mnemonic,\r\n         * sonst: normales Menu\r\n         */\r\n        if (s.indexOf(\"_\") > -1) {\r\n            int pos = s.indexOf(\"_\");\r\n            char c = s.charAt(pos + 1);\r\n            StringBuffer sb = new StringBuffer(s).delete(pos, pos + 1);\r\n            menu = new JMenu(sb.toString());\r\n            menu.setMnemonic(c);\r\n        } else\r\n            menu = new JMenu(s);\r\n        menuBar.add(menu);\r\n        return menu;\r\n    }\r\n\r\n    private static JMenuItem processAction(Action a) {\r\n        if (a != null) {\r\n            return new JMenuItem(a);\r\n        } else {\r\n            return new JMenuItem();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Setze das Zeichen nach '_' als Mnemonic des MenuItems\r\n     * @param s\r\n     */\r\n    private static void processMnemonic(JMenuItem menuItem, String s) {\r\n        if (s.indexOf(\"_\") > -1) {\r\n            int pos = s.indexOf(\"_\");\r\n            char c = s.charAt(pos + 1);\r\n            StringBuffer sb = new StringBuffer(s).delete(pos, pos + 1);\r\n            menuItem.setName(sb.toString());\r\n            menuItem.setMnemonic(c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Insert a JMenuItem to a given JMenu.\r\n     *\r\n     * @param m\r\n     *            a JMenu\r\n     * @param s\r\n     *            a String\r\n     * @param keyChar\r\n     *            a char\r\n     * @param al\r\n     *            an ActionListener\r\n     *\r\n     * @return a JMenuItem\r\n     */\r\n    public static JMenuItem addMenuItem(JMenu m, String s, char keyChar, Action a, ActionListener al) {\r\n        if (s.startsWith(\"-\")) {\r\n            m.addSeparator();\r\n            return null;\r\n        }\r\n        JMenuItem menuItem = processAction(a);\r\n        processMnemonic(menuItem, s);\r\n        //füge den Short-Cut hinzu\r\n        if (keyChar != 0)\r\n            menuItem.setAccelerator(KeyStroke.getKeyStroke(keyChar, InputEvent.CTRL_MASK));\r\n        //Actionslistener anmelden\r\n        if (al != null)\r\n            menuItem.addActionListener(al);\r\n        //dem Menu hinzufügen\r\n        m.add(menuItem);\r\n        return menuItem;\r\n    }\r\n\r\n    public static JMenuItem addMenuItem(JMenu m, String s, char c) {\r\n        return addMenuItem(m, s, c, null, null);\r\n    }\r\n\r\n    public static JMenuItem addMenuItem(JMenu m, String s) {\r\n        return addMenuItem(m, s, (char) 0, null, null);\r\n    }\r\n\r\n    public static JMenuItem addMenuItem(JMenu m, String s, ActionListener al) {\r\n        return addMenuItem(m, s, (char) 0, null, al);\r\n    }\r\n\r\n    public static JMenuItem addMenuItem(JMenu m, String s, Action a) {\r\n        return addMenuItem(m, s, (char) 0, a, null);\r\n    }\r\n\r\n    public static JMenuItem addMenuItem(JMenu m, String s, char c, Action a) {\r\n        return addMenuItem(m, s, c, a, null);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/controller/JMenuHelperTest0.java",
		"test_prompt": "// JMenuHelperTest0.java\npackage visu.handball.moves.controller;\n\nimport java.awt.event.*;\nimport javax.swing.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JMenuHelper}.\n* It contains ten unit test cases for the {@link JMenuHelper#addMenuBarItem(JMenuBar, String)} method.\n*/\nclass JMenuHelperTest0 {"
	},
	{
		"original_code": "// JMenuHelper.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.controller;\r\n\r\nimport java.awt.event.*;\r\nimport javax.swing.*;\r\n\r\npublic class JMenuHelper {\r\n\r\n    /**\r\n     * Add an element to the menubar.\r\n     *\r\n     * @param menuBar a JMenuBar\r\n     * @param s a String\r\n     *\r\n     * @return added JMenu\r\n     */\r\n    public static JMenu addMenuBarItem(JMenuBar menuBar, String s) {\r\n        JMenu menu;\r\n        /**\r\n         * Suche nach '_' und nimm das nächste Zeichen als Mnemonic,\r\n         * sonst: normales Menu\r\n         */\r\n        if (s.indexOf(\"_\") > -1) {\r\n            int pos = s.indexOf(\"_\");\r\n            char c = s.charAt(pos + 1);\r\n            StringBuffer sb = new StringBuffer(s).delete(pos, pos + 1);\r\n            menu = new JMenu(sb.toString());\r\n            menu.setMnemonic(c);\r\n        } else\r\n            menu = new JMenu(s);\r\n        menuBar.add(menu);\r\n        return menu;\r\n    }\r\n\r\n    private static JMenuItem processAction(Action a) {\r\n        if (a != null) {\r\n            return new JMenuItem(a);\r\n        } else {\r\n            return new JMenuItem();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Setze das Zeichen nach '_' als Mnemonic des MenuItems\r\n     * @param s\r\n     */\r\n    private static void processMnemonic(JMenuItem menuItem, String s) {\r\n        if (s.indexOf(\"_\") > -1) {\r\n            int pos = s.indexOf(\"_\");\r\n            char c = s.charAt(pos + 1);\r\n            StringBuffer sb = new StringBuffer(s).delete(pos, pos + 1);\r\n            menuItem.setName(sb.toString());\r\n            menuItem.setMnemonic(c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Insert a JMenuItem to a given JMenu.\r\n     *\r\n     * @param m\r\n     *            a JMenu\r\n     * @param s\r\n     *            a String\r\n     * @param keyChar\r\n     *            a char\r\n     * @param al\r\n     *            an ActionListener\r\n     *\r\n     * @return a JMenuItem\r\n     */\r\n    public static JMenuItem addMenuItem(JMenu m, String s, char keyChar, Action a, ActionListener al) {\r\n        if (s.startsWith(\"-\")) {\r\n            m.addSeparator();\r\n            return null;\r\n        }\r\n        JMenuItem menuItem = processAction(a);\r\n        processMnemonic(menuItem, s);\r\n        //füge den Short-Cut hinzu\r\n        if (keyChar != 0)\r\n            menuItem.setAccelerator(KeyStroke.getKeyStroke(keyChar, InputEvent.CTRL_MASK));\r\n        //Actionslistener anmelden\r\n        if (al != null)\r\n            menuItem.addActionListener(al);\r\n        //dem Menu hinzufügen\r\n        m.add(menuItem);\r\n        return menuItem;\r\n    }\r\n\r\n    public static JMenuItem addMenuItem(JMenu m, String s, char c) {\r\n        return addMenuItem(m, s, c, null, null);\r\n    }\r\n\r\n    public static JMenuItem addMenuItem(JMenu m, String s) {\r\n        return addMenuItem(m, s, (char) 0, null, null);\r\n    }\r\n\r\n    public static JMenuItem addMenuItem(JMenu m, String s, ActionListener al) {\r\n        return addMenuItem(m, s, (char) 0, null, al);\r\n    }\r\n\r\n    public static JMenuItem addMenuItem(JMenu m, String s, Action a) {\r\n        return addMenuItem(m, s, (char) 0, a, null);\r\n    }\r\n\r\n    public static JMenuItem addMenuItem(JMenu m, String s, char c, Action a) {\r\n        return addMenuItem(m, s, c, a, null);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/controller/JMenuHelperTest1.java",
		"test_prompt": "// JMenuHelperTest1.java\npackage visu.handball.moves.controller;\n\nimport java.awt.event.*;\nimport javax.swing.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JMenuHelper}.\n* It contains ten unit test cases for the {@link JMenuHelper#addMenuItem(JMenu, String, char, Action, ActionListener)} method.\n*/\nclass JMenuHelperTest1 {"
	},
	{
		"original_code": "// JMenuHelper.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.controller;\r\n\r\nimport java.awt.event.*;\r\nimport javax.swing.*;\r\n\r\npublic class JMenuHelper {\r\n\r\n    /**\r\n     * Add an element to the menubar.\r\n     *\r\n     * @param menuBar a JMenuBar\r\n     * @param s a String\r\n     *\r\n     * @return added JMenu\r\n     */\r\n    public static JMenu addMenuBarItem(JMenuBar menuBar, String s) {\r\n        JMenu menu;\r\n        /**\r\n         * Suche nach '_' und nimm das nächste Zeichen als Mnemonic,\r\n         * sonst: normales Menu\r\n         */\r\n        if (s.indexOf(\"_\") > -1) {\r\n            int pos = s.indexOf(\"_\");\r\n            char c = s.charAt(pos + 1);\r\n            StringBuffer sb = new StringBuffer(s).delete(pos, pos + 1);\r\n            menu = new JMenu(sb.toString());\r\n            menu.setMnemonic(c);\r\n        } else\r\n            menu = new JMenu(s);\r\n        menuBar.add(menu);\r\n        return menu;\r\n    }\r\n\r\n    private static JMenuItem processAction(Action a) {\r\n        if (a != null) {\r\n            return new JMenuItem(a);\r\n        } else {\r\n            return new JMenuItem();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Setze das Zeichen nach '_' als Mnemonic des MenuItems\r\n     * @param s\r\n     */\r\n    private static void processMnemonic(JMenuItem menuItem, String s) {\r\n        if (s.indexOf(\"_\") > -1) {\r\n            int pos = s.indexOf(\"_\");\r\n            char c = s.charAt(pos + 1);\r\n            StringBuffer sb = new StringBuffer(s).delete(pos, pos + 1);\r\n            menuItem.setName(sb.toString());\r\n            menuItem.setMnemonic(c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Insert a JMenuItem to a given JMenu.\r\n     *\r\n     * @param m\r\n     *            a JMenu\r\n     * @param s\r\n     *            a String\r\n     * @param keyChar\r\n     *            a char\r\n     * @param al\r\n     *            an ActionListener\r\n     *\r\n     * @return a JMenuItem\r\n     */\r\n    public static JMenuItem addMenuItem(JMenu m, String s, char keyChar, Action a, ActionListener al) {\r\n        if (s.startsWith(\"-\")) {\r\n            m.addSeparator();\r\n            return null;\r\n        }\r\n        JMenuItem menuItem = processAction(a);\r\n        processMnemonic(menuItem, s);\r\n        //füge den Short-Cut hinzu\r\n        if (keyChar != 0)\r\n            menuItem.setAccelerator(KeyStroke.getKeyStroke(keyChar, InputEvent.CTRL_MASK));\r\n        //Actionslistener anmelden\r\n        if (al != null)\r\n            menuItem.addActionListener(al);\r\n        //dem Menu hinzufügen\r\n        m.add(menuItem);\r\n        return menuItem;\r\n    }\r\n\r\n    public static JMenuItem addMenuItem(JMenu m, String s, char c) {\r\n        return addMenuItem(m, s, c, null, null);\r\n    }\r\n\r\n    public static JMenuItem addMenuItem(JMenu m, String s) {\r\n        return addMenuItem(m, s, (char) 0, null, null);\r\n    }\r\n\r\n    public static JMenuItem addMenuItem(JMenu m, String s, ActionListener al) {\r\n        return addMenuItem(m, s, (char) 0, null, al);\r\n    }\r\n\r\n    public static JMenuItem addMenuItem(JMenu m, String s, Action a) {\r\n        return addMenuItem(m, s, (char) 0, a, null);\r\n    }\r\n\r\n    public static JMenuItem addMenuItem(JMenu m, String s, char c, Action a) {\r\n        return addMenuItem(m, s, c, a, null);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/controller/JMenuHelperTest2.java",
		"test_prompt": "// JMenuHelperTest2.java\npackage visu.handball.moves.controller;\n\nimport java.awt.event.*;\nimport javax.swing.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JMenuHelper}.\n* It contains ten unit test cases for the {@link JMenuHelper#addMenuItem(JMenu, String, char)} method.\n*/\nclass JMenuHelperTest2 {"
	},
	{
		"original_code": "// JMenuHelper.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.controller;\r\n\r\nimport java.awt.event.*;\r\nimport javax.swing.*;\r\n\r\npublic class JMenuHelper {\r\n\r\n    /**\r\n     * Add an element to the menubar.\r\n     *\r\n     * @param menuBar a JMenuBar\r\n     * @param s a String\r\n     *\r\n     * @return added JMenu\r\n     */\r\n    public static JMenu addMenuBarItem(JMenuBar menuBar, String s) {\r\n        JMenu menu;\r\n        /**\r\n         * Suche nach '_' und nimm das nächste Zeichen als Mnemonic,\r\n         * sonst: normales Menu\r\n         */\r\n        if (s.indexOf(\"_\") > -1) {\r\n            int pos = s.indexOf(\"_\");\r\n            char c = s.charAt(pos + 1);\r\n            StringBuffer sb = new StringBuffer(s).delete(pos, pos + 1);\r\n            menu = new JMenu(sb.toString());\r\n            menu.setMnemonic(c);\r\n        } else\r\n            menu = new JMenu(s);\r\n        menuBar.add(menu);\r\n        return menu;\r\n    }\r\n\r\n    private static JMenuItem processAction(Action a) {\r\n        if (a != null) {\r\n            return new JMenuItem(a);\r\n        } else {\r\n            return new JMenuItem();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Setze das Zeichen nach '_' als Mnemonic des MenuItems\r\n     * @param s\r\n     */\r\n    private static void processMnemonic(JMenuItem menuItem, String s) {\r\n        if (s.indexOf(\"_\") > -1) {\r\n            int pos = s.indexOf(\"_\");\r\n            char c = s.charAt(pos + 1);\r\n            StringBuffer sb = new StringBuffer(s).delete(pos, pos + 1);\r\n            menuItem.setName(sb.toString());\r\n            menuItem.setMnemonic(c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Insert a JMenuItem to a given JMenu.\r\n     *\r\n     * @param m\r\n     *            a JMenu\r\n     * @param s\r\n     *            a String\r\n     * @param keyChar\r\n     *            a char\r\n     * @param al\r\n     *            an ActionListener\r\n     *\r\n     * @return a JMenuItem\r\n     */\r\n    public static JMenuItem addMenuItem(JMenu m, String s, char keyChar, Action a, ActionListener al) {\r\n        if (s.startsWith(\"-\")) {\r\n            m.addSeparator();\r\n            return null;\r\n        }\r\n        JMenuItem menuItem = processAction(a);\r\n        processMnemonic(menuItem, s);\r\n        //füge den Short-Cut hinzu\r\n        if (keyChar != 0)\r\n            menuItem.setAccelerator(KeyStroke.getKeyStroke(keyChar, InputEvent.CTRL_MASK));\r\n        //Actionslistener anmelden\r\n        if (al != null)\r\n            menuItem.addActionListener(al);\r\n        //dem Menu hinzufügen\r\n        m.add(menuItem);\r\n        return menuItem;\r\n    }\r\n\r\n    public static JMenuItem addMenuItem(JMenu m, String s, char c) {\r\n        return addMenuItem(m, s, c, null, null);\r\n    }\r\n\r\n    public static JMenuItem addMenuItem(JMenu m, String s) {\r\n        return addMenuItem(m, s, (char) 0, null, null);\r\n    }\r\n\r\n    public static JMenuItem addMenuItem(JMenu m, String s, ActionListener al) {\r\n        return addMenuItem(m, s, (char) 0, null, al);\r\n    }\r\n\r\n    public static JMenuItem addMenuItem(JMenu m, String s, Action a) {\r\n        return addMenuItem(m, s, (char) 0, a, null);\r\n    }\r\n\r\n    public static JMenuItem addMenuItem(JMenu m, String s, char c, Action a) {\r\n        return addMenuItem(m, s, c, a, null);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/controller/JMenuHelperTest3.java",
		"test_prompt": "// JMenuHelperTest3.java\npackage visu.handball.moves.controller;\n\nimport java.awt.event.*;\nimport javax.swing.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JMenuHelper}.\n* It contains ten unit test cases for the {@link JMenuHelper#addMenuItem(JMenu, String)} method.\n*/\nclass JMenuHelperTest3 {"
	},
	{
		"original_code": "// JMenuHelper.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.controller;\r\n\r\nimport java.awt.event.*;\r\nimport javax.swing.*;\r\n\r\npublic class JMenuHelper {\r\n\r\n    /**\r\n     * Add an element to the menubar.\r\n     *\r\n     * @param menuBar a JMenuBar\r\n     * @param s a String\r\n     *\r\n     * @return added JMenu\r\n     */\r\n    public static JMenu addMenuBarItem(JMenuBar menuBar, String s) {\r\n        JMenu menu;\r\n        /**\r\n         * Suche nach '_' und nimm das nächste Zeichen als Mnemonic,\r\n         * sonst: normales Menu\r\n         */\r\n        if (s.indexOf(\"_\") > -1) {\r\n            int pos = s.indexOf(\"_\");\r\n            char c = s.charAt(pos + 1);\r\n            StringBuffer sb = new StringBuffer(s).delete(pos, pos + 1);\r\n            menu = new JMenu(sb.toString());\r\n            menu.setMnemonic(c);\r\n        } else\r\n            menu = new JMenu(s);\r\n        menuBar.add(menu);\r\n        return menu;\r\n    }\r\n\r\n    private static JMenuItem processAction(Action a) {\r\n        if (a != null) {\r\n            return new JMenuItem(a);\r\n        } else {\r\n            return new JMenuItem();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Setze das Zeichen nach '_' als Mnemonic des MenuItems\r\n     * @param s\r\n     */\r\n    private static void processMnemonic(JMenuItem menuItem, String s) {\r\n        if (s.indexOf(\"_\") > -1) {\r\n            int pos = s.indexOf(\"_\");\r\n            char c = s.charAt(pos + 1);\r\n            StringBuffer sb = new StringBuffer(s).delete(pos, pos + 1);\r\n            menuItem.setName(sb.toString());\r\n            menuItem.setMnemonic(c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Insert a JMenuItem to a given JMenu.\r\n     *\r\n     * @param m\r\n     *            a JMenu\r\n     * @param s\r\n     *            a String\r\n     * @param keyChar\r\n     *            a char\r\n     * @param al\r\n     *            an ActionListener\r\n     *\r\n     * @return a JMenuItem\r\n     */\r\n    public static JMenuItem addMenuItem(JMenu m, String s, char keyChar, Action a, ActionListener al) {\r\n        if (s.startsWith(\"-\")) {\r\n            m.addSeparator();\r\n            return null;\r\n        }\r\n        JMenuItem menuItem = processAction(a);\r\n        processMnemonic(menuItem, s);\r\n        //füge den Short-Cut hinzu\r\n        if (keyChar != 0)\r\n            menuItem.setAccelerator(KeyStroke.getKeyStroke(keyChar, InputEvent.CTRL_MASK));\r\n        //Actionslistener anmelden\r\n        if (al != null)\r\n            menuItem.addActionListener(al);\r\n        //dem Menu hinzufügen\r\n        m.add(menuItem);\r\n        return menuItem;\r\n    }\r\n\r\n    public static JMenuItem addMenuItem(JMenu m, String s, char c) {\r\n        return addMenuItem(m, s, c, null, null);\r\n    }\r\n\r\n    public static JMenuItem addMenuItem(JMenu m, String s) {\r\n        return addMenuItem(m, s, (char) 0, null, null);\r\n    }\r\n\r\n    public static JMenuItem addMenuItem(JMenu m, String s, ActionListener al) {\r\n        return addMenuItem(m, s, (char) 0, null, al);\r\n    }\r\n\r\n    public static JMenuItem addMenuItem(JMenu m, String s, Action a) {\r\n        return addMenuItem(m, s, (char) 0, a, null);\r\n    }\r\n\r\n    public static JMenuItem addMenuItem(JMenu m, String s, char c, Action a) {\r\n        return addMenuItem(m, s, c, a, null);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/controller/JMenuHelperTest4.java",
		"test_prompt": "// JMenuHelperTest4.java\npackage visu.handball.moves.controller;\n\nimport java.awt.event.*;\nimport javax.swing.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JMenuHelper}.\n* It contains ten unit test cases for the {@link JMenuHelper#addMenuItem(JMenu, String, ActionListener)} method.\n*/\nclass JMenuHelperTest4 {"
	},
	{
		"original_code": "// JMenuHelper.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.controller;\r\n\r\nimport java.awt.event.*;\r\nimport javax.swing.*;\r\n\r\npublic class JMenuHelper {\r\n\r\n    /**\r\n     * Add an element to the menubar.\r\n     *\r\n     * @param menuBar a JMenuBar\r\n     * @param s a String\r\n     *\r\n     * @return added JMenu\r\n     */\r\n    public static JMenu addMenuBarItem(JMenuBar menuBar, String s) {\r\n        JMenu menu;\r\n        /**\r\n         * Suche nach '_' und nimm das nächste Zeichen als Mnemonic,\r\n         * sonst: normales Menu\r\n         */\r\n        if (s.indexOf(\"_\") > -1) {\r\n            int pos = s.indexOf(\"_\");\r\n            char c = s.charAt(pos + 1);\r\n            StringBuffer sb = new StringBuffer(s).delete(pos, pos + 1);\r\n            menu = new JMenu(sb.toString());\r\n            menu.setMnemonic(c);\r\n        } else\r\n            menu = new JMenu(s);\r\n        menuBar.add(menu);\r\n        return menu;\r\n    }\r\n\r\n    private static JMenuItem processAction(Action a) {\r\n        if (a != null) {\r\n            return new JMenuItem(a);\r\n        } else {\r\n            return new JMenuItem();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Setze das Zeichen nach '_' als Mnemonic des MenuItems\r\n     * @param s\r\n     */\r\n    private static void processMnemonic(JMenuItem menuItem, String s) {\r\n        if (s.indexOf(\"_\") > -1) {\r\n            int pos = s.indexOf(\"_\");\r\n            char c = s.charAt(pos + 1);\r\n            StringBuffer sb = new StringBuffer(s).delete(pos, pos + 1);\r\n            menuItem.setName(sb.toString());\r\n            menuItem.setMnemonic(c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Insert a JMenuItem to a given JMenu.\r\n     *\r\n     * @param m\r\n     *            a JMenu\r\n     * @param s\r\n     *            a String\r\n     * @param keyChar\r\n     *            a char\r\n     * @param al\r\n     *            an ActionListener\r\n     *\r\n     * @return a JMenuItem\r\n     */\r\n    public static JMenuItem addMenuItem(JMenu m, String s, char keyChar, Action a, ActionListener al) {\r\n        if (s.startsWith(\"-\")) {\r\n            m.addSeparator();\r\n            return null;\r\n        }\r\n        JMenuItem menuItem = processAction(a);\r\n        processMnemonic(menuItem, s);\r\n        //füge den Short-Cut hinzu\r\n        if (keyChar != 0)\r\n            menuItem.setAccelerator(KeyStroke.getKeyStroke(keyChar, InputEvent.CTRL_MASK));\r\n        //Actionslistener anmelden\r\n        if (al != null)\r\n            menuItem.addActionListener(al);\r\n        //dem Menu hinzufügen\r\n        m.add(menuItem);\r\n        return menuItem;\r\n    }\r\n\r\n    public static JMenuItem addMenuItem(JMenu m, String s, char c) {\r\n        return addMenuItem(m, s, c, null, null);\r\n    }\r\n\r\n    public static JMenuItem addMenuItem(JMenu m, String s) {\r\n        return addMenuItem(m, s, (char) 0, null, null);\r\n    }\r\n\r\n    public static JMenuItem addMenuItem(JMenu m, String s, ActionListener al) {\r\n        return addMenuItem(m, s, (char) 0, null, al);\r\n    }\r\n\r\n    public static JMenuItem addMenuItem(JMenu m, String s, Action a) {\r\n        return addMenuItem(m, s, (char) 0, a, null);\r\n    }\r\n\r\n    public static JMenuItem addMenuItem(JMenu m, String s, char c, Action a) {\r\n        return addMenuItem(m, s, c, a, null);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/controller/JMenuHelperTest5.java",
		"test_prompt": "// JMenuHelperTest5.java\npackage visu.handball.moves.controller;\n\nimport java.awt.event.*;\nimport javax.swing.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JMenuHelper}.\n* It contains ten unit test cases for the {@link JMenuHelper#addMenuItem(JMenu, String, Action)} method.\n*/\nclass JMenuHelperTest5 {"
	},
	{
		"original_code": "// JMenuHelper.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.controller;\r\n\r\nimport java.awt.event.*;\r\nimport javax.swing.*;\r\n\r\npublic class JMenuHelper {\r\n\r\n    /**\r\n     * Add an element to the menubar.\r\n     *\r\n     * @param menuBar a JMenuBar\r\n     * @param s a String\r\n     *\r\n     * @return added JMenu\r\n     */\r\n    public static JMenu addMenuBarItem(JMenuBar menuBar, String s) {\r\n        JMenu menu;\r\n        /**\r\n         * Suche nach '_' und nimm das nächste Zeichen als Mnemonic,\r\n         * sonst: normales Menu\r\n         */\r\n        if (s.indexOf(\"_\") > -1) {\r\n            int pos = s.indexOf(\"_\");\r\n            char c = s.charAt(pos + 1);\r\n            StringBuffer sb = new StringBuffer(s).delete(pos, pos + 1);\r\n            menu = new JMenu(sb.toString());\r\n            menu.setMnemonic(c);\r\n        } else\r\n            menu = new JMenu(s);\r\n        menuBar.add(menu);\r\n        return menu;\r\n    }\r\n\r\n    private static JMenuItem processAction(Action a) {\r\n        if (a != null) {\r\n            return new JMenuItem(a);\r\n        } else {\r\n            return new JMenuItem();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Setze das Zeichen nach '_' als Mnemonic des MenuItems\r\n     * @param s\r\n     */\r\n    private static void processMnemonic(JMenuItem menuItem, String s) {\r\n        if (s.indexOf(\"_\") > -1) {\r\n            int pos = s.indexOf(\"_\");\r\n            char c = s.charAt(pos + 1);\r\n            StringBuffer sb = new StringBuffer(s).delete(pos, pos + 1);\r\n            menuItem.setName(sb.toString());\r\n            menuItem.setMnemonic(c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Insert a JMenuItem to a given JMenu.\r\n     *\r\n     * @param m\r\n     *            a JMenu\r\n     * @param s\r\n     *            a String\r\n     * @param keyChar\r\n     *            a char\r\n     * @param al\r\n     *            an ActionListener\r\n     *\r\n     * @return a JMenuItem\r\n     */\r\n    public static JMenuItem addMenuItem(JMenu m, String s, char keyChar, Action a, ActionListener al) {\r\n        if (s.startsWith(\"-\")) {\r\n            m.addSeparator();\r\n            return null;\r\n        }\r\n        JMenuItem menuItem = processAction(a);\r\n        processMnemonic(menuItem, s);\r\n        //füge den Short-Cut hinzu\r\n        if (keyChar != 0)\r\n            menuItem.setAccelerator(KeyStroke.getKeyStroke(keyChar, InputEvent.CTRL_MASK));\r\n        //Actionslistener anmelden\r\n        if (al != null)\r\n            menuItem.addActionListener(al);\r\n        //dem Menu hinzufügen\r\n        m.add(menuItem);\r\n        return menuItem;\r\n    }\r\n\r\n    public static JMenuItem addMenuItem(JMenu m, String s, char c) {\r\n        return addMenuItem(m, s, c, null, null);\r\n    }\r\n\r\n    public static JMenuItem addMenuItem(JMenu m, String s) {\r\n        return addMenuItem(m, s, (char) 0, null, null);\r\n    }\r\n\r\n    public static JMenuItem addMenuItem(JMenu m, String s, ActionListener al) {\r\n        return addMenuItem(m, s, (char) 0, null, al);\r\n    }\r\n\r\n    public static JMenuItem addMenuItem(JMenu m, String s, Action a) {\r\n        return addMenuItem(m, s, (char) 0, a, null);\r\n    }\r\n\r\n    public static JMenuItem addMenuItem(JMenu m, String s, char c, Action a) {\r\n        return addMenuItem(m, s, c, a, null);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/controller/JMenuHelperTest6.java",
		"test_prompt": "// JMenuHelperTest6.java\npackage visu.handball.moves.controller;\n\nimport java.awt.event.*;\nimport javax.swing.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JMenuHelper}.\n* It contains ten unit test cases for the {@link JMenuHelper#addMenuItem(JMenu, String, char, Action)} method.\n*/\nclass JMenuHelperTest6 {"
	},
	{
		"original_code": "// Main.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves;\r\n\r\nimport java.awt.BorderLayout;\r\nimport java.awt.Color;\r\nimport java.awt.Component;\r\nimport java.awt.Dimension;\r\nimport java.awt.event.WindowAdapter;\r\nimport java.awt.event.WindowEvent;\r\nimport java.io.ByteArrayInputStream;\r\nimport java.io.ByteArrayOutputStream;\r\nimport java.io.ObjectInputStream;\r\nimport java.io.ObjectOutputStream;\r\nimport java.net.URL;\r\nimport javax.swing.ImageIcon;\r\nimport javax.swing.JDesktopPane;\r\nimport javax.swing.JFrame;\r\nimport javax.swing.JInternalFrame;\r\nimport javax.swing.JMenu;\r\nimport javax.swing.JMenuBar;\r\nimport javax.swing.JPanel;\r\nimport javax.swing.JScrollPane;\r\nimport javax.swing.JTable;\r\nimport javax.swing.JToolBar;\r\nimport javax.swing.ListSelectionModel;\r\nimport javax.swing.UIManager;\r\nimport visu.handball.moves.actions.AboutAction;\r\nimport visu.handball.moves.actions.ChangeColorsAction;\r\nimport visu.handball.moves.actions.CloseAction;\r\nimport visu.handball.moves.actions.CreateMovePdfAction;\r\nimport visu.handball.moves.actions.DeleteEventAction;\r\nimport visu.handball.moves.actions.NewAction;\r\nimport visu.handball.moves.actions.NewMoveEventAction;\r\nimport visu.handball.moves.actions.NewPassEventAction;\r\nimport visu.handball.moves.actions.NewSequenceAction;\r\nimport visu.handball.moves.actions.OpenAction;\r\nimport visu.handball.moves.actions.PauseAnimationAction;\r\nimport visu.handball.moves.actions.PrintActualSequenzAction;\r\nimport visu.handball.moves.actions.PrintMoveAction;\r\nimport visu.handball.moves.actions.SaveAction;\r\nimport visu.handball.moves.actions.SetMoveNameAction;\r\nimport visu.handball.moves.actions.StartAnimationAction;\r\nimport visu.handball.moves.actions.StartOneSequenceAnimationAction;\r\nimport visu.handball.moves.actions.StopAnimationAction;\r\nimport visu.handball.moves.controller.CommentController;\r\nimport visu.handball.moves.controller.JMenuHelper;\r\nimport visu.handball.moves.controller.MouseController;\r\nimport visu.handball.moves.model.ColorModel;\r\nimport visu.handball.moves.model.HandballModel;\r\nimport visu.handball.moves.model.TableHandballModel;\r\nimport visu.handball.moves.model.TableSelectionListener;\r\nimport visu.handball.moves.resources.Resources;\r\nimport visu.handball.moves.views.CommentView;\r\nimport visu.handball.moves.views.EventTableCellDelayEditor;\r\nimport visu.handball.moves.views.EventTableCellRenderer;\r\nimport visu.handball.moves.views.Field;\r\nimport visu.handball.moves.views.PlayerToolBar;\r\nimport visu.handball.moves.views.StatusBar;\r\n\r\n/**\r\n * Hauptklasse zum Starten der Anwendung plus den Zugriff auf die entsprechenden Objekt-Instanzen\r\n * @author tommy\r\n */\r\npublic class Main {\r\n\r\n    private static SaveAction saveAction;\r\n\r\n    private static CloseAction closeAction;\r\n\r\n    private static SetMoveNameAction setNameAction;\r\n\r\n    private static JFrame window;\r\n\r\n    private static Field field;\r\n\r\n    private static CommentView commentView;\r\n\r\n    private static ColorModel colorModel;\r\n\r\n    /**\r\n     * Liefert die Instanz des ColorModels\r\n     *\r\n     * @return colorModel\r\n     */\r\n    public static ColorModel getColorModel() {\r\n        return colorModel;\r\n    }\r\n\r\n    /**\r\n     * Main-Methode zum Starten der Anwendung\r\n     *\r\n     * @param args\r\n     */\r\n    public static void main(String[] args) {\r\n        try {\r\n            UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\r\n        } catch (Exception e) {\r\n            System.out.println(//$NON-NLS-1$\r\n            Resources.getString(\"error.lookAndFell\"));\r\n        }\r\n        //$NON-NLS-1$\r\n        window = new JFrame(Resources.getString(\"app.title\"));\r\n        //$NON-NLS-1$ //$NON-NLS-2$\r\n        window.setIconImage(createImageIcon(\"images/icon.gif\", \"\").getImage());\r\n        JPanel content = new JPanel(new BorderLayout());\r\n        JDesktopPane desktop = new JDesktopPane();\r\n        window.setContentPane(content);\r\n        content.add(desktop, BorderLayout.CENTER);\r\n        desktop.setBackground(new Color(255, 255, 174));\r\n        desktop.setDragMode(JDesktopPane.OUTLINE_DRAG_MODE);\r\n        // Create HandballModel\r\n        HandballModel handballModel = createHandballModel();\r\n        // Create ColorModel\r\n        colorModel = new ColorModel();\r\n        // Statusbar\r\n        StatusBar statusBar = createStatusBar(handballModel);\r\n        content.add(statusBar, BorderLayout.SOUTH);\r\n        // Create Menu\r\n        JMenuBar menu = createHandballMenu(handballModel);\r\n        window.setJMenuBar(menu);\r\n        // Create HandballField\r\n        field = new Field(handballModel, colorModel);\r\n        JInternalFrame handballField = new //$NON-NLS-1$\r\n        JInternalFrame(//$NON-NLS-1$\r\n        Resources.getString(\"field.title\"), //$NON-NLS-1$\r\n        false, false, false, true);\r\n        handballField.setLocation(10, 10);\r\n        handballField.add(field);\r\n        handballField.setVisible(true);\r\n        handballField.pack();\r\n        desktop.add(handballField);\r\n        // Create MouseController\r\n        MouseController mouse = new MouseController(handballModel, handballField);\r\n        field.addMouseListener(mouse);\r\n        field.addMouseMotionListener(mouse);\r\n        // Add Statusbar as Listener\r\n        field.addMouseMotionListener(statusBar);\r\n        // Create ToolBar\r\n        PlayerToolBar playerBar = new PlayerToolBar(handballModel);\r\n        content.add(playerBar, BorderLayout.NORTH);\r\n        // Create EventView\r\n        JPanel tablePanel = createTablePanel(handballModel);\r\n        JInternalFrame eventView = new //$NON-NLS-1$\r\n        JInternalFrame(//$NON-NLS-1$\r\n        Resources.getString(\"events.title\"), //$NON-NLS-1$\r\n        true, false, false, true);\r\n        eventView.add(tablePanel);\r\n        eventView.setLocation(20 + handballField.getWidth(), 10);\r\n        eventView.setVisible(true);\r\n        eventView.setSize(450, 400);\r\n        desktop.add(eventView);\r\n        // Create CommentView\r\n        //$NON-NLS-1$\r\n        commentView = new CommentView(Resources.getString(\"comment.title\"));\r\n        commentView.setLocation(20 + handballField.getWidth(), 420);\r\n        commentView.setSize(450, handballField.getHeight() - eventView.getHeight() - 10);\r\n        commentView.setVisible(true);\r\n        //Controller für CommentView erzeugen\r\n        new CommentController(handballModel, commentView);\r\n        desktop.add(commentView);\r\n        window.setSize(1000, 700);\r\n        locateOnScreenCenter(window);\r\n        window.addWindowListener(new WindowAdapter() {\r\n\r\n            public void windowClosing(WindowEvent e) {\r\n                Main.getCloseAction().actionPerformed(null);\r\n            }\r\n        });\r\n        window.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);\r\n        window.setVisible(true);\r\n    }\r\n\r\n    private static JMenuBar createHandballMenu(HandballModel handballModel) {\r\n        JMenuBar mbar;\r\n        JMenu menuDatei, menuHilfe, menuEinstellungen;\r\n        // Hauptmenue einrichten\r\n        mbar = new JMenuBar();\r\n        //$NON-NLS-1$\r\n        menuDatei = JMenuHelper.addMenuBarItem(mbar, Resources.getString(\"menu.file\"));\r\n        //$NON-NLS-1$\r\n        menuEinstellungen = JMenuHelper.addMenuBarItem(mbar, Resources.getString(\"menu.settings\"));\r\n        //$NON-NLS-1$\r\n        menuHilfe = JMenuHelper.addMenuBarItem(mbar, Resources.getString(\"menu.about\"));\r\n        // Einträge fuer Datei\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", new //$NON-NLS-1$\r\n        NewAction(handballModel));\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", new //$NON-NLS-1$\r\n        OpenAction(handballModel));\r\n        //Separator einfügen\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"-\");\r\n        saveAction = new SaveAction(handballModel);\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", saveAction);\r\n        // Separator einfügen\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"-\");\r\n        setNameAction = new SetMoveNameAction(handballModel);\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", setNameAction);\r\n        //Separator einfügen\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"-\");\r\n        //Drucken einfügen\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", new //$NON-NLS-1$\r\n        PrintActualSequenzAction(handballModel));\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", new PrintMoveAction(handballModel));\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", new CreateMovePdfAction(handballModel));\r\n        // Separator einfügen\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"-\");\r\n        closeAction = new CloseAction(handballModel);\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", closeAction);\r\n        // Einträge für Einstellungen\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuEinstellungen, \"\", new ChangeColorsAction());\r\n        // Einträge für Hilfe\r\n        //$NON-NLS-1$\r\n        JMenuHelper.//$NON-NLS-1$\r\n        addMenuItem(//$NON-NLS-1$\r\n        menuHilfe, //$NON-NLS-1$\r\n        \"\", new AboutAction());\r\n        return mbar;\r\n    }\r\n\r\n    private static JPanel createTablePanel(HandballModel handballModel) {\r\n        TableHandballModel tableModel = new TableHandballModel(handballModel);\r\n        JTable table = new JTable(tableModel);\r\n        table.setDefaultRenderer(Object.class, new EventTableCellRenderer());\r\n        table.getColumnModel().getColumn(0).setPreferredWidth(100);\r\n        table.getColumnModel().getColumn(1).setPreferredWidth(200);\r\n        EventTableCellDelayEditor delayEditor = new EventTableCellDelayEditor();\r\n        table.getColumnModel().getColumn(3).setCellEditor(delayEditor);\r\n        table.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\r\n        table.getSelectionModel().addListSelectionListener(new TableSelectionListener(tableModel));\r\n        JPanel panel = new JPanel(new BorderLayout());\r\n        //$NON-NLS-1$\r\n        JToolBar toolBar = new JToolBar(Resources.getString(\"toolbar.title\"));\r\n        toolBar.add(new NewMoveEventAction(handballModel));\r\n        toolBar.add(new NewSequenceAction(handballModel));\r\n        toolBar.add(new NewPassEventAction(handballModel));\r\n        toolBar.add(new DeleteEventAction(handballModel));\r\n        toolBar.addSeparator();\r\n        toolBar.add(new StartOneSequenceAnimationAction(handballModel));\r\n        toolBar.add(new StartAnimationAction(handballModel));\r\n        toolBar.add(new PauseAnimationAction(handballModel));\r\n        toolBar.add(new StopAnimationAction(handballModel));\r\n        JScrollPane scroll = new JScrollPane(table);\r\n        panel.add(scroll, BorderLayout.CENTER);\r\n        panel.add(toolBar, BorderLayout.PAGE_START);\r\n        return panel;\r\n    }\r\n\r\n    private static StatusBar createStatusBar(HandballModel model) {\r\n        StatusBar statusBar = new StatusBar(model);\r\n        return statusBar;\r\n    }\r\n\r\n    /**\r\n     * Basierend auf der relativen Pfad (relativ zum Ort dieser Klasse) und der Beschreibung\r\n     * wird ein Grafik geladen und ein ImageIcon-Objekt erstellt.\r\n     * @param path\r\n     * @param description\r\n     *\r\n     * @return imageIcon\r\n     */\r\n    public static ImageIcon createImageIcon(String path, String description) {\r\n        URL url = Main.class.getResource(path);\r\n        return new ImageIcon(url, description);\r\n    }\r\n\r\n    /**\r\n     * Erzeugt auf Basis eines relativen Pfads (relativ zum Ort dieser Klasse) eine URL.\r\n     * @param path\r\n     *\r\n     * @return url\r\n     */\r\n    public static URL getResource(String path) {\r\n        return Main.class.getResource(path);\r\n    }\r\n\r\n    /**\r\n     * Methode um Component-Objekte (z.B. Fenster) in der Mitte des Bildschirms zu positionieren\r\n     * @param component\r\n     */\r\n    public static void locateOnScreenCenter(Component component) {\r\n        Dimension paneSize = component.getSize();\r\n        Dimension screenSize = component.getToolkit().getScreenSize();\r\n        component.setLocation((screenSize.width - paneSize.width) / 2, (screenSize.height - paneSize.height) / 2);\r\n    }\r\n\r\n    private static HandballModel createHandballModel() {\r\n        HandballModel model = new HandballModel();\r\n        return model;\r\n    }\r\n\r\n    /**\r\n     * Die Instanz des Anwendungsfensters\r\n     *\r\n     * @return window\r\n     */\r\n    public static JFrame getWindow() {\r\n        return window;\r\n    }\r\n\r\n    /**\r\n     * Instanz des Spielfeld-Panels\r\n     *\r\n     * @return panel\r\n     */\r\n    public static Field getField() {\r\n        return field;\r\n    }\r\n\r\n    /**\r\n     * Instanz der Speichern-Aktion\r\n     *\r\n     * @return saveAction\r\n     */\r\n    public static SaveAction getSaveAction() {\r\n        return saveAction;\r\n    }\r\n\r\n    public static SetMoveNameAction getSetNameAction() {\r\n        return setNameAction;\r\n    }\r\n\r\n    /**\r\n     * Instanz der Schlie�en-Aktion\r\n     *\r\n     * @return close Action\r\n     */\r\n    public static CloseAction getCloseAction() {\r\n        return closeAction;\r\n    }\r\n\r\n    /**\r\n     * Methode um eine tiefe Objektkopie per Serialisierung zu erzeugen!\r\n     *\r\n     * @param oldObj (muss Serializable implementieren)\r\n     * @return tiefe Kopie\r\n     * @throws Exception\r\n     */\r\n    public static Object deepCopy(Object oldObj) throws Exception {\r\n        Object clone = null;\r\n        try {\r\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n            ObjectOutputStream oos = new ObjectOutputStream(baos);\r\n            oos.writeObject(oldObj);\r\n            oos.flush();\r\n            ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray()));\r\n            clone = ois.readObject();\r\n            oos.close();\r\n            ois.close();\r\n        } catch (Exception e) {\r\n            //$NON-NLS-1$\r\n            System.out.println(\"Exception in ObjectCloner = \" + e);\r\n            throw (e);\r\n        }\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Liefert die Version der Anwendung als String\r\n     *\r\n     * @return version\r\n     */\r\n    public static String getVersion() {\r\n        //$NON-NLS-1$\r\n        return \"1.0.5\";\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/MainTest0.java",
		"test_prompt": "// MainTest0.java\npackage visu.handball.moves;\n\nimport java.awt.BorderLayout;\nimport java.awt.Color;\nimport java.awt.Component;\nimport java.awt.Dimension;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.net.URL;\nimport javax.swing.ImageIcon;\nimport javax.swing.JDesktopPane;\nimport javax.swing.JFrame;\nimport javax.swing.JInternalFrame;\nimport javax.swing.JMenu;\nimport javax.swing.JMenuBar;\nimport javax.swing.JPanel;\nimport javax.swing.JScrollPane;\nimport javax.swing.JTable;\nimport javax.swing.JToolBar;\nimport javax.swing.ListSelectionModel;\nimport javax.swing.UIManager;\nimport visu.handball.moves.actions.AboutAction;\nimport visu.handball.moves.actions.ChangeColorsAction;\nimport visu.handball.moves.actions.CloseAction;\nimport visu.handball.moves.actions.CreateMovePdfAction;\nimport visu.handball.moves.actions.DeleteEventAction;\nimport visu.handball.moves.actions.NewAction;\nimport visu.handball.moves.actions.NewMoveEventAction;\nimport visu.handball.moves.actions.NewPassEventAction;\nimport visu.handball.moves.actions.NewSequenceAction;\nimport visu.handball.moves.actions.OpenAction;\nimport visu.handball.moves.actions.PauseAnimationAction;\nimport visu.handball.moves.actions.PrintActualSequenzAction;\nimport visu.handball.moves.actions.PrintMoveAction;\nimport visu.handball.moves.actions.SaveAction;\nimport visu.handball.moves.actions.SetMoveNameAction;\nimport visu.handball.moves.actions.StartAnimationAction;\nimport visu.handball.moves.actions.StartOneSequenceAnimationAction;\nimport visu.handball.moves.actions.StopAnimationAction;\nimport visu.handball.moves.controller.CommentController;\nimport visu.handball.moves.controller.JMenuHelper;\nimport visu.handball.moves.controller.MouseController;\nimport visu.handball.moves.model.ColorModel;\nimport visu.handball.moves.model.HandballModel;\nimport visu.handball.moves.model.TableHandballModel;\nimport visu.handball.moves.model.TableSelectionListener;\nimport visu.handball.moves.resources.Resources;\nimport visu.handball.moves.views.CommentView;\nimport visu.handball.moves.views.EventTableCellDelayEditor;\nimport visu.handball.moves.views.EventTableCellRenderer;\nimport visu.handball.moves.views.Field;\nimport visu.handball.moves.views.PlayerToolBar;\nimport visu.handball.moves.views.StatusBar;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Main}.\n* It contains ten unit test cases for the {@link Main#getColorModel()} method.\n*/\nclass MainTest0 {"
	},
	{
		"original_code": "// Main.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves;\r\n\r\nimport java.awt.BorderLayout;\r\nimport java.awt.Color;\r\nimport java.awt.Component;\r\nimport java.awt.Dimension;\r\nimport java.awt.event.WindowAdapter;\r\nimport java.awt.event.WindowEvent;\r\nimport java.io.ByteArrayInputStream;\r\nimport java.io.ByteArrayOutputStream;\r\nimport java.io.ObjectInputStream;\r\nimport java.io.ObjectOutputStream;\r\nimport java.net.URL;\r\nimport javax.swing.ImageIcon;\r\nimport javax.swing.JDesktopPane;\r\nimport javax.swing.JFrame;\r\nimport javax.swing.JInternalFrame;\r\nimport javax.swing.JMenu;\r\nimport javax.swing.JMenuBar;\r\nimport javax.swing.JPanel;\r\nimport javax.swing.JScrollPane;\r\nimport javax.swing.JTable;\r\nimport javax.swing.JToolBar;\r\nimport javax.swing.ListSelectionModel;\r\nimport javax.swing.UIManager;\r\nimport visu.handball.moves.actions.AboutAction;\r\nimport visu.handball.moves.actions.ChangeColorsAction;\r\nimport visu.handball.moves.actions.CloseAction;\r\nimport visu.handball.moves.actions.CreateMovePdfAction;\r\nimport visu.handball.moves.actions.DeleteEventAction;\r\nimport visu.handball.moves.actions.NewAction;\r\nimport visu.handball.moves.actions.NewMoveEventAction;\r\nimport visu.handball.moves.actions.NewPassEventAction;\r\nimport visu.handball.moves.actions.NewSequenceAction;\r\nimport visu.handball.moves.actions.OpenAction;\r\nimport visu.handball.moves.actions.PauseAnimationAction;\r\nimport visu.handball.moves.actions.PrintActualSequenzAction;\r\nimport visu.handball.moves.actions.PrintMoveAction;\r\nimport visu.handball.moves.actions.SaveAction;\r\nimport visu.handball.moves.actions.SetMoveNameAction;\r\nimport visu.handball.moves.actions.StartAnimationAction;\r\nimport visu.handball.moves.actions.StartOneSequenceAnimationAction;\r\nimport visu.handball.moves.actions.StopAnimationAction;\r\nimport visu.handball.moves.controller.CommentController;\r\nimport visu.handball.moves.controller.JMenuHelper;\r\nimport visu.handball.moves.controller.MouseController;\r\nimport visu.handball.moves.model.ColorModel;\r\nimport visu.handball.moves.model.HandballModel;\r\nimport visu.handball.moves.model.TableHandballModel;\r\nimport visu.handball.moves.model.TableSelectionListener;\r\nimport visu.handball.moves.resources.Resources;\r\nimport visu.handball.moves.views.CommentView;\r\nimport visu.handball.moves.views.EventTableCellDelayEditor;\r\nimport visu.handball.moves.views.EventTableCellRenderer;\r\nimport visu.handball.moves.views.Field;\r\nimport visu.handball.moves.views.PlayerToolBar;\r\nimport visu.handball.moves.views.StatusBar;\r\n\r\n/**\r\n * Hauptklasse zum Starten der Anwendung plus den Zugriff auf die entsprechenden Objekt-Instanzen\r\n * @author tommy\r\n */\r\npublic class Main {\r\n\r\n    private static SaveAction saveAction;\r\n\r\n    private static CloseAction closeAction;\r\n\r\n    private static SetMoveNameAction setNameAction;\r\n\r\n    private static JFrame window;\r\n\r\n    private static Field field;\r\n\r\n    private static CommentView commentView;\r\n\r\n    private static ColorModel colorModel;\r\n\r\n    /**\r\n     * Liefert die Instanz des ColorModels\r\n     *\r\n     * @return colorModel\r\n     */\r\n    public static ColorModel getColorModel() {\r\n        return colorModel;\r\n    }\r\n\r\n    /**\r\n     * Main-Methode zum Starten der Anwendung\r\n     *\r\n     * @param args\r\n     */\r\n    public static void main(String[] args) {\r\n        try {\r\n            UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\r\n        } catch (Exception e) {\r\n            System.out.println(//$NON-NLS-1$\r\n            Resources.getString(\"error.lookAndFell\"));\r\n        }\r\n        //$NON-NLS-1$\r\n        window = new JFrame(Resources.getString(\"app.title\"));\r\n        //$NON-NLS-1$ //$NON-NLS-2$\r\n        window.setIconImage(createImageIcon(\"images/icon.gif\", \"\").getImage());\r\n        JPanel content = new JPanel(new BorderLayout());\r\n        JDesktopPane desktop = new JDesktopPane();\r\n        window.setContentPane(content);\r\n        content.add(desktop, BorderLayout.CENTER);\r\n        desktop.setBackground(new Color(255, 255, 174));\r\n        desktop.setDragMode(JDesktopPane.OUTLINE_DRAG_MODE);\r\n        // Create HandballModel\r\n        HandballModel handballModel = createHandballModel();\r\n        // Create ColorModel\r\n        colorModel = new ColorModel();\r\n        // Statusbar\r\n        StatusBar statusBar = createStatusBar(handballModel);\r\n        content.add(statusBar, BorderLayout.SOUTH);\r\n        // Create Menu\r\n        JMenuBar menu = createHandballMenu(handballModel);\r\n        window.setJMenuBar(menu);\r\n        // Create HandballField\r\n        field = new Field(handballModel, colorModel);\r\n        JInternalFrame handballField = new //$NON-NLS-1$\r\n        JInternalFrame(//$NON-NLS-1$\r\n        Resources.getString(\"field.title\"), //$NON-NLS-1$\r\n        false, false, false, true);\r\n        handballField.setLocation(10, 10);\r\n        handballField.add(field);\r\n        handballField.setVisible(true);\r\n        handballField.pack();\r\n        desktop.add(handballField);\r\n        // Create MouseController\r\n        MouseController mouse = new MouseController(handballModel, handballField);\r\n        field.addMouseListener(mouse);\r\n        field.addMouseMotionListener(mouse);\r\n        // Add Statusbar as Listener\r\n        field.addMouseMotionListener(statusBar);\r\n        // Create ToolBar\r\n        PlayerToolBar playerBar = new PlayerToolBar(handballModel);\r\n        content.add(playerBar, BorderLayout.NORTH);\r\n        // Create EventView\r\n        JPanel tablePanel = createTablePanel(handballModel);\r\n        JInternalFrame eventView = new //$NON-NLS-1$\r\n        JInternalFrame(//$NON-NLS-1$\r\n        Resources.getString(\"events.title\"), //$NON-NLS-1$\r\n        true, false, false, true);\r\n        eventView.add(tablePanel);\r\n        eventView.setLocation(20 + handballField.getWidth(), 10);\r\n        eventView.setVisible(true);\r\n        eventView.setSize(450, 400);\r\n        desktop.add(eventView);\r\n        // Create CommentView\r\n        //$NON-NLS-1$\r\n        commentView = new CommentView(Resources.getString(\"comment.title\"));\r\n        commentView.setLocation(20 + handballField.getWidth(), 420);\r\n        commentView.setSize(450, handballField.getHeight() - eventView.getHeight() - 10);\r\n        commentView.setVisible(true);\r\n        //Controller für CommentView erzeugen\r\n        new CommentController(handballModel, commentView);\r\n        desktop.add(commentView);\r\n        window.setSize(1000, 700);\r\n        locateOnScreenCenter(window);\r\n        window.addWindowListener(new WindowAdapter() {\r\n\r\n            public void windowClosing(WindowEvent e) {\r\n                Main.getCloseAction().actionPerformed(null);\r\n            }\r\n        });\r\n        window.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);\r\n        window.setVisible(true);\r\n    }\r\n\r\n    private static JMenuBar createHandballMenu(HandballModel handballModel) {\r\n        JMenuBar mbar;\r\n        JMenu menuDatei, menuHilfe, menuEinstellungen;\r\n        // Hauptmenue einrichten\r\n        mbar = new JMenuBar();\r\n        //$NON-NLS-1$\r\n        menuDatei = JMenuHelper.addMenuBarItem(mbar, Resources.getString(\"menu.file\"));\r\n        //$NON-NLS-1$\r\n        menuEinstellungen = JMenuHelper.addMenuBarItem(mbar, Resources.getString(\"menu.settings\"));\r\n        //$NON-NLS-1$\r\n        menuHilfe = JMenuHelper.addMenuBarItem(mbar, Resources.getString(\"menu.about\"));\r\n        // Einträge fuer Datei\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", new //$NON-NLS-1$\r\n        NewAction(handballModel));\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", new //$NON-NLS-1$\r\n        OpenAction(handballModel));\r\n        //Separator einfügen\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"-\");\r\n        saveAction = new SaveAction(handballModel);\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", saveAction);\r\n        // Separator einfügen\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"-\");\r\n        setNameAction = new SetMoveNameAction(handballModel);\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", setNameAction);\r\n        //Separator einfügen\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"-\");\r\n        //Drucken einfügen\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", new //$NON-NLS-1$\r\n        PrintActualSequenzAction(handballModel));\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", new PrintMoveAction(handballModel));\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", new CreateMovePdfAction(handballModel));\r\n        // Separator einfügen\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"-\");\r\n        closeAction = new CloseAction(handballModel);\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", closeAction);\r\n        // Einträge für Einstellungen\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuEinstellungen, \"\", new ChangeColorsAction());\r\n        // Einträge für Hilfe\r\n        //$NON-NLS-1$\r\n        JMenuHelper.//$NON-NLS-1$\r\n        addMenuItem(//$NON-NLS-1$\r\n        menuHilfe, //$NON-NLS-1$\r\n        \"\", new AboutAction());\r\n        return mbar;\r\n    }\r\n\r\n    private static JPanel createTablePanel(HandballModel handballModel) {\r\n        TableHandballModel tableModel = new TableHandballModel(handballModel);\r\n        JTable table = new JTable(tableModel);\r\n        table.setDefaultRenderer(Object.class, new EventTableCellRenderer());\r\n        table.getColumnModel().getColumn(0).setPreferredWidth(100);\r\n        table.getColumnModel().getColumn(1).setPreferredWidth(200);\r\n        EventTableCellDelayEditor delayEditor = new EventTableCellDelayEditor();\r\n        table.getColumnModel().getColumn(3).setCellEditor(delayEditor);\r\n        table.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\r\n        table.getSelectionModel().addListSelectionListener(new TableSelectionListener(tableModel));\r\n        JPanel panel = new JPanel(new BorderLayout());\r\n        //$NON-NLS-1$\r\n        JToolBar toolBar = new JToolBar(Resources.getString(\"toolbar.title\"));\r\n        toolBar.add(new NewMoveEventAction(handballModel));\r\n        toolBar.add(new NewSequenceAction(handballModel));\r\n        toolBar.add(new NewPassEventAction(handballModel));\r\n        toolBar.add(new DeleteEventAction(handballModel));\r\n        toolBar.addSeparator();\r\n        toolBar.add(new StartOneSequenceAnimationAction(handballModel));\r\n        toolBar.add(new StartAnimationAction(handballModel));\r\n        toolBar.add(new PauseAnimationAction(handballModel));\r\n        toolBar.add(new StopAnimationAction(handballModel));\r\n        JScrollPane scroll = new JScrollPane(table);\r\n        panel.add(scroll, BorderLayout.CENTER);\r\n        panel.add(toolBar, BorderLayout.PAGE_START);\r\n        return panel;\r\n    }\r\n\r\n    private static StatusBar createStatusBar(HandballModel model) {\r\n        StatusBar statusBar = new StatusBar(model);\r\n        return statusBar;\r\n    }\r\n\r\n    /**\r\n     * Basierend auf der relativen Pfad (relativ zum Ort dieser Klasse) und der Beschreibung\r\n     * wird ein Grafik geladen und ein ImageIcon-Objekt erstellt.\r\n     * @param path\r\n     * @param description\r\n     *\r\n     * @return imageIcon\r\n     */\r\n    public static ImageIcon createImageIcon(String path, String description) {\r\n        URL url = Main.class.getResource(path);\r\n        return new ImageIcon(url, description);\r\n    }\r\n\r\n    /**\r\n     * Erzeugt auf Basis eines relativen Pfads (relativ zum Ort dieser Klasse) eine URL.\r\n     * @param path\r\n     *\r\n     * @return url\r\n     */\r\n    public static URL getResource(String path) {\r\n        return Main.class.getResource(path);\r\n    }\r\n\r\n    /**\r\n     * Methode um Component-Objekte (z.B. Fenster) in der Mitte des Bildschirms zu positionieren\r\n     * @param component\r\n     */\r\n    public static void locateOnScreenCenter(Component component) {\r\n        Dimension paneSize = component.getSize();\r\n        Dimension screenSize = component.getToolkit().getScreenSize();\r\n        component.setLocation((screenSize.width - paneSize.width) / 2, (screenSize.height - paneSize.height) / 2);\r\n    }\r\n\r\n    private static HandballModel createHandballModel() {\r\n        HandballModel model = new HandballModel();\r\n        return model;\r\n    }\r\n\r\n    /**\r\n     * Die Instanz des Anwendungsfensters\r\n     *\r\n     * @return window\r\n     */\r\n    public static JFrame getWindow() {\r\n        return window;\r\n    }\r\n\r\n    /**\r\n     * Instanz des Spielfeld-Panels\r\n     *\r\n     * @return panel\r\n     */\r\n    public static Field getField() {\r\n        return field;\r\n    }\r\n\r\n    /**\r\n     * Instanz der Speichern-Aktion\r\n     *\r\n     * @return saveAction\r\n     */\r\n    public static SaveAction getSaveAction() {\r\n        return saveAction;\r\n    }\r\n\r\n    public static SetMoveNameAction getSetNameAction() {\r\n        return setNameAction;\r\n    }\r\n\r\n    /**\r\n     * Instanz der Schlie�en-Aktion\r\n     *\r\n     * @return close Action\r\n     */\r\n    public static CloseAction getCloseAction() {\r\n        return closeAction;\r\n    }\r\n\r\n    /**\r\n     * Methode um eine tiefe Objektkopie per Serialisierung zu erzeugen!\r\n     *\r\n     * @param oldObj (muss Serializable implementieren)\r\n     * @return tiefe Kopie\r\n     * @throws Exception\r\n     */\r\n    public static Object deepCopy(Object oldObj) throws Exception {\r\n        Object clone = null;\r\n        try {\r\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n            ObjectOutputStream oos = new ObjectOutputStream(baos);\r\n            oos.writeObject(oldObj);\r\n            oos.flush();\r\n            ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray()));\r\n            clone = ois.readObject();\r\n            oos.close();\r\n            ois.close();\r\n        } catch (Exception e) {\r\n            //$NON-NLS-1$\r\n            System.out.println(\"Exception in ObjectCloner = \" + e);\r\n            throw (e);\r\n        }\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Liefert die Version der Anwendung als String\r\n     *\r\n     * @return version\r\n     */\r\n    public static String getVersion() {\r\n        //$NON-NLS-1$\r\n        return \"1.0.5\";\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/MainTest1.java",
		"test_prompt": "// MainTest1.java\npackage visu.handball.moves;\n\nimport java.awt.BorderLayout;\nimport java.awt.Color;\nimport java.awt.Component;\nimport java.awt.Dimension;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.net.URL;\nimport javax.swing.ImageIcon;\nimport javax.swing.JDesktopPane;\nimport javax.swing.JFrame;\nimport javax.swing.JInternalFrame;\nimport javax.swing.JMenu;\nimport javax.swing.JMenuBar;\nimport javax.swing.JPanel;\nimport javax.swing.JScrollPane;\nimport javax.swing.JTable;\nimport javax.swing.JToolBar;\nimport javax.swing.ListSelectionModel;\nimport javax.swing.UIManager;\nimport visu.handball.moves.actions.AboutAction;\nimport visu.handball.moves.actions.ChangeColorsAction;\nimport visu.handball.moves.actions.CloseAction;\nimport visu.handball.moves.actions.CreateMovePdfAction;\nimport visu.handball.moves.actions.DeleteEventAction;\nimport visu.handball.moves.actions.NewAction;\nimport visu.handball.moves.actions.NewMoveEventAction;\nimport visu.handball.moves.actions.NewPassEventAction;\nimport visu.handball.moves.actions.NewSequenceAction;\nimport visu.handball.moves.actions.OpenAction;\nimport visu.handball.moves.actions.PauseAnimationAction;\nimport visu.handball.moves.actions.PrintActualSequenzAction;\nimport visu.handball.moves.actions.PrintMoveAction;\nimport visu.handball.moves.actions.SaveAction;\nimport visu.handball.moves.actions.SetMoveNameAction;\nimport visu.handball.moves.actions.StartAnimationAction;\nimport visu.handball.moves.actions.StartOneSequenceAnimationAction;\nimport visu.handball.moves.actions.StopAnimationAction;\nimport visu.handball.moves.controller.CommentController;\nimport visu.handball.moves.controller.JMenuHelper;\nimport visu.handball.moves.controller.MouseController;\nimport visu.handball.moves.model.ColorModel;\nimport visu.handball.moves.model.HandballModel;\nimport visu.handball.moves.model.TableHandballModel;\nimport visu.handball.moves.model.TableSelectionListener;\nimport visu.handball.moves.resources.Resources;\nimport visu.handball.moves.views.CommentView;\nimport visu.handball.moves.views.EventTableCellDelayEditor;\nimport visu.handball.moves.views.EventTableCellRenderer;\nimport visu.handball.moves.views.Field;\nimport visu.handball.moves.views.PlayerToolBar;\nimport visu.handball.moves.views.StatusBar;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Main}.\n* It contains ten unit test cases for the {@link Main#createImageIcon(String, String)} method.\n*/\nclass MainTest1 {"
	},
	{
		"original_code": "// Main.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves;\r\n\r\nimport java.awt.BorderLayout;\r\nimport java.awt.Color;\r\nimport java.awt.Component;\r\nimport java.awt.Dimension;\r\nimport java.awt.event.WindowAdapter;\r\nimport java.awt.event.WindowEvent;\r\nimport java.io.ByteArrayInputStream;\r\nimport java.io.ByteArrayOutputStream;\r\nimport java.io.ObjectInputStream;\r\nimport java.io.ObjectOutputStream;\r\nimport java.net.URL;\r\nimport javax.swing.ImageIcon;\r\nimport javax.swing.JDesktopPane;\r\nimport javax.swing.JFrame;\r\nimport javax.swing.JInternalFrame;\r\nimport javax.swing.JMenu;\r\nimport javax.swing.JMenuBar;\r\nimport javax.swing.JPanel;\r\nimport javax.swing.JScrollPane;\r\nimport javax.swing.JTable;\r\nimport javax.swing.JToolBar;\r\nimport javax.swing.ListSelectionModel;\r\nimport javax.swing.UIManager;\r\nimport visu.handball.moves.actions.AboutAction;\r\nimport visu.handball.moves.actions.ChangeColorsAction;\r\nimport visu.handball.moves.actions.CloseAction;\r\nimport visu.handball.moves.actions.CreateMovePdfAction;\r\nimport visu.handball.moves.actions.DeleteEventAction;\r\nimport visu.handball.moves.actions.NewAction;\r\nimport visu.handball.moves.actions.NewMoveEventAction;\r\nimport visu.handball.moves.actions.NewPassEventAction;\r\nimport visu.handball.moves.actions.NewSequenceAction;\r\nimport visu.handball.moves.actions.OpenAction;\r\nimport visu.handball.moves.actions.PauseAnimationAction;\r\nimport visu.handball.moves.actions.PrintActualSequenzAction;\r\nimport visu.handball.moves.actions.PrintMoveAction;\r\nimport visu.handball.moves.actions.SaveAction;\r\nimport visu.handball.moves.actions.SetMoveNameAction;\r\nimport visu.handball.moves.actions.StartAnimationAction;\r\nimport visu.handball.moves.actions.StartOneSequenceAnimationAction;\r\nimport visu.handball.moves.actions.StopAnimationAction;\r\nimport visu.handball.moves.controller.CommentController;\r\nimport visu.handball.moves.controller.JMenuHelper;\r\nimport visu.handball.moves.controller.MouseController;\r\nimport visu.handball.moves.model.ColorModel;\r\nimport visu.handball.moves.model.HandballModel;\r\nimport visu.handball.moves.model.TableHandballModel;\r\nimport visu.handball.moves.model.TableSelectionListener;\r\nimport visu.handball.moves.resources.Resources;\r\nimport visu.handball.moves.views.CommentView;\r\nimport visu.handball.moves.views.EventTableCellDelayEditor;\r\nimport visu.handball.moves.views.EventTableCellRenderer;\r\nimport visu.handball.moves.views.Field;\r\nimport visu.handball.moves.views.PlayerToolBar;\r\nimport visu.handball.moves.views.StatusBar;\r\n\r\n/**\r\n * Hauptklasse zum Starten der Anwendung plus den Zugriff auf die entsprechenden Objekt-Instanzen\r\n * @author tommy\r\n */\r\npublic class Main {\r\n\r\n    private static SaveAction saveAction;\r\n\r\n    private static CloseAction closeAction;\r\n\r\n    private static SetMoveNameAction setNameAction;\r\n\r\n    private static JFrame window;\r\n\r\n    private static Field field;\r\n\r\n    private static CommentView commentView;\r\n\r\n    private static ColorModel colorModel;\r\n\r\n    /**\r\n     * Liefert die Instanz des ColorModels\r\n     *\r\n     * @return colorModel\r\n     */\r\n    public static ColorModel getColorModel() {\r\n        return colorModel;\r\n    }\r\n\r\n    /**\r\n     * Main-Methode zum Starten der Anwendung\r\n     *\r\n     * @param args\r\n     */\r\n    public static void main(String[] args) {\r\n        try {\r\n            UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\r\n        } catch (Exception e) {\r\n            System.out.println(//$NON-NLS-1$\r\n            Resources.getString(\"error.lookAndFell\"));\r\n        }\r\n        //$NON-NLS-1$\r\n        window = new JFrame(Resources.getString(\"app.title\"));\r\n        //$NON-NLS-1$ //$NON-NLS-2$\r\n        window.setIconImage(createImageIcon(\"images/icon.gif\", \"\").getImage());\r\n        JPanel content = new JPanel(new BorderLayout());\r\n        JDesktopPane desktop = new JDesktopPane();\r\n        window.setContentPane(content);\r\n        content.add(desktop, BorderLayout.CENTER);\r\n        desktop.setBackground(new Color(255, 255, 174));\r\n        desktop.setDragMode(JDesktopPane.OUTLINE_DRAG_MODE);\r\n        // Create HandballModel\r\n        HandballModel handballModel = createHandballModel();\r\n        // Create ColorModel\r\n        colorModel = new ColorModel();\r\n        // Statusbar\r\n        StatusBar statusBar = createStatusBar(handballModel);\r\n        content.add(statusBar, BorderLayout.SOUTH);\r\n        // Create Menu\r\n        JMenuBar menu = createHandballMenu(handballModel);\r\n        window.setJMenuBar(menu);\r\n        // Create HandballField\r\n        field = new Field(handballModel, colorModel);\r\n        JInternalFrame handballField = new //$NON-NLS-1$\r\n        JInternalFrame(//$NON-NLS-1$\r\n        Resources.getString(\"field.title\"), //$NON-NLS-1$\r\n        false, false, false, true);\r\n        handballField.setLocation(10, 10);\r\n        handballField.add(field);\r\n        handballField.setVisible(true);\r\n        handballField.pack();\r\n        desktop.add(handballField);\r\n        // Create MouseController\r\n        MouseController mouse = new MouseController(handballModel, handballField);\r\n        field.addMouseListener(mouse);\r\n        field.addMouseMotionListener(mouse);\r\n        // Add Statusbar as Listener\r\n        field.addMouseMotionListener(statusBar);\r\n        // Create ToolBar\r\n        PlayerToolBar playerBar = new PlayerToolBar(handballModel);\r\n        content.add(playerBar, BorderLayout.NORTH);\r\n        // Create EventView\r\n        JPanel tablePanel = createTablePanel(handballModel);\r\n        JInternalFrame eventView = new //$NON-NLS-1$\r\n        JInternalFrame(//$NON-NLS-1$\r\n        Resources.getString(\"events.title\"), //$NON-NLS-1$\r\n        true, false, false, true);\r\n        eventView.add(tablePanel);\r\n        eventView.setLocation(20 + handballField.getWidth(), 10);\r\n        eventView.setVisible(true);\r\n        eventView.setSize(450, 400);\r\n        desktop.add(eventView);\r\n        // Create CommentView\r\n        //$NON-NLS-1$\r\n        commentView = new CommentView(Resources.getString(\"comment.title\"));\r\n        commentView.setLocation(20 + handballField.getWidth(), 420);\r\n        commentView.setSize(450, handballField.getHeight() - eventView.getHeight() - 10);\r\n        commentView.setVisible(true);\r\n        //Controller für CommentView erzeugen\r\n        new CommentController(handballModel, commentView);\r\n        desktop.add(commentView);\r\n        window.setSize(1000, 700);\r\n        locateOnScreenCenter(window);\r\n        window.addWindowListener(new WindowAdapter() {\r\n\r\n            public void windowClosing(WindowEvent e) {\r\n                Main.getCloseAction().actionPerformed(null);\r\n            }\r\n        });\r\n        window.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);\r\n        window.setVisible(true);\r\n    }\r\n\r\n    private static JMenuBar createHandballMenu(HandballModel handballModel) {\r\n        JMenuBar mbar;\r\n        JMenu menuDatei, menuHilfe, menuEinstellungen;\r\n        // Hauptmenue einrichten\r\n        mbar = new JMenuBar();\r\n        //$NON-NLS-1$\r\n        menuDatei = JMenuHelper.addMenuBarItem(mbar, Resources.getString(\"menu.file\"));\r\n        //$NON-NLS-1$\r\n        menuEinstellungen = JMenuHelper.addMenuBarItem(mbar, Resources.getString(\"menu.settings\"));\r\n        //$NON-NLS-1$\r\n        menuHilfe = JMenuHelper.addMenuBarItem(mbar, Resources.getString(\"menu.about\"));\r\n        // Einträge fuer Datei\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", new //$NON-NLS-1$\r\n        NewAction(handballModel));\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", new //$NON-NLS-1$\r\n        OpenAction(handballModel));\r\n        //Separator einfügen\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"-\");\r\n        saveAction = new SaveAction(handballModel);\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", saveAction);\r\n        // Separator einfügen\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"-\");\r\n        setNameAction = new SetMoveNameAction(handballModel);\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", setNameAction);\r\n        //Separator einfügen\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"-\");\r\n        //Drucken einfügen\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", new //$NON-NLS-1$\r\n        PrintActualSequenzAction(handballModel));\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", new PrintMoveAction(handballModel));\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", new CreateMovePdfAction(handballModel));\r\n        // Separator einfügen\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"-\");\r\n        closeAction = new CloseAction(handballModel);\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", closeAction);\r\n        // Einträge für Einstellungen\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuEinstellungen, \"\", new ChangeColorsAction());\r\n        // Einträge für Hilfe\r\n        //$NON-NLS-1$\r\n        JMenuHelper.//$NON-NLS-1$\r\n        addMenuItem(//$NON-NLS-1$\r\n        menuHilfe, //$NON-NLS-1$\r\n        \"\", new AboutAction());\r\n        return mbar;\r\n    }\r\n\r\n    private static JPanel createTablePanel(HandballModel handballModel) {\r\n        TableHandballModel tableModel = new TableHandballModel(handballModel);\r\n        JTable table = new JTable(tableModel);\r\n        table.setDefaultRenderer(Object.class, new EventTableCellRenderer());\r\n        table.getColumnModel().getColumn(0).setPreferredWidth(100);\r\n        table.getColumnModel().getColumn(1).setPreferredWidth(200);\r\n        EventTableCellDelayEditor delayEditor = new EventTableCellDelayEditor();\r\n        table.getColumnModel().getColumn(3).setCellEditor(delayEditor);\r\n        table.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\r\n        table.getSelectionModel().addListSelectionListener(new TableSelectionListener(tableModel));\r\n        JPanel panel = new JPanel(new BorderLayout());\r\n        //$NON-NLS-1$\r\n        JToolBar toolBar = new JToolBar(Resources.getString(\"toolbar.title\"));\r\n        toolBar.add(new NewMoveEventAction(handballModel));\r\n        toolBar.add(new NewSequenceAction(handballModel));\r\n        toolBar.add(new NewPassEventAction(handballModel));\r\n        toolBar.add(new DeleteEventAction(handballModel));\r\n        toolBar.addSeparator();\r\n        toolBar.add(new StartOneSequenceAnimationAction(handballModel));\r\n        toolBar.add(new StartAnimationAction(handballModel));\r\n        toolBar.add(new PauseAnimationAction(handballModel));\r\n        toolBar.add(new StopAnimationAction(handballModel));\r\n        JScrollPane scroll = new JScrollPane(table);\r\n        panel.add(scroll, BorderLayout.CENTER);\r\n        panel.add(toolBar, BorderLayout.PAGE_START);\r\n        return panel;\r\n    }\r\n\r\n    private static StatusBar createStatusBar(HandballModel model) {\r\n        StatusBar statusBar = new StatusBar(model);\r\n        return statusBar;\r\n    }\r\n\r\n    /**\r\n     * Basierend auf der relativen Pfad (relativ zum Ort dieser Klasse) und der Beschreibung\r\n     * wird ein Grafik geladen und ein ImageIcon-Objekt erstellt.\r\n     * @param path\r\n     * @param description\r\n     *\r\n     * @return imageIcon\r\n     */\r\n    public static ImageIcon createImageIcon(String path, String description) {\r\n        URL url = Main.class.getResource(path);\r\n        return new ImageIcon(url, description);\r\n    }\r\n\r\n    /**\r\n     * Erzeugt auf Basis eines relativen Pfads (relativ zum Ort dieser Klasse) eine URL.\r\n     * @param path\r\n     *\r\n     * @return url\r\n     */\r\n    public static URL getResource(String path) {\r\n        return Main.class.getResource(path);\r\n    }\r\n\r\n    /**\r\n     * Methode um Component-Objekte (z.B. Fenster) in der Mitte des Bildschirms zu positionieren\r\n     * @param component\r\n     */\r\n    public static void locateOnScreenCenter(Component component) {\r\n        Dimension paneSize = component.getSize();\r\n        Dimension screenSize = component.getToolkit().getScreenSize();\r\n        component.setLocation((screenSize.width - paneSize.width) / 2, (screenSize.height - paneSize.height) / 2);\r\n    }\r\n\r\n    private static HandballModel createHandballModel() {\r\n        HandballModel model = new HandballModel();\r\n        return model;\r\n    }\r\n\r\n    /**\r\n     * Die Instanz des Anwendungsfensters\r\n     *\r\n     * @return window\r\n     */\r\n    public static JFrame getWindow() {\r\n        return window;\r\n    }\r\n\r\n    /**\r\n     * Instanz des Spielfeld-Panels\r\n     *\r\n     * @return panel\r\n     */\r\n    public static Field getField() {\r\n        return field;\r\n    }\r\n\r\n    /**\r\n     * Instanz der Speichern-Aktion\r\n     *\r\n     * @return saveAction\r\n     */\r\n    public static SaveAction getSaveAction() {\r\n        return saveAction;\r\n    }\r\n\r\n    public static SetMoveNameAction getSetNameAction() {\r\n        return setNameAction;\r\n    }\r\n\r\n    /**\r\n     * Instanz der Schlie�en-Aktion\r\n     *\r\n     * @return close Action\r\n     */\r\n    public static CloseAction getCloseAction() {\r\n        return closeAction;\r\n    }\r\n\r\n    /**\r\n     * Methode um eine tiefe Objektkopie per Serialisierung zu erzeugen!\r\n     *\r\n     * @param oldObj (muss Serializable implementieren)\r\n     * @return tiefe Kopie\r\n     * @throws Exception\r\n     */\r\n    public static Object deepCopy(Object oldObj) throws Exception {\r\n        Object clone = null;\r\n        try {\r\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n            ObjectOutputStream oos = new ObjectOutputStream(baos);\r\n            oos.writeObject(oldObj);\r\n            oos.flush();\r\n            ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray()));\r\n            clone = ois.readObject();\r\n            oos.close();\r\n            ois.close();\r\n        } catch (Exception e) {\r\n            //$NON-NLS-1$\r\n            System.out.println(\"Exception in ObjectCloner = \" + e);\r\n            throw (e);\r\n        }\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Liefert die Version der Anwendung als String\r\n     *\r\n     * @return version\r\n     */\r\n    public static String getVersion() {\r\n        //$NON-NLS-1$\r\n        return \"1.0.5\";\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/MainTest2.java",
		"test_prompt": "// MainTest2.java\npackage visu.handball.moves;\n\nimport java.awt.BorderLayout;\nimport java.awt.Color;\nimport java.awt.Component;\nimport java.awt.Dimension;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.net.URL;\nimport javax.swing.ImageIcon;\nimport javax.swing.JDesktopPane;\nimport javax.swing.JFrame;\nimport javax.swing.JInternalFrame;\nimport javax.swing.JMenu;\nimport javax.swing.JMenuBar;\nimport javax.swing.JPanel;\nimport javax.swing.JScrollPane;\nimport javax.swing.JTable;\nimport javax.swing.JToolBar;\nimport javax.swing.ListSelectionModel;\nimport javax.swing.UIManager;\nimport visu.handball.moves.actions.AboutAction;\nimport visu.handball.moves.actions.ChangeColorsAction;\nimport visu.handball.moves.actions.CloseAction;\nimport visu.handball.moves.actions.CreateMovePdfAction;\nimport visu.handball.moves.actions.DeleteEventAction;\nimport visu.handball.moves.actions.NewAction;\nimport visu.handball.moves.actions.NewMoveEventAction;\nimport visu.handball.moves.actions.NewPassEventAction;\nimport visu.handball.moves.actions.NewSequenceAction;\nimport visu.handball.moves.actions.OpenAction;\nimport visu.handball.moves.actions.PauseAnimationAction;\nimport visu.handball.moves.actions.PrintActualSequenzAction;\nimport visu.handball.moves.actions.PrintMoveAction;\nimport visu.handball.moves.actions.SaveAction;\nimport visu.handball.moves.actions.SetMoveNameAction;\nimport visu.handball.moves.actions.StartAnimationAction;\nimport visu.handball.moves.actions.StartOneSequenceAnimationAction;\nimport visu.handball.moves.actions.StopAnimationAction;\nimport visu.handball.moves.controller.CommentController;\nimport visu.handball.moves.controller.JMenuHelper;\nimport visu.handball.moves.controller.MouseController;\nimport visu.handball.moves.model.ColorModel;\nimport visu.handball.moves.model.HandballModel;\nimport visu.handball.moves.model.TableHandballModel;\nimport visu.handball.moves.model.TableSelectionListener;\nimport visu.handball.moves.resources.Resources;\nimport visu.handball.moves.views.CommentView;\nimport visu.handball.moves.views.EventTableCellDelayEditor;\nimport visu.handball.moves.views.EventTableCellRenderer;\nimport visu.handball.moves.views.Field;\nimport visu.handball.moves.views.PlayerToolBar;\nimport visu.handball.moves.views.StatusBar;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Main}.\n* It contains ten unit test cases for the {@link Main#getResource(String)} method.\n*/\nclass MainTest2 {"
	},
	{
		"original_code": "// Main.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves;\r\n\r\nimport java.awt.BorderLayout;\r\nimport java.awt.Color;\r\nimport java.awt.Component;\r\nimport java.awt.Dimension;\r\nimport java.awt.event.WindowAdapter;\r\nimport java.awt.event.WindowEvent;\r\nimport java.io.ByteArrayInputStream;\r\nimport java.io.ByteArrayOutputStream;\r\nimport java.io.ObjectInputStream;\r\nimport java.io.ObjectOutputStream;\r\nimport java.net.URL;\r\nimport javax.swing.ImageIcon;\r\nimport javax.swing.JDesktopPane;\r\nimport javax.swing.JFrame;\r\nimport javax.swing.JInternalFrame;\r\nimport javax.swing.JMenu;\r\nimport javax.swing.JMenuBar;\r\nimport javax.swing.JPanel;\r\nimport javax.swing.JScrollPane;\r\nimport javax.swing.JTable;\r\nimport javax.swing.JToolBar;\r\nimport javax.swing.ListSelectionModel;\r\nimport javax.swing.UIManager;\r\nimport visu.handball.moves.actions.AboutAction;\r\nimport visu.handball.moves.actions.ChangeColorsAction;\r\nimport visu.handball.moves.actions.CloseAction;\r\nimport visu.handball.moves.actions.CreateMovePdfAction;\r\nimport visu.handball.moves.actions.DeleteEventAction;\r\nimport visu.handball.moves.actions.NewAction;\r\nimport visu.handball.moves.actions.NewMoveEventAction;\r\nimport visu.handball.moves.actions.NewPassEventAction;\r\nimport visu.handball.moves.actions.NewSequenceAction;\r\nimport visu.handball.moves.actions.OpenAction;\r\nimport visu.handball.moves.actions.PauseAnimationAction;\r\nimport visu.handball.moves.actions.PrintActualSequenzAction;\r\nimport visu.handball.moves.actions.PrintMoveAction;\r\nimport visu.handball.moves.actions.SaveAction;\r\nimport visu.handball.moves.actions.SetMoveNameAction;\r\nimport visu.handball.moves.actions.StartAnimationAction;\r\nimport visu.handball.moves.actions.StartOneSequenceAnimationAction;\r\nimport visu.handball.moves.actions.StopAnimationAction;\r\nimport visu.handball.moves.controller.CommentController;\r\nimport visu.handball.moves.controller.JMenuHelper;\r\nimport visu.handball.moves.controller.MouseController;\r\nimport visu.handball.moves.model.ColorModel;\r\nimport visu.handball.moves.model.HandballModel;\r\nimport visu.handball.moves.model.TableHandballModel;\r\nimport visu.handball.moves.model.TableSelectionListener;\r\nimport visu.handball.moves.resources.Resources;\r\nimport visu.handball.moves.views.CommentView;\r\nimport visu.handball.moves.views.EventTableCellDelayEditor;\r\nimport visu.handball.moves.views.EventTableCellRenderer;\r\nimport visu.handball.moves.views.Field;\r\nimport visu.handball.moves.views.PlayerToolBar;\r\nimport visu.handball.moves.views.StatusBar;\r\n\r\n/**\r\n * Hauptklasse zum Starten der Anwendung plus den Zugriff auf die entsprechenden Objekt-Instanzen\r\n * @author tommy\r\n */\r\npublic class Main {\r\n\r\n    private static SaveAction saveAction;\r\n\r\n    private static CloseAction closeAction;\r\n\r\n    private static SetMoveNameAction setNameAction;\r\n\r\n    private static JFrame window;\r\n\r\n    private static Field field;\r\n\r\n    private static CommentView commentView;\r\n\r\n    private static ColorModel colorModel;\r\n\r\n    /**\r\n     * Liefert die Instanz des ColorModels\r\n     *\r\n     * @return colorModel\r\n     */\r\n    public static ColorModel getColorModel() {\r\n        return colorModel;\r\n    }\r\n\r\n    /**\r\n     * Main-Methode zum Starten der Anwendung\r\n     *\r\n     * @param args\r\n     */\r\n    public static void main(String[] args) {\r\n        try {\r\n            UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\r\n        } catch (Exception e) {\r\n            System.out.println(//$NON-NLS-1$\r\n            Resources.getString(\"error.lookAndFell\"));\r\n        }\r\n        //$NON-NLS-1$\r\n        window = new JFrame(Resources.getString(\"app.title\"));\r\n        //$NON-NLS-1$ //$NON-NLS-2$\r\n        window.setIconImage(createImageIcon(\"images/icon.gif\", \"\").getImage());\r\n        JPanel content = new JPanel(new BorderLayout());\r\n        JDesktopPane desktop = new JDesktopPane();\r\n        window.setContentPane(content);\r\n        content.add(desktop, BorderLayout.CENTER);\r\n        desktop.setBackground(new Color(255, 255, 174));\r\n        desktop.setDragMode(JDesktopPane.OUTLINE_DRAG_MODE);\r\n        // Create HandballModel\r\n        HandballModel handballModel = createHandballModel();\r\n        // Create ColorModel\r\n        colorModel = new ColorModel();\r\n        // Statusbar\r\n        StatusBar statusBar = createStatusBar(handballModel);\r\n        content.add(statusBar, BorderLayout.SOUTH);\r\n        // Create Menu\r\n        JMenuBar menu = createHandballMenu(handballModel);\r\n        window.setJMenuBar(menu);\r\n        // Create HandballField\r\n        field = new Field(handballModel, colorModel);\r\n        JInternalFrame handballField = new //$NON-NLS-1$\r\n        JInternalFrame(//$NON-NLS-1$\r\n        Resources.getString(\"field.title\"), //$NON-NLS-1$\r\n        false, false, false, true);\r\n        handballField.setLocation(10, 10);\r\n        handballField.add(field);\r\n        handballField.setVisible(true);\r\n        handballField.pack();\r\n        desktop.add(handballField);\r\n        // Create MouseController\r\n        MouseController mouse = new MouseController(handballModel, handballField);\r\n        field.addMouseListener(mouse);\r\n        field.addMouseMotionListener(mouse);\r\n        // Add Statusbar as Listener\r\n        field.addMouseMotionListener(statusBar);\r\n        // Create ToolBar\r\n        PlayerToolBar playerBar = new PlayerToolBar(handballModel);\r\n        content.add(playerBar, BorderLayout.NORTH);\r\n        // Create EventView\r\n        JPanel tablePanel = createTablePanel(handballModel);\r\n        JInternalFrame eventView = new //$NON-NLS-1$\r\n        JInternalFrame(//$NON-NLS-1$\r\n        Resources.getString(\"events.title\"), //$NON-NLS-1$\r\n        true, false, false, true);\r\n        eventView.add(tablePanel);\r\n        eventView.setLocation(20 + handballField.getWidth(), 10);\r\n        eventView.setVisible(true);\r\n        eventView.setSize(450, 400);\r\n        desktop.add(eventView);\r\n        // Create CommentView\r\n        //$NON-NLS-1$\r\n        commentView = new CommentView(Resources.getString(\"comment.title\"));\r\n        commentView.setLocation(20 + handballField.getWidth(), 420);\r\n        commentView.setSize(450, handballField.getHeight() - eventView.getHeight() - 10);\r\n        commentView.setVisible(true);\r\n        //Controller für CommentView erzeugen\r\n        new CommentController(handballModel, commentView);\r\n        desktop.add(commentView);\r\n        window.setSize(1000, 700);\r\n        locateOnScreenCenter(window);\r\n        window.addWindowListener(new WindowAdapter() {\r\n\r\n            public void windowClosing(WindowEvent e) {\r\n                Main.getCloseAction().actionPerformed(null);\r\n            }\r\n        });\r\n        window.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);\r\n        window.setVisible(true);\r\n    }\r\n\r\n    private static JMenuBar createHandballMenu(HandballModel handballModel) {\r\n        JMenuBar mbar;\r\n        JMenu menuDatei, menuHilfe, menuEinstellungen;\r\n        // Hauptmenue einrichten\r\n        mbar = new JMenuBar();\r\n        //$NON-NLS-1$\r\n        menuDatei = JMenuHelper.addMenuBarItem(mbar, Resources.getString(\"menu.file\"));\r\n        //$NON-NLS-1$\r\n        menuEinstellungen = JMenuHelper.addMenuBarItem(mbar, Resources.getString(\"menu.settings\"));\r\n        //$NON-NLS-1$\r\n        menuHilfe = JMenuHelper.addMenuBarItem(mbar, Resources.getString(\"menu.about\"));\r\n        // Einträge fuer Datei\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", new //$NON-NLS-1$\r\n        NewAction(handballModel));\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", new //$NON-NLS-1$\r\n        OpenAction(handballModel));\r\n        //Separator einfügen\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"-\");\r\n        saveAction = new SaveAction(handballModel);\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", saveAction);\r\n        // Separator einfügen\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"-\");\r\n        setNameAction = new SetMoveNameAction(handballModel);\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", setNameAction);\r\n        //Separator einfügen\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"-\");\r\n        //Drucken einfügen\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", new //$NON-NLS-1$\r\n        PrintActualSequenzAction(handballModel));\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", new PrintMoveAction(handballModel));\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", new CreateMovePdfAction(handballModel));\r\n        // Separator einfügen\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"-\");\r\n        closeAction = new CloseAction(handballModel);\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", closeAction);\r\n        // Einträge für Einstellungen\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuEinstellungen, \"\", new ChangeColorsAction());\r\n        // Einträge für Hilfe\r\n        //$NON-NLS-1$\r\n        JMenuHelper.//$NON-NLS-1$\r\n        addMenuItem(//$NON-NLS-1$\r\n        menuHilfe, //$NON-NLS-1$\r\n        \"\", new AboutAction());\r\n        return mbar;\r\n    }\r\n\r\n    private static JPanel createTablePanel(HandballModel handballModel) {\r\n        TableHandballModel tableModel = new TableHandballModel(handballModel);\r\n        JTable table = new JTable(tableModel);\r\n        table.setDefaultRenderer(Object.class, new EventTableCellRenderer());\r\n        table.getColumnModel().getColumn(0).setPreferredWidth(100);\r\n        table.getColumnModel().getColumn(1).setPreferredWidth(200);\r\n        EventTableCellDelayEditor delayEditor = new EventTableCellDelayEditor();\r\n        table.getColumnModel().getColumn(3).setCellEditor(delayEditor);\r\n        table.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\r\n        table.getSelectionModel().addListSelectionListener(new TableSelectionListener(tableModel));\r\n        JPanel panel = new JPanel(new BorderLayout());\r\n        //$NON-NLS-1$\r\n        JToolBar toolBar = new JToolBar(Resources.getString(\"toolbar.title\"));\r\n        toolBar.add(new NewMoveEventAction(handballModel));\r\n        toolBar.add(new NewSequenceAction(handballModel));\r\n        toolBar.add(new NewPassEventAction(handballModel));\r\n        toolBar.add(new DeleteEventAction(handballModel));\r\n        toolBar.addSeparator();\r\n        toolBar.add(new StartOneSequenceAnimationAction(handballModel));\r\n        toolBar.add(new StartAnimationAction(handballModel));\r\n        toolBar.add(new PauseAnimationAction(handballModel));\r\n        toolBar.add(new StopAnimationAction(handballModel));\r\n        JScrollPane scroll = new JScrollPane(table);\r\n        panel.add(scroll, BorderLayout.CENTER);\r\n        panel.add(toolBar, BorderLayout.PAGE_START);\r\n        return panel;\r\n    }\r\n\r\n    private static StatusBar createStatusBar(HandballModel model) {\r\n        StatusBar statusBar = new StatusBar(model);\r\n        return statusBar;\r\n    }\r\n\r\n    /**\r\n     * Basierend auf der relativen Pfad (relativ zum Ort dieser Klasse) und der Beschreibung\r\n     * wird ein Grafik geladen und ein ImageIcon-Objekt erstellt.\r\n     * @param path\r\n     * @param description\r\n     *\r\n     * @return imageIcon\r\n     */\r\n    public static ImageIcon createImageIcon(String path, String description) {\r\n        URL url = Main.class.getResource(path);\r\n        return new ImageIcon(url, description);\r\n    }\r\n\r\n    /**\r\n     * Erzeugt auf Basis eines relativen Pfads (relativ zum Ort dieser Klasse) eine URL.\r\n     * @param path\r\n     *\r\n     * @return url\r\n     */\r\n    public static URL getResource(String path) {\r\n        return Main.class.getResource(path);\r\n    }\r\n\r\n    /**\r\n     * Methode um Component-Objekte (z.B. Fenster) in der Mitte des Bildschirms zu positionieren\r\n     * @param component\r\n     */\r\n    public static void locateOnScreenCenter(Component component) {\r\n        Dimension paneSize = component.getSize();\r\n        Dimension screenSize = component.getToolkit().getScreenSize();\r\n        component.setLocation((screenSize.width - paneSize.width) / 2, (screenSize.height - paneSize.height) / 2);\r\n    }\r\n\r\n    private static HandballModel createHandballModel() {\r\n        HandballModel model = new HandballModel();\r\n        return model;\r\n    }\r\n\r\n    /**\r\n     * Die Instanz des Anwendungsfensters\r\n     *\r\n     * @return window\r\n     */\r\n    public static JFrame getWindow() {\r\n        return window;\r\n    }\r\n\r\n    /**\r\n     * Instanz des Spielfeld-Panels\r\n     *\r\n     * @return panel\r\n     */\r\n    public static Field getField() {\r\n        return field;\r\n    }\r\n\r\n    /**\r\n     * Instanz der Speichern-Aktion\r\n     *\r\n     * @return saveAction\r\n     */\r\n    public static SaveAction getSaveAction() {\r\n        return saveAction;\r\n    }\r\n\r\n    public static SetMoveNameAction getSetNameAction() {\r\n        return setNameAction;\r\n    }\r\n\r\n    /**\r\n     * Instanz der Schlie�en-Aktion\r\n     *\r\n     * @return close Action\r\n     */\r\n    public static CloseAction getCloseAction() {\r\n        return closeAction;\r\n    }\r\n\r\n    /**\r\n     * Methode um eine tiefe Objektkopie per Serialisierung zu erzeugen!\r\n     *\r\n     * @param oldObj (muss Serializable implementieren)\r\n     * @return tiefe Kopie\r\n     * @throws Exception\r\n     */\r\n    public static Object deepCopy(Object oldObj) throws Exception {\r\n        Object clone = null;\r\n        try {\r\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n            ObjectOutputStream oos = new ObjectOutputStream(baos);\r\n            oos.writeObject(oldObj);\r\n            oos.flush();\r\n            ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray()));\r\n            clone = ois.readObject();\r\n            oos.close();\r\n            ois.close();\r\n        } catch (Exception e) {\r\n            //$NON-NLS-1$\r\n            System.out.println(\"Exception in ObjectCloner = \" + e);\r\n            throw (e);\r\n        }\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Liefert die Version der Anwendung als String\r\n     *\r\n     * @return version\r\n     */\r\n    public static String getVersion() {\r\n        //$NON-NLS-1$\r\n        return \"1.0.5\";\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/MainTest3.java",
		"test_prompt": "// MainTest3.java\npackage visu.handball.moves;\n\nimport java.awt.BorderLayout;\nimport java.awt.Color;\nimport java.awt.Component;\nimport java.awt.Dimension;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.net.URL;\nimport javax.swing.ImageIcon;\nimport javax.swing.JDesktopPane;\nimport javax.swing.JFrame;\nimport javax.swing.JInternalFrame;\nimport javax.swing.JMenu;\nimport javax.swing.JMenuBar;\nimport javax.swing.JPanel;\nimport javax.swing.JScrollPane;\nimport javax.swing.JTable;\nimport javax.swing.JToolBar;\nimport javax.swing.ListSelectionModel;\nimport javax.swing.UIManager;\nimport visu.handball.moves.actions.AboutAction;\nimport visu.handball.moves.actions.ChangeColorsAction;\nimport visu.handball.moves.actions.CloseAction;\nimport visu.handball.moves.actions.CreateMovePdfAction;\nimport visu.handball.moves.actions.DeleteEventAction;\nimport visu.handball.moves.actions.NewAction;\nimport visu.handball.moves.actions.NewMoveEventAction;\nimport visu.handball.moves.actions.NewPassEventAction;\nimport visu.handball.moves.actions.NewSequenceAction;\nimport visu.handball.moves.actions.OpenAction;\nimport visu.handball.moves.actions.PauseAnimationAction;\nimport visu.handball.moves.actions.PrintActualSequenzAction;\nimport visu.handball.moves.actions.PrintMoveAction;\nimport visu.handball.moves.actions.SaveAction;\nimport visu.handball.moves.actions.SetMoveNameAction;\nimport visu.handball.moves.actions.StartAnimationAction;\nimport visu.handball.moves.actions.StartOneSequenceAnimationAction;\nimport visu.handball.moves.actions.StopAnimationAction;\nimport visu.handball.moves.controller.CommentController;\nimport visu.handball.moves.controller.JMenuHelper;\nimport visu.handball.moves.controller.MouseController;\nimport visu.handball.moves.model.ColorModel;\nimport visu.handball.moves.model.HandballModel;\nimport visu.handball.moves.model.TableHandballModel;\nimport visu.handball.moves.model.TableSelectionListener;\nimport visu.handball.moves.resources.Resources;\nimport visu.handball.moves.views.CommentView;\nimport visu.handball.moves.views.EventTableCellDelayEditor;\nimport visu.handball.moves.views.EventTableCellRenderer;\nimport visu.handball.moves.views.Field;\nimport visu.handball.moves.views.PlayerToolBar;\nimport visu.handball.moves.views.StatusBar;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Main}.\n* It contains ten unit test cases for the {@link Main#getWindow()} method.\n*/\nclass MainTest3 {"
	},
	{
		"original_code": "// Main.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves;\r\n\r\nimport java.awt.BorderLayout;\r\nimport java.awt.Color;\r\nimport java.awt.Component;\r\nimport java.awt.Dimension;\r\nimport java.awt.event.WindowAdapter;\r\nimport java.awt.event.WindowEvent;\r\nimport java.io.ByteArrayInputStream;\r\nimport java.io.ByteArrayOutputStream;\r\nimport java.io.ObjectInputStream;\r\nimport java.io.ObjectOutputStream;\r\nimport java.net.URL;\r\nimport javax.swing.ImageIcon;\r\nimport javax.swing.JDesktopPane;\r\nimport javax.swing.JFrame;\r\nimport javax.swing.JInternalFrame;\r\nimport javax.swing.JMenu;\r\nimport javax.swing.JMenuBar;\r\nimport javax.swing.JPanel;\r\nimport javax.swing.JScrollPane;\r\nimport javax.swing.JTable;\r\nimport javax.swing.JToolBar;\r\nimport javax.swing.ListSelectionModel;\r\nimport javax.swing.UIManager;\r\nimport visu.handball.moves.actions.AboutAction;\r\nimport visu.handball.moves.actions.ChangeColorsAction;\r\nimport visu.handball.moves.actions.CloseAction;\r\nimport visu.handball.moves.actions.CreateMovePdfAction;\r\nimport visu.handball.moves.actions.DeleteEventAction;\r\nimport visu.handball.moves.actions.NewAction;\r\nimport visu.handball.moves.actions.NewMoveEventAction;\r\nimport visu.handball.moves.actions.NewPassEventAction;\r\nimport visu.handball.moves.actions.NewSequenceAction;\r\nimport visu.handball.moves.actions.OpenAction;\r\nimport visu.handball.moves.actions.PauseAnimationAction;\r\nimport visu.handball.moves.actions.PrintActualSequenzAction;\r\nimport visu.handball.moves.actions.PrintMoveAction;\r\nimport visu.handball.moves.actions.SaveAction;\r\nimport visu.handball.moves.actions.SetMoveNameAction;\r\nimport visu.handball.moves.actions.StartAnimationAction;\r\nimport visu.handball.moves.actions.StartOneSequenceAnimationAction;\r\nimport visu.handball.moves.actions.StopAnimationAction;\r\nimport visu.handball.moves.controller.CommentController;\r\nimport visu.handball.moves.controller.JMenuHelper;\r\nimport visu.handball.moves.controller.MouseController;\r\nimport visu.handball.moves.model.ColorModel;\r\nimport visu.handball.moves.model.HandballModel;\r\nimport visu.handball.moves.model.TableHandballModel;\r\nimport visu.handball.moves.model.TableSelectionListener;\r\nimport visu.handball.moves.resources.Resources;\r\nimport visu.handball.moves.views.CommentView;\r\nimport visu.handball.moves.views.EventTableCellDelayEditor;\r\nimport visu.handball.moves.views.EventTableCellRenderer;\r\nimport visu.handball.moves.views.Field;\r\nimport visu.handball.moves.views.PlayerToolBar;\r\nimport visu.handball.moves.views.StatusBar;\r\n\r\n/**\r\n * Hauptklasse zum Starten der Anwendung plus den Zugriff auf die entsprechenden Objekt-Instanzen\r\n * @author tommy\r\n */\r\npublic class Main {\r\n\r\n    private static SaveAction saveAction;\r\n\r\n    private static CloseAction closeAction;\r\n\r\n    private static SetMoveNameAction setNameAction;\r\n\r\n    private static JFrame window;\r\n\r\n    private static Field field;\r\n\r\n    private static CommentView commentView;\r\n\r\n    private static ColorModel colorModel;\r\n\r\n    /**\r\n     * Liefert die Instanz des ColorModels\r\n     *\r\n     * @return colorModel\r\n     */\r\n    public static ColorModel getColorModel() {\r\n        return colorModel;\r\n    }\r\n\r\n    /**\r\n     * Main-Methode zum Starten der Anwendung\r\n     *\r\n     * @param args\r\n     */\r\n    public static void main(String[] args) {\r\n        try {\r\n            UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\r\n        } catch (Exception e) {\r\n            System.out.println(//$NON-NLS-1$\r\n            Resources.getString(\"error.lookAndFell\"));\r\n        }\r\n        //$NON-NLS-1$\r\n        window = new JFrame(Resources.getString(\"app.title\"));\r\n        //$NON-NLS-1$ //$NON-NLS-2$\r\n        window.setIconImage(createImageIcon(\"images/icon.gif\", \"\").getImage());\r\n        JPanel content = new JPanel(new BorderLayout());\r\n        JDesktopPane desktop = new JDesktopPane();\r\n        window.setContentPane(content);\r\n        content.add(desktop, BorderLayout.CENTER);\r\n        desktop.setBackground(new Color(255, 255, 174));\r\n        desktop.setDragMode(JDesktopPane.OUTLINE_DRAG_MODE);\r\n        // Create HandballModel\r\n        HandballModel handballModel = createHandballModel();\r\n        // Create ColorModel\r\n        colorModel = new ColorModel();\r\n        // Statusbar\r\n        StatusBar statusBar = createStatusBar(handballModel);\r\n        content.add(statusBar, BorderLayout.SOUTH);\r\n        // Create Menu\r\n        JMenuBar menu = createHandballMenu(handballModel);\r\n        window.setJMenuBar(menu);\r\n        // Create HandballField\r\n        field = new Field(handballModel, colorModel);\r\n        JInternalFrame handballField = new //$NON-NLS-1$\r\n        JInternalFrame(//$NON-NLS-1$\r\n        Resources.getString(\"field.title\"), //$NON-NLS-1$\r\n        false, false, false, true);\r\n        handballField.setLocation(10, 10);\r\n        handballField.add(field);\r\n        handballField.setVisible(true);\r\n        handballField.pack();\r\n        desktop.add(handballField);\r\n        // Create MouseController\r\n        MouseController mouse = new MouseController(handballModel, handballField);\r\n        field.addMouseListener(mouse);\r\n        field.addMouseMotionListener(mouse);\r\n        // Add Statusbar as Listener\r\n        field.addMouseMotionListener(statusBar);\r\n        // Create ToolBar\r\n        PlayerToolBar playerBar = new PlayerToolBar(handballModel);\r\n        content.add(playerBar, BorderLayout.NORTH);\r\n        // Create EventView\r\n        JPanel tablePanel = createTablePanel(handballModel);\r\n        JInternalFrame eventView = new //$NON-NLS-1$\r\n        JInternalFrame(//$NON-NLS-1$\r\n        Resources.getString(\"events.title\"), //$NON-NLS-1$\r\n        true, false, false, true);\r\n        eventView.add(tablePanel);\r\n        eventView.setLocation(20 + handballField.getWidth(), 10);\r\n        eventView.setVisible(true);\r\n        eventView.setSize(450, 400);\r\n        desktop.add(eventView);\r\n        // Create CommentView\r\n        //$NON-NLS-1$\r\n        commentView = new CommentView(Resources.getString(\"comment.title\"));\r\n        commentView.setLocation(20 + handballField.getWidth(), 420);\r\n        commentView.setSize(450, handballField.getHeight() - eventView.getHeight() - 10);\r\n        commentView.setVisible(true);\r\n        //Controller für CommentView erzeugen\r\n        new CommentController(handballModel, commentView);\r\n        desktop.add(commentView);\r\n        window.setSize(1000, 700);\r\n        locateOnScreenCenter(window);\r\n        window.addWindowListener(new WindowAdapter() {\r\n\r\n            public void windowClosing(WindowEvent e) {\r\n                Main.getCloseAction().actionPerformed(null);\r\n            }\r\n        });\r\n        window.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);\r\n        window.setVisible(true);\r\n    }\r\n\r\n    private static JMenuBar createHandballMenu(HandballModel handballModel) {\r\n        JMenuBar mbar;\r\n        JMenu menuDatei, menuHilfe, menuEinstellungen;\r\n        // Hauptmenue einrichten\r\n        mbar = new JMenuBar();\r\n        //$NON-NLS-1$\r\n        menuDatei = JMenuHelper.addMenuBarItem(mbar, Resources.getString(\"menu.file\"));\r\n        //$NON-NLS-1$\r\n        menuEinstellungen = JMenuHelper.addMenuBarItem(mbar, Resources.getString(\"menu.settings\"));\r\n        //$NON-NLS-1$\r\n        menuHilfe = JMenuHelper.addMenuBarItem(mbar, Resources.getString(\"menu.about\"));\r\n        // Einträge fuer Datei\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", new //$NON-NLS-1$\r\n        NewAction(handballModel));\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", new //$NON-NLS-1$\r\n        OpenAction(handballModel));\r\n        //Separator einfügen\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"-\");\r\n        saveAction = new SaveAction(handballModel);\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", saveAction);\r\n        // Separator einfügen\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"-\");\r\n        setNameAction = new SetMoveNameAction(handballModel);\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", setNameAction);\r\n        //Separator einfügen\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"-\");\r\n        //Drucken einfügen\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", new //$NON-NLS-1$\r\n        PrintActualSequenzAction(handballModel));\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", new PrintMoveAction(handballModel));\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", new CreateMovePdfAction(handballModel));\r\n        // Separator einfügen\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"-\");\r\n        closeAction = new CloseAction(handballModel);\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", closeAction);\r\n        // Einträge für Einstellungen\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuEinstellungen, \"\", new ChangeColorsAction());\r\n        // Einträge für Hilfe\r\n        //$NON-NLS-1$\r\n        JMenuHelper.//$NON-NLS-1$\r\n        addMenuItem(//$NON-NLS-1$\r\n        menuHilfe, //$NON-NLS-1$\r\n        \"\", new AboutAction());\r\n        return mbar;\r\n    }\r\n\r\n    private static JPanel createTablePanel(HandballModel handballModel) {\r\n        TableHandballModel tableModel = new TableHandballModel(handballModel);\r\n        JTable table = new JTable(tableModel);\r\n        table.setDefaultRenderer(Object.class, new EventTableCellRenderer());\r\n        table.getColumnModel().getColumn(0).setPreferredWidth(100);\r\n        table.getColumnModel().getColumn(1).setPreferredWidth(200);\r\n        EventTableCellDelayEditor delayEditor = new EventTableCellDelayEditor();\r\n        table.getColumnModel().getColumn(3).setCellEditor(delayEditor);\r\n        table.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\r\n        table.getSelectionModel().addListSelectionListener(new TableSelectionListener(tableModel));\r\n        JPanel panel = new JPanel(new BorderLayout());\r\n        //$NON-NLS-1$\r\n        JToolBar toolBar = new JToolBar(Resources.getString(\"toolbar.title\"));\r\n        toolBar.add(new NewMoveEventAction(handballModel));\r\n        toolBar.add(new NewSequenceAction(handballModel));\r\n        toolBar.add(new NewPassEventAction(handballModel));\r\n        toolBar.add(new DeleteEventAction(handballModel));\r\n        toolBar.addSeparator();\r\n        toolBar.add(new StartOneSequenceAnimationAction(handballModel));\r\n        toolBar.add(new StartAnimationAction(handballModel));\r\n        toolBar.add(new PauseAnimationAction(handballModel));\r\n        toolBar.add(new StopAnimationAction(handballModel));\r\n        JScrollPane scroll = new JScrollPane(table);\r\n        panel.add(scroll, BorderLayout.CENTER);\r\n        panel.add(toolBar, BorderLayout.PAGE_START);\r\n        return panel;\r\n    }\r\n\r\n    private static StatusBar createStatusBar(HandballModel model) {\r\n        StatusBar statusBar = new StatusBar(model);\r\n        return statusBar;\r\n    }\r\n\r\n    /**\r\n     * Basierend auf der relativen Pfad (relativ zum Ort dieser Klasse) und der Beschreibung\r\n     * wird ein Grafik geladen und ein ImageIcon-Objekt erstellt.\r\n     * @param path\r\n     * @param description\r\n     *\r\n     * @return imageIcon\r\n     */\r\n    public static ImageIcon createImageIcon(String path, String description) {\r\n        URL url = Main.class.getResource(path);\r\n        return new ImageIcon(url, description);\r\n    }\r\n\r\n    /**\r\n     * Erzeugt auf Basis eines relativen Pfads (relativ zum Ort dieser Klasse) eine URL.\r\n     * @param path\r\n     *\r\n     * @return url\r\n     */\r\n    public static URL getResource(String path) {\r\n        return Main.class.getResource(path);\r\n    }\r\n\r\n    /**\r\n     * Methode um Component-Objekte (z.B. Fenster) in der Mitte des Bildschirms zu positionieren\r\n     * @param component\r\n     */\r\n    public static void locateOnScreenCenter(Component component) {\r\n        Dimension paneSize = component.getSize();\r\n        Dimension screenSize = component.getToolkit().getScreenSize();\r\n        component.setLocation((screenSize.width - paneSize.width) / 2, (screenSize.height - paneSize.height) / 2);\r\n    }\r\n\r\n    private static HandballModel createHandballModel() {\r\n        HandballModel model = new HandballModel();\r\n        return model;\r\n    }\r\n\r\n    /**\r\n     * Die Instanz des Anwendungsfensters\r\n     *\r\n     * @return window\r\n     */\r\n    public static JFrame getWindow() {\r\n        return window;\r\n    }\r\n\r\n    /**\r\n     * Instanz des Spielfeld-Panels\r\n     *\r\n     * @return panel\r\n     */\r\n    public static Field getField() {\r\n        return field;\r\n    }\r\n\r\n    /**\r\n     * Instanz der Speichern-Aktion\r\n     *\r\n     * @return saveAction\r\n     */\r\n    public static SaveAction getSaveAction() {\r\n        return saveAction;\r\n    }\r\n\r\n    public static SetMoveNameAction getSetNameAction() {\r\n        return setNameAction;\r\n    }\r\n\r\n    /**\r\n     * Instanz der Schlie�en-Aktion\r\n     *\r\n     * @return close Action\r\n     */\r\n    public static CloseAction getCloseAction() {\r\n        return closeAction;\r\n    }\r\n\r\n    /**\r\n     * Methode um eine tiefe Objektkopie per Serialisierung zu erzeugen!\r\n     *\r\n     * @param oldObj (muss Serializable implementieren)\r\n     * @return tiefe Kopie\r\n     * @throws Exception\r\n     */\r\n    public static Object deepCopy(Object oldObj) throws Exception {\r\n        Object clone = null;\r\n        try {\r\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n            ObjectOutputStream oos = new ObjectOutputStream(baos);\r\n            oos.writeObject(oldObj);\r\n            oos.flush();\r\n            ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray()));\r\n            clone = ois.readObject();\r\n            oos.close();\r\n            ois.close();\r\n        } catch (Exception e) {\r\n            //$NON-NLS-1$\r\n            System.out.println(\"Exception in ObjectCloner = \" + e);\r\n            throw (e);\r\n        }\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Liefert die Version der Anwendung als String\r\n     *\r\n     * @return version\r\n     */\r\n    public static String getVersion() {\r\n        //$NON-NLS-1$\r\n        return \"1.0.5\";\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/MainTest4.java",
		"test_prompt": "// MainTest4.java\npackage visu.handball.moves;\n\nimport java.awt.BorderLayout;\nimport java.awt.Color;\nimport java.awt.Component;\nimport java.awt.Dimension;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.net.URL;\nimport javax.swing.ImageIcon;\nimport javax.swing.JDesktopPane;\nimport javax.swing.JFrame;\nimport javax.swing.JInternalFrame;\nimport javax.swing.JMenu;\nimport javax.swing.JMenuBar;\nimport javax.swing.JPanel;\nimport javax.swing.JScrollPane;\nimport javax.swing.JTable;\nimport javax.swing.JToolBar;\nimport javax.swing.ListSelectionModel;\nimport javax.swing.UIManager;\nimport visu.handball.moves.actions.AboutAction;\nimport visu.handball.moves.actions.ChangeColorsAction;\nimport visu.handball.moves.actions.CloseAction;\nimport visu.handball.moves.actions.CreateMovePdfAction;\nimport visu.handball.moves.actions.DeleteEventAction;\nimport visu.handball.moves.actions.NewAction;\nimport visu.handball.moves.actions.NewMoveEventAction;\nimport visu.handball.moves.actions.NewPassEventAction;\nimport visu.handball.moves.actions.NewSequenceAction;\nimport visu.handball.moves.actions.OpenAction;\nimport visu.handball.moves.actions.PauseAnimationAction;\nimport visu.handball.moves.actions.PrintActualSequenzAction;\nimport visu.handball.moves.actions.PrintMoveAction;\nimport visu.handball.moves.actions.SaveAction;\nimport visu.handball.moves.actions.SetMoveNameAction;\nimport visu.handball.moves.actions.StartAnimationAction;\nimport visu.handball.moves.actions.StartOneSequenceAnimationAction;\nimport visu.handball.moves.actions.StopAnimationAction;\nimport visu.handball.moves.controller.CommentController;\nimport visu.handball.moves.controller.JMenuHelper;\nimport visu.handball.moves.controller.MouseController;\nimport visu.handball.moves.model.ColorModel;\nimport visu.handball.moves.model.HandballModel;\nimport visu.handball.moves.model.TableHandballModel;\nimport visu.handball.moves.model.TableSelectionListener;\nimport visu.handball.moves.resources.Resources;\nimport visu.handball.moves.views.CommentView;\nimport visu.handball.moves.views.EventTableCellDelayEditor;\nimport visu.handball.moves.views.EventTableCellRenderer;\nimport visu.handball.moves.views.Field;\nimport visu.handball.moves.views.PlayerToolBar;\nimport visu.handball.moves.views.StatusBar;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Main}.\n* It contains ten unit test cases for the {@link Main#getField()} method.\n*/\nclass MainTest4 {"
	},
	{
		"original_code": "// Main.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves;\r\n\r\nimport java.awt.BorderLayout;\r\nimport java.awt.Color;\r\nimport java.awt.Component;\r\nimport java.awt.Dimension;\r\nimport java.awt.event.WindowAdapter;\r\nimport java.awt.event.WindowEvent;\r\nimport java.io.ByteArrayInputStream;\r\nimport java.io.ByteArrayOutputStream;\r\nimport java.io.ObjectInputStream;\r\nimport java.io.ObjectOutputStream;\r\nimport java.net.URL;\r\nimport javax.swing.ImageIcon;\r\nimport javax.swing.JDesktopPane;\r\nimport javax.swing.JFrame;\r\nimport javax.swing.JInternalFrame;\r\nimport javax.swing.JMenu;\r\nimport javax.swing.JMenuBar;\r\nimport javax.swing.JPanel;\r\nimport javax.swing.JScrollPane;\r\nimport javax.swing.JTable;\r\nimport javax.swing.JToolBar;\r\nimport javax.swing.ListSelectionModel;\r\nimport javax.swing.UIManager;\r\nimport visu.handball.moves.actions.AboutAction;\r\nimport visu.handball.moves.actions.ChangeColorsAction;\r\nimport visu.handball.moves.actions.CloseAction;\r\nimport visu.handball.moves.actions.CreateMovePdfAction;\r\nimport visu.handball.moves.actions.DeleteEventAction;\r\nimport visu.handball.moves.actions.NewAction;\r\nimport visu.handball.moves.actions.NewMoveEventAction;\r\nimport visu.handball.moves.actions.NewPassEventAction;\r\nimport visu.handball.moves.actions.NewSequenceAction;\r\nimport visu.handball.moves.actions.OpenAction;\r\nimport visu.handball.moves.actions.PauseAnimationAction;\r\nimport visu.handball.moves.actions.PrintActualSequenzAction;\r\nimport visu.handball.moves.actions.PrintMoveAction;\r\nimport visu.handball.moves.actions.SaveAction;\r\nimport visu.handball.moves.actions.SetMoveNameAction;\r\nimport visu.handball.moves.actions.StartAnimationAction;\r\nimport visu.handball.moves.actions.StartOneSequenceAnimationAction;\r\nimport visu.handball.moves.actions.StopAnimationAction;\r\nimport visu.handball.moves.controller.CommentController;\r\nimport visu.handball.moves.controller.JMenuHelper;\r\nimport visu.handball.moves.controller.MouseController;\r\nimport visu.handball.moves.model.ColorModel;\r\nimport visu.handball.moves.model.HandballModel;\r\nimport visu.handball.moves.model.TableHandballModel;\r\nimport visu.handball.moves.model.TableSelectionListener;\r\nimport visu.handball.moves.resources.Resources;\r\nimport visu.handball.moves.views.CommentView;\r\nimport visu.handball.moves.views.EventTableCellDelayEditor;\r\nimport visu.handball.moves.views.EventTableCellRenderer;\r\nimport visu.handball.moves.views.Field;\r\nimport visu.handball.moves.views.PlayerToolBar;\r\nimport visu.handball.moves.views.StatusBar;\r\n\r\n/**\r\n * Hauptklasse zum Starten der Anwendung plus den Zugriff auf die entsprechenden Objekt-Instanzen\r\n * @author tommy\r\n */\r\npublic class Main {\r\n\r\n    private static SaveAction saveAction;\r\n\r\n    private static CloseAction closeAction;\r\n\r\n    private static SetMoveNameAction setNameAction;\r\n\r\n    private static JFrame window;\r\n\r\n    private static Field field;\r\n\r\n    private static CommentView commentView;\r\n\r\n    private static ColorModel colorModel;\r\n\r\n    /**\r\n     * Liefert die Instanz des ColorModels\r\n     *\r\n     * @return colorModel\r\n     */\r\n    public static ColorModel getColorModel() {\r\n        return colorModel;\r\n    }\r\n\r\n    /**\r\n     * Main-Methode zum Starten der Anwendung\r\n     *\r\n     * @param args\r\n     */\r\n    public static void main(String[] args) {\r\n        try {\r\n            UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\r\n        } catch (Exception e) {\r\n            System.out.println(//$NON-NLS-1$\r\n            Resources.getString(\"error.lookAndFell\"));\r\n        }\r\n        //$NON-NLS-1$\r\n        window = new JFrame(Resources.getString(\"app.title\"));\r\n        //$NON-NLS-1$ //$NON-NLS-2$\r\n        window.setIconImage(createImageIcon(\"images/icon.gif\", \"\").getImage());\r\n        JPanel content = new JPanel(new BorderLayout());\r\n        JDesktopPane desktop = new JDesktopPane();\r\n        window.setContentPane(content);\r\n        content.add(desktop, BorderLayout.CENTER);\r\n        desktop.setBackground(new Color(255, 255, 174));\r\n        desktop.setDragMode(JDesktopPane.OUTLINE_DRAG_MODE);\r\n        // Create HandballModel\r\n        HandballModel handballModel = createHandballModel();\r\n        // Create ColorModel\r\n        colorModel = new ColorModel();\r\n        // Statusbar\r\n        StatusBar statusBar = createStatusBar(handballModel);\r\n        content.add(statusBar, BorderLayout.SOUTH);\r\n        // Create Menu\r\n        JMenuBar menu = createHandballMenu(handballModel);\r\n        window.setJMenuBar(menu);\r\n        // Create HandballField\r\n        field = new Field(handballModel, colorModel);\r\n        JInternalFrame handballField = new //$NON-NLS-1$\r\n        JInternalFrame(//$NON-NLS-1$\r\n        Resources.getString(\"field.title\"), //$NON-NLS-1$\r\n        false, false, false, true);\r\n        handballField.setLocation(10, 10);\r\n        handballField.add(field);\r\n        handballField.setVisible(true);\r\n        handballField.pack();\r\n        desktop.add(handballField);\r\n        // Create MouseController\r\n        MouseController mouse = new MouseController(handballModel, handballField);\r\n        field.addMouseListener(mouse);\r\n        field.addMouseMotionListener(mouse);\r\n        // Add Statusbar as Listener\r\n        field.addMouseMotionListener(statusBar);\r\n        // Create ToolBar\r\n        PlayerToolBar playerBar = new PlayerToolBar(handballModel);\r\n        content.add(playerBar, BorderLayout.NORTH);\r\n        // Create EventView\r\n        JPanel tablePanel = createTablePanel(handballModel);\r\n        JInternalFrame eventView = new //$NON-NLS-1$\r\n        JInternalFrame(//$NON-NLS-1$\r\n        Resources.getString(\"events.title\"), //$NON-NLS-1$\r\n        true, false, false, true);\r\n        eventView.add(tablePanel);\r\n        eventView.setLocation(20 + handballField.getWidth(), 10);\r\n        eventView.setVisible(true);\r\n        eventView.setSize(450, 400);\r\n        desktop.add(eventView);\r\n        // Create CommentView\r\n        //$NON-NLS-1$\r\n        commentView = new CommentView(Resources.getString(\"comment.title\"));\r\n        commentView.setLocation(20 + handballField.getWidth(), 420);\r\n        commentView.setSize(450, handballField.getHeight() - eventView.getHeight() - 10);\r\n        commentView.setVisible(true);\r\n        //Controller für CommentView erzeugen\r\n        new CommentController(handballModel, commentView);\r\n        desktop.add(commentView);\r\n        window.setSize(1000, 700);\r\n        locateOnScreenCenter(window);\r\n        window.addWindowListener(new WindowAdapter() {\r\n\r\n            public void windowClosing(WindowEvent e) {\r\n                Main.getCloseAction().actionPerformed(null);\r\n            }\r\n        });\r\n        window.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);\r\n        window.setVisible(true);\r\n    }\r\n\r\n    private static JMenuBar createHandballMenu(HandballModel handballModel) {\r\n        JMenuBar mbar;\r\n        JMenu menuDatei, menuHilfe, menuEinstellungen;\r\n        // Hauptmenue einrichten\r\n        mbar = new JMenuBar();\r\n        //$NON-NLS-1$\r\n        menuDatei = JMenuHelper.addMenuBarItem(mbar, Resources.getString(\"menu.file\"));\r\n        //$NON-NLS-1$\r\n        menuEinstellungen = JMenuHelper.addMenuBarItem(mbar, Resources.getString(\"menu.settings\"));\r\n        //$NON-NLS-1$\r\n        menuHilfe = JMenuHelper.addMenuBarItem(mbar, Resources.getString(\"menu.about\"));\r\n        // Einträge fuer Datei\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", new //$NON-NLS-1$\r\n        NewAction(handballModel));\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", new //$NON-NLS-1$\r\n        OpenAction(handballModel));\r\n        //Separator einfügen\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"-\");\r\n        saveAction = new SaveAction(handballModel);\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", saveAction);\r\n        // Separator einfügen\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"-\");\r\n        setNameAction = new SetMoveNameAction(handballModel);\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", setNameAction);\r\n        //Separator einfügen\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"-\");\r\n        //Drucken einfügen\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", new //$NON-NLS-1$\r\n        PrintActualSequenzAction(handballModel));\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", new PrintMoveAction(handballModel));\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", new CreateMovePdfAction(handballModel));\r\n        // Separator einfügen\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"-\");\r\n        closeAction = new CloseAction(handballModel);\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", closeAction);\r\n        // Einträge für Einstellungen\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuEinstellungen, \"\", new ChangeColorsAction());\r\n        // Einträge für Hilfe\r\n        //$NON-NLS-1$\r\n        JMenuHelper.//$NON-NLS-1$\r\n        addMenuItem(//$NON-NLS-1$\r\n        menuHilfe, //$NON-NLS-1$\r\n        \"\", new AboutAction());\r\n        return mbar;\r\n    }\r\n\r\n    private static JPanel createTablePanel(HandballModel handballModel) {\r\n        TableHandballModel tableModel = new TableHandballModel(handballModel);\r\n        JTable table = new JTable(tableModel);\r\n        table.setDefaultRenderer(Object.class, new EventTableCellRenderer());\r\n        table.getColumnModel().getColumn(0).setPreferredWidth(100);\r\n        table.getColumnModel().getColumn(1).setPreferredWidth(200);\r\n        EventTableCellDelayEditor delayEditor = new EventTableCellDelayEditor();\r\n        table.getColumnModel().getColumn(3).setCellEditor(delayEditor);\r\n        table.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\r\n        table.getSelectionModel().addListSelectionListener(new TableSelectionListener(tableModel));\r\n        JPanel panel = new JPanel(new BorderLayout());\r\n        //$NON-NLS-1$\r\n        JToolBar toolBar = new JToolBar(Resources.getString(\"toolbar.title\"));\r\n        toolBar.add(new NewMoveEventAction(handballModel));\r\n        toolBar.add(new NewSequenceAction(handballModel));\r\n        toolBar.add(new NewPassEventAction(handballModel));\r\n        toolBar.add(new DeleteEventAction(handballModel));\r\n        toolBar.addSeparator();\r\n        toolBar.add(new StartOneSequenceAnimationAction(handballModel));\r\n        toolBar.add(new StartAnimationAction(handballModel));\r\n        toolBar.add(new PauseAnimationAction(handballModel));\r\n        toolBar.add(new StopAnimationAction(handballModel));\r\n        JScrollPane scroll = new JScrollPane(table);\r\n        panel.add(scroll, BorderLayout.CENTER);\r\n        panel.add(toolBar, BorderLayout.PAGE_START);\r\n        return panel;\r\n    }\r\n\r\n    private static StatusBar createStatusBar(HandballModel model) {\r\n        StatusBar statusBar = new StatusBar(model);\r\n        return statusBar;\r\n    }\r\n\r\n    /**\r\n     * Basierend auf der relativen Pfad (relativ zum Ort dieser Klasse) und der Beschreibung\r\n     * wird ein Grafik geladen und ein ImageIcon-Objekt erstellt.\r\n     * @param path\r\n     * @param description\r\n     *\r\n     * @return imageIcon\r\n     */\r\n    public static ImageIcon createImageIcon(String path, String description) {\r\n        URL url = Main.class.getResource(path);\r\n        return new ImageIcon(url, description);\r\n    }\r\n\r\n    /**\r\n     * Erzeugt auf Basis eines relativen Pfads (relativ zum Ort dieser Klasse) eine URL.\r\n     * @param path\r\n     *\r\n     * @return url\r\n     */\r\n    public static URL getResource(String path) {\r\n        return Main.class.getResource(path);\r\n    }\r\n\r\n    /**\r\n     * Methode um Component-Objekte (z.B. Fenster) in der Mitte des Bildschirms zu positionieren\r\n     * @param component\r\n     */\r\n    public static void locateOnScreenCenter(Component component) {\r\n        Dimension paneSize = component.getSize();\r\n        Dimension screenSize = component.getToolkit().getScreenSize();\r\n        component.setLocation((screenSize.width - paneSize.width) / 2, (screenSize.height - paneSize.height) / 2);\r\n    }\r\n\r\n    private static HandballModel createHandballModel() {\r\n        HandballModel model = new HandballModel();\r\n        return model;\r\n    }\r\n\r\n    /**\r\n     * Die Instanz des Anwendungsfensters\r\n     *\r\n     * @return window\r\n     */\r\n    public static JFrame getWindow() {\r\n        return window;\r\n    }\r\n\r\n    /**\r\n     * Instanz des Spielfeld-Panels\r\n     *\r\n     * @return panel\r\n     */\r\n    public static Field getField() {\r\n        return field;\r\n    }\r\n\r\n    /**\r\n     * Instanz der Speichern-Aktion\r\n     *\r\n     * @return saveAction\r\n     */\r\n    public static SaveAction getSaveAction() {\r\n        return saveAction;\r\n    }\r\n\r\n    public static SetMoveNameAction getSetNameAction() {\r\n        return setNameAction;\r\n    }\r\n\r\n    /**\r\n     * Instanz der Schlie�en-Aktion\r\n     *\r\n     * @return close Action\r\n     */\r\n    public static CloseAction getCloseAction() {\r\n        return closeAction;\r\n    }\r\n\r\n    /**\r\n     * Methode um eine tiefe Objektkopie per Serialisierung zu erzeugen!\r\n     *\r\n     * @param oldObj (muss Serializable implementieren)\r\n     * @return tiefe Kopie\r\n     * @throws Exception\r\n     */\r\n    public static Object deepCopy(Object oldObj) throws Exception {\r\n        Object clone = null;\r\n        try {\r\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n            ObjectOutputStream oos = new ObjectOutputStream(baos);\r\n            oos.writeObject(oldObj);\r\n            oos.flush();\r\n            ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray()));\r\n            clone = ois.readObject();\r\n            oos.close();\r\n            ois.close();\r\n        } catch (Exception e) {\r\n            //$NON-NLS-1$\r\n            System.out.println(\"Exception in ObjectCloner = \" + e);\r\n            throw (e);\r\n        }\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Liefert die Version der Anwendung als String\r\n     *\r\n     * @return version\r\n     */\r\n    public static String getVersion() {\r\n        //$NON-NLS-1$\r\n        return \"1.0.5\";\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/MainTest5.java",
		"test_prompt": "// MainTest5.java\npackage visu.handball.moves;\n\nimport java.awt.BorderLayout;\nimport java.awt.Color;\nimport java.awt.Component;\nimport java.awt.Dimension;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.net.URL;\nimport javax.swing.ImageIcon;\nimport javax.swing.JDesktopPane;\nimport javax.swing.JFrame;\nimport javax.swing.JInternalFrame;\nimport javax.swing.JMenu;\nimport javax.swing.JMenuBar;\nimport javax.swing.JPanel;\nimport javax.swing.JScrollPane;\nimport javax.swing.JTable;\nimport javax.swing.JToolBar;\nimport javax.swing.ListSelectionModel;\nimport javax.swing.UIManager;\nimport visu.handball.moves.actions.AboutAction;\nimport visu.handball.moves.actions.ChangeColorsAction;\nimport visu.handball.moves.actions.CloseAction;\nimport visu.handball.moves.actions.CreateMovePdfAction;\nimport visu.handball.moves.actions.DeleteEventAction;\nimport visu.handball.moves.actions.NewAction;\nimport visu.handball.moves.actions.NewMoveEventAction;\nimport visu.handball.moves.actions.NewPassEventAction;\nimport visu.handball.moves.actions.NewSequenceAction;\nimport visu.handball.moves.actions.OpenAction;\nimport visu.handball.moves.actions.PauseAnimationAction;\nimport visu.handball.moves.actions.PrintActualSequenzAction;\nimport visu.handball.moves.actions.PrintMoveAction;\nimport visu.handball.moves.actions.SaveAction;\nimport visu.handball.moves.actions.SetMoveNameAction;\nimport visu.handball.moves.actions.StartAnimationAction;\nimport visu.handball.moves.actions.StartOneSequenceAnimationAction;\nimport visu.handball.moves.actions.StopAnimationAction;\nimport visu.handball.moves.controller.CommentController;\nimport visu.handball.moves.controller.JMenuHelper;\nimport visu.handball.moves.controller.MouseController;\nimport visu.handball.moves.model.ColorModel;\nimport visu.handball.moves.model.HandballModel;\nimport visu.handball.moves.model.TableHandballModel;\nimport visu.handball.moves.model.TableSelectionListener;\nimport visu.handball.moves.resources.Resources;\nimport visu.handball.moves.views.CommentView;\nimport visu.handball.moves.views.EventTableCellDelayEditor;\nimport visu.handball.moves.views.EventTableCellRenderer;\nimport visu.handball.moves.views.Field;\nimport visu.handball.moves.views.PlayerToolBar;\nimport visu.handball.moves.views.StatusBar;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Main}.\n* It contains ten unit test cases for the {@link Main#getSaveAction()} method.\n*/\nclass MainTest5 {"
	},
	{
		"original_code": "// Main.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves;\r\n\r\nimport java.awt.BorderLayout;\r\nimport java.awt.Color;\r\nimport java.awt.Component;\r\nimport java.awt.Dimension;\r\nimport java.awt.event.WindowAdapter;\r\nimport java.awt.event.WindowEvent;\r\nimport java.io.ByteArrayInputStream;\r\nimport java.io.ByteArrayOutputStream;\r\nimport java.io.ObjectInputStream;\r\nimport java.io.ObjectOutputStream;\r\nimport java.net.URL;\r\nimport javax.swing.ImageIcon;\r\nimport javax.swing.JDesktopPane;\r\nimport javax.swing.JFrame;\r\nimport javax.swing.JInternalFrame;\r\nimport javax.swing.JMenu;\r\nimport javax.swing.JMenuBar;\r\nimport javax.swing.JPanel;\r\nimport javax.swing.JScrollPane;\r\nimport javax.swing.JTable;\r\nimport javax.swing.JToolBar;\r\nimport javax.swing.ListSelectionModel;\r\nimport javax.swing.UIManager;\r\nimport visu.handball.moves.actions.AboutAction;\r\nimport visu.handball.moves.actions.ChangeColorsAction;\r\nimport visu.handball.moves.actions.CloseAction;\r\nimport visu.handball.moves.actions.CreateMovePdfAction;\r\nimport visu.handball.moves.actions.DeleteEventAction;\r\nimport visu.handball.moves.actions.NewAction;\r\nimport visu.handball.moves.actions.NewMoveEventAction;\r\nimport visu.handball.moves.actions.NewPassEventAction;\r\nimport visu.handball.moves.actions.NewSequenceAction;\r\nimport visu.handball.moves.actions.OpenAction;\r\nimport visu.handball.moves.actions.PauseAnimationAction;\r\nimport visu.handball.moves.actions.PrintActualSequenzAction;\r\nimport visu.handball.moves.actions.PrintMoveAction;\r\nimport visu.handball.moves.actions.SaveAction;\r\nimport visu.handball.moves.actions.SetMoveNameAction;\r\nimport visu.handball.moves.actions.StartAnimationAction;\r\nimport visu.handball.moves.actions.StartOneSequenceAnimationAction;\r\nimport visu.handball.moves.actions.StopAnimationAction;\r\nimport visu.handball.moves.controller.CommentController;\r\nimport visu.handball.moves.controller.JMenuHelper;\r\nimport visu.handball.moves.controller.MouseController;\r\nimport visu.handball.moves.model.ColorModel;\r\nimport visu.handball.moves.model.HandballModel;\r\nimport visu.handball.moves.model.TableHandballModel;\r\nimport visu.handball.moves.model.TableSelectionListener;\r\nimport visu.handball.moves.resources.Resources;\r\nimport visu.handball.moves.views.CommentView;\r\nimport visu.handball.moves.views.EventTableCellDelayEditor;\r\nimport visu.handball.moves.views.EventTableCellRenderer;\r\nimport visu.handball.moves.views.Field;\r\nimport visu.handball.moves.views.PlayerToolBar;\r\nimport visu.handball.moves.views.StatusBar;\r\n\r\n/**\r\n * Hauptklasse zum Starten der Anwendung plus den Zugriff auf die entsprechenden Objekt-Instanzen\r\n * @author tommy\r\n */\r\npublic class Main {\r\n\r\n    private static SaveAction saveAction;\r\n\r\n    private static CloseAction closeAction;\r\n\r\n    private static SetMoveNameAction setNameAction;\r\n\r\n    private static JFrame window;\r\n\r\n    private static Field field;\r\n\r\n    private static CommentView commentView;\r\n\r\n    private static ColorModel colorModel;\r\n\r\n    /**\r\n     * Liefert die Instanz des ColorModels\r\n     *\r\n     * @return colorModel\r\n     */\r\n    public static ColorModel getColorModel() {\r\n        return colorModel;\r\n    }\r\n\r\n    /**\r\n     * Main-Methode zum Starten der Anwendung\r\n     *\r\n     * @param args\r\n     */\r\n    public static void main(String[] args) {\r\n        try {\r\n            UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\r\n        } catch (Exception e) {\r\n            System.out.println(//$NON-NLS-1$\r\n            Resources.getString(\"error.lookAndFell\"));\r\n        }\r\n        //$NON-NLS-1$\r\n        window = new JFrame(Resources.getString(\"app.title\"));\r\n        //$NON-NLS-1$ //$NON-NLS-2$\r\n        window.setIconImage(createImageIcon(\"images/icon.gif\", \"\").getImage());\r\n        JPanel content = new JPanel(new BorderLayout());\r\n        JDesktopPane desktop = new JDesktopPane();\r\n        window.setContentPane(content);\r\n        content.add(desktop, BorderLayout.CENTER);\r\n        desktop.setBackground(new Color(255, 255, 174));\r\n        desktop.setDragMode(JDesktopPane.OUTLINE_DRAG_MODE);\r\n        // Create HandballModel\r\n        HandballModel handballModel = createHandballModel();\r\n        // Create ColorModel\r\n        colorModel = new ColorModel();\r\n        // Statusbar\r\n        StatusBar statusBar = createStatusBar(handballModel);\r\n        content.add(statusBar, BorderLayout.SOUTH);\r\n        // Create Menu\r\n        JMenuBar menu = createHandballMenu(handballModel);\r\n        window.setJMenuBar(menu);\r\n        // Create HandballField\r\n        field = new Field(handballModel, colorModel);\r\n        JInternalFrame handballField = new //$NON-NLS-1$\r\n        JInternalFrame(//$NON-NLS-1$\r\n        Resources.getString(\"field.title\"), //$NON-NLS-1$\r\n        false, false, false, true);\r\n        handballField.setLocation(10, 10);\r\n        handballField.add(field);\r\n        handballField.setVisible(true);\r\n        handballField.pack();\r\n        desktop.add(handballField);\r\n        // Create MouseController\r\n        MouseController mouse = new MouseController(handballModel, handballField);\r\n        field.addMouseListener(mouse);\r\n        field.addMouseMotionListener(mouse);\r\n        // Add Statusbar as Listener\r\n        field.addMouseMotionListener(statusBar);\r\n        // Create ToolBar\r\n        PlayerToolBar playerBar = new PlayerToolBar(handballModel);\r\n        content.add(playerBar, BorderLayout.NORTH);\r\n        // Create EventView\r\n        JPanel tablePanel = createTablePanel(handballModel);\r\n        JInternalFrame eventView = new //$NON-NLS-1$\r\n        JInternalFrame(//$NON-NLS-1$\r\n        Resources.getString(\"events.title\"), //$NON-NLS-1$\r\n        true, false, false, true);\r\n        eventView.add(tablePanel);\r\n        eventView.setLocation(20 + handballField.getWidth(), 10);\r\n        eventView.setVisible(true);\r\n        eventView.setSize(450, 400);\r\n        desktop.add(eventView);\r\n        // Create CommentView\r\n        //$NON-NLS-1$\r\n        commentView = new CommentView(Resources.getString(\"comment.title\"));\r\n        commentView.setLocation(20 + handballField.getWidth(), 420);\r\n        commentView.setSize(450, handballField.getHeight() - eventView.getHeight() - 10);\r\n        commentView.setVisible(true);\r\n        //Controller für CommentView erzeugen\r\n        new CommentController(handballModel, commentView);\r\n        desktop.add(commentView);\r\n        window.setSize(1000, 700);\r\n        locateOnScreenCenter(window);\r\n        window.addWindowListener(new WindowAdapter() {\r\n\r\n            public void windowClosing(WindowEvent e) {\r\n                Main.getCloseAction().actionPerformed(null);\r\n            }\r\n        });\r\n        window.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);\r\n        window.setVisible(true);\r\n    }\r\n\r\n    private static JMenuBar createHandballMenu(HandballModel handballModel) {\r\n        JMenuBar mbar;\r\n        JMenu menuDatei, menuHilfe, menuEinstellungen;\r\n        // Hauptmenue einrichten\r\n        mbar = new JMenuBar();\r\n        //$NON-NLS-1$\r\n        menuDatei = JMenuHelper.addMenuBarItem(mbar, Resources.getString(\"menu.file\"));\r\n        //$NON-NLS-1$\r\n        menuEinstellungen = JMenuHelper.addMenuBarItem(mbar, Resources.getString(\"menu.settings\"));\r\n        //$NON-NLS-1$\r\n        menuHilfe = JMenuHelper.addMenuBarItem(mbar, Resources.getString(\"menu.about\"));\r\n        // Einträge fuer Datei\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", new //$NON-NLS-1$\r\n        NewAction(handballModel));\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", new //$NON-NLS-1$\r\n        OpenAction(handballModel));\r\n        //Separator einfügen\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"-\");\r\n        saveAction = new SaveAction(handballModel);\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", saveAction);\r\n        // Separator einfügen\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"-\");\r\n        setNameAction = new SetMoveNameAction(handballModel);\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", setNameAction);\r\n        //Separator einfügen\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"-\");\r\n        //Drucken einfügen\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", new //$NON-NLS-1$\r\n        PrintActualSequenzAction(handballModel));\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", new PrintMoveAction(handballModel));\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", new CreateMovePdfAction(handballModel));\r\n        // Separator einfügen\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"-\");\r\n        closeAction = new CloseAction(handballModel);\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", closeAction);\r\n        // Einträge für Einstellungen\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuEinstellungen, \"\", new ChangeColorsAction());\r\n        // Einträge für Hilfe\r\n        //$NON-NLS-1$\r\n        JMenuHelper.//$NON-NLS-1$\r\n        addMenuItem(//$NON-NLS-1$\r\n        menuHilfe, //$NON-NLS-1$\r\n        \"\", new AboutAction());\r\n        return mbar;\r\n    }\r\n\r\n    private static JPanel createTablePanel(HandballModel handballModel) {\r\n        TableHandballModel tableModel = new TableHandballModel(handballModel);\r\n        JTable table = new JTable(tableModel);\r\n        table.setDefaultRenderer(Object.class, new EventTableCellRenderer());\r\n        table.getColumnModel().getColumn(0).setPreferredWidth(100);\r\n        table.getColumnModel().getColumn(1).setPreferredWidth(200);\r\n        EventTableCellDelayEditor delayEditor = new EventTableCellDelayEditor();\r\n        table.getColumnModel().getColumn(3).setCellEditor(delayEditor);\r\n        table.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\r\n        table.getSelectionModel().addListSelectionListener(new TableSelectionListener(tableModel));\r\n        JPanel panel = new JPanel(new BorderLayout());\r\n        //$NON-NLS-1$\r\n        JToolBar toolBar = new JToolBar(Resources.getString(\"toolbar.title\"));\r\n        toolBar.add(new NewMoveEventAction(handballModel));\r\n        toolBar.add(new NewSequenceAction(handballModel));\r\n        toolBar.add(new NewPassEventAction(handballModel));\r\n        toolBar.add(new DeleteEventAction(handballModel));\r\n        toolBar.addSeparator();\r\n        toolBar.add(new StartOneSequenceAnimationAction(handballModel));\r\n        toolBar.add(new StartAnimationAction(handballModel));\r\n        toolBar.add(new PauseAnimationAction(handballModel));\r\n        toolBar.add(new StopAnimationAction(handballModel));\r\n        JScrollPane scroll = new JScrollPane(table);\r\n        panel.add(scroll, BorderLayout.CENTER);\r\n        panel.add(toolBar, BorderLayout.PAGE_START);\r\n        return panel;\r\n    }\r\n\r\n    private static StatusBar createStatusBar(HandballModel model) {\r\n        StatusBar statusBar = new StatusBar(model);\r\n        return statusBar;\r\n    }\r\n\r\n    /**\r\n     * Basierend auf der relativen Pfad (relativ zum Ort dieser Klasse) und der Beschreibung\r\n     * wird ein Grafik geladen und ein ImageIcon-Objekt erstellt.\r\n     * @param path\r\n     * @param description\r\n     *\r\n     * @return imageIcon\r\n     */\r\n    public static ImageIcon createImageIcon(String path, String description) {\r\n        URL url = Main.class.getResource(path);\r\n        return new ImageIcon(url, description);\r\n    }\r\n\r\n    /**\r\n     * Erzeugt auf Basis eines relativen Pfads (relativ zum Ort dieser Klasse) eine URL.\r\n     * @param path\r\n     *\r\n     * @return url\r\n     */\r\n    public static URL getResource(String path) {\r\n        return Main.class.getResource(path);\r\n    }\r\n\r\n    /**\r\n     * Methode um Component-Objekte (z.B. Fenster) in der Mitte des Bildschirms zu positionieren\r\n     * @param component\r\n     */\r\n    public static void locateOnScreenCenter(Component component) {\r\n        Dimension paneSize = component.getSize();\r\n        Dimension screenSize = component.getToolkit().getScreenSize();\r\n        component.setLocation((screenSize.width - paneSize.width) / 2, (screenSize.height - paneSize.height) / 2);\r\n    }\r\n\r\n    private static HandballModel createHandballModel() {\r\n        HandballModel model = new HandballModel();\r\n        return model;\r\n    }\r\n\r\n    /**\r\n     * Die Instanz des Anwendungsfensters\r\n     *\r\n     * @return window\r\n     */\r\n    public static JFrame getWindow() {\r\n        return window;\r\n    }\r\n\r\n    /**\r\n     * Instanz des Spielfeld-Panels\r\n     *\r\n     * @return panel\r\n     */\r\n    public static Field getField() {\r\n        return field;\r\n    }\r\n\r\n    /**\r\n     * Instanz der Speichern-Aktion\r\n     *\r\n     * @return saveAction\r\n     */\r\n    public static SaveAction getSaveAction() {\r\n        return saveAction;\r\n    }\r\n\r\n    public static SetMoveNameAction getSetNameAction() {\r\n        return setNameAction;\r\n    }\r\n\r\n    /**\r\n     * Instanz der Schlie�en-Aktion\r\n     *\r\n     * @return close Action\r\n     */\r\n    public static CloseAction getCloseAction() {\r\n        return closeAction;\r\n    }\r\n\r\n    /**\r\n     * Methode um eine tiefe Objektkopie per Serialisierung zu erzeugen!\r\n     *\r\n     * @param oldObj (muss Serializable implementieren)\r\n     * @return tiefe Kopie\r\n     * @throws Exception\r\n     */\r\n    public static Object deepCopy(Object oldObj) throws Exception {\r\n        Object clone = null;\r\n        try {\r\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n            ObjectOutputStream oos = new ObjectOutputStream(baos);\r\n            oos.writeObject(oldObj);\r\n            oos.flush();\r\n            ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray()));\r\n            clone = ois.readObject();\r\n            oos.close();\r\n            ois.close();\r\n        } catch (Exception e) {\r\n            //$NON-NLS-1$\r\n            System.out.println(\"Exception in ObjectCloner = \" + e);\r\n            throw (e);\r\n        }\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Liefert die Version der Anwendung als String\r\n     *\r\n     * @return version\r\n     */\r\n    public static String getVersion() {\r\n        //$NON-NLS-1$\r\n        return \"1.0.5\";\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/MainTest6.java",
		"test_prompt": "// MainTest6.java\npackage visu.handball.moves;\n\nimport java.awt.BorderLayout;\nimport java.awt.Color;\nimport java.awt.Component;\nimport java.awt.Dimension;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.net.URL;\nimport javax.swing.ImageIcon;\nimport javax.swing.JDesktopPane;\nimport javax.swing.JFrame;\nimport javax.swing.JInternalFrame;\nimport javax.swing.JMenu;\nimport javax.swing.JMenuBar;\nimport javax.swing.JPanel;\nimport javax.swing.JScrollPane;\nimport javax.swing.JTable;\nimport javax.swing.JToolBar;\nimport javax.swing.ListSelectionModel;\nimport javax.swing.UIManager;\nimport visu.handball.moves.actions.AboutAction;\nimport visu.handball.moves.actions.ChangeColorsAction;\nimport visu.handball.moves.actions.CloseAction;\nimport visu.handball.moves.actions.CreateMovePdfAction;\nimport visu.handball.moves.actions.DeleteEventAction;\nimport visu.handball.moves.actions.NewAction;\nimport visu.handball.moves.actions.NewMoveEventAction;\nimport visu.handball.moves.actions.NewPassEventAction;\nimport visu.handball.moves.actions.NewSequenceAction;\nimport visu.handball.moves.actions.OpenAction;\nimport visu.handball.moves.actions.PauseAnimationAction;\nimport visu.handball.moves.actions.PrintActualSequenzAction;\nimport visu.handball.moves.actions.PrintMoveAction;\nimport visu.handball.moves.actions.SaveAction;\nimport visu.handball.moves.actions.SetMoveNameAction;\nimport visu.handball.moves.actions.StartAnimationAction;\nimport visu.handball.moves.actions.StartOneSequenceAnimationAction;\nimport visu.handball.moves.actions.StopAnimationAction;\nimport visu.handball.moves.controller.CommentController;\nimport visu.handball.moves.controller.JMenuHelper;\nimport visu.handball.moves.controller.MouseController;\nimport visu.handball.moves.model.ColorModel;\nimport visu.handball.moves.model.HandballModel;\nimport visu.handball.moves.model.TableHandballModel;\nimport visu.handball.moves.model.TableSelectionListener;\nimport visu.handball.moves.resources.Resources;\nimport visu.handball.moves.views.CommentView;\nimport visu.handball.moves.views.EventTableCellDelayEditor;\nimport visu.handball.moves.views.EventTableCellRenderer;\nimport visu.handball.moves.views.Field;\nimport visu.handball.moves.views.PlayerToolBar;\nimport visu.handball.moves.views.StatusBar;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Main}.\n* It contains ten unit test cases for the {@link Main#getSetNameAction()} method.\n*/\nclass MainTest6 {"
	},
	{
		"original_code": "// Main.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves;\r\n\r\nimport java.awt.BorderLayout;\r\nimport java.awt.Color;\r\nimport java.awt.Component;\r\nimport java.awt.Dimension;\r\nimport java.awt.event.WindowAdapter;\r\nimport java.awt.event.WindowEvent;\r\nimport java.io.ByteArrayInputStream;\r\nimport java.io.ByteArrayOutputStream;\r\nimport java.io.ObjectInputStream;\r\nimport java.io.ObjectOutputStream;\r\nimport java.net.URL;\r\nimport javax.swing.ImageIcon;\r\nimport javax.swing.JDesktopPane;\r\nimport javax.swing.JFrame;\r\nimport javax.swing.JInternalFrame;\r\nimport javax.swing.JMenu;\r\nimport javax.swing.JMenuBar;\r\nimport javax.swing.JPanel;\r\nimport javax.swing.JScrollPane;\r\nimport javax.swing.JTable;\r\nimport javax.swing.JToolBar;\r\nimport javax.swing.ListSelectionModel;\r\nimport javax.swing.UIManager;\r\nimport visu.handball.moves.actions.AboutAction;\r\nimport visu.handball.moves.actions.ChangeColorsAction;\r\nimport visu.handball.moves.actions.CloseAction;\r\nimport visu.handball.moves.actions.CreateMovePdfAction;\r\nimport visu.handball.moves.actions.DeleteEventAction;\r\nimport visu.handball.moves.actions.NewAction;\r\nimport visu.handball.moves.actions.NewMoveEventAction;\r\nimport visu.handball.moves.actions.NewPassEventAction;\r\nimport visu.handball.moves.actions.NewSequenceAction;\r\nimport visu.handball.moves.actions.OpenAction;\r\nimport visu.handball.moves.actions.PauseAnimationAction;\r\nimport visu.handball.moves.actions.PrintActualSequenzAction;\r\nimport visu.handball.moves.actions.PrintMoveAction;\r\nimport visu.handball.moves.actions.SaveAction;\r\nimport visu.handball.moves.actions.SetMoveNameAction;\r\nimport visu.handball.moves.actions.StartAnimationAction;\r\nimport visu.handball.moves.actions.StartOneSequenceAnimationAction;\r\nimport visu.handball.moves.actions.StopAnimationAction;\r\nimport visu.handball.moves.controller.CommentController;\r\nimport visu.handball.moves.controller.JMenuHelper;\r\nimport visu.handball.moves.controller.MouseController;\r\nimport visu.handball.moves.model.ColorModel;\r\nimport visu.handball.moves.model.HandballModel;\r\nimport visu.handball.moves.model.TableHandballModel;\r\nimport visu.handball.moves.model.TableSelectionListener;\r\nimport visu.handball.moves.resources.Resources;\r\nimport visu.handball.moves.views.CommentView;\r\nimport visu.handball.moves.views.EventTableCellDelayEditor;\r\nimport visu.handball.moves.views.EventTableCellRenderer;\r\nimport visu.handball.moves.views.Field;\r\nimport visu.handball.moves.views.PlayerToolBar;\r\nimport visu.handball.moves.views.StatusBar;\r\n\r\n/**\r\n * Hauptklasse zum Starten der Anwendung plus den Zugriff auf die entsprechenden Objekt-Instanzen\r\n * @author tommy\r\n */\r\npublic class Main {\r\n\r\n    private static SaveAction saveAction;\r\n\r\n    private static CloseAction closeAction;\r\n\r\n    private static SetMoveNameAction setNameAction;\r\n\r\n    private static JFrame window;\r\n\r\n    private static Field field;\r\n\r\n    private static CommentView commentView;\r\n\r\n    private static ColorModel colorModel;\r\n\r\n    /**\r\n     * Liefert die Instanz des ColorModels\r\n     *\r\n     * @return colorModel\r\n     */\r\n    public static ColorModel getColorModel() {\r\n        return colorModel;\r\n    }\r\n\r\n    /**\r\n     * Main-Methode zum Starten der Anwendung\r\n     *\r\n     * @param args\r\n     */\r\n    public static void main(String[] args) {\r\n        try {\r\n            UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\r\n        } catch (Exception e) {\r\n            System.out.println(//$NON-NLS-1$\r\n            Resources.getString(\"error.lookAndFell\"));\r\n        }\r\n        //$NON-NLS-1$\r\n        window = new JFrame(Resources.getString(\"app.title\"));\r\n        //$NON-NLS-1$ //$NON-NLS-2$\r\n        window.setIconImage(createImageIcon(\"images/icon.gif\", \"\").getImage());\r\n        JPanel content = new JPanel(new BorderLayout());\r\n        JDesktopPane desktop = new JDesktopPane();\r\n        window.setContentPane(content);\r\n        content.add(desktop, BorderLayout.CENTER);\r\n        desktop.setBackground(new Color(255, 255, 174));\r\n        desktop.setDragMode(JDesktopPane.OUTLINE_DRAG_MODE);\r\n        // Create HandballModel\r\n        HandballModel handballModel = createHandballModel();\r\n        // Create ColorModel\r\n        colorModel = new ColorModel();\r\n        // Statusbar\r\n        StatusBar statusBar = createStatusBar(handballModel);\r\n        content.add(statusBar, BorderLayout.SOUTH);\r\n        // Create Menu\r\n        JMenuBar menu = createHandballMenu(handballModel);\r\n        window.setJMenuBar(menu);\r\n        // Create HandballField\r\n        field = new Field(handballModel, colorModel);\r\n        JInternalFrame handballField = new //$NON-NLS-1$\r\n        JInternalFrame(//$NON-NLS-1$\r\n        Resources.getString(\"field.title\"), //$NON-NLS-1$\r\n        false, false, false, true);\r\n        handballField.setLocation(10, 10);\r\n        handballField.add(field);\r\n        handballField.setVisible(true);\r\n        handballField.pack();\r\n        desktop.add(handballField);\r\n        // Create MouseController\r\n        MouseController mouse = new MouseController(handballModel, handballField);\r\n        field.addMouseListener(mouse);\r\n        field.addMouseMotionListener(mouse);\r\n        // Add Statusbar as Listener\r\n        field.addMouseMotionListener(statusBar);\r\n        // Create ToolBar\r\n        PlayerToolBar playerBar = new PlayerToolBar(handballModel);\r\n        content.add(playerBar, BorderLayout.NORTH);\r\n        // Create EventView\r\n        JPanel tablePanel = createTablePanel(handballModel);\r\n        JInternalFrame eventView = new //$NON-NLS-1$\r\n        JInternalFrame(//$NON-NLS-1$\r\n        Resources.getString(\"events.title\"), //$NON-NLS-1$\r\n        true, false, false, true);\r\n        eventView.add(tablePanel);\r\n        eventView.setLocation(20 + handballField.getWidth(), 10);\r\n        eventView.setVisible(true);\r\n        eventView.setSize(450, 400);\r\n        desktop.add(eventView);\r\n        // Create CommentView\r\n        //$NON-NLS-1$\r\n        commentView = new CommentView(Resources.getString(\"comment.title\"));\r\n        commentView.setLocation(20 + handballField.getWidth(), 420);\r\n        commentView.setSize(450, handballField.getHeight() - eventView.getHeight() - 10);\r\n        commentView.setVisible(true);\r\n        //Controller für CommentView erzeugen\r\n        new CommentController(handballModel, commentView);\r\n        desktop.add(commentView);\r\n        window.setSize(1000, 700);\r\n        locateOnScreenCenter(window);\r\n        window.addWindowListener(new WindowAdapter() {\r\n\r\n            public void windowClosing(WindowEvent e) {\r\n                Main.getCloseAction().actionPerformed(null);\r\n            }\r\n        });\r\n        window.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);\r\n        window.setVisible(true);\r\n    }\r\n\r\n    private static JMenuBar createHandballMenu(HandballModel handballModel) {\r\n        JMenuBar mbar;\r\n        JMenu menuDatei, menuHilfe, menuEinstellungen;\r\n        // Hauptmenue einrichten\r\n        mbar = new JMenuBar();\r\n        //$NON-NLS-1$\r\n        menuDatei = JMenuHelper.addMenuBarItem(mbar, Resources.getString(\"menu.file\"));\r\n        //$NON-NLS-1$\r\n        menuEinstellungen = JMenuHelper.addMenuBarItem(mbar, Resources.getString(\"menu.settings\"));\r\n        //$NON-NLS-1$\r\n        menuHilfe = JMenuHelper.addMenuBarItem(mbar, Resources.getString(\"menu.about\"));\r\n        // Einträge fuer Datei\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", new //$NON-NLS-1$\r\n        NewAction(handballModel));\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", new //$NON-NLS-1$\r\n        OpenAction(handballModel));\r\n        //Separator einfügen\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"-\");\r\n        saveAction = new SaveAction(handballModel);\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", saveAction);\r\n        // Separator einfügen\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"-\");\r\n        setNameAction = new SetMoveNameAction(handballModel);\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", setNameAction);\r\n        //Separator einfügen\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"-\");\r\n        //Drucken einfügen\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", new //$NON-NLS-1$\r\n        PrintActualSequenzAction(handballModel));\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", new PrintMoveAction(handballModel));\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", new CreateMovePdfAction(handballModel));\r\n        // Separator einfügen\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"-\");\r\n        closeAction = new CloseAction(handballModel);\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", closeAction);\r\n        // Einträge für Einstellungen\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuEinstellungen, \"\", new ChangeColorsAction());\r\n        // Einträge für Hilfe\r\n        //$NON-NLS-1$\r\n        JMenuHelper.//$NON-NLS-1$\r\n        addMenuItem(//$NON-NLS-1$\r\n        menuHilfe, //$NON-NLS-1$\r\n        \"\", new AboutAction());\r\n        return mbar;\r\n    }\r\n\r\n    private static JPanel createTablePanel(HandballModel handballModel) {\r\n        TableHandballModel tableModel = new TableHandballModel(handballModel);\r\n        JTable table = new JTable(tableModel);\r\n        table.setDefaultRenderer(Object.class, new EventTableCellRenderer());\r\n        table.getColumnModel().getColumn(0).setPreferredWidth(100);\r\n        table.getColumnModel().getColumn(1).setPreferredWidth(200);\r\n        EventTableCellDelayEditor delayEditor = new EventTableCellDelayEditor();\r\n        table.getColumnModel().getColumn(3).setCellEditor(delayEditor);\r\n        table.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\r\n        table.getSelectionModel().addListSelectionListener(new TableSelectionListener(tableModel));\r\n        JPanel panel = new JPanel(new BorderLayout());\r\n        //$NON-NLS-1$\r\n        JToolBar toolBar = new JToolBar(Resources.getString(\"toolbar.title\"));\r\n        toolBar.add(new NewMoveEventAction(handballModel));\r\n        toolBar.add(new NewSequenceAction(handballModel));\r\n        toolBar.add(new NewPassEventAction(handballModel));\r\n        toolBar.add(new DeleteEventAction(handballModel));\r\n        toolBar.addSeparator();\r\n        toolBar.add(new StartOneSequenceAnimationAction(handballModel));\r\n        toolBar.add(new StartAnimationAction(handballModel));\r\n        toolBar.add(new PauseAnimationAction(handballModel));\r\n        toolBar.add(new StopAnimationAction(handballModel));\r\n        JScrollPane scroll = new JScrollPane(table);\r\n        panel.add(scroll, BorderLayout.CENTER);\r\n        panel.add(toolBar, BorderLayout.PAGE_START);\r\n        return panel;\r\n    }\r\n\r\n    private static StatusBar createStatusBar(HandballModel model) {\r\n        StatusBar statusBar = new StatusBar(model);\r\n        return statusBar;\r\n    }\r\n\r\n    /**\r\n     * Basierend auf der relativen Pfad (relativ zum Ort dieser Klasse) und der Beschreibung\r\n     * wird ein Grafik geladen und ein ImageIcon-Objekt erstellt.\r\n     * @param path\r\n     * @param description\r\n     *\r\n     * @return imageIcon\r\n     */\r\n    public static ImageIcon createImageIcon(String path, String description) {\r\n        URL url = Main.class.getResource(path);\r\n        return new ImageIcon(url, description);\r\n    }\r\n\r\n    /**\r\n     * Erzeugt auf Basis eines relativen Pfads (relativ zum Ort dieser Klasse) eine URL.\r\n     * @param path\r\n     *\r\n     * @return url\r\n     */\r\n    public static URL getResource(String path) {\r\n        return Main.class.getResource(path);\r\n    }\r\n\r\n    /**\r\n     * Methode um Component-Objekte (z.B. Fenster) in der Mitte des Bildschirms zu positionieren\r\n     * @param component\r\n     */\r\n    public static void locateOnScreenCenter(Component component) {\r\n        Dimension paneSize = component.getSize();\r\n        Dimension screenSize = component.getToolkit().getScreenSize();\r\n        component.setLocation((screenSize.width - paneSize.width) / 2, (screenSize.height - paneSize.height) / 2);\r\n    }\r\n\r\n    private static HandballModel createHandballModel() {\r\n        HandballModel model = new HandballModel();\r\n        return model;\r\n    }\r\n\r\n    /**\r\n     * Die Instanz des Anwendungsfensters\r\n     *\r\n     * @return window\r\n     */\r\n    public static JFrame getWindow() {\r\n        return window;\r\n    }\r\n\r\n    /**\r\n     * Instanz des Spielfeld-Panels\r\n     *\r\n     * @return panel\r\n     */\r\n    public static Field getField() {\r\n        return field;\r\n    }\r\n\r\n    /**\r\n     * Instanz der Speichern-Aktion\r\n     *\r\n     * @return saveAction\r\n     */\r\n    public static SaveAction getSaveAction() {\r\n        return saveAction;\r\n    }\r\n\r\n    public static SetMoveNameAction getSetNameAction() {\r\n        return setNameAction;\r\n    }\r\n\r\n    /**\r\n     * Instanz der Schlie�en-Aktion\r\n     *\r\n     * @return close Action\r\n     */\r\n    public static CloseAction getCloseAction() {\r\n        return closeAction;\r\n    }\r\n\r\n    /**\r\n     * Methode um eine tiefe Objektkopie per Serialisierung zu erzeugen!\r\n     *\r\n     * @param oldObj (muss Serializable implementieren)\r\n     * @return tiefe Kopie\r\n     * @throws Exception\r\n     */\r\n    public static Object deepCopy(Object oldObj) throws Exception {\r\n        Object clone = null;\r\n        try {\r\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n            ObjectOutputStream oos = new ObjectOutputStream(baos);\r\n            oos.writeObject(oldObj);\r\n            oos.flush();\r\n            ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray()));\r\n            clone = ois.readObject();\r\n            oos.close();\r\n            ois.close();\r\n        } catch (Exception e) {\r\n            //$NON-NLS-1$\r\n            System.out.println(\"Exception in ObjectCloner = \" + e);\r\n            throw (e);\r\n        }\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Liefert die Version der Anwendung als String\r\n     *\r\n     * @return version\r\n     */\r\n    public static String getVersion() {\r\n        //$NON-NLS-1$\r\n        return \"1.0.5\";\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/MainTest7.java",
		"test_prompt": "// MainTest7.java\npackage visu.handball.moves;\n\nimport java.awt.BorderLayout;\nimport java.awt.Color;\nimport java.awt.Component;\nimport java.awt.Dimension;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.net.URL;\nimport javax.swing.ImageIcon;\nimport javax.swing.JDesktopPane;\nimport javax.swing.JFrame;\nimport javax.swing.JInternalFrame;\nimport javax.swing.JMenu;\nimport javax.swing.JMenuBar;\nimport javax.swing.JPanel;\nimport javax.swing.JScrollPane;\nimport javax.swing.JTable;\nimport javax.swing.JToolBar;\nimport javax.swing.ListSelectionModel;\nimport javax.swing.UIManager;\nimport visu.handball.moves.actions.AboutAction;\nimport visu.handball.moves.actions.ChangeColorsAction;\nimport visu.handball.moves.actions.CloseAction;\nimport visu.handball.moves.actions.CreateMovePdfAction;\nimport visu.handball.moves.actions.DeleteEventAction;\nimport visu.handball.moves.actions.NewAction;\nimport visu.handball.moves.actions.NewMoveEventAction;\nimport visu.handball.moves.actions.NewPassEventAction;\nimport visu.handball.moves.actions.NewSequenceAction;\nimport visu.handball.moves.actions.OpenAction;\nimport visu.handball.moves.actions.PauseAnimationAction;\nimport visu.handball.moves.actions.PrintActualSequenzAction;\nimport visu.handball.moves.actions.PrintMoveAction;\nimport visu.handball.moves.actions.SaveAction;\nimport visu.handball.moves.actions.SetMoveNameAction;\nimport visu.handball.moves.actions.StartAnimationAction;\nimport visu.handball.moves.actions.StartOneSequenceAnimationAction;\nimport visu.handball.moves.actions.StopAnimationAction;\nimport visu.handball.moves.controller.CommentController;\nimport visu.handball.moves.controller.JMenuHelper;\nimport visu.handball.moves.controller.MouseController;\nimport visu.handball.moves.model.ColorModel;\nimport visu.handball.moves.model.HandballModel;\nimport visu.handball.moves.model.TableHandballModel;\nimport visu.handball.moves.model.TableSelectionListener;\nimport visu.handball.moves.resources.Resources;\nimport visu.handball.moves.views.CommentView;\nimport visu.handball.moves.views.EventTableCellDelayEditor;\nimport visu.handball.moves.views.EventTableCellRenderer;\nimport visu.handball.moves.views.Field;\nimport visu.handball.moves.views.PlayerToolBar;\nimport visu.handball.moves.views.StatusBar;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Main}.\n* It contains ten unit test cases for the {@link Main#getCloseAction()} method.\n*/\nclass MainTest7 {"
	},
	{
		"original_code": "// Main.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves;\r\n\r\nimport java.awt.BorderLayout;\r\nimport java.awt.Color;\r\nimport java.awt.Component;\r\nimport java.awt.Dimension;\r\nimport java.awt.event.WindowAdapter;\r\nimport java.awt.event.WindowEvent;\r\nimport java.io.ByteArrayInputStream;\r\nimport java.io.ByteArrayOutputStream;\r\nimport java.io.ObjectInputStream;\r\nimport java.io.ObjectOutputStream;\r\nimport java.net.URL;\r\nimport javax.swing.ImageIcon;\r\nimport javax.swing.JDesktopPane;\r\nimport javax.swing.JFrame;\r\nimport javax.swing.JInternalFrame;\r\nimport javax.swing.JMenu;\r\nimport javax.swing.JMenuBar;\r\nimport javax.swing.JPanel;\r\nimport javax.swing.JScrollPane;\r\nimport javax.swing.JTable;\r\nimport javax.swing.JToolBar;\r\nimport javax.swing.ListSelectionModel;\r\nimport javax.swing.UIManager;\r\nimport visu.handball.moves.actions.AboutAction;\r\nimport visu.handball.moves.actions.ChangeColorsAction;\r\nimport visu.handball.moves.actions.CloseAction;\r\nimport visu.handball.moves.actions.CreateMovePdfAction;\r\nimport visu.handball.moves.actions.DeleteEventAction;\r\nimport visu.handball.moves.actions.NewAction;\r\nimport visu.handball.moves.actions.NewMoveEventAction;\r\nimport visu.handball.moves.actions.NewPassEventAction;\r\nimport visu.handball.moves.actions.NewSequenceAction;\r\nimport visu.handball.moves.actions.OpenAction;\r\nimport visu.handball.moves.actions.PauseAnimationAction;\r\nimport visu.handball.moves.actions.PrintActualSequenzAction;\r\nimport visu.handball.moves.actions.PrintMoveAction;\r\nimport visu.handball.moves.actions.SaveAction;\r\nimport visu.handball.moves.actions.SetMoveNameAction;\r\nimport visu.handball.moves.actions.StartAnimationAction;\r\nimport visu.handball.moves.actions.StartOneSequenceAnimationAction;\r\nimport visu.handball.moves.actions.StopAnimationAction;\r\nimport visu.handball.moves.controller.CommentController;\r\nimport visu.handball.moves.controller.JMenuHelper;\r\nimport visu.handball.moves.controller.MouseController;\r\nimport visu.handball.moves.model.ColorModel;\r\nimport visu.handball.moves.model.HandballModel;\r\nimport visu.handball.moves.model.TableHandballModel;\r\nimport visu.handball.moves.model.TableSelectionListener;\r\nimport visu.handball.moves.resources.Resources;\r\nimport visu.handball.moves.views.CommentView;\r\nimport visu.handball.moves.views.EventTableCellDelayEditor;\r\nimport visu.handball.moves.views.EventTableCellRenderer;\r\nimport visu.handball.moves.views.Field;\r\nimport visu.handball.moves.views.PlayerToolBar;\r\nimport visu.handball.moves.views.StatusBar;\r\n\r\n/**\r\n * Hauptklasse zum Starten der Anwendung plus den Zugriff auf die entsprechenden Objekt-Instanzen\r\n * @author tommy\r\n */\r\npublic class Main {\r\n\r\n    private static SaveAction saveAction;\r\n\r\n    private static CloseAction closeAction;\r\n\r\n    private static SetMoveNameAction setNameAction;\r\n\r\n    private static JFrame window;\r\n\r\n    private static Field field;\r\n\r\n    private static CommentView commentView;\r\n\r\n    private static ColorModel colorModel;\r\n\r\n    /**\r\n     * Liefert die Instanz des ColorModels\r\n     *\r\n     * @return colorModel\r\n     */\r\n    public static ColorModel getColorModel() {\r\n        return colorModel;\r\n    }\r\n\r\n    /**\r\n     * Main-Methode zum Starten der Anwendung\r\n     *\r\n     * @param args\r\n     */\r\n    public static void main(String[] args) {\r\n        try {\r\n            UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\r\n        } catch (Exception e) {\r\n            System.out.println(//$NON-NLS-1$\r\n            Resources.getString(\"error.lookAndFell\"));\r\n        }\r\n        //$NON-NLS-1$\r\n        window = new JFrame(Resources.getString(\"app.title\"));\r\n        //$NON-NLS-1$ //$NON-NLS-2$\r\n        window.setIconImage(createImageIcon(\"images/icon.gif\", \"\").getImage());\r\n        JPanel content = new JPanel(new BorderLayout());\r\n        JDesktopPane desktop = new JDesktopPane();\r\n        window.setContentPane(content);\r\n        content.add(desktop, BorderLayout.CENTER);\r\n        desktop.setBackground(new Color(255, 255, 174));\r\n        desktop.setDragMode(JDesktopPane.OUTLINE_DRAG_MODE);\r\n        // Create HandballModel\r\n        HandballModel handballModel = createHandballModel();\r\n        // Create ColorModel\r\n        colorModel = new ColorModel();\r\n        // Statusbar\r\n        StatusBar statusBar = createStatusBar(handballModel);\r\n        content.add(statusBar, BorderLayout.SOUTH);\r\n        // Create Menu\r\n        JMenuBar menu = createHandballMenu(handballModel);\r\n        window.setJMenuBar(menu);\r\n        // Create HandballField\r\n        field = new Field(handballModel, colorModel);\r\n        JInternalFrame handballField = new //$NON-NLS-1$\r\n        JInternalFrame(//$NON-NLS-1$\r\n        Resources.getString(\"field.title\"), //$NON-NLS-1$\r\n        false, false, false, true);\r\n        handballField.setLocation(10, 10);\r\n        handballField.add(field);\r\n        handballField.setVisible(true);\r\n        handballField.pack();\r\n        desktop.add(handballField);\r\n        // Create MouseController\r\n        MouseController mouse = new MouseController(handballModel, handballField);\r\n        field.addMouseListener(mouse);\r\n        field.addMouseMotionListener(mouse);\r\n        // Add Statusbar as Listener\r\n        field.addMouseMotionListener(statusBar);\r\n        // Create ToolBar\r\n        PlayerToolBar playerBar = new PlayerToolBar(handballModel);\r\n        content.add(playerBar, BorderLayout.NORTH);\r\n        // Create EventView\r\n        JPanel tablePanel = createTablePanel(handballModel);\r\n        JInternalFrame eventView = new //$NON-NLS-1$\r\n        JInternalFrame(//$NON-NLS-1$\r\n        Resources.getString(\"events.title\"), //$NON-NLS-1$\r\n        true, false, false, true);\r\n        eventView.add(tablePanel);\r\n        eventView.setLocation(20 + handballField.getWidth(), 10);\r\n        eventView.setVisible(true);\r\n        eventView.setSize(450, 400);\r\n        desktop.add(eventView);\r\n        // Create CommentView\r\n        //$NON-NLS-1$\r\n        commentView = new CommentView(Resources.getString(\"comment.title\"));\r\n        commentView.setLocation(20 + handballField.getWidth(), 420);\r\n        commentView.setSize(450, handballField.getHeight() - eventView.getHeight() - 10);\r\n        commentView.setVisible(true);\r\n        //Controller für CommentView erzeugen\r\n        new CommentController(handballModel, commentView);\r\n        desktop.add(commentView);\r\n        window.setSize(1000, 700);\r\n        locateOnScreenCenter(window);\r\n        window.addWindowListener(new WindowAdapter() {\r\n\r\n            public void windowClosing(WindowEvent e) {\r\n                Main.getCloseAction().actionPerformed(null);\r\n            }\r\n        });\r\n        window.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);\r\n        window.setVisible(true);\r\n    }\r\n\r\n    private static JMenuBar createHandballMenu(HandballModel handballModel) {\r\n        JMenuBar mbar;\r\n        JMenu menuDatei, menuHilfe, menuEinstellungen;\r\n        // Hauptmenue einrichten\r\n        mbar = new JMenuBar();\r\n        //$NON-NLS-1$\r\n        menuDatei = JMenuHelper.addMenuBarItem(mbar, Resources.getString(\"menu.file\"));\r\n        //$NON-NLS-1$\r\n        menuEinstellungen = JMenuHelper.addMenuBarItem(mbar, Resources.getString(\"menu.settings\"));\r\n        //$NON-NLS-1$\r\n        menuHilfe = JMenuHelper.addMenuBarItem(mbar, Resources.getString(\"menu.about\"));\r\n        // Einträge fuer Datei\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", new //$NON-NLS-1$\r\n        NewAction(handballModel));\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", new //$NON-NLS-1$\r\n        OpenAction(handballModel));\r\n        //Separator einfügen\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"-\");\r\n        saveAction = new SaveAction(handballModel);\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", saveAction);\r\n        // Separator einfügen\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"-\");\r\n        setNameAction = new SetMoveNameAction(handballModel);\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", setNameAction);\r\n        //Separator einfügen\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"-\");\r\n        //Drucken einfügen\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", new //$NON-NLS-1$\r\n        PrintActualSequenzAction(handballModel));\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", new PrintMoveAction(handballModel));\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", new CreateMovePdfAction(handballModel));\r\n        // Separator einfügen\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"-\");\r\n        closeAction = new CloseAction(handballModel);\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", closeAction);\r\n        // Einträge für Einstellungen\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuEinstellungen, \"\", new ChangeColorsAction());\r\n        // Einträge für Hilfe\r\n        //$NON-NLS-1$\r\n        JMenuHelper.//$NON-NLS-1$\r\n        addMenuItem(//$NON-NLS-1$\r\n        menuHilfe, //$NON-NLS-1$\r\n        \"\", new AboutAction());\r\n        return mbar;\r\n    }\r\n\r\n    private static JPanel createTablePanel(HandballModel handballModel) {\r\n        TableHandballModel tableModel = new TableHandballModel(handballModel);\r\n        JTable table = new JTable(tableModel);\r\n        table.setDefaultRenderer(Object.class, new EventTableCellRenderer());\r\n        table.getColumnModel().getColumn(0).setPreferredWidth(100);\r\n        table.getColumnModel().getColumn(1).setPreferredWidth(200);\r\n        EventTableCellDelayEditor delayEditor = new EventTableCellDelayEditor();\r\n        table.getColumnModel().getColumn(3).setCellEditor(delayEditor);\r\n        table.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\r\n        table.getSelectionModel().addListSelectionListener(new TableSelectionListener(tableModel));\r\n        JPanel panel = new JPanel(new BorderLayout());\r\n        //$NON-NLS-1$\r\n        JToolBar toolBar = new JToolBar(Resources.getString(\"toolbar.title\"));\r\n        toolBar.add(new NewMoveEventAction(handballModel));\r\n        toolBar.add(new NewSequenceAction(handballModel));\r\n        toolBar.add(new NewPassEventAction(handballModel));\r\n        toolBar.add(new DeleteEventAction(handballModel));\r\n        toolBar.addSeparator();\r\n        toolBar.add(new StartOneSequenceAnimationAction(handballModel));\r\n        toolBar.add(new StartAnimationAction(handballModel));\r\n        toolBar.add(new PauseAnimationAction(handballModel));\r\n        toolBar.add(new StopAnimationAction(handballModel));\r\n        JScrollPane scroll = new JScrollPane(table);\r\n        panel.add(scroll, BorderLayout.CENTER);\r\n        panel.add(toolBar, BorderLayout.PAGE_START);\r\n        return panel;\r\n    }\r\n\r\n    private static StatusBar createStatusBar(HandballModel model) {\r\n        StatusBar statusBar = new StatusBar(model);\r\n        return statusBar;\r\n    }\r\n\r\n    /**\r\n     * Basierend auf der relativen Pfad (relativ zum Ort dieser Klasse) und der Beschreibung\r\n     * wird ein Grafik geladen und ein ImageIcon-Objekt erstellt.\r\n     * @param path\r\n     * @param description\r\n     *\r\n     * @return imageIcon\r\n     */\r\n    public static ImageIcon createImageIcon(String path, String description) {\r\n        URL url = Main.class.getResource(path);\r\n        return new ImageIcon(url, description);\r\n    }\r\n\r\n    /**\r\n     * Erzeugt auf Basis eines relativen Pfads (relativ zum Ort dieser Klasse) eine URL.\r\n     * @param path\r\n     *\r\n     * @return url\r\n     */\r\n    public static URL getResource(String path) {\r\n        return Main.class.getResource(path);\r\n    }\r\n\r\n    /**\r\n     * Methode um Component-Objekte (z.B. Fenster) in der Mitte des Bildschirms zu positionieren\r\n     * @param component\r\n     */\r\n    public static void locateOnScreenCenter(Component component) {\r\n        Dimension paneSize = component.getSize();\r\n        Dimension screenSize = component.getToolkit().getScreenSize();\r\n        component.setLocation((screenSize.width - paneSize.width) / 2, (screenSize.height - paneSize.height) / 2);\r\n    }\r\n\r\n    private static HandballModel createHandballModel() {\r\n        HandballModel model = new HandballModel();\r\n        return model;\r\n    }\r\n\r\n    /**\r\n     * Die Instanz des Anwendungsfensters\r\n     *\r\n     * @return window\r\n     */\r\n    public static JFrame getWindow() {\r\n        return window;\r\n    }\r\n\r\n    /**\r\n     * Instanz des Spielfeld-Panels\r\n     *\r\n     * @return panel\r\n     */\r\n    public static Field getField() {\r\n        return field;\r\n    }\r\n\r\n    /**\r\n     * Instanz der Speichern-Aktion\r\n     *\r\n     * @return saveAction\r\n     */\r\n    public static SaveAction getSaveAction() {\r\n        return saveAction;\r\n    }\r\n\r\n    public static SetMoveNameAction getSetNameAction() {\r\n        return setNameAction;\r\n    }\r\n\r\n    /**\r\n     * Instanz der Schlie�en-Aktion\r\n     *\r\n     * @return close Action\r\n     */\r\n    public static CloseAction getCloseAction() {\r\n        return closeAction;\r\n    }\r\n\r\n    /**\r\n     * Methode um eine tiefe Objektkopie per Serialisierung zu erzeugen!\r\n     *\r\n     * @param oldObj (muss Serializable implementieren)\r\n     * @return tiefe Kopie\r\n     * @throws Exception\r\n     */\r\n    public static Object deepCopy(Object oldObj) throws Exception {\r\n        Object clone = null;\r\n        try {\r\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n            ObjectOutputStream oos = new ObjectOutputStream(baos);\r\n            oos.writeObject(oldObj);\r\n            oos.flush();\r\n            ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray()));\r\n            clone = ois.readObject();\r\n            oos.close();\r\n            ois.close();\r\n        } catch (Exception e) {\r\n            //$NON-NLS-1$\r\n            System.out.println(\"Exception in ObjectCloner = \" + e);\r\n            throw (e);\r\n        }\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Liefert die Version der Anwendung als String\r\n     *\r\n     * @return version\r\n     */\r\n    public static String getVersion() {\r\n        //$NON-NLS-1$\r\n        return \"1.0.5\";\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/MainTest8.java",
		"test_prompt": "// MainTest8.java\npackage visu.handball.moves;\n\nimport java.awt.BorderLayout;\nimport java.awt.Color;\nimport java.awt.Component;\nimport java.awt.Dimension;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.net.URL;\nimport javax.swing.ImageIcon;\nimport javax.swing.JDesktopPane;\nimport javax.swing.JFrame;\nimport javax.swing.JInternalFrame;\nimport javax.swing.JMenu;\nimport javax.swing.JMenuBar;\nimport javax.swing.JPanel;\nimport javax.swing.JScrollPane;\nimport javax.swing.JTable;\nimport javax.swing.JToolBar;\nimport javax.swing.ListSelectionModel;\nimport javax.swing.UIManager;\nimport visu.handball.moves.actions.AboutAction;\nimport visu.handball.moves.actions.ChangeColorsAction;\nimport visu.handball.moves.actions.CloseAction;\nimport visu.handball.moves.actions.CreateMovePdfAction;\nimport visu.handball.moves.actions.DeleteEventAction;\nimport visu.handball.moves.actions.NewAction;\nimport visu.handball.moves.actions.NewMoveEventAction;\nimport visu.handball.moves.actions.NewPassEventAction;\nimport visu.handball.moves.actions.NewSequenceAction;\nimport visu.handball.moves.actions.OpenAction;\nimport visu.handball.moves.actions.PauseAnimationAction;\nimport visu.handball.moves.actions.PrintActualSequenzAction;\nimport visu.handball.moves.actions.PrintMoveAction;\nimport visu.handball.moves.actions.SaveAction;\nimport visu.handball.moves.actions.SetMoveNameAction;\nimport visu.handball.moves.actions.StartAnimationAction;\nimport visu.handball.moves.actions.StartOneSequenceAnimationAction;\nimport visu.handball.moves.actions.StopAnimationAction;\nimport visu.handball.moves.controller.CommentController;\nimport visu.handball.moves.controller.JMenuHelper;\nimport visu.handball.moves.controller.MouseController;\nimport visu.handball.moves.model.ColorModel;\nimport visu.handball.moves.model.HandballModel;\nimport visu.handball.moves.model.TableHandballModel;\nimport visu.handball.moves.model.TableSelectionListener;\nimport visu.handball.moves.resources.Resources;\nimport visu.handball.moves.views.CommentView;\nimport visu.handball.moves.views.EventTableCellDelayEditor;\nimport visu.handball.moves.views.EventTableCellRenderer;\nimport visu.handball.moves.views.Field;\nimport visu.handball.moves.views.PlayerToolBar;\nimport visu.handball.moves.views.StatusBar;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Main}.\n* It contains ten unit test cases for the {@link Main#deepCopy(Object)} method.\n*/\nclass MainTest8 {"
	},
	{
		"original_code": "// Main.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves;\r\n\r\nimport java.awt.BorderLayout;\r\nimport java.awt.Color;\r\nimport java.awt.Component;\r\nimport java.awt.Dimension;\r\nimport java.awt.event.WindowAdapter;\r\nimport java.awt.event.WindowEvent;\r\nimport java.io.ByteArrayInputStream;\r\nimport java.io.ByteArrayOutputStream;\r\nimport java.io.ObjectInputStream;\r\nimport java.io.ObjectOutputStream;\r\nimport java.net.URL;\r\nimport javax.swing.ImageIcon;\r\nimport javax.swing.JDesktopPane;\r\nimport javax.swing.JFrame;\r\nimport javax.swing.JInternalFrame;\r\nimport javax.swing.JMenu;\r\nimport javax.swing.JMenuBar;\r\nimport javax.swing.JPanel;\r\nimport javax.swing.JScrollPane;\r\nimport javax.swing.JTable;\r\nimport javax.swing.JToolBar;\r\nimport javax.swing.ListSelectionModel;\r\nimport javax.swing.UIManager;\r\nimport visu.handball.moves.actions.AboutAction;\r\nimport visu.handball.moves.actions.ChangeColorsAction;\r\nimport visu.handball.moves.actions.CloseAction;\r\nimport visu.handball.moves.actions.CreateMovePdfAction;\r\nimport visu.handball.moves.actions.DeleteEventAction;\r\nimport visu.handball.moves.actions.NewAction;\r\nimport visu.handball.moves.actions.NewMoveEventAction;\r\nimport visu.handball.moves.actions.NewPassEventAction;\r\nimport visu.handball.moves.actions.NewSequenceAction;\r\nimport visu.handball.moves.actions.OpenAction;\r\nimport visu.handball.moves.actions.PauseAnimationAction;\r\nimport visu.handball.moves.actions.PrintActualSequenzAction;\r\nimport visu.handball.moves.actions.PrintMoveAction;\r\nimport visu.handball.moves.actions.SaveAction;\r\nimport visu.handball.moves.actions.SetMoveNameAction;\r\nimport visu.handball.moves.actions.StartAnimationAction;\r\nimport visu.handball.moves.actions.StartOneSequenceAnimationAction;\r\nimport visu.handball.moves.actions.StopAnimationAction;\r\nimport visu.handball.moves.controller.CommentController;\r\nimport visu.handball.moves.controller.JMenuHelper;\r\nimport visu.handball.moves.controller.MouseController;\r\nimport visu.handball.moves.model.ColorModel;\r\nimport visu.handball.moves.model.HandballModel;\r\nimport visu.handball.moves.model.TableHandballModel;\r\nimport visu.handball.moves.model.TableSelectionListener;\r\nimport visu.handball.moves.resources.Resources;\r\nimport visu.handball.moves.views.CommentView;\r\nimport visu.handball.moves.views.EventTableCellDelayEditor;\r\nimport visu.handball.moves.views.EventTableCellRenderer;\r\nimport visu.handball.moves.views.Field;\r\nimport visu.handball.moves.views.PlayerToolBar;\r\nimport visu.handball.moves.views.StatusBar;\r\n\r\n/**\r\n * Hauptklasse zum Starten der Anwendung plus den Zugriff auf die entsprechenden Objekt-Instanzen\r\n * @author tommy\r\n */\r\npublic class Main {\r\n\r\n    private static SaveAction saveAction;\r\n\r\n    private static CloseAction closeAction;\r\n\r\n    private static SetMoveNameAction setNameAction;\r\n\r\n    private static JFrame window;\r\n\r\n    private static Field field;\r\n\r\n    private static CommentView commentView;\r\n\r\n    private static ColorModel colorModel;\r\n\r\n    /**\r\n     * Liefert die Instanz des ColorModels\r\n     *\r\n     * @return colorModel\r\n     */\r\n    public static ColorModel getColorModel() {\r\n        return colorModel;\r\n    }\r\n\r\n    /**\r\n     * Main-Methode zum Starten der Anwendung\r\n     *\r\n     * @param args\r\n     */\r\n    public static void main(String[] args) {\r\n        try {\r\n            UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\r\n        } catch (Exception e) {\r\n            System.out.println(//$NON-NLS-1$\r\n            Resources.getString(\"error.lookAndFell\"));\r\n        }\r\n        //$NON-NLS-1$\r\n        window = new JFrame(Resources.getString(\"app.title\"));\r\n        //$NON-NLS-1$ //$NON-NLS-2$\r\n        window.setIconImage(createImageIcon(\"images/icon.gif\", \"\").getImage());\r\n        JPanel content = new JPanel(new BorderLayout());\r\n        JDesktopPane desktop = new JDesktopPane();\r\n        window.setContentPane(content);\r\n        content.add(desktop, BorderLayout.CENTER);\r\n        desktop.setBackground(new Color(255, 255, 174));\r\n        desktop.setDragMode(JDesktopPane.OUTLINE_DRAG_MODE);\r\n        // Create HandballModel\r\n        HandballModel handballModel = createHandballModel();\r\n        // Create ColorModel\r\n        colorModel = new ColorModel();\r\n        // Statusbar\r\n        StatusBar statusBar = createStatusBar(handballModel);\r\n        content.add(statusBar, BorderLayout.SOUTH);\r\n        // Create Menu\r\n        JMenuBar menu = createHandballMenu(handballModel);\r\n        window.setJMenuBar(menu);\r\n        // Create HandballField\r\n        field = new Field(handballModel, colorModel);\r\n        JInternalFrame handballField = new //$NON-NLS-1$\r\n        JInternalFrame(//$NON-NLS-1$\r\n        Resources.getString(\"field.title\"), //$NON-NLS-1$\r\n        false, false, false, true);\r\n        handballField.setLocation(10, 10);\r\n        handballField.add(field);\r\n        handballField.setVisible(true);\r\n        handballField.pack();\r\n        desktop.add(handballField);\r\n        // Create MouseController\r\n        MouseController mouse = new MouseController(handballModel, handballField);\r\n        field.addMouseListener(mouse);\r\n        field.addMouseMotionListener(mouse);\r\n        // Add Statusbar as Listener\r\n        field.addMouseMotionListener(statusBar);\r\n        // Create ToolBar\r\n        PlayerToolBar playerBar = new PlayerToolBar(handballModel);\r\n        content.add(playerBar, BorderLayout.NORTH);\r\n        // Create EventView\r\n        JPanel tablePanel = createTablePanel(handballModel);\r\n        JInternalFrame eventView = new //$NON-NLS-1$\r\n        JInternalFrame(//$NON-NLS-1$\r\n        Resources.getString(\"events.title\"), //$NON-NLS-1$\r\n        true, false, false, true);\r\n        eventView.add(tablePanel);\r\n        eventView.setLocation(20 + handballField.getWidth(), 10);\r\n        eventView.setVisible(true);\r\n        eventView.setSize(450, 400);\r\n        desktop.add(eventView);\r\n        // Create CommentView\r\n        //$NON-NLS-1$\r\n        commentView = new CommentView(Resources.getString(\"comment.title\"));\r\n        commentView.setLocation(20 + handballField.getWidth(), 420);\r\n        commentView.setSize(450, handballField.getHeight() - eventView.getHeight() - 10);\r\n        commentView.setVisible(true);\r\n        //Controller für CommentView erzeugen\r\n        new CommentController(handballModel, commentView);\r\n        desktop.add(commentView);\r\n        window.setSize(1000, 700);\r\n        locateOnScreenCenter(window);\r\n        window.addWindowListener(new WindowAdapter() {\r\n\r\n            public void windowClosing(WindowEvent e) {\r\n                Main.getCloseAction().actionPerformed(null);\r\n            }\r\n        });\r\n        window.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);\r\n        window.setVisible(true);\r\n    }\r\n\r\n    private static JMenuBar createHandballMenu(HandballModel handballModel) {\r\n        JMenuBar mbar;\r\n        JMenu menuDatei, menuHilfe, menuEinstellungen;\r\n        // Hauptmenue einrichten\r\n        mbar = new JMenuBar();\r\n        //$NON-NLS-1$\r\n        menuDatei = JMenuHelper.addMenuBarItem(mbar, Resources.getString(\"menu.file\"));\r\n        //$NON-NLS-1$\r\n        menuEinstellungen = JMenuHelper.addMenuBarItem(mbar, Resources.getString(\"menu.settings\"));\r\n        //$NON-NLS-1$\r\n        menuHilfe = JMenuHelper.addMenuBarItem(mbar, Resources.getString(\"menu.about\"));\r\n        // Einträge fuer Datei\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", new //$NON-NLS-1$\r\n        NewAction(handballModel));\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", new //$NON-NLS-1$\r\n        OpenAction(handballModel));\r\n        //Separator einfügen\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"-\");\r\n        saveAction = new SaveAction(handballModel);\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", saveAction);\r\n        // Separator einfügen\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"-\");\r\n        setNameAction = new SetMoveNameAction(handballModel);\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", setNameAction);\r\n        //Separator einfügen\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"-\");\r\n        //Drucken einfügen\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", new //$NON-NLS-1$\r\n        PrintActualSequenzAction(handballModel));\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", new PrintMoveAction(handballModel));\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", new CreateMovePdfAction(handballModel));\r\n        // Separator einfügen\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"-\");\r\n        closeAction = new CloseAction(handballModel);\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuDatei, \"\", closeAction);\r\n        // Einträge für Einstellungen\r\n        //$NON-NLS-1$\r\n        JMenuHelper.addMenuItem(menuEinstellungen, \"\", new ChangeColorsAction());\r\n        // Einträge für Hilfe\r\n        //$NON-NLS-1$\r\n        JMenuHelper.//$NON-NLS-1$\r\n        addMenuItem(//$NON-NLS-1$\r\n        menuHilfe, //$NON-NLS-1$\r\n        \"\", new AboutAction());\r\n        return mbar;\r\n    }\r\n\r\n    private static JPanel createTablePanel(HandballModel handballModel) {\r\n        TableHandballModel tableModel = new TableHandballModel(handballModel);\r\n        JTable table = new JTable(tableModel);\r\n        table.setDefaultRenderer(Object.class, new EventTableCellRenderer());\r\n        table.getColumnModel().getColumn(0).setPreferredWidth(100);\r\n        table.getColumnModel().getColumn(1).setPreferredWidth(200);\r\n        EventTableCellDelayEditor delayEditor = new EventTableCellDelayEditor();\r\n        table.getColumnModel().getColumn(3).setCellEditor(delayEditor);\r\n        table.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\r\n        table.getSelectionModel().addListSelectionListener(new TableSelectionListener(tableModel));\r\n        JPanel panel = new JPanel(new BorderLayout());\r\n        //$NON-NLS-1$\r\n        JToolBar toolBar = new JToolBar(Resources.getString(\"toolbar.title\"));\r\n        toolBar.add(new NewMoveEventAction(handballModel));\r\n        toolBar.add(new NewSequenceAction(handballModel));\r\n        toolBar.add(new NewPassEventAction(handballModel));\r\n        toolBar.add(new DeleteEventAction(handballModel));\r\n        toolBar.addSeparator();\r\n        toolBar.add(new StartOneSequenceAnimationAction(handballModel));\r\n        toolBar.add(new StartAnimationAction(handballModel));\r\n        toolBar.add(new PauseAnimationAction(handballModel));\r\n        toolBar.add(new StopAnimationAction(handballModel));\r\n        JScrollPane scroll = new JScrollPane(table);\r\n        panel.add(scroll, BorderLayout.CENTER);\r\n        panel.add(toolBar, BorderLayout.PAGE_START);\r\n        return panel;\r\n    }\r\n\r\n    private static StatusBar createStatusBar(HandballModel model) {\r\n        StatusBar statusBar = new StatusBar(model);\r\n        return statusBar;\r\n    }\r\n\r\n    /**\r\n     * Basierend auf der relativen Pfad (relativ zum Ort dieser Klasse) und der Beschreibung\r\n     * wird ein Grafik geladen und ein ImageIcon-Objekt erstellt.\r\n     * @param path\r\n     * @param description\r\n     *\r\n     * @return imageIcon\r\n     */\r\n    public static ImageIcon createImageIcon(String path, String description) {\r\n        URL url = Main.class.getResource(path);\r\n        return new ImageIcon(url, description);\r\n    }\r\n\r\n    /**\r\n     * Erzeugt auf Basis eines relativen Pfads (relativ zum Ort dieser Klasse) eine URL.\r\n     * @param path\r\n     *\r\n     * @return url\r\n     */\r\n    public static URL getResource(String path) {\r\n        return Main.class.getResource(path);\r\n    }\r\n\r\n    /**\r\n     * Methode um Component-Objekte (z.B. Fenster) in der Mitte des Bildschirms zu positionieren\r\n     * @param component\r\n     */\r\n    public static void locateOnScreenCenter(Component component) {\r\n        Dimension paneSize = component.getSize();\r\n        Dimension screenSize = component.getToolkit().getScreenSize();\r\n        component.setLocation((screenSize.width - paneSize.width) / 2, (screenSize.height - paneSize.height) / 2);\r\n    }\r\n\r\n    private static HandballModel createHandballModel() {\r\n        HandballModel model = new HandballModel();\r\n        return model;\r\n    }\r\n\r\n    /**\r\n     * Die Instanz des Anwendungsfensters\r\n     *\r\n     * @return window\r\n     */\r\n    public static JFrame getWindow() {\r\n        return window;\r\n    }\r\n\r\n    /**\r\n     * Instanz des Spielfeld-Panels\r\n     *\r\n     * @return panel\r\n     */\r\n    public static Field getField() {\r\n        return field;\r\n    }\r\n\r\n    /**\r\n     * Instanz der Speichern-Aktion\r\n     *\r\n     * @return saveAction\r\n     */\r\n    public static SaveAction getSaveAction() {\r\n        return saveAction;\r\n    }\r\n\r\n    public static SetMoveNameAction getSetNameAction() {\r\n        return setNameAction;\r\n    }\r\n\r\n    /**\r\n     * Instanz der Schlie�en-Aktion\r\n     *\r\n     * @return close Action\r\n     */\r\n    public static CloseAction getCloseAction() {\r\n        return closeAction;\r\n    }\r\n\r\n    /**\r\n     * Methode um eine tiefe Objektkopie per Serialisierung zu erzeugen!\r\n     *\r\n     * @param oldObj (muss Serializable implementieren)\r\n     * @return tiefe Kopie\r\n     * @throws Exception\r\n     */\r\n    public static Object deepCopy(Object oldObj) throws Exception {\r\n        Object clone = null;\r\n        try {\r\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n            ObjectOutputStream oos = new ObjectOutputStream(baos);\r\n            oos.writeObject(oldObj);\r\n            oos.flush();\r\n            ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray()));\r\n            clone = ois.readObject();\r\n            oos.close();\r\n            ois.close();\r\n        } catch (Exception e) {\r\n            //$NON-NLS-1$\r\n            System.out.println(\"Exception in ObjectCloner = \" + e);\r\n            throw (e);\r\n        }\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Liefert die Version der Anwendung als String\r\n     *\r\n     * @return version\r\n     */\r\n    public static String getVersion() {\r\n        //$NON-NLS-1$\r\n        return \"1.0.5\";\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/MainTest9.java",
		"test_prompt": "// MainTest9.java\npackage visu.handball.moves;\n\nimport java.awt.BorderLayout;\nimport java.awt.Color;\nimport java.awt.Component;\nimport java.awt.Dimension;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.net.URL;\nimport javax.swing.ImageIcon;\nimport javax.swing.JDesktopPane;\nimport javax.swing.JFrame;\nimport javax.swing.JInternalFrame;\nimport javax.swing.JMenu;\nimport javax.swing.JMenuBar;\nimport javax.swing.JPanel;\nimport javax.swing.JScrollPane;\nimport javax.swing.JTable;\nimport javax.swing.JToolBar;\nimport javax.swing.ListSelectionModel;\nimport javax.swing.UIManager;\nimport visu.handball.moves.actions.AboutAction;\nimport visu.handball.moves.actions.ChangeColorsAction;\nimport visu.handball.moves.actions.CloseAction;\nimport visu.handball.moves.actions.CreateMovePdfAction;\nimport visu.handball.moves.actions.DeleteEventAction;\nimport visu.handball.moves.actions.NewAction;\nimport visu.handball.moves.actions.NewMoveEventAction;\nimport visu.handball.moves.actions.NewPassEventAction;\nimport visu.handball.moves.actions.NewSequenceAction;\nimport visu.handball.moves.actions.OpenAction;\nimport visu.handball.moves.actions.PauseAnimationAction;\nimport visu.handball.moves.actions.PrintActualSequenzAction;\nimport visu.handball.moves.actions.PrintMoveAction;\nimport visu.handball.moves.actions.SaveAction;\nimport visu.handball.moves.actions.SetMoveNameAction;\nimport visu.handball.moves.actions.StartAnimationAction;\nimport visu.handball.moves.actions.StartOneSequenceAnimationAction;\nimport visu.handball.moves.actions.StopAnimationAction;\nimport visu.handball.moves.controller.CommentController;\nimport visu.handball.moves.controller.JMenuHelper;\nimport visu.handball.moves.controller.MouseController;\nimport visu.handball.moves.model.ColorModel;\nimport visu.handball.moves.model.HandballModel;\nimport visu.handball.moves.model.TableHandballModel;\nimport visu.handball.moves.model.TableSelectionListener;\nimport visu.handball.moves.resources.Resources;\nimport visu.handball.moves.views.CommentView;\nimport visu.handball.moves.views.EventTableCellDelayEditor;\nimport visu.handball.moves.views.EventTableCellRenderer;\nimport visu.handball.moves.views.Field;\nimport visu.handball.moves.views.PlayerToolBar;\nimport visu.handball.moves.views.StatusBar;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Main}.\n* It contains ten unit test cases for the {@link Main#getVersion()} method.\n*/\nclass MainTest9 {"
	},
	{
		"original_code": "// MoveEvent.java\n/*\n * Created on 31.08.2006\n * Created by Richard Doerfler, Thomas Halm\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n */\npackage visu.handball.moves.model;\n\nimport java.io.Serializable;\nimport visu.handball.moves.model.player.Defender;\nimport visu.handball.moves.model.player.MovePoint;\nimport visu.handball.moves.model.player.Offender;\nimport visu.handball.moves.model.player.Player;\n\n/**\n * @author tommy\n */\npublic class MoveEvent implements Comparable<MoveEvent>, Serializable {\n\n    private static final long serialVersionUID = -5372891552466311536L;\n\n    /**\n     * Ereignis ist einem Spieler zugeordnet\n     */\n    protected Player player;\n\n    /**\n     * Ereignis besitzt eine Sequenz-Nummer (1. Ereignis hat die Sequenz-Nummer\n     * 0)\n     */\n    protected int sequenceNr;\n\n    /**\n     * Ereignis kann Verzögerung besitzen, d.h. gleiche Sequenz-Nummer aber\n     * Verzögerung. Erst nach Ablauf der Verzögerung innerhalb einer\n     * Sequenz-Animation wird dieses Ereignis animiert\n     */\n    protected int delay;\n\n    protected MovePoint destinationPoint;\n\n    protected MovePoint controlPoint;\n\n    protected int oldPlayerX;\n\n    protected int oldPlayerY;\n\n    protected boolean destinationPointTemporary = true;\n\n    protected boolean controlPointTemporary = true;\n\n    protected boolean marked = false;\n\n    public MoveEvent(Player player, int nr) {\n        this(player, nr, 0);\n    }\n\n    public MoveEvent(Player player, int nr, int delay) {\n        this.player = player;\n        this.sequenceNr = nr;\n        this.delay = delay;\n        destinationPoint = null;\n        controlPoint = null;\n        oldPlayerX = player.getCurrent_x();\n        oldPlayerY = player.getCurrent_y();\n    }\n\n    /**\n     * Liefert die Verzögerung des Ereignisses\n     *\n     * @return delay\n     */\n    public int getDelay() {\n        return delay;\n    }\n\n    /**\n     * Setzt die Verzögerung des Ereignisses\n     *\n     * @param delay\n     */\n    public void setDelay(int delay) {\n        this.delay = delay;\n    }\n\n    /**\n     * Liefert den zugeordneten Spieler\n     *\n     * @return player\n     */\n    public Player getPlayer() {\n        return player;\n    }\n\n    /**\n     * Ordnet den uebergebenen Spieler dem Ereignis zu (Es ist fraglich ob, dies\n     * nachträglich noch möglich sein muss)\n     *\n     * @param player\n     */\n    public void setPlayer(Player player) {\n        this.player = player;\n    }\n\n    /**\n     * Liefert die Sequenz-Nummer, des Ereignisses\n     *\n     * @return sequence\n     */\n    public int getSequenceNr() {\n        return sequenceNr;\n    }\n\n    /**\n     * Setzt die Sequenz-Nummer auf den übergebenen Wert\n     *\n     * @param sequenceNr\n     */\n    public void setSequenceNr(int sequenceNr) {\n        this.sequenceNr = sequenceNr;\n    }\n\n    public int compareTo(MoveEvent o) {\n        if (sequenceNr < o.sequenceNr)\n            return -1;\n        else if (sequenceNr > o.sequenceNr)\n            return 1;\n        else {\n            if (delay < o.getDelay()) {\n                return -1;\n            } else if (delay > o.getDelay()) {\n                return 1;\n            } else {\n                if (player.getPlayerNumber() < o.getPlayer().getPlayerNumber()) {\n                    return -1;\n                } else if (player.getPlayerNumber() > o.getPlayer().getPlayerNumber()) {\n                    return 1;\n                } else if ((player instanceof Offender) && (o.getPlayer() instanceof Defender)) {\n                    return -1;\n                } else if ((player instanceof Defender) && (o.getPlayer() instanceof Offender)) {\n                    return 1;\n                } else {\n                    if (this instanceof PassEvent && !(o instanceof PassEvent)) {\n                        return -1;\n                    } else if (o instanceof PassEvent && !(this instanceof PassEvent)) {\n                        return 1;\n                    }\n                    // gleich, kann dann nicht dem sorted-Set hinzugefügt werden\n                    return 0;\n                }\n            }\n        }\n    }\n\n    public void setPoint(MovePoint point, int x, int y) {\n        if (point.equals(controlPoint)) {\n            setControlPoint(x, y, false);\n        } else if (point.equals(destinationPoint)) {\n            setDestinationPoint(x, y, false);\n        }\n    }\n\n    public void setControlPoint(int x, int y, boolean temp) {\n        controlPointTemporary = temp;\n        if (controlPoint == null) {\n            controlPoint = new MovePoint(x, y);\n        } else {\n            controlPoint.setCurrent_x(x);\n            controlPoint.setCurrent_y(y);\n        }\n    }\n\n    public void setDestinationPoint(int x, int y, boolean temp) {\n        destinationPointTemporary = temp;\n        if (destinationPoint == null) {\n            destinationPoint = new MovePoint(x, y);\n        } else {\n            destinationPoint.setCurrent_x(x);\n            destinationPoint.setCurrent_y(y);\n        }\n    }\n\n    @Override\n    public String toString() {\n        String str = \"\";\n        if (destinationPoint == null) {\n            str = \"Laufweg nicht definiert\";\n        } else {\n            str = \"Laufweg zu Position (\" + destinationPoint.getCurrent_x() + \",\" + destinationPoint.getCurrent_y() + \")\";\n        }\n        return str;\n    }\n\n    public int getDestinationX() {\n        return destinationPoint.getCurrent_x();\n    }\n\n    public int getDestinationY() {\n        return destinationPoint.getCurrent_y();\n    }\n\n    public MovePoint getControlPoint() {\n        return controlPoint;\n    }\n\n    public MovePoint getDestinationPoint() {\n        return destinationPoint;\n    }\n\n    public int getControlPointX() {\n        return controlPoint.getCurrent_x();\n    }\n\n    public int getControlPointY() {\n        return controlPoint.getCurrent_y();\n    }\n\n    public boolean isControlPointSet() {\n        return !controlPointTemporary;\n    }\n\n    public boolean isDestinationPointSet() {\n        return !destinationPointTemporary;\n    }\n\n    public boolean isMarked() {\n        return marked;\n    }\n\n    public void setMarked(boolean marked) {\n        this.marked = marked;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (obj.getClass() != getClass())\n            return false;\n        MoveEvent other = (MoveEvent) obj;\n        if (other.getControlPoint() == null ^ this.getControlPoint() == null) {\n            return false;\n        }\n        if (other.getControlPoint() == null) {\n            // hier ist dann auch this.getControllPoint == null\n            if (other.getDestinationX() != this.getDestinationX() || other.getDestinationY() != this.getDestinationY() || other.getDelay() != this.getDelay() || !other.getPlayer().equals(this.getPlayer()) || other.getSequenceNr() != this.getSequenceNr()) {\n                return false;\n            }\n        } else if (other.getControlPointX() != this.getControlPointX() || other.getControlPointY() != this.getControlPointY() || other.getDestinationX() != this.getDestinationX() || other.getDestinationY() != this.getDestinationY() || other.getDelay() != this.getDelay() || !other.getPlayer().equals(this.getPlayer()) || other.getSequenceNr() != this.getSequenceNr()) {\n            return false;\n        }\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/model/MoveEventTest0.java",
		"test_prompt": "// MoveEventTest0.java\npackage visu.handball.moves.model;\n\nimport java.io.Serializable;\nimport visu.handball.moves.model.player.Defender;\nimport visu.handball.moves.model.player.MovePoint;\nimport visu.handball.moves.model.player.Offender;\nimport visu.handball.moves.model.player.Player;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MoveEvent}.\n* It contains ten unit test cases for the {@link MoveEvent#compareTo(MoveEvent)} method.\n*/\nclass MoveEventTest0 {"
	},
	{
		"original_code": "// MoveEvent.java\n/*\n * Created on 31.08.2006\n * Created by Richard Doerfler, Thomas Halm\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n */\npackage visu.handball.moves.model;\n\nimport java.io.Serializable;\nimport visu.handball.moves.model.player.Defender;\nimport visu.handball.moves.model.player.MovePoint;\nimport visu.handball.moves.model.player.Offender;\nimport visu.handball.moves.model.player.Player;\n\n/**\n * @author tommy\n */\npublic class MoveEvent implements Comparable<MoveEvent>, Serializable {\n\n    private static final long serialVersionUID = -5372891552466311536L;\n\n    /**\n     * Ereignis ist einem Spieler zugeordnet\n     */\n    protected Player player;\n\n    /**\n     * Ereignis besitzt eine Sequenz-Nummer (1. Ereignis hat die Sequenz-Nummer\n     * 0)\n     */\n    protected int sequenceNr;\n\n    /**\n     * Ereignis kann Verzögerung besitzen, d.h. gleiche Sequenz-Nummer aber\n     * Verzögerung. Erst nach Ablauf der Verzögerung innerhalb einer\n     * Sequenz-Animation wird dieses Ereignis animiert\n     */\n    protected int delay;\n\n    protected MovePoint destinationPoint;\n\n    protected MovePoint controlPoint;\n\n    protected int oldPlayerX;\n\n    protected int oldPlayerY;\n\n    protected boolean destinationPointTemporary = true;\n\n    protected boolean controlPointTemporary = true;\n\n    protected boolean marked = false;\n\n    public MoveEvent(Player player, int nr) {\n        this(player, nr, 0);\n    }\n\n    public MoveEvent(Player player, int nr, int delay) {\n        this.player = player;\n        this.sequenceNr = nr;\n        this.delay = delay;\n        destinationPoint = null;\n        controlPoint = null;\n        oldPlayerX = player.getCurrent_x();\n        oldPlayerY = player.getCurrent_y();\n    }\n\n    /**\n     * Liefert die Verzögerung des Ereignisses\n     *\n     * @return delay\n     */\n    public int getDelay() {\n        return delay;\n    }\n\n    /**\n     * Setzt die Verzögerung des Ereignisses\n     *\n     * @param delay\n     */\n    public void setDelay(int delay) {\n        this.delay = delay;\n    }\n\n    /**\n     * Liefert den zugeordneten Spieler\n     *\n     * @return player\n     */\n    public Player getPlayer() {\n        return player;\n    }\n\n    /**\n     * Ordnet den uebergebenen Spieler dem Ereignis zu (Es ist fraglich ob, dies\n     * nachträglich noch möglich sein muss)\n     *\n     * @param player\n     */\n    public void setPlayer(Player player) {\n        this.player = player;\n    }\n\n    /**\n     * Liefert die Sequenz-Nummer, des Ereignisses\n     *\n     * @return sequence\n     */\n    public int getSequenceNr() {\n        return sequenceNr;\n    }\n\n    /**\n     * Setzt die Sequenz-Nummer auf den übergebenen Wert\n     *\n     * @param sequenceNr\n     */\n    public void setSequenceNr(int sequenceNr) {\n        this.sequenceNr = sequenceNr;\n    }\n\n    public int compareTo(MoveEvent o) {\n        if (sequenceNr < o.sequenceNr)\n            return -1;\n        else if (sequenceNr > o.sequenceNr)\n            return 1;\n        else {\n            if (delay < o.getDelay()) {\n                return -1;\n            } else if (delay > o.getDelay()) {\n                return 1;\n            } else {\n                if (player.getPlayerNumber() < o.getPlayer().getPlayerNumber()) {\n                    return -1;\n                } else if (player.getPlayerNumber() > o.getPlayer().getPlayerNumber()) {\n                    return 1;\n                } else if ((player instanceof Offender) && (o.getPlayer() instanceof Defender)) {\n                    return -1;\n                } else if ((player instanceof Defender) && (o.getPlayer() instanceof Offender)) {\n                    return 1;\n                } else {\n                    if (this instanceof PassEvent && !(o instanceof PassEvent)) {\n                        return -1;\n                    } else if (o instanceof PassEvent && !(this instanceof PassEvent)) {\n                        return 1;\n                    }\n                    // gleich, kann dann nicht dem sorted-Set hinzugefügt werden\n                    return 0;\n                }\n            }\n        }\n    }\n\n    public void setPoint(MovePoint point, int x, int y) {\n        if (point.equals(controlPoint)) {\n            setControlPoint(x, y, false);\n        } else if (point.equals(destinationPoint)) {\n            setDestinationPoint(x, y, false);\n        }\n    }\n\n    public void setControlPoint(int x, int y, boolean temp) {\n        controlPointTemporary = temp;\n        if (controlPoint == null) {\n            controlPoint = new MovePoint(x, y);\n        } else {\n            controlPoint.setCurrent_x(x);\n            controlPoint.setCurrent_y(y);\n        }\n    }\n\n    public void setDestinationPoint(int x, int y, boolean temp) {\n        destinationPointTemporary = temp;\n        if (destinationPoint == null) {\n            destinationPoint = new MovePoint(x, y);\n        } else {\n            destinationPoint.setCurrent_x(x);\n            destinationPoint.setCurrent_y(y);\n        }\n    }\n\n    @Override\n    public String toString() {\n        String str = \"\";\n        if (destinationPoint == null) {\n            str = \"Laufweg nicht definiert\";\n        } else {\n            str = \"Laufweg zu Position (\" + destinationPoint.getCurrent_x() + \",\" + destinationPoint.getCurrent_y() + \")\";\n        }\n        return str;\n    }\n\n    public int getDestinationX() {\n        return destinationPoint.getCurrent_x();\n    }\n\n    public int getDestinationY() {\n        return destinationPoint.getCurrent_y();\n    }\n\n    public MovePoint getControlPoint() {\n        return controlPoint;\n    }\n\n    public MovePoint getDestinationPoint() {\n        return destinationPoint;\n    }\n\n    public int getControlPointX() {\n        return controlPoint.getCurrent_x();\n    }\n\n    public int getControlPointY() {\n        return controlPoint.getCurrent_y();\n    }\n\n    public boolean isControlPointSet() {\n        return !controlPointTemporary;\n    }\n\n    public boolean isDestinationPointSet() {\n        return !destinationPointTemporary;\n    }\n\n    public boolean isMarked() {\n        return marked;\n    }\n\n    public void setMarked(boolean marked) {\n        this.marked = marked;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (obj.getClass() != getClass())\n            return false;\n        MoveEvent other = (MoveEvent) obj;\n        if (other.getControlPoint() == null ^ this.getControlPoint() == null) {\n            return false;\n        }\n        if (other.getControlPoint() == null) {\n            // hier ist dann auch this.getControllPoint == null\n            if (other.getDestinationX() != this.getDestinationX() || other.getDestinationY() != this.getDestinationY() || other.getDelay() != this.getDelay() || !other.getPlayer().equals(this.getPlayer()) || other.getSequenceNr() != this.getSequenceNr()) {\n                return false;\n            }\n        } else if (other.getControlPointX() != this.getControlPointX() || other.getControlPointY() != this.getControlPointY() || other.getDestinationX() != this.getDestinationX() || other.getDestinationY() != this.getDestinationY() || other.getDelay() != this.getDelay() || !other.getPlayer().equals(this.getPlayer()) || other.getSequenceNr() != this.getSequenceNr()) {\n            return false;\n        }\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/model/MoveEventTest1.java",
		"test_prompt": "// MoveEventTest1.java\npackage visu.handball.moves.model;\n\nimport java.io.Serializable;\nimport visu.handball.moves.model.player.Defender;\nimport visu.handball.moves.model.player.MovePoint;\nimport visu.handball.moves.model.player.Offender;\nimport visu.handball.moves.model.player.Player;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MoveEvent}.\n* It contains ten unit test cases for the {@link MoveEvent#isControlPointSet()} method.\n*/\nclass MoveEventTest1 {"
	},
	{
		"original_code": "// MoveEvent.java\n/*\n * Created on 31.08.2006\n * Created by Richard Doerfler, Thomas Halm\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n */\npackage visu.handball.moves.model;\n\nimport java.io.Serializable;\nimport visu.handball.moves.model.player.Defender;\nimport visu.handball.moves.model.player.MovePoint;\nimport visu.handball.moves.model.player.Offender;\nimport visu.handball.moves.model.player.Player;\n\n/**\n * @author tommy\n */\npublic class MoveEvent implements Comparable<MoveEvent>, Serializable {\n\n    private static final long serialVersionUID = -5372891552466311536L;\n\n    /**\n     * Ereignis ist einem Spieler zugeordnet\n     */\n    protected Player player;\n\n    /**\n     * Ereignis besitzt eine Sequenz-Nummer (1. Ereignis hat die Sequenz-Nummer\n     * 0)\n     */\n    protected int sequenceNr;\n\n    /**\n     * Ereignis kann Verzögerung besitzen, d.h. gleiche Sequenz-Nummer aber\n     * Verzögerung. Erst nach Ablauf der Verzögerung innerhalb einer\n     * Sequenz-Animation wird dieses Ereignis animiert\n     */\n    protected int delay;\n\n    protected MovePoint destinationPoint;\n\n    protected MovePoint controlPoint;\n\n    protected int oldPlayerX;\n\n    protected int oldPlayerY;\n\n    protected boolean destinationPointTemporary = true;\n\n    protected boolean controlPointTemporary = true;\n\n    protected boolean marked = false;\n\n    public MoveEvent(Player player, int nr) {\n        this(player, nr, 0);\n    }\n\n    public MoveEvent(Player player, int nr, int delay) {\n        this.player = player;\n        this.sequenceNr = nr;\n        this.delay = delay;\n        destinationPoint = null;\n        controlPoint = null;\n        oldPlayerX = player.getCurrent_x();\n        oldPlayerY = player.getCurrent_y();\n    }\n\n    /**\n     * Liefert die Verzögerung des Ereignisses\n     *\n     * @return delay\n     */\n    public int getDelay() {\n        return delay;\n    }\n\n    /**\n     * Setzt die Verzögerung des Ereignisses\n     *\n     * @param delay\n     */\n    public void setDelay(int delay) {\n        this.delay = delay;\n    }\n\n    /**\n     * Liefert den zugeordneten Spieler\n     *\n     * @return player\n     */\n    public Player getPlayer() {\n        return player;\n    }\n\n    /**\n     * Ordnet den uebergebenen Spieler dem Ereignis zu (Es ist fraglich ob, dies\n     * nachträglich noch möglich sein muss)\n     *\n     * @param player\n     */\n    public void setPlayer(Player player) {\n        this.player = player;\n    }\n\n    /**\n     * Liefert die Sequenz-Nummer, des Ereignisses\n     *\n     * @return sequence\n     */\n    public int getSequenceNr() {\n        return sequenceNr;\n    }\n\n    /**\n     * Setzt die Sequenz-Nummer auf den übergebenen Wert\n     *\n     * @param sequenceNr\n     */\n    public void setSequenceNr(int sequenceNr) {\n        this.sequenceNr = sequenceNr;\n    }\n\n    public int compareTo(MoveEvent o) {\n        if (sequenceNr < o.sequenceNr)\n            return -1;\n        else if (sequenceNr > o.sequenceNr)\n            return 1;\n        else {\n            if (delay < o.getDelay()) {\n                return -1;\n            } else if (delay > o.getDelay()) {\n                return 1;\n            } else {\n                if (player.getPlayerNumber() < o.getPlayer().getPlayerNumber()) {\n                    return -1;\n                } else if (player.getPlayerNumber() > o.getPlayer().getPlayerNumber()) {\n                    return 1;\n                } else if ((player instanceof Offender) && (o.getPlayer() instanceof Defender)) {\n                    return -1;\n                } else if ((player instanceof Defender) && (o.getPlayer() instanceof Offender)) {\n                    return 1;\n                } else {\n                    if (this instanceof PassEvent && !(o instanceof PassEvent)) {\n                        return -1;\n                    } else if (o instanceof PassEvent && !(this instanceof PassEvent)) {\n                        return 1;\n                    }\n                    // gleich, kann dann nicht dem sorted-Set hinzugefügt werden\n                    return 0;\n                }\n            }\n        }\n    }\n\n    public void setPoint(MovePoint point, int x, int y) {\n        if (point.equals(controlPoint)) {\n            setControlPoint(x, y, false);\n        } else if (point.equals(destinationPoint)) {\n            setDestinationPoint(x, y, false);\n        }\n    }\n\n    public void setControlPoint(int x, int y, boolean temp) {\n        controlPointTemporary = temp;\n        if (controlPoint == null) {\n            controlPoint = new MovePoint(x, y);\n        } else {\n            controlPoint.setCurrent_x(x);\n            controlPoint.setCurrent_y(y);\n        }\n    }\n\n    public void setDestinationPoint(int x, int y, boolean temp) {\n        destinationPointTemporary = temp;\n        if (destinationPoint == null) {\n            destinationPoint = new MovePoint(x, y);\n        } else {\n            destinationPoint.setCurrent_x(x);\n            destinationPoint.setCurrent_y(y);\n        }\n    }\n\n    @Override\n    public String toString() {\n        String str = \"\";\n        if (destinationPoint == null) {\n            str = \"Laufweg nicht definiert\";\n        } else {\n            str = \"Laufweg zu Position (\" + destinationPoint.getCurrent_x() + \",\" + destinationPoint.getCurrent_y() + \")\";\n        }\n        return str;\n    }\n\n    public int getDestinationX() {\n        return destinationPoint.getCurrent_x();\n    }\n\n    public int getDestinationY() {\n        return destinationPoint.getCurrent_y();\n    }\n\n    public MovePoint getControlPoint() {\n        return controlPoint;\n    }\n\n    public MovePoint getDestinationPoint() {\n        return destinationPoint;\n    }\n\n    public int getControlPointX() {\n        return controlPoint.getCurrent_x();\n    }\n\n    public int getControlPointY() {\n        return controlPoint.getCurrent_y();\n    }\n\n    public boolean isControlPointSet() {\n        return !controlPointTemporary;\n    }\n\n    public boolean isDestinationPointSet() {\n        return !destinationPointTemporary;\n    }\n\n    public boolean isMarked() {\n        return marked;\n    }\n\n    public void setMarked(boolean marked) {\n        this.marked = marked;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (obj.getClass() != getClass())\n            return false;\n        MoveEvent other = (MoveEvent) obj;\n        if (other.getControlPoint() == null ^ this.getControlPoint() == null) {\n            return false;\n        }\n        if (other.getControlPoint() == null) {\n            // hier ist dann auch this.getControllPoint == null\n            if (other.getDestinationX() != this.getDestinationX() || other.getDestinationY() != this.getDestinationY() || other.getDelay() != this.getDelay() || !other.getPlayer().equals(this.getPlayer()) || other.getSequenceNr() != this.getSequenceNr()) {\n                return false;\n            }\n        } else if (other.getControlPointX() != this.getControlPointX() || other.getControlPointY() != this.getControlPointY() || other.getDestinationX() != this.getDestinationX() || other.getDestinationY() != this.getDestinationY() || other.getDelay() != this.getDelay() || !other.getPlayer().equals(this.getPlayer()) || other.getSequenceNr() != this.getSequenceNr()) {\n            return false;\n        }\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/model/MoveEventTest2.java",
		"test_prompt": "// MoveEventTest2.java\npackage visu.handball.moves.model;\n\nimport java.io.Serializable;\nimport visu.handball.moves.model.player.Defender;\nimport visu.handball.moves.model.player.MovePoint;\nimport visu.handball.moves.model.player.Offender;\nimport visu.handball.moves.model.player.Player;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MoveEvent}.\n* It contains ten unit test cases for the {@link MoveEvent#isDestinationPointSet()} method.\n*/\nclass MoveEventTest2 {"
	},
	{
		"original_code": "// MoveEvent.java\n/*\n * Created on 31.08.2006\n * Created by Richard Doerfler, Thomas Halm\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n */\npackage visu.handball.moves.model;\n\nimport java.io.Serializable;\nimport visu.handball.moves.model.player.Defender;\nimport visu.handball.moves.model.player.MovePoint;\nimport visu.handball.moves.model.player.Offender;\nimport visu.handball.moves.model.player.Player;\n\n/**\n * @author tommy\n */\npublic class MoveEvent implements Comparable<MoveEvent>, Serializable {\n\n    private static final long serialVersionUID = -5372891552466311536L;\n\n    /**\n     * Ereignis ist einem Spieler zugeordnet\n     */\n    protected Player player;\n\n    /**\n     * Ereignis besitzt eine Sequenz-Nummer (1. Ereignis hat die Sequenz-Nummer\n     * 0)\n     */\n    protected int sequenceNr;\n\n    /**\n     * Ereignis kann Verzögerung besitzen, d.h. gleiche Sequenz-Nummer aber\n     * Verzögerung. Erst nach Ablauf der Verzögerung innerhalb einer\n     * Sequenz-Animation wird dieses Ereignis animiert\n     */\n    protected int delay;\n\n    protected MovePoint destinationPoint;\n\n    protected MovePoint controlPoint;\n\n    protected int oldPlayerX;\n\n    protected int oldPlayerY;\n\n    protected boolean destinationPointTemporary = true;\n\n    protected boolean controlPointTemporary = true;\n\n    protected boolean marked = false;\n\n    public MoveEvent(Player player, int nr) {\n        this(player, nr, 0);\n    }\n\n    public MoveEvent(Player player, int nr, int delay) {\n        this.player = player;\n        this.sequenceNr = nr;\n        this.delay = delay;\n        destinationPoint = null;\n        controlPoint = null;\n        oldPlayerX = player.getCurrent_x();\n        oldPlayerY = player.getCurrent_y();\n    }\n\n    /**\n     * Liefert die Verzögerung des Ereignisses\n     *\n     * @return delay\n     */\n    public int getDelay() {\n        return delay;\n    }\n\n    /**\n     * Setzt die Verzögerung des Ereignisses\n     *\n     * @param delay\n     */\n    public void setDelay(int delay) {\n        this.delay = delay;\n    }\n\n    /**\n     * Liefert den zugeordneten Spieler\n     *\n     * @return player\n     */\n    public Player getPlayer() {\n        return player;\n    }\n\n    /**\n     * Ordnet den uebergebenen Spieler dem Ereignis zu (Es ist fraglich ob, dies\n     * nachträglich noch möglich sein muss)\n     *\n     * @param player\n     */\n    public void setPlayer(Player player) {\n        this.player = player;\n    }\n\n    /**\n     * Liefert die Sequenz-Nummer, des Ereignisses\n     *\n     * @return sequence\n     */\n    public int getSequenceNr() {\n        return sequenceNr;\n    }\n\n    /**\n     * Setzt die Sequenz-Nummer auf den übergebenen Wert\n     *\n     * @param sequenceNr\n     */\n    public void setSequenceNr(int sequenceNr) {\n        this.sequenceNr = sequenceNr;\n    }\n\n    public int compareTo(MoveEvent o) {\n        if (sequenceNr < o.sequenceNr)\n            return -1;\n        else if (sequenceNr > o.sequenceNr)\n            return 1;\n        else {\n            if (delay < o.getDelay()) {\n                return -1;\n            } else if (delay > o.getDelay()) {\n                return 1;\n            } else {\n                if (player.getPlayerNumber() < o.getPlayer().getPlayerNumber()) {\n                    return -1;\n                } else if (player.getPlayerNumber() > o.getPlayer().getPlayerNumber()) {\n                    return 1;\n                } else if ((player instanceof Offender) && (o.getPlayer() instanceof Defender)) {\n                    return -1;\n                } else if ((player instanceof Defender) && (o.getPlayer() instanceof Offender)) {\n                    return 1;\n                } else {\n                    if (this instanceof PassEvent && !(o instanceof PassEvent)) {\n                        return -1;\n                    } else if (o instanceof PassEvent && !(this instanceof PassEvent)) {\n                        return 1;\n                    }\n                    // gleich, kann dann nicht dem sorted-Set hinzugefügt werden\n                    return 0;\n                }\n            }\n        }\n    }\n\n    public void setPoint(MovePoint point, int x, int y) {\n        if (point.equals(controlPoint)) {\n            setControlPoint(x, y, false);\n        } else if (point.equals(destinationPoint)) {\n            setDestinationPoint(x, y, false);\n        }\n    }\n\n    public void setControlPoint(int x, int y, boolean temp) {\n        controlPointTemporary = temp;\n        if (controlPoint == null) {\n            controlPoint = new MovePoint(x, y);\n        } else {\n            controlPoint.setCurrent_x(x);\n            controlPoint.setCurrent_y(y);\n        }\n    }\n\n    public void setDestinationPoint(int x, int y, boolean temp) {\n        destinationPointTemporary = temp;\n        if (destinationPoint == null) {\n            destinationPoint = new MovePoint(x, y);\n        } else {\n            destinationPoint.setCurrent_x(x);\n            destinationPoint.setCurrent_y(y);\n        }\n    }\n\n    @Override\n    public String toString() {\n        String str = \"\";\n        if (destinationPoint == null) {\n            str = \"Laufweg nicht definiert\";\n        } else {\n            str = \"Laufweg zu Position (\" + destinationPoint.getCurrent_x() + \",\" + destinationPoint.getCurrent_y() + \")\";\n        }\n        return str;\n    }\n\n    public int getDestinationX() {\n        return destinationPoint.getCurrent_x();\n    }\n\n    public int getDestinationY() {\n        return destinationPoint.getCurrent_y();\n    }\n\n    public MovePoint getControlPoint() {\n        return controlPoint;\n    }\n\n    public MovePoint getDestinationPoint() {\n        return destinationPoint;\n    }\n\n    public int getControlPointX() {\n        return controlPoint.getCurrent_x();\n    }\n\n    public int getControlPointY() {\n        return controlPoint.getCurrent_y();\n    }\n\n    public boolean isControlPointSet() {\n        return !controlPointTemporary;\n    }\n\n    public boolean isDestinationPointSet() {\n        return !destinationPointTemporary;\n    }\n\n    public boolean isMarked() {\n        return marked;\n    }\n\n    public void setMarked(boolean marked) {\n        this.marked = marked;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (obj.getClass() != getClass())\n            return false;\n        MoveEvent other = (MoveEvent) obj;\n        if (other.getControlPoint() == null ^ this.getControlPoint() == null) {\n            return false;\n        }\n        if (other.getControlPoint() == null) {\n            // hier ist dann auch this.getControllPoint == null\n            if (other.getDestinationX() != this.getDestinationX() || other.getDestinationY() != this.getDestinationY() || other.getDelay() != this.getDelay() || !other.getPlayer().equals(this.getPlayer()) || other.getSequenceNr() != this.getSequenceNr()) {\n                return false;\n            }\n        } else if (other.getControlPointX() != this.getControlPointX() || other.getControlPointY() != this.getControlPointY() || other.getDestinationX() != this.getDestinationX() || other.getDestinationY() != this.getDestinationY() || other.getDelay() != this.getDelay() || !other.getPlayer().equals(this.getPlayer()) || other.getSequenceNr() != this.getSequenceNr()) {\n            return false;\n        }\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/model/MoveEventTest3.java",
		"test_prompt": "// MoveEventTest3.java\npackage visu.handball.moves.model;\n\nimport java.io.Serializable;\nimport visu.handball.moves.model.player.Defender;\nimport visu.handball.moves.model.player.MovePoint;\nimport visu.handball.moves.model.player.Offender;\nimport visu.handball.moves.model.player.Player;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MoveEvent}.\n* It contains ten unit test cases for the {@link MoveEvent#isMarked()} method.\n*/\nclass MoveEventTest3 {"
	},
	{
		"original_code": "// MoveEvent.java\n/*\n * Created on 31.08.2006\n * Created by Richard Doerfler, Thomas Halm\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n */\npackage visu.handball.moves.model;\n\nimport java.io.Serializable;\nimport visu.handball.moves.model.player.Defender;\nimport visu.handball.moves.model.player.MovePoint;\nimport visu.handball.moves.model.player.Offender;\nimport visu.handball.moves.model.player.Player;\n\n/**\n * @author tommy\n */\npublic class MoveEvent implements Comparable<MoveEvent>, Serializable {\n\n    private static final long serialVersionUID = -5372891552466311536L;\n\n    /**\n     * Ereignis ist einem Spieler zugeordnet\n     */\n    protected Player player;\n\n    /**\n     * Ereignis besitzt eine Sequenz-Nummer (1. Ereignis hat die Sequenz-Nummer\n     * 0)\n     */\n    protected int sequenceNr;\n\n    /**\n     * Ereignis kann Verzögerung besitzen, d.h. gleiche Sequenz-Nummer aber\n     * Verzögerung. Erst nach Ablauf der Verzögerung innerhalb einer\n     * Sequenz-Animation wird dieses Ereignis animiert\n     */\n    protected int delay;\n\n    protected MovePoint destinationPoint;\n\n    protected MovePoint controlPoint;\n\n    protected int oldPlayerX;\n\n    protected int oldPlayerY;\n\n    protected boolean destinationPointTemporary = true;\n\n    protected boolean controlPointTemporary = true;\n\n    protected boolean marked = false;\n\n    public MoveEvent(Player player, int nr) {\n        this(player, nr, 0);\n    }\n\n    public MoveEvent(Player player, int nr, int delay) {\n        this.player = player;\n        this.sequenceNr = nr;\n        this.delay = delay;\n        destinationPoint = null;\n        controlPoint = null;\n        oldPlayerX = player.getCurrent_x();\n        oldPlayerY = player.getCurrent_y();\n    }\n\n    /**\n     * Liefert die Verzögerung des Ereignisses\n     *\n     * @return delay\n     */\n    public int getDelay() {\n        return delay;\n    }\n\n    /**\n     * Setzt die Verzögerung des Ereignisses\n     *\n     * @param delay\n     */\n    public void setDelay(int delay) {\n        this.delay = delay;\n    }\n\n    /**\n     * Liefert den zugeordneten Spieler\n     *\n     * @return player\n     */\n    public Player getPlayer() {\n        return player;\n    }\n\n    /**\n     * Ordnet den uebergebenen Spieler dem Ereignis zu (Es ist fraglich ob, dies\n     * nachträglich noch möglich sein muss)\n     *\n     * @param player\n     */\n    public void setPlayer(Player player) {\n        this.player = player;\n    }\n\n    /**\n     * Liefert die Sequenz-Nummer, des Ereignisses\n     *\n     * @return sequence\n     */\n    public int getSequenceNr() {\n        return sequenceNr;\n    }\n\n    /**\n     * Setzt die Sequenz-Nummer auf den übergebenen Wert\n     *\n     * @param sequenceNr\n     */\n    public void setSequenceNr(int sequenceNr) {\n        this.sequenceNr = sequenceNr;\n    }\n\n    public int compareTo(MoveEvent o) {\n        if (sequenceNr < o.sequenceNr)\n            return -1;\n        else if (sequenceNr > o.sequenceNr)\n            return 1;\n        else {\n            if (delay < o.getDelay()) {\n                return -1;\n            } else if (delay > o.getDelay()) {\n                return 1;\n            } else {\n                if (player.getPlayerNumber() < o.getPlayer().getPlayerNumber()) {\n                    return -1;\n                } else if (player.getPlayerNumber() > o.getPlayer().getPlayerNumber()) {\n                    return 1;\n                } else if ((player instanceof Offender) && (o.getPlayer() instanceof Defender)) {\n                    return -1;\n                } else if ((player instanceof Defender) && (o.getPlayer() instanceof Offender)) {\n                    return 1;\n                } else {\n                    if (this instanceof PassEvent && !(o instanceof PassEvent)) {\n                        return -1;\n                    } else if (o instanceof PassEvent && !(this instanceof PassEvent)) {\n                        return 1;\n                    }\n                    // gleich, kann dann nicht dem sorted-Set hinzugefügt werden\n                    return 0;\n                }\n            }\n        }\n    }\n\n    public void setPoint(MovePoint point, int x, int y) {\n        if (point.equals(controlPoint)) {\n            setControlPoint(x, y, false);\n        } else if (point.equals(destinationPoint)) {\n            setDestinationPoint(x, y, false);\n        }\n    }\n\n    public void setControlPoint(int x, int y, boolean temp) {\n        controlPointTemporary = temp;\n        if (controlPoint == null) {\n            controlPoint = new MovePoint(x, y);\n        } else {\n            controlPoint.setCurrent_x(x);\n            controlPoint.setCurrent_y(y);\n        }\n    }\n\n    public void setDestinationPoint(int x, int y, boolean temp) {\n        destinationPointTemporary = temp;\n        if (destinationPoint == null) {\n            destinationPoint = new MovePoint(x, y);\n        } else {\n            destinationPoint.setCurrent_x(x);\n            destinationPoint.setCurrent_y(y);\n        }\n    }\n\n    @Override\n    public String toString() {\n        String str = \"\";\n        if (destinationPoint == null) {\n            str = \"Laufweg nicht definiert\";\n        } else {\n            str = \"Laufweg zu Position (\" + destinationPoint.getCurrent_x() + \",\" + destinationPoint.getCurrent_y() + \")\";\n        }\n        return str;\n    }\n\n    public int getDestinationX() {\n        return destinationPoint.getCurrent_x();\n    }\n\n    public int getDestinationY() {\n        return destinationPoint.getCurrent_y();\n    }\n\n    public MovePoint getControlPoint() {\n        return controlPoint;\n    }\n\n    public MovePoint getDestinationPoint() {\n        return destinationPoint;\n    }\n\n    public int getControlPointX() {\n        return controlPoint.getCurrent_x();\n    }\n\n    public int getControlPointY() {\n        return controlPoint.getCurrent_y();\n    }\n\n    public boolean isControlPointSet() {\n        return !controlPointTemporary;\n    }\n\n    public boolean isDestinationPointSet() {\n        return !destinationPointTemporary;\n    }\n\n    public boolean isMarked() {\n        return marked;\n    }\n\n    public void setMarked(boolean marked) {\n        this.marked = marked;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (obj.getClass() != getClass())\n            return false;\n        MoveEvent other = (MoveEvent) obj;\n        if (other.getControlPoint() == null ^ this.getControlPoint() == null) {\n            return false;\n        }\n        if (other.getControlPoint() == null) {\n            // hier ist dann auch this.getControllPoint == null\n            if (other.getDestinationX() != this.getDestinationX() || other.getDestinationY() != this.getDestinationY() || other.getDelay() != this.getDelay() || !other.getPlayer().equals(this.getPlayer()) || other.getSequenceNr() != this.getSequenceNr()) {\n                return false;\n            }\n        } else if (other.getControlPointX() != this.getControlPointX() || other.getControlPointY() != this.getControlPointY() || other.getDestinationX() != this.getDestinationX() || other.getDestinationY() != this.getDestinationY() || other.getDelay() != this.getDelay() || !other.getPlayer().equals(this.getPlayer()) || other.getSequenceNr() != this.getSequenceNr()) {\n            return false;\n        }\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/model/MoveEventTest4.java",
		"test_prompt": "// MoveEventTest4.java\npackage visu.handball.moves.model;\n\nimport java.io.Serializable;\nimport visu.handball.moves.model.player.Defender;\nimport visu.handball.moves.model.player.MovePoint;\nimport visu.handball.moves.model.player.Offender;\nimport visu.handball.moves.model.player.Player;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MoveEvent}.\n* It contains ten unit test cases for the {@link MoveEvent#equals(Object)} method.\n*/\nclass MoveEventTest4 {"
	},
	{
		"original_code": "// TableHandballModel.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.model;\r\n\r\nimport java.util.List;\r\nimport javax.swing.table.AbstractTableModel;\r\n\r\npublic class TableHandballModel extends AbstractTableModel implements HandballModelListener {\r\n\r\n    private HandballModel model;\r\n\r\n    private boolean disabeld = false;\r\n\r\n    public TableHandballModel(HandballModel model) {\r\n        super();\r\n        this.model = model;\r\n        model.addListener(this);\r\n    }\r\n\r\n    public String getColumnName(int columnIndex) {\r\n        switch(columnIndex) {\r\n            case 0:\r\n                return \"Spieler\";\r\n            case 1:\r\n                return \"Beschreibung\";\r\n            case 2:\r\n                return \"Sequenz\";\r\n            case 3:\r\n                return \"Verzögerung\";\r\n        }\r\n        return \"\";\r\n    }\r\n\r\n    public int getColumnCount() {\r\n        return 4;\r\n    }\r\n\r\n    public int getRowCount() {\r\n        return model.getEvents().size();\r\n    }\r\n\r\n    public Object getValueAt(int rowIndex, int columnIndex) {\r\n        List<MoveEvent> events = model.getEvents();\r\n        switch(columnIndex) {\r\n            case 0:\r\n                return events.get(rowIndex).getPlayer();\r\n            case 1:\r\n                return events.get(rowIndex);\r\n            case 2:\r\n                return events.get(rowIndex).getSequenceNr();\r\n            case 3:\r\n                return events.get(rowIndex).getDelay();\r\n        }\r\n        return \"\";\r\n    }\r\n\r\n    public boolean isCellEditable(int rowIndex, int columnIndex) {\r\n        // if (disabeld) {\r\n        // return false;\r\n        // }\r\n        if (columnIndex == 3) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public void setValueAt(Object aValue, int rowIndex, int columnIndex) {\r\n        // Delay anpassen\r\n        if (columnIndex == 3) {\r\n            model.setDelay(rowIndex, ((Integer) aValue).intValue());\r\n        }\r\n    }\r\n\r\n    public void modelChanged() {\r\n        switch(model.getState()) {\r\n            case EDIT:\r\n            case FULL_ANIMATION_ENDED:\r\n            case ANIMATION:\r\n                disabeld = false;\r\n                break;\r\n            default:\r\n                disabeld = true;\r\n                break;\r\n        }\r\n        fireTableDataChanged();\r\n    }\r\n\r\n    public HandballModel getHandballModel() {\r\n        return model;\r\n    }\r\n\r\n    public void setDisabled(boolean disabled) {\r\n        this.disabeld = disabled;\r\n        fireTableDataChanged();\r\n    }\r\n\r\n    public boolean isDisabled() {\r\n        return disabeld;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/model/TableHandballModelTest0.java",
		"test_prompt": "// TableHandballModelTest0.java\npackage visu.handball.moves.model;\n\nimport java.util.List;\nimport javax.swing.table.AbstractTableModel;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TableHandballModel}.\n* It contains ten unit test cases for the {@link TableHandballModel#isCellEditable(int, int)} method.\n*/\nclass TableHandballModelTest0 {"
	},
	{
		"original_code": "// TableHandballModel.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.model;\r\n\r\nimport java.util.List;\r\nimport javax.swing.table.AbstractTableModel;\r\n\r\npublic class TableHandballModel extends AbstractTableModel implements HandballModelListener {\r\n\r\n    private HandballModel model;\r\n\r\n    private boolean disabeld = false;\r\n\r\n    public TableHandballModel(HandballModel model) {\r\n        super();\r\n        this.model = model;\r\n        model.addListener(this);\r\n    }\r\n\r\n    public String getColumnName(int columnIndex) {\r\n        switch(columnIndex) {\r\n            case 0:\r\n                return \"Spieler\";\r\n            case 1:\r\n                return \"Beschreibung\";\r\n            case 2:\r\n                return \"Sequenz\";\r\n            case 3:\r\n                return \"Verzögerung\";\r\n        }\r\n        return \"\";\r\n    }\r\n\r\n    public int getColumnCount() {\r\n        return 4;\r\n    }\r\n\r\n    public int getRowCount() {\r\n        return model.getEvents().size();\r\n    }\r\n\r\n    public Object getValueAt(int rowIndex, int columnIndex) {\r\n        List<MoveEvent> events = model.getEvents();\r\n        switch(columnIndex) {\r\n            case 0:\r\n                return events.get(rowIndex).getPlayer();\r\n            case 1:\r\n                return events.get(rowIndex);\r\n            case 2:\r\n                return events.get(rowIndex).getSequenceNr();\r\n            case 3:\r\n                return events.get(rowIndex).getDelay();\r\n        }\r\n        return \"\";\r\n    }\r\n\r\n    public boolean isCellEditable(int rowIndex, int columnIndex) {\r\n        // if (disabeld) {\r\n        // return false;\r\n        // }\r\n        if (columnIndex == 3) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public void setValueAt(Object aValue, int rowIndex, int columnIndex) {\r\n        // Delay anpassen\r\n        if (columnIndex == 3) {\r\n            model.setDelay(rowIndex, ((Integer) aValue).intValue());\r\n        }\r\n    }\r\n\r\n    public void modelChanged() {\r\n        switch(model.getState()) {\r\n            case EDIT:\r\n            case FULL_ANIMATION_ENDED:\r\n            case ANIMATION:\r\n                disabeld = false;\r\n                break;\r\n            default:\r\n                disabeld = true;\r\n                break;\r\n        }\r\n        fireTableDataChanged();\r\n    }\r\n\r\n    public HandballModel getHandballModel() {\r\n        return model;\r\n    }\r\n\r\n    public void setDisabled(boolean disabled) {\r\n        this.disabeld = disabled;\r\n        fireTableDataChanged();\r\n    }\r\n\r\n    public boolean isDisabled() {\r\n        return disabeld;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/model/TableHandballModelTest1.java",
		"test_prompt": "// TableHandballModelTest1.java\npackage visu.handball.moves.model;\n\nimport java.util.List;\nimport javax.swing.table.AbstractTableModel;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TableHandballModel}.\n* It contains ten unit test cases for the {@link TableHandballModel#isDisabled()} method.\n*/\nclass TableHandballModelTest1 {"
	},
	{
		"original_code": "// AnimationModel.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.model.animation;\r\n\r\nimport java.awt.geom.PathIterator;\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport visu.handball.moves.model.HandballModel;\r\nimport visu.handball.moves.model.MoveEvent;\r\nimport visu.handball.moves.model.PassEvent;\r\n\r\npublic class AnimationModel {\r\n\r\n    private HandballModel model;\r\n\r\n    /**\r\n     * Events einer Sequenznummer\r\n     */\r\n    private List<MoveEvent> events;\r\n\r\n    private boolean onlyOneSequence;\r\n\r\n    private HashMap<MoveEvent, PathIterator> pathIters;\r\n\r\n    private PassEvent sequenzPassEvent;\r\n\r\n    public AnimationModel(MoveEvent startEvent, HandballModel model, boolean onlyOneSequence) {\r\n        this.model = model;\r\n        events = new ArrayList<MoveEvent>();\r\n        pathIters = new HashMap<MoveEvent, PathIterator>();\r\n        initEventList(startEvent);\r\n        this.onlyOneSequence = onlyOneSequence;\r\n    }\r\n\r\n    private void initEventList(MoveEvent startEvent) {\r\n        events.clear();\r\n        pathIters.clear();\r\n        int sequenz = startEvent.getSequenceNr();\r\n        sequenzPassEvent = null;\r\n        for (MoveEvent event : model.getEvents()) {\r\n            if (event.getSequenceNr() == sequenz) {\r\n                events.add(event);\r\n                if (event instanceof PassEvent) {\r\n                    // Initialisierung bei PassEvent\r\n                    if (events.size() == 1 && events.get(0) instanceof PassEvent) {\r\n                        // Pass animieren\r\n                        sequenzPassEvent = (PassEvent) event;\r\n                        if (sequenzPassEvent.getDestinationPlayer() != null || sequenzPassEvent.isGoalPass()) {\r\n                            pathIters.put(event, new PassLineIterator(sequenzPassEvent));\r\n                        }\r\n                    }\r\n                } else {\r\n                    pathIters.put(event, new CurveIterator(event));\r\n                }\r\n            }\r\n            if (event.getSequenceNr() > sequenz) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    public boolean nextStep() {\r\n        boolean allDone = true;\r\n        for (MoveEvent event : events) {\r\n            if (!pathIters.get(event).isDone()) {\r\n                allDone = false;\r\n                double[] corrs = new double[2];\r\n                pathIters.get(event).currentSegment(corrs);\r\n                if (event instanceof PassEvent) {\r\n                    model.setBallOwnerSilent(null);\r\n                    model.moveBallTo((int) Math.round(corrs[0]), (int) Math.round(corrs[1]));\r\n                } else {\r\n                    event.getPlayer().setCurrent_x((int) Math.round(corrs[0]));\r\n                    event.getPlayer().setCurrent_y((int) Math.round(corrs[1]));\r\n                }\r\n                pathIters.get(event).next();\r\n            }\r\n        }\r\n        if (allDone && sequenzPassEvent != null) {\r\n            if (!sequenzPassEvent.isGoalPass()) {\r\n                model.setBallOwner(sequenzPassEvent.getDestinationPlayer());\r\n            } else {\r\n                model.setBallOwner(null);\r\n                model.moveBallTo(sequenzPassEvent.getDestinationX(), sequenzPassEvent.getDestinationY());\r\n            }\r\n        }\r\n        if (allDone && !onlyOneSequence) {\r\n            // wenn noch weiteren Sequenzen vorhanden sind diese abspielen\r\n            int index = model.getEvents().indexOf(events.get(events.size() - 1)) + 1;\r\n            if (index < model.getEvents().size()) {\r\n                MoveEvent event = model.getEvents().get(index);\r\n                initEventList(event);\r\n                allDone = false;\r\n            }\r\n        }\r\n        // liefer true wenn alles zu Ende\r\n        return allDone;\r\n    }\r\n\r\n    public boolean isOnlyOneSequence() {\r\n        return onlyOneSequence;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/model/animation/AnimationModelTest0.java",
		"test_prompt": "// AnimationModelTest0.java\npackage visu.handball.moves.model.animation;\n\nimport java.awt.geom.PathIterator;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport visu.handball.moves.model.HandballModel;\nimport visu.handball.moves.model.MoveEvent;\nimport visu.handball.moves.model.PassEvent;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AnimationModel}.\n* It contains ten unit test cases for the {@link AnimationModel#nextStep()} method.\n*/\nclass AnimationModelTest0 {"
	},
	{
		"original_code": "// AnimationModel.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.model.animation;\r\n\r\nimport java.awt.geom.PathIterator;\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport visu.handball.moves.model.HandballModel;\r\nimport visu.handball.moves.model.MoveEvent;\r\nimport visu.handball.moves.model.PassEvent;\r\n\r\npublic class AnimationModel {\r\n\r\n    private HandballModel model;\r\n\r\n    /**\r\n     * Events einer Sequenznummer\r\n     */\r\n    private List<MoveEvent> events;\r\n\r\n    private boolean onlyOneSequence;\r\n\r\n    private HashMap<MoveEvent, PathIterator> pathIters;\r\n\r\n    private PassEvent sequenzPassEvent;\r\n\r\n    public AnimationModel(MoveEvent startEvent, HandballModel model, boolean onlyOneSequence) {\r\n        this.model = model;\r\n        events = new ArrayList<MoveEvent>();\r\n        pathIters = new HashMap<MoveEvent, PathIterator>();\r\n        initEventList(startEvent);\r\n        this.onlyOneSequence = onlyOneSequence;\r\n    }\r\n\r\n    private void initEventList(MoveEvent startEvent) {\r\n        events.clear();\r\n        pathIters.clear();\r\n        int sequenz = startEvent.getSequenceNr();\r\n        sequenzPassEvent = null;\r\n        for (MoveEvent event : model.getEvents()) {\r\n            if (event.getSequenceNr() == sequenz) {\r\n                events.add(event);\r\n                if (event instanceof PassEvent) {\r\n                    // Initialisierung bei PassEvent\r\n                    if (events.size() == 1 && events.get(0) instanceof PassEvent) {\r\n                        // Pass animieren\r\n                        sequenzPassEvent = (PassEvent) event;\r\n                        if (sequenzPassEvent.getDestinationPlayer() != null || sequenzPassEvent.isGoalPass()) {\r\n                            pathIters.put(event, new PassLineIterator(sequenzPassEvent));\r\n                        }\r\n                    }\r\n                } else {\r\n                    pathIters.put(event, new CurveIterator(event));\r\n                }\r\n            }\r\n            if (event.getSequenceNr() > sequenz) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    public boolean nextStep() {\r\n        boolean allDone = true;\r\n        for (MoveEvent event : events) {\r\n            if (!pathIters.get(event).isDone()) {\r\n                allDone = false;\r\n                double[] corrs = new double[2];\r\n                pathIters.get(event).currentSegment(corrs);\r\n                if (event instanceof PassEvent) {\r\n                    model.setBallOwnerSilent(null);\r\n                    model.moveBallTo((int) Math.round(corrs[0]), (int) Math.round(corrs[1]));\r\n                } else {\r\n                    event.getPlayer().setCurrent_x((int) Math.round(corrs[0]));\r\n                    event.getPlayer().setCurrent_y((int) Math.round(corrs[1]));\r\n                }\r\n                pathIters.get(event).next();\r\n            }\r\n        }\r\n        if (allDone && sequenzPassEvent != null) {\r\n            if (!sequenzPassEvent.isGoalPass()) {\r\n                model.setBallOwner(sequenzPassEvent.getDestinationPlayer());\r\n            } else {\r\n                model.setBallOwner(null);\r\n                model.moveBallTo(sequenzPassEvent.getDestinationX(), sequenzPassEvent.getDestinationY());\r\n            }\r\n        }\r\n        if (allDone && !onlyOneSequence) {\r\n            // wenn noch weiteren Sequenzen vorhanden sind diese abspielen\r\n            int index = model.getEvents().indexOf(events.get(events.size() - 1)) + 1;\r\n            if (index < model.getEvents().size()) {\r\n                MoveEvent event = model.getEvents().get(index);\r\n                initEventList(event);\r\n                allDone = false;\r\n            }\r\n        }\r\n        // liefer true wenn alles zu Ende\r\n        return allDone;\r\n    }\r\n\r\n    public boolean isOnlyOneSequence() {\r\n        return onlyOneSequence;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/model/animation/AnimationModelTest1.java",
		"test_prompt": "// AnimationModelTest1.java\npackage visu.handball.moves.model.animation;\n\nimport java.awt.geom.PathIterator;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport visu.handball.moves.model.HandballModel;\nimport visu.handball.moves.model.MoveEvent;\nimport visu.handball.moves.model.PassEvent;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AnimationModel}.\n* It contains ten unit test cases for the {@link AnimationModel#isOnlyOneSequence()} method.\n*/\nclass AnimationModelTest1 {"
	},
	{
		"original_code": "// PassLineIterator.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.model.animation;\r\n\r\nimport java.awt.geom.PathIterator;\r\nimport java.awt.geom.Point2D;\r\nimport visu.handball.moves.model.PassEvent;\r\n\r\npublic class PassLineIterator implements PathIterator {\r\n\r\n    private static final double SPEED = 15;\r\n\r\n    private double[] passCoordsX;\r\n\r\n    private double[] passCoordsY;\r\n\r\n    private int delay = 0;\r\n\r\n    private int index;\r\n\r\n    public PassLineIterator(PassEvent event) {\r\n        int startX = event.getPlayer().getCurrent_x();\r\n        int startY = event.getPlayer().getCurrent_y();\r\n        if (event.isGoalPass()) {\r\n            createPassPath(startX, startY, event.getDestinationX(), event.getDestinationY());\r\n        } else {\r\n            int endX = event.getDestinationPlayer().getCurrent_x();\r\n            int endY = event.getDestinationPlayer().getCurrent_y();\r\n            createPassPath(startX, startY, endX, endY);\r\n        }\r\n        if (event.getDelay() > 0) {\r\n            delay = Animator.getDelayUnits(event.getDelay());\r\n        }\r\n        index = 0;\r\n    }\r\n\r\n    private void createPassPath(int startX, int startY, int endX, int endY) {\r\n        int length = (int) Point2D.distance(startX, startY, endX, endY);\r\n        length = (int) Math.round((length < 20) ? 1 : length / SPEED);\r\n        double xStep = (endX - startX) / ((double) length);\r\n        double yStep = (endY - startY) / (double) length;\r\n        passCoordsX = new double[length];\r\n        passCoordsY = new double[length];\r\n        for (int i = 0; i < length; i++) {\r\n            passCoordsX[i] = startX + (i * xStep);\r\n            passCoordsY[i] = startY + (i * yStep);\r\n        }\r\n    }\r\n\r\n    public int getWindingRule() {\r\n        return 0;\r\n    }\r\n\r\n    public boolean isDone() {\r\n        return index >= passCoordsX.length;\r\n    }\r\n\r\n    public void next() {\r\n        if (delay > 0) {\r\n            delay--;\r\n        } else {\r\n            index++;\r\n        }\r\n    }\r\n\r\n    public int currentSegment(float[] coords) {\r\n        coords[0] = new Float(passCoordsX[index]).floatValue();\r\n        coords[1] = new Float(passCoordsY[index]).floatValue();\r\n        return 0;\r\n    }\r\n\r\n    public int currentSegment(double[] coords) {\r\n        coords[0] = passCoordsX[index];\r\n        coords[1] = passCoordsY[index];\r\n        return 0;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/model/animation/PassLineIteratorTest0.java",
		"test_prompt": "// PassLineIteratorTest0.java\npackage visu.handball.moves.model.animation;\n\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport visu.handball.moves.model.PassEvent;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PassLineIterator}.\n* It contains ten unit test cases for the {@link PassLineIterator#isDone()} method.\n*/\nclass PassLineIteratorTest0 {"
	},
	{
		"original_code": "// PassLineIterator.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.model.animation;\r\n\r\nimport java.awt.geom.PathIterator;\r\nimport java.awt.geom.Point2D;\r\nimport visu.handball.moves.model.PassEvent;\r\n\r\npublic class PassLineIterator implements PathIterator {\r\n\r\n    private static final double SPEED = 15;\r\n\r\n    private double[] passCoordsX;\r\n\r\n    private double[] passCoordsY;\r\n\r\n    private int delay = 0;\r\n\r\n    private int index;\r\n\r\n    public PassLineIterator(PassEvent event) {\r\n        int startX = event.getPlayer().getCurrent_x();\r\n        int startY = event.getPlayer().getCurrent_y();\r\n        if (event.isGoalPass()) {\r\n            createPassPath(startX, startY, event.getDestinationX(), event.getDestinationY());\r\n        } else {\r\n            int endX = event.getDestinationPlayer().getCurrent_x();\r\n            int endY = event.getDestinationPlayer().getCurrent_y();\r\n            createPassPath(startX, startY, endX, endY);\r\n        }\r\n        if (event.getDelay() > 0) {\r\n            delay = Animator.getDelayUnits(event.getDelay());\r\n        }\r\n        index = 0;\r\n    }\r\n\r\n    private void createPassPath(int startX, int startY, int endX, int endY) {\r\n        int length = (int) Point2D.distance(startX, startY, endX, endY);\r\n        length = (int) Math.round((length < 20) ? 1 : length / SPEED);\r\n        double xStep = (endX - startX) / ((double) length);\r\n        double yStep = (endY - startY) / (double) length;\r\n        passCoordsX = new double[length];\r\n        passCoordsY = new double[length];\r\n        for (int i = 0; i < length; i++) {\r\n            passCoordsX[i] = startX + (i * xStep);\r\n            passCoordsY[i] = startY + (i * yStep);\r\n        }\r\n    }\r\n\r\n    public int getWindingRule() {\r\n        return 0;\r\n    }\r\n\r\n    public boolean isDone() {\r\n        return index >= passCoordsX.length;\r\n    }\r\n\r\n    public void next() {\r\n        if (delay > 0) {\r\n            delay--;\r\n        } else {\r\n            index++;\r\n        }\r\n    }\r\n\r\n    public int currentSegment(float[] coords) {\r\n        coords[0] = new Float(passCoordsX[index]).floatValue();\r\n        coords[1] = new Float(passCoordsY[index]).floatValue();\r\n        return 0;\r\n    }\r\n\r\n    public int currentSegment(double[] coords) {\r\n        coords[0] = passCoordsX[index];\r\n        coords[1] = passCoordsY[index];\r\n        return 0;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/model/animation/PassLineIteratorTest1.java",
		"test_prompt": "// PassLineIteratorTest1.java\npackage visu.handball.moves.model.animation;\n\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport visu.handball.moves.model.PassEvent;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PassLineIterator}.\n* It contains ten unit test cases for the {@link PassLineIterator#currentSegment(float[])} method.\n*/\nclass PassLineIteratorTest1 {"
	},
	{
		"original_code": "// PassLineIterator.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.model.animation;\r\n\r\nimport java.awt.geom.PathIterator;\r\nimport java.awt.geom.Point2D;\r\nimport visu.handball.moves.model.PassEvent;\r\n\r\npublic class PassLineIterator implements PathIterator {\r\n\r\n    private static final double SPEED = 15;\r\n\r\n    private double[] passCoordsX;\r\n\r\n    private double[] passCoordsY;\r\n\r\n    private int delay = 0;\r\n\r\n    private int index;\r\n\r\n    public PassLineIterator(PassEvent event) {\r\n        int startX = event.getPlayer().getCurrent_x();\r\n        int startY = event.getPlayer().getCurrent_y();\r\n        if (event.isGoalPass()) {\r\n            createPassPath(startX, startY, event.getDestinationX(), event.getDestinationY());\r\n        } else {\r\n            int endX = event.getDestinationPlayer().getCurrent_x();\r\n            int endY = event.getDestinationPlayer().getCurrent_y();\r\n            createPassPath(startX, startY, endX, endY);\r\n        }\r\n        if (event.getDelay() > 0) {\r\n            delay = Animator.getDelayUnits(event.getDelay());\r\n        }\r\n        index = 0;\r\n    }\r\n\r\n    private void createPassPath(int startX, int startY, int endX, int endY) {\r\n        int length = (int) Point2D.distance(startX, startY, endX, endY);\r\n        length = (int) Math.round((length < 20) ? 1 : length / SPEED);\r\n        double xStep = (endX - startX) / ((double) length);\r\n        double yStep = (endY - startY) / (double) length;\r\n        passCoordsX = new double[length];\r\n        passCoordsY = new double[length];\r\n        for (int i = 0; i < length; i++) {\r\n            passCoordsX[i] = startX + (i * xStep);\r\n            passCoordsY[i] = startY + (i * yStep);\r\n        }\r\n    }\r\n\r\n    public int getWindingRule() {\r\n        return 0;\r\n    }\r\n\r\n    public boolean isDone() {\r\n        return index >= passCoordsX.length;\r\n    }\r\n\r\n    public void next() {\r\n        if (delay > 0) {\r\n            delay--;\r\n        } else {\r\n            index++;\r\n        }\r\n    }\r\n\r\n    public int currentSegment(float[] coords) {\r\n        coords[0] = new Float(passCoordsX[index]).floatValue();\r\n        coords[1] = new Float(passCoordsY[index]).floatValue();\r\n        return 0;\r\n    }\r\n\r\n    public int currentSegment(double[] coords) {\r\n        coords[0] = passCoordsX[index];\r\n        coords[1] = passCoordsY[index];\r\n        return 0;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/model/animation/PassLineIteratorTest2.java",
		"test_prompt": "// PassLineIteratorTest2.java\npackage visu.handball.moves.model.animation;\n\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport visu.handball.moves.model.PassEvent;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PassLineIterator}.\n* It contains ten unit test cases for the {@link PassLineIterator#currentSegment(double[])} method.\n*/\nclass PassLineIteratorTest2 {"
	},
	{
		"original_code": "// Animator.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.model.animation;\r\n\r\nimport visu.handball.moves.model.HandballModel;\r\n\r\npublic class Animator extends Thread {\r\n\r\n    /**\r\n     * Wie oft soll der Animator die Animation pro Sekunde aktualisieren?\r\n     */\r\n    public final static int SPEED = 20;\r\n\r\n    /**\r\n     * Liefert die Anzahl an Animator-Steps bis das Delay abgelaufen ist\r\n     * @param delay\r\n     *\r\n     * @return animatorSteps\r\n     */\r\n    public static int getDelayUnits(int delay) {\r\n        //quasi halbe sekunde\r\n        return delay * SPEED / 2;\r\n    }\r\n\r\n    private HandballModel model;\r\n\r\n    private boolean pause;\r\n\r\n    public Animator(HandballModel model) {\r\n        this.model = model;\r\n        start();\r\n    }\r\n\r\n    @Override\r\n    public void run() {\r\n        while (model.getState() == HandballModel.State.ANIMATION_RUNNING && !isPause()) {\r\n            if (model.nextAnimationStep())\r\n                break;\r\n            try {\r\n                sleep(1000 / SPEED);\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    public synchronized boolean isPause() {\r\n        while (pause) {\r\n            try {\r\n                wait();\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public synchronized void setPause(boolean pause) {\r\n        this.pause = pause;\r\n        notify();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/model/animation/AnimatorTest0.java",
		"test_prompt": "// AnimatorTest0.java\npackage visu.handball.moves.model.animation;\n\nimport visu.handball.moves.model.HandballModel;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Animator}.\n* It contains ten unit test cases for the {@link Animator#getDelayUnits(int)} method.\n*/\nclass AnimatorTest0 {"
	},
	{
		"original_code": "// Animator.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.model.animation;\r\n\r\nimport visu.handball.moves.model.HandballModel;\r\n\r\npublic class Animator extends Thread {\r\n\r\n    /**\r\n     * Wie oft soll der Animator die Animation pro Sekunde aktualisieren?\r\n     */\r\n    public final static int SPEED = 20;\r\n\r\n    /**\r\n     * Liefert die Anzahl an Animator-Steps bis das Delay abgelaufen ist\r\n     * @param delay\r\n     *\r\n     * @return animatorSteps\r\n     */\r\n    public static int getDelayUnits(int delay) {\r\n        //quasi halbe sekunde\r\n        return delay * SPEED / 2;\r\n    }\r\n\r\n    private HandballModel model;\r\n\r\n    private boolean pause;\r\n\r\n    public Animator(HandballModel model) {\r\n        this.model = model;\r\n        start();\r\n    }\r\n\r\n    @Override\r\n    public void run() {\r\n        while (model.getState() == HandballModel.State.ANIMATION_RUNNING && !isPause()) {\r\n            if (model.nextAnimationStep())\r\n                break;\r\n            try {\r\n                sleep(1000 / SPEED);\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    public synchronized boolean isPause() {\r\n        while (pause) {\r\n            try {\r\n                wait();\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public synchronized void setPause(boolean pause) {\r\n        this.pause = pause;\r\n        notify();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/model/animation/AnimatorTest1.java",
		"test_prompt": "// AnimatorTest1.java\npackage visu.handball.moves.model.animation;\n\nimport visu.handball.moves.model.HandballModel;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Animator}.\n* It contains ten unit test cases for the {@link Animator#isPause()} method.\n*/\nclass AnimatorTest1 {"
	},
	{
		"original_code": "// CurveIterator.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.model.animation;\r\n\r\nimport java.awt.geom.PathIterator;\r\nimport java.awt.geom.Point2D;\r\nimport visu.handball.moves.model.MoveEvent;\r\n\r\npublic class CurveIterator implements PathIterator {\r\n\r\n    private static final int SPEED = 10;\r\n\r\n    private static final int COUNT = 1000;\r\n\r\n    private double[] curveCoordsX;\r\n\r\n    private double[] curveCoordsY;\r\n\r\n    private int index;\r\n\r\n    private int delay;\r\n\r\n    public CurveIterator(MoveEvent event) {\r\n        int startX = event.getPlayer().getCurrent_x();\r\n        int startY = event.getPlayer().getCurrent_y();\r\n        int controlX = event.getControlPointX();\r\n        int controlY = event.getControlPointY();\r\n        int endX = event.getDestinationX();\r\n        int endY = event.getDestinationY();\r\n        createCurvePath(startX, startY, controlX, controlY, endX, endY);\r\n        if (event.getDelay() > 0) {\r\n            delay = Animator.getDelayUnits(event.getDelay());\r\n        }\r\n        index = 0;\r\n    }\r\n\r\n    private void createCurvePath(int startX, int startY, int controlX, int controlY, int endX, int endY) {\r\n        curveCoordsX = new double[COUNT];\r\n        curveCoordsY = new double[COUNT];\r\n        curveCoordsX[0] = startX;\r\n        curveCoordsY[0] = startY;\r\n        for (int i = 1; i < COUNT - 1; i++) {\r\n            double u = i / (COUNT * 1.0);\r\n            double Cx = qb0(u) * startX + qb1(u) * controlX + qb2(u) * endX;\r\n            double Cy = qb0(u) * startY + qb1(u) * controlY + qb2(u) * endY;\r\n            curveCoordsX[i] = Cx;\r\n            curveCoordsY[i] = Cy;\r\n        }\r\n        curveCoordsX[curveCoordsX.length - 1] = endX;\r\n        curveCoordsY[curveCoordsY.length - 1] = endY;\r\n    }\r\n\r\n    private double qb0(double u) {\r\n        return (1 - u) * (1 - u);\r\n    }\r\n\r\n    private double qb1(double u) {\r\n        return 2 * u * (1 - u);\r\n    }\r\n\r\n    private double qb2(double u) {\r\n        return u * u;\r\n    }\r\n\r\n    public int currentSegment(float[] coords) {\r\n        coords[0] = new Float(curveCoordsX[index]).floatValue();\r\n        coords[1] = new Float(curveCoordsY[index]).floatValue();\r\n        return 0;\r\n    }\r\n\r\n    public int currentSegment(double[] coords) {\r\n        coords[0] = curveCoordsX[index];\r\n        coords[1] = curveCoordsY[index];\r\n        return 0;\r\n    }\r\n\r\n    public int getWindingRule() {\r\n        return 0;\r\n    }\r\n\r\n    public boolean isDone() {\r\n        return index >= curveCoordsX.length;\r\n    }\r\n\r\n    public void next() {\r\n        if (delay > 0) {\r\n            delay--;\r\n        } else {\r\n            int oldIndex = index;\r\n            while ((index < curveCoordsX.length) && (Point2D.distance(curveCoordsX[oldIndex], curveCoordsY[oldIndex], curveCoordsX[index], curveCoordsY[index]) < SPEED)) {\r\n                index++;\r\n            }\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/model/animation/CurveIteratorTest0.java",
		"test_prompt": "// CurveIteratorTest0.java\npackage visu.handball.moves.model.animation;\n\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport visu.handball.moves.model.MoveEvent;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CurveIterator}.\n* It contains ten unit test cases for the {@link CurveIterator#currentSegment(float[])} method.\n*/\nclass CurveIteratorTest0 {"
	},
	{
		"original_code": "// CurveIterator.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.model.animation;\r\n\r\nimport java.awt.geom.PathIterator;\r\nimport java.awt.geom.Point2D;\r\nimport visu.handball.moves.model.MoveEvent;\r\n\r\npublic class CurveIterator implements PathIterator {\r\n\r\n    private static final int SPEED = 10;\r\n\r\n    private static final int COUNT = 1000;\r\n\r\n    private double[] curveCoordsX;\r\n\r\n    private double[] curveCoordsY;\r\n\r\n    private int index;\r\n\r\n    private int delay;\r\n\r\n    public CurveIterator(MoveEvent event) {\r\n        int startX = event.getPlayer().getCurrent_x();\r\n        int startY = event.getPlayer().getCurrent_y();\r\n        int controlX = event.getControlPointX();\r\n        int controlY = event.getControlPointY();\r\n        int endX = event.getDestinationX();\r\n        int endY = event.getDestinationY();\r\n        createCurvePath(startX, startY, controlX, controlY, endX, endY);\r\n        if (event.getDelay() > 0) {\r\n            delay = Animator.getDelayUnits(event.getDelay());\r\n        }\r\n        index = 0;\r\n    }\r\n\r\n    private void createCurvePath(int startX, int startY, int controlX, int controlY, int endX, int endY) {\r\n        curveCoordsX = new double[COUNT];\r\n        curveCoordsY = new double[COUNT];\r\n        curveCoordsX[0] = startX;\r\n        curveCoordsY[0] = startY;\r\n        for (int i = 1; i < COUNT - 1; i++) {\r\n            double u = i / (COUNT * 1.0);\r\n            double Cx = qb0(u) * startX + qb1(u) * controlX + qb2(u) * endX;\r\n            double Cy = qb0(u) * startY + qb1(u) * controlY + qb2(u) * endY;\r\n            curveCoordsX[i] = Cx;\r\n            curveCoordsY[i] = Cy;\r\n        }\r\n        curveCoordsX[curveCoordsX.length - 1] = endX;\r\n        curveCoordsY[curveCoordsY.length - 1] = endY;\r\n    }\r\n\r\n    private double qb0(double u) {\r\n        return (1 - u) * (1 - u);\r\n    }\r\n\r\n    private double qb1(double u) {\r\n        return 2 * u * (1 - u);\r\n    }\r\n\r\n    private double qb2(double u) {\r\n        return u * u;\r\n    }\r\n\r\n    public int currentSegment(float[] coords) {\r\n        coords[0] = new Float(curveCoordsX[index]).floatValue();\r\n        coords[1] = new Float(curveCoordsY[index]).floatValue();\r\n        return 0;\r\n    }\r\n\r\n    public int currentSegment(double[] coords) {\r\n        coords[0] = curveCoordsX[index];\r\n        coords[1] = curveCoordsY[index];\r\n        return 0;\r\n    }\r\n\r\n    public int getWindingRule() {\r\n        return 0;\r\n    }\r\n\r\n    public boolean isDone() {\r\n        return index >= curveCoordsX.length;\r\n    }\r\n\r\n    public void next() {\r\n        if (delay > 0) {\r\n            delay--;\r\n        } else {\r\n            int oldIndex = index;\r\n            while ((index < curveCoordsX.length) && (Point2D.distance(curveCoordsX[oldIndex], curveCoordsY[oldIndex], curveCoordsX[index], curveCoordsY[index]) < SPEED)) {\r\n                index++;\r\n            }\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/model/animation/CurveIteratorTest1.java",
		"test_prompt": "// CurveIteratorTest1.java\npackage visu.handball.moves.model.animation;\n\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport visu.handball.moves.model.MoveEvent;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CurveIterator}.\n* It contains ten unit test cases for the {@link CurveIterator#currentSegment(double[])} method.\n*/\nclass CurveIteratorTest1 {"
	},
	{
		"original_code": "// CurveIterator.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.model.animation;\r\n\r\nimport java.awt.geom.PathIterator;\r\nimport java.awt.geom.Point2D;\r\nimport visu.handball.moves.model.MoveEvent;\r\n\r\npublic class CurveIterator implements PathIterator {\r\n\r\n    private static final int SPEED = 10;\r\n\r\n    private static final int COUNT = 1000;\r\n\r\n    private double[] curveCoordsX;\r\n\r\n    private double[] curveCoordsY;\r\n\r\n    private int index;\r\n\r\n    private int delay;\r\n\r\n    public CurveIterator(MoveEvent event) {\r\n        int startX = event.getPlayer().getCurrent_x();\r\n        int startY = event.getPlayer().getCurrent_y();\r\n        int controlX = event.getControlPointX();\r\n        int controlY = event.getControlPointY();\r\n        int endX = event.getDestinationX();\r\n        int endY = event.getDestinationY();\r\n        createCurvePath(startX, startY, controlX, controlY, endX, endY);\r\n        if (event.getDelay() > 0) {\r\n            delay = Animator.getDelayUnits(event.getDelay());\r\n        }\r\n        index = 0;\r\n    }\r\n\r\n    private void createCurvePath(int startX, int startY, int controlX, int controlY, int endX, int endY) {\r\n        curveCoordsX = new double[COUNT];\r\n        curveCoordsY = new double[COUNT];\r\n        curveCoordsX[0] = startX;\r\n        curveCoordsY[0] = startY;\r\n        for (int i = 1; i < COUNT - 1; i++) {\r\n            double u = i / (COUNT * 1.0);\r\n            double Cx = qb0(u) * startX + qb1(u) * controlX + qb2(u) * endX;\r\n            double Cy = qb0(u) * startY + qb1(u) * controlY + qb2(u) * endY;\r\n            curveCoordsX[i] = Cx;\r\n            curveCoordsY[i] = Cy;\r\n        }\r\n        curveCoordsX[curveCoordsX.length - 1] = endX;\r\n        curveCoordsY[curveCoordsY.length - 1] = endY;\r\n    }\r\n\r\n    private double qb0(double u) {\r\n        return (1 - u) * (1 - u);\r\n    }\r\n\r\n    private double qb1(double u) {\r\n        return 2 * u * (1 - u);\r\n    }\r\n\r\n    private double qb2(double u) {\r\n        return u * u;\r\n    }\r\n\r\n    public int currentSegment(float[] coords) {\r\n        coords[0] = new Float(curveCoordsX[index]).floatValue();\r\n        coords[1] = new Float(curveCoordsY[index]).floatValue();\r\n        return 0;\r\n    }\r\n\r\n    public int currentSegment(double[] coords) {\r\n        coords[0] = curveCoordsX[index];\r\n        coords[1] = curveCoordsY[index];\r\n        return 0;\r\n    }\r\n\r\n    public int getWindingRule() {\r\n        return 0;\r\n    }\r\n\r\n    public boolean isDone() {\r\n        return index >= curveCoordsX.length;\r\n    }\r\n\r\n    public void next() {\r\n        if (delay > 0) {\r\n            delay--;\r\n        } else {\r\n            int oldIndex = index;\r\n            while ((index < curveCoordsX.length) && (Point2D.distance(curveCoordsX[oldIndex], curveCoordsY[oldIndex], curveCoordsX[index], curveCoordsY[index]) < SPEED)) {\r\n                index++;\r\n            }\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/model/animation/CurveIteratorTest2.java",
		"test_prompt": "// CurveIteratorTest2.java\npackage visu.handball.moves.model.animation;\n\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport visu.handball.moves.model.MoveEvent;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CurveIterator}.\n* It contains ten unit test cases for the {@link CurveIterator#isDone()} method.\n*/\nclass CurveIteratorTest2 {"
	},
	{
		"original_code": "// HandballModel.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.model;\r\n\r\nimport java.awt.geom.Point2D;\r\nimport java.io.Serializable;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.SortedSet;\r\nimport java.util.TreeSet;\r\nimport javax.swing.JOptionPane;\r\nimport visu.handball.moves.Main;\r\nimport visu.handball.moves.model.animation.AnimationModel;\r\nimport visu.handball.moves.model.animation.Animator;\r\nimport visu.handball.moves.model.player.Ball;\r\nimport visu.handball.moves.model.player.Defender;\r\nimport visu.handball.moves.model.player.HighlightableItem;\r\nimport visu.handball.moves.model.player.MovePoint;\r\nimport visu.handball.moves.model.player.Offender;\r\nimport visu.handball.moves.model.player.Player;\r\n\r\npublic class HandballModel implements Serializable {\r\n\r\n    private static final long serialVersionUID = -5372891552466311536L;\r\n\r\n    public enum State {\r\n\r\n        INITIAL,\r\n        PLACE_OFFENDERS,\r\n        PLACE_DEFENDERS,\r\n        PLACE_BALL,\r\n        EDIT,\r\n        EDIT_EVENT,\r\n        ANIMATION,\r\n        ANIMATION_RUNNING,\r\n        FULL_ANIMATION_ENDED\r\n    }\r\n\r\n    private static final int MAX_OFFENDERS = 6;\r\n\r\n    private static final int MAX_DEFENDERS = 6;\r\n\r\n    private static final int MARK_RADIUS = 12;\r\n\r\n    private static final String APP_NAME = \"jHandballMoves\";\r\n\r\n    private transient List<HandballModelListener> listeners;\r\n\r\n    private transient List<PlayerRemovedListener> playerRemoveListener;\r\n\r\n    private List<Defender> defenders;\r\n\r\n    private List<Offender> offenders;\r\n\r\n    private SortedSet<MoveEvent> events;\r\n\r\n    private State state;\r\n\r\n    private MoveEvent actualEvent;\r\n\r\n    private Player markedPlayer;\r\n\r\n    private HighlightableItem hightlightedItem;\r\n\r\n    private Offender ballOwner;\r\n\r\n    private Ball ball;\r\n\r\n    private Offender firstBallOwner;\r\n\r\n    private transient Animator runningAnimator;\r\n\r\n    private int animationSequenz;\r\n\r\n    private transient AnimationModel animationModel;\r\n\r\n    private transient HandballModel lastSavedModel;\r\n\r\n    private String comment;\r\n\r\n    private String moveName;\r\n\r\n    public HandballModel() {\r\n        listeners = new ArrayList<HandballModelListener>();\r\n        playerRemoveListener = new ArrayList<PlayerRemovedListener>();\r\n        initModel();\r\n    }\r\n\r\n    public void initModel() {\r\n        defenders = new ArrayList<Defender>();\r\n        Defender.setCounter(0);\r\n        offenders = new ArrayList<Offender>();\r\n        Offender.setCounter(0);\r\n        events = new TreeSet<MoveEvent>();\r\n        // Workaround wegen ToolBar\r\n        state = State.PLACE_OFFENDERS;\r\n        actualEvent = null;\r\n        markedPlayer = null;\r\n        firstBallOwner = null;\r\n        comment = \"\";\r\n        moveName = \"\";\r\n        resetBallPosition();\r\n        try {\r\n            lastSavedModel = (HandballModel) Main.deepCopy(this);\r\n        } catch (Exception e) {\r\n            lastSavedModel = null;\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    private void resetBallPosition() {\r\n        ball = new Ball(-500, -500);\r\n    }\r\n\r\n    public void addOffender(int x, int y) {\r\n        if (offenders.size() == MAX_OFFENDERS) {\r\n            JOptionPane.showMessageDialog(Main.getWindow(), \"Sie haben schon \" + MAX_OFFENDERS + \" Angreifer angelegt.\", \"Info:\", JOptionPane.INFORMATION_MESSAGE);\r\n        } else {\r\n            offenders.add(new Offender(x, y));\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void removePlayer(Player toRemove) {\r\n        if (eventDefinedWithPlayer(toRemove)) {\r\n            removeEventsOfPlayer(toRemove);\r\n        }\r\n        if (toRemove instanceof Offender) {\r\n            removeOffender((Offender) toRemove);\r\n        } else {\r\n            removeDefender((Defender) toRemove);\r\n        }\r\n    }\r\n\r\n    private void removeOffender(Offender toRemove) {\r\n        if (getFirstBallOwner() != null && getFirstBallOwner().equals(toRemove)) {\r\n            setFirstBallOwner(null);\r\n        }\r\n        offenders.remove(toRemove);\r\n        if ((getDefenders().size() + getOffenders().size()) == 0) {\r\n            markedPlayer = null;\r\n        }\r\n        // Spielernummer aktualisieren\r\n        Offender.setCounter(determineMaxPlayerNumber(offenders));\r\n        fireOffenderRemoved(toRemove);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void addDefender(int x, int y) {\r\n        if (defenders.size() == MAX_DEFENDERS) {\r\n            JOptionPane.showMessageDialog(Main.getWindow(), \"Sie haben schon \" + MAX_OFFENDERS + \" Verteidiger angelegt.\", \"Info:\", JOptionPane.INFORMATION_MESSAGE);\r\n        } else {\r\n            defenders.add(new Defender(x, y));\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    private void removeDefender(Defender toRemove) {\r\n        defenders.remove(toRemove);\r\n        if ((getDefenders().size() + getOffenders().size()) == 0) {\r\n            markedPlayer = null;\r\n        }\r\n        Defender.setCounter(determineMaxPlayerNumber(defenders));\r\n        fireDefenderRemoved(toRemove);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public boolean addListener(HandballModelListener o) {\r\n        return listeners.add(o);\r\n    }\r\n\r\n    public boolean removeListener(HandballModelListener o) {\r\n        return listeners.remove(o);\r\n    }\r\n\r\n    public boolean addPlayerRemovedListener(PlayerRemovedListener o) {\r\n        return playerRemoveListener.add(o);\r\n    }\r\n\r\n    public boolean removePlayerRemovedListener(PlayerRemovedListener o) {\r\n        return playerRemoveListener.remove(o);\r\n    }\r\n\r\n    private void fireModelChanged() {\r\n        setMoveName(getMoveName());\r\n        for (HandballModelListener listener : listeners) {\r\n            listener.modelChanged();\r\n        }\r\n    }\r\n\r\n    private void fireOffenderRemoved(Offender offender) {\r\n        for (PlayerRemovedListener listener : playerRemoveListener) {\r\n            listener.offenderRemoved(offender);\r\n        }\r\n    }\r\n\r\n    private void fireDefenderRemoved(Defender defender) {\r\n        for (PlayerRemovedListener listener : playerRemoveListener) {\r\n            listener.defenderRemoved(defender);\r\n        }\r\n    }\r\n\r\n    public List<Defender> getDefenders() {\r\n        return defenders;\r\n    }\r\n\r\n    public List<Offender> getOffenders() {\r\n        return offenders;\r\n    }\r\n\r\n    public State getState() {\r\n        return state;\r\n    }\r\n\r\n    public void setState(State state) {\r\n        if (state == State.EDIT) {\r\n            if (getActualMoveEvent() == null) {\r\n                // Wenn leer, dann Null, sonst letztes Move Event setzen\r\n                setActualMoveEvent(getEvents().isEmpty() ? null : (getEvents().get(getEvents().size() - 1)));\r\n            } else {\r\n                setActualMoveEvent(getActualMoveEvent());\r\n            }\r\n        }\r\n        if (state == State.PLACE_DEFENDERS || state == State.PLACE_OFFENDERS) {\r\n            if (getFirstBallOwner() != null) {\r\n                setBallOwner(getFirstBallOwner());\r\n            }\r\n            setActualMoveEvent(null);\r\n        }\r\n        this.state = state;\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void addMoveEvent(MoveEvent event) {\r\n        events.add(event);\r\n        if (state == State.EDIT) {\r\n            setActualMoveEvent(event);\r\n            state = State.EDIT_EVENT;\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void removeMoveEvent(MoveEvent event) {\r\n        events.remove(event);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public List<MoveEvent> getEvents() {\r\n        List<MoveEvent> list = new ArrayList<MoveEvent>(events);\r\n        return list;\r\n    }\r\n\r\n    public SortedSet<MoveEvent> getSortedEvents() {\r\n        return events;\r\n    }\r\n\r\n    public int getAcutalSequenceNr() {\r\n        if (actualEvent == null)\r\n            return 0;\r\n        else {\r\n            return actualEvent.getSequenceNr();\r\n        }\r\n    }\r\n\r\n    public void setActualMoveEvent(MoveEvent event) {\r\n        if (this.actualEvent != null) {\r\n            this.actualEvent.setMarked(false);\r\n        }\r\n        this.actualEvent = event;\r\n        computePlayerPositions();\r\n        // aktuellen Spieler setzen\r\n        setMarkedPlayer((event == null) ? null : event.getPlayer());\r\n        if (actualEvent != null) {\r\n            if (!actualEvent.isDestinationPointSet()) {\r\n                state = State.EDIT_EVENT;\r\n            } else {\r\n                if (state == State.FULL_ANIMATION_ENDED) {\r\n                    state = State.ANIMATION;\r\n                } else if (state != State.ANIMATION && state != State.ANIMATION_RUNNING) {\r\n                    state = State.EDIT;\r\n                }\r\n            }\r\n            actualEvent.setMarked(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setDestinationPointForEvent(MoveEvent event, int x, int y, boolean temp) {\r\n        event.setDestinationPoint(x, y, temp);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setControlPointForEvent(MoveEvent event, int x, int y, boolean temp) {\r\n        event.setControlPoint(x, y, temp);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setMovePointTo(MovePoint point, int x, int y) {\r\n        actualEvent.setPoint(point, x, y);\r\n        fireModelChanged();\r\n    }\r\n\r\n    private void computePlayerPositions() {\r\n        computePlayerPositions(getAcutalSequenceNr());\r\n    }\r\n\r\n    public void computePlayerPositions(int seqNr) {\r\n        // Spieler Positionen auf Ausgangsstellung\r\n        for (Player offender : offenders) {\r\n            offender.resetPosition();\r\n        }\r\n        for (Player defender : defenders) {\r\n            defender.resetPosition();\r\n        }\r\n        if (seqNr == 1) {\r\n            setBallOwner(firstBallOwner);\r\n        }\r\n        // alle Events mit kleinerer Sequenznummer verarbeiten\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() < seqNr) {\r\n                if (event instanceof PassEvent) {\r\n                    // Ball an anderen Spieler �bertragen\r\n                    setBallOwner(((PassEvent) event).getDestinationPlayer());\r\n                } else {\r\n                    if (event.getDestinationX() > -1 && event.getDestinationY() > -1) {\r\n                        event.getPlayer().setCurrentPosition(event.getDestinationX(), event.getDestinationY());\r\n                    }\r\n                }\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    public MoveEvent getActualMoveEvent() {\r\n        return actualEvent;\r\n    }\r\n\r\n    public Player getMarkedPlayer() {\r\n        return markedPlayer;\r\n    }\r\n\r\n    public void setMarkedPlayer(Player markedPlayer) {\r\n        // alten markierten Spieler demarkieren\r\n        if (this.markedPlayer != null) {\r\n            this.markedPlayer.setMarked(false);\r\n        }\r\n        // evtl. neuen Spieler markieren\r\n        this.markedPlayer = markedPlayer;\r\n        if (markedPlayer != null) {\r\n            markedPlayer.setMarked(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setHighLightedItem(HighlightableItem item) {\r\n        if (this.hightlightedItem != null) {\r\n            // altes Item zur�cksetzen\r\n            this.hightlightedItem.setHighlight(false);\r\n        }\r\n        this.hightlightedItem = item;\r\n        if (item != null) {\r\n            hightlightedItem.setHighlight(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public HighlightableItem getHightligtedItem() {\r\n        return hightlightedItem;\r\n    }\r\n\r\n    public Player getNearestPlayer(int x, int y) {\r\n        List<Player> all = new ArrayList<Player>(offenders);\r\n        all.addAll(defenders);\r\n        return findNearestPlayer(x, y, all);\r\n    }\r\n\r\n    public Offender getNearestOffender(int x, int y) {\r\n        List<Player> all = new ArrayList<Player>(offenders);\r\n        return (Offender) findNearestPlayer(x, y, all);\r\n    }\r\n\r\n    private Player findNearestPlayer(int x, int y, List<Player> players) {\r\n        double entfernung = Double.MAX_VALUE;\r\n        Player temp = null;\r\n        for (Player player : players) {\r\n            int player_x = player.getCurrent_x();\r\n            int player_y = player.getCurrent_y();\r\n            double tempEntfernung = Point2D.distance(x, y, player_x, player_y);\r\n            // Wenn naeher als der MARK_RADIUS\r\n            if (!(tempEntfernung > MARK_RADIUS)) {\r\n                if (tempEntfernung < entfernung) {\r\n                    temp = player;\r\n                    entfernung = tempEntfernung;\r\n                }\r\n            }\r\n        }\r\n        return temp;\r\n    }\r\n\r\n    public MovePoint getNearestMovePoint(int x, int y) {\r\n        MovePoint point = null;\r\n        if (actualEvent != null) {\r\n            double entfernung = Double.MAX_VALUE;\r\n            if (actualEvent.isDestinationPointSet()) {\r\n                int destination_x = actualEvent.getDestinationX();\r\n                int destination_y = actualEvent.getDestinationY();\r\n                double tempEntfernung = Point2D.distance(x, y, destination_x, destination_y);\r\n                // Wenn naeher als der MARK_RADIUS\r\n                if (!(tempEntfernung > MARK_RADIUS)) {\r\n                    if (tempEntfernung < entfernung) {\r\n                        point = actualEvent.getDestinationPoint();\r\n                        entfernung = tempEntfernung;\r\n                    }\r\n                }\r\n            }\r\n            if (actualEvent.isControlPointSet()) {\r\n                int controlPoint_x = actualEvent.getControlPointX();\r\n                int controlPoint_y = actualEvent.getControlPointY();\r\n                double tempEntfernung = Point2D.distance(x, y, controlPoint_x, controlPoint_y);\r\n                // Wenn naeher als der MARK_RADIUS\r\n                if (!(tempEntfernung > MARK_RADIUS)) {\r\n                    if (tempEntfernung < entfernung) {\r\n                        point = actualEvent.getControlPoint();\r\n                        entfernung = tempEntfernung;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return point;\r\n    }\r\n\r\n    public HighlightableItem getNearestHighlightableItem(int x, int y) {\r\n        HighlightableItem temp = null;\r\n        temp = getNearestMovePoint(x, y);\r\n        if (temp == null) {\r\n            temp = getNearestPlayer(x, y);\r\n        }\r\n        return temp;\r\n    }\r\n\r\n    public void movePlayerTo(Player actualPlayer, int x, int y) {\r\n        if (getAcutalSequenceNr() == 0) {\r\n            actualPlayer.setStart_x(x);\r\n            actualPlayer.setStart_y(y);\r\n        }\r\n        // Ansonsten muss die Position im entsprechenden Ereignis gesetzt\r\n        // werden\r\n        // Startposition darf nur im Angreifer/Verteidiger-Modus ge�ndert werden\r\n        fireModelChanged();\r\n    }\r\n\r\n    public boolean isSaved() {\r\n        boolean changed = false;\r\n        if (lastSavedModel != null) {\r\n            //Spielzugnamen vergleichen\r\n            if (lastSavedModel.getMoveName() != null) {\r\n                if (getMoveName() == null || !lastSavedModel.getMoveName().equals(getMoveName())) {\r\n                    return false;\r\n                }\r\n            } else if (getMoveName() != null) {\r\n                //alt: kein Name <-> neu: Name vorhanden\r\n                return false;\r\n            }\r\n            //Ueberprüfen ob Angreifer und Verteidiger unterschiedlich\r\n            // zuerst Spielerlisten vergleichen\r\n            if (changedPlayerList(getOffenders().toArray(new Player[getOffenders().size()]), lastSavedModel.getOffenders().toArray(new Player[lastSavedModel.getOffenders().size()])) || changedPlayerList(getDefenders().toArray(new Player[getDefenders().size()]), lastSavedModel.getDefenders().toArray(new Player[lastSavedModel.getDefenders().size()]))) {\r\n                changed = true;\r\n            } else {\r\n                List<MoveEvent> newEvents = getEvents();\r\n                List<MoveEvent> oldEvents = lastSavedModel.getEvents();\r\n                if (newEvents.size() == oldEvents.size()) {\r\n                    for (int i = 0; i < newEvents.size(); i++) {\r\n                        if (!newEvents.get(i).equals(oldEvents.get(i))) {\r\n                            changed = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                } else {\r\n                    changed = true;\r\n                }\r\n            }\r\n            if (!changed && (getFirstBallOwner() != null || lastSavedModel.getFirstBallOwner() != null)) {\r\n                changed = (getFirstBallOwner() == null) ^ (lastSavedModel.getFirstBallOwner() == null);\r\n                if (!changed) {\r\n                    changed = !getFirstBallOwner().equals(lastSavedModel.getFirstBallOwner());\r\n                }\r\n            }\r\n            // wurde Kommentar geändert?\r\n            if (!changed) {\r\n                if (comment == null || comment.equals(\"\")) {\r\n                    if (lastSavedModel.getComment() != null && !lastSavedModel.getComment().equals(\"\")) {\r\n                        changed = true;\r\n                    }\r\n                } else if (lastSavedModel.getComment() != null) {\r\n                    if (!lastSavedModel.getComment().equals(comment)) {\r\n                        changed = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return !changed;\r\n    }\r\n\r\n    private boolean changedPlayerList(Player[] newList, Player[] oldList) {\r\n        boolean changed = false;\r\n        int size = newList.length;\r\n        int sizeOld = oldList.length;\r\n        if (size == sizeOld) {\r\n            for (int i = 0; i < size; i++) {\r\n                if (!newList[i].equals(oldList[i])) {\r\n                    changed = true;\r\n                    break;\r\n                }\r\n            }\r\n        } else {\r\n            changed = true;\r\n        }\r\n        return changed;\r\n    }\r\n\r\n    public void initWithLoadedModel(HandballModel loadedModel) {\r\n        initModel();\r\n        offenders = loadedModel.getOffenders();\r\n        defenders = loadedModel.getDefenders();\r\n        events = loadedModel.getSortedEvents();\r\n        Offender.setCounter(determineMaxPlayerNumber(offenders));\r\n        Defender.setCounter(determineMaxPlayerNumber(defenders));\r\n        setFirstBallOwner(loadedModel.getFirstBallOwner());\r\n        setState(loadedModel.getState());\r\n        setActualMoveEvent(loadedModel.getActualMoveEvent());\r\n        setComment(loadedModel.getComment());\r\n        // zur Sicherheit\r\n        if (getComment() == null) {\r\n            setComment(\"\");\r\n        }\r\n        setMoveName(loadedModel.getMoveName());\r\n        markAsSaved(loadedModel);\r\n        fireModelChanged();\r\n    }\r\n\r\n    private int determineMaxPlayerNumber(List players) {\r\n        int max = 0;\r\n        for (Object o : players) {\r\n            if (o instanceof Player) {\r\n                Player player = (Player) o;\r\n                if (player.getPlayerNumber() > max) {\r\n                    max = player.getPlayerNumber();\r\n                }\r\n            }\r\n        }\r\n        return max;\r\n    }\r\n\r\n    public void markAsSaved(HandballModel model) {\r\n        try {\r\n            lastSavedModel = (HandballModel) Main.deepCopy(model);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            lastSavedModel = null;\r\n        }\r\n    }\r\n\r\n    public void setDelay(int eventIndex, int delay) {\r\n        getEvents().get(eventIndex).setDelay(delay);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setBallOwner(Offender ballOwner) {\r\n        if (this.ballOwner != null) {\r\n            this.ballOwner.setHasBall(false);\r\n        }\r\n        this.ballOwner = ballOwner;\r\n        if (ballOwner != null) {\r\n            ballOwner.setHasBall(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setBallOwnerSilent(Offender ballOwner) {\r\n        if (this.ballOwner != null) {\r\n            this.ballOwner.setHasBall(false);\r\n        }\r\n        this.ballOwner = ballOwner;\r\n        if (ballOwner != null) {\r\n            ballOwner.setHasBall(true);\r\n        }\r\n        // fireModelChanged();\r\n    }\r\n\r\n    public void startAnimation(boolean onlyActualSequence) {\r\n        setState(State.ANIMATION_RUNNING);\r\n        MoveEvent event = actualEvent;\r\n        if (event == null) {\r\n            event = getEvents().get(0);\r\n        }\r\n        setActualMoveEvent(event);\r\n        animationSequenz = event.getSequenceNr();\r\n        animationModel = new AnimationModel(event, this, onlyActualSequence);\r\n        runningAnimator = new Animator(this);\r\n        computePlayerPositions(animationSequenz);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void pauseAnimation(boolean pause) {\r\n        if (pause) {\r\n            runningAnimator.setPause(true);\r\n        } else {\r\n            runningAnimator.setPause(false);\r\n        }\r\n    }\r\n\r\n    public void initAnimation() {\r\n    }\r\n\r\n    public boolean nextAnimationStep() {\r\n        boolean finished = animationModel.nextStep();\r\n        if (finished) {\r\n            if (animationModel.isOnlyOneSequence()) {\r\n                setState(State.ANIMATION);\r\n                // n�chste Sequzenz ausw�hlen (einfaches sequentielles Anschauen des Spielzugs)\r\n                int nextSeq = (getAcutalSequenceNr() == getHighestSequenceNumber()) ? getAcutalSequenceNr() : getAcutalSequenceNr() + 1;\r\n                List<MoveEvent> nextSeqEvents = getMoveEvents(nextSeq);\r\n                if (nextSeqEvents.get(0) != null) {\r\n                    setActualMoveEvent(nextSeqEvents.get(0));\r\n                }\r\n            } else {\r\n                setState(State.FULL_ANIMATION_ENDED);\r\n            }\r\n        } else {\r\n            fireModelChanged();\r\n        }\r\n        return finished;\r\n    }\r\n\r\n    public void stopAnimation() {\r\n        setState(State.ANIMATION);\r\n        runningAnimator = null;\r\n        setActualMoveEvent(getActualMoveEvent());\r\n    }\r\n\r\n    public boolean isMarkedPlayerAddable() {\r\n        int seq = getAcutalSequenceNr();\r\n        return !events.contains(new MoveEvent(markedPlayer, seq));\r\n    }\r\n\r\n    public boolean passEventDefined(int seq) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() == seq && event instanceof PassEvent) {\r\n                defined = true;\r\n                break;\r\n            }\r\n            if (event.getSequenceNr() > seq) {\r\n                break;\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public boolean passEventDefined() {\r\n        return passEventDefined(getAcutalSequenceNr());\r\n    }\r\n\r\n    public boolean passEventDefinedAfter(int seq) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if ((event instanceof PassEvent) && (event.getSequenceNr() > seq)) {\r\n                defined = true;\r\n                break;\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public boolean eventDefinedAfter(int seq) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() > seq) {\r\n                defined = true;\r\n                break;\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public Ball getBall() {\r\n        return ball;\r\n    }\r\n\r\n    public void setFirstBallOwner(Offender offender) {\r\n        this.firstBallOwner = offender;\r\n        setBallOwner(offender);\r\n        if (firstBallOwner == null) {\r\n            resetBallPosition();\r\n        }\r\n    }\r\n\r\n    public Offender getFirstBallOwner() {\r\n        return firstBallOwner;\r\n    }\r\n\r\n    public boolean hasPlayerBallInNextSequence(Player player) {\r\n        PassEvent pass = null;\r\n        int seq = getAcutalSequenceNr();\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() == seq && event instanceof PassEvent) {\r\n                pass = (PassEvent) event;\r\n                break;\r\n            }\r\n            if (event.getSequenceNr() > seq) {\r\n                break;\r\n            }\r\n        }\r\n        if (pass != null && pass.getDestinationPlayer() != null) {\r\n            return pass.getDestinationPlayer().equals(player) && !passEventDefined(seq + 1);\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public boolean isBallSet() {\r\n        return ballOwner != null;\r\n    }\r\n\r\n    public boolean isGoalPassSet() {\r\n        boolean defined = false;\r\n        for (MoveEvent event : getEvents()) {\r\n            if (event instanceof PassEvent) {\r\n                PassEvent pass = (PassEvent) event;\r\n                if (pass.isGoalPass()) {\r\n                    defined = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public void moveBallTo(int x, int y) {\r\n        ball.setCurrent_x(x);\r\n        ball.setCurrent_y(y);\r\n    }\r\n\r\n    public List<MoveEvent> getActualMoveEvents() {\r\n        return getMoveEvents(getAcutalSequenceNr());\r\n    }\r\n\r\n    public List<MoveEvent> getMoveEvents(int sequenceNr) {\r\n        List<MoveEvent> sequenceEvents = new ArrayList<MoveEvent>();\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() == sequenceNr) {\r\n                sequenceEvents.add(event);\r\n            } else if (event.getSequenceNr() > getAcutalSequenceNr()) {\r\n                break;\r\n            }\r\n        }\r\n        return sequenceEvents;\r\n    }\r\n\r\n    /**\r\n     * Löscht das Aktuelle Ereignis und ALLE Folgenden\r\n     */\r\n    public void removeEventsAfter() {\r\n        MoveEvent event = getActualMoveEvent();\r\n        List<MoveEvent> toDeleteEvents = new ArrayList<MoveEvent>();\r\n        int sequenceNr = event.getSequenceNr();\r\n        // zu loeschende Events sammeln\r\n        for (MoveEvent evt : getEvents()) {\r\n            if (evt.getSequenceNr() > sequenceNr) {\r\n                // Event ist hoeher, also loeschen\r\n                toDeleteEvents.add(evt);\r\n            }\r\n        }\r\n        toDeleteEvents.add(event);\r\n        // gesammelte Events loeschen\r\n        for (MoveEvent deleteEvent : toDeleteEvents) {\r\n            removeMoveEvent(deleteEvent);\r\n        }\r\n        setActualMoveEvent((getEvents().size() > 0) ? getEvents().get(getEvents().size() - 1) : null);\r\n        fireModelChanged();\r\n    }\r\n\r\n    /**\r\n     * Löscht die Ereignisse (auch P�sse) des �bergebenen Spielers. Und die\r\n     * evtl. davon abh�ngigen Folgep�sse\r\n     *\r\n     * @param player\r\n     */\r\n    private void removeEventsOfPlayer(Player player) {\r\n        List<MoveEvent> toDeleteEvents = new ArrayList<MoveEvent>();\r\n        boolean playerInvolved = false;\r\n        // zu loeschende Events sammeln\r\n        for (MoveEvent evt : getEvents()) {\r\n            // Pass?\r\n            if (evt instanceof PassEvent) {\r\n                PassEvent pass = (PassEvent) evt;\r\n                // War ein Pass zu dem Spieler? oder Spieler passt selbst?\r\n                if (pass.getDestinationPlayer().equals(player) || pass.getPlayer().equals(player)) {\r\n                    playerInvolved = true;\r\n                }\r\n                // War Spieler an einem Pass beteiligt?\r\n                if (playerInvolved) {\r\n                    toDeleteEvents.add(pass);\r\n                    continue;\r\n                }\r\n            }\r\n            if (evt.getPlayer().equals(player)) {\r\n                toDeleteEvents.add(evt);\r\n            }\r\n        }\r\n        // gesammelte Events loeschen\r\n        for (MoveEvent deleteEvent : toDeleteEvents) {\r\n            removeMoveEvent(deleteEvent);\r\n        }\r\n        setActualMoveEvent((getEvents().size() > 0) ? getEvents().get(getEvents().size() - 1) : null);\r\n    }\r\n\r\n    public boolean eventDefinedWithPlayer(Player player) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if (event.getPlayer().equals(player)) {\r\n                defined = true;\r\n                break;\r\n            }\r\n            if (event instanceof PassEvent) {\r\n                PassEvent pass = (PassEvent) event;\r\n                if (pass.getDestinationPlayer().equals(player)) {\r\n                    defined = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public int getHighestSequenceNumber() {\r\n        if (events.size() == 0) {\r\n            return 0;\r\n        } else {\r\n            return events.last().getSequenceNr();\r\n        }\r\n    }\r\n\r\n    public String getMoveName() {\r\n        return moveName;\r\n    }\r\n\r\n    public void setMoveName(String moveName) {\r\n        this.moveName = moveName;\r\n        if (Main.getWindow() != null) {\r\n            StringBuffer buffer = new StringBuffer(APP_NAME);\r\n            buffer.append(\" - \");\r\n            if (moveName == null || moveName.equals(\"\")) {\r\n                buffer.append(\"Unbenannt\");\r\n                // Titelleiste aktualisieren\r\n            } else {\r\n                buffer.append(moveName);\r\n            }\r\n            if (!isSaved()) {\r\n                buffer.append(\"*\");\r\n            }\r\n            Main.getWindow().setTitle(buffer.toString());\r\n        }\r\n    }\r\n\r\n    public String getComment() {\r\n        if (comment == null) {\r\n            comment = \"\";\r\n        }\r\n        return comment;\r\n    }\r\n\r\n    public void setComment(String comment) {\r\n        this.comment = comment;\r\n        fireModelChanged();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/model/HandballModelTest0.java",
		"test_prompt": "// HandballModelTest0.java\npackage visu.handball.moves.model;\n\nimport java.awt.geom.Point2D;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\nimport javax.swing.JOptionPane;\nimport visu.handball.moves.Main;\nimport visu.handball.moves.model.animation.AnimationModel;\nimport visu.handball.moves.model.animation.Animator;\nimport visu.handball.moves.model.player.Ball;\nimport visu.handball.moves.model.player.Defender;\nimport visu.handball.moves.model.player.HighlightableItem;\nimport visu.handball.moves.model.player.MovePoint;\nimport visu.handball.moves.model.player.Offender;\nimport visu.handball.moves.model.player.Player;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HandballModel}.\n* It contains ten unit test cases for the {@link HandballModel#addListener(HandballModelListener)} method.\n*/\nclass HandballModelTest0 {"
	},
	{
		"original_code": "// HandballModel.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.model;\r\n\r\nimport java.awt.geom.Point2D;\r\nimport java.io.Serializable;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.SortedSet;\r\nimport java.util.TreeSet;\r\nimport javax.swing.JOptionPane;\r\nimport visu.handball.moves.Main;\r\nimport visu.handball.moves.model.animation.AnimationModel;\r\nimport visu.handball.moves.model.animation.Animator;\r\nimport visu.handball.moves.model.player.Ball;\r\nimport visu.handball.moves.model.player.Defender;\r\nimport visu.handball.moves.model.player.HighlightableItem;\r\nimport visu.handball.moves.model.player.MovePoint;\r\nimport visu.handball.moves.model.player.Offender;\r\nimport visu.handball.moves.model.player.Player;\r\n\r\npublic class HandballModel implements Serializable {\r\n\r\n    private static final long serialVersionUID = -5372891552466311536L;\r\n\r\n    public enum State {\r\n\r\n        INITIAL,\r\n        PLACE_OFFENDERS,\r\n        PLACE_DEFENDERS,\r\n        PLACE_BALL,\r\n        EDIT,\r\n        EDIT_EVENT,\r\n        ANIMATION,\r\n        ANIMATION_RUNNING,\r\n        FULL_ANIMATION_ENDED\r\n    }\r\n\r\n    private static final int MAX_OFFENDERS = 6;\r\n\r\n    private static final int MAX_DEFENDERS = 6;\r\n\r\n    private static final int MARK_RADIUS = 12;\r\n\r\n    private static final String APP_NAME = \"jHandballMoves\";\r\n\r\n    private transient List<HandballModelListener> listeners;\r\n\r\n    private transient List<PlayerRemovedListener> playerRemoveListener;\r\n\r\n    private List<Defender> defenders;\r\n\r\n    private List<Offender> offenders;\r\n\r\n    private SortedSet<MoveEvent> events;\r\n\r\n    private State state;\r\n\r\n    private MoveEvent actualEvent;\r\n\r\n    private Player markedPlayer;\r\n\r\n    private HighlightableItem hightlightedItem;\r\n\r\n    private Offender ballOwner;\r\n\r\n    private Ball ball;\r\n\r\n    private Offender firstBallOwner;\r\n\r\n    private transient Animator runningAnimator;\r\n\r\n    private int animationSequenz;\r\n\r\n    private transient AnimationModel animationModel;\r\n\r\n    private transient HandballModel lastSavedModel;\r\n\r\n    private String comment;\r\n\r\n    private String moveName;\r\n\r\n    public HandballModel() {\r\n        listeners = new ArrayList<HandballModelListener>();\r\n        playerRemoveListener = new ArrayList<PlayerRemovedListener>();\r\n        initModel();\r\n    }\r\n\r\n    public void initModel() {\r\n        defenders = new ArrayList<Defender>();\r\n        Defender.setCounter(0);\r\n        offenders = new ArrayList<Offender>();\r\n        Offender.setCounter(0);\r\n        events = new TreeSet<MoveEvent>();\r\n        // Workaround wegen ToolBar\r\n        state = State.PLACE_OFFENDERS;\r\n        actualEvent = null;\r\n        markedPlayer = null;\r\n        firstBallOwner = null;\r\n        comment = \"\";\r\n        moveName = \"\";\r\n        resetBallPosition();\r\n        try {\r\n            lastSavedModel = (HandballModel) Main.deepCopy(this);\r\n        } catch (Exception e) {\r\n            lastSavedModel = null;\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    private void resetBallPosition() {\r\n        ball = new Ball(-500, -500);\r\n    }\r\n\r\n    public void addOffender(int x, int y) {\r\n        if (offenders.size() == MAX_OFFENDERS) {\r\n            JOptionPane.showMessageDialog(Main.getWindow(), \"Sie haben schon \" + MAX_OFFENDERS + \" Angreifer angelegt.\", \"Info:\", JOptionPane.INFORMATION_MESSAGE);\r\n        } else {\r\n            offenders.add(new Offender(x, y));\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void removePlayer(Player toRemove) {\r\n        if (eventDefinedWithPlayer(toRemove)) {\r\n            removeEventsOfPlayer(toRemove);\r\n        }\r\n        if (toRemove instanceof Offender) {\r\n            removeOffender((Offender) toRemove);\r\n        } else {\r\n            removeDefender((Defender) toRemove);\r\n        }\r\n    }\r\n\r\n    private void removeOffender(Offender toRemove) {\r\n        if (getFirstBallOwner() != null && getFirstBallOwner().equals(toRemove)) {\r\n            setFirstBallOwner(null);\r\n        }\r\n        offenders.remove(toRemove);\r\n        if ((getDefenders().size() + getOffenders().size()) == 0) {\r\n            markedPlayer = null;\r\n        }\r\n        // Spielernummer aktualisieren\r\n        Offender.setCounter(determineMaxPlayerNumber(offenders));\r\n        fireOffenderRemoved(toRemove);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void addDefender(int x, int y) {\r\n        if (defenders.size() == MAX_DEFENDERS) {\r\n            JOptionPane.showMessageDialog(Main.getWindow(), \"Sie haben schon \" + MAX_OFFENDERS + \" Verteidiger angelegt.\", \"Info:\", JOptionPane.INFORMATION_MESSAGE);\r\n        } else {\r\n            defenders.add(new Defender(x, y));\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    private void removeDefender(Defender toRemove) {\r\n        defenders.remove(toRemove);\r\n        if ((getDefenders().size() + getOffenders().size()) == 0) {\r\n            markedPlayer = null;\r\n        }\r\n        Defender.setCounter(determineMaxPlayerNumber(defenders));\r\n        fireDefenderRemoved(toRemove);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public boolean addListener(HandballModelListener o) {\r\n        return listeners.add(o);\r\n    }\r\n\r\n    public boolean removeListener(HandballModelListener o) {\r\n        return listeners.remove(o);\r\n    }\r\n\r\n    public boolean addPlayerRemovedListener(PlayerRemovedListener o) {\r\n        return playerRemoveListener.add(o);\r\n    }\r\n\r\n    public boolean removePlayerRemovedListener(PlayerRemovedListener o) {\r\n        return playerRemoveListener.remove(o);\r\n    }\r\n\r\n    private void fireModelChanged() {\r\n        setMoveName(getMoveName());\r\n        for (HandballModelListener listener : listeners) {\r\n            listener.modelChanged();\r\n        }\r\n    }\r\n\r\n    private void fireOffenderRemoved(Offender offender) {\r\n        for (PlayerRemovedListener listener : playerRemoveListener) {\r\n            listener.offenderRemoved(offender);\r\n        }\r\n    }\r\n\r\n    private void fireDefenderRemoved(Defender defender) {\r\n        for (PlayerRemovedListener listener : playerRemoveListener) {\r\n            listener.defenderRemoved(defender);\r\n        }\r\n    }\r\n\r\n    public List<Defender> getDefenders() {\r\n        return defenders;\r\n    }\r\n\r\n    public List<Offender> getOffenders() {\r\n        return offenders;\r\n    }\r\n\r\n    public State getState() {\r\n        return state;\r\n    }\r\n\r\n    public void setState(State state) {\r\n        if (state == State.EDIT) {\r\n            if (getActualMoveEvent() == null) {\r\n                // Wenn leer, dann Null, sonst letztes Move Event setzen\r\n                setActualMoveEvent(getEvents().isEmpty() ? null : (getEvents().get(getEvents().size() - 1)));\r\n            } else {\r\n                setActualMoveEvent(getActualMoveEvent());\r\n            }\r\n        }\r\n        if (state == State.PLACE_DEFENDERS || state == State.PLACE_OFFENDERS) {\r\n            if (getFirstBallOwner() != null) {\r\n                setBallOwner(getFirstBallOwner());\r\n            }\r\n            setActualMoveEvent(null);\r\n        }\r\n        this.state = state;\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void addMoveEvent(MoveEvent event) {\r\n        events.add(event);\r\n        if (state == State.EDIT) {\r\n            setActualMoveEvent(event);\r\n            state = State.EDIT_EVENT;\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void removeMoveEvent(MoveEvent event) {\r\n        events.remove(event);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public List<MoveEvent> getEvents() {\r\n        List<MoveEvent> list = new ArrayList<MoveEvent>(events);\r\n        return list;\r\n    }\r\n\r\n    public SortedSet<MoveEvent> getSortedEvents() {\r\n        return events;\r\n    }\r\n\r\n    public int getAcutalSequenceNr() {\r\n        if (actualEvent == null)\r\n            return 0;\r\n        else {\r\n            return actualEvent.getSequenceNr();\r\n        }\r\n    }\r\n\r\n    public void setActualMoveEvent(MoveEvent event) {\r\n        if (this.actualEvent != null) {\r\n            this.actualEvent.setMarked(false);\r\n        }\r\n        this.actualEvent = event;\r\n        computePlayerPositions();\r\n        // aktuellen Spieler setzen\r\n        setMarkedPlayer((event == null) ? null : event.getPlayer());\r\n        if (actualEvent != null) {\r\n            if (!actualEvent.isDestinationPointSet()) {\r\n                state = State.EDIT_EVENT;\r\n            } else {\r\n                if (state == State.FULL_ANIMATION_ENDED) {\r\n                    state = State.ANIMATION;\r\n                } else if (state != State.ANIMATION && state != State.ANIMATION_RUNNING) {\r\n                    state = State.EDIT;\r\n                }\r\n            }\r\n            actualEvent.setMarked(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setDestinationPointForEvent(MoveEvent event, int x, int y, boolean temp) {\r\n        event.setDestinationPoint(x, y, temp);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setControlPointForEvent(MoveEvent event, int x, int y, boolean temp) {\r\n        event.setControlPoint(x, y, temp);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setMovePointTo(MovePoint point, int x, int y) {\r\n        actualEvent.setPoint(point, x, y);\r\n        fireModelChanged();\r\n    }\r\n\r\n    private void computePlayerPositions() {\r\n        computePlayerPositions(getAcutalSequenceNr());\r\n    }\r\n\r\n    public void computePlayerPositions(int seqNr) {\r\n        // Spieler Positionen auf Ausgangsstellung\r\n        for (Player offender : offenders) {\r\n            offender.resetPosition();\r\n        }\r\n        for (Player defender : defenders) {\r\n            defender.resetPosition();\r\n        }\r\n        if (seqNr == 1) {\r\n            setBallOwner(firstBallOwner);\r\n        }\r\n        // alle Events mit kleinerer Sequenznummer verarbeiten\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() < seqNr) {\r\n                if (event instanceof PassEvent) {\r\n                    // Ball an anderen Spieler �bertragen\r\n                    setBallOwner(((PassEvent) event).getDestinationPlayer());\r\n                } else {\r\n                    if (event.getDestinationX() > -1 && event.getDestinationY() > -1) {\r\n                        event.getPlayer().setCurrentPosition(event.getDestinationX(), event.getDestinationY());\r\n                    }\r\n                }\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    public MoveEvent getActualMoveEvent() {\r\n        return actualEvent;\r\n    }\r\n\r\n    public Player getMarkedPlayer() {\r\n        return markedPlayer;\r\n    }\r\n\r\n    public void setMarkedPlayer(Player markedPlayer) {\r\n        // alten markierten Spieler demarkieren\r\n        if (this.markedPlayer != null) {\r\n            this.markedPlayer.setMarked(false);\r\n        }\r\n        // evtl. neuen Spieler markieren\r\n        this.markedPlayer = markedPlayer;\r\n        if (markedPlayer != null) {\r\n            markedPlayer.setMarked(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setHighLightedItem(HighlightableItem item) {\r\n        if (this.hightlightedItem != null) {\r\n            // altes Item zur�cksetzen\r\n            this.hightlightedItem.setHighlight(false);\r\n        }\r\n        this.hightlightedItem = item;\r\n        if (item != null) {\r\n            hightlightedItem.setHighlight(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public HighlightableItem getHightligtedItem() {\r\n        return hightlightedItem;\r\n    }\r\n\r\n    public Player getNearestPlayer(int x, int y) {\r\n        List<Player> all = new ArrayList<Player>(offenders);\r\n        all.addAll(defenders);\r\n        return findNearestPlayer(x, y, all);\r\n    }\r\n\r\n    public Offender getNearestOffender(int x, int y) {\r\n        List<Player> all = new ArrayList<Player>(offenders);\r\n        return (Offender) findNearestPlayer(x, y, all);\r\n    }\r\n\r\n    private Player findNearestPlayer(int x, int y, List<Player> players) {\r\n        double entfernung = Double.MAX_VALUE;\r\n        Player temp = null;\r\n        for (Player player : players) {\r\n            int player_x = player.getCurrent_x();\r\n            int player_y = player.getCurrent_y();\r\n            double tempEntfernung = Point2D.distance(x, y, player_x, player_y);\r\n            // Wenn naeher als der MARK_RADIUS\r\n            if (!(tempEntfernung > MARK_RADIUS)) {\r\n                if (tempEntfernung < entfernung) {\r\n                    temp = player;\r\n                    entfernung = tempEntfernung;\r\n                }\r\n            }\r\n        }\r\n        return temp;\r\n    }\r\n\r\n    public MovePoint getNearestMovePoint(int x, int y) {\r\n        MovePoint point = null;\r\n        if (actualEvent != null) {\r\n            double entfernung = Double.MAX_VALUE;\r\n            if (actualEvent.isDestinationPointSet()) {\r\n                int destination_x = actualEvent.getDestinationX();\r\n                int destination_y = actualEvent.getDestinationY();\r\n                double tempEntfernung = Point2D.distance(x, y, destination_x, destination_y);\r\n                // Wenn naeher als der MARK_RADIUS\r\n                if (!(tempEntfernung > MARK_RADIUS)) {\r\n                    if (tempEntfernung < entfernung) {\r\n                        point = actualEvent.getDestinationPoint();\r\n                        entfernung = tempEntfernung;\r\n                    }\r\n                }\r\n            }\r\n            if (actualEvent.isControlPointSet()) {\r\n                int controlPoint_x = actualEvent.getControlPointX();\r\n                int controlPoint_y = actualEvent.getControlPointY();\r\n                double tempEntfernung = Point2D.distance(x, y, controlPoint_x, controlPoint_y);\r\n                // Wenn naeher als der MARK_RADIUS\r\n                if (!(tempEntfernung > MARK_RADIUS)) {\r\n                    if (tempEntfernung < entfernung) {\r\n                        point = actualEvent.getControlPoint();\r\n                        entfernung = tempEntfernung;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return point;\r\n    }\r\n\r\n    public HighlightableItem getNearestHighlightableItem(int x, int y) {\r\n        HighlightableItem temp = null;\r\n        temp = getNearestMovePoint(x, y);\r\n        if (temp == null) {\r\n            temp = getNearestPlayer(x, y);\r\n        }\r\n        return temp;\r\n    }\r\n\r\n    public void movePlayerTo(Player actualPlayer, int x, int y) {\r\n        if (getAcutalSequenceNr() == 0) {\r\n            actualPlayer.setStart_x(x);\r\n            actualPlayer.setStart_y(y);\r\n        }\r\n        // Ansonsten muss die Position im entsprechenden Ereignis gesetzt\r\n        // werden\r\n        // Startposition darf nur im Angreifer/Verteidiger-Modus ge�ndert werden\r\n        fireModelChanged();\r\n    }\r\n\r\n    public boolean isSaved() {\r\n        boolean changed = false;\r\n        if (lastSavedModel != null) {\r\n            //Spielzugnamen vergleichen\r\n            if (lastSavedModel.getMoveName() != null) {\r\n                if (getMoveName() == null || !lastSavedModel.getMoveName().equals(getMoveName())) {\r\n                    return false;\r\n                }\r\n            } else if (getMoveName() != null) {\r\n                //alt: kein Name <-> neu: Name vorhanden\r\n                return false;\r\n            }\r\n            //Ueberprüfen ob Angreifer und Verteidiger unterschiedlich\r\n            // zuerst Spielerlisten vergleichen\r\n            if (changedPlayerList(getOffenders().toArray(new Player[getOffenders().size()]), lastSavedModel.getOffenders().toArray(new Player[lastSavedModel.getOffenders().size()])) || changedPlayerList(getDefenders().toArray(new Player[getDefenders().size()]), lastSavedModel.getDefenders().toArray(new Player[lastSavedModel.getDefenders().size()]))) {\r\n                changed = true;\r\n            } else {\r\n                List<MoveEvent> newEvents = getEvents();\r\n                List<MoveEvent> oldEvents = lastSavedModel.getEvents();\r\n                if (newEvents.size() == oldEvents.size()) {\r\n                    for (int i = 0; i < newEvents.size(); i++) {\r\n                        if (!newEvents.get(i).equals(oldEvents.get(i))) {\r\n                            changed = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                } else {\r\n                    changed = true;\r\n                }\r\n            }\r\n            if (!changed && (getFirstBallOwner() != null || lastSavedModel.getFirstBallOwner() != null)) {\r\n                changed = (getFirstBallOwner() == null) ^ (lastSavedModel.getFirstBallOwner() == null);\r\n                if (!changed) {\r\n                    changed = !getFirstBallOwner().equals(lastSavedModel.getFirstBallOwner());\r\n                }\r\n            }\r\n            // wurde Kommentar geändert?\r\n            if (!changed) {\r\n                if (comment == null || comment.equals(\"\")) {\r\n                    if (lastSavedModel.getComment() != null && !lastSavedModel.getComment().equals(\"\")) {\r\n                        changed = true;\r\n                    }\r\n                } else if (lastSavedModel.getComment() != null) {\r\n                    if (!lastSavedModel.getComment().equals(comment)) {\r\n                        changed = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return !changed;\r\n    }\r\n\r\n    private boolean changedPlayerList(Player[] newList, Player[] oldList) {\r\n        boolean changed = false;\r\n        int size = newList.length;\r\n        int sizeOld = oldList.length;\r\n        if (size == sizeOld) {\r\n            for (int i = 0; i < size; i++) {\r\n                if (!newList[i].equals(oldList[i])) {\r\n                    changed = true;\r\n                    break;\r\n                }\r\n            }\r\n        } else {\r\n            changed = true;\r\n        }\r\n        return changed;\r\n    }\r\n\r\n    public void initWithLoadedModel(HandballModel loadedModel) {\r\n        initModel();\r\n        offenders = loadedModel.getOffenders();\r\n        defenders = loadedModel.getDefenders();\r\n        events = loadedModel.getSortedEvents();\r\n        Offender.setCounter(determineMaxPlayerNumber(offenders));\r\n        Defender.setCounter(determineMaxPlayerNumber(defenders));\r\n        setFirstBallOwner(loadedModel.getFirstBallOwner());\r\n        setState(loadedModel.getState());\r\n        setActualMoveEvent(loadedModel.getActualMoveEvent());\r\n        setComment(loadedModel.getComment());\r\n        // zur Sicherheit\r\n        if (getComment() == null) {\r\n            setComment(\"\");\r\n        }\r\n        setMoveName(loadedModel.getMoveName());\r\n        markAsSaved(loadedModel);\r\n        fireModelChanged();\r\n    }\r\n\r\n    private int determineMaxPlayerNumber(List players) {\r\n        int max = 0;\r\n        for (Object o : players) {\r\n            if (o instanceof Player) {\r\n                Player player = (Player) o;\r\n                if (player.getPlayerNumber() > max) {\r\n                    max = player.getPlayerNumber();\r\n                }\r\n            }\r\n        }\r\n        return max;\r\n    }\r\n\r\n    public void markAsSaved(HandballModel model) {\r\n        try {\r\n            lastSavedModel = (HandballModel) Main.deepCopy(model);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            lastSavedModel = null;\r\n        }\r\n    }\r\n\r\n    public void setDelay(int eventIndex, int delay) {\r\n        getEvents().get(eventIndex).setDelay(delay);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setBallOwner(Offender ballOwner) {\r\n        if (this.ballOwner != null) {\r\n            this.ballOwner.setHasBall(false);\r\n        }\r\n        this.ballOwner = ballOwner;\r\n        if (ballOwner != null) {\r\n            ballOwner.setHasBall(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setBallOwnerSilent(Offender ballOwner) {\r\n        if (this.ballOwner != null) {\r\n            this.ballOwner.setHasBall(false);\r\n        }\r\n        this.ballOwner = ballOwner;\r\n        if (ballOwner != null) {\r\n            ballOwner.setHasBall(true);\r\n        }\r\n        // fireModelChanged();\r\n    }\r\n\r\n    public void startAnimation(boolean onlyActualSequence) {\r\n        setState(State.ANIMATION_RUNNING);\r\n        MoveEvent event = actualEvent;\r\n        if (event == null) {\r\n            event = getEvents().get(0);\r\n        }\r\n        setActualMoveEvent(event);\r\n        animationSequenz = event.getSequenceNr();\r\n        animationModel = new AnimationModel(event, this, onlyActualSequence);\r\n        runningAnimator = new Animator(this);\r\n        computePlayerPositions(animationSequenz);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void pauseAnimation(boolean pause) {\r\n        if (pause) {\r\n            runningAnimator.setPause(true);\r\n        } else {\r\n            runningAnimator.setPause(false);\r\n        }\r\n    }\r\n\r\n    public void initAnimation() {\r\n    }\r\n\r\n    public boolean nextAnimationStep() {\r\n        boolean finished = animationModel.nextStep();\r\n        if (finished) {\r\n            if (animationModel.isOnlyOneSequence()) {\r\n                setState(State.ANIMATION);\r\n                // n�chste Sequzenz ausw�hlen (einfaches sequentielles Anschauen des Spielzugs)\r\n                int nextSeq = (getAcutalSequenceNr() == getHighestSequenceNumber()) ? getAcutalSequenceNr() : getAcutalSequenceNr() + 1;\r\n                List<MoveEvent> nextSeqEvents = getMoveEvents(nextSeq);\r\n                if (nextSeqEvents.get(0) != null) {\r\n                    setActualMoveEvent(nextSeqEvents.get(0));\r\n                }\r\n            } else {\r\n                setState(State.FULL_ANIMATION_ENDED);\r\n            }\r\n        } else {\r\n            fireModelChanged();\r\n        }\r\n        return finished;\r\n    }\r\n\r\n    public void stopAnimation() {\r\n        setState(State.ANIMATION);\r\n        runningAnimator = null;\r\n        setActualMoveEvent(getActualMoveEvent());\r\n    }\r\n\r\n    public boolean isMarkedPlayerAddable() {\r\n        int seq = getAcutalSequenceNr();\r\n        return !events.contains(new MoveEvent(markedPlayer, seq));\r\n    }\r\n\r\n    public boolean passEventDefined(int seq) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() == seq && event instanceof PassEvent) {\r\n                defined = true;\r\n                break;\r\n            }\r\n            if (event.getSequenceNr() > seq) {\r\n                break;\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public boolean passEventDefined() {\r\n        return passEventDefined(getAcutalSequenceNr());\r\n    }\r\n\r\n    public boolean passEventDefinedAfter(int seq) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if ((event instanceof PassEvent) && (event.getSequenceNr() > seq)) {\r\n                defined = true;\r\n                break;\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public boolean eventDefinedAfter(int seq) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() > seq) {\r\n                defined = true;\r\n                break;\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public Ball getBall() {\r\n        return ball;\r\n    }\r\n\r\n    public void setFirstBallOwner(Offender offender) {\r\n        this.firstBallOwner = offender;\r\n        setBallOwner(offender);\r\n        if (firstBallOwner == null) {\r\n            resetBallPosition();\r\n        }\r\n    }\r\n\r\n    public Offender getFirstBallOwner() {\r\n        return firstBallOwner;\r\n    }\r\n\r\n    public boolean hasPlayerBallInNextSequence(Player player) {\r\n        PassEvent pass = null;\r\n        int seq = getAcutalSequenceNr();\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() == seq && event instanceof PassEvent) {\r\n                pass = (PassEvent) event;\r\n                break;\r\n            }\r\n            if (event.getSequenceNr() > seq) {\r\n                break;\r\n            }\r\n        }\r\n        if (pass != null && pass.getDestinationPlayer() != null) {\r\n            return pass.getDestinationPlayer().equals(player) && !passEventDefined(seq + 1);\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public boolean isBallSet() {\r\n        return ballOwner != null;\r\n    }\r\n\r\n    public boolean isGoalPassSet() {\r\n        boolean defined = false;\r\n        for (MoveEvent event : getEvents()) {\r\n            if (event instanceof PassEvent) {\r\n                PassEvent pass = (PassEvent) event;\r\n                if (pass.isGoalPass()) {\r\n                    defined = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public void moveBallTo(int x, int y) {\r\n        ball.setCurrent_x(x);\r\n        ball.setCurrent_y(y);\r\n    }\r\n\r\n    public List<MoveEvent> getActualMoveEvents() {\r\n        return getMoveEvents(getAcutalSequenceNr());\r\n    }\r\n\r\n    public List<MoveEvent> getMoveEvents(int sequenceNr) {\r\n        List<MoveEvent> sequenceEvents = new ArrayList<MoveEvent>();\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() == sequenceNr) {\r\n                sequenceEvents.add(event);\r\n            } else if (event.getSequenceNr() > getAcutalSequenceNr()) {\r\n                break;\r\n            }\r\n        }\r\n        return sequenceEvents;\r\n    }\r\n\r\n    /**\r\n     * Löscht das Aktuelle Ereignis und ALLE Folgenden\r\n     */\r\n    public void removeEventsAfter() {\r\n        MoveEvent event = getActualMoveEvent();\r\n        List<MoveEvent> toDeleteEvents = new ArrayList<MoveEvent>();\r\n        int sequenceNr = event.getSequenceNr();\r\n        // zu loeschende Events sammeln\r\n        for (MoveEvent evt : getEvents()) {\r\n            if (evt.getSequenceNr() > sequenceNr) {\r\n                // Event ist hoeher, also loeschen\r\n                toDeleteEvents.add(evt);\r\n            }\r\n        }\r\n        toDeleteEvents.add(event);\r\n        // gesammelte Events loeschen\r\n        for (MoveEvent deleteEvent : toDeleteEvents) {\r\n            removeMoveEvent(deleteEvent);\r\n        }\r\n        setActualMoveEvent((getEvents().size() > 0) ? getEvents().get(getEvents().size() - 1) : null);\r\n        fireModelChanged();\r\n    }\r\n\r\n    /**\r\n     * Löscht die Ereignisse (auch P�sse) des �bergebenen Spielers. Und die\r\n     * evtl. davon abh�ngigen Folgep�sse\r\n     *\r\n     * @param player\r\n     */\r\n    private void removeEventsOfPlayer(Player player) {\r\n        List<MoveEvent> toDeleteEvents = new ArrayList<MoveEvent>();\r\n        boolean playerInvolved = false;\r\n        // zu loeschende Events sammeln\r\n        for (MoveEvent evt : getEvents()) {\r\n            // Pass?\r\n            if (evt instanceof PassEvent) {\r\n                PassEvent pass = (PassEvent) evt;\r\n                // War ein Pass zu dem Spieler? oder Spieler passt selbst?\r\n                if (pass.getDestinationPlayer().equals(player) || pass.getPlayer().equals(player)) {\r\n                    playerInvolved = true;\r\n                }\r\n                // War Spieler an einem Pass beteiligt?\r\n                if (playerInvolved) {\r\n                    toDeleteEvents.add(pass);\r\n                    continue;\r\n                }\r\n            }\r\n            if (evt.getPlayer().equals(player)) {\r\n                toDeleteEvents.add(evt);\r\n            }\r\n        }\r\n        // gesammelte Events loeschen\r\n        for (MoveEvent deleteEvent : toDeleteEvents) {\r\n            removeMoveEvent(deleteEvent);\r\n        }\r\n        setActualMoveEvent((getEvents().size() > 0) ? getEvents().get(getEvents().size() - 1) : null);\r\n    }\r\n\r\n    public boolean eventDefinedWithPlayer(Player player) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if (event.getPlayer().equals(player)) {\r\n                defined = true;\r\n                break;\r\n            }\r\n            if (event instanceof PassEvent) {\r\n                PassEvent pass = (PassEvent) event;\r\n                if (pass.getDestinationPlayer().equals(player)) {\r\n                    defined = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public int getHighestSequenceNumber() {\r\n        if (events.size() == 0) {\r\n            return 0;\r\n        } else {\r\n            return events.last().getSequenceNr();\r\n        }\r\n    }\r\n\r\n    public String getMoveName() {\r\n        return moveName;\r\n    }\r\n\r\n    public void setMoveName(String moveName) {\r\n        this.moveName = moveName;\r\n        if (Main.getWindow() != null) {\r\n            StringBuffer buffer = new StringBuffer(APP_NAME);\r\n            buffer.append(\" - \");\r\n            if (moveName == null || moveName.equals(\"\")) {\r\n                buffer.append(\"Unbenannt\");\r\n                // Titelleiste aktualisieren\r\n            } else {\r\n                buffer.append(moveName);\r\n            }\r\n            if (!isSaved()) {\r\n                buffer.append(\"*\");\r\n            }\r\n            Main.getWindow().setTitle(buffer.toString());\r\n        }\r\n    }\r\n\r\n    public String getComment() {\r\n        if (comment == null) {\r\n            comment = \"\";\r\n        }\r\n        return comment;\r\n    }\r\n\r\n    public void setComment(String comment) {\r\n        this.comment = comment;\r\n        fireModelChanged();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/model/HandballModelTest1.java",
		"test_prompt": "// HandballModelTest1.java\npackage visu.handball.moves.model;\n\nimport java.awt.geom.Point2D;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\nimport javax.swing.JOptionPane;\nimport visu.handball.moves.Main;\nimport visu.handball.moves.model.animation.AnimationModel;\nimport visu.handball.moves.model.animation.Animator;\nimport visu.handball.moves.model.player.Ball;\nimport visu.handball.moves.model.player.Defender;\nimport visu.handball.moves.model.player.HighlightableItem;\nimport visu.handball.moves.model.player.MovePoint;\nimport visu.handball.moves.model.player.Offender;\nimport visu.handball.moves.model.player.Player;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HandballModel}.\n* It contains ten unit test cases for the {@link HandballModel#removeListener(HandballModelListener)} method.\n*/\nclass HandballModelTest1 {"
	},
	{
		"original_code": "// HandballModel.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.model;\r\n\r\nimport java.awt.geom.Point2D;\r\nimport java.io.Serializable;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.SortedSet;\r\nimport java.util.TreeSet;\r\nimport javax.swing.JOptionPane;\r\nimport visu.handball.moves.Main;\r\nimport visu.handball.moves.model.animation.AnimationModel;\r\nimport visu.handball.moves.model.animation.Animator;\r\nimport visu.handball.moves.model.player.Ball;\r\nimport visu.handball.moves.model.player.Defender;\r\nimport visu.handball.moves.model.player.HighlightableItem;\r\nimport visu.handball.moves.model.player.MovePoint;\r\nimport visu.handball.moves.model.player.Offender;\r\nimport visu.handball.moves.model.player.Player;\r\n\r\npublic class HandballModel implements Serializable {\r\n\r\n    private static final long serialVersionUID = -5372891552466311536L;\r\n\r\n    public enum State {\r\n\r\n        INITIAL,\r\n        PLACE_OFFENDERS,\r\n        PLACE_DEFENDERS,\r\n        PLACE_BALL,\r\n        EDIT,\r\n        EDIT_EVENT,\r\n        ANIMATION,\r\n        ANIMATION_RUNNING,\r\n        FULL_ANIMATION_ENDED\r\n    }\r\n\r\n    private static final int MAX_OFFENDERS = 6;\r\n\r\n    private static final int MAX_DEFENDERS = 6;\r\n\r\n    private static final int MARK_RADIUS = 12;\r\n\r\n    private static final String APP_NAME = \"jHandballMoves\";\r\n\r\n    private transient List<HandballModelListener> listeners;\r\n\r\n    private transient List<PlayerRemovedListener> playerRemoveListener;\r\n\r\n    private List<Defender> defenders;\r\n\r\n    private List<Offender> offenders;\r\n\r\n    private SortedSet<MoveEvent> events;\r\n\r\n    private State state;\r\n\r\n    private MoveEvent actualEvent;\r\n\r\n    private Player markedPlayer;\r\n\r\n    private HighlightableItem hightlightedItem;\r\n\r\n    private Offender ballOwner;\r\n\r\n    private Ball ball;\r\n\r\n    private Offender firstBallOwner;\r\n\r\n    private transient Animator runningAnimator;\r\n\r\n    private int animationSequenz;\r\n\r\n    private transient AnimationModel animationModel;\r\n\r\n    private transient HandballModel lastSavedModel;\r\n\r\n    private String comment;\r\n\r\n    private String moveName;\r\n\r\n    public HandballModel() {\r\n        listeners = new ArrayList<HandballModelListener>();\r\n        playerRemoveListener = new ArrayList<PlayerRemovedListener>();\r\n        initModel();\r\n    }\r\n\r\n    public void initModel() {\r\n        defenders = new ArrayList<Defender>();\r\n        Defender.setCounter(0);\r\n        offenders = new ArrayList<Offender>();\r\n        Offender.setCounter(0);\r\n        events = new TreeSet<MoveEvent>();\r\n        // Workaround wegen ToolBar\r\n        state = State.PLACE_OFFENDERS;\r\n        actualEvent = null;\r\n        markedPlayer = null;\r\n        firstBallOwner = null;\r\n        comment = \"\";\r\n        moveName = \"\";\r\n        resetBallPosition();\r\n        try {\r\n            lastSavedModel = (HandballModel) Main.deepCopy(this);\r\n        } catch (Exception e) {\r\n            lastSavedModel = null;\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    private void resetBallPosition() {\r\n        ball = new Ball(-500, -500);\r\n    }\r\n\r\n    public void addOffender(int x, int y) {\r\n        if (offenders.size() == MAX_OFFENDERS) {\r\n            JOptionPane.showMessageDialog(Main.getWindow(), \"Sie haben schon \" + MAX_OFFENDERS + \" Angreifer angelegt.\", \"Info:\", JOptionPane.INFORMATION_MESSAGE);\r\n        } else {\r\n            offenders.add(new Offender(x, y));\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void removePlayer(Player toRemove) {\r\n        if (eventDefinedWithPlayer(toRemove)) {\r\n            removeEventsOfPlayer(toRemove);\r\n        }\r\n        if (toRemove instanceof Offender) {\r\n            removeOffender((Offender) toRemove);\r\n        } else {\r\n            removeDefender((Defender) toRemove);\r\n        }\r\n    }\r\n\r\n    private void removeOffender(Offender toRemove) {\r\n        if (getFirstBallOwner() != null && getFirstBallOwner().equals(toRemove)) {\r\n            setFirstBallOwner(null);\r\n        }\r\n        offenders.remove(toRemove);\r\n        if ((getDefenders().size() + getOffenders().size()) == 0) {\r\n            markedPlayer = null;\r\n        }\r\n        // Spielernummer aktualisieren\r\n        Offender.setCounter(determineMaxPlayerNumber(offenders));\r\n        fireOffenderRemoved(toRemove);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void addDefender(int x, int y) {\r\n        if (defenders.size() == MAX_DEFENDERS) {\r\n            JOptionPane.showMessageDialog(Main.getWindow(), \"Sie haben schon \" + MAX_OFFENDERS + \" Verteidiger angelegt.\", \"Info:\", JOptionPane.INFORMATION_MESSAGE);\r\n        } else {\r\n            defenders.add(new Defender(x, y));\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    private void removeDefender(Defender toRemove) {\r\n        defenders.remove(toRemove);\r\n        if ((getDefenders().size() + getOffenders().size()) == 0) {\r\n            markedPlayer = null;\r\n        }\r\n        Defender.setCounter(determineMaxPlayerNumber(defenders));\r\n        fireDefenderRemoved(toRemove);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public boolean addListener(HandballModelListener o) {\r\n        return listeners.add(o);\r\n    }\r\n\r\n    public boolean removeListener(HandballModelListener o) {\r\n        return listeners.remove(o);\r\n    }\r\n\r\n    public boolean addPlayerRemovedListener(PlayerRemovedListener o) {\r\n        return playerRemoveListener.add(o);\r\n    }\r\n\r\n    public boolean removePlayerRemovedListener(PlayerRemovedListener o) {\r\n        return playerRemoveListener.remove(o);\r\n    }\r\n\r\n    private void fireModelChanged() {\r\n        setMoveName(getMoveName());\r\n        for (HandballModelListener listener : listeners) {\r\n            listener.modelChanged();\r\n        }\r\n    }\r\n\r\n    private void fireOffenderRemoved(Offender offender) {\r\n        for (PlayerRemovedListener listener : playerRemoveListener) {\r\n            listener.offenderRemoved(offender);\r\n        }\r\n    }\r\n\r\n    private void fireDefenderRemoved(Defender defender) {\r\n        for (PlayerRemovedListener listener : playerRemoveListener) {\r\n            listener.defenderRemoved(defender);\r\n        }\r\n    }\r\n\r\n    public List<Defender> getDefenders() {\r\n        return defenders;\r\n    }\r\n\r\n    public List<Offender> getOffenders() {\r\n        return offenders;\r\n    }\r\n\r\n    public State getState() {\r\n        return state;\r\n    }\r\n\r\n    public void setState(State state) {\r\n        if (state == State.EDIT) {\r\n            if (getActualMoveEvent() == null) {\r\n                // Wenn leer, dann Null, sonst letztes Move Event setzen\r\n                setActualMoveEvent(getEvents().isEmpty() ? null : (getEvents().get(getEvents().size() - 1)));\r\n            } else {\r\n                setActualMoveEvent(getActualMoveEvent());\r\n            }\r\n        }\r\n        if (state == State.PLACE_DEFENDERS || state == State.PLACE_OFFENDERS) {\r\n            if (getFirstBallOwner() != null) {\r\n                setBallOwner(getFirstBallOwner());\r\n            }\r\n            setActualMoveEvent(null);\r\n        }\r\n        this.state = state;\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void addMoveEvent(MoveEvent event) {\r\n        events.add(event);\r\n        if (state == State.EDIT) {\r\n            setActualMoveEvent(event);\r\n            state = State.EDIT_EVENT;\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void removeMoveEvent(MoveEvent event) {\r\n        events.remove(event);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public List<MoveEvent> getEvents() {\r\n        List<MoveEvent> list = new ArrayList<MoveEvent>(events);\r\n        return list;\r\n    }\r\n\r\n    public SortedSet<MoveEvent> getSortedEvents() {\r\n        return events;\r\n    }\r\n\r\n    public int getAcutalSequenceNr() {\r\n        if (actualEvent == null)\r\n            return 0;\r\n        else {\r\n            return actualEvent.getSequenceNr();\r\n        }\r\n    }\r\n\r\n    public void setActualMoveEvent(MoveEvent event) {\r\n        if (this.actualEvent != null) {\r\n            this.actualEvent.setMarked(false);\r\n        }\r\n        this.actualEvent = event;\r\n        computePlayerPositions();\r\n        // aktuellen Spieler setzen\r\n        setMarkedPlayer((event == null) ? null : event.getPlayer());\r\n        if (actualEvent != null) {\r\n            if (!actualEvent.isDestinationPointSet()) {\r\n                state = State.EDIT_EVENT;\r\n            } else {\r\n                if (state == State.FULL_ANIMATION_ENDED) {\r\n                    state = State.ANIMATION;\r\n                } else if (state != State.ANIMATION && state != State.ANIMATION_RUNNING) {\r\n                    state = State.EDIT;\r\n                }\r\n            }\r\n            actualEvent.setMarked(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setDestinationPointForEvent(MoveEvent event, int x, int y, boolean temp) {\r\n        event.setDestinationPoint(x, y, temp);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setControlPointForEvent(MoveEvent event, int x, int y, boolean temp) {\r\n        event.setControlPoint(x, y, temp);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setMovePointTo(MovePoint point, int x, int y) {\r\n        actualEvent.setPoint(point, x, y);\r\n        fireModelChanged();\r\n    }\r\n\r\n    private void computePlayerPositions() {\r\n        computePlayerPositions(getAcutalSequenceNr());\r\n    }\r\n\r\n    public void computePlayerPositions(int seqNr) {\r\n        // Spieler Positionen auf Ausgangsstellung\r\n        for (Player offender : offenders) {\r\n            offender.resetPosition();\r\n        }\r\n        for (Player defender : defenders) {\r\n            defender.resetPosition();\r\n        }\r\n        if (seqNr == 1) {\r\n            setBallOwner(firstBallOwner);\r\n        }\r\n        // alle Events mit kleinerer Sequenznummer verarbeiten\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() < seqNr) {\r\n                if (event instanceof PassEvent) {\r\n                    // Ball an anderen Spieler �bertragen\r\n                    setBallOwner(((PassEvent) event).getDestinationPlayer());\r\n                } else {\r\n                    if (event.getDestinationX() > -1 && event.getDestinationY() > -1) {\r\n                        event.getPlayer().setCurrentPosition(event.getDestinationX(), event.getDestinationY());\r\n                    }\r\n                }\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    public MoveEvent getActualMoveEvent() {\r\n        return actualEvent;\r\n    }\r\n\r\n    public Player getMarkedPlayer() {\r\n        return markedPlayer;\r\n    }\r\n\r\n    public void setMarkedPlayer(Player markedPlayer) {\r\n        // alten markierten Spieler demarkieren\r\n        if (this.markedPlayer != null) {\r\n            this.markedPlayer.setMarked(false);\r\n        }\r\n        // evtl. neuen Spieler markieren\r\n        this.markedPlayer = markedPlayer;\r\n        if (markedPlayer != null) {\r\n            markedPlayer.setMarked(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setHighLightedItem(HighlightableItem item) {\r\n        if (this.hightlightedItem != null) {\r\n            // altes Item zur�cksetzen\r\n            this.hightlightedItem.setHighlight(false);\r\n        }\r\n        this.hightlightedItem = item;\r\n        if (item != null) {\r\n            hightlightedItem.setHighlight(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public HighlightableItem getHightligtedItem() {\r\n        return hightlightedItem;\r\n    }\r\n\r\n    public Player getNearestPlayer(int x, int y) {\r\n        List<Player> all = new ArrayList<Player>(offenders);\r\n        all.addAll(defenders);\r\n        return findNearestPlayer(x, y, all);\r\n    }\r\n\r\n    public Offender getNearestOffender(int x, int y) {\r\n        List<Player> all = new ArrayList<Player>(offenders);\r\n        return (Offender) findNearestPlayer(x, y, all);\r\n    }\r\n\r\n    private Player findNearestPlayer(int x, int y, List<Player> players) {\r\n        double entfernung = Double.MAX_VALUE;\r\n        Player temp = null;\r\n        for (Player player : players) {\r\n            int player_x = player.getCurrent_x();\r\n            int player_y = player.getCurrent_y();\r\n            double tempEntfernung = Point2D.distance(x, y, player_x, player_y);\r\n            // Wenn naeher als der MARK_RADIUS\r\n            if (!(tempEntfernung > MARK_RADIUS)) {\r\n                if (tempEntfernung < entfernung) {\r\n                    temp = player;\r\n                    entfernung = tempEntfernung;\r\n                }\r\n            }\r\n        }\r\n        return temp;\r\n    }\r\n\r\n    public MovePoint getNearestMovePoint(int x, int y) {\r\n        MovePoint point = null;\r\n        if (actualEvent != null) {\r\n            double entfernung = Double.MAX_VALUE;\r\n            if (actualEvent.isDestinationPointSet()) {\r\n                int destination_x = actualEvent.getDestinationX();\r\n                int destination_y = actualEvent.getDestinationY();\r\n                double tempEntfernung = Point2D.distance(x, y, destination_x, destination_y);\r\n                // Wenn naeher als der MARK_RADIUS\r\n                if (!(tempEntfernung > MARK_RADIUS)) {\r\n                    if (tempEntfernung < entfernung) {\r\n                        point = actualEvent.getDestinationPoint();\r\n                        entfernung = tempEntfernung;\r\n                    }\r\n                }\r\n            }\r\n            if (actualEvent.isControlPointSet()) {\r\n                int controlPoint_x = actualEvent.getControlPointX();\r\n                int controlPoint_y = actualEvent.getControlPointY();\r\n                double tempEntfernung = Point2D.distance(x, y, controlPoint_x, controlPoint_y);\r\n                // Wenn naeher als der MARK_RADIUS\r\n                if (!(tempEntfernung > MARK_RADIUS)) {\r\n                    if (tempEntfernung < entfernung) {\r\n                        point = actualEvent.getControlPoint();\r\n                        entfernung = tempEntfernung;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return point;\r\n    }\r\n\r\n    public HighlightableItem getNearestHighlightableItem(int x, int y) {\r\n        HighlightableItem temp = null;\r\n        temp = getNearestMovePoint(x, y);\r\n        if (temp == null) {\r\n            temp = getNearestPlayer(x, y);\r\n        }\r\n        return temp;\r\n    }\r\n\r\n    public void movePlayerTo(Player actualPlayer, int x, int y) {\r\n        if (getAcutalSequenceNr() == 0) {\r\n            actualPlayer.setStart_x(x);\r\n            actualPlayer.setStart_y(y);\r\n        }\r\n        // Ansonsten muss die Position im entsprechenden Ereignis gesetzt\r\n        // werden\r\n        // Startposition darf nur im Angreifer/Verteidiger-Modus ge�ndert werden\r\n        fireModelChanged();\r\n    }\r\n\r\n    public boolean isSaved() {\r\n        boolean changed = false;\r\n        if (lastSavedModel != null) {\r\n            //Spielzugnamen vergleichen\r\n            if (lastSavedModel.getMoveName() != null) {\r\n                if (getMoveName() == null || !lastSavedModel.getMoveName().equals(getMoveName())) {\r\n                    return false;\r\n                }\r\n            } else if (getMoveName() != null) {\r\n                //alt: kein Name <-> neu: Name vorhanden\r\n                return false;\r\n            }\r\n            //Ueberprüfen ob Angreifer und Verteidiger unterschiedlich\r\n            // zuerst Spielerlisten vergleichen\r\n            if (changedPlayerList(getOffenders().toArray(new Player[getOffenders().size()]), lastSavedModel.getOffenders().toArray(new Player[lastSavedModel.getOffenders().size()])) || changedPlayerList(getDefenders().toArray(new Player[getDefenders().size()]), lastSavedModel.getDefenders().toArray(new Player[lastSavedModel.getDefenders().size()]))) {\r\n                changed = true;\r\n            } else {\r\n                List<MoveEvent> newEvents = getEvents();\r\n                List<MoveEvent> oldEvents = lastSavedModel.getEvents();\r\n                if (newEvents.size() == oldEvents.size()) {\r\n                    for (int i = 0; i < newEvents.size(); i++) {\r\n                        if (!newEvents.get(i).equals(oldEvents.get(i))) {\r\n                            changed = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                } else {\r\n                    changed = true;\r\n                }\r\n            }\r\n            if (!changed && (getFirstBallOwner() != null || lastSavedModel.getFirstBallOwner() != null)) {\r\n                changed = (getFirstBallOwner() == null) ^ (lastSavedModel.getFirstBallOwner() == null);\r\n                if (!changed) {\r\n                    changed = !getFirstBallOwner().equals(lastSavedModel.getFirstBallOwner());\r\n                }\r\n            }\r\n            // wurde Kommentar geändert?\r\n            if (!changed) {\r\n                if (comment == null || comment.equals(\"\")) {\r\n                    if (lastSavedModel.getComment() != null && !lastSavedModel.getComment().equals(\"\")) {\r\n                        changed = true;\r\n                    }\r\n                } else if (lastSavedModel.getComment() != null) {\r\n                    if (!lastSavedModel.getComment().equals(comment)) {\r\n                        changed = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return !changed;\r\n    }\r\n\r\n    private boolean changedPlayerList(Player[] newList, Player[] oldList) {\r\n        boolean changed = false;\r\n        int size = newList.length;\r\n        int sizeOld = oldList.length;\r\n        if (size == sizeOld) {\r\n            for (int i = 0; i < size; i++) {\r\n                if (!newList[i].equals(oldList[i])) {\r\n                    changed = true;\r\n                    break;\r\n                }\r\n            }\r\n        } else {\r\n            changed = true;\r\n        }\r\n        return changed;\r\n    }\r\n\r\n    public void initWithLoadedModel(HandballModel loadedModel) {\r\n        initModel();\r\n        offenders = loadedModel.getOffenders();\r\n        defenders = loadedModel.getDefenders();\r\n        events = loadedModel.getSortedEvents();\r\n        Offender.setCounter(determineMaxPlayerNumber(offenders));\r\n        Defender.setCounter(determineMaxPlayerNumber(defenders));\r\n        setFirstBallOwner(loadedModel.getFirstBallOwner());\r\n        setState(loadedModel.getState());\r\n        setActualMoveEvent(loadedModel.getActualMoveEvent());\r\n        setComment(loadedModel.getComment());\r\n        // zur Sicherheit\r\n        if (getComment() == null) {\r\n            setComment(\"\");\r\n        }\r\n        setMoveName(loadedModel.getMoveName());\r\n        markAsSaved(loadedModel);\r\n        fireModelChanged();\r\n    }\r\n\r\n    private int determineMaxPlayerNumber(List players) {\r\n        int max = 0;\r\n        for (Object o : players) {\r\n            if (o instanceof Player) {\r\n                Player player = (Player) o;\r\n                if (player.getPlayerNumber() > max) {\r\n                    max = player.getPlayerNumber();\r\n                }\r\n            }\r\n        }\r\n        return max;\r\n    }\r\n\r\n    public void markAsSaved(HandballModel model) {\r\n        try {\r\n            lastSavedModel = (HandballModel) Main.deepCopy(model);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            lastSavedModel = null;\r\n        }\r\n    }\r\n\r\n    public void setDelay(int eventIndex, int delay) {\r\n        getEvents().get(eventIndex).setDelay(delay);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setBallOwner(Offender ballOwner) {\r\n        if (this.ballOwner != null) {\r\n            this.ballOwner.setHasBall(false);\r\n        }\r\n        this.ballOwner = ballOwner;\r\n        if (ballOwner != null) {\r\n            ballOwner.setHasBall(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setBallOwnerSilent(Offender ballOwner) {\r\n        if (this.ballOwner != null) {\r\n            this.ballOwner.setHasBall(false);\r\n        }\r\n        this.ballOwner = ballOwner;\r\n        if (ballOwner != null) {\r\n            ballOwner.setHasBall(true);\r\n        }\r\n        // fireModelChanged();\r\n    }\r\n\r\n    public void startAnimation(boolean onlyActualSequence) {\r\n        setState(State.ANIMATION_RUNNING);\r\n        MoveEvent event = actualEvent;\r\n        if (event == null) {\r\n            event = getEvents().get(0);\r\n        }\r\n        setActualMoveEvent(event);\r\n        animationSequenz = event.getSequenceNr();\r\n        animationModel = new AnimationModel(event, this, onlyActualSequence);\r\n        runningAnimator = new Animator(this);\r\n        computePlayerPositions(animationSequenz);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void pauseAnimation(boolean pause) {\r\n        if (pause) {\r\n            runningAnimator.setPause(true);\r\n        } else {\r\n            runningAnimator.setPause(false);\r\n        }\r\n    }\r\n\r\n    public void initAnimation() {\r\n    }\r\n\r\n    public boolean nextAnimationStep() {\r\n        boolean finished = animationModel.nextStep();\r\n        if (finished) {\r\n            if (animationModel.isOnlyOneSequence()) {\r\n                setState(State.ANIMATION);\r\n                // n�chste Sequzenz ausw�hlen (einfaches sequentielles Anschauen des Spielzugs)\r\n                int nextSeq = (getAcutalSequenceNr() == getHighestSequenceNumber()) ? getAcutalSequenceNr() : getAcutalSequenceNr() + 1;\r\n                List<MoveEvent> nextSeqEvents = getMoveEvents(nextSeq);\r\n                if (nextSeqEvents.get(0) != null) {\r\n                    setActualMoveEvent(nextSeqEvents.get(0));\r\n                }\r\n            } else {\r\n                setState(State.FULL_ANIMATION_ENDED);\r\n            }\r\n        } else {\r\n            fireModelChanged();\r\n        }\r\n        return finished;\r\n    }\r\n\r\n    public void stopAnimation() {\r\n        setState(State.ANIMATION);\r\n        runningAnimator = null;\r\n        setActualMoveEvent(getActualMoveEvent());\r\n    }\r\n\r\n    public boolean isMarkedPlayerAddable() {\r\n        int seq = getAcutalSequenceNr();\r\n        return !events.contains(new MoveEvent(markedPlayer, seq));\r\n    }\r\n\r\n    public boolean passEventDefined(int seq) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() == seq && event instanceof PassEvent) {\r\n                defined = true;\r\n                break;\r\n            }\r\n            if (event.getSequenceNr() > seq) {\r\n                break;\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public boolean passEventDefined() {\r\n        return passEventDefined(getAcutalSequenceNr());\r\n    }\r\n\r\n    public boolean passEventDefinedAfter(int seq) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if ((event instanceof PassEvent) && (event.getSequenceNr() > seq)) {\r\n                defined = true;\r\n                break;\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public boolean eventDefinedAfter(int seq) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() > seq) {\r\n                defined = true;\r\n                break;\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public Ball getBall() {\r\n        return ball;\r\n    }\r\n\r\n    public void setFirstBallOwner(Offender offender) {\r\n        this.firstBallOwner = offender;\r\n        setBallOwner(offender);\r\n        if (firstBallOwner == null) {\r\n            resetBallPosition();\r\n        }\r\n    }\r\n\r\n    public Offender getFirstBallOwner() {\r\n        return firstBallOwner;\r\n    }\r\n\r\n    public boolean hasPlayerBallInNextSequence(Player player) {\r\n        PassEvent pass = null;\r\n        int seq = getAcutalSequenceNr();\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() == seq && event instanceof PassEvent) {\r\n                pass = (PassEvent) event;\r\n                break;\r\n            }\r\n            if (event.getSequenceNr() > seq) {\r\n                break;\r\n            }\r\n        }\r\n        if (pass != null && pass.getDestinationPlayer() != null) {\r\n            return pass.getDestinationPlayer().equals(player) && !passEventDefined(seq + 1);\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public boolean isBallSet() {\r\n        return ballOwner != null;\r\n    }\r\n\r\n    public boolean isGoalPassSet() {\r\n        boolean defined = false;\r\n        for (MoveEvent event : getEvents()) {\r\n            if (event instanceof PassEvent) {\r\n                PassEvent pass = (PassEvent) event;\r\n                if (pass.isGoalPass()) {\r\n                    defined = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public void moveBallTo(int x, int y) {\r\n        ball.setCurrent_x(x);\r\n        ball.setCurrent_y(y);\r\n    }\r\n\r\n    public List<MoveEvent> getActualMoveEvents() {\r\n        return getMoveEvents(getAcutalSequenceNr());\r\n    }\r\n\r\n    public List<MoveEvent> getMoveEvents(int sequenceNr) {\r\n        List<MoveEvent> sequenceEvents = new ArrayList<MoveEvent>();\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() == sequenceNr) {\r\n                sequenceEvents.add(event);\r\n            } else if (event.getSequenceNr() > getAcutalSequenceNr()) {\r\n                break;\r\n            }\r\n        }\r\n        return sequenceEvents;\r\n    }\r\n\r\n    /**\r\n     * Löscht das Aktuelle Ereignis und ALLE Folgenden\r\n     */\r\n    public void removeEventsAfter() {\r\n        MoveEvent event = getActualMoveEvent();\r\n        List<MoveEvent> toDeleteEvents = new ArrayList<MoveEvent>();\r\n        int sequenceNr = event.getSequenceNr();\r\n        // zu loeschende Events sammeln\r\n        for (MoveEvent evt : getEvents()) {\r\n            if (evt.getSequenceNr() > sequenceNr) {\r\n                // Event ist hoeher, also loeschen\r\n                toDeleteEvents.add(evt);\r\n            }\r\n        }\r\n        toDeleteEvents.add(event);\r\n        // gesammelte Events loeschen\r\n        for (MoveEvent deleteEvent : toDeleteEvents) {\r\n            removeMoveEvent(deleteEvent);\r\n        }\r\n        setActualMoveEvent((getEvents().size() > 0) ? getEvents().get(getEvents().size() - 1) : null);\r\n        fireModelChanged();\r\n    }\r\n\r\n    /**\r\n     * Löscht die Ereignisse (auch P�sse) des �bergebenen Spielers. Und die\r\n     * evtl. davon abh�ngigen Folgep�sse\r\n     *\r\n     * @param player\r\n     */\r\n    private void removeEventsOfPlayer(Player player) {\r\n        List<MoveEvent> toDeleteEvents = new ArrayList<MoveEvent>();\r\n        boolean playerInvolved = false;\r\n        // zu loeschende Events sammeln\r\n        for (MoveEvent evt : getEvents()) {\r\n            // Pass?\r\n            if (evt instanceof PassEvent) {\r\n                PassEvent pass = (PassEvent) evt;\r\n                // War ein Pass zu dem Spieler? oder Spieler passt selbst?\r\n                if (pass.getDestinationPlayer().equals(player) || pass.getPlayer().equals(player)) {\r\n                    playerInvolved = true;\r\n                }\r\n                // War Spieler an einem Pass beteiligt?\r\n                if (playerInvolved) {\r\n                    toDeleteEvents.add(pass);\r\n                    continue;\r\n                }\r\n            }\r\n            if (evt.getPlayer().equals(player)) {\r\n                toDeleteEvents.add(evt);\r\n            }\r\n        }\r\n        // gesammelte Events loeschen\r\n        for (MoveEvent deleteEvent : toDeleteEvents) {\r\n            removeMoveEvent(deleteEvent);\r\n        }\r\n        setActualMoveEvent((getEvents().size() > 0) ? getEvents().get(getEvents().size() - 1) : null);\r\n    }\r\n\r\n    public boolean eventDefinedWithPlayer(Player player) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if (event.getPlayer().equals(player)) {\r\n                defined = true;\r\n                break;\r\n            }\r\n            if (event instanceof PassEvent) {\r\n                PassEvent pass = (PassEvent) event;\r\n                if (pass.getDestinationPlayer().equals(player)) {\r\n                    defined = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public int getHighestSequenceNumber() {\r\n        if (events.size() == 0) {\r\n            return 0;\r\n        } else {\r\n            return events.last().getSequenceNr();\r\n        }\r\n    }\r\n\r\n    public String getMoveName() {\r\n        return moveName;\r\n    }\r\n\r\n    public void setMoveName(String moveName) {\r\n        this.moveName = moveName;\r\n        if (Main.getWindow() != null) {\r\n            StringBuffer buffer = new StringBuffer(APP_NAME);\r\n            buffer.append(\" - \");\r\n            if (moveName == null || moveName.equals(\"\")) {\r\n                buffer.append(\"Unbenannt\");\r\n                // Titelleiste aktualisieren\r\n            } else {\r\n                buffer.append(moveName);\r\n            }\r\n            if (!isSaved()) {\r\n                buffer.append(\"*\");\r\n            }\r\n            Main.getWindow().setTitle(buffer.toString());\r\n        }\r\n    }\r\n\r\n    public String getComment() {\r\n        if (comment == null) {\r\n            comment = \"\";\r\n        }\r\n        return comment;\r\n    }\r\n\r\n    public void setComment(String comment) {\r\n        this.comment = comment;\r\n        fireModelChanged();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/model/HandballModelTest2.java",
		"test_prompt": "// HandballModelTest2.java\npackage visu.handball.moves.model;\n\nimport java.awt.geom.Point2D;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\nimport javax.swing.JOptionPane;\nimport visu.handball.moves.Main;\nimport visu.handball.moves.model.animation.AnimationModel;\nimport visu.handball.moves.model.animation.Animator;\nimport visu.handball.moves.model.player.Ball;\nimport visu.handball.moves.model.player.Defender;\nimport visu.handball.moves.model.player.HighlightableItem;\nimport visu.handball.moves.model.player.MovePoint;\nimport visu.handball.moves.model.player.Offender;\nimport visu.handball.moves.model.player.Player;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HandballModel}.\n* It contains ten unit test cases for the {@link HandballModel#addPlayerRemovedListener(PlayerRemovedListener)} method.\n*/\nclass HandballModelTest2 {"
	},
	{
		"original_code": "// HandballModel.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.model;\r\n\r\nimport java.awt.geom.Point2D;\r\nimport java.io.Serializable;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.SortedSet;\r\nimport java.util.TreeSet;\r\nimport javax.swing.JOptionPane;\r\nimport visu.handball.moves.Main;\r\nimport visu.handball.moves.model.animation.AnimationModel;\r\nimport visu.handball.moves.model.animation.Animator;\r\nimport visu.handball.moves.model.player.Ball;\r\nimport visu.handball.moves.model.player.Defender;\r\nimport visu.handball.moves.model.player.HighlightableItem;\r\nimport visu.handball.moves.model.player.MovePoint;\r\nimport visu.handball.moves.model.player.Offender;\r\nimport visu.handball.moves.model.player.Player;\r\n\r\npublic class HandballModel implements Serializable {\r\n\r\n    private static final long serialVersionUID = -5372891552466311536L;\r\n\r\n    public enum State {\r\n\r\n        INITIAL,\r\n        PLACE_OFFENDERS,\r\n        PLACE_DEFENDERS,\r\n        PLACE_BALL,\r\n        EDIT,\r\n        EDIT_EVENT,\r\n        ANIMATION,\r\n        ANIMATION_RUNNING,\r\n        FULL_ANIMATION_ENDED\r\n    }\r\n\r\n    private static final int MAX_OFFENDERS = 6;\r\n\r\n    private static final int MAX_DEFENDERS = 6;\r\n\r\n    private static final int MARK_RADIUS = 12;\r\n\r\n    private static final String APP_NAME = \"jHandballMoves\";\r\n\r\n    private transient List<HandballModelListener> listeners;\r\n\r\n    private transient List<PlayerRemovedListener> playerRemoveListener;\r\n\r\n    private List<Defender> defenders;\r\n\r\n    private List<Offender> offenders;\r\n\r\n    private SortedSet<MoveEvent> events;\r\n\r\n    private State state;\r\n\r\n    private MoveEvent actualEvent;\r\n\r\n    private Player markedPlayer;\r\n\r\n    private HighlightableItem hightlightedItem;\r\n\r\n    private Offender ballOwner;\r\n\r\n    private Ball ball;\r\n\r\n    private Offender firstBallOwner;\r\n\r\n    private transient Animator runningAnimator;\r\n\r\n    private int animationSequenz;\r\n\r\n    private transient AnimationModel animationModel;\r\n\r\n    private transient HandballModel lastSavedModel;\r\n\r\n    private String comment;\r\n\r\n    private String moveName;\r\n\r\n    public HandballModel() {\r\n        listeners = new ArrayList<HandballModelListener>();\r\n        playerRemoveListener = new ArrayList<PlayerRemovedListener>();\r\n        initModel();\r\n    }\r\n\r\n    public void initModel() {\r\n        defenders = new ArrayList<Defender>();\r\n        Defender.setCounter(0);\r\n        offenders = new ArrayList<Offender>();\r\n        Offender.setCounter(0);\r\n        events = new TreeSet<MoveEvent>();\r\n        // Workaround wegen ToolBar\r\n        state = State.PLACE_OFFENDERS;\r\n        actualEvent = null;\r\n        markedPlayer = null;\r\n        firstBallOwner = null;\r\n        comment = \"\";\r\n        moveName = \"\";\r\n        resetBallPosition();\r\n        try {\r\n            lastSavedModel = (HandballModel) Main.deepCopy(this);\r\n        } catch (Exception e) {\r\n            lastSavedModel = null;\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    private void resetBallPosition() {\r\n        ball = new Ball(-500, -500);\r\n    }\r\n\r\n    public void addOffender(int x, int y) {\r\n        if (offenders.size() == MAX_OFFENDERS) {\r\n            JOptionPane.showMessageDialog(Main.getWindow(), \"Sie haben schon \" + MAX_OFFENDERS + \" Angreifer angelegt.\", \"Info:\", JOptionPane.INFORMATION_MESSAGE);\r\n        } else {\r\n            offenders.add(new Offender(x, y));\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void removePlayer(Player toRemove) {\r\n        if (eventDefinedWithPlayer(toRemove)) {\r\n            removeEventsOfPlayer(toRemove);\r\n        }\r\n        if (toRemove instanceof Offender) {\r\n            removeOffender((Offender) toRemove);\r\n        } else {\r\n            removeDefender((Defender) toRemove);\r\n        }\r\n    }\r\n\r\n    private void removeOffender(Offender toRemove) {\r\n        if (getFirstBallOwner() != null && getFirstBallOwner().equals(toRemove)) {\r\n            setFirstBallOwner(null);\r\n        }\r\n        offenders.remove(toRemove);\r\n        if ((getDefenders().size() + getOffenders().size()) == 0) {\r\n            markedPlayer = null;\r\n        }\r\n        // Spielernummer aktualisieren\r\n        Offender.setCounter(determineMaxPlayerNumber(offenders));\r\n        fireOffenderRemoved(toRemove);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void addDefender(int x, int y) {\r\n        if (defenders.size() == MAX_DEFENDERS) {\r\n            JOptionPane.showMessageDialog(Main.getWindow(), \"Sie haben schon \" + MAX_OFFENDERS + \" Verteidiger angelegt.\", \"Info:\", JOptionPane.INFORMATION_MESSAGE);\r\n        } else {\r\n            defenders.add(new Defender(x, y));\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    private void removeDefender(Defender toRemove) {\r\n        defenders.remove(toRemove);\r\n        if ((getDefenders().size() + getOffenders().size()) == 0) {\r\n            markedPlayer = null;\r\n        }\r\n        Defender.setCounter(determineMaxPlayerNumber(defenders));\r\n        fireDefenderRemoved(toRemove);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public boolean addListener(HandballModelListener o) {\r\n        return listeners.add(o);\r\n    }\r\n\r\n    public boolean removeListener(HandballModelListener o) {\r\n        return listeners.remove(o);\r\n    }\r\n\r\n    public boolean addPlayerRemovedListener(PlayerRemovedListener o) {\r\n        return playerRemoveListener.add(o);\r\n    }\r\n\r\n    public boolean removePlayerRemovedListener(PlayerRemovedListener o) {\r\n        return playerRemoveListener.remove(o);\r\n    }\r\n\r\n    private void fireModelChanged() {\r\n        setMoveName(getMoveName());\r\n        for (HandballModelListener listener : listeners) {\r\n            listener.modelChanged();\r\n        }\r\n    }\r\n\r\n    private void fireOffenderRemoved(Offender offender) {\r\n        for (PlayerRemovedListener listener : playerRemoveListener) {\r\n            listener.offenderRemoved(offender);\r\n        }\r\n    }\r\n\r\n    private void fireDefenderRemoved(Defender defender) {\r\n        for (PlayerRemovedListener listener : playerRemoveListener) {\r\n            listener.defenderRemoved(defender);\r\n        }\r\n    }\r\n\r\n    public List<Defender> getDefenders() {\r\n        return defenders;\r\n    }\r\n\r\n    public List<Offender> getOffenders() {\r\n        return offenders;\r\n    }\r\n\r\n    public State getState() {\r\n        return state;\r\n    }\r\n\r\n    public void setState(State state) {\r\n        if (state == State.EDIT) {\r\n            if (getActualMoveEvent() == null) {\r\n                // Wenn leer, dann Null, sonst letztes Move Event setzen\r\n                setActualMoveEvent(getEvents().isEmpty() ? null : (getEvents().get(getEvents().size() - 1)));\r\n            } else {\r\n                setActualMoveEvent(getActualMoveEvent());\r\n            }\r\n        }\r\n        if (state == State.PLACE_DEFENDERS || state == State.PLACE_OFFENDERS) {\r\n            if (getFirstBallOwner() != null) {\r\n                setBallOwner(getFirstBallOwner());\r\n            }\r\n            setActualMoveEvent(null);\r\n        }\r\n        this.state = state;\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void addMoveEvent(MoveEvent event) {\r\n        events.add(event);\r\n        if (state == State.EDIT) {\r\n            setActualMoveEvent(event);\r\n            state = State.EDIT_EVENT;\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void removeMoveEvent(MoveEvent event) {\r\n        events.remove(event);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public List<MoveEvent> getEvents() {\r\n        List<MoveEvent> list = new ArrayList<MoveEvent>(events);\r\n        return list;\r\n    }\r\n\r\n    public SortedSet<MoveEvent> getSortedEvents() {\r\n        return events;\r\n    }\r\n\r\n    public int getAcutalSequenceNr() {\r\n        if (actualEvent == null)\r\n            return 0;\r\n        else {\r\n            return actualEvent.getSequenceNr();\r\n        }\r\n    }\r\n\r\n    public void setActualMoveEvent(MoveEvent event) {\r\n        if (this.actualEvent != null) {\r\n            this.actualEvent.setMarked(false);\r\n        }\r\n        this.actualEvent = event;\r\n        computePlayerPositions();\r\n        // aktuellen Spieler setzen\r\n        setMarkedPlayer((event == null) ? null : event.getPlayer());\r\n        if (actualEvent != null) {\r\n            if (!actualEvent.isDestinationPointSet()) {\r\n                state = State.EDIT_EVENT;\r\n            } else {\r\n                if (state == State.FULL_ANIMATION_ENDED) {\r\n                    state = State.ANIMATION;\r\n                } else if (state != State.ANIMATION && state != State.ANIMATION_RUNNING) {\r\n                    state = State.EDIT;\r\n                }\r\n            }\r\n            actualEvent.setMarked(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setDestinationPointForEvent(MoveEvent event, int x, int y, boolean temp) {\r\n        event.setDestinationPoint(x, y, temp);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setControlPointForEvent(MoveEvent event, int x, int y, boolean temp) {\r\n        event.setControlPoint(x, y, temp);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setMovePointTo(MovePoint point, int x, int y) {\r\n        actualEvent.setPoint(point, x, y);\r\n        fireModelChanged();\r\n    }\r\n\r\n    private void computePlayerPositions() {\r\n        computePlayerPositions(getAcutalSequenceNr());\r\n    }\r\n\r\n    public void computePlayerPositions(int seqNr) {\r\n        // Spieler Positionen auf Ausgangsstellung\r\n        for (Player offender : offenders) {\r\n            offender.resetPosition();\r\n        }\r\n        for (Player defender : defenders) {\r\n            defender.resetPosition();\r\n        }\r\n        if (seqNr == 1) {\r\n            setBallOwner(firstBallOwner);\r\n        }\r\n        // alle Events mit kleinerer Sequenznummer verarbeiten\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() < seqNr) {\r\n                if (event instanceof PassEvent) {\r\n                    // Ball an anderen Spieler �bertragen\r\n                    setBallOwner(((PassEvent) event).getDestinationPlayer());\r\n                } else {\r\n                    if (event.getDestinationX() > -1 && event.getDestinationY() > -1) {\r\n                        event.getPlayer().setCurrentPosition(event.getDestinationX(), event.getDestinationY());\r\n                    }\r\n                }\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    public MoveEvent getActualMoveEvent() {\r\n        return actualEvent;\r\n    }\r\n\r\n    public Player getMarkedPlayer() {\r\n        return markedPlayer;\r\n    }\r\n\r\n    public void setMarkedPlayer(Player markedPlayer) {\r\n        // alten markierten Spieler demarkieren\r\n        if (this.markedPlayer != null) {\r\n            this.markedPlayer.setMarked(false);\r\n        }\r\n        // evtl. neuen Spieler markieren\r\n        this.markedPlayer = markedPlayer;\r\n        if (markedPlayer != null) {\r\n            markedPlayer.setMarked(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setHighLightedItem(HighlightableItem item) {\r\n        if (this.hightlightedItem != null) {\r\n            // altes Item zur�cksetzen\r\n            this.hightlightedItem.setHighlight(false);\r\n        }\r\n        this.hightlightedItem = item;\r\n        if (item != null) {\r\n            hightlightedItem.setHighlight(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public HighlightableItem getHightligtedItem() {\r\n        return hightlightedItem;\r\n    }\r\n\r\n    public Player getNearestPlayer(int x, int y) {\r\n        List<Player> all = new ArrayList<Player>(offenders);\r\n        all.addAll(defenders);\r\n        return findNearestPlayer(x, y, all);\r\n    }\r\n\r\n    public Offender getNearestOffender(int x, int y) {\r\n        List<Player> all = new ArrayList<Player>(offenders);\r\n        return (Offender) findNearestPlayer(x, y, all);\r\n    }\r\n\r\n    private Player findNearestPlayer(int x, int y, List<Player> players) {\r\n        double entfernung = Double.MAX_VALUE;\r\n        Player temp = null;\r\n        for (Player player : players) {\r\n            int player_x = player.getCurrent_x();\r\n            int player_y = player.getCurrent_y();\r\n            double tempEntfernung = Point2D.distance(x, y, player_x, player_y);\r\n            // Wenn naeher als der MARK_RADIUS\r\n            if (!(tempEntfernung > MARK_RADIUS)) {\r\n                if (tempEntfernung < entfernung) {\r\n                    temp = player;\r\n                    entfernung = tempEntfernung;\r\n                }\r\n            }\r\n        }\r\n        return temp;\r\n    }\r\n\r\n    public MovePoint getNearestMovePoint(int x, int y) {\r\n        MovePoint point = null;\r\n        if (actualEvent != null) {\r\n            double entfernung = Double.MAX_VALUE;\r\n            if (actualEvent.isDestinationPointSet()) {\r\n                int destination_x = actualEvent.getDestinationX();\r\n                int destination_y = actualEvent.getDestinationY();\r\n                double tempEntfernung = Point2D.distance(x, y, destination_x, destination_y);\r\n                // Wenn naeher als der MARK_RADIUS\r\n                if (!(tempEntfernung > MARK_RADIUS)) {\r\n                    if (tempEntfernung < entfernung) {\r\n                        point = actualEvent.getDestinationPoint();\r\n                        entfernung = tempEntfernung;\r\n                    }\r\n                }\r\n            }\r\n            if (actualEvent.isControlPointSet()) {\r\n                int controlPoint_x = actualEvent.getControlPointX();\r\n                int controlPoint_y = actualEvent.getControlPointY();\r\n                double tempEntfernung = Point2D.distance(x, y, controlPoint_x, controlPoint_y);\r\n                // Wenn naeher als der MARK_RADIUS\r\n                if (!(tempEntfernung > MARK_RADIUS)) {\r\n                    if (tempEntfernung < entfernung) {\r\n                        point = actualEvent.getControlPoint();\r\n                        entfernung = tempEntfernung;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return point;\r\n    }\r\n\r\n    public HighlightableItem getNearestHighlightableItem(int x, int y) {\r\n        HighlightableItem temp = null;\r\n        temp = getNearestMovePoint(x, y);\r\n        if (temp == null) {\r\n            temp = getNearestPlayer(x, y);\r\n        }\r\n        return temp;\r\n    }\r\n\r\n    public void movePlayerTo(Player actualPlayer, int x, int y) {\r\n        if (getAcutalSequenceNr() == 0) {\r\n            actualPlayer.setStart_x(x);\r\n            actualPlayer.setStart_y(y);\r\n        }\r\n        // Ansonsten muss die Position im entsprechenden Ereignis gesetzt\r\n        // werden\r\n        // Startposition darf nur im Angreifer/Verteidiger-Modus ge�ndert werden\r\n        fireModelChanged();\r\n    }\r\n\r\n    public boolean isSaved() {\r\n        boolean changed = false;\r\n        if (lastSavedModel != null) {\r\n            //Spielzugnamen vergleichen\r\n            if (lastSavedModel.getMoveName() != null) {\r\n                if (getMoveName() == null || !lastSavedModel.getMoveName().equals(getMoveName())) {\r\n                    return false;\r\n                }\r\n            } else if (getMoveName() != null) {\r\n                //alt: kein Name <-> neu: Name vorhanden\r\n                return false;\r\n            }\r\n            //Ueberprüfen ob Angreifer und Verteidiger unterschiedlich\r\n            // zuerst Spielerlisten vergleichen\r\n            if (changedPlayerList(getOffenders().toArray(new Player[getOffenders().size()]), lastSavedModel.getOffenders().toArray(new Player[lastSavedModel.getOffenders().size()])) || changedPlayerList(getDefenders().toArray(new Player[getDefenders().size()]), lastSavedModel.getDefenders().toArray(new Player[lastSavedModel.getDefenders().size()]))) {\r\n                changed = true;\r\n            } else {\r\n                List<MoveEvent> newEvents = getEvents();\r\n                List<MoveEvent> oldEvents = lastSavedModel.getEvents();\r\n                if (newEvents.size() == oldEvents.size()) {\r\n                    for (int i = 0; i < newEvents.size(); i++) {\r\n                        if (!newEvents.get(i).equals(oldEvents.get(i))) {\r\n                            changed = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                } else {\r\n                    changed = true;\r\n                }\r\n            }\r\n            if (!changed && (getFirstBallOwner() != null || lastSavedModel.getFirstBallOwner() != null)) {\r\n                changed = (getFirstBallOwner() == null) ^ (lastSavedModel.getFirstBallOwner() == null);\r\n                if (!changed) {\r\n                    changed = !getFirstBallOwner().equals(lastSavedModel.getFirstBallOwner());\r\n                }\r\n            }\r\n            // wurde Kommentar geändert?\r\n            if (!changed) {\r\n                if (comment == null || comment.equals(\"\")) {\r\n                    if (lastSavedModel.getComment() != null && !lastSavedModel.getComment().equals(\"\")) {\r\n                        changed = true;\r\n                    }\r\n                } else if (lastSavedModel.getComment() != null) {\r\n                    if (!lastSavedModel.getComment().equals(comment)) {\r\n                        changed = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return !changed;\r\n    }\r\n\r\n    private boolean changedPlayerList(Player[] newList, Player[] oldList) {\r\n        boolean changed = false;\r\n        int size = newList.length;\r\n        int sizeOld = oldList.length;\r\n        if (size == sizeOld) {\r\n            for (int i = 0; i < size; i++) {\r\n                if (!newList[i].equals(oldList[i])) {\r\n                    changed = true;\r\n                    break;\r\n                }\r\n            }\r\n        } else {\r\n            changed = true;\r\n        }\r\n        return changed;\r\n    }\r\n\r\n    public void initWithLoadedModel(HandballModel loadedModel) {\r\n        initModel();\r\n        offenders = loadedModel.getOffenders();\r\n        defenders = loadedModel.getDefenders();\r\n        events = loadedModel.getSortedEvents();\r\n        Offender.setCounter(determineMaxPlayerNumber(offenders));\r\n        Defender.setCounter(determineMaxPlayerNumber(defenders));\r\n        setFirstBallOwner(loadedModel.getFirstBallOwner());\r\n        setState(loadedModel.getState());\r\n        setActualMoveEvent(loadedModel.getActualMoveEvent());\r\n        setComment(loadedModel.getComment());\r\n        // zur Sicherheit\r\n        if (getComment() == null) {\r\n            setComment(\"\");\r\n        }\r\n        setMoveName(loadedModel.getMoveName());\r\n        markAsSaved(loadedModel);\r\n        fireModelChanged();\r\n    }\r\n\r\n    private int determineMaxPlayerNumber(List players) {\r\n        int max = 0;\r\n        for (Object o : players) {\r\n            if (o instanceof Player) {\r\n                Player player = (Player) o;\r\n                if (player.getPlayerNumber() > max) {\r\n                    max = player.getPlayerNumber();\r\n                }\r\n            }\r\n        }\r\n        return max;\r\n    }\r\n\r\n    public void markAsSaved(HandballModel model) {\r\n        try {\r\n            lastSavedModel = (HandballModel) Main.deepCopy(model);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            lastSavedModel = null;\r\n        }\r\n    }\r\n\r\n    public void setDelay(int eventIndex, int delay) {\r\n        getEvents().get(eventIndex).setDelay(delay);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setBallOwner(Offender ballOwner) {\r\n        if (this.ballOwner != null) {\r\n            this.ballOwner.setHasBall(false);\r\n        }\r\n        this.ballOwner = ballOwner;\r\n        if (ballOwner != null) {\r\n            ballOwner.setHasBall(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setBallOwnerSilent(Offender ballOwner) {\r\n        if (this.ballOwner != null) {\r\n            this.ballOwner.setHasBall(false);\r\n        }\r\n        this.ballOwner = ballOwner;\r\n        if (ballOwner != null) {\r\n            ballOwner.setHasBall(true);\r\n        }\r\n        // fireModelChanged();\r\n    }\r\n\r\n    public void startAnimation(boolean onlyActualSequence) {\r\n        setState(State.ANIMATION_RUNNING);\r\n        MoveEvent event = actualEvent;\r\n        if (event == null) {\r\n            event = getEvents().get(0);\r\n        }\r\n        setActualMoveEvent(event);\r\n        animationSequenz = event.getSequenceNr();\r\n        animationModel = new AnimationModel(event, this, onlyActualSequence);\r\n        runningAnimator = new Animator(this);\r\n        computePlayerPositions(animationSequenz);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void pauseAnimation(boolean pause) {\r\n        if (pause) {\r\n            runningAnimator.setPause(true);\r\n        } else {\r\n            runningAnimator.setPause(false);\r\n        }\r\n    }\r\n\r\n    public void initAnimation() {\r\n    }\r\n\r\n    public boolean nextAnimationStep() {\r\n        boolean finished = animationModel.nextStep();\r\n        if (finished) {\r\n            if (animationModel.isOnlyOneSequence()) {\r\n                setState(State.ANIMATION);\r\n                // n�chste Sequzenz ausw�hlen (einfaches sequentielles Anschauen des Spielzugs)\r\n                int nextSeq = (getAcutalSequenceNr() == getHighestSequenceNumber()) ? getAcutalSequenceNr() : getAcutalSequenceNr() + 1;\r\n                List<MoveEvent> nextSeqEvents = getMoveEvents(nextSeq);\r\n                if (nextSeqEvents.get(0) != null) {\r\n                    setActualMoveEvent(nextSeqEvents.get(0));\r\n                }\r\n            } else {\r\n                setState(State.FULL_ANIMATION_ENDED);\r\n            }\r\n        } else {\r\n            fireModelChanged();\r\n        }\r\n        return finished;\r\n    }\r\n\r\n    public void stopAnimation() {\r\n        setState(State.ANIMATION);\r\n        runningAnimator = null;\r\n        setActualMoveEvent(getActualMoveEvent());\r\n    }\r\n\r\n    public boolean isMarkedPlayerAddable() {\r\n        int seq = getAcutalSequenceNr();\r\n        return !events.contains(new MoveEvent(markedPlayer, seq));\r\n    }\r\n\r\n    public boolean passEventDefined(int seq) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() == seq && event instanceof PassEvent) {\r\n                defined = true;\r\n                break;\r\n            }\r\n            if (event.getSequenceNr() > seq) {\r\n                break;\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public boolean passEventDefined() {\r\n        return passEventDefined(getAcutalSequenceNr());\r\n    }\r\n\r\n    public boolean passEventDefinedAfter(int seq) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if ((event instanceof PassEvent) && (event.getSequenceNr() > seq)) {\r\n                defined = true;\r\n                break;\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public boolean eventDefinedAfter(int seq) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() > seq) {\r\n                defined = true;\r\n                break;\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public Ball getBall() {\r\n        return ball;\r\n    }\r\n\r\n    public void setFirstBallOwner(Offender offender) {\r\n        this.firstBallOwner = offender;\r\n        setBallOwner(offender);\r\n        if (firstBallOwner == null) {\r\n            resetBallPosition();\r\n        }\r\n    }\r\n\r\n    public Offender getFirstBallOwner() {\r\n        return firstBallOwner;\r\n    }\r\n\r\n    public boolean hasPlayerBallInNextSequence(Player player) {\r\n        PassEvent pass = null;\r\n        int seq = getAcutalSequenceNr();\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() == seq && event instanceof PassEvent) {\r\n                pass = (PassEvent) event;\r\n                break;\r\n            }\r\n            if (event.getSequenceNr() > seq) {\r\n                break;\r\n            }\r\n        }\r\n        if (pass != null && pass.getDestinationPlayer() != null) {\r\n            return pass.getDestinationPlayer().equals(player) && !passEventDefined(seq + 1);\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public boolean isBallSet() {\r\n        return ballOwner != null;\r\n    }\r\n\r\n    public boolean isGoalPassSet() {\r\n        boolean defined = false;\r\n        for (MoveEvent event : getEvents()) {\r\n            if (event instanceof PassEvent) {\r\n                PassEvent pass = (PassEvent) event;\r\n                if (pass.isGoalPass()) {\r\n                    defined = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public void moveBallTo(int x, int y) {\r\n        ball.setCurrent_x(x);\r\n        ball.setCurrent_y(y);\r\n    }\r\n\r\n    public List<MoveEvent> getActualMoveEvents() {\r\n        return getMoveEvents(getAcutalSequenceNr());\r\n    }\r\n\r\n    public List<MoveEvent> getMoveEvents(int sequenceNr) {\r\n        List<MoveEvent> sequenceEvents = new ArrayList<MoveEvent>();\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() == sequenceNr) {\r\n                sequenceEvents.add(event);\r\n            } else if (event.getSequenceNr() > getAcutalSequenceNr()) {\r\n                break;\r\n            }\r\n        }\r\n        return sequenceEvents;\r\n    }\r\n\r\n    /**\r\n     * Löscht das Aktuelle Ereignis und ALLE Folgenden\r\n     */\r\n    public void removeEventsAfter() {\r\n        MoveEvent event = getActualMoveEvent();\r\n        List<MoveEvent> toDeleteEvents = new ArrayList<MoveEvent>();\r\n        int sequenceNr = event.getSequenceNr();\r\n        // zu loeschende Events sammeln\r\n        for (MoveEvent evt : getEvents()) {\r\n            if (evt.getSequenceNr() > sequenceNr) {\r\n                // Event ist hoeher, also loeschen\r\n                toDeleteEvents.add(evt);\r\n            }\r\n        }\r\n        toDeleteEvents.add(event);\r\n        // gesammelte Events loeschen\r\n        for (MoveEvent deleteEvent : toDeleteEvents) {\r\n            removeMoveEvent(deleteEvent);\r\n        }\r\n        setActualMoveEvent((getEvents().size() > 0) ? getEvents().get(getEvents().size() - 1) : null);\r\n        fireModelChanged();\r\n    }\r\n\r\n    /**\r\n     * Löscht die Ereignisse (auch P�sse) des �bergebenen Spielers. Und die\r\n     * evtl. davon abh�ngigen Folgep�sse\r\n     *\r\n     * @param player\r\n     */\r\n    private void removeEventsOfPlayer(Player player) {\r\n        List<MoveEvent> toDeleteEvents = new ArrayList<MoveEvent>();\r\n        boolean playerInvolved = false;\r\n        // zu loeschende Events sammeln\r\n        for (MoveEvent evt : getEvents()) {\r\n            // Pass?\r\n            if (evt instanceof PassEvent) {\r\n                PassEvent pass = (PassEvent) evt;\r\n                // War ein Pass zu dem Spieler? oder Spieler passt selbst?\r\n                if (pass.getDestinationPlayer().equals(player) || pass.getPlayer().equals(player)) {\r\n                    playerInvolved = true;\r\n                }\r\n                // War Spieler an einem Pass beteiligt?\r\n                if (playerInvolved) {\r\n                    toDeleteEvents.add(pass);\r\n                    continue;\r\n                }\r\n            }\r\n            if (evt.getPlayer().equals(player)) {\r\n                toDeleteEvents.add(evt);\r\n            }\r\n        }\r\n        // gesammelte Events loeschen\r\n        for (MoveEvent deleteEvent : toDeleteEvents) {\r\n            removeMoveEvent(deleteEvent);\r\n        }\r\n        setActualMoveEvent((getEvents().size() > 0) ? getEvents().get(getEvents().size() - 1) : null);\r\n    }\r\n\r\n    public boolean eventDefinedWithPlayer(Player player) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if (event.getPlayer().equals(player)) {\r\n                defined = true;\r\n                break;\r\n            }\r\n            if (event instanceof PassEvent) {\r\n                PassEvent pass = (PassEvent) event;\r\n                if (pass.getDestinationPlayer().equals(player)) {\r\n                    defined = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public int getHighestSequenceNumber() {\r\n        if (events.size() == 0) {\r\n            return 0;\r\n        } else {\r\n            return events.last().getSequenceNr();\r\n        }\r\n    }\r\n\r\n    public String getMoveName() {\r\n        return moveName;\r\n    }\r\n\r\n    public void setMoveName(String moveName) {\r\n        this.moveName = moveName;\r\n        if (Main.getWindow() != null) {\r\n            StringBuffer buffer = new StringBuffer(APP_NAME);\r\n            buffer.append(\" - \");\r\n            if (moveName == null || moveName.equals(\"\")) {\r\n                buffer.append(\"Unbenannt\");\r\n                // Titelleiste aktualisieren\r\n            } else {\r\n                buffer.append(moveName);\r\n            }\r\n            if (!isSaved()) {\r\n                buffer.append(\"*\");\r\n            }\r\n            Main.getWindow().setTitle(buffer.toString());\r\n        }\r\n    }\r\n\r\n    public String getComment() {\r\n        if (comment == null) {\r\n            comment = \"\";\r\n        }\r\n        return comment;\r\n    }\r\n\r\n    public void setComment(String comment) {\r\n        this.comment = comment;\r\n        fireModelChanged();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/model/HandballModelTest3.java",
		"test_prompt": "// HandballModelTest3.java\npackage visu.handball.moves.model;\n\nimport java.awt.geom.Point2D;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\nimport javax.swing.JOptionPane;\nimport visu.handball.moves.Main;\nimport visu.handball.moves.model.animation.AnimationModel;\nimport visu.handball.moves.model.animation.Animator;\nimport visu.handball.moves.model.player.Ball;\nimport visu.handball.moves.model.player.Defender;\nimport visu.handball.moves.model.player.HighlightableItem;\nimport visu.handball.moves.model.player.MovePoint;\nimport visu.handball.moves.model.player.Offender;\nimport visu.handball.moves.model.player.Player;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HandballModel}.\n* It contains ten unit test cases for the {@link HandballModel#removePlayerRemovedListener(PlayerRemovedListener)} method.\n*/\nclass HandballModelTest3 {"
	},
	{
		"original_code": "// HandballModel.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.model;\r\n\r\nimport java.awt.geom.Point2D;\r\nimport java.io.Serializable;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.SortedSet;\r\nimport java.util.TreeSet;\r\nimport javax.swing.JOptionPane;\r\nimport visu.handball.moves.Main;\r\nimport visu.handball.moves.model.animation.AnimationModel;\r\nimport visu.handball.moves.model.animation.Animator;\r\nimport visu.handball.moves.model.player.Ball;\r\nimport visu.handball.moves.model.player.Defender;\r\nimport visu.handball.moves.model.player.HighlightableItem;\r\nimport visu.handball.moves.model.player.MovePoint;\r\nimport visu.handball.moves.model.player.Offender;\r\nimport visu.handball.moves.model.player.Player;\r\n\r\npublic class HandballModel implements Serializable {\r\n\r\n    private static final long serialVersionUID = -5372891552466311536L;\r\n\r\n    public enum State {\r\n\r\n        INITIAL,\r\n        PLACE_OFFENDERS,\r\n        PLACE_DEFENDERS,\r\n        PLACE_BALL,\r\n        EDIT,\r\n        EDIT_EVENT,\r\n        ANIMATION,\r\n        ANIMATION_RUNNING,\r\n        FULL_ANIMATION_ENDED\r\n    }\r\n\r\n    private static final int MAX_OFFENDERS = 6;\r\n\r\n    private static final int MAX_DEFENDERS = 6;\r\n\r\n    private static final int MARK_RADIUS = 12;\r\n\r\n    private static final String APP_NAME = \"jHandballMoves\";\r\n\r\n    private transient List<HandballModelListener> listeners;\r\n\r\n    private transient List<PlayerRemovedListener> playerRemoveListener;\r\n\r\n    private List<Defender> defenders;\r\n\r\n    private List<Offender> offenders;\r\n\r\n    private SortedSet<MoveEvent> events;\r\n\r\n    private State state;\r\n\r\n    private MoveEvent actualEvent;\r\n\r\n    private Player markedPlayer;\r\n\r\n    private HighlightableItem hightlightedItem;\r\n\r\n    private Offender ballOwner;\r\n\r\n    private Ball ball;\r\n\r\n    private Offender firstBallOwner;\r\n\r\n    private transient Animator runningAnimator;\r\n\r\n    private int animationSequenz;\r\n\r\n    private transient AnimationModel animationModel;\r\n\r\n    private transient HandballModel lastSavedModel;\r\n\r\n    private String comment;\r\n\r\n    private String moveName;\r\n\r\n    public HandballModel() {\r\n        listeners = new ArrayList<HandballModelListener>();\r\n        playerRemoveListener = new ArrayList<PlayerRemovedListener>();\r\n        initModel();\r\n    }\r\n\r\n    public void initModel() {\r\n        defenders = new ArrayList<Defender>();\r\n        Defender.setCounter(0);\r\n        offenders = new ArrayList<Offender>();\r\n        Offender.setCounter(0);\r\n        events = new TreeSet<MoveEvent>();\r\n        // Workaround wegen ToolBar\r\n        state = State.PLACE_OFFENDERS;\r\n        actualEvent = null;\r\n        markedPlayer = null;\r\n        firstBallOwner = null;\r\n        comment = \"\";\r\n        moveName = \"\";\r\n        resetBallPosition();\r\n        try {\r\n            lastSavedModel = (HandballModel) Main.deepCopy(this);\r\n        } catch (Exception e) {\r\n            lastSavedModel = null;\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    private void resetBallPosition() {\r\n        ball = new Ball(-500, -500);\r\n    }\r\n\r\n    public void addOffender(int x, int y) {\r\n        if (offenders.size() == MAX_OFFENDERS) {\r\n            JOptionPane.showMessageDialog(Main.getWindow(), \"Sie haben schon \" + MAX_OFFENDERS + \" Angreifer angelegt.\", \"Info:\", JOptionPane.INFORMATION_MESSAGE);\r\n        } else {\r\n            offenders.add(new Offender(x, y));\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void removePlayer(Player toRemove) {\r\n        if (eventDefinedWithPlayer(toRemove)) {\r\n            removeEventsOfPlayer(toRemove);\r\n        }\r\n        if (toRemove instanceof Offender) {\r\n            removeOffender((Offender) toRemove);\r\n        } else {\r\n            removeDefender((Defender) toRemove);\r\n        }\r\n    }\r\n\r\n    private void removeOffender(Offender toRemove) {\r\n        if (getFirstBallOwner() != null && getFirstBallOwner().equals(toRemove)) {\r\n            setFirstBallOwner(null);\r\n        }\r\n        offenders.remove(toRemove);\r\n        if ((getDefenders().size() + getOffenders().size()) == 0) {\r\n            markedPlayer = null;\r\n        }\r\n        // Spielernummer aktualisieren\r\n        Offender.setCounter(determineMaxPlayerNumber(offenders));\r\n        fireOffenderRemoved(toRemove);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void addDefender(int x, int y) {\r\n        if (defenders.size() == MAX_DEFENDERS) {\r\n            JOptionPane.showMessageDialog(Main.getWindow(), \"Sie haben schon \" + MAX_OFFENDERS + \" Verteidiger angelegt.\", \"Info:\", JOptionPane.INFORMATION_MESSAGE);\r\n        } else {\r\n            defenders.add(new Defender(x, y));\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    private void removeDefender(Defender toRemove) {\r\n        defenders.remove(toRemove);\r\n        if ((getDefenders().size() + getOffenders().size()) == 0) {\r\n            markedPlayer = null;\r\n        }\r\n        Defender.setCounter(determineMaxPlayerNumber(defenders));\r\n        fireDefenderRemoved(toRemove);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public boolean addListener(HandballModelListener o) {\r\n        return listeners.add(o);\r\n    }\r\n\r\n    public boolean removeListener(HandballModelListener o) {\r\n        return listeners.remove(o);\r\n    }\r\n\r\n    public boolean addPlayerRemovedListener(PlayerRemovedListener o) {\r\n        return playerRemoveListener.add(o);\r\n    }\r\n\r\n    public boolean removePlayerRemovedListener(PlayerRemovedListener o) {\r\n        return playerRemoveListener.remove(o);\r\n    }\r\n\r\n    private void fireModelChanged() {\r\n        setMoveName(getMoveName());\r\n        for (HandballModelListener listener : listeners) {\r\n            listener.modelChanged();\r\n        }\r\n    }\r\n\r\n    private void fireOffenderRemoved(Offender offender) {\r\n        for (PlayerRemovedListener listener : playerRemoveListener) {\r\n            listener.offenderRemoved(offender);\r\n        }\r\n    }\r\n\r\n    private void fireDefenderRemoved(Defender defender) {\r\n        for (PlayerRemovedListener listener : playerRemoveListener) {\r\n            listener.defenderRemoved(defender);\r\n        }\r\n    }\r\n\r\n    public List<Defender> getDefenders() {\r\n        return defenders;\r\n    }\r\n\r\n    public List<Offender> getOffenders() {\r\n        return offenders;\r\n    }\r\n\r\n    public State getState() {\r\n        return state;\r\n    }\r\n\r\n    public void setState(State state) {\r\n        if (state == State.EDIT) {\r\n            if (getActualMoveEvent() == null) {\r\n                // Wenn leer, dann Null, sonst letztes Move Event setzen\r\n                setActualMoveEvent(getEvents().isEmpty() ? null : (getEvents().get(getEvents().size() - 1)));\r\n            } else {\r\n                setActualMoveEvent(getActualMoveEvent());\r\n            }\r\n        }\r\n        if (state == State.PLACE_DEFENDERS || state == State.PLACE_OFFENDERS) {\r\n            if (getFirstBallOwner() != null) {\r\n                setBallOwner(getFirstBallOwner());\r\n            }\r\n            setActualMoveEvent(null);\r\n        }\r\n        this.state = state;\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void addMoveEvent(MoveEvent event) {\r\n        events.add(event);\r\n        if (state == State.EDIT) {\r\n            setActualMoveEvent(event);\r\n            state = State.EDIT_EVENT;\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void removeMoveEvent(MoveEvent event) {\r\n        events.remove(event);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public List<MoveEvent> getEvents() {\r\n        List<MoveEvent> list = new ArrayList<MoveEvent>(events);\r\n        return list;\r\n    }\r\n\r\n    public SortedSet<MoveEvent> getSortedEvents() {\r\n        return events;\r\n    }\r\n\r\n    public int getAcutalSequenceNr() {\r\n        if (actualEvent == null)\r\n            return 0;\r\n        else {\r\n            return actualEvent.getSequenceNr();\r\n        }\r\n    }\r\n\r\n    public void setActualMoveEvent(MoveEvent event) {\r\n        if (this.actualEvent != null) {\r\n            this.actualEvent.setMarked(false);\r\n        }\r\n        this.actualEvent = event;\r\n        computePlayerPositions();\r\n        // aktuellen Spieler setzen\r\n        setMarkedPlayer((event == null) ? null : event.getPlayer());\r\n        if (actualEvent != null) {\r\n            if (!actualEvent.isDestinationPointSet()) {\r\n                state = State.EDIT_EVENT;\r\n            } else {\r\n                if (state == State.FULL_ANIMATION_ENDED) {\r\n                    state = State.ANIMATION;\r\n                } else if (state != State.ANIMATION && state != State.ANIMATION_RUNNING) {\r\n                    state = State.EDIT;\r\n                }\r\n            }\r\n            actualEvent.setMarked(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setDestinationPointForEvent(MoveEvent event, int x, int y, boolean temp) {\r\n        event.setDestinationPoint(x, y, temp);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setControlPointForEvent(MoveEvent event, int x, int y, boolean temp) {\r\n        event.setControlPoint(x, y, temp);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setMovePointTo(MovePoint point, int x, int y) {\r\n        actualEvent.setPoint(point, x, y);\r\n        fireModelChanged();\r\n    }\r\n\r\n    private void computePlayerPositions() {\r\n        computePlayerPositions(getAcutalSequenceNr());\r\n    }\r\n\r\n    public void computePlayerPositions(int seqNr) {\r\n        // Spieler Positionen auf Ausgangsstellung\r\n        for (Player offender : offenders) {\r\n            offender.resetPosition();\r\n        }\r\n        for (Player defender : defenders) {\r\n            defender.resetPosition();\r\n        }\r\n        if (seqNr == 1) {\r\n            setBallOwner(firstBallOwner);\r\n        }\r\n        // alle Events mit kleinerer Sequenznummer verarbeiten\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() < seqNr) {\r\n                if (event instanceof PassEvent) {\r\n                    // Ball an anderen Spieler �bertragen\r\n                    setBallOwner(((PassEvent) event).getDestinationPlayer());\r\n                } else {\r\n                    if (event.getDestinationX() > -1 && event.getDestinationY() > -1) {\r\n                        event.getPlayer().setCurrentPosition(event.getDestinationX(), event.getDestinationY());\r\n                    }\r\n                }\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    public MoveEvent getActualMoveEvent() {\r\n        return actualEvent;\r\n    }\r\n\r\n    public Player getMarkedPlayer() {\r\n        return markedPlayer;\r\n    }\r\n\r\n    public void setMarkedPlayer(Player markedPlayer) {\r\n        // alten markierten Spieler demarkieren\r\n        if (this.markedPlayer != null) {\r\n            this.markedPlayer.setMarked(false);\r\n        }\r\n        // evtl. neuen Spieler markieren\r\n        this.markedPlayer = markedPlayer;\r\n        if (markedPlayer != null) {\r\n            markedPlayer.setMarked(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setHighLightedItem(HighlightableItem item) {\r\n        if (this.hightlightedItem != null) {\r\n            // altes Item zur�cksetzen\r\n            this.hightlightedItem.setHighlight(false);\r\n        }\r\n        this.hightlightedItem = item;\r\n        if (item != null) {\r\n            hightlightedItem.setHighlight(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public HighlightableItem getHightligtedItem() {\r\n        return hightlightedItem;\r\n    }\r\n\r\n    public Player getNearestPlayer(int x, int y) {\r\n        List<Player> all = new ArrayList<Player>(offenders);\r\n        all.addAll(defenders);\r\n        return findNearestPlayer(x, y, all);\r\n    }\r\n\r\n    public Offender getNearestOffender(int x, int y) {\r\n        List<Player> all = new ArrayList<Player>(offenders);\r\n        return (Offender) findNearestPlayer(x, y, all);\r\n    }\r\n\r\n    private Player findNearestPlayer(int x, int y, List<Player> players) {\r\n        double entfernung = Double.MAX_VALUE;\r\n        Player temp = null;\r\n        for (Player player : players) {\r\n            int player_x = player.getCurrent_x();\r\n            int player_y = player.getCurrent_y();\r\n            double tempEntfernung = Point2D.distance(x, y, player_x, player_y);\r\n            // Wenn naeher als der MARK_RADIUS\r\n            if (!(tempEntfernung > MARK_RADIUS)) {\r\n                if (tempEntfernung < entfernung) {\r\n                    temp = player;\r\n                    entfernung = tempEntfernung;\r\n                }\r\n            }\r\n        }\r\n        return temp;\r\n    }\r\n\r\n    public MovePoint getNearestMovePoint(int x, int y) {\r\n        MovePoint point = null;\r\n        if (actualEvent != null) {\r\n            double entfernung = Double.MAX_VALUE;\r\n            if (actualEvent.isDestinationPointSet()) {\r\n                int destination_x = actualEvent.getDestinationX();\r\n                int destination_y = actualEvent.getDestinationY();\r\n                double tempEntfernung = Point2D.distance(x, y, destination_x, destination_y);\r\n                // Wenn naeher als der MARK_RADIUS\r\n                if (!(tempEntfernung > MARK_RADIUS)) {\r\n                    if (tempEntfernung < entfernung) {\r\n                        point = actualEvent.getDestinationPoint();\r\n                        entfernung = tempEntfernung;\r\n                    }\r\n                }\r\n            }\r\n            if (actualEvent.isControlPointSet()) {\r\n                int controlPoint_x = actualEvent.getControlPointX();\r\n                int controlPoint_y = actualEvent.getControlPointY();\r\n                double tempEntfernung = Point2D.distance(x, y, controlPoint_x, controlPoint_y);\r\n                // Wenn naeher als der MARK_RADIUS\r\n                if (!(tempEntfernung > MARK_RADIUS)) {\r\n                    if (tempEntfernung < entfernung) {\r\n                        point = actualEvent.getControlPoint();\r\n                        entfernung = tempEntfernung;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return point;\r\n    }\r\n\r\n    public HighlightableItem getNearestHighlightableItem(int x, int y) {\r\n        HighlightableItem temp = null;\r\n        temp = getNearestMovePoint(x, y);\r\n        if (temp == null) {\r\n            temp = getNearestPlayer(x, y);\r\n        }\r\n        return temp;\r\n    }\r\n\r\n    public void movePlayerTo(Player actualPlayer, int x, int y) {\r\n        if (getAcutalSequenceNr() == 0) {\r\n            actualPlayer.setStart_x(x);\r\n            actualPlayer.setStart_y(y);\r\n        }\r\n        // Ansonsten muss die Position im entsprechenden Ereignis gesetzt\r\n        // werden\r\n        // Startposition darf nur im Angreifer/Verteidiger-Modus ge�ndert werden\r\n        fireModelChanged();\r\n    }\r\n\r\n    public boolean isSaved() {\r\n        boolean changed = false;\r\n        if (lastSavedModel != null) {\r\n            //Spielzugnamen vergleichen\r\n            if (lastSavedModel.getMoveName() != null) {\r\n                if (getMoveName() == null || !lastSavedModel.getMoveName().equals(getMoveName())) {\r\n                    return false;\r\n                }\r\n            } else if (getMoveName() != null) {\r\n                //alt: kein Name <-> neu: Name vorhanden\r\n                return false;\r\n            }\r\n            //Ueberprüfen ob Angreifer und Verteidiger unterschiedlich\r\n            // zuerst Spielerlisten vergleichen\r\n            if (changedPlayerList(getOffenders().toArray(new Player[getOffenders().size()]), lastSavedModel.getOffenders().toArray(new Player[lastSavedModel.getOffenders().size()])) || changedPlayerList(getDefenders().toArray(new Player[getDefenders().size()]), lastSavedModel.getDefenders().toArray(new Player[lastSavedModel.getDefenders().size()]))) {\r\n                changed = true;\r\n            } else {\r\n                List<MoveEvent> newEvents = getEvents();\r\n                List<MoveEvent> oldEvents = lastSavedModel.getEvents();\r\n                if (newEvents.size() == oldEvents.size()) {\r\n                    for (int i = 0; i < newEvents.size(); i++) {\r\n                        if (!newEvents.get(i).equals(oldEvents.get(i))) {\r\n                            changed = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                } else {\r\n                    changed = true;\r\n                }\r\n            }\r\n            if (!changed && (getFirstBallOwner() != null || lastSavedModel.getFirstBallOwner() != null)) {\r\n                changed = (getFirstBallOwner() == null) ^ (lastSavedModel.getFirstBallOwner() == null);\r\n                if (!changed) {\r\n                    changed = !getFirstBallOwner().equals(lastSavedModel.getFirstBallOwner());\r\n                }\r\n            }\r\n            // wurde Kommentar geändert?\r\n            if (!changed) {\r\n                if (comment == null || comment.equals(\"\")) {\r\n                    if (lastSavedModel.getComment() != null && !lastSavedModel.getComment().equals(\"\")) {\r\n                        changed = true;\r\n                    }\r\n                } else if (lastSavedModel.getComment() != null) {\r\n                    if (!lastSavedModel.getComment().equals(comment)) {\r\n                        changed = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return !changed;\r\n    }\r\n\r\n    private boolean changedPlayerList(Player[] newList, Player[] oldList) {\r\n        boolean changed = false;\r\n        int size = newList.length;\r\n        int sizeOld = oldList.length;\r\n        if (size == sizeOld) {\r\n            for (int i = 0; i < size; i++) {\r\n                if (!newList[i].equals(oldList[i])) {\r\n                    changed = true;\r\n                    break;\r\n                }\r\n            }\r\n        } else {\r\n            changed = true;\r\n        }\r\n        return changed;\r\n    }\r\n\r\n    public void initWithLoadedModel(HandballModel loadedModel) {\r\n        initModel();\r\n        offenders = loadedModel.getOffenders();\r\n        defenders = loadedModel.getDefenders();\r\n        events = loadedModel.getSortedEvents();\r\n        Offender.setCounter(determineMaxPlayerNumber(offenders));\r\n        Defender.setCounter(determineMaxPlayerNumber(defenders));\r\n        setFirstBallOwner(loadedModel.getFirstBallOwner());\r\n        setState(loadedModel.getState());\r\n        setActualMoveEvent(loadedModel.getActualMoveEvent());\r\n        setComment(loadedModel.getComment());\r\n        // zur Sicherheit\r\n        if (getComment() == null) {\r\n            setComment(\"\");\r\n        }\r\n        setMoveName(loadedModel.getMoveName());\r\n        markAsSaved(loadedModel);\r\n        fireModelChanged();\r\n    }\r\n\r\n    private int determineMaxPlayerNumber(List players) {\r\n        int max = 0;\r\n        for (Object o : players) {\r\n            if (o instanceof Player) {\r\n                Player player = (Player) o;\r\n                if (player.getPlayerNumber() > max) {\r\n                    max = player.getPlayerNumber();\r\n                }\r\n            }\r\n        }\r\n        return max;\r\n    }\r\n\r\n    public void markAsSaved(HandballModel model) {\r\n        try {\r\n            lastSavedModel = (HandballModel) Main.deepCopy(model);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            lastSavedModel = null;\r\n        }\r\n    }\r\n\r\n    public void setDelay(int eventIndex, int delay) {\r\n        getEvents().get(eventIndex).setDelay(delay);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setBallOwner(Offender ballOwner) {\r\n        if (this.ballOwner != null) {\r\n            this.ballOwner.setHasBall(false);\r\n        }\r\n        this.ballOwner = ballOwner;\r\n        if (ballOwner != null) {\r\n            ballOwner.setHasBall(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setBallOwnerSilent(Offender ballOwner) {\r\n        if (this.ballOwner != null) {\r\n            this.ballOwner.setHasBall(false);\r\n        }\r\n        this.ballOwner = ballOwner;\r\n        if (ballOwner != null) {\r\n            ballOwner.setHasBall(true);\r\n        }\r\n        // fireModelChanged();\r\n    }\r\n\r\n    public void startAnimation(boolean onlyActualSequence) {\r\n        setState(State.ANIMATION_RUNNING);\r\n        MoveEvent event = actualEvent;\r\n        if (event == null) {\r\n            event = getEvents().get(0);\r\n        }\r\n        setActualMoveEvent(event);\r\n        animationSequenz = event.getSequenceNr();\r\n        animationModel = new AnimationModel(event, this, onlyActualSequence);\r\n        runningAnimator = new Animator(this);\r\n        computePlayerPositions(animationSequenz);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void pauseAnimation(boolean pause) {\r\n        if (pause) {\r\n            runningAnimator.setPause(true);\r\n        } else {\r\n            runningAnimator.setPause(false);\r\n        }\r\n    }\r\n\r\n    public void initAnimation() {\r\n    }\r\n\r\n    public boolean nextAnimationStep() {\r\n        boolean finished = animationModel.nextStep();\r\n        if (finished) {\r\n            if (animationModel.isOnlyOneSequence()) {\r\n                setState(State.ANIMATION);\r\n                // n�chste Sequzenz ausw�hlen (einfaches sequentielles Anschauen des Spielzugs)\r\n                int nextSeq = (getAcutalSequenceNr() == getHighestSequenceNumber()) ? getAcutalSequenceNr() : getAcutalSequenceNr() + 1;\r\n                List<MoveEvent> nextSeqEvents = getMoveEvents(nextSeq);\r\n                if (nextSeqEvents.get(0) != null) {\r\n                    setActualMoveEvent(nextSeqEvents.get(0));\r\n                }\r\n            } else {\r\n                setState(State.FULL_ANIMATION_ENDED);\r\n            }\r\n        } else {\r\n            fireModelChanged();\r\n        }\r\n        return finished;\r\n    }\r\n\r\n    public void stopAnimation() {\r\n        setState(State.ANIMATION);\r\n        runningAnimator = null;\r\n        setActualMoveEvent(getActualMoveEvent());\r\n    }\r\n\r\n    public boolean isMarkedPlayerAddable() {\r\n        int seq = getAcutalSequenceNr();\r\n        return !events.contains(new MoveEvent(markedPlayer, seq));\r\n    }\r\n\r\n    public boolean passEventDefined(int seq) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() == seq && event instanceof PassEvent) {\r\n                defined = true;\r\n                break;\r\n            }\r\n            if (event.getSequenceNr() > seq) {\r\n                break;\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public boolean passEventDefined() {\r\n        return passEventDefined(getAcutalSequenceNr());\r\n    }\r\n\r\n    public boolean passEventDefinedAfter(int seq) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if ((event instanceof PassEvent) && (event.getSequenceNr() > seq)) {\r\n                defined = true;\r\n                break;\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public boolean eventDefinedAfter(int seq) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() > seq) {\r\n                defined = true;\r\n                break;\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public Ball getBall() {\r\n        return ball;\r\n    }\r\n\r\n    public void setFirstBallOwner(Offender offender) {\r\n        this.firstBallOwner = offender;\r\n        setBallOwner(offender);\r\n        if (firstBallOwner == null) {\r\n            resetBallPosition();\r\n        }\r\n    }\r\n\r\n    public Offender getFirstBallOwner() {\r\n        return firstBallOwner;\r\n    }\r\n\r\n    public boolean hasPlayerBallInNextSequence(Player player) {\r\n        PassEvent pass = null;\r\n        int seq = getAcutalSequenceNr();\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() == seq && event instanceof PassEvent) {\r\n                pass = (PassEvent) event;\r\n                break;\r\n            }\r\n            if (event.getSequenceNr() > seq) {\r\n                break;\r\n            }\r\n        }\r\n        if (pass != null && pass.getDestinationPlayer() != null) {\r\n            return pass.getDestinationPlayer().equals(player) && !passEventDefined(seq + 1);\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public boolean isBallSet() {\r\n        return ballOwner != null;\r\n    }\r\n\r\n    public boolean isGoalPassSet() {\r\n        boolean defined = false;\r\n        for (MoveEvent event : getEvents()) {\r\n            if (event instanceof PassEvent) {\r\n                PassEvent pass = (PassEvent) event;\r\n                if (pass.isGoalPass()) {\r\n                    defined = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public void moveBallTo(int x, int y) {\r\n        ball.setCurrent_x(x);\r\n        ball.setCurrent_y(y);\r\n    }\r\n\r\n    public List<MoveEvent> getActualMoveEvents() {\r\n        return getMoveEvents(getAcutalSequenceNr());\r\n    }\r\n\r\n    public List<MoveEvent> getMoveEvents(int sequenceNr) {\r\n        List<MoveEvent> sequenceEvents = new ArrayList<MoveEvent>();\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() == sequenceNr) {\r\n                sequenceEvents.add(event);\r\n            } else if (event.getSequenceNr() > getAcutalSequenceNr()) {\r\n                break;\r\n            }\r\n        }\r\n        return sequenceEvents;\r\n    }\r\n\r\n    /**\r\n     * Löscht das Aktuelle Ereignis und ALLE Folgenden\r\n     */\r\n    public void removeEventsAfter() {\r\n        MoveEvent event = getActualMoveEvent();\r\n        List<MoveEvent> toDeleteEvents = new ArrayList<MoveEvent>();\r\n        int sequenceNr = event.getSequenceNr();\r\n        // zu loeschende Events sammeln\r\n        for (MoveEvent evt : getEvents()) {\r\n            if (evt.getSequenceNr() > sequenceNr) {\r\n                // Event ist hoeher, also loeschen\r\n                toDeleteEvents.add(evt);\r\n            }\r\n        }\r\n        toDeleteEvents.add(event);\r\n        // gesammelte Events loeschen\r\n        for (MoveEvent deleteEvent : toDeleteEvents) {\r\n            removeMoveEvent(deleteEvent);\r\n        }\r\n        setActualMoveEvent((getEvents().size() > 0) ? getEvents().get(getEvents().size() - 1) : null);\r\n        fireModelChanged();\r\n    }\r\n\r\n    /**\r\n     * Löscht die Ereignisse (auch P�sse) des �bergebenen Spielers. Und die\r\n     * evtl. davon abh�ngigen Folgep�sse\r\n     *\r\n     * @param player\r\n     */\r\n    private void removeEventsOfPlayer(Player player) {\r\n        List<MoveEvent> toDeleteEvents = new ArrayList<MoveEvent>();\r\n        boolean playerInvolved = false;\r\n        // zu loeschende Events sammeln\r\n        for (MoveEvent evt : getEvents()) {\r\n            // Pass?\r\n            if (evt instanceof PassEvent) {\r\n                PassEvent pass = (PassEvent) evt;\r\n                // War ein Pass zu dem Spieler? oder Spieler passt selbst?\r\n                if (pass.getDestinationPlayer().equals(player) || pass.getPlayer().equals(player)) {\r\n                    playerInvolved = true;\r\n                }\r\n                // War Spieler an einem Pass beteiligt?\r\n                if (playerInvolved) {\r\n                    toDeleteEvents.add(pass);\r\n                    continue;\r\n                }\r\n            }\r\n            if (evt.getPlayer().equals(player)) {\r\n                toDeleteEvents.add(evt);\r\n            }\r\n        }\r\n        // gesammelte Events loeschen\r\n        for (MoveEvent deleteEvent : toDeleteEvents) {\r\n            removeMoveEvent(deleteEvent);\r\n        }\r\n        setActualMoveEvent((getEvents().size() > 0) ? getEvents().get(getEvents().size() - 1) : null);\r\n    }\r\n\r\n    public boolean eventDefinedWithPlayer(Player player) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if (event.getPlayer().equals(player)) {\r\n                defined = true;\r\n                break;\r\n            }\r\n            if (event instanceof PassEvent) {\r\n                PassEvent pass = (PassEvent) event;\r\n                if (pass.getDestinationPlayer().equals(player)) {\r\n                    defined = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public int getHighestSequenceNumber() {\r\n        if (events.size() == 0) {\r\n            return 0;\r\n        } else {\r\n            return events.last().getSequenceNr();\r\n        }\r\n    }\r\n\r\n    public String getMoveName() {\r\n        return moveName;\r\n    }\r\n\r\n    public void setMoveName(String moveName) {\r\n        this.moveName = moveName;\r\n        if (Main.getWindow() != null) {\r\n            StringBuffer buffer = new StringBuffer(APP_NAME);\r\n            buffer.append(\" - \");\r\n            if (moveName == null || moveName.equals(\"\")) {\r\n                buffer.append(\"Unbenannt\");\r\n                // Titelleiste aktualisieren\r\n            } else {\r\n                buffer.append(moveName);\r\n            }\r\n            if (!isSaved()) {\r\n                buffer.append(\"*\");\r\n            }\r\n            Main.getWindow().setTitle(buffer.toString());\r\n        }\r\n    }\r\n\r\n    public String getComment() {\r\n        if (comment == null) {\r\n            comment = \"\";\r\n        }\r\n        return comment;\r\n    }\r\n\r\n    public void setComment(String comment) {\r\n        this.comment = comment;\r\n        fireModelChanged();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/model/HandballModelTest4.java",
		"test_prompt": "// HandballModelTest4.java\npackage visu.handball.moves.model;\n\nimport java.awt.geom.Point2D;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\nimport javax.swing.JOptionPane;\nimport visu.handball.moves.Main;\nimport visu.handball.moves.model.animation.AnimationModel;\nimport visu.handball.moves.model.animation.Animator;\nimport visu.handball.moves.model.player.Ball;\nimport visu.handball.moves.model.player.Defender;\nimport visu.handball.moves.model.player.HighlightableItem;\nimport visu.handball.moves.model.player.MovePoint;\nimport visu.handball.moves.model.player.Offender;\nimport visu.handball.moves.model.player.Player;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HandballModel}.\n* It contains ten unit test cases for the {@link HandballModel#isSaved()} method.\n*/\nclass HandballModelTest4 {"
	},
	{
		"original_code": "// HandballModel.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.model;\r\n\r\nimport java.awt.geom.Point2D;\r\nimport java.io.Serializable;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.SortedSet;\r\nimport java.util.TreeSet;\r\nimport javax.swing.JOptionPane;\r\nimport visu.handball.moves.Main;\r\nimport visu.handball.moves.model.animation.AnimationModel;\r\nimport visu.handball.moves.model.animation.Animator;\r\nimport visu.handball.moves.model.player.Ball;\r\nimport visu.handball.moves.model.player.Defender;\r\nimport visu.handball.moves.model.player.HighlightableItem;\r\nimport visu.handball.moves.model.player.MovePoint;\r\nimport visu.handball.moves.model.player.Offender;\r\nimport visu.handball.moves.model.player.Player;\r\n\r\npublic class HandballModel implements Serializable {\r\n\r\n    private static final long serialVersionUID = -5372891552466311536L;\r\n\r\n    public enum State {\r\n\r\n        INITIAL,\r\n        PLACE_OFFENDERS,\r\n        PLACE_DEFENDERS,\r\n        PLACE_BALL,\r\n        EDIT,\r\n        EDIT_EVENT,\r\n        ANIMATION,\r\n        ANIMATION_RUNNING,\r\n        FULL_ANIMATION_ENDED\r\n    }\r\n\r\n    private static final int MAX_OFFENDERS = 6;\r\n\r\n    private static final int MAX_DEFENDERS = 6;\r\n\r\n    private static final int MARK_RADIUS = 12;\r\n\r\n    private static final String APP_NAME = \"jHandballMoves\";\r\n\r\n    private transient List<HandballModelListener> listeners;\r\n\r\n    private transient List<PlayerRemovedListener> playerRemoveListener;\r\n\r\n    private List<Defender> defenders;\r\n\r\n    private List<Offender> offenders;\r\n\r\n    private SortedSet<MoveEvent> events;\r\n\r\n    private State state;\r\n\r\n    private MoveEvent actualEvent;\r\n\r\n    private Player markedPlayer;\r\n\r\n    private HighlightableItem hightlightedItem;\r\n\r\n    private Offender ballOwner;\r\n\r\n    private Ball ball;\r\n\r\n    private Offender firstBallOwner;\r\n\r\n    private transient Animator runningAnimator;\r\n\r\n    private int animationSequenz;\r\n\r\n    private transient AnimationModel animationModel;\r\n\r\n    private transient HandballModel lastSavedModel;\r\n\r\n    private String comment;\r\n\r\n    private String moveName;\r\n\r\n    public HandballModel() {\r\n        listeners = new ArrayList<HandballModelListener>();\r\n        playerRemoveListener = new ArrayList<PlayerRemovedListener>();\r\n        initModel();\r\n    }\r\n\r\n    public void initModel() {\r\n        defenders = new ArrayList<Defender>();\r\n        Defender.setCounter(0);\r\n        offenders = new ArrayList<Offender>();\r\n        Offender.setCounter(0);\r\n        events = new TreeSet<MoveEvent>();\r\n        // Workaround wegen ToolBar\r\n        state = State.PLACE_OFFENDERS;\r\n        actualEvent = null;\r\n        markedPlayer = null;\r\n        firstBallOwner = null;\r\n        comment = \"\";\r\n        moveName = \"\";\r\n        resetBallPosition();\r\n        try {\r\n            lastSavedModel = (HandballModel) Main.deepCopy(this);\r\n        } catch (Exception e) {\r\n            lastSavedModel = null;\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    private void resetBallPosition() {\r\n        ball = new Ball(-500, -500);\r\n    }\r\n\r\n    public void addOffender(int x, int y) {\r\n        if (offenders.size() == MAX_OFFENDERS) {\r\n            JOptionPane.showMessageDialog(Main.getWindow(), \"Sie haben schon \" + MAX_OFFENDERS + \" Angreifer angelegt.\", \"Info:\", JOptionPane.INFORMATION_MESSAGE);\r\n        } else {\r\n            offenders.add(new Offender(x, y));\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void removePlayer(Player toRemove) {\r\n        if (eventDefinedWithPlayer(toRemove)) {\r\n            removeEventsOfPlayer(toRemove);\r\n        }\r\n        if (toRemove instanceof Offender) {\r\n            removeOffender((Offender) toRemove);\r\n        } else {\r\n            removeDefender((Defender) toRemove);\r\n        }\r\n    }\r\n\r\n    private void removeOffender(Offender toRemove) {\r\n        if (getFirstBallOwner() != null && getFirstBallOwner().equals(toRemove)) {\r\n            setFirstBallOwner(null);\r\n        }\r\n        offenders.remove(toRemove);\r\n        if ((getDefenders().size() + getOffenders().size()) == 0) {\r\n            markedPlayer = null;\r\n        }\r\n        // Spielernummer aktualisieren\r\n        Offender.setCounter(determineMaxPlayerNumber(offenders));\r\n        fireOffenderRemoved(toRemove);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void addDefender(int x, int y) {\r\n        if (defenders.size() == MAX_DEFENDERS) {\r\n            JOptionPane.showMessageDialog(Main.getWindow(), \"Sie haben schon \" + MAX_OFFENDERS + \" Verteidiger angelegt.\", \"Info:\", JOptionPane.INFORMATION_MESSAGE);\r\n        } else {\r\n            defenders.add(new Defender(x, y));\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    private void removeDefender(Defender toRemove) {\r\n        defenders.remove(toRemove);\r\n        if ((getDefenders().size() + getOffenders().size()) == 0) {\r\n            markedPlayer = null;\r\n        }\r\n        Defender.setCounter(determineMaxPlayerNumber(defenders));\r\n        fireDefenderRemoved(toRemove);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public boolean addListener(HandballModelListener o) {\r\n        return listeners.add(o);\r\n    }\r\n\r\n    public boolean removeListener(HandballModelListener o) {\r\n        return listeners.remove(o);\r\n    }\r\n\r\n    public boolean addPlayerRemovedListener(PlayerRemovedListener o) {\r\n        return playerRemoveListener.add(o);\r\n    }\r\n\r\n    public boolean removePlayerRemovedListener(PlayerRemovedListener o) {\r\n        return playerRemoveListener.remove(o);\r\n    }\r\n\r\n    private void fireModelChanged() {\r\n        setMoveName(getMoveName());\r\n        for (HandballModelListener listener : listeners) {\r\n            listener.modelChanged();\r\n        }\r\n    }\r\n\r\n    private void fireOffenderRemoved(Offender offender) {\r\n        for (PlayerRemovedListener listener : playerRemoveListener) {\r\n            listener.offenderRemoved(offender);\r\n        }\r\n    }\r\n\r\n    private void fireDefenderRemoved(Defender defender) {\r\n        for (PlayerRemovedListener listener : playerRemoveListener) {\r\n            listener.defenderRemoved(defender);\r\n        }\r\n    }\r\n\r\n    public List<Defender> getDefenders() {\r\n        return defenders;\r\n    }\r\n\r\n    public List<Offender> getOffenders() {\r\n        return offenders;\r\n    }\r\n\r\n    public State getState() {\r\n        return state;\r\n    }\r\n\r\n    public void setState(State state) {\r\n        if (state == State.EDIT) {\r\n            if (getActualMoveEvent() == null) {\r\n                // Wenn leer, dann Null, sonst letztes Move Event setzen\r\n                setActualMoveEvent(getEvents().isEmpty() ? null : (getEvents().get(getEvents().size() - 1)));\r\n            } else {\r\n                setActualMoveEvent(getActualMoveEvent());\r\n            }\r\n        }\r\n        if (state == State.PLACE_DEFENDERS || state == State.PLACE_OFFENDERS) {\r\n            if (getFirstBallOwner() != null) {\r\n                setBallOwner(getFirstBallOwner());\r\n            }\r\n            setActualMoveEvent(null);\r\n        }\r\n        this.state = state;\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void addMoveEvent(MoveEvent event) {\r\n        events.add(event);\r\n        if (state == State.EDIT) {\r\n            setActualMoveEvent(event);\r\n            state = State.EDIT_EVENT;\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void removeMoveEvent(MoveEvent event) {\r\n        events.remove(event);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public List<MoveEvent> getEvents() {\r\n        List<MoveEvent> list = new ArrayList<MoveEvent>(events);\r\n        return list;\r\n    }\r\n\r\n    public SortedSet<MoveEvent> getSortedEvents() {\r\n        return events;\r\n    }\r\n\r\n    public int getAcutalSequenceNr() {\r\n        if (actualEvent == null)\r\n            return 0;\r\n        else {\r\n            return actualEvent.getSequenceNr();\r\n        }\r\n    }\r\n\r\n    public void setActualMoveEvent(MoveEvent event) {\r\n        if (this.actualEvent != null) {\r\n            this.actualEvent.setMarked(false);\r\n        }\r\n        this.actualEvent = event;\r\n        computePlayerPositions();\r\n        // aktuellen Spieler setzen\r\n        setMarkedPlayer((event == null) ? null : event.getPlayer());\r\n        if (actualEvent != null) {\r\n            if (!actualEvent.isDestinationPointSet()) {\r\n                state = State.EDIT_EVENT;\r\n            } else {\r\n                if (state == State.FULL_ANIMATION_ENDED) {\r\n                    state = State.ANIMATION;\r\n                } else if (state != State.ANIMATION && state != State.ANIMATION_RUNNING) {\r\n                    state = State.EDIT;\r\n                }\r\n            }\r\n            actualEvent.setMarked(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setDestinationPointForEvent(MoveEvent event, int x, int y, boolean temp) {\r\n        event.setDestinationPoint(x, y, temp);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setControlPointForEvent(MoveEvent event, int x, int y, boolean temp) {\r\n        event.setControlPoint(x, y, temp);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setMovePointTo(MovePoint point, int x, int y) {\r\n        actualEvent.setPoint(point, x, y);\r\n        fireModelChanged();\r\n    }\r\n\r\n    private void computePlayerPositions() {\r\n        computePlayerPositions(getAcutalSequenceNr());\r\n    }\r\n\r\n    public void computePlayerPositions(int seqNr) {\r\n        // Spieler Positionen auf Ausgangsstellung\r\n        for (Player offender : offenders) {\r\n            offender.resetPosition();\r\n        }\r\n        for (Player defender : defenders) {\r\n            defender.resetPosition();\r\n        }\r\n        if (seqNr == 1) {\r\n            setBallOwner(firstBallOwner);\r\n        }\r\n        // alle Events mit kleinerer Sequenznummer verarbeiten\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() < seqNr) {\r\n                if (event instanceof PassEvent) {\r\n                    // Ball an anderen Spieler �bertragen\r\n                    setBallOwner(((PassEvent) event).getDestinationPlayer());\r\n                } else {\r\n                    if (event.getDestinationX() > -1 && event.getDestinationY() > -1) {\r\n                        event.getPlayer().setCurrentPosition(event.getDestinationX(), event.getDestinationY());\r\n                    }\r\n                }\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    public MoveEvent getActualMoveEvent() {\r\n        return actualEvent;\r\n    }\r\n\r\n    public Player getMarkedPlayer() {\r\n        return markedPlayer;\r\n    }\r\n\r\n    public void setMarkedPlayer(Player markedPlayer) {\r\n        // alten markierten Spieler demarkieren\r\n        if (this.markedPlayer != null) {\r\n            this.markedPlayer.setMarked(false);\r\n        }\r\n        // evtl. neuen Spieler markieren\r\n        this.markedPlayer = markedPlayer;\r\n        if (markedPlayer != null) {\r\n            markedPlayer.setMarked(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setHighLightedItem(HighlightableItem item) {\r\n        if (this.hightlightedItem != null) {\r\n            // altes Item zur�cksetzen\r\n            this.hightlightedItem.setHighlight(false);\r\n        }\r\n        this.hightlightedItem = item;\r\n        if (item != null) {\r\n            hightlightedItem.setHighlight(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public HighlightableItem getHightligtedItem() {\r\n        return hightlightedItem;\r\n    }\r\n\r\n    public Player getNearestPlayer(int x, int y) {\r\n        List<Player> all = new ArrayList<Player>(offenders);\r\n        all.addAll(defenders);\r\n        return findNearestPlayer(x, y, all);\r\n    }\r\n\r\n    public Offender getNearestOffender(int x, int y) {\r\n        List<Player> all = new ArrayList<Player>(offenders);\r\n        return (Offender) findNearestPlayer(x, y, all);\r\n    }\r\n\r\n    private Player findNearestPlayer(int x, int y, List<Player> players) {\r\n        double entfernung = Double.MAX_VALUE;\r\n        Player temp = null;\r\n        for (Player player : players) {\r\n            int player_x = player.getCurrent_x();\r\n            int player_y = player.getCurrent_y();\r\n            double tempEntfernung = Point2D.distance(x, y, player_x, player_y);\r\n            // Wenn naeher als der MARK_RADIUS\r\n            if (!(tempEntfernung > MARK_RADIUS)) {\r\n                if (tempEntfernung < entfernung) {\r\n                    temp = player;\r\n                    entfernung = tempEntfernung;\r\n                }\r\n            }\r\n        }\r\n        return temp;\r\n    }\r\n\r\n    public MovePoint getNearestMovePoint(int x, int y) {\r\n        MovePoint point = null;\r\n        if (actualEvent != null) {\r\n            double entfernung = Double.MAX_VALUE;\r\n            if (actualEvent.isDestinationPointSet()) {\r\n                int destination_x = actualEvent.getDestinationX();\r\n                int destination_y = actualEvent.getDestinationY();\r\n                double tempEntfernung = Point2D.distance(x, y, destination_x, destination_y);\r\n                // Wenn naeher als der MARK_RADIUS\r\n                if (!(tempEntfernung > MARK_RADIUS)) {\r\n                    if (tempEntfernung < entfernung) {\r\n                        point = actualEvent.getDestinationPoint();\r\n                        entfernung = tempEntfernung;\r\n                    }\r\n                }\r\n            }\r\n            if (actualEvent.isControlPointSet()) {\r\n                int controlPoint_x = actualEvent.getControlPointX();\r\n                int controlPoint_y = actualEvent.getControlPointY();\r\n                double tempEntfernung = Point2D.distance(x, y, controlPoint_x, controlPoint_y);\r\n                // Wenn naeher als der MARK_RADIUS\r\n                if (!(tempEntfernung > MARK_RADIUS)) {\r\n                    if (tempEntfernung < entfernung) {\r\n                        point = actualEvent.getControlPoint();\r\n                        entfernung = tempEntfernung;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return point;\r\n    }\r\n\r\n    public HighlightableItem getNearestHighlightableItem(int x, int y) {\r\n        HighlightableItem temp = null;\r\n        temp = getNearestMovePoint(x, y);\r\n        if (temp == null) {\r\n            temp = getNearestPlayer(x, y);\r\n        }\r\n        return temp;\r\n    }\r\n\r\n    public void movePlayerTo(Player actualPlayer, int x, int y) {\r\n        if (getAcutalSequenceNr() == 0) {\r\n            actualPlayer.setStart_x(x);\r\n            actualPlayer.setStart_y(y);\r\n        }\r\n        // Ansonsten muss die Position im entsprechenden Ereignis gesetzt\r\n        // werden\r\n        // Startposition darf nur im Angreifer/Verteidiger-Modus ge�ndert werden\r\n        fireModelChanged();\r\n    }\r\n\r\n    public boolean isSaved() {\r\n        boolean changed = false;\r\n        if (lastSavedModel != null) {\r\n            //Spielzugnamen vergleichen\r\n            if (lastSavedModel.getMoveName() != null) {\r\n                if (getMoveName() == null || !lastSavedModel.getMoveName().equals(getMoveName())) {\r\n                    return false;\r\n                }\r\n            } else if (getMoveName() != null) {\r\n                //alt: kein Name <-> neu: Name vorhanden\r\n                return false;\r\n            }\r\n            //Ueberprüfen ob Angreifer und Verteidiger unterschiedlich\r\n            // zuerst Spielerlisten vergleichen\r\n            if (changedPlayerList(getOffenders().toArray(new Player[getOffenders().size()]), lastSavedModel.getOffenders().toArray(new Player[lastSavedModel.getOffenders().size()])) || changedPlayerList(getDefenders().toArray(new Player[getDefenders().size()]), lastSavedModel.getDefenders().toArray(new Player[lastSavedModel.getDefenders().size()]))) {\r\n                changed = true;\r\n            } else {\r\n                List<MoveEvent> newEvents = getEvents();\r\n                List<MoveEvent> oldEvents = lastSavedModel.getEvents();\r\n                if (newEvents.size() == oldEvents.size()) {\r\n                    for (int i = 0; i < newEvents.size(); i++) {\r\n                        if (!newEvents.get(i).equals(oldEvents.get(i))) {\r\n                            changed = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                } else {\r\n                    changed = true;\r\n                }\r\n            }\r\n            if (!changed && (getFirstBallOwner() != null || lastSavedModel.getFirstBallOwner() != null)) {\r\n                changed = (getFirstBallOwner() == null) ^ (lastSavedModel.getFirstBallOwner() == null);\r\n                if (!changed) {\r\n                    changed = !getFirstBallOwner().equals(lastSavedModel.getFirstBallOwner());\r\n                }\r\n            }\r\n            // wurde Kommentar geändert?\r\n            if (!changed) {\r\n                if (comment == null || comment.equals(\"\")) {\r\n                    if (lastSavedModel.getComment() != null && !lastSavedModel.getComment().equals(\"\")) {\r\n                        changed = true;\r\n                    }\r\n                } else if (lastSavedModel.getComment() != null) {\r\n                    if (!lastSavedModel.getComment().equals(comment)) {\r\n                        changed = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return !changed;\r\n    }\r\n\r\n    private boolean changedPlayerList(Player[] newList, Player[] oldList) {\r\n        boolean changed = false;\r\n        int size = newList.length;\r\n        int sizeOld = oldList.length;\r\n        if (size == sizeOld) {\r\n            for (int i = 0; i < size; i++) {\r\n                if (!newList[i].equals(oldList[i])) {\r\n                    changed = true;\r\n                    break;\r\n                }\r\n            }\r\n        } else {\r\n            changed = true;\r\n        }\r\n        return changed;\r\n    }\r\n\r\n    public void initWithLoadedModel(HandballModel loadedModel) {\r\n        initModel();\r\n        offenders = loadedModel.getOffenders();\r\n        defenders = loadedModel.getDefenders();\r\n        events = loadedModel.getSortedEvents();\r\n        Offender.setCounter(determineMaxPlayerNumber(offenders));\r\n        Defender.setCounter(determineMaxPlayerNumber(defenders));\r\n        setFirstBallOwner(loadedModel.getFirstBallOwner());\r\n        setState(loadedModel.getState());\r\n        setActualMoveEvent(loadedModel.getActualMoveEvent());\r\n        setComment(loadedModel.getComment());\r\n        // zur Sicherheit\r\n        if (getComment() == null) {\r\n            setComment(\"\");\r\n        }\r\n        setMoveName(loadedModel.getMoveName());\r\n        markAsSaved(loadedModel);\r\n        fireModelChanged();\r\n    }\r\n\r\n    private int determineMaxPlayerNumber(List players) {\r\n        int max = 0;\r\n        for (Object o : players) {\r\n            if (o instanceof Player) {\r\n                Player player = (Player) o;\r\n                if (player.getPlayerNumber() > max) {\r\n                    max = player.getPlayerNumber();\r\n                }\r\n            }\r\n        }\r\n        return max;\r\n    }\r\n\r\n    public void markAsSaved(HandballModel model) {\r\n        try {\r\n            lastSavedModel = (HandballModel) Main.deepCopy(model);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            lastSavedModel = null;\r\n        }\r\n    }\r\n\r\n    public void setDelay(int eventIndex, int delay) {\r\n        getEvents().get(eventIndex).setDelay(delay);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setBallOwner(Offender ballOwner) {\r\n        if (this.ballOwner != null) {\r\n            this.ballOwner.setHasBall(false);\r\n        }\r\n        this.ballOwner = ballOwner;\r\n        if (ballOwner != null) {\r\n            ballOwner.setHasBall(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setBallOwnerSilent(Offender ballOwner) {\r\n        if (this.ballOwner != null) {\r\n            this.ballOwner.setHasBall(false);\r\n        }\r\n        this.ballOwner = ballOwner;\r\n        if (ballOwner != null) {\r\n            ballOwner.setHasBall(true);\r\n        }\r\n        // fireModelChanged();\r\n    }\r\n\r\n    public void startAnimation(boolean onlyActualSequence) {\r\n        setState(State.ANIMATION_RUNNING);\r\n        MoveEvent event = actualEvent;\r\n        if (event == null) {\r\n            event = getEvents().get(0);\r\n        }\r\n        setActualMoveEvent(event);\r\n        animationSequenz = event.getSequenceNr();\r\n        animationModel = new AnimationModel(event, this, onlyActualSequence);\r\n        runningAnimator = new Animator(this);\r\n        computePlayerPositions(animationSequenz);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void pauseAnimation(boolean pause) {\r\n        if (pause) {\r\n            runningAnimator.setPause(true);\r\n        } else {\r\n            runningAnimator.setPause(false);\r\n        }\r\n    }\r\n\r\n    public void initAnimation() {\r\n    }\r\n\r\n    public boolean nextAnimationStep() {\r\n        boolean finished = animationModel.nextStep();\r\n        if (finished) {\r\n            if (animationModel.isOnlyOneSequence()) {\r\n                setState(State.ANIMATION);\r\n                // n�chste Sequzenz ausw�hlen (einfaches sequentielles Anschauen des Spielzugs)\r\n                int nextSeq = (getAcutalSequenceNr() == getHighestSequenceNumber()) ? getAcutalSequenceNr() : getAcutalSequenceNr() + 1;\r\n                List<MoveEvent> nextSeqEvents = getMoveEvents(nextSeq);\r\n                if (nextSeqEvents.get(0) != null) {\r\n                    setActualMoveEvent(nextSeqEvents.get(0));\r\n                }\r\n            } else {\r\n                setState(State.FULL_ANIMATION_ENDED);\r\n            }\r\n        } else {\r\n            fireModelChanged();\r\n        }\r\n        return finished;\r\n    }\r\n\r\n    public void stopAnimation() {\r\n        setState(State.ANIMATION);\r\n        runningAnimator = null;\r\n        setActualMoveEvent(getActualMoveEvent());\r\n    }\r\n\r\n    public boolean isMarkedPlayerAddable() {\r\n        int seq = getAcutalSequenceNr();\r\n        return !events.contains(new MoveEvent(markedPlayer, seq));\r\n    }\r\n\r\n    public boolean passEventDefined(int seq) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() == seq && event instanceof PassEvent) {\r\n                defined = true;\r\n                break;\r\n            }\r\n            if (event.getSequenceNr() > seq) {\r\n                break;\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public boolean passEventDefined() {\r\n        return passEventDefined(getAcutalSequenceNr());\r\n    }\r\n\r\n    public boolean passEventDefinedAfter(int seq) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if ((event instanceof PassEvent) && (event.getSequenceNr() > seq)) {\r\n                defined = true;\r\n                break;\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public boolean eventDefinedAfter(int seq) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() > seq) {\r\n                defined = true;\r\n                break;\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public Ball getBall() {\r\n        return ball;\r\n    }\r\n\r\n    public void setFirstBallOwner(Offender offender) {\r\n        this.firstBallOwner = offender;\r\n        setBallOwner(offender);\r\n        if (firstBallOwner == null) {\r\n            resetBallPosition();\r\n        }\r\n    }\r\n\r\n    public Offender getFirstBallOwner() {\r\n        return firstBallOwner;\r\n    }\r\n\r\n    public boolean hasPlayerBallInNextSequence(Player player) {\r\n        PassEvent pass = null;\r\n        int seq = getAcutalSequenceNr();\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() == seq && event instanceof PassEvent) {\r\n                pass = (PassEvent) event;\r\n                break;\r\n            }\r\n            if (event.getSequenceNr() > seq) {\r\n                break;\r\n            }\r\n        }\r\n        if (pass != null && pass.getDestinationPlayer() != null) {\r\n            return pass.getDestinationPlayer().equals(player) && !passEventDefined(seq + 1);\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public boolean isBallSet() {\r\n        return ballOwner != null;\r\n    }\r\n\r\n    public boolean isGoalPassSet() {\r\n        boolean defined = false;\r\n        for (MoveEvent event : getEvents()) {\r\n            if (event instanceof PassEvent) {\r\n                PassEvent pass = (PassEvent) event;\r\n                if (pass.isGoalPass()) {\r\n                    defined = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public void moveBallTo(int x, int y) {\r\n        ball.setCurrent_x(x);\r\n        ball.setCurrent_y(y);\r\n    }\r\n\r\n    public List<MoveEvent> getActualMoveEvents() {\r\n        return getMoveEvents(getAcutalSequenceNr());\r\n    }\r\n\r\n    public List<MoveEvent> getMoveEvents(int sequenceNr) {\r\n        List<MoveEvent> sequenceEvents = new ArrayList<MoveEvent>();\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() == sequenceNr) {\r\n                sequenceEvents.add(event);\r\n            } else if (event.getSequenceNr() > getAcutalSequenceNr()) {\r\n                break;\r\n            }\r\n        }\r\n        return sequenceEvents;\r\n    }\r\n\r\n    /**\r\n     * Löscht das Aktuelle Ereignis und ALLE Folgenden\r\n     */\r\n    public void removeEventsAfter() {\r\n        MoveEvent event = getActualMoveEvent();\r\n        List<MoveEvent> toDeleteEvents = new ArrayList<MoveEvent>();\r\n        int sequenceNr = event.getSequenceNr();\r\n        // zu loeschende Events sammeln\r\n        for (MoveEvent evt : getEvents()) {\r\n            if (evt.getSequenceNr() > sequenceNr) {\r\n                // Event ist hoeher, also loeschen\r\n                toDeleteEvents.add(evt);\r\n            }\r\n        }\r\n        toDeleteEvents.add(event);\r\n        // gesammelte Events loeschen\r\n        for (MoveEvent deleteEvent : toDeleteEvents) {\r\n            removeMoveEvent(deleteEvent);\r\n        }\r\n        setActualMoveEvent((getEvents().size() > 0) ? getEvents().get(getEvents().size() - 1) : null);\r\n        fireModelChanged();\r\n    }\r\n\r\n    /**\r\n     * Löscht die Ereignisse (auch P�sse) des �bergebenen Spielers. Und die\r\n     * evtl. davon abh�ngigen Folgep�sse\r\n     *\r\n     * @param player\r\n     */\r\n    private void removeEventsOfPlayer(Player player) {\r\n        List<MoveEvent> toDeleteEvents = new ArrayList<MoveEvent>();\r\n        boolean playerInvolved = false;\r\n        // zu loeschende Events sammeln\r\n        for (MoveEvent evt : getEvents()) {\r\n            // Pass?\r\n            if (evt instanceof PassEvent) {\r\n                PassEvent pass = (PassEvent) evt;\r\n                // War ein Pass zu dem Spieler? oder Spieler passt selbst?\r\n                if (pass.getDestinationPlayer().equals(player) || pass.getPlayer().equals(player)) {\r\n                    playerInvolved = true;\r\n                }\r\n                // War Spieler an einem Pass beteiligt?\r\n                if (playerInvolved) {\r\n                    toDeleteEvents.add(pass);\r\n                    continue;\r\n                }\r\n            }\r\n            if (evt.getPlayer().equals(player)) {\r\n                toDeleteEvents.add(evt);\r\n            }\r\n        }\r\n        // gesammelte Events loeschen\r\n        for (MoveEvent deleteEvent : toDeleteEvents) {\r\n            removeMoveEvent(deleteEvent);\r\n        }\r\n        setActualMoveEvent((getEvents().size() > 0) ? getEvents().get(getEvents().size() - 1) : null);\r\n    }\r\n\r\n    public boolean eventDefinedWithPlayer(Player player) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if (event.getPlayer().equals(player)) {\r\n                defined = true;\r\n                break;\r\n            }\r\n            if (event instanceof PassEvent) {\r\n                PassEvent pass = (PassEvent) event;\r\n                if (pass.getDestinationPlayer().equals(player)) {\r\n                    defined = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public int getHighestSequenceNumber() {\r\n        if (events.size() == 0) {\r\n            return 0;\r\n        } else {\r\n            return events.last().getSequenceNr();\r\n        }\r\n    }\r\n\r\n    public String getMoveName() {\r\n        return moveName;\r\n    }\r\n\r\n    public void setMoveName(String moveName) {\r\n        this.moveName = moveName;\r\n        if (Main.getWindow() != null) {\r\n            StringBuffer buffer = new StringBuffer(APP_NAME);\r\n            buffer.append(\" - \");\r\n            if (moveName == null || moveName.equals(\"\")) {\r\n                buffer.append(\"Unbenannt\");\r\n                // Titelleiste aktualisieren\r\n            } else {\r\n                buffer.append(moveName);\r\n            }\r\n            if (!isSaved()) {\r\n                buffer.append(\"*\");\r\n            }\r\n            Main.getWindow().setTitle(buffer.toString());\r\n        }\r\n    }\r\n\r\n    public String getComment() {\r\n        if (comment == null) {\r\n            comment = \"\";\r\n        }\r\n        return comment;\r\n    }\r\n\r\n    public void setComment(String comment) {\r\n        this.comment = comment;\r\n        fireModelChanged();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/model/HandballModelTest5.java",
		"test_prompt": "// HandballModelTest5.java\npackage visu.handball.moves.model;\n\nimport java.awt.geom.Point2D;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\nimport javax.swing.JOptionPane;\nimport visu.handball.moves.Main;\nimport visu.handball.moves.model.animation.AnimationModel;\nimport visu.handball.moves.model.animation.Animator;\nimport visu.handball.moves.model.player.Ball;\nimport visu.handball.moves.model.player.Defender;\nimport visu.handball.moves.model.player.HighlightableItem;\nimport visu.handball.moves.model.player.MovePoint;\nimport visu.handball.moves.model.player.Offender;\nimport visu.handball.moves.model.player.Player;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HandballModel}.\n* It contains ten unit test cases for the {@link HandballModel#nextAnimationStep()} method.\n*/\nclass HandballModelTest5 {"
	},
	{
		"original_code": "// HandballModel.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.model;\r\n\r\nimport java.awt.geom.Point2D;\r\nimport java.io.Serializable;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.SortedSet;\r\nimport java.util.TreeSet;\r\nimport javax.swing.JOptionPane;\r\nimport visu.handball.moves.Main;\r\nimport visu.handball.moves.model.animation.AnimationModel;\r\nimport visu.handball.moves.model.animation.Animator;\r\nimport visu.handball.moves.model.player.Ball;\r\nimport visu.handball.moves.model.player.Defender;\r\nimport visu.handball.moves.model.player.HighlightableItem;\r\nimport visu.handball.moves.model.player.MovePoint;\r\nimport visu.handball.moves.model.player.Offender;\r\nimport visu.handball.moves.model.player.Player;\r\n\r\npublic class HandballModel implements Serializable {\r\n\r\n    private static final long serialVersionUID = -5372891552466311536L;\r\n\r\n    public enum State {\r\n\r\n        INITIAL,\r\n        PLACE_OFFENDERS,\r\n        PLACE_DEFENDERS,\r\n        PLACE_BALL,\r\n        EDIT,\r\n        EDIT_EVENT,\r\n        ANIMATION,\r\n        ANIMATION_RUNNING,\r\n        FULL_ANIMATION_ENDED\r\n    }\r\n\r\n    private static final int MAX_OFFENDERS = 6;\r\n\r\n    private static final int MAX_DEFENDERS = 6;\r\n\r\n    private static final int MARK_RADIUS = 12;\r\n\r\n    private static final String APP_NAME = \"jHandballMoves\";\r\n\r\n    private transient List<HandballModelListener> listeners;\r\n\r\n    private transient List<PlayerRemovedListener> playerRemoveListener;\r\n\r\n    private List<Defender> defenders;\r\n\r\n    private List<Offender> offenders;\r\n\r\n    private SortedSet<MoveEvent> events;\r\n\r\n    private State state;\r\n\r\n    private MoveEvent actualEvent;\r\n\r\n    private Player markedPlayer;\r\n\r\n    private HighlightableItem hightlightedItem;\r\n\r\n    private Offender ballOwner;\r\n\r\n    private Ball ball;\r\n\r\n    private Offender firstBallOwner;\r\n\r\n    private transient Animator runningAnimator;\r\n\r\n    private int animationSequenz;\r\n\r\n    private transient AnimationModel animationModel;\r\n\r\n    private transient HandballModel lastSavedModel;\r\n\r\n    private String comment;\r\n\r\n    private String moveName;\r\n\r\n    public HandballModel() {\r\n        listeners = new ArrayList<HandballModelListener>();\r\n        playerRemoveListener = new ArrayList<PlayerRemovedListener>();\r\n        initModel();\r\n    }\r\n\r\n    public void initModel() {\r\n        defenders = new ArrayList<Defender>();\r\n        Defender.setCounter(0);\r\n        offenders = new ArrayList<Offender>();\r\n        Offender.setCounter(0);\r\n        events = new TreeSet<MoveEvent>();\r\n        // Workaround wegen ToolBar\r\n        state = State.PLACE_OFFENDERS;\r\n        actualEvent = null;\r\n        markedPlayer = null;\r\n        firstBallOwner = null;\r\n        comment = \"\";\r\n        moveName = \"\";\r\n        resetBallPosition();\r\n        try {\r\n            lastSavedModel = (HandballModel) Main.deepCopy(this);\r\n        } catch (Exception e) {\r\n            lastSavedModel = null;\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    private void resetBallPosition() {\r\n        ball = new Ball(-500, -500);\r\n    }\r\n\r\n    public void addOffender(int x, int y) {\r\n        if (offenders.size() == MAX_OFFENDERS) {\r\n            JOptionPane.showMessageDialog(Main.getWindow(), \"Sie haben schon \" + MAX_OFFENDERS + \" Angreifer angelegt.\", \"Info:\", JOptionPane.INFORMATION_MESSAGE);\r\n        } else {\r\n            offenders.add(new Offender(x, y));\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void removePlayer(Player toRemove) {\r\n        if (eventDefinedWithPlayer(toRemove)) {\r\n            removeEventsOfPlayer(toRemove);\r\n        }\r\n        if (toRemove instanceof Offender) {\r\n            removeOffender((Offender) toRemove);\r\n        } else {\r\n            removeDefender((Defender) toRemove);\r\n        }\r\n    }\r\n\r\n    private void removeOffender(Offender toRemove) {\r\n        if (getFirstBallOwner() != null && getFirstBallOwner().equals(toRemove)) {\r\n            setFirstBallOwner(null);\r\n        }\r\n        offenders.remove(toRemove);\r\n        if ((getDefenders().size() + getOffenders().size()) == 0) {\r\n            markedPlayer = null;\r\n        }\r\n        // Spielernummer aktualisieren\r\n        Offender.setCounter(determineMaxPlayerNumber(offenders));\r\n        fireOffenderRemoved(toRemove);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void addDefender(int x, int y) {\r\n        if (defenders.size() == MAX_DEFENDERS) {\r\n            JOptionPane.showMessageDialog(Main.getWindow(), \"Sie haben schon \" + MAX_OFFENDERS + \" Verteidiger angelegt.\", \"Info:\", JOptionPane.INFORMATION_MESSAGE);\r\n        } else {\r\n            defenders.add(new Defender(x, y));\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    private void removeDefender(Defender toRemove) {\r\n        defenders.remove(toRemove);\r\n        if ((getDefenders().size() + getOffenders().size()) == 0) {\r\n            markedPlayer = null;\r\n        }\r\n        Defender.setCounter(determineMaxPlayerNumber(defenders));\r\n        fireDefenderRemoved(toRemove);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public boolean addListener(HandballModelListener o) {\r\n        return listeners.add(o);\r\n    }\r\n\r\n    public boolean removeListener(HandballModelListener o) {\r\n        return listeners.remove(o);\r\n    }\r\n\r\n    public boolean addPlayerRemovedListener(PlayerRemovedListener o) {\r\n        return playerRemoveListener.add(o);\r\n    }\r\n\r\n    public boolean removePlayerRemovedListener(PlayerRemovedListener o) {\r\n        return playerRemoveListener.remove(o);\r\n    }\r\n\r\n    private void fireModelChanged() {\r\n        setMoveName(getMoveName());\r\n        for (HandballModelListener listener : listeners) {\r\n            listener.modelChanged();\r\n        }\r\n    }\r\n\r\n    private void fireOffenderRemoved(Offender offender) {\r\n        for (PlayerRemovedListener listener : playerRemoveListener) {\r\n            listener.offenderRemoved(offender);\r\n        }\r\n    }\r\n\r\n    private void fireDefenderRemoved(Defender defender) {\r\n        for (PlayerRemovedListener listener : playerRemoveListener) {\r\n            listener.defenderRemoved(defender);\r\n        }\r\n    }\r\n\r\n    public List<Defender> getDefenders() {\r\n        return defenders;\r\n    }\r\n\r\n    public List<Offender> getOffenders() {\r\n        return offenders;\r\n    }\r\n\r\n    public State getState() {\r\n        return state;\r\n    }\r\n\r\n    public void setState(State state) {\r\n        if (state == State.EDIT) {\r\n            if (getActualMoveEvent() == null) {\r\n                // Wenn leer, dann Null, sonst letztes Move Event setzen\r\n                setActualMoveEvent(getEvents().isEmpty() ? null : (getEvents().get(getEvents().size() - 1)));\r\n            } else {\r\n                setActualMoveEvent(getActualMoveEvent());\r\n            }\r\n        }\r\n        if (state == State.PLACE_DEFENDERS || state == State.PLACE_OFFENDERS) {\r\n            if (getFirstBallOwner() != null) {\r\n                setBallOwner(getFirstBallOwner());\r\n            }\r\n            setActualMoveEvent(null);\r\n        }\r\n        this.state = state;\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void addMoveEvent(MoveEvent event) {\r\n        events.add(event);\r\n        if (state == State.EDIT) {\r\n            setActualMoveEvent(event);\r\n            state = State.EDIT_EVENT;\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void removeMoveEvent(MoveEvent event) {\r\n        events.remove(event);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public List<MoveEvent> getEvents() {\r\n        List<MoveEvent> list = new ArrayList<MoveEvent>(events);\r\n        return list;\r\n    }\r\n\r\n    public SortedSet<MoveEvent> getSortedEvents() {\r\n        return events;\r\n    }\r\n\r\n    public int getAcutalSequenceNr() {\r\n        if (actualEvent == null)\r\n            return 0;\r\n        else {\r\n            return actualEvent.getSequenceNr();\r\n        }\r\n    }\r\n\r\n    public void setActualMoveEvent(MoveEvent event) {\r\n        if (this.actualEvent != null) {\r\n            this.actualEvent.setMarked(false);\r\n        }\r\n        this.actualEvent = event;\r\n        computePlayerPositions();\r\n        // aktuellen Spieler setzen\r\n        setMarkedPlayer((event == null) ? null : event.getPlayer());\r\n        if (actualEvent != null) {\r\n            if (!actualEvent.isDestinationPointSet()) {\r\n                state = State.EDIT_EVENT;\r\n            } else {\r\n                if (state == State.FULL_ANIMATION_ENDED) {\r\n                    state = State.ANIMATION;\r\n                } else if (state != State.ANIMATION && state != State.ANIMATION_RUNNING) {\r\n                    state = State.EDIT;\r\n                }\r\n            }\r\n            actualEvent.setMarked(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setDestinationPointForEvent(MoveEvent event, int x, int y, boolean temp) {\r\n        event.setDestinationPoint(x, y, temp);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setControlPointForEvent(MoveEvent event, int x, int y, boolean temp) {\r\n        event.setControlPoint(x, y, temp);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setMovePointTo(MovePoint point, int x, int y) {\r\n        actualEvent.setPoint(point, x, y);\r\n        fireModelChanged();\r\n    }\r\n\r\n    private void computePlayerPositions() {\r\n        computePlayerPositions(getAcutalSequenceNr());\r\n    }\r\n\r\n    public void computePlayerPositions(int seqNr) {\r\n        // Spieler Positionen auf Ausgangsstellung\r\n        for (Player offender : offenders) {\r\n            offender.resetPosition();\r\n        }\r\n        for (Player defender : defenders) {\r\n            defender.resetPosition();\r\n        }\r\n        if (seqNr == 1) {\r\n            setBallOwner(firstBallOwner);\r\n        }\r\n        // alle Events mit kleinerer Sequenznummer verarbeiten\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() < seqNr) {\r\n                if (event instanceof PassEvent) {\r\n                    // Ball an anderen Spieler �bertragen\r\n                    setBallOwner(((PassEvent) event).getDestinationPlayer());\r\n                } else {\r\n                    if (event.getDestinationX() > -1 && event.getDestinationY() > -1) {\r\n                        event.getPlayer().setCurrentPosition(event.getDestinationX(), event.getDestinationY());\r\n                    }\r\n                }\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    public MoveEvent getActualMoveEvent() {\r\n        return actualEvent;\r\n    }\r\n\r\n    public Player getMarkedPlayer() {\r\n        return markedPlayer;\r\n    }\r\n\r\n    public void setMarkedPlayer(Player markedPlayer) {\r\n        // alten markierten Spieler demarkieren\r\n        if (this.markedPlayer != null) {\r\n            this.markedPlayer.setMarked(false);\r\n        }\r\n        // evtl. neuen Spieler markieren\r\n        this.markedPlayer = markedPlayer;\r\n        if (markedPlayer != null) {\r\n            markedPlayer.setMarked(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setHighLightedItem(HighlightableItem item) {\r\n        if (this.hightlightedItem != null) {\r\n            // altes Item zur�cksetzen\r\n            this.hightlightedItem.setHighlight(false);\r\n        }\r\n        this.hightlightedItem = item;\r\n        if (item != null) {\r\n            hightlightedItem.setHighlight(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public HighlightableItem getHightligtedItem() {\r\n        return hightlightedItem;\r\n    }\r\n\r\n    public Player getNearestPlayer(int x, int y) {\r\n        List<Player> all = new ArrayList<Player>(offenders);\r\n        all.addAll(defenders);\r\n        return findNearestPlayer(x, y, all);\r\n    }\r\n\r\n    public Offender getNearestOffender(int x, int y) {\r\n        List<Player> all = new ArrayList<Player>(offenders);\r\n        return (Offender) findNearestPlayer(x, y, all);\r\n    }\r\n\r\n    private Player findNearestPlayer(int x, int y, List<Player> players) {\r\n        double entfernung = Double.MAX_VALUE;\r\n        Player temp = null;\r\n        for (Player player : players) {\r\n            int player_x = player.getCurrent_x();\r\n            int player_y = player.getCurrent_y();\r\n            double tempEntfernung = Point2D.distance(x, y, player_x, player_y);\r\n            // Wenn naeher als der MARK_RADIUS\r\n            if (!(tempEntfernung > MARK_RADIUS)) {\r\n                if (tempEntfernung < entfernung) {\r\n                    temp = player;\r\n                    entfernung = tempEntfernung;\r\n                }\r\n            }\r\n        }\r\n        return temp;\r\n    }\r\n\r\n    public MovePoint getNearestMovePoint(int x, int y) {\r\n        MovePoint point = null;\r\n        if (actualEvent != null) {\r\n            double entfernung = Double.MAX_VALUE;\r\n            if (actualEvent.isDestinationPointSet()) {\r\n                int destination_x = actualEvent.getDestinationX();\r\n                int destination_y = actualEvent.getDestinationY();\r\n                double tempEntfernung = Point2D.distance(x, y, destination_x, destination_y);\r\n                // Wenn naeher als der MARK_RADIUS\r\n                if (!(tempEntfernung > MARK_RADIUS)) {\r\n                    if (tempEntfernung < entfernung) {\r\n                        point = actualEvent.getDestinationPoint();\r\n                        entfernung = tempEntfernung;\r\n                    }\r\n                }\r\n            }\r\n            if (actualEvent.isControlPointSet()) {\r\n                int controlPoint_x = actualEvent.getControlPointX();\r\n                int controlPoint_y = actualEvent.getControlPointY();\r\n                double tempEntfernung = Point2D.distance(x, y, controlPoint_x, controlPoint_y);\r\n                // Wenn naeher als der MARK_RADIUS\r\n                if (!(tempEntfernung > MARK_RADIUS)) {\r\n                    if (tempEntfernung < entfernung) {\r\n                        point = actualEvent.getControlPoint();\r\n                        entfernung = tempEntfernung;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return point;\r\n    }\r\n\r\n    public HighlightableItem getNearestHighlightableItem(int x, int y) {\r\n        HighlightableItem temp = null;\r\n        temp = getNearestMovePoint(x, y);\r\n        if (temp == null) {\r\n            temp = getNearestPlayer(x, y);\r\n        }\r\n        return temp;\r\n    }\r\n\r\n    public void movePlayerTo(Player actualPlayer, int x, int y) {\r\n        if (getAcutalSequenceNr() == 0) {\r\n            actualPlayer.setStart_x(x);\r\n            actualPlayer.setStart_y(y);\r\n        }\r\n        // Ansonsten muss die Position im entsprechenden Ereignis gesetzt\r\n        // werden\r\n        // Startposition darf nur im Angreifer/Verteidiger-Modus ge�ndert werden\r\n        fireModelChanged();\r\n    }\r\n\r\n    public boolean isSaved() {\r\n        boolean changed = false;\r\n        if (lastSavedModel != null) {\r\n            //Spielzugnamen vergleichen\r\n            if (lastSavedModel.getMoveName() != null) {\r\n                if (getMoveName() == null || !lastSavedModel.getMoveName().equals(getMoveName())) {\r\n                    return false;\r\n                }\r\n            } else if (getMoveName() != null) {\r\n                //alt: kein Name <-> neu: Name vorhanden\r\n                return false;\r\n            }\r\n            //Ueberprüfen ob Angreifer und Verteidiger unterschiedlich\r\n            // zuerst Spielerlisten vergleichen\r\n            if (changedPlayerList(getOffenders().toArray(new Player[getOffenders().size()]), lastSavedModel.getOffenders().toArray(new Player[lastSavedModel.getOffenders().size()])) || changedPlayerList(getDefenders().toArray(new Player[getDefenders().size()]), lastSavedModel.getDefenders().toArray(new Player[lastSavedModel.getDefenders().size()]))) {\r\n                changed = true;\r\n            } else {\r\n                List<MoveEvent> newEvents = getEvents();\r\n                List<MoveEvent> oldEvents = lastSavedModel.getEvents();\r\n                if (newEvents.size() == oldEvents.size()) {\r\n                    for (int i = 0; i < newEvents.size(); i++) {\r\n                        if (!newEvents.get(i).equals(oldEvents.get(i))) {\r\n                            changed = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                } else {\r\n                    changed = true;\r\n                }\r\n            }\r\n            if (!changed && (getFirstBallOwner() != null || lastSavedModel.getFirstBallOwner() != null)) {\r\n                changed = (getFirstBallOwner() == null) ^ (lastSavedModel.getFirstBallOwner() == null);\r\n                if (!changed) {\r\n                    changed = !getFirstBallOwner().equals(lastSavedModel.getFirstBallOwner());\r\n                }\r\n            }\r\n            // wurde Kommentar geändert?\r\n            if (!changed) {\r\n                if (comment == null || comment.equals(\"\")) {\r\n                    if (lastSavedModel.getComment() != null && !lastSavedModel.getComment().equals(\"\")) {\r\n                        changed = true;\r\n                    }\r\n                } else if (lastSavedModel.getComment() != null) {\r\n                    if (!lastSavedModel.getComment().equals(comment)) {\r\n                        changed = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return !changed;\r\n    }\r\n\r\n    private boolean changedPlayerList(Player[] newList, Player[] oldList) {\r\n        boolean changed = false;\r\n        int size = newList.length;\r\n        int sizeOld = oldList.length;\r\n        if (size == sizeOld) {\r\n            for (int i = 0; i < size; i++) {\r\n                if (!newList[i].equals(oldList[i])) {\r\n                    changed = true;\r\n                    break;\r\n                }\r\n            }\r\n        } else {\r\n            changed = true;\r\n        }\r\n        return changed;\r\n    }\r\n\r\n    public void initWithLoadedModel(HandballModel loadedModel) {\r\n        initModel();\r\n        offenders = loadedModel.getOffenders();\r\n        defenders = loadedModel.getDefenders();\r\n        events = loadedModel.getSortedEvents();\r\n        Offender.setCounter(determineMaxPlayerNumber(offenders));\r\n        Defender.setCounter(determineMaxPlayerNumber(defenders));\r\n        setFirstBallOwner(loadedModel.getFirstBallOwner());\r\n        setState(loadedModel.getState());\r\n        setActualMoveEvent(loadedModel.getActualMoveEvent());\r\n        setComment(loadedModel.getComment());\r\n        // zur Sicherheit\r\n        if (getComment() == null) {\r\n            setComment(\"\");\r\n        }\r\n        setMoveName(loadedModel.getMoveName());\r\n        markAsSaved(loadedModel);\r\n        fireModelChanged();\r\n    }\r\n\r\n    private int determineMaxPlayerNumber(List players) {\r\n        int max = 0;\r\n        for (Object o : players) {\r\n            if (o instanceof Player) {\r\n                Player player = (Player) o;\r\n                if (player.getPlayerNumber() > max) {\r\n                    max = player.getPlayerNumber();\r\n                }\r\n            }\r\n        }\r\n        return max;\r\n    }\r\n\r\n    public void markAsSaved(HandballModel model) {\r\n        try {\r\n            lastSavedModel = (HandballModel) Main.deepCopy(model);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            lastSavedModel = null;\r\n        }\r\n    }\r\n\r\n    public void setDelay(int eventIndex, int delay) {\r\n        getEvents().get(eventIndex).setDelay(delay);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setBallOwner(Offender ballOwner) {\r\n        if (this.ballOwner != null) {\r\n            this.ballOwner.setHasBall(false);\r\n        }\r\n        this.ballOwner = ballOwner;\r\n        if (ballOwner != null) {\r\n            ballOwner.setHasBall(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setBallOwnerSilent(Offender ballOwner) {\r\n        if (this.ballOwner != null) {\r\n            this.ballOwner.setHasBall(false);\r\n        }\r\n        this.ballOwner = ballOwner;\r\n        if (ballOwner != null) {\r\n            ballOwner.setHasBall(true);\r\n        }\r\n        // fireModelChanged();\r\n    }\r\n\r\n    public void startAnimation(boolean onlyActualSequence) {\r\n        setState(State.ANIMATION_RUNNING);\r\n        MoveEvent event = actualEvent;\r\n        if (event == null) {\r\n            event = getEvents().get(0);\r\n        }\r\n        setActualMoveEvent(event);\r\n        animationSequenz = event.getSequenceNr();\r\n        animationModel = new AnimationModel(event, this, onlyActualSequence);\r\n        runningAnimator = new Animator(this);\r\n        computePlayerPositions(animationSequenz);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void pauseAnimation(boolean pause) {\r\n        if (pause) {\r\n            runningAnimator.setPause(true);\r\n        } else {\r\n            runningAnimator.setPause(false);\r\n        }\r\n    }\r\n\r\n    public void initAnimation() {\r\n    }\r\n\r\n    public boolean nextAnimationStep() {\r\n        boolean finished = animationModel.nextStep();\r\n        if (finished) {\r\n            if (animationModel.isOnlyOneSequence()) {\r\n                setState(State.ANIMATION);\r\n                // n�chste Sequzenz ausw�hlen (einfaches sequentielles Anschauen des Spielzugs)\r\n                int nextSeq = (getAcutalSequenceNr() == getHighestSequenceNumber()) ? getAcutalSequenceNr() : getAcutalSequenceNr() + 1;\r\n                List<MoveEvent> nextSeqEvents = getMoveEvents(nextSeq);\r\n                if (nextSeqEvents.get(0) != null) {\r\n                    setActualMoveEvent(nextSeqEvents.get(0));\r\n                }\r\n            } else {\r\n                setState(State.FULL_ANIMATION_ENDED);\r\n            }\r\n        } else {\r\n            fireModelChanged();\r\n        }\r\n        return finished;\r\n    }\r\n\r\n    public void stopAnimation() {\r\n        setState(State.ANIMATION);\r\n        runningAnimator = null;\r\n        setActualMoveEvent(getActualMoveEvent());\r\n    }\r\n\r\n    public boolean isMarkedPlayerAddable() {\r\n        int seq = getAcutalSequenceNr();\r\n        return !events.contains(new MoveEvent(markedPlayer, seq));\r\n    }\r\n\r\n    public boolean passEventDefined(int seq) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() == seq && event instanceof PassEvent) {\r\n                defined = true;\r\n                break;\r\n            }\r\n            if (event.getSequenceNr() > seq) {\r\n                break;\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public boolean passEventDefined() {\r\n        return passEventDefined(getAcutalSequenceNr());\r\n    }\r\n\r\n    public boolean passEventDefinedAfter(int seq) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if ((event instanceof PassEvent) && (event.getSequenceNr() > seq)) {\r\n                defined = true;\r\n                break;\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public boolean eventDefinedAfter(int seq) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() > seq) {\r\n                defined = true;\r\n                break;\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public Ball getBall() {\r\n        return ball;\r\n    }\r\n\r\n    public void setFirstBallOwner(Offender offender) {\r\n        this.firstBallOwner = offender;\r\n        setBallOwner(offender);\r\n        if (firstBallOwner == null) {\r\n            resetBallPosition();\r\n        }\r\n    }\r\n\r\n    public Offender getFirstBallOwner() {\r\n        return firstBallOwner;\r\n    }\r\n\r\n    public boolean hasPlayerBallInNextSequence(Player player) {\r\n        PassEvent pass = null;\r\n        int seq = getAcutalSequenceNr();\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() == seq && event instanceof PassEvent) {\r\n                pass = (PassEvent) event;\r\n                break;\r\n            }\r\n            if (event.getSequenceNr() > seq) {\r\n                break;\r\n            }\r\n        }\r\n        if (pass != null && pass.getDestinationPlayer() != null) {\r\n            return pass.getDestinationPlayer().equals(player) && !passEventDefined(seq + 1);\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public boolean isBallSet() {\r\n        return ballOwner != null;\r\n    }\r\n\r\n    public boolean isGoalPassSet() {\r\n        boolean defined = false;\r\n        for (MoveEvent event : getEvents()) {\r\n            if (event instanceof PassEvent) {\r\n                PassEvent pass = (PassEvent) event;\r\n                if (pass.isGoalPass()) {\r\n                    defined = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public void moveBallTo(int x, int y) {\r\n        ball.setCurrent_x(x);\r\n        ball.setCurrent_y(y);\r\n    }\r\n\r\n    public List<MoveEvent> getActualMoveEvents() {\r\n        return getMoveEvents(getAcutalSequenceNr());\r\n    }\r\n\r\n    public List<MoveEvent> getMoveEvents(int sequenceNr) {\r\n        List<MoveEvent> sequenceEvents = new ArrayList<MoveEvent>();\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() == sequenceNr) {\r\n                sequenceEvents.add(event);\r\n            } else if (event.getSequenceNr() > getAcutalSequenceNr()) {\r\n                break;\r\n            }\r\n        }\r\n        return sequenceEvents;\r\n    }\r\n\r\n    /**\r\n     * Löscht das Aktuelle Ereignis und ALLE Folgenden\r\n     */\r\n    public void removeEventsAfter() {\r\n        MoveEvent event = getActualMoveEvent();\r\n        List<MoveEvent> toDeleteEvents = new ArrayList<MoveEvent>();\r\n        int sequenceNr = event.getSequenceNr();\r\n        // zu loeschende Events sammeln\r\n        for (MoveEvent evt : getEvents()) {\r\n            if (evt.getSequenceNr() > sequenceNr) {\r\n                // Event ist hoeher, also loeschen\r\n                toDeleteEvents.add(evt);\r\n            }\r\n        }\r\n        toDeleteEvents.add(event);\r\n        // gesammelte Events loeschen\r\n        for (MoveEvent deleteEvent : toDeleteEvents) {\r\n            removeMoveEvent(deleteEvent);\r\n        }\r\n        setActualMoveEvent((getEvents().size() > 0) ? getEvents().get(getEvents().size() - 1) : null);\r\n        fireModelChanged();\r\n    }\r\n\r\n    /**\r\n     * Löscht die Ereignisse (auch P�sse) des �bergebenen Spielers. Und die\r\n     * evtl. davon abh�ngigen Folgep�sse\r\n     *\r\n     * @param player\r\n     */\r\n    private void removeEventsOfPlayer(Player player) {\r\n        List<MoveEvent> toDeleteEvents = new ArrayList<MoveEvent>();\r\n        boolean playerInvolved = false;\r\n        // zu loeschende Events sammeln\r\n        for (MoveEvent evt : getEvents()) {\r\n            // Pass?\r\n            if (evt instanceof PassEvent) {\r\n                PassEvent pass = (PassEvent) evt;\r\n                // War ein Pass zu dem Spieler? oder Spieler passt selbst?\r\n                if (pass.getDestinationPlayer().equals(player) || pass.getPlayer().equals(player)) {\r\n                    playerInvolved = true;\r\n                }\r\n                // War Spieler an einem Pass beteiligt?\r\n                if (playerInvolved) {\r\n                    toDeleteEvents.add(pass);\r\n                    continue;\r\n                }\r\n            }\r\n            if (evt.getPlayer().equals(player)) {\r\n                toDeleteEvents.add(evt);\r\n            }\r\n        }\r\n        // gesammelte Events loeschen\r\n        for (MoveEvent deleteEvent : toDeleteEvents) {\r\n            removeMoveEvent(deleteEvent);\r\n        }\r\n        setActualMoveEvent((getEvents().size() > 0) ? getEvents().get(getEvents().size() - 1) : null);\r\n    }\r\n\r\n    public boolean eventDefinedWithPlayer(Player player) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if (event.getPlayer().equals(player)) {\r\n                defined = true;\r\n                break;\r\n            }\r\n            if (event instanceof PassEvent) {\r\n                PassEvent pass = (PassEvent) event;\r\n                if (pass.getDestinationPlayer().equals(player)) {\r\n                    defined = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public int getHighestSequenceNumber() {\r\n        if (events.size() == 0) {\r\n            return 0;\r\n        } else {\r\n            return events.last().getSequenceNr();\r\n        }\r\n    }\r\n\r\n    public String getMoveName() {\r\n        return moveName;\r\n    }\r\n\r\n    public void setMoveName(String moveName) {\r\n        this.moveName = moveName;\r\n        if (Main.getWindow() != null) {\r\n            StringBuffer buffer = new StringBuffer(APP_NAME);\r\n            buffer.append(\" - \");\r\n            if (moveName == null || moveName.equals(\"\")) {\r\n                buffer.append(\"Unbenannt\");\r\n                // Titelleiste aktualisieren\r\n            } else {\r\n                buffer.append(moveName);\r\n            }\r\n            if (!isSaved()) {\r\n                buffer.append(\"*\");\r\n            }\r\n            Main.getWindow().setTitle(buffer.toString());\r\n        }\r\n    }\r\n\r\n    public String getComment() {\r\n        if (comment == null) {\r\n            comment = \"\";\r\n        }\r\n        return comment;\r\n    }\r\n\r\n    public void setComment(String comment) {\r\n        this.comment = comment;\r\n        fireModelChanged();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/model/HandballModelTest6.java",
		"test_prompt": "// HandballModelTest6.java\npackage visu.handball.moves.model;\n\nimport java.awt.geom.Point2D;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\nimport javax.swing.JOptionPane;\nimport visu.handball.moves.Main;\nimport visu.handball.moves.model.animation.AnimationModel;\nimport visu.handball.moves.model.animation.Animator;\nimport visu.handball.moves.model.player.Ball;\nimport visu.handball.moves.model.player.Defender;\nimport visu.handball.moves.model.player.HighlightableItem;\nimport visu.handball.moves.model.player.MovePoint;\nimport visu.handball.moves.model.player.Offender;\nimport visu.handball.moves.model.player.Player;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HandballModel}.\n* It contains ten unit test cases for the {@link HandballModel#isMarkedPlayerAddable()} method.\n*/\nclass HandballModelTest6 {"
	},
	{
		"original_code": "// HandballModel.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.model;\r\n\r\nimport java.awt.geom.Point2D;\r\nimport java.io.Serializable;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.SortedSet;\r\nimport java.util.TreeSet;\r\nimport javax.swing.JOptionPane;\r\nimport visu.handball.moves.Main;\r\nimport visu.handball.moves.model.animation.AnimationModel;\r\nimport visu.handball.moves.model.animation.Animator;\r\nimport visu.handball.moves.model.player.Ball;\r\nimport visu.handball.moves.model.player.Defender;\r\nimport visu.handball.moves.model.player.HighlightableItem;\r\nimport visu.handball.moves.model.player.MovePoint;\r\nimport visu.handball.moves.model.player.Offender;\r\nimport visu.handball.moves.model.player.Player;\r\n\r\npublic class HandballModel implements Serializable {\r\n\r\n    private static final long serialVersionUID = -5372891552466311536L;\r\n\r\n    public enum State {\r\n\r\n        INITIAL,\r\n        PLACE_OFFENDERS,\r\n        PLACE_DEFENDERS,\r\n        PLACE_BALL,\r\n        EDIT,\r\n        EDIT_EVENT,\r\n        ANIMATION,\r\n        ANIMATION_RUNNING,\r\n        FULL_ANIMATION_ENDED\r\n    }\r\n\r\n    private static final int MAX_OFFENDERS = 6;\r\n\r\n    private static final int MAX_DEFENDERS = 6;\r\n\r\n    private static final int MARK_RADIUS = 12;\r\n\r\n    private static final String APP_NAME = \"jHandballMoves\";\r\n\r\n    private transient List<HandballModelListener> listeners;\r\n\r\n    private transient List<PlayerRemovedListener> playerRemoveListener;\r\n\r\n    private List<Defender> defenders;\r\n\r\n    private List<Offender> offenders;\r\n\r\n    private SortedSet<MoveEvent> events;\r\n\r\n    private State state;\r\n\r\n    private MoveEvent actualEvent;\r\n\r\n    private Player markedPlayer;\r\n\r\n    private HighlightableItem hightlightedItem;\r\n\r\n    private Offender ballOwner;\r\n\r\n    private Ball ball;\r\n\r\n    private Offender firstBallOwner;\r\n\r\n    private transient Animator runningAnimator;\r\n\r\n    private int animationSequenz;\r\n\r\n    private transient AnimationModel animationModel;\r\n\r\n    private transient HandballModel lastSavedModel;\r\n\r\n    private String comment;\r\n\r\n    private String moveName;\r\n\r\n    public HandballModel() {\r\n        listeners = new ArrayList<HandballModelListener>();\r\n        playerRemoveListener = new ArrayList<PlayerRemovedListener>();\r\n        initModel();\r\n    }\r\n\r\n    public void initModel() {\r\n        defenders = new ArrayList<Defender>();\r\n        Defender.setCounter(0);\r\n        offenders = new ArrayList<Offender>();\r\n        Offender.setCounter(0);\r\n        events = new TreeSet<MoveEvent>();\r\n        // Workaround wegen ToolBar\r\n        state = State.PLACE_OFFENDERS;\r\n        actualEvent = null;\r\n        markedPlayer = null;\r\n        firstBallOwner = null;\r\n        comment = \"\";\r\n        moveName = \"\";\r\n        resetBallPosition();\r\n        try {\r\n            lastSavedModel = (HandballModel) Main.deepCopy(this);\r\n        } catch (Exception e) {\r\n            lastSavedModel = null;\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    private void resetBallPosition() {\r\n        ball = new Ball(-500, -500);\r\n    }\r\n\r\n    public void addOffender(int x, int y) {\r\n        if (offenders.size() == MAX_OFFENDERS) {\r\n            JOptionPane.showMessageDialog(Main.getWindow(), \"Sie haben schon \" + MAX_OFFENDERS + \" Angreifer angelegt.\", \"Info:\", JOptionPane.INFORMATION_MESSAGE);\r\n        } else {\r\n            offenders.add(new Offender(x, y));\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void removePlayer(Player toRemove) {\r\n        if (eventDefinedWithPlayer(toRemove)) {\r\n            removeEventsOfPlayer(toRemove);\r\n        }\r\n        if (toRemove instanceof Offender) {\r\n            removeOffender((Offender) toRemove);\r\n        } else {\r\n            removeDefender((Defender) toRemove);\r\n        }\r\n    }\r\n\r\n    private void removeOffender(Offender toRemove) {\r\n        if (getFirstBallOwner() != null && getFirstBallOwner().equals(toRemove)) {\r\n            setFirstBallOwner(null);\r\n        }\r\n        offenders.remove(toRemove);\r\n        if ((getDefenders().size() + getOffenders().size()) == 0) {\r\n            markedPlayer = null;\r\n        }\r\n        // Spielernummer aktualisieren\r\n        Offender.setCounter(determineMaxPlayerNumber(offenders));\r\n        fireOffenderRemoved(toRemove);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void addDefender(int x, int y) {\r\n        if (defenders.size() == MAX_DEFENDERS) {\r\n            JOptionPane.showMessageDialog(Main.getWindow(), \"Sie haben schon \" + MAX_OFFENDERS + \" Verteidiger angelegt.\", \"Info:\", JOptionPane.INFORMATION_MESSAGE);\r\n        } else {\r\n            defenders.add(new Defender(x, y));\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    private void removeDefender(Defender toRemove) {\r\n        defenders.remove(toRemove);\r\n        if ((getDefenders().size() + getOffenders().size()) == 0) {\r\n            markedPlayer = null;\r\n        }\r\n        Defender.setCounter(determineMaxPlayerNumber(defenders));\r\n        fireDefenderRemoved(toRemove);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public boolean addListener(HandballModelListener o) {\r\n        return listeners.add(o);\r\n    }\r\n\r\n    public boolean removeListener(HandballModelListener o) {\r\n        return listeners.remove(o);\r\n    }\r\n\r\n    public boolean addPlayerRemovedListener(PlayerRemovedListener o) {\r\n        return playerRemoveListener.add(o);\r\n    }\r\n\r\n    public boolean removePlayerRemovedListener(PlayerRemovedListener o) {\r\n        return playerRemoveListener.remove(o);\r\n    }\r\n\r\n    private void fireModelChanged() {\r\n        setMoveName(getMoveName());\r\n        for (HandballModelListener listener : listeners) {\r\n            listener.modelChanged();\r\n        }\r\n    }\r\n\r\n    private void fireOffenderRemoved(Offender offender) {\r\n        for (PlayerRemovedListener listener : playerRemoveListener) {\r\n            listener.offenderRemoved(offender);\r\n        }\r\n    }\r\n\r\n    private void fireDefenderRemoved(Defender defender) {\r\n        for (PlayerRemovedListener listener : playerRemoveListener) {\r\n            listener.defenderRemoved(defender);\r\n        }\r\n    }\r\n\r\n    public List<Defender> getDefenders() {\r\n        return defenders;\r\n    }\r\n\r\n    public List<Offender> getOffenders() {\r\n        return offenders;\r\n    }\r\n\r\n    public State getState() {\r\n        return state;\r\n    }\r\n\r\n    public void setState(State state) {\r\n        if (state == State.EDIT) {\r\n            if (getActualMoveEvent() == null) {\r\n                // Wenn leer, dann Null, sonst letztes Move Event setzen\r\n                setActualMoveEvent(getEvents().isEmpty() ? null : (getEvents().get(getEvents().size() - 1)));\r\n            } else {\r\n                setActualMoveEvent(getActualMoveEvent());\r\n            }\r\n        }\r\n        if (state == State.PLACE_DEFENDERS || state == State.PLACE_OFFENDERS) {\r\n            if (getFirstBallOwner() != null) {\r\n                setBallOwner(getFirstBallOwner());\r\n            }\r\n            setActualMoveEvent(null);\r\n        }\r\n        this.state = state;\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void addMoveEvent(MoveEvent event) {\r\n        events.add(event);\r\n        if (state == State.EDIT) {\r\n            setActualMoveEvent(event);\r\n            state = State.EDIT_EVENT;\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void removeMoveEvent(MoveEvent event) {\r\n        events.remove(event);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public List<MoveEvent> getEvents() {\r\n        List<MoveEvent> list = new ArrayList<MoveEvent>(events);\r\n        return list;\r\n    }\r\n\r\n    public SortedSet<MoveEvent> getSortedEvents() {\r\n        return events;\r\n    }\r\n\r\n    public int getAcutalSequenceNr() {\r\n        if (actualEvent == null)\r\n            return 0;\r\n        else {\r\n            return actualEvent.getSequenceNr();\r\n        }\r\n    }\r\n\r\n    public void setActualMoveEvent(MoveEvent event) {\r\n        if (this.actualEvent != null) {\r\n            this.actualEvent.setMarked(false);\r\n        }\r\n        this.actualEvent = event;\r\n        computePlayerPositions();\r\n        // aktuellen Spieler setzen\r\n        setMarkedPlayer((event == null) ? null : event.getPlayer());\r\n        if (actualEvent != null) {\r\n            if (!actualEvent.isDestinationPointSet()) {\r\n                state = State.EDIT_EVENT;\r\n            } else {\r\n                if (state == State.FULL_ANIMATION_ENDED) {\r\n                    state = State.ANIMATION;\r\n                } else if (state != State.ANIMATION && state != State.ANIMATION_RUNNING) {\r\n                    state = State.EDIT;\r\n                }\r\n            }\r\n            actualEvent.setMarked(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setDestinationPointForEvent(MoveEvent event, int x, int y, boolean temp) {\r\n        event.setDestinationPoint(x, y, temp);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setControlPointForEvent(MoveEvent event, int x, int y, boolean temp) {\r\n        event.setControlPoint(x, y, temp);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setMovePointTo(MovePoint point, int x, int y) {\r\n        actualEvent.setPoint(point, x, y);\r\n        fireModelChanged();\r\n    }\r\n\r\n    private void computePlayerPositions() {\r\n        computePlayerPositions(getAcutalSequenceNr());\r\n    }\r\n\r\n    public void computePlayerPositions(int seqNr) {\r\n        // Spieler Positionen auf Ausgangsstellung\r\n        for (Player offender : offenders) {\r\n            offender.resetPosition();\r\n        }\r\n        for (Player defender : defenders) {\r\n            defender.resetPosition();\r\n        }\r\n        if (seqNr == 1) {\r\n            setBallOwner(firstBallOwner);\r\n        }\r\n        // alle Events mit kleinerer Sequenznummer verarbeiten\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() < seqNr) {\r\n                if (event instanceof PassEvent) {\r\n                    // Ball an anderen Spieler �bertragen\r\n                    setBallOwner(((PassEvent) event).getDestinationPlayer());\r\n                } else {\r\n                    if (event.getDestinationX() > -1 && event.getDestinationY() > -1) {\r\n                        event.getPlayer().setCurrentPosition(event.getDestinationX(), event.getDestinationY());\r\n                    }\r\n                }\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    public MoveEvent getActualMoveEvent() {\r\n        return actualEvent;\r\n    }\r\n\r\n    public Player getMarkedPlayer() {\r\n        return markedPlayer;\r\n    }\r\n\r\n    public void setMarkedPlayer(Player markedPlayer) {\r\n        // alten markierten Spieler demarkieren\r\n        if (this.markedPlayer != null) {\r\n            this.markedPlayer.setMarked(false);\r\n        }\r\n        // evtl. neuen Spieler markieren\r\n        this.markedPlayer = markedPlayer;\r\n        if (markedPlayer != null) {\r\n            markedPlayer.setMarked(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setHighLightedItem(HighlightableItem item) {\r\n        if (this.hightlightedItem != null) {\r\n            // altes Item zur�cksetzen\r\n            this.hightlightedItem.setHighlight(false);\r\n        }\r\n        this.hightlightedItem = item;\r\n        if (item != null) {\r\n            hightlightedItem.setHighlight(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public HighlightableItem getHightligtedItem() {\r\n        return hightlightedItem;\r\n    }\r\n\r\n    public Player getNearestPlayer(int x, int y) {\r\n        List<Player> all = new ArrayList<Player>(offenders);\r\n        all.addAll(defenders);\r\n        return findNearestPlayer(x, y, all);\r\n    }\r\n\r\n    public Offender getNearestOffender(int x, int y) {\r\n        List<Player> all = new ArrayList<Player>(offenders);\r\n        return (Offender) findNearestPlayer(x, y, all);\r\n    }\r\n\r\n    private Player findNearestPlayer(int x, int y, List<Player> players) {\r\n        double entfernung = Double.MAX_VALUE;\r\n        Player temp = null;\r\n        for (Player player : players) {\r\n            int player_x = player.getCurrent_x();\r\n            int player_y = player.getCurrent_y();\r\n            double tempEntfernung = Point2D.distance(x, y, player_x, player_y);\r\n            // Wenn naeher als der MARK_RADIUS\r\n            if (!(tempEntfernung > MARK_RADIUS)) {\r\n                if (tempEntfernung < entfernung) {\r\n                    temp = player;\r\n                    entfernung = tempEntfernung;\r\n                }\r\n            }\r\n        }\r\n        return temp;\r\n    }\r\n\r\n    public MovePoint getNearestMovePoint(int x, int y) {\r\n        MovePoint point = null;\r\n        if (actualEvent != null) {\r\n            double entfernung = Double.MAX_VALUE;\r\n            if (actualEvent.isDestinationPointSet()) {\r\n                int destination_x = actualEvent.getDestinationX();\r\n                int destination_y = actualEvent.getDestinationY();\r\n                double tempEntfernung = Point2D.distance(x, y, destination_x, destination_y);\r\n                // Wenn naeher als der MARK_RADIUS\r\n                if (!(tempEntfernung > MARK_RADIUS)) {\r\n                    if (tempEntfernung < entfernung) {\r\n                        point = actualEvent.getDestinationPoint();\r\n                        entfernung = tempEntfernung;\r\n                    }\r\n                }\r\n            }\r\n            if (actualEvent.isControlPointSet()) {\r\n                int controlPoint_x = actualEvent.getControlPointX();\r\n                int controlPoint_y = actualEvent.getControlPointY();\r\n                double tempEntfernung = Point2D.distance(x, y, controlPoint_x, controlPoint_y);\r\n                // Wenn naeher als der MARK_RADIUS\r\n                if (!(tempEntfernung > MARK_RADIUS)) {\r\n                    if (tempEntfernung < entfernung) {\r\n                        point = actualEvent.getControlPoint();\r\n                        entfernung = tempEntfernung;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return point;\r\n    }\r\n\r\n    public HighlightableItem getNearestHighlightableItem(int x, int y) {\r\n        HighlightableItem temp = null;\r\n        temp = getNearestMovePoint(x, y);\r\n        if (temp == null) {\r\n            temp = getNearestPlayer(x, y);\r\n        }\r\n        return temp;\r\n    }\r\n\r\n    public void movePlayerTo(Player actualPlayer, int x, int y) {\r\n        if (getAcutalSequenceNr() == 0) {\r\n            actualPlayer.setStart_x(x);\r\n            actualPlayer.setStart_y(y);\r\n        }\r\n        // Ansonsten muss die Position im entsprechenden Ereignis gesetzt\r\n        // werden\r\n        // Startposition darf nur im Angreifer/Verteidiger-Modus ge�ndert werden\r\n        fireModelChanged();\r\n    }\r\n\r\n    public boolean isSaved() {\r\n        boolean changed = false;\r\n        if (lastSavedModel != null) {\r\n            //Spielzugnamen vergleichen\r\n            if (lastSavedModel.getMoveName() != null) {\r\n                if (getMoveName() == null || !lastSavedModel.getMoveName().equals(getMoveName())) {\r\n                    return false;\r\n                }\r\n            } else if (getMoveName() != null) {\r\n                //alt: kein Name <-> neu: Name vorhanden\r\n                return false;\r\n            }\r\n            //Ueberprüfen ob Angreifer und Verteidiger unterschiedlich\r\n            // zuerst Spielerlisten vergleichen\r\n            if (changedPlayerList(getOffenders().toArray(new Player[getOffenders().size()]), lastSavedModel.getOffenders().toArray(new Player[lastSavedModel.getOffenders().size()])) || changedPlayerList(getDefenders().toArray(new Player[getDefenders().size()]), lastSavedModel.getDefenders().toArray(new Player[lastSavedModel.getDefenders().size()]))) {\r\n                changed = true;\r\n            } else {\r\n                List<MoveEvent> newEvents = getEvents();\r\n                List<MoveEvent> oldEvents = lastSavedModel.getEvents();\r\n                if (newEvents.size() == oldEvents.size()) {\r\n                    for (int i = 0; i < newEvents.size(); i++) {\r\n                        if (!newEvents.get(i).equals(oldEvents.get(i))) {\r\n                            changed = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                } else {\r\n                    changed = true;\r\n                }\r\n            }\r\n            if (!changed && (getFirstBallOwner() != null || lastSavedModel.getFirstBallOwner() != null)) {\r\n                changed = (getFirstBallOwner() == null) ^ (lastSavedModel.getFirstBallOwner() == null);\r\n                if (!changed) {\r\n                    changed = !getFirstBallOwner().equals(lastSavedModel.getFirstBallOwner());\r\n                }\r\n            }\r\n            // wurde Kommentar geändert?\r\n            if (!changed) {\r\n                if (comment == null || comment.equals(\"\")) {\r\n                    if (lastSavedModel.getComment() != null && !lastSavedModel.getComment().equals(\"\")) {\r\n                        changed = true;\r\n                    }\r\n                } else if (lastSavedModel.getComment() != null) {\r\n                    if (!lastSavedModel.getComment().equals(comment)) {\r\n                        changed = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return !changed;\r\n    }\r\n\r\n    private boolean changedPlayerList(Player[] newList, Player[] oldList) {\r\n        boolean changed = false;\r\n        int size = newList.length;\r\n        int sizeOld = oldList.length;\r\n        if (size == sizeOld) {\r\n            for (int i = 0; i < size; i++) {\r\n                if (!newList[i].equals(oldList[i])) {\r\n                    changed = true;\r\n                    break;\r\n                }\r\n            }\r\n        } else {\r\n            changed = true;\r\n        }\r\n        return changed;\r\n    }\r\n\r\n    public void initWithLoadedModel(HandballModel loadedModel) {\r\n        initModel();\r\n        offenders = loadedModel.getOffenders();\r\n        defenders = loadedModel.getDefenders();\r\n        events = loadedModel.getSortedEvents();\r\n        Offender.setCounter(determineMaxPlayerNumber(offenders));\r\n        Defender.setCounter(determineMaxPlayerNumber(defenders));\r\n        setFirstBallOwner(loadedModel.getFirstBallOwner());\r\n        setState(loadedModel.getState());\r\n        setActualMoveEvent(loadedModel.getActualMoveEvent());\r\n        setComment(loadedModel.getComment());\r\n        // zur Sicherheit\r\n        if (getComment() == null) {\r\n            setComment(\"\");\r\n        }\r\n        setMoveName(loadedModel.getMoveName());\r\n        markAsSaved(loadedModel);\r\n        fireModelChanged();\r\n    }\r\n\r\n    private int determineMaxPlayerNumber(List players) {\r\n        int max = 0;\r\n        for (Object o : players) {\r\n            if (o instanceof Player) {\r\n                Player player = (Player) o;\r\n                if (player.getPlayerNumber() > max) {\r\n                    max = player.getPlayerNumber();\r\n                }\r\n            }\r\n        }\r\n        return max;\r\n    }\r\n\r\n    public void markAsSaved(HandballModel model) {\r\n        try {\r\n            lastSavedModel = (HandballModel) Main.deepCopy(model);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            lastSavedModel = null;\r\n        }\r\n    }\r\n\r\n    public void setDelay(int eventIndex, int delay) {\r\n        getEvents().get(eventIndex).setDelay(delay);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setBallOwner(Offender ballOwner) {\r\n        if (this.ballOwner != null) {\r\n            this.ballOwner.setHasBall(false);\r\n        }\r\n        this.ballOwner = ballOwner;\r\n        if (ballOwner != null) {\r\n            ballOwner.setHasBall(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setBallOwnerSilent(Offender ballOwner) {\r\n        if (this.ballOwner != null) {\r\n            this.ballOwner.setHasBall(false);\r\n        }\r\n        this.ballOwner = ballOwner;\r\n        if (ballOwner != null) {\r\n            ballOwner.setHasBall(true);\r\n        }\r\n        // fireModelChanged();\r\n    }\r\n\r\n    public void startAnimation(boolean onlyActualSequence) {\r\n        setState(State.ANIMATION_RUNNING);\r\n        MoveEvent event = actualEvent;\r\n        if (event == null) {\r\n            event = getEvents().get(0);\r\n        }\r\n        setActualMoveEvent(event);\r\n        animationSequenz = event.getSequenceNr();\r\n        animationModel = new AnimationModel(event, this, onlyActualSequence);\r\n        runningAnimator = new Animator(this);\r\n        computePlayerPositions(animationSequenz);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void pauseAnimation(boolean pause) {\r\n        if (pause) {\r\n            runningAnimator.setPause(true);\r\n        } else {\r\n            runningAnimator.setPause(false);\r\n        }\r\n    }\r\n\r\n    public void initAnimation() {\r\n    }\r\n\r\n    public boolean nextAnimationStep() {\r\n        boolean finished = animationModel.nextStep();\r\n        if (finished) {\r\n            if (animationModel.isOnlyOneSequence()) {\r\n                setState(State.ANIMATION);\r\n                // n�chste Sequzenz ausw�hlen (einfaches sequentielles Anschauen des Spielzugs)\r\n                int nextSeq = (getAcutalSequenceNr() == getHighestSequenceNumber()) ? getAcutalSequenceNr() : getAcutalSequenceNr() + 1;\r\n                List<MoveEvent> nextSeqEvents = getMoveEvents(nextSeq);\r\n                if (nextSeqEvents.get(0) != null) {\r\n                    setActualMoveEvent(nextSeqEvents.get(0));\r\n                }\r\n            } else {\r\n                setState(State.FULL_ANIMATION_ENDED);\r\n            }\r\n        } else {\r\n            fireModelChanged();\r\n        }\r\n        return finished;\r\n    }\r\n\r\n    public void stopAnimation() {\r\n        setState(State.ANIMATION);\r\n        runningAnimator = null;\r\n        setActualMoveEvent(getActualMoveEvent());\r\n    }\r\n\r\n    public boolean isMarkedPlayerAddable() {\r\n        int seq = getAcutalSequenceNr();\r\n        return !events.contains(new MoveEvent(markedPlayer, seq));\r\n    }\r\n\r\n    public boolean passEventDefined(int seq) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() == seq && event instanceof PassEvent) {\r\n                defined = true;\r\n                break;\r\n            }\r\n            if (event.getSequenceNr() > seq) {\r\n                break;\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public boolean passEventDefined() {\r\n        return passEventDefined(getAcutalSequenceNr());\r\n    }\r\n\r\n    public boolean passEventDefinedAfter(int seq) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if ((event instanceof PassEvent) && (event.getSequenceNr() > seq)) {\r\n                defined = true;\r\n                break;\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public boolean eventDefinedAfter(int seq) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() > seq) {\r\n                defined = true;\r\n                break;\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public Ball getBall() {\r\n        return ball;\r\n    }\r\n\r\n    public void setFirstBallOwner(Offender offender) {\r\n        this.firstBallOwner = offender;\r\n        setBallOwner(offender);\r\n        if (firstBallOwner == null) {\r\n            resetBallPosition();\r\n        }\r\n    }\r\n\r\n    public Offender getFirstBallOwner() {\r\n        return firstBallOwner;\r\n    }\r\n\r\n    public boolean hasPlayerBallInNextSequence(Player player) {\r\n        PassEvent pass = null;\r\n        int seq = getAcutalSequenceNr();\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() == seq && event instanceof PassEvent) {\r\n                pass = (PassEvent) event;\r\n                break;\r\n            }\r\n            if (event.getSequenceNr() > seq) {\r\n                break;\r\n            }\r\n        }\r\n        if (pass != null && pass.getDestinationPlayer() != null) {\r\n            return pass.getDestinationPlayer().equals(player) && !passEventDefined(seq + 1);\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public boolean isBallSet() {\r\n        return ballOwner != null;\r\n    }\r\n\r\n    public boolean isGoalPassSet() {\r\n        boolean defined = false;\r\n        for (MoveEvent event : getEvents()) {\r\n            if (event instanceof PassEvent) {\r\n                PassEvent pass = (PassEvent) event;\r\n                if (pass.isGoalPass()) {\r\n                    defined = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public void moveBallTo(int x, int y) {\r\n        ball.setCurrent_x(x);\r\n        ball.setCurrent_y(y);\r\n    }\r\n\r\n    public List<MoveEvent> getActualMoveEvents() {\r\n        return getMoveEvents(getAcutalSequenceNr());\r\n    }\r\n\r\n    public List<MoveEvent> getMoveEvents(int sequenceNr) {\r\n        List<MoveEvent> sequenceEvents = new ArrayList<MoveEvent>();\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() == sequenceNr) {\r\n                sequenceEvents.add(event);\r\n            } else if (event.getSequenceNr() > getAcutalSequenceNr()) {\r\n                break;\r\n            }\r\n        }\r\n        return sequenceEvents;\r\n    }\r\n\r\n    /**\r\n     * Löscht das Aktuelle Ereignis und ALLE Folgenden\r\n     */\r\n    public void removeEventsAfter() {\r\n        MoveEvent event = getActualMoveEvent();\r\n        List<MoveEvent> toDeleteEvents = new ArrayList<MoveEvent>();\r\n        int sequenceNr = event.getSequenceNr();\r\n        // zu loeschende Events sammeln\r\n        for (MoveEvent evt : getEvents()) {\r\n            if (evt.getSequenceNr() > sequenceNr) {\r\n                // Event ist hoeher, also loeschen\r\n                toDeleteEvents.add(evt);\r\n            }\r\n        }\r\n        toDeleteEvents.add(event);\r\n        // gesammelte Events loeschen\r\n        for (MoveEvent deleteEvent : toDeleteEvents) {\r\n            removeMoveEvent(deleteEvent);\r\n        }\r\n        setActualMoveEvent((getEvents().size() > 0) ? getEvents().get(getEvents().size() - 1) : null);\r\n        fireModelChanged();\r\n    }\r\n\r\n    /**\r\n     * Löscht die Ereignisse (auch P�sse) des �bergebenen Spielers. Und die\r\n     * evtl. davon abh�ngigen Folgep�sse\r\n     *\r\n     * @param player\r\n     */\r\n    private void removeEventsOfPlayer(Player player) {\r\n        List<MoveEvent> toDeleteEvents = new ArrayList<MoveEvent>();\r\n        boolean playerInvolved = false;\r\n        // zu loeschende Events sammeln\r\n        for (MoveEvent evt : getEvents()) {\r\n            // Pass?\r\n            if (evt instanceof PassEvent) {\r\n                PassEvent pass = (PassEvent) evt;\r\n                // War ein Pass zu dem Spieler? oder Spieler passt selbst?\r\n                if (pass.getDestinationPlayer().equals(player) || pass.getPlayer().equals(player)) {\r\n                    playerInvolved = true;\r\n                }\r\n                // War Spieler an einem Pass beteiligt?\r\n                if (playerInvolved) {\r\n                    toDeleteEvents.add(pass);\r\n                    continue;\r\n                }\r\n            }\r\n            if (evt.getPlayer().equals(player)) {\r\n                toDeleteEvents.add(evt);\r\n            }\r\n        }\r\n        // gesammelte Events loeschen\r\n        for (MoveEvent deleteEvent : toDeleteEvents) {\r\n            removeMoveEvent(deleteEvent);\r\n        }\r\n        setActualMoveEvent((getEvents().size() > 0) ? getEvents().get(getEvents().size() - 1) : null);\r\n    }\r\n\r\n    public boolean eventDefinedWithPlayer(Player player) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if (event.getPlayer().equals(player)) {\r\n                defined = true;\r\n                break;\r\n            }\r\n            if (event instanceof PassEvent) {\r\n                PassEvent pass = (PassEvent) event;\r\n                if (pass.getDestinationPlayer().equals(player)) {\r\n                    defined = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public int getHighestSequenceNumber() {\r\n        if (events.size() == 0) {\r\n            return 0;\r\n        } else {\r\n            return events.last().getSequenceNr();\r\n        }\r\n    }\r\n\r\n    public String getMoveName() {\r\n        return moveName;\r\n    }\r\n\r\n    public void setMoveName(String moveName) {\r\n        this.moveName = moveName;\r\n        if (Main.getWindow() != null) {\r\n            StringBuffer buffer = new StringBuffer(APP_NAME);\r\n            buffer.append(\" - \");\r\n            if (moveName == null || moveName.equals(\"\")) {\r\n                buffer.append(\"Unbenannt\");\r\n                // Titelleiste aktualisieren\r\n            } else {\r\n                buffer.append(moveName);\r\n            }\r\n            if (!isSaved()) {\r\n                buffer.append(\"*\");\r\n            }\r\n            Main.getWindow().setTitle(buffer.toString());\r\n        }\r\n    }\r\n\r\n    public String getComment() {\r\n        if (comment == null) {\r\n            comment = \"\";\r\n        }\r\n        return comment;\r\n    }\r\n\r\n    public void setComment(String comment) {\r\n        this.comment = comment;\r\n        fireModelChanged();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/model/HandballModelTest7.java",
		"test_prompt": "// HandballModelTest7.java\npackage visu.handball.moves.model;\n\nimport java.awt.geom.Point2D;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\nimport javax.swing.JOptionPane;\nimport visu.handball.moves.Main;\nimport visu.handball.moves.model.animation.AnimationModel;\nimport visu.handball.moves.model.animation.Animator;\nimport visu.handball.moves.model.player.Ball;\nimport visu.handball.moves.model.player.Defender;\nimport visu.handball.moves.model.player.HighlightableItem;\nimport visu.handball.moves.model.player.MovePoint;\nimport visu.handball.moves.model.player.Offender;\nimport visu.handball.moves.model.player.Player;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HandballModel}.\n* It contains ten unit test cases for the {@link HandballModel#passEventDefined(int)} method.\n*/\nclass HandballModelTest7 {"
	},
	{
		"original_code": "// HandballModel.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.model;\r\n\r\nimport java.awt.geom.Point2D;\r\nimport java.io.Serializable;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.SortedSet;\r\nimport java.util.TreeSet;\r\nimport javax.swing.JOptionPane;\r\nimport visu.handball.moves.Main;\r\nimport visu.handball.moves.model.animation.AnimationModel;\r\nimport visu.handball.moves.model.animation.Animator;\r\nimport visu.handball.moves.model.player.Ball;\r\nimport visu.handball.moves.model.player.Defender;\r\nimport visu.handball.moves.model.player.HighlightableItem;\r\nimport visu.handball.moves.model.player.MovePoint;\r\nimport visu.handball.moves.model.player.Offender;\r\nimport visu.handball.moves.model.player.Player;\r\n\r\npublic class HandballModel implements Serializable {\r\n\r\n    private static final long serialVersionUID = -5372891552466311536L;\r\n\r\n    public enum State {\r\n\r\n        INITIAL,\r\n        PLACE_OFFENDERS,\r\n        PLACE_DEFENDERS,\r\n        PLACE_BALL,\r\n        EDIT,\r\n        EDIT_EVENT,\r\n        ANIMATION,\r\n        ANIMATION_RUNNING,\r\n        FULL_ANIMATION_ENDED\r\n    }\r\n\r\n    private static final int MAX_OFFENDERS = 6;\r\n\r\n    private static final int MAX_DEFENDERS = 6;\r\n\r\n    private static final int MARK_RADIUS = 12;\r\n\r\n    private static final String APP_NAME = \"jHandballMoves\";\r\n\r\n    private transient List<HandballModelListener> listeners;\r\n\r\n    private transient List<PlayerRemovedListener> playerRemoveListener;\r\n\r\n    private List<Defender> defenders;\r\n\r\n    private List<Offender> offenders;\r\n\r\n    private SortedSet<MoveEvent> events;\r\n\r\n    private State state;\r\n\r\n    private MoveEvent actualEvent;\r\n\r\n    private Player markedPlayer;\r\n\r\n    private HighlightableItem hightlightedItem;\r\n\r\n    private Offender ballOwner;\r\n\r\n    private Ball ball;\r\n\r\n    private Offender firstBallOwner;\r\n\r\n    private transient Animator runningAnimator;\r\n\r\n    private int animationSequenz;\r\n\r\n    private transient AnimationModel animationModel;\r\n\r\n    private transient HandballModel lastSavedModel;\r\n\r\n    private String comment;\r\n\r\n    private String moveName;\r\n\r\n    public HandballModel() {\r\n        listeners = new ArrayList<HandballModelListener>();\r\n        playerRemoveListener = new ArrayList<PlayerRemovedListener>();\r\n        initModel();\r\n    }\r\n\r\n    public void initModel() {\r\n        defenders = new ArrayList<Defender>();\r\n        Defender.setCounter(0);\r\n        offenders = new ArrayList<Offender>();\r\n        Offender.setCounter(0);\r\n        events = new TreeSet<MoveEvent>();\r\n        // Workaround wegen ToolBar\r\n        state = State.PLACE_OFFENDERS;\r\n        actualEvent = null;\r\n        markedPlayer = null;\r\n        firstBallOwner = null;\r\n        comment = \"\";\r\n        moveName = \"\";\r\n        resetBallPosition();\r\n        try {\r\n            lastSavedModel = (HandballModel) Main.deepCopy(this);\r\n        } catch (Exception e) {\r\n            lastSavedModel = null;\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    private void resetBallPosition() {\r\n        ball = new Ball(-500, -500);\r\n    }\r\n\r\n    public void addOffender(int x, int y) {\r\n        if (offenders.size() == MAX_OFFENDERS) {\r\n            JOptionPane.showMessageDialog(Main.getWindow(), \"Sie haben schon \" + MAX_OFFENDERS + \" Angreifer angelegt.\", \"Info:\", JOptionPane.INFORMATION_MESSAGE);\r\n        } else {\r\n            offenders.add(new Offender(x, y));\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void removePlayer(Player toRemove) {\r\n        if (eventDefinedWithPlayer(toRemove)) {\r\n            removeEventsOfPlayer(toRemove);\r\n        }\r\n        if (toRemove instanceof Offender) {\r\n            removeOffender((Offender) toRemove);\r\n        } else {\r\n            removeDefender((Defender) toRemove);\r\n        }\r\n    }\r\n\r\n    private void removeOffender(Offender toRemove) {\r\n        if (getFirstBallOwner() != null && getFirstBallOwner().equals(toRemove)) {\r\n            setFirstBallOwner(null);\r\n        }\r\n        offenders.remove(toRemove);\r\n        if ((getDefenders().size() + getOffenders().size()) == 0) {\r\n            markedPlayer = null;\r\n        }\r\n        // Spielernummer aktualisieren\r\n        Offender.setCounter(determineMaxPlayerNumber(offenders));\r\n        fireOffenderRemoved(toRemove);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void addDefender(int x, int y) {\r\n        if (defenders.size() == MAX_DEFENDERS) {\r\n            JOptionPane.showMessageDialog(Main.getWindow(), \"Sie haben schon \" + MAX_OFFENDERS + \" Verteidiger angelegt.\", \"Info:\", JOptionPane.INFORMATION_MESSAGE);\r\n        } else {\r\n            defenders.add(new Defender(x, y));\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    private void removeDefender(Defender toRemove) {\r\n        defenders.remove(toRemove);\r\n        if ((getDefenders().size() + getOffenders().size()) == 0) {\r\n            markedPlayer = null;\r\n        }\r\n        Defender.setCounter(determineMaxPlayerNumber(defenders));\r\n        fireDefenderRemoved(toRemove);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public boolean addListener(HandballModelListener o) {\r\n        return listeners.add(o);\r\n    }\r\n\r\n    public boolean removeListener(HandballModelListener o) {\r\n        return listeners.remove(o);\r\n    }\r\n\r\n    public boolean addPlayerRemovedListener(PlayerRemovedListener o) {\r\n        return playerRemoveListener.add(o);\r\n    }\r\n\r\n    public boolean removePlayerRemovedListener(PlayerRemovedListener o) {\r\n        return playerRemoveListener.remove(o);\r\n    }\r\n\r\n    private void fireModelChanged() {\r\n        setMoveName(getMoveName());\r\n        for (HandballModelListener listener : listeners) {\r\n            listener.modelChanged();\r\n        }\r\n    }\r\n\r\n    private void fireOffenderRemoved(Offender offender) {\r\n        for (PlayerRemovedListener listener : playerRemoveListener) {\r\n            listener.offenderRemoved(offender);\r\n        }\r\n    }\r\n\r\n    private void fireDefenderRemoved(Defender defender) {\r\n        for (PlayerRemovedListener listener : playerRemoveListener) {\r\n            listener.defenderRemoved(defender);\r\n        }\r\n    }\r\n\r\n    public List<Defender> getDefenders() {\r\n        return defenders;\r\n    }\r\n\r\n    public List<Offender> getOffenders() {\r\n        return offenders;\r\n    }\r\n\r\n    public State getState() {\r\n        return state;\r\n    }\r\n\r\n    public void setState(State state) {\r\n        if (state == State.EDIT) {\r\n            if (getActualMoveEvent() == null) {\r\n                // Wenn leer, dann Null, sonst letztes Move Event setzen\r\n                setActualMoveEvent(getEvents().isEmpty() ? null : (getEvents().get(getEvents().size() - 1)));\r\n            } else {\r\n                setActualMoveEvent(getActualMoveEvent());\r\n            }\r\n        }\r\n        if (state == State.PLACE_DEFENDERS || state == State.PLACE_OFFENDERS) {\r\n            if (getFirstBallOwner() != null) {\r\n                setBallOwner(getFirstBallOwner());\r\n            }\r\n            setActualMoveEvent(null);\r\n        }\r\n        this.state = state;\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void addMoveEvent(MoveEvent event) {\r\n        events.add(event);\r\n        if (state == State.EDIT) {\r\n            setActualMoveEvent(event);\r\n            state = State.EDIT_EVENT;\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void removeMoveEvent(MoveEvent event) {\r\n        events.remove(event);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public List<MoveEvent> getEvents() {\r\n        List<MoveEvent> list = new ArrayList<MoveEvent>(events);\r\n        return list;\r\n    }\r\n\r\n    public SortedSet<MoveEvent> getSortedEvents() {\r\n        return events;\r\n    }\r\n\r\n    public int getAcutalSequenceNr() {\r\n        if (actualEvent == null)\r\n            return 0;\r\n        else {\r\n            return actualEvent.getSequenceNr();\r\n        }\r\n    }\r\n\r\n    public void setActualMoveEvent(MoveEvent event) {\r\n        if (this.actualEvent != null) {\r\n            this.actualEvent.setMarked(false);\r\n        }\r\n        this.actualEvent = event;\r\n        computePlayerPositions();\r\n        // aktuellen Spieler setzen\r\n        setMarkedPlayer((event == null) ? null : event.getPlayer());\r\n        if (actualEvent != null) {\r\n            if (!actualEvent.isDestinationPointSet()) {\r\n                state = State.EDIT_EVENT;\r\n            } else {\r\n                if (state == State.FULL_ANIMATION_ENDED) {\r\n                    state = State.ANIMATION;\r\n                } else if (state != State.ANIMATION && state != State.ANIMATION_RUNNING) {\r\n                    state = State.EDIT;\r\n                }\r\n            }\r\n            actualEvent.setMarked(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setDestinationPointForEvent(MoveEvent event, int x, int y, boolean temp) {\r\n        event.setDestinationPoint(x, y, temp);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setControlPointForEvent(MoveEvent event, int x, int y, boolean temp) {\r\n        event.setControlPoint(x, y, temp);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setMovePointTo(MovePoint point, int x, int y) {\r\n        actualEvent.setPoint(point, x, y);\r\n        fireModelChanged();\r\n    }\r\n\r\n    private void computePlayerPositions() {\r\n        computePlayerPositions(getAcutalSequenceNr());\r\n    }\r\n\r\n    public void computePlayerPositions(int seqNr) {\r\n        // Spieler Positionen auf Ausgangsstellung\r\n        for (Player offender : offenders) {\r\n            offender.resetPosition();\r\n        }\r\n        for (Player defender : defenders) {\r\n            defender.resetPosition();\r\n        }\r\n        if (seqNr == 1) {\r\n            setBallOwner(firstBallOwner);\r\n        }\r\n        // alle Events mit kleinerer Sequenznummer verarbeiten\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() < seqNr) {\r\n                if (event instanceof PassEvent) {\r\n                    // Ball an anderen Spieler �bertragen\r\n                    setBallOwner(((PassEvent) event).getDestinationPlayer());\r\n                } else {\r\n                    if (event.getDestinationX() > -1 && event.getDestinationY() > -1) {\r\n                        event.getPlayer().setCurrentPosition(event.getDestinationX(), event.getDestinationY());\r\n                    }\r\n                }\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    public MoveEvent getActualMoveEvent() {\r\n        return actualEvent;\r\n    }\r\n\r\n    public Player getMarkedPlayer() {\r\n        return markedPlayer;\r\n    }\r\n\r\n    public void setMarkedPlayer(Player markedPlayer) {\r\n        // alten markierten Spieler demarkieren\r\n        if (this.markedPlayer != null) {\r\n            this.markedPlayer.setMarked(false);\r\n        }\r\n        // evtl. neuen Spieler markieren\r\n        this.markedPlayer = markedPlayer;\r\n        if (markedPlayer != null) {\r\n            markedPlayer.setMarked(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setHighLightedItem(HighlightableItem item) {\r\n        if (this.hightlightedItem != null) {\r\n            // altes Item zur�cksetzen\r\n            this.hightlightedItem.setHighlight(false);\r\n        }\r\n        this.hightlightedItem = item;\r\n        if (item != null) {\r\n            hightlightedItem.setHighlight(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public HighlightableItem getHightligtedItem() {\r\n        return hightlightedItem;\r\n    }\r\n\r\n    public Player getNearestPlayer(int x, int y) {\r\n        List<Player> all = new ArrayList<Player>(offenders);\r\n        all.addAll(defenders);\r\n        return findNearestPlayer(x, y, all);\r\n    }\r\n\r\n    public Offender getNearestOffender(int x, int y) {\r\n        List<Player> all = new ArrayList<Player>(offenders);\r\n        return (Offender) findNearestPlayer(x, y, all);\r\n    }\r\n\r\n    private Player findNearestPlayer(int x, int y, List<Player> players) {\r\n        double entfernung = Double.MAX_VALUE;\r\n        Player temp = null;\r\n        for (Player player : players) {\r\n            int player_x = player.getCurrent_x();\r\n            int player_y = player.getCurrent_y();\r\n            double tempEntfernung = Point2D.distance(x, y, player_x, player_y);\r\n            // Wenn naeher als der MARK_RADIUS\r\n            if (!(tempEntfernung > MARK_RADIUS)) {\r\n                if (tempEntfernung < entfernung) {\r\n                    temp = player;\r\n                    entfernung = tempEntfernung;\r\n                }\r\n            }\r\n        }\r\n        return temp;\r\n    }\r\n\r\n    public MovePoint getNearestMovePoint(int x, int y) {\r\n        MovePoint point = null;\r\n        if (actualEvent != null) {\r\n            double entfernung = Double.MAX_VALUE;\r\n            if (actualEvent.isDestinationPointSet()) {\r\n                int destination_x = actualEvent.getDestinationX();\r\n                int destination_y = actualEvent.getDestinationY();\r\n                double tempEntfernung = Point2D.distance(x, y, destination_x, destination_y);\r\n                // Wenn naeher als der MARK_RADIUS\r\n                if (!(tempEntfernung > MARK_RADIUS)) {\r\n                    if (tempEntfernung < entfernung) {\r\n                        point = actualEvent.getDestinationPoint();\r\n                        entfernung = tempEntfernung;\r\n                    }\r\n                }\r\n            }\r\n            if (actualEvent.isControlPointSet()) {\r\n                int controlPoint_x = actualEvent.getControlPointX();\r\n                int controlPoint_y = actualEvent.getControlPointY();\r\n                double tempEntfernung = Point2D.distance(x, y, controlPoint_x, controlPoint_y);\r\n                // Wenn naeher als der MARK_RADIUS\r\n                if (!(tempEntfernung > MARK_RADIUS)) {\r\n                    if (tempEntfernung < entfernung) {\r\n                        point = actualEvent.getControlPoint();\r\n                        entfernung = tempEntfernung;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return point;\r\n    }\r\n\r\n    public HighlightableItem getNearestHighlightableItem(int x, int y) {\r\n        HighlightableItem temp = null;\r\n        temp = getNearestMovePoint(x, y);\r\n        if (temp == null) {\r\n            temp = getNearestPlayer(x, y);\r\n        }\r\n        return temp;\r\n    }\r\n\r\n    public void movePlayerTo(Player actualPlayer, int x, int y) {\r\n        if (getAcutalSequenceNr() == 0) {\r\n            actualPlayer.setStart_x(x);\r\n            actualPlayer.setStart_y(y);\r\n        }\r\n        // Ansonsten muss die Position im entsprechenden Ereignis gesetzt\r\n        // werden\r\n        // Startposition darf nur im Angreifer/Verteidiger-Modus ge�ndert werden\r\n        fireModelChanged();\r\n    }\r\n\r\n    public boolean isSaved() {\r\n        boolean changed = false;\r\n        if (lastSavedModel != null) {\r\n            //Spielzugnamen vergleichen\r\n            if (lastSavedModel.getMoveName() != null) {\r\n                if (getMoveName() == null || !lastSavedModel.getMoveName().equals(getMoveName())) {\r\n                    return false;\r\n                }\r\n            } else if (getMoveName() != null) {\r\n                //alt: kein Name <-> neu: Name vorhanden\r\n                return false;\r\n            }\r\n            //Ueberprüfen ob Angreifer und Verteidiger unterschiedlich\r\n            // zuerst Spielerlisten vergleichen\r\n            if (changedPlayerList(getOffenders().toArray(new Player[getOffenders().size()]), lastSavedModel.getOffenders().toArray(new Player[lastSavedModel.getOffenders().size()])) || changedPlayerList(getDefenders().toArray(new Player[getDefenders().size()]), lastSavedModel.getDefenders().toArray(new Player[lastSavedModel.getDefenders().size()]))) {\r\n                changed = true;\r\n            } else {\r\n                List<MoveEvent> newEvents = getEvents();\r\n                List<MoveEvent> oldEvents = lastSavedModel.getEvents();\r\n                if (newEvents.size() == oldEvents.size()) {\r\n                    for (int i = 0; i < newEvents.size(); i++) {\r\n                        if (!newEvents.get(i).equals(oldEvents.get(i))) {\r\n                            changed = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                } else {\r\n                    changed = true;\r\n                }\r\n            }\r\n            if (!changed && (getFirstBallOwner() != null || lastSavedModel.getFirstBallOwner() != null)) {\r\n                changed = (getFirstBallOwner() == null) ^ (lastSavedModel.getFirstBallOwner() == null);\r\n                if (!changed) {\r\n                    changed = !getFirstBallOwner().equals(lastSavedModel.getFirstBallOwner());\r\n                }\r\n            }\r\n            // wurde Kommentar geändert?\r\n            if (!changed) {\r\n                if (comment == null || comment.equals(\"\")) {\r\n                    if (lastSavedModel.getComment() != null && !lastSavedModel.getComment().equals(\"\")) {\r\n                        changed = true;\r\n                    }\r\n                } else if (lastSavedModel.getComment() != null) {\r\n                    if (!lastSavedModel.getComment().equals(comment)) {\r\n                        changed = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return !changed;\r\n    }\r\n\r\n    private boolean changedPlayerList(Player[] newList, Player[] oldList) {\r\n        boolean changed = false;\r\n        int size = newList.length;\r\n        int sizeOld = oldList.length;\r\n        if (size == sizeOld) {\r\n            for (int i = 0; i < size; i++) {\r\n                if (!newList[i].equals(oldList[i])) {\r\n                    changed = true;\r\n                    break;\r\n                }\r\n            }\r\n        } else {\r\n            changed = true;\r\n        }\r\n        return changed;\r\n    }\r\n\r\n    public void initWithLoadedModel(HandballModel loadedModel) {\r\n        initModel();\r\n        offenders = loadedModel.getOffenders();\r\n        defenders = loadedModel.getDefenders();\r\n        events = loadedModel.getSortedEvents();\r\n        Offender.setCounter(determineMaxPlayerNumber(offenders));\r\n        Defender.setCounter(determineMaxPlayerNumber(defenders));\r\n        setFirstBallOwner(loadedModel.getFirstBallOwner());\r\n        setState(loadedModel.getState());\r\n        setActualMoveEvent(loadedModel.getActualMoveEvent());\r\n        setComment(loadedModel.getComment());\r\n        // zur Sicherheit\r\n        if (getComment() == null) {\r\n            setComment(\"\");\r\n        }\r\n        setMoveName(loadedModel.getMoveName());\r\n        markAsSaved(loadedModel);\r\n        fireModelChanged();\r\n    }\r\n\r\n    private int determineMaxPlayerNumber(List players) {\r\n        int max = 0;\r\n        for (Object o : players) {\r\n            if (o instanceof Player) {\r\n                Player player = (Player) o;\r\n                if (player.getPlayerNumber() > max) {\r\n                    max = player.getPlayerNumber();\r\n                }\r\n            }\r\n        }\r\n        return max;\r\n    }\r\n\r\n    public void markAsSaved(HandballModel model) {\r\n        try {\r\n            lastSavedModel = (HandballModel) Main.deepCopy(model);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            lastSavedModel = null;\r\n        }\r\n    }\r\n\r\n    public void setDelay(int eventIndex, int delay) {\r\n        getEvents().get(eventIndex).setDelay(delay);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setBallOwner(Offender ballOwner) {\r\n        if (this.ballOwner != null) {\r\n            this.ballOwner.setHasBall(false);\r\n        }\r\n        this.ballOwner = ballOwner;\r\n        if (ballOwner != null) {\r\n            ballOwner.setHasBall(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setBallOwnerSilent(Offender ballOwner) {\r\n        if (this.ballOwner != null) {\r\n            this.ballOwner.setHasBall(false);\r\n        }\r\n        this.ballOwner = ballOwner;\r\n        if (ballOwner != null) {\r\n            ballOwner.setHasBall(true);\r\n        }\r\n        // fireModelChanged();\r\n    }\r\n\r\n    public void startAnimation(boolean onlyActualSequence) {\r\n        setState(State.ANIMATION_RUNNING);\r\n        MoveEvent event = actualEvent;\r\n        if (event == null) {\r\n            event = getEvents().get(0);\r\n        }\r\n        setActualMoveEvent(event);\r\n        animationSequenz = event.getSequenceNr();\r\n        animationModel = new AnimationModel(event, this, onlyActualSequence);\r\n        runningAnimator = new Animator(this);\r\n        computePlayerPositions(animationSequenz);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void pauseAnimation(boolean pause) {\r\n        if (pause) {\r\n            runningAnimator.setPause(true);\r\n        } else {\r\n            runningAnimator.setPause(false);\r\n        }\r\n    }\r\n\r\n    public void initAnimation() {\r\n    }\r\n\r\n    public boolean nextAnimationStep() {\r\n        boolean finished = animationModel.nextStep();\r\n        if (finished) {\r\n            if (animationModel.isOnlyOneSequence()) {\r\n                setState(State.ANIMATION);\r\n                // n�chste Sequzenz ausw�hlen (einfaches sequentielles Anschauen des Spielzugs)\r\n                int nextSeq = (getAcutalSequenceNr() == getHighestSequenceNumber()) ? getAcutalSequenceNr() : getAcutalSequenceNr() + 1;\r\n                List<MoveEvent> nextSeqEvents = getMoveEvents(nextSeq);\r\n                if (nextSeqEvents.get(0) != null) {\r\n                    setActualMoveEvent(nextSeqEvents.get(0));\r\n                }\r\n            } else {\r\n                setState(State.FULL_ANIMATION_ENDED);\r\n            }\r\n        } else {\r\n            fireModelChanged();\r\n        }\r\n        return finished;\r\n    }\r\n\r\n    public void stopAnimation() {\r\n        setState(State.ANIMATION);\r\n        runningAnimator = null;\r\n        setActualMoveEvent(getActualMoveEvent());\r\n    }\r\n\r\n    public boolean isMarkedPlayerAddable() {\r\n        int seq = getAcutalSequenceNr();\r\n        return !events.contains(new MoveEvent(markedPlayer, seq));\r\n    }\r\n\r\n    public boolean passEventDefined(int seq) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() == seq && event instanceof PassEvent) {\r\n                defined = true;\r\n                break;\r\n            }\r\n            if (event.getSequenceNr() > seq) {\r\n                break;\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public boolean passEventDefined() {\r\n        return passEventDefined(getAcutalSequenceNr());\r\n    }\r\n\r\n    public boolean passEventDefinedAfter(int seq) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if ((event instanceof PassEvent) && (event.getSequenceNr() > seq)) {\r\n                defined = true;\r\n                break;\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public boolean eventDefinedAfter(int seq) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() > seq) {\r\n                defined = true;\r\n                break;\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public Ball getBall() {\r\n        return ball;\r\n    }\r\n\r\n    public void setFirstBallOwner(Offender offender) {\r\n        this.firstBallOwner = offender;\r\n        setBallOwner(offender);\r\n        if (firstBallOwner == null) {\r\n            resetBallPosition();\r\n        }\r\n    }\r\n\r\n    public Offender getFirstBallOwner() {\r\n        return firstBallOwner;\r\n    }\r\n\r\n    public boolean hasPlayerBallInNextSequence(Player player) {\r\n        PassEvent pass = null;\r\n        int seq = getAcutalSequenceNr();\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() == seq && event instanceof PassEvent) {\r\n                pass = (PassEvent) event;\r\n                break;\r\n            }\r\n            if (event.getSequenceNr() > seq) {\r\n                break;\r\n            }\r\n        }\r\n        if (pass != null && pass.getDestinationPlayer() != null) {\r\n            return pass.getDestinationPlayer().equals(player) && !passEventDefined(seq + 1);\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public boolean isBallSet() {\r\n        return ballOwner != null;\r\n    }\r\n\r\n    public boolean isGoalPassSet() {\r\n        boolean defined = false;\r\n        for (MoveEvent event : getEvents()) {\r\n            if (event instanceof PassEvent) {\r\n                PassEvent pass = (PassEvent) event;\r\n                if (pass.isGoalPass()) {\r\n                    defined = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public void moveBallTo(int x, int y) {\r\n        ball.setCurrent_x(x);\r\n        ball.setCurrent_y(y);\r\n    }\r\n\r\n    public List<MoveEvent> getActualMoveEvents() {\r\n        return getMoveEvents(getAcutalSequenceNr());\r\n    }\r\n\r\n    public List<MoveEvent> getMoveEvents(int sequenceNr) {\r\n        List<MoveEvent> sequenceEvents = new ArrayList<MoveEvent>();\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() == sequenceNr) {\r\n                sequenceEvents.add(event);\r\n            } else if (event.getSequenceNr() > getAcutalSequenceNr()) {\r\n                break;\r\n            }\r\n        }\r\n        return sequenceEvents;\r\n    }\r\n\r\n    /**\r\n     * Löscht das Aktuelle Ereignis und ALLE Folgenden\r\n     */\r\n    public void removeEventsAfter() {\r\n        MoveEvent event = getActualMoveEvent();\r\n        List<MoveEvent> toDeleteEvents = new ArrayList<MoveEvent>();\r\n        int sequenceNr = event.getSequenceNr();\r\n        // zu loeschende Events sammeln\r\n        for (MoveEvent evt : getEvents()) {\r\n            if (evt.getSequenceNr() > sequenceNr) {\r\n                // Event ist hoeher, also loeschen\r\n                toDeleteEvents.add(evt);\r\n            }\r\n        }\r\n        toDeleteEvents.add(event);\r\n        // gesammelte Events loeschen\r\n        for (MoveEvent deleteEvent : toDeleteEvents) {\r\n            removeMoveEvent(deleteEvent);\r\n        }\r\n        setActualMoveEvent((getEvents().size() > 0) ? getEvents().get(getEvents().size() - 1) : null);\r\n        fireModelChanged();\r\n    }\r\n\r\n    /**\r\n     * Löscht die Ereignisse (auch P�sse) des �bergebenen Spielers. Und die\r\n     * evtl. davon abh�ngigen Folgep�sse\r\n     *\r\n     * @param player\r\n     */\r\n    private void removeEventsOfPlayer(Player player) {\r\n        List<MoveEvent> toDeleteEvents = new ArrayList<MoveEvent>();\r\n        boolean playerInvolved = false;\r\n        // zu loeschende Events sammeln\r\n        for (MoveEvent evt : getEvents()) {\r\n            // Pass?\r\n            if (evt instanceof PassEvent) {\r\n                PassEvent pass = (PassEvent) evt;\r\n                // War ein Pass zu dem Spieler? oder Spieler passt selbst?\r\n                if (pass.getDestinationPlayer().equals(player) || pass.getPlayer().equals(player)) {\r\n                    playerInvolved = true;\r\n                }\r\n                // War Spieler an einem Pass beteiligt?\r\n                if (playerInvolved) {\r\n                    toDeleteEvents.add(pass);\r\n                    continue;\r\n                }\r\n            }\r\n            if (evt.getPlayer().equals(player)) {\r\n                toDeleteEvents.add(evt);\r\n            }\r\n        }\r\n        // gesammelte Events loeschen\r\n        for (MoveEvent deleteEvent : toDeleteEvents) {\r\n            removeMoveEvent(deleteEvent);\r\n        }\r\n        setActualMoveEvent((getEvents().size() > 0) ? getEvents().get(getEvents().size() - 1) : null);\r\n    }\r\n\r\n    public boolean eventDefinedWithPlayer(Player player) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if (event.getPlayer().equals(player)) {\r\n                defined = true;\r\n                break;\r\n            }\r\n            if (event instanceof PassEvent) {\r\n                PassEvent pass = (PassEvent) event;\r\n                if (pass.getDestinationPlayer().equals(player)) {\r\n                    defined = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public int getHighestSequenceNumber() {\r\n        if (events.size() == 0) {\r\n            return 0;\r\n        } else {\r\n            return events.last().getSequenceNr();\r\n        }\r\n    }\r\n\r\n    public String getMoveName() {\r\n        return moveName;\r\n    }\r\n\r\n    public void setMoveName(String moveName) {\r\n        this.moveName = moveName;\r\n        if (Main.getWindow() != null) {\r\n            StringBuffer buffer = new StringBuffer(APP_NAME);\r\n            buffer.append(\" - \");\r\n            if (moveName == null || moveName.equals(\"\")) {\r\n                buffer.append(\"Unbenannt\");\r\n                // Titelleiste aktualisieren\r\n            } else {\r\n                buffer.append(moveName);\r\n            }\r\n            if (!isSaved()) {\r\n                buffer.append(\"*\");\r\n            }\r\n            Main.getWindow().setTitle(buffer.toString());\r\n        }\r\n    }\r\n\r\n    public String getComment() {\r\n        if (comment == null) {\r\n            comment = \"\";\r\n        }\r\n        return comment;\r\n    }\r\n\r\n    public void setComment(String comment) {\r\n        this.comment = comment;\r\n        fireModelChanged();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/model/HandballModelTest8.java",
		"test_prompt": "// HandballModelTest8.java\npackage visu.handball.moves.model;\n\nimport java.awt.geom.Point2D;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\nimport javax.swing.JOptionPane;\nimport visu.handball.moves.Main;\nimport visu.handball.moves.model.animation.AnimationModel;\nimport visu.handball.moves.model.animation.Animator;\nimport visu.handball.moves.model.player.Ball;\nimport visu.handball.moves.model.player.Defender;\nimport visu.handball.moves.model.player.HighlightableItem;\nimport visu.handball.moves.model.player.MovePoint;\nimport visu.handball.moves.model.player.Offender;\nimport visu.handball.moves.model.player.Player;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HandballModel}.\n* It contains ten unit test cases for the {@link HandballModel#passEventDefined()} method.\n*/\nclass HandballModelTest8 {"
	},
	{
		"original_code": "// HandballModel.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.model;\r\n\r\nimport java.awt.geom.Point2D;\r\nimport java.io.Serializable;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.SortedSet;\r\nimport java.util.TreeSet;\r\nimport javax.swing.JOptionPane;\r\nimport visu.handball.moves.Main;\r\nimport visu.handball.moves.model.animation.AnimationModel;\r\nimport visu.handball.moves.model.animation.Animator;\r\nimport visu.handball.moves.model.player.Ball;\r\nimport visu.handball.moves.model.player.Defender;\r\nimport visu.handball.moves.model.player.HighlightableItem;\r\nimport visu.handball.moves.model.player.MovePoint;\r\nimport visu.handball.moves.model.player.Offender;\r\nimport visu.handball.moves.model.player.Player;\r\n\r\npublic class HandballModel implements Serializable {\r\n\r\n    private static final long serialVersionUID = -5372891552466311536L;\r\n\r\n    public enum State {\r\n\r\n        INITIAL,\r\n        PLACE_OFFENDERS,\r\n        PLACE_DEFENDERS,\r\n        PLACE_BALL,\r\n        EDIT,\r\n        EDIT_EVENT,\r\n        ANIMATION,\r\n        ANIMATION_RUNNING,\r\n        FULL_ANIMATION_ENDED\r\n    }\r\n\r\n    private static final int MAX_OFFENDERS = 6;\r\n\r\n    private static final int MAX_DEFENDERS = 6;\r\n\r\n    private static final int MARK_RADIUS = 12;\r\n\r\n    private static final String APP_NAME = \"jHandballMoves\";\r\n\r\n    private transient List<HandballModelListener> listeners;\r\n\r\n    private transient List<PlayerRemovedListener> playerRemoveListener;\r\n\r\n    private List<Defender> defenders;\r\n\r\n    private List<Offender> offenders;\r\n\r\n    private SortedSet<MoveEvent> events;\r\n\r\n    private State state;\r\n\r\n    private MoveEvent actualEvent;\r\n\r\n    private Player markedPlayer;\r\n\r\n    private HighlightableItem hightlightedItem;\r\n\r\n    private Offender ballOwner;\r\n\r\n    private Ball ball;\r\n\r\n    private Offender firstBallOwner;\r\n\r\n    private transient Animator runningAnimator;\r\n\r\n    private int animationSequenz;\r\n\r\n    private transient AnimationModel animationModel;\r\n\r\n    private transient HandballModel lastSavedModel;\r\n\r\n    private String comment;\r\n\r\n    private String moveName;\r\n\r\n    public HandballModel() {\r\n        listeners = new ArrayList<HandballModelListener>();\r\n        playerRemoveListener = new ArrayList<PlayerRemovedListener>();\r\n        initModel();\r\n    }\r\n\r\n    public void initModel() {\r\n        defenders = new ArrayList<Defender>();\r\n        Defender.setCounter(0);\r\n        offenders = new ArrayList<Offender>();\r\n        Offender.setCounter(0);\r\n        events = new TreeSet<MoveEvent>();\r\n        // Workaround wegen ToolBar\r\n        state = State.PLACE_OFFENDERS;\r\n        actualEvent = null;\r\n        markedPlayer = null;\r\n        firstBallOwner = null;\r\n        comment = \"\";\r\n        moveName = \"\";\r\n        resetBallPosition();\r\n        try {\r\n            lastSavedModel = (HandballModel) Main.deepCopy(this);\r\n        } catch (Exception e) {\r\n            lastSavedModel = null;\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    private void resetBallPosition() {\r\n        ball = new Ball(-500, -500);\r\n    }\r\n\r\n    public void addOffender(int x, int y) {\r\n        if (offenders.size() == MAX_OFFENDERS) {\r\n            JOptionPane.showMessageDialog(Main.getWindow(), \"Sie haben schon \" + MAX_OFFENDERS + \" Angreifer angelegt.\", \"Info:\", JOptionPane.INFORMATION_MESSAGE);\r\n        } else {\r\n            offenders.add(new Offender(x, y));\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void removePlayer(Player toRemove) {\r\n        if (eventDefinedWithPlayer(toRemove)) {\r\n            removeEventsOfPlayer(toRemove);\r\n        }\r\n        if (toRemove instanceof Offender) {\r\n            removeOffender((Offender) toRemove);\r\n        } else {\r\n            removeDefender((Defender) toRemove);\r\n        }\r\n    }\r\n\r\n    private void removeOffender(Offender toRemove) {\r\n        if (getFirstBallOwner() != null && getFirstBallOwner().equals(toRemove)) {\r\n            setFirstBallOwner(null);\r\n        }\r\n        offenders.remove(toRemove);\r\n        if ((getDefenders().size() + getOffenders().size()) == 0) {\r\n            markedPlayer = null;\r\n        }\r\n        // Spielernummer aktualisieren\r\n        Offender.setCounter(determineMaxPlayerNumber(offenders));\r\n        fireOffenderRemoved(toRemove);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void addDefender(int x, int y) {\r\n        if (defenders.size() == MAX_DEFENDERS) {\r\n            JOptionPane.showMessageDialog(Main.getWindow(), \"Sie haben schon \" + MAX_OFFENDERS + \" Verteidiger angelegt.\", \"Info:\", JOptionPane.INFORMATION_MESSAGE);\r\n        } else {\r\n            defenders.add(new Defender(x, y));\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    private void removeDefender(Defender toRemove) {\r\n        defenders.remove(toRemove);\r\n        if ((getDefenders().size() + getOffenders().size()) == 0) {\r\n            markedPlayer = null;\r\n        }\r\n        Defender.setCounter(determineMaxPlayerNumber(defenders));\r\n        fireDefenderRemoved(toRemove);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public boolean addListener(HandballModelListener o) {\r\n        return listeners.add(o);\r\n    }\r\n\r\n    public boolean removeListener(HandballModelListener o) {\r\n        return listeners.remove(o);\r\n    }\r\n\r\n    public boolean addPlayerRemovedListener(PlayerRemovedListener o) {\r\n        return playerRemoveListener.add(o);\r\n    }\r\n\r\n    public boolean removePlayerRemovedListener(PlayerRemovedListener o) {\r\n        return playerRemoveListener.remove(o);\r\n    }\r\n\r\n    private void fireModelChanged() {\r\n        setMoveName(getMoveName());\r\n        for (HandballModelListener listener : listeners) {\r\n            listener.modelChanged();\r\n        }\r\n    }\r\n\r\n    private void fireOffenderRemoved(Offender offender) {\r\n        for (PlayerRemovedListener listener : playerRemoveListener) {\r\n            listener.offenderRemoved(offender);\r\n        }\r\n    }\r\n\r\n    private void fireDefenderRemoved(Defender defender) {\r\n        for (PlayerRemovedListener listener : playerRemoveListener) {\r\n            listener.defenderRemoved(defender);\r\n        }\r\n    }\r\n\r\n    public List<Defender> getDefenders() {\r\n        return defenders;\r\n    }\r\n\r\n    public List<Offender> getOffenders() {\r\n        return offenders;\r\n    }\r\n\r\n    public State getState() {\r\n        return state;\r\n    }\r\n\r\n    public void setState(State state) {\r\n        if (state == State.EDIT) {\r\n            if (getActualMoveEvent() == null) {\r\n                // Wenn leer, dann Null, sonst letztes Move Event setzen\r\n                setActualMoveEvent(getEvents().isEmpty() ? null : (getEvents().get(getEvents().size() - 1)));\r\n            } else {\r\n                setActualMoveEvent(getActualMoveEvent());\r\n            }\r\n        }\r\n        if (state == State.PLACE_DEFENDERS || state == State.PLACE_OFFENDERS) {\r\n            if (getFirstBallOwner() != null) {\r\n                setBallOwner(getFirstBallOwner());\r\n            }\r\n            setActualMoveEvent(null);\r\n        }\r\n        this.state = state;\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void addMoveEvent(MoveEvent event) {\r\n        events.add(event);\r\n        if (state == State.EDIT) {\r\n            setActualMoveEvent(event);\r\n            state = State.EDIT_EVENT;\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void removeMoveEvent(MoveEvent event) {\r\n        events.remove(event);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public List<MoveEvent> getEvents() {\r\n        List<MoveEvent> list = new ArrayList<MoveEvent>(events);\r\n        return list;\r\n    }\r\n\r\n    public SortedSet<MoveEvent> getSortedEvents() {\r\n        return events;\r\n    }\r\n\r\n    public int getAcutalSequenceNr() {\r\n        if (actualEvent == null)\r\n            return 0;\r\n        else {\r\n            return actualEvent.getSequenceNr();\r\n        }\r\n    }\r\n\r\n    public void setActualMoveEvent(MoveEvent event) {\r\n        if (this.actualEvent != null) {\r\n            this.actualEvent.setMarked(false);\r\n        }\r\n        this.actualEvent = event;\r\n        computePlayerPositions();\r\n        // aktuellen Spieler setzen\r\n        setMarkedPlayer((event == null) ? null : event.getPlayer());\r\n        if (actualEvent != null) {\r\n            if (!actualEvent.isDestinationPointSet()) {\r\n                state = State.EDIT_EVENT;\r\n            } else {\r\n                if (state == State.FULL_ANIMATION_ENDED) {\r\n                    state = State.ANIMATION;\r\n                } else if (state != State.ANIMATION && state != State.ANIMATION_RUNNING) {\r\n                    state = State.EDIT;\r\n                }\r\n            }\r\n            actualEvent.setMarked(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setDestinationPointForEvent(MoveEvent event, int x, int y, boolean temp) {\r\n        event.setDestinationPoint(x, y, temp);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setControlPointForEvent(MoveEvent event, int x, int y, boolean temp) {\r\n        event.setControlPoint(x, y, temp);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setMovePointTo(MovePoint point, int x, int y) {\r\n        actualEvent.setPoint(point, x, y);\r\n        fireModelChanged();\r\n    }\r\n\r\n    private void computePlayerPositions() {\r\n        computePlayerPositions(getAcutalSequenceNr());\r\n    }\r\n\r\n    public void computePlayerPositions(int seqNr) {\r\n        // Spieler Positionen auf Ausgangsstellung\r\n        for (Player offender : offenders) {\r\n            offender.resetPosition();\r\n        }\r\n        for (Player defender : defenders) {\r\n            defender.resetPosition();\r\n        }\r\n        if (seqNr == 1) {\r\n            setBallOwner(firstBallOwner);\r\n        }\r\n        // alle Events mit kleinerer Sequenznummer verarbeiten\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() < seqNr) {\r\n                if (event instanceof PassEvent) {\r\n                    // Ball an anderen Spieler �bertragen\r\n                    setBallOwner(((PassEvent) event).getDestinationPlayer());\r\n                } else {\r\n                    if (event.getDestinationX() > -1 && event.getDestinationY() > -1) {\r\n                        event.getPlayer().setCurrentPosition(event.getDestinationX(), event.getDestinationY());\r\n                    }\r\n                }\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    public MoveEvent getActualMoveEvent() {\r\n        return actualEvent;\r\n    }\r\n\r\n    public Player getMarkedPlayer() {\r\n        return markedPlayer;\r\n    }\r\n\r\n    public void setMarkedPlayer(Player markedPlayer) {\r\n        // alten markierten Spieler demarkieren\r\n        if (this.markedPlayer != null) {\r\n            this.markedPlayer.setMarked(false);\r\n        }\r\n        // evtl. neuen Spieler markieren\r\n        this.markedPlayer = markedPlayer;\r\n        if (markedPlayer != null) {\r\n            markedPlayer.setMarked(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setHighLightedItem(HighlightableItem item) {\r\n        if (this.hightlightedItem != null) {\r\n            // altes Item zur�cksetzen\r\n            this.hightlightedItem.setHighlight(false);\r\n        }\r\n        this.hightlightedItem = item;\r\n        if (item != null) {\r\n            hightlightedItem.setHighlight(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public HighlightableItem getHightligtedItem() {\r\n        return hightlightedItem;\r\n    }\r\n\r\n    public Player getNearestPlayer(int x, int y) {\r\n        List<Player> all = new ArrayList<Player>(offenders);\r\n        all.addAll(defenders);\r\n        return findNearestPlayer(x, y, all);\r\n    }\r\n\r\n    public Offender getNearestOffender(int x, int y) {\r\n        List<Player> all = new ArrayList<Player>(offenders);\r\n        return (Offender) findNearestPlayer(x, y, all);\r\n    }\r\n\r\n    private Player findNearestPlayer(int x, int y, List<Player> players) {\r\n        double entfernung = Double.MAX_VALUE;\r\n        Player temp = null;\r\n        for (Player player : players) {\r\n            int player_x = player.getCurrent_x();\r\n            int player_y = player.getCurrent_y();\r\n            double tempEntfernung = Point2D.distance(x, y, player_x, player_y);\r\n            // Wenn naeher als der MARK_RADIUS\r\n            if (!(tempEntfernung > MARK_RADIUS)) {\r\n                if (tempEntfernung < entfernung) {\r\n                    temp = player;\r\n                    entfernung = tempEntfernung;\r\n                }\r\n            }\r\n        }\r\n        return temp;\r\n    }\r\n\r\n    public MovePoint getNearestMovePoint(int x, int y) {\r\n        MovePoint point = null;\r\n        if (actualEvent != null) {\r\n            double entfernung = Double.MAX_VALUE;\r\n            if (actualEvent.isDestinationPointSet()) {\r\n                int destination_x = actualEvent.getDestinationX();\r\n                int destination_y = actualEvent.getDestinationY();\r\n                double tempEntfernung = Point2D.distance(x, y, destination_x, destination_y);\r\n                // Wenn naeher als der MARK_RADIUS\r\n                if (!(tempEntfernung > MARK_RADIUS)) {\r\n                    if (tempEntfernung < entfernung) {\r\n                        point = actualEvent.getDestinationPoint();\r\n                        entfernung = tempEntfernung;\r\n                    }\r\n                }\r\n            }\r\n            if (actualEvent.isControlPointSet()) {\r\n                int controlPoint_x = actualEvent.getControlPointX();\r\n                int controlPoint_y = actualEvent.getControlPointY();\r\n                double tempEntfernung = Point2D.distance(x, y, controlPoint_x, controlPoint_y);\r\n                // Wenn naeher als der MARK_RADIUS\r\n                if (!(tempEntfernung > MARK_RADIUS)) {\r\n                    if (tempEntfernung < entfernung) {\r\n                        point = actualEvent.getControlPoint();\r\n                        entfernung = tempEntfernung;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return point;\r\n    }\r\n\r\n    public HighlightableItem getNearestHighlightableItem(int x, int y) {\r\n        HighlightableItem temp = null;\r\n        temp = getNearestMovePoint(x, y);\r\n        if (temp == null) {\r\n            temp = getNearestPlayer(x, y);\r\n        }\r\n        return temp;\r\n    }\r\n\r\n    public void movePlayerTo(Player actualPlayer, int x, int y) {\r\n        if (getAcutalSequenceNr() == 0) {\r\n            actualPlayer.setStart_x(x);\r\n            actualPlayer.setStart_y(y);\r\n        }\r\n        // Ansonsten muss die Position im entsprechenden Ereignis gesetzt\r\n        // werden\r\n        // Startposition darf nur im Angreifer/Verteidiger-Modus ge�ndert werden\r\n        fireModelChanged();\r\n    }\r\n\r\n    public boolean isSaved() {\r\n        boolean changed = false;\r\n        if (lastSavedModel != null) {\r\n            //Spielzugnamen vergleichen\r\n            if (lastSavedModel.getMoveName() != null) {\r\n                if (getMoveName() == null || !lastSavedModel.getMoveName().equals(getMoveName())) {\r\n                    return false;\r\n                }\r\n            } else if (getMoveName() != null) {\r\n                //alt: kein Name <-> neu: Name vorhanden\r\n                return false;\r\n            }\r\n            //Ueberprüfen ob Angreifer und Verteidiger unterschiedlich\r\n            // zuerst Spielerlisten vergleichen\r\n            if (changedPlayerList(getOffenders().toArray(new Player[getOffenders().size()]), lastSavedModel.getOffenders().toArray(new Player[lastSavedModel.getOffenders().size()])) || changedPlayerList(getDefenders().toArray(new Player[getDefenders().size()]), lastSavedModel.getDefenders().toArray(new Player[lastSavedModel.getDefenders().size()]))) {\r\n                changed = true;\r\n            } else {\r\n                List<MoveEvent> newEvents = getEvents();\r\n                List<MoveEvent> oldEvents = lastSavedModel.getEvents();\r\n                if (newEvents.size() == oldEvents.size()) {\r\n                    for (int i = 0; i < newEvents.size(); i++) {\r\n                        if (!newEvents.get(i).equals(oldEvents.get(i))) {\r\n                            changed = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                } else {\r\n                    changed = true;\r\n                }\r\n            }\r\n            if (!changed && (getFirstBallOwner() != null || lastSavedModel.getFirstBallOwner() != null)) {\r\n                changed = (getFirstBallOwner() == null) ^ (lastSavedModel.getFirstBallOwner() == null);\r\n                if (!changed) {\r\n                    changed = !getFirstBallOwner().equals(lastSavedModel.getFirstBallOwner());\r\n                }\r\n            }\r\n            // wurde Kommentar geändert?\r\n            if (!changed) {\r\n                if (comment == null || comment.equals(\"\")) {\r\n                    if (lastSavedModel.getComment() != null && !lastSavedModel.getComment().equals(\"\")) {\r\n                        changed = true;\r\n                    }\r\n                } else if (lastSavedModel.getComment() != null) {\r\n                    if (!lastSavedModel.getComment().equals(comment)) {\r\n                        changed = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return !changed;\r\n    }\r\n\r\n    private boolean changedPlayerList(Player[] newList, Player[] oldList) {\r\n        boolean changed = false;\r\n        int size = newList.length;\r\n        int sizeOld = oldList.length;\r\n        if (size == sizeOld) {\r\n            for (int i = 0; i < size; i++) {\r\n                if (!newList[i].equals(oldList[i])) {\r\n                    changed = true;\r\n                    break;\r\n                }\r\n            }\r\n        } else {\r\n            changed = true;\r\n        }\r\n        return changed;\r\n    }\r\n\r\n    public void initWithLoadedModel(HandballModel loadedModel) {\r\n        initModel();\r\n        offenders = loadedModel.getOffenders();\r\n        defenders = loadedModel.getDefenders();\r\n        events = loadedModel.getSortedEvents();\r\n        Offender.setCounter(determineMaxPlayerNumber(offenders));\r\n        Defender.setCounter(determineMaxPlayerNumber(defenders));\r\n        setFirstBallOwner(loadedModel.getFirstBallOwner());\r\n        setState(loadedModel.getState());\r\n        setActualMoveEvent(loadedModel.getActualMoveEvent());\r\n        setComment(loadedModel.getComment());\r\n        // zur Sicherheit\r\n        if (getComment() == null) {\r\n            setComment(\"\");\r\n        }\r\n        setMoveName(loadedModel.getMoveName());\r\n        markAsSaved(loadedModel);\r\n        fireModelChanged();\r\n    }\r\n\r\n    private int determineMaxPlayerNumber(List players) {\r\n        int max = 0;\r\n        for (Object o : players) {\r\n            if (o instanceof Player) {\r\n                Player player = (Player) o;\r\n                if (player.getPlayerNumber() > max) {\r\n                    max = player.getPlayerNumber();\r\n                }\r\n            }\r\n        }\r\n        return max;\r\n    }\r\n\r\n    public void markAsSaved(HandballModel model) {\r\n        try {\r\n            lastSavedModel = (HandballModel) Main.deepCopy(model);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            lastSavedModel = null;\r\n        }\r\n    }\r\n\r\n    public void setDelay(int eventIndex, int delay) {\r\n        getEvents().get(eventIndex).setDelay(delay);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setBallOwner(Offender ballOwner) {\r\n        if (this.ballOwner != null) {\r\n            this.ballOwner.setHasBall(false);\r\n        }\r\n        this.ballOwner = ballOwner;\r\n        if (ballOwner != null) {\r\n            ballOwner.setHasBall(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setBallOwnerSilent(Offender ballOwner) {\r\n        if (this.ballOwner != null) {\r\n            this.ballOwner.setHasBall(false);\r\n        }\r\n        this.ballOwner = ballOwner;\r\n        if (ballOwner != null) {\r\n            ballOwner.setHasBall(true);\r\n        }\r\n        // fireModelChanged();\r\n    }\r\n\r\n    public void startAnimation(boolean onlyActualSequence) {\r\n        setState(State.ANIMATION_RUNNING);\r\n        MoveEvent event = actualEvent;\r\n        if (event == null) {\r\n            event = getEvents().get(0);\r\n        }\r\n        setActualMoveEvent(event);\r\n        animationSequenz = event.getSequenceNr();\r\n        animationModel = new AnimationModel(event, this, onlyActualSequence);\r\n        runningAnimator = new Animator(this);\r\n        computePlayerPositions(animationSequenz);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void pauseAnimation(boolean pause) {\r\n        if (pause) {\r\n            runningAnimator.setPause(true);\r\n        } else {\r\n            runningAnimator.setPause(false);\r\n        }\r\n    }\r\n\r\n    public void initAnimation() {\r\n    }\r\n\r\n    public boolean nextAnimationStep() {\r\n        boolean finished = animationModel.nextStep();\r\n        if (finished) {\r\n            if (animationModel.isOnlyOneSequence()) {\r\n                setState(State.ANIMATION);\r\n                // n�chste Sequzenz ausw�hlen (einfaches sequentielles Anschauen des Spielzugs)\r\n                int nextSeq = (getAcutalSequenceNr() == getHighestSequenceNumber()) ? getAcutalSequenceNr() : getAcutalSequenceNr() + 1;\r\n                List<MoveEvent> nextSeqEvents = getMoveEvents(nextSeq);\r\n                if (nextSeqEvents.get(0) != null) {\r\n                    setActualMoveEvent(nextSeqEvents.get(0));\r\n                }\r\n            } else {\r\n                setState(State.FULL_ANIMATION_ENDED);\r\n            }\r\n        } else {\r\n            fireModelChanged();\r\n        }\r\n        return finished;\r\n    }\r\n\r\n    public void stopAnimation() {\r\n        setState(State.ANIMATION);\r\n        runningAnimator = null;\r\n        setActualMoveEvent(getActualMoveEvent());\r\n    }\r\n\r\n    public boolean isMarkedPlayerAddable() {\r\n        int seq = getAcutalSequenceNr();\r\n        return !events.contains(new MoveEvent(markedPlayer, seq));\r\n    }\r\n\r\n    public boolean passEventDefined(int seq) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() == seq && event instanceof PassEvent) {\r\n                defined = true;\r\n                break;\r\n            }\r\n            if (event.getSequenceNr() > seq) {\r\n                break;\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public boolean passEventDefined() {\r\n        return passEventDefined(getAcutalSequenceNr());\r\n    }\r\n\r\n    public boolean passEventDefinedAfter(int seq) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if ((event instanceof PassEvent) && (event.getSequenceNr() > seq)) {\r\n                defined = true;\r\n                break;\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public boolean eventDefinedAfter(int seq) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() > seq) {\r\n                defined = true;\r\n                break;\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public Ball getBall() {\r\n        return ball;\r\n    }\r\n\r\n    public void setFirstBallOwner(Offender offender) {\r\n        this.firstBallOwner = offender;\r\n        setBallOwner(offender);\r\n        if (firstBallOwner == null) {\r\n            resetBallPosition();\r\n        }\r\n    }\r\n\r\n    public Offender getFirstBallOwner() {\r\n        return firstBallOwner;\r\n    }\r\n\r\n    public boolean hasPlayerBallInNextSequence(Player player) {\r\n        PassEvent pass = null;\r\n        int seq = getAcutalSequenceNr();\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() == seq && event instanceof PassEvent) {\r\n                pass = (PassEvent) event;\r\n                break;\r\n            }\r\n            if (event.getSequenceNr() > seq) {\r\n                break;\r\n            }\r\n        }\r\n        if (pass != null && pass.getDestinationPlayer() != null) {\r\n            return pass.getDestinationPlayer().equals(player) && !passEventDefined(seq + 1);\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public boolean isBallSet() {\r\n        return ballOwner != null;\r\n    }\r\n\r\n    public boolean isGoalPassSet() {\r\n        boolean defined = false;\r\n        for (MoveEvent event : getEvents()) {\r\n            if (event instanceof PassEvent) {\r\n                PassEvent pass = (PassEvent) event;\r\n                if (pass.isGoalPass()) {\r\n                    defined = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public void moveBallTo(int x, int y) {\r\n        ball.setCurrent_x(x);\r\n        ball.setCurrent_y(y);\r\n    }\r\n\r\n    public List<MoveEvent> getActualMoveEvents() {\r\n        return getMoveEvents(getAcutalSequenceNr());\r\n    }\r\n\r\n    public List<MoveEvent> getMoveEvents(int sequenceNr) {\r\n        List<MoveEvent> sequenceEvents = new ArrayList<MoveEvent>();\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() == sequenceNr) {\r\n                sequenceEvents.add(event);\r\n            } else if (event.getSequenceNr() > getAcutalSequenceNr()) {\r\n                break;\r\n            }\r\n        }\r\n        return sequenceEvents;\r\n    }\r\n\r\n    /**\r\n     * Löscht das Aktuelle Ereignis und ALLE Folgenden\r\n     */\r\n    public void removeEventsAfter() {\r\n        MoveEvent event = getActualMoveEvent();\r\n        List<MoveEvent> toDeleteEvents = new ArrayList<MoveEvent>();\r\n        int sequenceNr = event.getSequenceNr();\r\n        // zu loeschende Events sammeln\r\n        for (MoveEvent evt : getEvents()) {\r\n            if (evt.getSequenceNr() > sequenceNr) {\r\n                // Event ist hoeher, also loeschen\r\n                toDeleteEvents.add(evt);\r\n            }\r\n        }\r\n        toDeleteEvents.add(event);\r\n        // gesammelte Events loeschen\r\n        for (MoveEvent deleteEvent : toDeleteEvents) {\r\n            removeMoveEvent(deleteEvent);\r\n        }\r\n        setActualMoveEvent((getEvents().size() > 0) ? getEvents().get(getEvents().size() - 1) : null);\r\n        fireModelChanged();\r\n    }\r\n\r\n    /**\r\n     * Löscht die Ereignisse (auch P�sse) des �bergebenen Spielers. Und die\r\n     * evtl. davon abh�ngigen Folgep�sse\r\n     *\r\n     * @param player\r\n     */\r\n    private void removeEventsOfPlayer(Player player) {\r\n        List<MoveEvent> toDeleteEvents = new ArrayList<MoveEvent>();\r\n        boolean playerInvolved = false;\r\n        // zu loeschende Events sammeln\r\n        for (MoveEvent evt : getEvents()) {\r\n            // Pass?\r\n            if (evt instanceof PassEvent) {\r\n                PassEvent pass = (PassEvent) evt;\r\n                // War ein Pass zu dem Spieler? oder Spieler passt selbst?\r\n                if (pass.getDestinationPlayer().equals(player) || pass.getPlayer().equals(player)) {\r\n                    playerInvolved = true;\r\n                }\r\n                // War Spieler an einem Pass beteiligt?\r\n                if (playerInvolved) {\r\n                    toDeleteEvents.add(pass);\r\n                    continue;\r\n                }\r\n            }\r\n            if (evt.getPlayer().equals(player)) {\r\n                toDeleteEvents.add(evt);\r\n            }\r\n        }\r\n        // gesammelte Events loeschen\r\n        for (MoveEvent deleteEvent : toDeleteEvents) {\r\n            removeMoveEvent(deleteEvent);\r\n        }\r\n        setActualMoveEvent((getEvents().size() > 0) ? getEvents().get(getEvents().size() - 1) : null);\r\n    }\r\n\r\n    public boolean eventDefinedWithPlayer(Player player) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if (event.getPlayer().equals(player)) {\r\n                defined = true;\r\n                break;\r\n            }\r\n            if (event instanceof PassEvent) {\r\n                PassEvent pass = (PassEvent) event;\r\n                if (pass.getDestinationPlayer().equals(player)) {\r\n                    defined = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public int getHighestSequenceNumber() {\r\n        if (events.size() == 0) {\r\n            return 0;\r\n        } else {\r\n            return events.last().getSequenceNr();\r\n        }\r\n    }\r\n\r\n    public String getMoveName() {\r\n        return moveName;\r\n    }\r\n\r\n    public void setMoveName(String moveName) {\r\n        this.moveName = moveName;\r\n        if (Main.getWindow() != null) {\r\n            StringBuffer buffer = new StringBuffer(APP_NAME);\r\n            buffer.append(\" - \");\r\n            if (moveName == null || moveName.equals(\"\")) {\r\n                buffer.append(\"Unbenannt\");\r\n                // Titelleiste aktualisieren\r\n            } else {\r\n                buffer.append(moveName);\r\n            }\r\n            if (!isSaved()) {\r\n                buffer.append(\"*\");\r\n            }\r\n            Main.getWindow().setTitle(buffer.toString());\r\n        }\r\n    }\r\n\r\n    public String getComment() {\r\n        if (comment == null) {\r\n            comment = \"\";\r\n        }\r\n        return comment;\r\n    }\r\n\r\n    public void setComment(String comment) {\r\n        this.comment = comment;\r\n        fireModelChanged();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/model/HandballModelTest9.java",
		"test_prompt": "// HandballModelTest9.java\npackage visu.handball.moves.model;\n\nimport java.awt.geom.Point2D;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\nimport javax.swing.JOptionPane;\nimport visu.handball.moves.Main;\nimport visu.handball.moves.model.animation.AnimationModel;\nimport visu.handball.moves.model.animation.Animator;\nimport visu.handball.moves.model.player.Ball;\nimport visu.handball.moves.model.player.Defender;\nimport visu.handball.moves.model.player.HighlightableItem;\nimport visu.handball.moves.model.player.MovePoint;\nimport visu.handball.moves.model.player.Offender;\nimport visu.handball.moves.model.player.Player;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HandballModel}.\n* It contains ten unit test cases for the {@link HandballModel#passEventDefinedAfter(int)} method.\n*/\nclass HandballModelTest9 {"
	},
	{
		"original_code": "// HandballModel.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.model;\r\n\r\nimport java.awt.geom.Point2D;\r\nimport java.io.Serializable;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.SortedSet;\r\nimport java.util.TreeSet;\r\nimport javax.swing.JOptionPane;\r\nimport visu.handball.moves.Main;\r\nimport visu.handball.moves.model.animation.AnimationModel;\r\nimport visu.handball.moves.model.animation.Animator;\r\nimport visu.handball.moves.model.player.Ball;\r\nimport visu.handball.moves.model.player.Defender;\r\nimport visu.handball.moves.model.player.HighlightableItem;\r\nimport visu.handball.moves.model.player.MovePoint;\r\nimport visu.handball.moves.model.player.Offender;\r\nimport visu.handball.moves.model.player.Player;\r\n\r\npublic class HandballModel implements Serializable {\r\n\r\n    private static final long serialVersionUID = -5372891552466311536L;\r\n\r\n    public enum State {\r\n\r\n        INITIAL,\r\n        PLACE_OFFENDERS,\r\n        PLACE_DEFENDERS,\r\n        PLACE_BALL,\r\n        EDIT,\r\n        EDIT_EVENT,\r\n        ANIMATION,\r\n        ANIMATION_RUNNING,\r\n        FULL_ANIMATION_ENDED\r\n    }\r\n\r\n    private static final int MAX_OFFENDERS = 6;\r\n\r\n    private static final int MAX_DEFENDERS = 6;\r\n\r\n    private static final int MARK_RADIUS = 12;\r\n\r\n    private static final String APP_NAME = \"jHandballMoves\";\r\n\r\n    private transient List<HandballModelListener> listeners;\r\n\r\n    private transient List<PlayerRemovedListener> playerRemoveListener;\r\n\r\n    private List<Defender> defenders;\r\n\r\n    private List<Offender> offenders;\r\n\r\n    private SortedSet<MoveEvent> events;\r\n\r\n    private State state;\r\n\r\n    private MoveEvent actualEvent;\r\n\r\n    private Player markedPlayer;\r\n\r\n    private HighlightableItem hightlightedItem;\r\n\r\n    private Offender ballOwner;\r\n\r\n    private Ball ball;\r\n\r\n    private Offender firstBallOwner;\r\n\r\n    private transient Animator runningAnimator;\r\n\r\n    private int animationSequenz;\r\n\r\n    private transient AnimationModel animationModel;\r\n\r\n    private transient HandballModel lastSavedModel;\r\n\r\n    private String comment;\r\n\r\n    private String moveName;\r\n\r\n    public HandballModel() {\r\n        listeners = new ArrayList<HandballModelListener>();\r\n        playerRemoveListener = new ArrayList<PlayerRemovedListener>();\r\n        initModel();\r\n    }\r\n\r\n    public void initModel() {\r\n        defenders = new ArrayList<Defender>();\r\n        Defender.setCounter(0);\r\n        offenders = new ArrayList<Offender>();\r\n        Offender.setCounter(0);\r\n        events = new TreeSet<MoveEvent>();\r\n        // Workaround wegen ToolBar\r\n        state = State.PLACE_OFFENDERS;\r\n        actualEvent = null;\r\n        markedPlayer = null;\r\n        firstBallOwner = null;\r\n        comment = \"\";\r\n        moveName = \"\";\r\n        resetBallPosition();\r\n        try {\r\n            lastSavedModel = (HandballModel) Main.deepCopy(this);\r\n        } catch (Exception e) {\r\n            lastSavedModel = null;\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    private void resetBallPosition() {\r\n        ball = new Ball(-500, -500);\r\n    }\r\n\r\n    public void addOffender(int x, int y) {\r\n        if (offenders.size() == MAX_OFFENDERS) {\r\n            JOptionPane.showMessageDialog(Main.getWindow(), \"Sie haben schon \" + MAX_OFFENDERS + \" Angreifer angelegt.\", \"Info:\", JOptionPane.INFORMATION_MESSAGE);\r\n        } else {\r\n            offenders.add(new Offender(x, y));\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void removePlayer(Player toRemove) {\r\n        if (eventDefinedWithPlayer(toRemove)) {\r\n            removeEventsOfPlayer(toRemove);\r\n        }\r\n        if (toRemove instanceof Offender) {\r\n            removeOffender((Offender) toRemove);\r\n        } else {\r\n            removeDefender((Defender) toRemove);\r\n        }\r\n    }\r\n\r\n    private void removeOffender(Offender toRemove) {\r\n        if (getFirstBallOwner() != null && getFirstBallOwner().equals(toRemove)) {\r\n            setFirstBallOwner(null);\r\n        }\r\n        offenders.remove(toRemove);\r\n        if ((getDefenders().size() + getOffenders().size()) == 0) {\r\n            markedPlayer = null;\r\n        }\r\n        // Spielernummer aktualisieren\r\n        Offender.setCounter(determineMaxPlayerNumber(offenders));\r\n        fireOffenderRemoved(toRemove);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void addDefender(int x, int y) {\r\n        if (defenders.size() == MAX_DEFENDERS) {\r\n            JOptionPane.showMessageDialog(Main.getWindow(), \"Sie haben schon \" + MAX_OFFENDERS + \" Verteidiger angelegt.\", \"Info:\", JOptionPane.INFORMATION_MESSAGE);\r\n        } else {\r\n            defenders.add(new Defender(x, y));\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    private void removeDefender(Defender toRemove) {\r\n        defenders.remove(toRemove);\r\n        if ((getDefenders().size() + getOffenders().size()) == 0) {\r\n            markedPlayer = null;\r\n        }\r\n        Defender.setCounter(determineMaxPlayerNumber(defenders));\r\n        fireDefenderRemoved(toRemove);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public boolean addListener(HandballModelListener o) {\r\n        return listeners.add(o);\r\n    }\r\n\r\n    public boolean removeListener(HandballModelListener o) {\r\n        return listeners.remove(o);\r\n    }\r\n\r\n    public boolean addPlayerRemovedListener(PlayerRemovedListener o) {\r\n        return playerRemoveListener.add(o);\r\n    }\r\n\r\n    public boolean removePlayerRemovedListener(PlayerRemovedListener o) {\r\n        return playerRemoveListener.remove(o);\r\n    }\r\n\r\n    private void fireModelChanged() {\r\n        setMoveName(getMoveName());\r\n        for (HandballModelListener listener : listeners) {\r\n            listener.modelChanged();\r\n        }\r\n    }\r\n\r\n    private void fireOffenderRemoved(Offender offender) {\r\n        for (PlayerRemovedListener listener : playerRemoveListener) {\r\n            listener.offenderRemoved(offender);\r\n        }\r\n    }\r\n\r\n    private void fireDefenderRemoved(Defender defender) {\r\n        for (PlayerRemovedListener listener : playerRemoveListener) {\r\n            listener.defenderRemoved(defender);\r\n        }\r\n    }\r\n\r\n    public List<Defender> getDefenders() {\r\n        return defenders;\r\n    }\r\n\r\n    public List<Offender> getOffenders() {\r\n        return offenders;\r\n    }\r\n\r\n    public State getState() {\r\n        return state;\r\n    }\r\n\r\n    public void setState(State state) {\r\n        if (state == State.EDIT) {\r\n            if (getActualMoveEvent() == null) {\r\n                // Wenn leer, dann Null, sonst letztes Move Event setzen\r\n                setActualMoveEvent(getEvents().isEmpty() ? null : (getEvents().get(getEvents().size() - 1)));\r\n            } else {\r\n                setActualMoveEvent(getActualMoveEvent());\r\n            }\r\n        }\r\n        if (state == State.PLACE_DEFENDERS || state == State.PLACE_OFFENDERS) {\r\n            if (getFirstBallOwner() != null) {\r\n                setBallOwner(getFirstBallOwner());\r\n            }\r\n            setActualMoveEvent(null);\r\n        }\r\n        this.state = state;\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void addMoveEvent(MoveEvent event) {\r\n        events.add(event);\r\n        if (state == State.EDIT) {\r\n            setActualMoveEvent(event);\r\n            state = State.EDIT_EVENT;\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void removeMoveEvent(MoveEvent event) {\r\n        events.remove(event);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public List<MoveEvent> getEvents() {\r\n        List<MoveEvent> list = new ArrayList<MoveEvent>(events);\r\n        return list;\r\n    }\r\n\r\n    public SortedSet<MoveEvent> getSortedEvents() {\r\n        return events;\r\n    }\r\n\r\n    public int getAcutalSequenceNr() {\r\n        if (actualEvent == null)\r\n            return 0;\r\n        else {\r\n            return actualEvent.getSequenceNr();\r\n        }\r\n    }\r\n\r\n    public void setActualMoveEvent(MoveEvent event) {\r\n        if (this.actualEvent != null) {\r\n            this.actualEvent.setMarked(false);\r\n        }\r\n        this.actualEvent = event;\r\n        computePlayerPositions();\r\n        // aktuellen Spieler setzen\r\n        setMarkedPlayer((event == null) ? null : event.getPlayer());\r\n        if (actualEvent != null) {\r\n            if (!actualEvent.isDestinationPointSet()) {\r\n                state = State.EDIT_EVENT;\r\n            } else {\r\n                if (state == State.FULL_ANIMATION_ENDED) {\r\n                    state = State.ANIMATION;\r\n                } else if (state != State.ANIMATION && state != State.ANIMATION_RUNNING) {\r\n                    state = State.EDIT;\r\n                }\r\n            }\r\n            actualEvent.setMarked(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setDestinationPointForEvent(MoveEvent event, int x, int y, boolean temp) {\r\n        event.setDestinationPoint(x, y, temp);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setControlPointForEvent(MoveEvent event, int x, int y, boolean temp) {\r\n        event.setControlPoint(x, y, temp);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setMovePointTo(MovePoint point, int x, int y) {\r\n        actualEvent.setPoint(point, x, y);\r\n        fireModelChanged();\r\n    }\r\n\r\n    private void computePlayerPositions() {\r\n        computePlayerPositions(getAcutalSequenceNr());\r\n    }\r\n\r\n    public void computePlayerPositions(int seqNr) {\r\n        // Spieler Positionen auf Ausgangsstellung\r\n        for (Player offender : offenders) {\r\n            offender.resetPosition();\r\n        }\r\n        for (Player defender : defenders) {\r\n            defender.resetPosition();\r\n        }\r\n        if (seqNr == 1) {\r\n            setBallOwner(firstBallOwner);\r\n        }\r\n        // alle Events mit kleinerer Sequenznummer verarbeiten\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() < seqNr) {\r\n                if (event instanceof PassEvent) {\r\n                    // Ball an anderen Spieler �bertragen\r\n                    setBallOwner(((PassEvent) event).getDestinationPlayer());\r\n                } else {\r\n                    if (event.getDestinationX() > -1 && event.getDestinationY() > -1) {\r\n                        event.getPlayer().setCurrentPosition(event.getDestinationX(), event.getDestinationY());\r\n                    }\r\n                }\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    public MoveEvent getActualMoveEvent() {\r\n        return actualEvent;\r\n    }\r\n\r\n    public Player getMarkedPlayer() {\r\n        return markedPlayer;\r\n    }\r\n\r\n    public void setMarkedPlayer(Player markedPlayer) {\r\n        // alten markierten Spieler demarkieren\r\n        if (this.markedPlayer != null) {\r\n            this.markedPlayer.setMarked(false);\r\n        }\r\n        // evtl. neuen Spieler markieren\r\n        this.markedPlayer = markedPlayer;\r\n        if (markedPlayer != null) {\r\n            markedPlayer.setMarked(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setHighLightedItem(HighlightableItem item) {\r\n        if (this.hightlightedItem != null) {\r\n            // altes Item zur�cksetzen\r\n            this.hightlightedItem.setHighlight(false);\r\n        }\r\n        this.hightlightedItem = item;\r\n        if (item != null) {\r\n            hightlightedItem.setHighlight(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public HighlightableItem getHightligtedItem() {\r\n        return hightlightedItem;\r\n    }\r\n\r\n    public Player getNearestPlayer(int x, int y) {\r\n        List<Player> all = new ArrayList<Player>(offenders);\r\n        all.addAll(defenders);\r\n        return findNearestPlayer(x, y, all);\r\n    }\r\n\r\n    public Offender getNearestOffender(int x, int y) {\r\n        List<Player> all = new ArrayList<Player>(offenders);\r\n        return (Offender) findNearestPlayer(x, y, all);\r\n    }\r\n\r\n    private Player findNearestPlayer(int x, int y, List<Player> players) {\r\n        double entfernung = Double.MAX_VALUE;\r\n        Player temp = null;\r\n        for (Player player : players) {\r\n            int player_x = player.getCurrent_x();\r\n            int player_y = player.getCurrent_y();\r\n            double tempEntfernung = Point2D.distance(x, y, player_x, player_y);\r\n            // Wenn naeher als der MARK_RADIUS\r\n            if (!(tempEntfernung > MARK_RADIUS)) {\r\n                if (tempEntfernung < entfernung) {\r\n                    temp = player;\r\n                    entfernung = tempEntfernung;\r\n                }\r\n            }\r\n        }\r\n        return temp;\r\n    }\r\n\r\n    public MovePoint getNearestMovePoint(int x, int y) {\r\n        MovePoint point = null;\r\n        if (actualEvent != null) {\r\n            double entfernung = Double.MAX_VALUE;\r\n            if (actualEvent.isDestinationPointSet()) {\r\n                int destination_x = actualEvent.getDestinationX();\r\n                int destination_y = actualEvent.getDestinationY();\r\n                double tempEntfernung = Point2D.distance(x, y, destination_x, destination_y);\r\n                // Wenn naeher als der MARK_RADIUS\r\n                if (!(tempEntfernung > MARK_RADIUS)) {\r\n                    if (tempEntfernung < entfernung) {\r\n                        point = actualEvent.getDestinationPoint();\r\n                        entfernung = tempEntfernung;\r\n                    }\r\n                }\r\n            }\r\n            if (actualEvent.isControlPointSet()) {\r\n                int controlPoint_x = actualEvent.getControlPointX();\r\n                int controlPoint_y = actualEvent.getControlPointY();\r\n                double tempEntfernung = Point2D.distance(x, y, controlPoint_x, controlPoint_y);\r\n                // Wenn naeher als der MARK_RADIUS\r\n                if (!(tempEntfernung > MARK_RADIUS)) {\r\n                    if (tempEntfernung < entfernung) {\r\n                        point = actualEvent.getControlPoint();\r\n                        entfernung = tempEntfernung;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return point;\r\n    }\r\n\r\n    public HighlightableItem getNearestHighlightableItem(int x, int y) {\r\n        HighlightableItem temp = null;\r\n        temp = getNearestMovePoint(x, y);\r\n        if (temp == null) {\r\n            temp = getNearestPlayer(x, y);\r\n        }\r\n        return temp;\r\n    }\r\n\r\n    public void movePlayerTo(Player actualPlayer, int x, int y) {\r\n        if (getAcutalSequenceNr() == 0) {\r\n            actualPlayer.setStart_x(x);\r\n            actualPlayer.setStart_y(y);\r\n        }\r\n        // Ansonsten muss die Position im entsprechenden Ereignis gesetzt\r\n        // werden\r\n        // Startposition darf nur im Angreifer/Verteidiger-Modus ge�ndert werden\r\n        fireModelChanged();\r\n    }\r\n\r\n    public boolean isSaved() {\r\n        boolean changed = false;\r\n        if (lastSavedModel != null) {\r\n            //Spielzugnamen vergleichen\r\n            if (lastSavedModel.getMoveName() != null) {\r\n                if (getMoveName() == null || !lastSavedModel.getMoveName().equals(getMoveName())) {\r\n                    return false;\r\n                }\r\n            } else if (getMoveName() != null) {\r\n                //alt: kein Name <-> neu: Name vorhanden\r\n                return false;\r\n            }\r\n            //Ueberprüfen ob Angreifer und Verteidiger unterschiedlich\r\n            // zuerst Spielerlisten vergleichen\r\n            if (changedPlayerList(getOffenders().toArray(new Player[getOffenders().size()]), lastSavedModel.getOffenders().toArray(new Player[lastSavedModel.getOffenders().size()])) || changedPlayerList(getDefenders().toArray(new Player[getDefenders().size()]), lastSavedModel.getDefenders().toArray(new Player[lastSavedModel.getDefenders().size()]))) {\r\n                changed = true;\r\n            } else {\r\n                List<MoveEvent> newEvents = getEvents();\r\n                List<MoveEvent> oldEvents = lastSavedModel.getEvents();\r\n                if (newEvents.size() == oldEvents.size()) {\r\n                    for (int i = 0; i < newEvents.size(); i++) {\r\n                        if (!newEvents.get(i).equals(oldEvents.get(i))) {\r\n                            changed = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                } else {\r\n                    changed = true;\r\n                }\r\n            }\r\n            if (!changed && (getFirstBallOwner() != null || lastSavedModel.getFirstBallOwner() != null)) {\r\n                changed = (getFirstBallOwner() == null) ^ (lastSavedModel.getFirstBallOwner() == null);\r\n                if (!changed) {\r\n                    changed = !getFirstBallOwner().equals(lastSavedModel.getFirstBallOwner());\r\n                }\r\n            }\r\n            // wurde Kommentar geändert?\r\n            if (!changed) {\r\n                if (comment == null || comment.equals(\"\")) {\r\n                    if (lastSavedModel.getComment() != null && !lastSavedModel.getComment().equals(\"\")) {\r\n                        changed = true;\r\n                    }\r\n                } else if (lastSavedModel.getComment() != null) {\r\n                    if (!lastSavedModel.getComment().equals(comment)) {\r\n                        changed = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return !changed;\r\n    }\r\n\r\n    private boolean changedPlayerList(Player[] newList, Player[] oldList) {\r\n        boolean changed = false;\r\n        int size = newList.length;\r\n        int sizeOld = oldList.length;\r\n        if (size == sizeOld) {\r\n            for (int i = 0; i < size; i++) {\r\n                if (!newList[i].equals(oldList[i])) {\r\n                    changed = true;\r\n                    break;\r\n                }\r\n            }\r\n        } else {\r\n            changed = true;\r\n        }\r\n        return changed;\r\n    }\r\n\r\n    public void initWithLoadedModel(HandballModel loadedModel) {\r\n        initModel();\r\n        offenders = loadedModel.getOffenders();\r\n        defenders = loadedModel.getDefenders();\r\n        events = loadedModel.getSortedEvents();\r\n        Offender.setCounter(determineMaxPlayerNumber(offenders));\r\n        Defender.setCounter(determineMaxPlayerNumber(defenders));\r\n        setFirstBallOwner(loadedModel.getFirstBallOwner());\r\n        setState(loadedModel.getState());\r\n        setActualMoveEvent(loadedModel.getActualMoveEvent());\r\n        setComment(loadedModel.getComment());\r\n        // zur Sicherheit\r\n        if (getComment() == null) {\r\n            setComment(\"\");\r\n        }\r\n        setMoveName(loadedModel.getMoveName());\r\n        markAsSaved(loadedModel);\r\n        fireModelChanged();\r\n    }\r\n\r\n    private int determineMaxPlayerNumber(List players) {\r\n        int max = 0;\r\n        for (Object o : players) {\r\n            if (o instanceof Player) {\r\n                Player player = (Player) o;\r\n                if (player.getPlayerNumber() > max) {\r\n                    max = player.getPlayerNumber();\r\n                }\r\n            }\r\n        }\r\n        return max;\r\n    }\r\n\r\n    public void markAsSaved(HandballModel model) {\r\n        try {\r\n            lastSavedModel = (HandballModel) Main.deepCopy(model);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            lastSavedModel = null;\r\n        }\r\n    }\r\n\r\n    public void setDelay(int eventIndex, int delay) {\r\n        getEvents().get(eventIndex).setDelay(delay);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setBallOwner(Offender ballOwner) {\r\n        if (this.ballOwner != null) {\r\n            this.ballOwner.setHasBall(false);\r\n        }\r\n        this.ballOwner = ballOwner;\r\n        if (ballOwner != null) {\r\n            ballOwner.setHasBall(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setBallOwnerSilent(Offender ballOwner) {\r\n        if (this.ballOwner != null) {\r\n            this.ballOwner.setHasBall(false);\r\n        }\r\n        this.ballOwner = ballOwner;\r\n        if (ballOwner != null) {\r\n            ballOwner.setHasBall(true);\r\n        }\r\n        // fireModelChanged();\r\n    }\r\n\r\n    public void startAnimation(boolean onlyActualSequence) {\r\n        setState(State.ANIMATION_RUNNING);\r\n        MoveEvent event = actualEvent;\r\n        if (event == null) {\r\n            event = getEvents().get(0);\r\n        }\r\n        setActualMoveEvent(event);\r\n        animationSequenz = event.getSequenceNr();\r\n        animationModel = new AnimationModel(event, this, onlyActualSequence);\r\n        runningAnimator = new Animator(this);\r\n        computePlayerPositions(animationSequenz);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void pauseAnimation(boolean pause) {\r\n        if (pause) {\r\n            runningAnimator.setPause(true);\r\n        } else {\r\n            runningAnimator.setPause(false);\r\n        }\r\n    }\r\n\r\n    public void initAnimation() {\r\n    }\r\n\r\n    public boolean nextAnimationStep() {\r\n        boolean finished = animationModel.nextStep();\r\n        if (finished) {\r\n            if (animationModel.isOnlyOneSequence()) {\r\n                setState(State.ANIMATION);\r\n                // n�chste Sequzenz ausw�hlen (einfaches sequentielles Anschauen des Spielzugs)\r\n                int nextSeq = (getAcutalSequenceNr() == getHighestSequenceNumber()) ? getAcutalSequenceNr() : getAcutalSequenceNr() + 1;\r\n                List<MoveEvent> nextSeqEvents = getMoveEvents(nextSeq);\r\n                if (nextSeqEvents.get(0) != null) {\r\n                    setActualMoveEvent(nextSeqEvents.get(0));\r\n                }\r\n            } else {\r\n                setState(State.FULL_ANIMATION_ENDED);\r\n            }\r\n        } else {\r\n            fireModelChanged();\r\n        }\r\n        return finished;\r\n    }\r\n\r\n    public void stopAnimation() {\r\n        setState(State.ANIMATION);\r\n        runningAnimator = null;\r\n        setActualMoveEvent(getActualMoveEvent());\r\n    }\r\n\r\n    public boolean isMarkedPlayerAddable() {\r\n        int seq = getAcutalSequenceNr();\r\n        return !events.contains(new MoveEvent(markedPlayer, seq));\r\n    }\r\n\r\n    public boolean passEventDefined(int seq) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() == seq && event instanceof PassEvent) {\r\n                defined = true;\r\n                break;\r\n            }\r\n            if (event.getSequenceNr() > seq) {\r\n                break;\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public boolean passEventDefined() {\r\n        return passEventDefined(getAcutalSequenceNr());\r\n    }\r\n\r\n    public boolean passEventDefinedAfter(int seq) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if ((event instanceof PassEvent) && (event.getSequenceNr() > seq)) {\r\n                defined = true;\r\n                break;\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public boolean eventDefinedAfter(int seq) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() > seq) {\r\n                defined = true;\r\n                break;\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public Ball getBall() {\r\n        return ball;\r\n    }\r\n\r\n    public void setFirstBallOwner(Offender offender) {\r\n        this.firstBallOwner = offender;\r\n        setBallOwner(offender);\r\n        if (firstBallOwner == null) {\r\n            resetBallPosition();\r\n        }\r\n    }\r\n\r\n    public Offender getFirstBallOwner() {\r\n        return firstBallOwner;\r\n    }\r\n\r\n    public boolean hasPlayerBallInNextSequence(Player player) {\r\n        PassEvent pass = null;\r\n        int seq = getAcutalSequenceNr();\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() == seq && event instanceof PassEvent) {\r\n                pass = (PassEvent) event;\r\n                break;\r\n            }\r\n            if (event.getSequenceNr() > seq) {\r\n                break;\r\n            }\r\n        }\r\n        if (pass != null && pass.getDestinationPlayer() != null) {\r\n            return pass.getDestinationPlayer().equals(player) && !passEventDefined(seq + 1);\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public boolean isBallSet() {\r\n        return ballOwner != null;\r\n    }\r\n\r\n    public boolean isGoalPassSet() {\r\n        boolean defined = false;\r\n        for (MoveEvent event : getEvents()) {\r\n            if (event instanceof PassEvent) {\r\n                PassEvent pass = (PassEvent) event;\r\n                if (pass.isGoalPass()) {\r\n                    defined = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public void moveBallTo(int x, int y) {\r\n        ball.setCurrent_x(x);\r\n        ball.setCurrent_y(y);\r\n    }\r\n\r\n    public List<MoveEvent> getActualMoveEvents() {\r\n        return getMoveEvents(getAcutalSequenceNr());\r\n    }\r\n\r\n    public List<MoveEvent> getMoveEvents(int sequenceNr) {\r\n        List<MoveEvent> sequenceEvents = new ArrayList<MoveEvent>();\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() == sequenceNr) {\r\n                sequenceEvents.add(event);\r\n            } else if (event.getSequenceNr() > getAcutalSequenceNr()) {\r\n                break;\r\n            }\r\n        }\r\n        return sequenceEvents;\r\n    }\r\n\r\n    /**\r\n     * Löscht das Aktuelle Ereignis und ALLE Folgenden\r\n     */\r\n    public void removeEventsAfter() {\r\n        MoveEvent event = getActualMoveEvent();\r\n        List<MoveEvent> toDeleteEvents = new ArrayList<MoveEvent>();\r\n        int sequenceNr = event.getSequenceNr();\r\n        // zu loeschende Events sammeln\r\n        for (MoveEvent evt : getEvents()) {\r\n            if (evt.getSequenceNr() > sequenceNr) {\r\n                // Event ist hoeher, also loeschen\r\n                toDeleteEvents.add(evt);\r\n            }\r\n        }\r\n        toDeleteEvents.add(event);\r\n        // gesammelte Events loeschen\r\n        for (MoveEvent deleteEvent : toDeleteEvents) {\r\n            removeMoveEvent(deleteEvent);\r\n        }\r\n        setActualMoveEvent((getEvents().size() > 0) ? getEvents().get(getEvents().size() - 1) : null);\r\n        fireModelChanged();\r\n    }\r\n\r\n    /**\r\n     * Löscht die Ereignisse (auch P�sse) des �bergebenen Spielers. Und die\r\n     * evtl. davon abh�ngigen Folgep�sse\r\n     *\r\n     * @param player\r\n     */\r\n    private void removeEventsOfPlayer(Player player) {\r\n        List<MoveEvent> toDeleteEvents = new ArrayList<MoveEvent>();\r\n        boolean playerInvolved = false;\r\n        // zu loeschende Events sammeln\r\n        for (MoveEvent evt : getEvents()) {\r\n            // Pass?\r\n            if (evt instanceof PassEvent) {\r\n                PassEvent pass = (PassEvent) evt;\r\n                // War ein Pass zu dem Spieler? oder Spieler passt selbst?\r\n                if (pass.getDestinationPlayer().equals(player) || pass.getPlayer().equals(player)) {\r\n                    playerInvolved = true;\r\n                }\r\n                // War Spieler an einem Pass beteiligt?\r\n                if (playerInvolved) {\r\n                    toDeleteEvents.add(pass);\r\n                    continue;\r\n                }\r\n            }\r\n            if (evt.getPlayer().equals(player)) {\r\n                toDeleteEvents.add(evt);\r\n            }\r\n        }\r\n        // gesammelte Events loeschen\r\n        for (MoveEvent deleteEvent : toDeleteEvents) {\r\n            removeMoveEvent(deleteEvent);\r\n        }\r\n        setActualMoveEvent((getEvents().size() > 0) ? getEvents().get(getEvents().size() - 1) : null);\r\n    }\r\n\r\n    public boolean eventDefinedWithPlayer(Player player) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if (event.getPlayer().equals(player)) {\r\n                defined = true;\r\n                break;\r\n            }\r\n            if (event instanceof PassEvent) {\r\n                PassEvent pass = (PassEvent) event;\r\n                if (pass.getDestinationPlayer().equals(player)) {\r\n                    defined = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public int getHighestSequenceNumber() {\r\n        if (events.size() == 0) {\r\n            return 0;\r\n        } else {\r\n            return events.last().getSequenceNr();\r\n        }\r\n    }\r\n\r\n    public String getMoveName() {\r\n        return moveName;\r\n    }\r\n\r\n    public void setMoveName(String moveName) {\r\n        this.moveName = moveName;\r\n        if (Main.getWindow() != null) {\r\n            StringBuffer buffer = new StringBuffer(APP_NAME);\r\n            buffer.append(\" - \");\r\n            if (moveName == null || moveName.equals(\"\")) {\r\n                buffer.append(\"Unbenannt\");\r\n                // Titelleiste aktualisieren\r\n            } else {\r\n                buffer.append(moveName);\r\n            }\r\n            if (!isSaved()) {\r\n                buffer.append(\"*\");\r\n            }\r\n            Main.getWindow().setTitle(buffer.toString());\r\n        }\r\n    }\r\n\r\n    public String getComment() {\r\n        if (comment == null) {\r\n            comment = \"\";\r\n        }\r\n        return comment;\r\n    }\r\n\r\n    public void setComment(String comment) {\r\n        this.comment = comment;\r\n        fireModelChanged();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/model/HandballModelTest10.java",
		"test_prompt": "// HandballModelTest10.java\npackage visu.handball.moves.model;\n\nimport java.awt.geom.Point2D;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\nimport javax.swing.JOptionPane;\nimport visu.handball.moves.Main;\nimport visu.handball.moves.model.animation.AnimationModel;\nimport visu.handball.moves.model.animation.Animator;\nimport visu.handball.moves.model.player.Ball;\nimport visu.handball.moves.model.player.Defender;\nimport visu.handball.moves.model.player.HighlightableItem;\nimport visu.handball.moves.model.player.MovePoint;\nimport visu.handball.moves.model.player.Offender;\nimport visu.handball.moves.model.player.Player;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HandballModel}.\n* It contains ten unit test cases for the {@link HandballModel#eventDefinedAfter(int)} method.\n*/\nclass HandballModelTest10 {"
	},
	{
		"original_code": "// HandballModel.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.model;\r\n\r\nimport java.awt.geom.Point2D;\r\nimport java.io.Serializable;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.SortedSet;\r\nimport java.util.TreeSet;\r\nimport javax.swing.JOptionPane;\r\nimport visu.handball.moves.Main;\r\nimport visu.handball.moves.model.animation.AnimationModel;\r\nimport visu.handball.moves.model.animation.Animator;\r\nimport visu.handball.moves.model.player.Ball;\r\nimport visu.handball.moves.model.player.Defender;\r\nimport visu.handball.moves.model.player.HighlightableItem;\r\nimport visu.handball.moves.model.player.MovePoint;\r\nimport visu.handball.moves.model.player.Offender;\r\nimport visu.handball.moves.model.player.Player;\r\n\r\npublic class HandballModel implements Serializable {\r\n\r\n    private static final long serialVersionUID = -5372891552466311536L;\r\n\r\n    public enum State {\r\n\r\n        INITIAL,\r\n        PLACE_OFFENDERS,\r\n        PLACE_DEFENDERS,\r\n        PLACE_BALL,\r\n        EDIT,\r\n        EDIT_EVENT,\r\n        ANIMATION,\r\n        ANIMATION_RUNNING,\r\n        FULL_ANIMATION_ENDED\r\n    }\r\n\r\n    private static final int MAX_OFFENDERS = 6;\r\n\r\n    private static final int MAX_DEFENDERS = 6;\r\n\r\n    private static final int MARK_RADIUS = 12;\r\n\r\n    private static final String APP_NAME = \"jHandballMoves\";\r\n\r\n    private transient List<HandballModelListener> listeners;\r\n\r\n    private transient List<PlayerRemovedListener> playerRemoveListener;\r\n\r\n    private List<Defender> defenders;\r\n\r\n    private List<Offender> offenders;\r\n\r\n    private SortedSet<MoveEvent> events;\r\n\r\n    private State state;\r\n\r\n    private MoveEvent actualEvent;\r\n\r\n    private Player markedPlayer;\r\n\r\n    private HighlightableItem hightlightedItem;\r\n\r\n    private Offender ballOwner;\r\n\r\n    private Ball ball;\r\n\r\n    private Offender firstBallOwner;\r\n\r\n    private transient Animator runningAnimator;\r\n\r\n    private int animationSequenz;\r\n\r\n    private transient AnimationModel animationModel;\r\n\r\n    private transient HandballModel lastSavedModel;\r\n\r\n    private String comment;\r\n\r\n    private String moveName;\r\n\r\n    public HandballModel() {\r\n        listeners = new ArrayList<HandballModelListener>();\r\n        playerRemoveListener = new ArrayList<PlayerRemovedListener>();\r\n        initModel();\r\n    }\r\n\r\n    public void initModel() {\r\n        defenders = new ArrayList<Defender>();\r\n        Defender.setCounter(0);\r\n        offenders = new ArrayList<Offender>();\r\n        Offender.setCounter(0);\r\n        events = new TreeSet<MoveEvent>();\r\n        // Workaround wegen ToolBar\r\n        state = State.PLACE_OFFENDERS;\r\n        actualEvent = null;\r\n        markedPlayer = null;\r\n        firstBallOwner = null;\r\n        comment = \"\";\r\n        moveName = \"\";\r\n        resetBallPosition();\r\n        try {\r\n            lastSavedModel = (HandballModel) Main.deepCopy(this);\r\n        } catch (Exception e) {\r\n            lastSavedModel = null;\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    private void resetBallPosition() {\r\n        ball = new Ball(-500, -500);\r\n    }\r\n\r\n    public void addOffender(int x, int y) {\r\n        if (offenders.size() == MAX_OFFENDERS) {\r\n            JOptionPane.showMessageDialog(Main.getWindow(), \"Sie haben schon \" + MAX_OFFENDERS + \" Angreifer angelegt.\", \"Info:\", JOptionPane.INFORMATION_MESSAGE);\r\n        } else {\r\n            offenders.add(new Offender(x, y));\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void removePlayer(Player toRemove) {\r\n        if (eventDefinedWithPlayer(toRemove)) {\r\n            removeEventsOfPlayer(toRemove);\r\n        }\r\n        if (toRemove instanceof Offender) {\r\n            removeOffender((Offender) toRemove);\r\n        } else {\r\n            removeDefender((Defender) toRemove);\r\n        }\r\n    }\r\n\r\n    private void removeOffender(Offender toRemove) {\r\n        if (getFirstBallOwner() != null && getFirstBallOwner().equals(toRemove)) {\r\n            setFirstBallOwner(null);\r\n        }\r\n        offenders.remove(toRemove);\r\n        if ((getDefenders().size() + getOffenders().size()) == 0) {\r\n            markedPlayer = null;\r\n        }\r\n        // Spielernummer aktualisieren\r\n        Offender.setCounter(determineMaxPlayerNumber(offenders));\r\n        fireOffenderRemoved(toRemove);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void addDefender(int x, int y) {\r\n        if (defenders.size() == MAX_DEFENDERS) {\r\n            JOptionPane.showMessageDialog(Main.getWindow(), \"Sie haben schon \" + MAX_OFFENDERS + \" Verteidiger angelegt.\", \"Info:\", JOptionPane.INFORMATION_MESSAGE);\r\n        } else {\r\n            defenders.add(new Defender(x, y));\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    private void removeDefender(Defender toRemove) {\r\n        defenders.remove(toRemove);\r\n        if ((getDefenders().size() + getOffenders().size()) == 0) {\r\n            markedPlayer = null;\r\n        }\r\n        Defender.setCounter(determineMaxPlayerNumber(defenders));\r\n        fireDefenderRemoved(toRemove);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public boolean addListener(HandballModelListener o) {\r\n        return listeners.add(o);\r\n    }\r\n\r\n    public boolean removeListener(HandballModelListener o) {\r\n        return listeners.remove(o);\r\n    }\r\n\r\n    public boolean addPlayerRemovedListener(PlayerRemovedListener o) {\r\n        return playerRemoveListener.add(o);\r\n    }\r\n\r\n    public boolean removePlayerRemovedListener(PlayerRemovedListener o) {\r\n        return playerRemoveListener.remove(o);\r\n    }\r\n\r\n    private void fireModelChanged() {\r\n        setMoveName(getMoveName());\r\n        for (HandballModelListener listener : listeners) {\r\n            listener.modelChanged();\r\n        }\r\n    }\r\n\r\n    private void fireOffenderRemoved(Offender offender) {\r\n        for (PlayerRemovedListener listener : playerRemoveListener) {\r\n            listener.offenderRemoved(offender);\r\n        }\r\n    }\r\n\r\n    private void fireDefenderRemoved(Defender defender) {\r\n        for (PlayerRemovedListener listener : playerRemoveListener) {\r\n            listener.defenderRemoved(defender);\r\n        }\r\n    }\r\n\r\n    public List<Defender> getDefenders() {\r\n        return defenders;\r\n    }\r\n\r\n    public List<Offender> getOffenders() {\r\n        return offenders;\r\n    }\r\n\r\n    public State getState() {\r\n        return state;\r\n    }\r\n\r\n    public void setState(State state) {\r\n        if (state == State.EDIT) {\r\n            if (getActualMoveEvent() == null) {\r\n                // Wenn leer, dann Null, sonst letztes Move Event setzen\r\n                setActualMoveEvent(getEvents().isEmpty() ? null : (getEvents().get(getEvents().size() - 1)));\r\n            } else {\r\n                setActualMoveEvent(getActualMoveEvent());\r\n            }\r\n        }\r\n        if (state == State.PLACE_DEFENDERS || state == State.PLACE_OFFENDERS) {\r\n            if (getFirstBallOwner() != null) {\r\n                setBallOwner(getFirstBallOwner());\r\n            }\r\n            setActualMoveEvent(null);\r\n        }\r\n        this.state = state;\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void addMoveEvent(MoveEvent event) {\r\n        events.add(event);\r\n        if (state == State.EDIT) {\r\n            setActualMoveEvent(event);\r\n            state = State.EDIT_EVENT;\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void removeMoveEvent(MoveEvent event) {\r\n        events.remove(event);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public List<MoveEvent> getEvents() {\r\n        List<MoveEvent> list = new ArrayList<MoveEvent>(events);\r\n        return list;\r\n    }\r\n\r\n    public SortedSet<MoveEvent> getSortedEvents() {\r\n        return events;\r\n    }\r\n\r\n    public int getAcutalSequenceNr() {\r\n        if (actualEvent == null)\r\n            return 0;\r\n        else {\r\n            return actualEvent.getSequenceNr();\r\n        }\r\n    }\r\n\r\n    public void setActualMoveEvent(MoveEvent event) {\r\n        if (this.actualEvent != null) {\r\n            this.actualEvent.setMarked(false);\r\n        }\r\n        this.actualEvent = event;\r\n        computePlayerPositions();\r\n        // aktuellen Spieler setzen\r\n        setMarkedPlayer((event == null) ? null : event.getPlayer());\r\n        if (actualEvent != null) {\r\n            if (!actualEvent.isDestinationPointSet()) {\r\n                state = State.EDIT_EVENT;\r\n            } else {\r\n                if (state == State.FULL_ANIMATION_ENDED) {\r\n                    state = State.ANIMATION;\r\n                } else if (state != State.ANIMATION && state != State.ANIMATION_RUNNING) {\r\n                    state = State.EDIT;\r\n                }\r\n            }\r\n            actualEvent.setMarked(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setDestinationPointForEvent(MoveEvent event, int x, int y, boolean temp) {\r\n        event.setDestinationPoint(x, y, temp);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setControlPointForEvent(MoveEvent event, int x, int y, boolean temp) {\r\n        event.setControlPoint(x, y, temp);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setMovePointTo(MovePoint point, int x, int y) {\r\n        actualEvent.setPoint(point, x, y);\r\n        fireModelChanged();\r\n    }\r\n\r\n    private void computePlayerPositions() {\r\n        computePlayerPositions(getAcutalSequenceNr());\r\n    }\r\n\r\n    public void computePlayerPositions(int seqNr) {\r\n        // Spieler Positionen auf Ausgangsstellung\r\n        for (Player offender : offenders) {\r\n            offender.resetPosition();\r\n        }\r\n        for (Player defender : defenders) {\r\n            defender.resetPosition();\r\n        }\r\n        if (seqNr == 1) {\r\n            setBallOwner(firstBallOwner);\r\n        }\r\n        // alle Events mit kleinerer Sequenznummer verarbeiten\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() < seqNr) {\r\n                if (event instanceof PassEvent) {\r\n                    // Ball an anderen Spieler �bertragen\r\n                    setBallOwner(((PassEvent) event).getDestinationPlayer());\r\n                } else {\r\n                    if (event.getDestinationX() > -1 && event.getDestinationY() > -1) {\r\n                        event.getPlayer().setCurrentPosition(event.getDestinationX(), event.getDestinationY());\r\n                    }\r\n                }\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    public MoveEvent getActualMoveEvent() {\r\n        return actualEvent;\r\n    }\r\n\r\n    public Player getMarkedPlayer() {\r\n        return markedPlayer;\r\n    }\r\n\r\n    public void setMarkedPlayer(Player markedPlayer) {\r\n        // alten markierten Spieler demarkieren\r\n        if (this.markedPlayer != null) {\r\n            this.markedPlayer.setMarked(false);\r\n        }\r\n        // evtl. neuen Spieler markieren\r\n        this.markedPlayer = markedPlayer;\r\n        if (markedPlayer != null) {\r\n            markedPlayer.setMarked(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setHighLightedItem(HighlightableItem item) {\r\n        if (this.hightlightedItem != null) {\r\n            // altes Item zur�cksetzen\r\n            this.hightlightedItem.setHighlight(false);\r\n        }\r\n        this.hightlightedItem = item;\r\n        if (item != null) {\r\n            hightlightedItem.setHighlight(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public HighlightableItem getHightligtedItem() {\r\n        return hightlightedItem;\r\n    }\r\n\r\n    public Player getNearestPlayer(int x, int y) {\r\n        List<Player> all = new ArrayList<Player>(offenders);\r\n        all.addAll(defenders);\r\n        return findNearestPlayer(x, y, all);\r\n    }\r\n\r\n    public Offender getNearestOffender(int x, int y) {\r\n        List<Player> all = new ArrayList<Player>(offenders);\r\n        return (Offender) findNearestPlayer(x, y, all);\r\n    }\r\n\r\n    private Player findNearestPlayer(int x, int y, List<Player> players) {\r\n        double entfernung = Double.MAX_VALUE;\r\n        Player temp = null;\r\n        for (Player player : players) {\r\n            int player_x = player.getCurrent_x();\r\n            int player_y = player.getCurrent_y();\r\n            double tempEntfernung = Point2D.distance(x, y, player_x, player_y);\r\n            // Wenn naeher als der MARK_RADIUS\r\n            if (!(tempEntfernung > MARK_RADIUS)) {\r\n                if (tempEntfernung < entfernung) {\r\n                    temp = player;\r\n                    entfernung = tempEntfernung;\r\n                }\r\n            }\r\n        }\r\n        return temp;\r\n    }\r\n\r\n    public MovePoint getNearestMovePoint(int x, int y) {\r\n        MovePoint point = null;\r\n        if (actualEvent != null) {\r\n            double entfernung = Double.MAX_VALUE;\r\n            if (actualEvent.isDestinationPointSet()) {\r\n                int destination_x = actualEvent.getDestinationX();\r\n                int destination_y = actualEvent.getDestinationY();\r\n                double tempEntfernung = Point2D.distance(x, y, destination_x, destination_y);\r\n                // Wenn naeher als der MARK_RADIUS\r\n                if (!(tempEntfernung > MARK_RADIUS)) {\r\n                    if (tempEntfernung < entfernung) {\r\n                        point = actualEvent.getDestinationPoint();\r\n                        entfernung = tempEntfernung;\r\n                    }\r\n                }\r\n            }\r\n            if (actualEvent.isControlPointSet()) {\r\n                int controlPoint_x = actualEvent.getControlPointX();\r\n                int controlPoint_y = actualEvent.getControlPointY();\r\n                double tempEntfernung = Point2D.distance(x, y, controlPoint_x, controlPoint_y);\r\n                // Wenn naeher als der MARK_RADIUS\r\n                if (!(tempEntfernung > MARK_RADIUS)) {\r\n                    if (tempEntfernung < entfernung) {\r\n                        point = actualEvent.getControlPoint();\r\n                        entfernung = tempEntfernung;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return point;\r\n    }\r\n\r\n    public HighlightableItem getNearestHighlightableItem(int x, int y) {\r\n        HighlightableItem temp = null;\r\n        temp = getNearestMovePoint(x, y);\r\n        if (temp == null) {\r\n            temp = getNearestPlayer(x, y);\r\n        }\r\n        return temp;\r\n    }\r\n\r\n    public void movePlayerTo(Player actualPlayer, int x, int y) {\r\n        if (getAcutalSequenceNr() == 0) {\r\n            actualPlayer.setStart_x(x);\r\n            actualPlayer.setStart_y(y);\r\n        }\r\n        // Ansonsten muss die Position im entsprechenden Ereignis gesetzt\r\n        // werden\r\n        // Startposition darf nur im Angreifer/Verteidiger-Modus ge�ndert werden\r\n        fireModelChanged();\r\n    }\r\n\r\n    public boolean isSaved() {\r\n        boolean changed = false;\r\n        if (lastSavedModel != null) {\r\n            //Spielzugnamen vergleichen\r\n            if (lastSavedModel.getMoveName() != null) {\r\n                if (getMoveName() == null || !lastSavedModel.getMoveName().equals(getMoveName())) {\r\n                    return false;\r\n                }\r\n            } else if (getMoveName() != null) {\r\n                //alt: kein Name <-> neu: Name vorhanden\r\n                return false;\r\n            }\r\n            //Ueberprüfen ob Angreifer und Verteidiger unterschiedlich\r\n            // zuerst Spielerlisten vergleichen\r\n            if (changedPlayerList(getOffenders().toArray(new Player[getOffenders().size()]), lastSavedModel.getOffenders().toArray(new Player[lastSavedModel.getOffenders().size()])) || changedPlayerList(getDefenders().toArray(new Player[getDefenders().size()]), lastSavedModel.getDefenders().toArray(new Player[lastSavedModel.getDefenders().size()]))) {\r\n                changed = true;\r\n            } else {\r\n                List<MoveEvent> newEvents = getEvents();\r\n                List<MoveEvent> oldEvents = lastSavedModel.getEvents();\r\n                if (newEvents.size() == oldEvents.size()) {\r\n                    for (int i = 0; i < newEvents.size(); i++) {\r\n                        if (!newEvents.get(i).equals(oldEvents.get(i))) {\r\n                            changed = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                } else {\r\n                    changed = true;\r\n                }\r\n            }\r\n            if (!changed && (getFirstBallOwner() != null || lastSavedModel.getFirstBallOwner() != null)) {\r\n                changed = (getFirstBallOwner() == null) ^ (lastSavedModel.getFirstBallOwner() == null);\r\n                if (!changed) {\r\n                    changed = !getFirstBallOwner().equals(lastSavedModel.getFirstBallOwner());\r\n                }\r\n            }\r\n            // wurde Kommentar geändert?\r\n            if (!changed) {\r\n                if (comment == null || comment.equals(\"\")) {\r\n                    if (lastSavedModel.getComment() != null && !lastSavedModel.getComment().equals(\"\")) {\r\n                        changed = true;\r\n                    }\r\n                } else if (lastSavedModel.getComment() != null) {\r\n                    if (!lastSavedModel.getComment().equals(comment)) {\r\n                        changed = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return !changed;\r\n    }\r\n\r\n    private boolean changedPlayerList(Player[] newList, Player[] oldList) {\r\n        boolean changed = false;\r\n        int size = newList.length;\r\n        int sizeOld = oldList.length;\r\n        if (size == sizeOld) {\r\n            for (int i = 0; i < size; i++) {\r\n                if (!newList[i].equals(oldList[i])) {\r\n                    changed = true;\r\n                    break;\r\n                }\r\n            }\r\n        } else {\r\n            changed = true;\r\n        }\r\n        return changed;\r\n    }\r\n\r\n    public void initWithLoadedModel(HandballModel loadedModel) {\r\n        initModel();\r\n        offenders = loadedModel.getOffenders();\r\n        defenders = loadedModel.getDefenders();\r\n        events = loadedModel.getSortedEvents();\r\n        Offender.setCounter(determineMaxPlayerNumber(offenders));\r\n        Defender.setCounter(determineMaxPlayerNumber(defenders));\r\n        setFirstBallOwner(loadedModel.getFirstBallOwner());\r\n        setState(loadedModel.getState());\r\n        setActualMoveEvent(loadedModel.getActualMoveEvent());\r\n        setComment(loadedModel.getComment());\r\n        // zur Sicherheit\r\n        if (getComment() == null) {\r\n            setComment(\"\");\r\n        }\r\n        setMoveName(loadedModel.getMoveName());\r\n        markAsSaved(loadedModel);\r\n        fireModelChanged();\r\n    }\r\n\r\n    private int determineMaxPlayerNumber(List players) {\r\n        int max = 0;\r\n        for (Object o : players) {\r\n            if (o instanceof Player) {\r\n                Player player = (Player) o;\r\n                if (player.getPlayerNumber() > max) {\r\n                    max = player.getPlayerNumber();\r\n                }\r\n            }\r\n        }\r\n        return max;\r\n    }\r\n\r\n    public void markAsSaved(HandballModel model) {\r\n        try {\r\n            lastSavedModel = (HandballModel) Main.deepCopy(model);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            lastSavedModel = null;\r\n        }\r\n    }\r\n\r\n    public void setDelay(int eventIndex, int delay) {\r\n        getEvents().get(eventIndex).setDelay(delay);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setBallOwner(Offender ballOwner) {\r\n        if (this.ballOwner != null) {\r\n            this.ballOwner.setHasBall(false);\r\n        }\r\n        this.ballOwner = ballOwner;\r\n        if (ballOwner != null) {\r\n            ballOwner.setHasBall(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setBallOwnerSilent(Offender ballOwner) {\r\n        if (this.ballOwner != null) {\r\n            this.ballOwner.setHasBall(false);\r\n        }\r\n        this.ballOwner = ballOwner;\r\n        if (ballOwner != null) {\r\n            ballOwner.setHasBall(true);\r\n        }\r\n        // fireModelChanged();\r\n    }\r\n\r\n    public void startAnimation(boolean onlyActualSequence) {\r\n        setState(State.ANIMATION_RUNNING);\r\n        MoveEvent event = actualEvent;\r\n        if (event == null) {\r\n            event = getEvents().get(0);\r\n        }\r\n        setActualMoveEvent(event);\r\n        animationSequenz = event.getSequenceNr();\r\n        animationModel = new AnimationModel(event, this, onlyActualSequence);\r\n        runningAnimator = new Animator(this);\r\n        computePlayerPositions(animationSequenz);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void pauseAnimation(boolean pause) {\r\n        if (pause) {\r\n            runningAnimator.setPause(true);\r\n        } else {\r\n            runningAnimator.setPause(false);\r\n        }\r\n    }\r\n\r\n    public void initAnimation() {\r\n    }\r\n\r\n    public boolean nextAnimationStep() {\r\n        boolean finished = animationModel.nextStep();\r\n        if (finished) {\r\n            if (animationModel.isOnlyOneSequence()) {\r\n                setState(State.ANIMATION);\r\n                // n�chste Sequzenz ausw�hlen (einfaches sequentielles Anschauen des Spielzugs)\r\n                int nextSeq = (getAcutalSequenceNr() == getHighestSequenceNumber()) ? getAcutalSequenceNr() : getAcutalSequenceNr() + 1;\r\n                List<MoveEvent> nextSeqEvents = getMoveEvents(nextSeq);\r\n                if (nextSeqEvents.get(0) != null) {\r\n                    setActualMoveEvent(nextSeqEvents.get(0));\r\n                }\r\n            } else {\r\n                setState(State.FULL_ANIMATION_ENDED);\r\n            }\r\n        } else {\r\n            fireModelChanged();\r\n        }\r\n        return finished;\r\n    }\r\n\r\n    public void stopAnimation() {\r\n        setState(State.ANIMATION);\r\n        runningAnimator = null;\r\n        setActualMoveEvent(getActualMoveEvent());\r\n    }\r\n\r\n    public boolean isMarkedPlayerAddable() {\r\n        int seq = getAcutalSequenceNr();\r\n        return !events.contains(new MoveEvent(markedPlayer, seq));\r\n    }\r\n\r\n    public boolean passEventDefined(int seq) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() == seq && event instanceof PassEvent) {\r\n                defined = true;\r\n                break;\r\n            }\r\n            if (event.getSequenceNr() > seq) {\r\n                break;\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public boolean passEventDefined() {\r\n        return passEventDefined(getAcutalSequenceNr());\r\n    }\r\n\r\n    public boolean passEventDefinedAfter(int seq) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if ((event instanceof PassEvent) && (event.getSequenceNr() > seq)) {\r\n                defined = true;\r\n                break;\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public boolean eventDefinedAfter(int seq) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() > seq) {\r\n                defined = true;\r\n                break;\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public Ball getBall() {\r\n        return ball;\r\n    }\r\n\r\n    public void setFirstBallOwner(Offender offender) {\r\n        this.firstBallOwner = offender;\r\n        setBallOwner(offender);\r\n        if (firstBallOwner == null) {\r\n            resetBallPosition();\r\n        }\r\n    }\r\n\r\n    public Offender getFirstBallOwner() {\r\n        return firstBallOwner;\r\n    }\r\n\r\n    public boolean hasPlayerBallInNextSequence(Player player) {\r\n        PassEvent pass = null;\r\n        int seq = getAcutalSequenceNr();\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() == seq && event instanceof PassEvent) {\r\n                pass = (PassEvent) event;\r\n                break;\r\n            }\r\n            if (event.getSequenceNr() > seq) {\r\n                break;\r\n            }\r\n        }\r\n        if (pass != null && pass.getDestinationPlayer() != null) {\r\n            return pass.getDestinationPlayer().equals(player) && !passEventDefined(seq + 1);\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public boolean isBallSet() {\r\n        return ballOwner != null;\r\n    }\r\n\r\n    public boolean isGoalPassSet() {\r\n        boolean defined = false;\r\n        for (MoveEvent event : getEvents()) {\r\n            if (event instanceof PassEvent) {\r\n                PassEvent pass = (PassEvent) event;\r\n                if (pass.isGoalPass()) {\r\n                    defined = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public void moveBallTo(int x, int y) {\r\n        ball.setCurrent_x(x);\r\n        ball.setCurrent_y(y);\r\n    }\r\n\r\n    public List<MoveEvent> getActualMoveEvents() {\r\n        return getMoveEvents(getAcutalSequenceNr());\r\n    }\r\n\r\n    public List<MoveEvent> getMoveEvents(int sequenceNr) {\r\n        List<MoveEvent> sequenceEvents = new ArrayList<MoveEvent>();\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() == sequenceNr) {\r\n                sequenceEvents.add(event);\r\n            } else if (event.getSequenceNr() > getAcutalSequenceNr()) {\r\n                break;\r\n            }\r\n        }\r\n        return sequenceEvents;\r\n    }\r\n\r\n    /**\r\n     * Löscht das Aktuelle Ereignis und ALLE Folgenden\r\n     */\r\n    public void removeEventsAfter() {\r\n        MoveEvent event = getActualMoveEvent();\r\n        List<MoveEvent> toDeleteEvents = new ArrayList<MoveEvent>();\r\n        int sequenceNr = event.getSequenceNr();\r\n        // zu loeschende Events sammeln\r\n        for (MoveEvent evt : getEvents()) {\r\n            if (evt.getSequenceNr() > sequenceNr) {\r\n                // Event ist hoeher, also loeschen\r\n                toDeleteEvents.add(evt);\r\n            }\r\n        }\r\n        toDeleteEvents.add(event);\r\n        // gesammelte Events loeschen\r\n        for (MoveEvent deleteEvent : toDeleteEvents) {\r\n            removeMoveEvent(deleteEvent);\r\n        }\r\n        setActualMoveEvent((getEvents().size() > 0) ? getEvents().get(getEvents().size() - 1) : null);\r\n        fireModelChanged();\r\n    }\r\n\r\n    /**\r\n     * Löscht die Ereignisse (auch P�sse) des �bergebenen Spielers. Und die\r\n     * evtl. davon abh�ngigen Folgep�sse\r\n     *\r\n     * @param player\r\n     */\r\n    private void removeEventsOfPlayer(Player player) {\r\n        List<MoveEvent> toDeleteEvents = new ArrayList<MoveEvent>();\r\n        boolean playerInvolved = false;\r\n        // zu loeschende Events sammeln\r\n        for (MoveEvent evt : getEvents()) {\r\n            // Pass?\r\n            if (evt instanceof PassEvent) {\r\n                PassEvent pass = (PassEvent) evt;\r\n                // War ein Pass zu dem Spieler? oder Spieler passt selbst?\r\n                if (pass.getDestinationPlayer().equals(player) || pass.getPlayer().equals(player)) {\r\n                    playerInvolved = true;\r\n                }\r\n                // War Spieler an einem Pass beteiligt?\r\n                if (playerInvolved) {\r\n                    toDeleteEvents.add(pass);\r\n                    continue;\r\n                }\r\n            }\r\n            if (evt.getPlayer().equals(player)) {\r\n                toDeleteEvents.add(evt);\r\n            }\r\n        }\r\n        // gesammelte Events loeschen\r\n        for (MoveEvent deleteEvent : toDeleteEvents) {\r\n            removeMoveEvent(deleteEvent);\r\n        }\r\n        setActualMoveEvent((getEvents().size() > 0) ? getEvents().get(getEvents().size() - 1) : null);\r\n    }\r\n\r\n    public boolean eventDefinedWithPlayer(Player player) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if (event.getPlayer().equals(player)) {\r\n                defined = true;\r\n                break;\r\n            }\r\n            if (event instanceof PassEvent) {\r\n                PassEvent pass = (PassEvent) event;\r\n                if (pass.getDestinationPlayer().equals(player)) {\r\n                    defined = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public int getHighestSequenceNumber() {\r\n        if (events.size() == 0) {\r\n            return 0;\r\n        } else {\r\n            return events.last().getSequenceNr();\r\n        }\r\n    }\r\n\r\n    public String getMoveName() {\r\n        return moveName;\r\n    }\r\n\r\n    public void setMoveName(String moveName) {\r\n        this.moveName = moveName;\r\n        if (Main.getWindow() != null) {\r\n            StringBuffer buffer = new StringBuffer(APP_NAME);\r\n            buffer.append(\" - \");\r\n            if (moveName == null || moveName.equals(\"\")) {\r\n                buffer.append(\"Unbenannt\");\r\n                // Titelleiste aktualisieren\r\n            } else {\r\n                buffer.append(moveName);\r\n            }\r\n            if (!isSaved()) {\r\n                buffer.append(\"*\");\r\n            }\r\n            Main.getWindow().setTitle(buffer.toString());\r\n        }\r\n    }\r\n\r\n    public String getComment() {\r\n        if (comment == null) {\r\n            comment = \"\";\r\n        }\r\n        return comment;\r\n    }\r\n\r\n    public void setComment(String comment) {\r\n        this.comment = comment;\r\n        fireModelChanged();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/model/HandballModelTest11.java",
		"test_prompt": "// HandballModelTest11.java\npackage visu.handball.moves.model;\n\nimport java.awt.geom.Point2D;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\nimport javax.swing.JOptionPane;\nimport visu.handball.moves.Main;\nimport visu.handball.moves.model.animation.AnimationModel;\nimport visu.handball.moves.model.animation.Animator;\nimport visu.handball.moves.model.player.Ball;\nimport visu.handball.moves.model.player.Defender;\nimport visu.handball.moves.model.player.HighlightableItem;\nimport visu.handball.moves.model.player.MovePoint;\nimport visu.handball.moves.model.player.Offender;\nimport visu.handball.moves.model.player.Player;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HandballModel}.\n* It contains ten unit test cases for the {@link HandballModel#hasPlayerBallInNextSequence(Player)} method.\n*/\nclass HandballModelTest11 {"
	},
	{
		"original_code": "// HandballModel.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.model;\r\n\r\nimport java.awt.geom.Point2D;\r\nimport java.io.Serializable;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.SortedSet;\r\nimport java.util.TreeSet;\r\nimport javax.swing.JOptionPane;\r\nimport visu.handball.moves.Main;\r\nimport visu.handball.moves.model.animation.AnimationModel;\r\nimport visu.handball.moves.model.animation.Animator;\r\nimport visu.handball.moves.model.player.Ball;\r\nimport visu.handball.moves.model.player.Defender;\r\nimport visu.handball.moves.model.player.HighlightableItem;\r\nimport visu.handball.moves.model.player.MovePoint;\r\nimport visu.handball.moves.model.player.Offender;\r\nimport visu.handball.moves.model.player.Player;\r\n\r\npublic class HandballModel implements Serializable {\r\n\r\n    private static final long serialVersionUID = -5372891552466311536L;\r\n\r\n    public enum State {\r\n\r\n        INITIAL,\r\n        PLACE_OFFENDERS,\r\n        PLACE_DEFENDERS,\r\n        PLACE_BALL,\r\n        EDIT,\r\n        EDIT_EVENT,\r\n        ANIMATION,\r\n        ANIMATION_RUNNING,\r\n        FULL_ANIMATION_ENDED\r\n    }\r\n\r\n    private static final int MAX_OFFENDERS = 6;\r\n\r\n    private static final int MAX_DEFENDERS = 6;\r\n\r\n    private static final int MARK_RADIUS = 12;\r\n\r\n    private static final String APP_NAME = \"jHandballMoves\";\r\n\r\n    private transient List<HandballModelListener> listeners;\r\n\r\n    private transient List<PlayerRemovedListener> playerRemoveListener;\r\n\r\n    private List<Defender> defenders;\r\n\r\n    private List<Offender> offenders;\r\n\r\n    private SortedSet<MoveEvent> events;\r\n\r\n    private State state;\r\n\r\n    private MoveEvent actualEvent;\r\n\r\n    private Player markedPlayer;\r\n\r\n    private HighlightableItem hightlightedItem;\r\n\r\n    private Offender ballOwner;\r\n\r\n    private Ball ball;\r\n\r\n    private Offender firstBallOwner;\r\n\r\n    private transient Animator runningAnimator;\r\n\r\n    private int animationSequenz;\r\n\r\n    private transient AnimationModel animationModel;\r\n\r\n    private transient HandballModel lastSavedModel;\r\n\r\n    private String comment;\r\n\r\n    private String moveName;\r\n\r\n    public HandballModel() {\r\n        listeners = new ArrayList<HandballModelListener>();\r\n        playerRemoveListener = new ArrayList<PlayerRemovedListener>();\r\n        initModel();\r\n    }\r\n\r\n    public void initModel() {\r\n        defenders = new ArrayList<Defender>();\r\n        Defender.setCounter(0);\r\n        offenders = new ArrayList<Offender>();\r\n        Offender.setCounter(0);\r\n        events = new TreeSet<MoveEvent>();\r\n        // Workaround wegen ToolBar\r\n        state = State.PLACE_OFFENDERS;\r\n        actualEvent = null;\r\n        markedPlayer = null;\r\n        firstBallOwner = null;\r\n        comment = \"\";\r\n        moveName = \"\";\r\n        resetBallPosition();\r\n        try {\r\n            lastSavedModel = (HandballModel) Main.deepCopy(this);\r\n        } catch (Exception e) {\r\n            lastSavedModel = null;\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    private void resetBallPosition() {\r\n        ball = new Ball(-500, -500);\r\n    }\r\n\r\n    public void addOffender(int x, int y) {\r\n        if (offenders.size() == MAX_OFFENDERS) {\r\n            JOptionPane.showMessageDialog(Main.getWindow(), \"Sie haben schon \" + MAX_OFFENDERS + \" Angreifer angelegt.\", \"Info:\", JOptionPane.INFORMATION_MESSAGE);\r\n        } else {\r\n            offenders.add(new Offender(x, y));\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void removePlayer(Player toRemove) {\r\n        if (eventDefinedWithPlayer(toRemove)) {\r\n            removeEventsOfPlayer(toRemove);\r\n        }\r\n        if (toRemove instanceof Offender) {\r\n            removeOffender((Offender) toRemove);\r\n        } else {\r\n            removeDefender((Defender) toRemove);\r\n        }\r\n    }\r\n\r\n    private void removeOffender(Offender toRemove) {\r\n        if (getFirstBallOwner() != null && getFirstBallOwner().equals(toRemove)) {\r\n            setFirstBallOwner(null);\r\n        }\r\n        offenders.remove(toRemove);\r\n        if ((getDefenders().size() + getOffenders().size()) == 0) {\r\n            markedPlayer = null;\r\n        }\r\n        // Spielernummer aktualisieren\r\n        Offender.setCounter(determineMaxPlayerNumber(offenders));\r\n        fireOffenderRemoved(toRemove);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void addDefender(int x, int y) {\r\n        if (defenders.size() == MAX_DEFENDERS) {\r\n            JOptionPane.showMessageDialog(Main.getWindow(), \"Sie haben schon \" + MAX_OFFENDERS + \" Verteidiger angelegt.\", \"Info:\", JOptionPane.INFORMATION_MESSAGE);\r\n        } else {\r\n            defenders.add(new Defender(x, y));\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    private void removeDefender(Defender toRemove) {\r\n        defenders.remove(toRemove);\r\n        if ((getDefenders().size() + getOffenders().size()) == 0) {\r\n            markedPlayer = null;\r\n        }\r\n        Defender.setCounter(determineMaxPlayerNumber(defenders));\r\n        fireDefenderRemoved(toRemove);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public boolean addListener(HandballModelListener o) {\r\n        return listeners.add(o);\r\n    }\r\n\r\n    public boolean removeListener(HandballModelListener o) {\r\n        return listeners.remove(o);\r\n    }\r\n\r\n    public boolean addPlayerRemovedListener(PlayerRemovedListener o) {\r\n        return playerRemoveListener.add(o);\r\n    }\r\n\r\n    public boolean removePlayerRemovedListener(PlayerRemovedListener o) {\r\n        return playerRemoveListener.remove(o);\r\n    }\r\n\r\n    private void fireModelChanged() {\r\n        setMoveName(getMoveName());\r\n        for (HandballModelListener listener : listeners) {\r\n            listener.modelChanged();\r\n        }\r\n    }\r\n\r\n    private void fireOffenderRemoved(Offender offender) {\r\n        for (PlayerRemovedListener listener : playerRemoveListener) {\r\n            listener.offenderRemoved(offender);\r\n        }\r\n    }\r\n\r\n    private void fireDefenderRemoved(Defender defender) {\r\n        for (PlayerRemovedListener listener : playerRemoveListener) {\r\n            listener.defenderRemoved(defender);\r\n        }\r\n    }\r\n\r\n    public List<Defender> getDefenders() {\r\n        return defenders;\r\n    }\r\n\r\n    public List<Offender> getOffenders() {\r\n        return offenders;\r\n    }\r\n\r\n    public State getState() {\r\n        return state;\r\n    }\r\n\r\n    public void setState(State state) {\r\n        if (state == State.EDIT) {\r\n            if (getActualMoveEvent() == null) {\r\n                // Wenn leer, dann Null, sonst letztes Move Event setzen\r\n                setActualMoveEvent(getEvents().isEmpty() ? null : (getEvents().get(getEvents().size() - 1)));\r\n            } else {\r\n                setActualMoveEvent(getActualMoveEvent());\r\n            }\r\n        }\r\n        if (state == State.PLACE_DEFENDERS || state == State.PLACE_OFFENDERS) {\r\n            if (getFirstBallOwner() != null) {\r\n                setBallOwner(getFirstBallOwner());\r\n            }\r\n            setActualMoveEvent(null);\r\n        }\r\n        this.state = state;\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void addMoveEvent(MoveEvent event) {\r\n        events.add(event);\r\n        if (state == State.EDIT) {\r\n            setActualMoveEvent(event);\r\n            state = State.EDIT_EVENT;\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void removeMoveEvent(MoveEvent event) {\r\n        events.remove(event);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public List<MoveEvent> getEvents() {\r\n        List<MoveEvent> list = new ArrayList<MoveEvent>(events);\r\n        return list;\r\n    }\r\n\r\n    public SortedSet<MoveEvent> getSortedEvents() {\r\n        return events;\r\n    }\r\n\r\n    public int getAcutalSequenceNr() {\r\n        if (actualEvent == null)\r\n            return 0;\r\n        else {\r\n            return actualEvent.getSequenceNr();\r\n        }\r\n    }\r\n\r\n    public void setActualMoveEvent(MoveEvent event) {\r\n        if (this.actualEvent != null) {\r\n            this.actualEvent.setMarked(false);\r\n        }\r\n        this.actualEvent = event;\r\n        computePlayerPositions();\r\n        // aktuellen Spieler setzen\r\n        setMarkedPlayer((event == null) ? null : event.getPlayer());\r\n        if (actualEvent != null) {\r\n            if (!actualEvent.isDestinationPointSet()) {\r\n                state = State.EDIT_EVENT;\r\n            } else {\r\n                if (state == State.FULL_ANIMATION_ENDED) {\r\n                    state = State.ANIMATION;\r\n                } else if (state != State.ANIMATION && state != State.ANIMATION_RUNNING) {\r\n                    state = State.EDIT;\r\n                }\r\n            }\r\n            actualEvent.setMarked(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setDestinationPointForEvent(MoveEvent event, int x, int y, boolean temp) {\r\n        event.setDestinationPoint(x, y, temp);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setControlPointForEvent(MoveEvent event, int x, int y, boolean temp) {\r\n        event.setControlPoint(x, y, temp);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setMovePointTo(MovePoint point, int x, int y) {\r\n        actualEvent.setPoint(point, x, y);\r\n        fireModelChanged();\r\n    }\r\n\r\n    private void computePlayerPositions() {\r\n        computePlayerPositions(getAcutalSequenceNr());\r\n    }\r\n\r\n    public void computePlayerPositions(int seqNr) {\r\n        // Spieler Positionen auf Ausgangsstellung\r\n        for (Player offender : offenders) {\r\n            offender.resetPosition();\r\n        }\r\n        for (Player defender : defenders) {\r\n            defender.resetPosition();\r\n        }\r\n        if (seqNr == 1) {\r\n            setBallOwner(firstBallOwner);\r\n        }\r\n        // alle Events mit kleinerer Sequenznummer verarbeiten\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() < seqNr) {\r\n                if (event instanceof PassEvent) {\r\n                    // Ball an anderen Spieler �bertragen\r\n                    setBallOwner(((PassEvent) event).getDestinationPlayer());\r\n                } else {\r\n                    if (event.getDestinationX() > -1 && event.getDestinationY() > -1) {\r\n                        event.getPlayer().setCurrentPosition(event.getDestinationX(), event.getDestinationY());\r\n                    }\r\n                }\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    public MoveEvent getActualMoveEvent() {\r\n        return actualEvent;\r\n    }\r\n\r\n    public Player getMarkedPlayer() {\r\n        return markedPlayer;\r\n    }\r\n\r\n    public void setMarkedPlayer(Player markedPlayer) {\r\n        // alten markierten Spieler demarkieren\r\n        if (this.markedPlayer != null) {\r\n            this.markedPlayer.setMarked(false);\r\n        }\r\n        // evtl. neuen Spieler markieren\r\n        this.markedPlayer = markedPlayer;\r\n        if (markedPlayer != null) {\r\n            markedPlayer.setMarked(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setHighLightedItem(HighlightableItem item) {\r\n        if (this.hightlightedItem != null) {\r\n            // altes Item zur�cksetzen\r\n            this.hightlightedItem.setHighlight(false);\r\n        }\r\n        this.hightlightedItem = item;\r\n        if (item != null) {\r\n            hightlightedItem.setHighlight(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public HighlightableItem getHightligtedItem() {\r\n        return hightlightedItem;\r\n    }\r\n\r\n    public Player getNearestPlayer(int x, int y) {\r\n        List<Player> all = new ArrayList<Player>(offenders);\r\n        all.addAll(defenders);\r\n        return findNearestPlayer(x, y, all);\r\n    }\r\n\r\n    public Offender getNearestOffender(int x, int y) {\r\n        List<Player> all = new ArrayList<Player>(offenders);\r\n        return (Offender) findNearestPlayer(x, y, all);\r\n    }\r\n\r\n    private Player findNearestPlayer(int x, int y, List<Player> players) {\r\n        double entfernung = Double.MAX_VALUE;\r\n        Player temp = null;\r\n        for (Player player : players) {\r\n            int player_x = player.getCurrent_x();\r\n            int player_y = player.getCurrent_y();\r\n            double tempEntfernung = Point2D.distance(x, y, player_x, player_y);\r\n            // Wenn naeher als der MARK_RADIUS\r\n            if (!(tempEntfernung > MARK_RADIUS)) {\r\n                if (tempEntfernung < entfernung) {\r\n                    temp = player;\r\n                    entfernung = tempEntfernung;\r\n                }\r\n            }\r\n        }\r\n        return temp;\r\n    }\r\n\r\n    public MovePoint getNearestMovePoint(int x, int y) {\r\n        MovePoint point = null;\r\n        if (actualEvent != null) {\r\n            double entfernung = Double.MAX_VALUE;\r\n            if (actualEvent.isDestinationPointSet()) {\r\n                int destination_x = actualEvent.getDestinationX();\r\n                int destination_y = actualEvent.getDestinationY();\r\n                double tempEntfernung = Point2D.distance(x, y, destination_x, destination_y);\r\n                // Wenn naeher als der MARK_RADIUS\r\n                if (!(tempEntfernung > MARK_RADIUS)) {\r\n                    if (tempEntfernung < entfernung) {\r\n                        point = actualEvent.getDestinationPoint();\r\n                        entfernung = tempEntfernung;\r\n                    }\r\n                }\r\n            }\r\n            if (actualEvent.isControlPointSet()) {\r\n                int controlPoint_x = actualEvent.getControlPointX();\r\n                int controlPoint_y = actualEvent.getControlPointY();\r\n                double tempEntfernung = Point2D.distance(x, y, controlPoint_x, controlPoint_y);\r\n                // Wenn naeher als der MARK_RADIUS\r\n                if (!(tempEntfernung > MARK_RADIUS)) {\r\n                    if (tempEntfernung < entfernung) {\r\n                        point = actualEvent.getControlPoint();\r\n                        entfernung = tempEntfernung;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return point;\r\n    }\r\n\r\n    public HighlightableItem getNearestHighlightableItem(int x, int y) {\r\n        HighlightableItem temp = null;\r\n        temp = getNearestMovePoint(x, y);\r\n        if (temp == null) {\r\n            temp = getNearestPlayer(x, y);\r\n        }\r\n        return temp;\r\n    }\r\n\r\n    public void movePlayerTo(Player actualPlayer, int x, int y) {\r\n        if (getAcutalSequenceNr() == 0) {\r\n            actualPlayer.setStart_x(x);\r\n            actualPlayer.setStart_y(y);\r\n        }\r\n        // Ansonsten muss die Position im entsprechenden Ereignis gesetzt\r\n        // werden\r\n        // Startposition darf nur im Angreifer/Verteidiger-Modus ge�ndert werden\r\n        fireModelChanged();\r\n    }\r\n\r\n    public boolean isSaved() {\r\n        boolean changed = false;\r\n        if (lastSavedModel != null) {\r\n            //Spielzugnamen vergleichen\r\n            if (lastSavedModel.getMoveName() != null) {\r\n                if (getMoveName() == null || !lastSavedModel.getMoveName().equals(getMoveName())) {\r\n                    return false;\r\n                }\r\n            } else if (getMoveName() != null) {\r\n                //alt: kein Name <-> neu: Name vorhanden\r\n                return false;\r\n            }\r\n            //Ueberprüfen ob Angreifer und Verteidiger unterschiedlich\r\n            // zuerst Spielerlisten vergleichen\r\n            if (changedPlayerList(getOffenders().toArray(new Player[getOffenders().size()]), lastSavedModel.getOffenders().toArray(new Player[lastSavedModel.getOffenders().size()])) || changedPlayerList(getDefenders().toArray(new Player[getDefenders().size()]), lastSavedModel.getDefenders().toArray(new Player[lastSavedModel.getDefenders().size()]))) {\r\n                changed = true;\r\n            } else {\r\n                List<MoveEvent> newEvents = getEvents();\r\n                List<MoveEvent> oldEvents = lastSavedModel.getEvents();\r\n                if (newEvents.size() == oldEvents.size()) {\r\n                    for (int i = 0; i < newEvents.size(); i++) {\r\n                        if (!newEvents.get(i).equals(oldEvents.get(i))) {\r\n                            changed = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                } else {\r\n                    changed = true;\r\n                }\r\n            }\r\n            if (!changed && (getFirstBallOwner() != null || lastSavedModel.getFirstBallOwner() != null)) {\r\n                changed = (getFirstBallOwner() == null) ^ (lastSavedModel.getFirstBallOwner() == null);\r\n                if (!changed) {\r\n                    changed = !getFirstBallOwner().equals(lastSavedModel.getFirstBallOwner());\r\n                }\r\n            }\r\n            // wurde Kommentar geändert?\r\n            if (!changed) {\r\n                if (comment == null || comment.equals(\"\")) {\r\n                    if (lastSavedModel.getComment() != null && !lastSavedModel.getComment().equals(\"\")) {\r\n                        changed = true;\r\n                    }\r\n                } else if (lastSavedModel.getComment() != null) {\r\n                    if (!lastSavedModel.getComment().equals(comment)) {\r\n                        changed = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return !changed;\r\n    }\r\n\r\n    private boolean changedPlayerList(Player[] newList, Player[] oldList) {\r\n        boolean changed = false;\r\n        int size = newList.length;\r\n        int sizeOld = oldList.length;\r\n        if (size == sizeOld) {\r\n            for (int i = 0; i < size; i++) {\r\n                if (!newList[i].equals(oldList[i])) {\r\n                    changed = true;\r\n                    break;\r\n                }\r\n            }\r\n        } else {\r\n            changed = true;\r\n        }\r\n        return changed;\r\n    }\r\n\r\n    public void initWithLoadedModel(HandballModel loadedModel) {\r\n        initModel();\r\n        offenders = loadedModel.getOffenders();\r\n        defenders = loadedModel.getDefenders();\r\n        events = loadedModel.getSortedEvents();\r\n        Offender.setCounter(determineMaxPlayerNumber(offenders));\r\n        Defender.setCounter(determineMaxPlayerNumber(defenders));\r\n        setFirstBallOwner(loadedModel.getFirstBallOwner());\r\n        setState(loadedModel.getState());\r\n        setActualMoveEvent(loadedModel.getActualMoveEvent());\r\n        setComment(loadedModel.getComment());\r\n        // zur Sicherheit\r\n        if (getComment() == null) {\r\n            setComment(\"\");\r\n        }\r\n        setMoveName(loadedModel.getMoveName());\r\n        markAsSaved(loadedModel);\r\n        fireModelChanged();\r\n    }\r\n\r\n    private int determineMaxPlayerNumber(List players) {\r\n        int max = 0;\r\n        for (Object o : players) {\r\n            if (o instanceof Player) {\r\n                Player player = (Player) o;\r\n                if (player.getPlayerNumber() > max) {\r\n                    max = player.getPlayerNumber();\r\n                }\r\n            }\r\n        }\r\n        return max;\r\n    }\r\n\r\n    public void markAsSaved(HandballModel model) {\r\n        try {\r\n            lastSavedModel = (HandballModel) Main.deepCopy(model);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            lastSavedModel = null;\r\n        }\r\n    }\r\n\r\n    public void setDelay(int eventIndex, int delay) {\r\n        getEvents().get(eventIndex).setDelay(delay);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setBallOwner(Offender ballOwner) {\r\n        if (this.ballOwner != null) {\r\n            this.ballOwner.setHasBall(false);\r\n        }\r\n        this.ballOwner = ballOwner;\r\n        if (ballOwner != null) {\r\n            ballOwner.setHasBall(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setBallOwnerSilent(Offender ballOwner) {\r\n        if (this.ballOwner != null) {\r\n            this.ballOwner.setHasBall(false);\r\n        }\r\n        this.ballOwner = ballOwner;\r\n        if (ballOwner != null) {\r\n            ballOwner.setHasBall(true);\r\n        }\r\n        // fireModelChanged();\r\n    }\r\n\r\n    public void startAnimation(boolean onlyActualSequence) {\r\n        setState(State.ANIMATION_RUNNING);\r\n        MoveEvent event = actualEvent;\r\n        if (event == null) {\r\n            event = getEvents().get(0);\r\n        }\r\n        setActualMoveEvent(event);\r\n        animationSequenz = event.getSequenceNr();\r\n        animationModel = new AnimationModel(event, this, onlyActualSequence);\r\n        runningAnimator = new Animator(this);\r\n        computePlayerPositions(animationSequenz);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void pauseAnimation(boolean pause) {\r\n        if (pause) {\r\n            runningAnimator.setPause(true);\r\n        } else {\r\n            runningAnimator.setPause(false);\r\n        }\r\n    }\r\n\r\n    public void initAnimation() {\r\n    }\r\n\r\n    public boolean nextAnimationStep() {\r\n        boolean finished = animationModel.nextStep();\r\n        if (finished) {\r\n            if (animationModel.isOnlyOneSequence()) {\r\n                setState(State.ANIMATION);\r\n                // n�chste Sequzenz ausw�hlen (einfaches sequentielles Anschauen des Spielzugs)\r\n                int nextSeq = (getAcutalSequenceNr() == getHighestSequenceNumber()) ? getAcutalSequenceNr() : getAcutalSequenceNr() + 1;\r\n                List<MoveEvent> nextSeqEvents = getMoveEvents(nextSeq);\r\n                if (nextSeqEvents.get(0) != null) {\r\n                    setActualMoveEvent(nextSeqEvents.get(0));\r\n                }\r\n            } else {\r\n                setState(State.FULL_ANIMATION_ENDED);\r\n            }\r\n        } else {\r\n            fireModelChanged();\r\n        }\r\n        return finished;\r\n    }\r\n\r\n    public void stopAnimation() {\r\n        setState(State.ANIMATION);\r\n        runningAnimator = null;\r\n        setActualMoveEvent(getActualMoveEvent());\r\n    }\r\n\r\n    public boolean isMarkedPlayerAddable() {\r\n        int seq = getAcutalSequenceNr();\r\n        return !events.contains(new MoveEvent(markedPlayer, seq));\r\n    }\r\n\r\n    public boolean passEventDefined(int seq) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() == seq && event instanceof PassEvent) {\r\n                defined = true;\r\n                break;\r\n            }\r\n            if (event.getSequenceNr() > seq) {\r\n                break;\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public boolean passEventDefined() {\r\n        return passEventDefined(getAcutalSequenceNr());\r\n    }\r\n\r\n    public boolean passEventDefinedAfter(int seq) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if ((event instanceof PassEvent) && (event.getSequenceNr() > seq)) {\r\n                defined = true;\r\n                break;\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public boolean eventDefinedAfter(int seq) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() > seq) {\r\n                defined = true;\r\n                break;\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public Ball getBall() {\r\n        return ball;\r\n    }\r\n\r\n    public void setFirstBallOwner(Offender offender) {\r\n        this.firstBallOwner = offender;\r\n        setBallOwner(offender);\r\n        if (firstBallOwner == null) {\r\n            resetBallPosition();\r\n        }\r\n    }\r\n\r\n    public Offender getFirstBallOwner() {\r\n        return firstBallOwner;\r\n    }\r\n\r\n    public boolean hasPlayerBallInNextSequence(Player player) {\r\n        PassEvent pass = null;\r\n        int seq = getAcutalSequenceNr();\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() == seq && event instanceof PassEvent) {\r\n                pass = (PassEvent) event;\r\n                break;\r\n            }\r\n            if (event.getSequenceNr() > seq) {\r\n                break;\r\n            }\r\n        }\r\n        if (pass != null && pass.getDestinationPlayer() != null) {\r\n            return pass.getDestinationPlayer().equals(player) && !passEventDefined(seq + 1);\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public boolean isBallSet() {\r\n        return ballOwner != null;\r\n    }\r\n\r\n    public boolean isGoalPassSet() {\r\n        boolean defined = false;\r\n        for (MoveEvent event : getEvents()) {\r\n            if (event instanceof PassEvent) {\r\n                PassEvent pass = (PassEvent) event;\r\n                if (pass.isGoalPass()) {\r\n                    defined = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public void moveBallTo(int x, int y) {\r\n        ball.setCurrent_x(x);\r\n        ball.setCurrent_y(y);\r\n    }\r\n\r\n    public List<MoveEvent> getActualMoveEvents() {\r\n        return getMoveEvents(getAcutalSequenceNr());\r\n    }\r\n\r\n    public List<MoveEvent> getMoveEvents(int sequenceNr) {\r\n        List<MoveEvent> sequenceEvents = new ArrayList<MoveEvent>();\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() == sequenceNr) {\r\n                sequenceEvents.add(event);\r\n            } else if (event.getSequenceNr() > getAcutalSequenceNr()) {\r\n                break;\r\n            }\r\n        }\r\n        return sequenceEvents;\r\n    }\r\n\r\n    /**\r\n     * Löscht das Aktuelle Ereignis und ALLE Folgenden\r\n     */\r\n    public void removeEventsAfter() {\r\n        MoveEvent event = getActualMoveEvent();\r\n        List<MoveEvent> toDeleteEvents = new ArrayList<MoveEvent>();\r\n        int sequenceNr = event.getSequenceNr();\r\n        // zu loeschende Events sammeln\r\n        for (MoveEvent evt : getEvents()) {\r\n            if (evt.getSequenceNr() > sequenceNr) {\r\n                // Event ist hoeher, also loeschen\r\n                toDeleteEvents.add(evt);\r\n            }\r\n        }\r\n        toDeleteEvents.add(event);\r\n        // gesammelte Events loeschen\r\n        for (MoveEvent deleteEvent : toDeleteEvents) {\r\n            removeMoveEvent(deleteEvent);\r\n        }\r\n        setActualMoveEvent((getEvents().size() > 0) ? getEvents().get(getEvents().size() - 1) : null);\r\n        fireModelChanged();\r\n    }\r\n\r\n    /**\r\n     * Löscht die Ereignisse (auch P�sse) des �bergebenen Spielers. Und die\r\n     * evtl. davon abh�ngigen Folgep�sse\r\n     *\r\n     * @param player\r\n     */\r\n    private void removeEventsOfPlayer(Player player) {\r\n        List<MoveEvent> toDeleteEvents = new ArrayList<MoveEvent>();\r\n        boolean playerInvolved = false;\r\n        // zu loeschende Events sammeln\r\n        for (MoveEvent evt : getEvents()) {\r\n            // Pass?\r\n            if (evt instanceof PassEvent) {\r\n                PassEvent pass = (PassEvent) evt;\r\n                // War ein Pass zu dem Spieler? oder Spieler passt selbst?\r\n                if (pass.getDestinationPlayer().equals(player) || pass.getPlayer().equals(player)) {\r\n                    playerInvolved = true;\r\n                }\r\n                // War Spieler an einem Pass beteiligt?\r\n                if (playerInvolved) {\r\n                    toDeleteEvents.add(pass);\r\n                    continue;\r\n                }\r\n            }\r\n            if (evt.getPlayer().equals(player)) {\r\n                toDeleteEvents.add(evt);\r\n            }\r\n        }\r\n        // gesammelte Events loeschen\r\n        for (MoveEvent deleteEvent : toDeleteEvents) {\r\n            removeMoveEvent(deleteEvent);\r\n        }\r\n        setActualMoveEvent((getEvents().size() > 0) ? getEvents().get(getEvents().size() - 1) : null);\r\n    }\r\n\r\n    public boolean eventDefinedWithPlayer(Player player) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if (event.getPlayer().equals(player)) {\r\n                defined = true;\r\n                break;\r\n            }\r\n            if (event instanceof PassEvent) {\r\n                PassEvent pass = (PassEvent) event;\r\n                if (pass.getDestinationPlayer().equals(player)) {\r\n                    defined = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public int getHighestSequenceNumber() {\r\n        if (events.size() == 0) {\r\n            return 0;\r\n        } else {\r\n            return events.last().getSequenceNr();\r\n        }\r\n    }\r\n\r\n    public String getMoveName() {\r\n        return moveName;\r\n    }\r\n\r\n    public void setMoveName(String moveName) {\r\n        this.moveName = moveName;\r\n        if (Main.getWindow() != null) {\r\n            StringBuffer buffer = new StringBuffer(APP_NAME);\r\n            buffer.append(\" - \");\r\n            if (moveName == null || moveName.equals(\"\")) {\r\n                buffer.append(\"Unbenannt\");\r\n                // Titelleiste aktualisieren\r\n            } else {\r\n                buffer.append(moveName);\r\n            }\r\n            if (!isSaved()) {\r\n                buffer.append(\"*\");\r\n            }\r\n            Main.getWindow().setTitle(buffer.toString());\r\n        }\r\n    }\r\n\r\n    public String getComment() {\r\n        if (comment == null) {\r\n            comment = \"\";\r\n        }\r\n        return comment;\r\n    }\r\n\r\n    public void setComment(String comment) {\r\n        this.comment = comment;\r\n        fireModelChanged();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/model/HandballModelTest12.java",
		"test_prompt": "// HandballModelTest12.java\npackage visu.handball.moves.model;\n\nimport java.awt.geom.Point2D;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\nimport javax.swing.JOptionPane;\nimport visu.handball.moves.Main;\nimport visu.handball.moves.model.animation.AnimationModel;\nimport visu.handball.moves.model.animation.Animator;\nimport visu.handball.moves.model.player.Ball;\nimport visu.handball.moves.model.player.Defender;\nimport visu.handball.moves.model.player.HighlightableItem;\nimport visu.handball.moves.model.player.MovePoint;\nimport visu.handball.moves.model.player.Offender;\nimport visu.handball.moves.model.player.Player;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HandballModel}.\n* It contains ten unit test cases for the {@link HandballModel#isBallSet()} method.\n*/\nclass HandballModelTest12 {"
	},
	{
		"original_code": "// HandballModel.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.model;\r\n\r\nimport java.awt.geom.Point2D;\r\nimport java.io.Serializable;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.SortedSet;\r\nimport java.util.TreeSet;\r\nimport javax.swing.JOptionPane;\r\nimport visu.handball.moves.Main;\r\nimport visu.handball.moves.model.animation.AnimationModel;\r\nimport visu.handball.moves.model.animation.Animator;\r\nimport visu.handball.moves.model.player.Ball;\r\nimport visu.handball.moves.model.player.Defender;\r\nimport visu.handball.moves.model.player.HighlightableItem;\r\nimport visu.handball.moves.model.player.MovePoint;\r\nimport visu.handball.moves.model.player.Offender;\r\nimport visu.handball.moves.model.player.Player;\r\n\r\npublic class HandballModel implements Serializable {\r\n\r\n    private static final long serialVersionUID = -5372891552466311536L;\r\n\r\n    public enum State {\r\n\r\n        INITIAL,\r\n        PLACE_OFFENDERS,\r\n        PLACE_DEFENDERS,\r\n        PLACE_BALL,\r\n        EDIT,\r\n        EDIT_EVENT,\r\n        ANIMATION,\r\n        ANIMATION_RUNNING,\r\n        FULL_ANIMATION_ENDED\r\n    }\r\n\r\n    private static final int MAX_OFFENDERS = 6;\r\n\r\n    private static final int MAX_DEFENDERS = 6;\r\n\r\n    private static final int MARK_RADIUS = 12;\r\n\r\n    private static final String APP_NAME = \"jHandballMoves\";\r\n\r\n    private transient List<HandballModelListener> listeners;\r\n\r\n    private transient List<PlayerRemovedListener> playerRemoveListener;\r\n\r\n    private List<Defender> defenders;\r\n\r\n    private List<Offender> offenders;\r\n\r\n    private SortedSet<MoveEvent> events;\r\n\r\n    private State state;\r\n\r\n    private MoveEvent actualEvent;\r\n\r\n    private Player markedPlayer;\r\n\r\n    private HighlightableItem hightlightedItem;\r\n\r\n    private Offender ballOwner;\r\n\r\n    private Ball ball;\r\n\r\n    private Offender firstBallOwner;\r\n\r\n    private transient Animator runningAnimator;\r\n\r\n    private int animationSequenz;\r\n\r\n    private transient AnimationModel animationModel;\r\n\r\n    private transient HandballModel lastSavedModel;\r\n\r\n    private String comment;\r\n\r\n    private String moveName;\r\n\r\n    public HandballModel() {\r\n        listeners = new ArrayList<HandballModelListener>();\r\n        playerRemoveListener = new ArrayList<PlayerRemovedListener>();\r\n        initModel();\r\n    }\r\n\r\n    public void initModel() {\r\n        defenders = new ArrayList<Defender>();\r\n        Defender.setCounter(0);\r\n        offenders = new ArrayList<Offender>();\r\n        Offender.setCounter(0);\r\n        events = new TreeSet<MoveEvent>();\r\n        // Workaround wegen ToolBar\r\n        state = State.PLACE_OFFENDERS;\r\n        actualEvent = null;\r\n        markedPlayer = null;\r\n        firstBallOwner = null;\r\n        comment = \"\";\r\n        moveName = \"\";\r\n        resetBallPosition();\r\n        try {\r\n            lastSavedModel = (HandballModel) Main.deepCopy(this);\r\n        } catch (Exception e) {\r\n            lastSavedModel = null;\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    private void resetBallPosition() {\r\n        ball = new Ball(-500, -500);\r\n    }\r\n\r\n    public void addOffender(int x, int y) {\r\n        if (offenders.size() == MAX_OFFENDERS) {\r\n            JOptionPane.showMessageDialog(Main.getWindow(), \"Sie haben schon \" + MAX_OFFENDERS + \" Angreifer angelegt.\", \"Info:\", JOptionPane.INFORMATION_MESSAGE);\r\n        } else {\r\n            offenders.add(new Offender(x, y));\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void removePlayer(Player toRemove) {\r\n        if (eventDefinedWithPlayer(toRemove)) {\r\n            removeEventsOfPlayer(toRemove);\r\n        }\r\n        if (toRemove instanceof Offender) {\r\n            removeOffender((Offender) toRemove);\r\n        } else {\r\n            removeDefender((Defender) toRemove);\r\n        }\r\n    }\r\n\r\n    private void removeOffender(Offender toRemove) {\r\n        if (getFirstBallOwner() != null && getFirstBallOwner().equals(toRemove)) {\r\n            setFirstBallOwner(null);\r\n        }\r\n        offenders.remove(toRemove);\r\n        if ((getDefenders().size() + getOffenders().size()) == 0) {\r\n            markedPlayer = null;\r\n        }\r\n        // Spielernummer aktualisieren\r\n        Offender.setCounter(determineMaxPlayerNumber(offenders));\r\n        fireOffenderRemoved(toRemove);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void addDefender(int x, int y) {\r\n        if (defenders.size() == MAX_DEFENDERS) {\r\n            JOptionPane.showMessageDialog(Main.getWindow(), \"Sie haben schon \" + MAX_OFFENDERS + \" Verteidiger angelegt.\", \"Info:\", JOptionPane.INFORMATION_MESSAGE);\r\n        } else {\r\n            defenders.add(new Defender(x, y));\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    private void removeDefender(Defender toRemove) {\r\n        defenders.remove(toRemove);\r\n        if ((getDefenders().size() + getOffenders().size()) == 0) {\r\n            markedPlayer = null;\r\n        }\r\n        Defender.setCounter(determineMaxPlayerNumber(defenders));\r\n        fireDefenderRemoved(toRemove);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public boolean addListener(HandballModelListener o) {\r\n        return listeners.add(o);\r\n    }\r\n\r\n    public boolean removeListener(HandballModelListener o) {\r\n        return listeners.remove(o);\r\n    }\r\n\r\n    public boolean addPlayerRemovedListener(PlayerRemovedListener o) {\r\n        return playerRemoveListener.add(o);\r\n    }\r\n\r\n    public boolean removePlayerRemovedListener(PlayerRemovedListener o) {\r\n        return playerRemoveListener.remove(o);\r\n    }\r\n\r\n    private void fireModelChanged() {\r\n        setMoveName(getMoveName());\r\n        for (HandballModelListener listener : listeners) {\r\n            listener.modelChanged();\r\n        }\r\n    }\r\n\r\n    private void fireOffenderRemoved(Offender offender) {\r\n        for (PlayerRemovedListener listener : playerRemoveListener) {\r\n            listener.offenderRemoved(offender);\r\n        }\r\n    }\r\n\r\n    private void fireDefenderRemoved(Defender defender) {\r\n        for (PlayerRemovedListener listener : playerRemoveListener) {\r\n            listener.defenderRemoved(defender);\r\n        }\r\n    }\r\n\r\n    public List<Defender> getDefenders() {\r\n        return defenders;\r\n    }\r\n\r\n    public List<Offender> getOffenders() {\r\n        return offenders;\r\n    }\r\n\r\n    public State getState() {\r\n        return state;\r\n    }\r\n\r\n    public void setState(State state) {\r\n        if (state == State.EDIT) {\r\n            if (getActualMoveEvent() == null) {\r\n                // Wenn leer, dann Null, sonst letztes Move Event setzen\r\n                setActualMoveEvent(getEvents().isEmpty() ? null : (getEvents().get(getEvents().size() - 1)));\r\n            } else {\r\n                setActualMoveEvent(getActualMoveEvent());\r\n            }\r\n        }\r\n        if (state == State.PLACE_DEFENDERS || state == State.PLACE_OFFENDERS) {\r\n            if (getFirstBallOwner() != null) {\r\n                setBallOwner(getFirstBallOwner());\r\n            }\r\n            setActualMoveEvent(null);\r\n        }\r\n        this.state = state;\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void addMoveEvent(MoveEvent event) {\r\n        events.add(event);\r\n        if (state == State.EDIT) {\r\n            setActualMoveEvent(event);\r\n            state = State.EDIT_EVENT;\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void removeMoveEvent(MoveEvent event) {\r\n        events.remove(event);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public List<MoveEvent> getEvents() {\r\n        List<MoveEvent> list = new ArrayList<MoveEvent>(events);\r\n        return list;\r\n    }\r\n\r\n    public SortedSet<MoveEvent> getSortedEvents() {\r\n        return events;\r\n    }\r\n\r\n    public int getAcutalSequenceNr() {\r\n        if (actualEvent == null)\r\n            return 0;\r\n        else {\r\n            return actualEvent.getSequenceNr();\r\n        }\r\n    }\r\n\r\n    public void setActualMoveEvent(MoveEvent event) {\r\n        if (this.actualEvent != null) {\r\n            this.actualEvent.setMarked(false);\r\n        }\r\n        this.actualEvent = event;\r\n        computePlayerPositions();\r\n        // aktuellen Spieler setzen\r\n        setMarkedPlayer((event == null) ? null : event.getPlayer());\r\n        if (actualEvent != null) {\r\n            if (!actualEvent.isDestinationPointSet()) {\r\n                state = State.EDIT_EVENT;\r\n            } else {\r\n                if (state == State.FULL_ANIMATION_ENDED) {\r\n                    state = State.ANIMATION;\r\n                } else if (state != State.ANIMATION && state != State.ANIMATION_RUNNING) {\r\n                    state = State.EDIT;\r\n                }\r\n            }\r\n            actualEvent.setMarked(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setDestinationPointForEvent(MoveEvent event, int x, int y, boolean temp) {\r\n        event.setDestinationPoint(x, y, temp);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setControlPointForEvent(MoveEvent event, int x, int y, boolean temp) {\r\n        event.setControlPoint(x, y, temp);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setMovePointTo(MovePoint point, int x, int y) {\r\n        actualEvent.setPoint(point, x, y);\r\n        fireModelChanged();\r\n    }\r\n\r\n    private void computePlayerPositions() {\r\n        computePlayerPositions(getAcutalSequenceNr());\r\n    }\r\n\r\n    public void computePlayerPositions(int seqNr) {\r\n        // Spieler Positionen auf Ausgangsstellung\r\n        for (Player offender : offenders) {\r\n            offender.resetPosition();\r\n        }\r\n        for (Player defender : defenders) {\r\n            defender.resetPosition();\r\n        }\r\n        if (seqNr == 1) {\r\n            setBallOwner(firstBallOwner);\r\n        }\r\n        // alle Events mit kleinerer Sequenznummer verarbeiten\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() < seqNr) {\r\n                if (event instanceof PassEvent) {\r\n                    // Ball an anderen Spieler �bertragen\r\n                    setBallOwner(((PassEvent) event).getDestinationPlayer());\r\n                } else {\r\n                    if (event.getDestinationX() > -1 && event.getDestinationY() > -1) {\r\n                        event.getPlayer().setCurrentPosition(event.getDestinationX(), event.getDestinationY());\r\n                    }\r\n                }\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    public MoveEvent getActualMoveEvent() {\r\n        return actualEvent;\r\n    }\r\n\r\n    public Player getMarkedPlayer() {\r\n        return markedPlayer;\r\n    }\r\n\r\n    public void setMarkedPlayer(Player markedPlayer) {\r\n        // alten markierten Spieler demarkieren\r\n        if (this.markedPlayer != null) {\r\n            this.markedPlayer.setMarked(false);\r\n        }\r\n        // evtl. neuen Spieler markieren\r\n        this.markedPlayer = markedPlayer;\r\n        if (markedPlayer != null) {\r\n            markedPlayer.setMarked(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setHighLightedItem(HighlightableItem item) {\r\n        if (this.hightlightedItem != null) {\r\n            // altes Item zur�cksetzen\r\n            this.hightlightedItem.setHighlight(false);\r\n        }\r\n        this.hightlightedItem = item;\r\n        if (item != null) {\r\n            hightlightedItem.setHighlight(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public HighlightableItem getHightligtedItem() {\r\n        return hightlightedItem;\r\n    }\r\n\r\n    public Player getNearestPlayer(int x, int y) {\r\n        List<Player> all = new ArrayList<Player>(offenders);\r\n        all.addAll(defenders);\r\n        return findNearestPlayer(x, y, all);\r\n    }\r\n\r\n    public Offender getNearestOffender(int x, int y) {\r\n        List<Player> all = new ArrayList<Player>(offenders);\r\n        return (Offender) findNearestPlayer(x, y, all);\r\n    }\r\n\r\n    private Player findNearestPlayer(int x, int y, List<Player> players) {\r\n        double entfernung = Double.MAX_VALUE;\r\n        Player temp = null;\r\n        for (Player player : players) {\r\n            int player_x = player.getCurrent_x();\r\n            int player_y = player.getCurrent_y();\r\n            double tempEntfernung = Point2D.distance(x, y, player_x, player_y);\r\n            // Wenn naeher als der MARK_RADIUS\r\n            if (!(tempEntfernung > MARK_RADIUS)) {\r\n                if (tempEntfernung < entfernung) {\r\n                    temp = player;\r\n                    entfernung = tempEntfernung;\r\n                }\r\n            }\r\n        }\r\n        return temp;\r\n    }\r\n\r\n    public MovePoint getNearestMovePoint(int x, int y) {\r\n        MovePoint point = null;\r\n        if (actualEvent != null) {\r\n            double entfernung = Double.MAX_VALUE;\r\n            if (actualEvent.isDestinationPointSet()) {\r\n                int destination_x = actualEvent.getDestinationX();\r\n                int destination_y = actualEvent.getDestinationY();\r\n                double tempEntfernung = Point2D.distance(x, y, destination_x, destination_y);\r\n                // Wenn naeher als der MARK_RADIUS\r\n                if (!(tempEntfernung > MARK_RADIUS)) {\r\n                    if (tempEntfernung < entfernung) {\r\n                        point = actualEvent.getDestinationPoint();\r\n                        entfernung = tempEntfernung;\r\n                    }\r\n                }\r\n            }\r\n            if (actualEvent.isControlPointSet()) {\r\n                int controlPoint_x = actualEvent.getControlPointX();\r\n                int controlPoint_y = actualEvent.getControlPointY();\r\n                double tempEntfernung = Point2D.distance(x, y, controlPoint_x, controlPoint_y);\r\n                // Wenn naeher als der MARK_RADIUS\r\n                if (!(tempEntfernung > MARK_RADIUS)) {\r\n                    if (tempEntfernung < entfernung) {\r\n                        point = actualEvent.getControlPoint();\r\n                        entfernung = tempEntfernung;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return point;\r\n    }\r\n\r\n    public HighlightableItem getNearestHighlightableItem(int x, int y) {\r\n        HighlightableItem temp = null;\r\n        temp = getNearestMovePoint(x, y);\r\n        if (temp == null) {\r\n            temp = getNearestPlayer(x, y);\r\n        }\r\n        return temp;\r\n    }\r\n\r\n    public void movePlayerTo(Player actualPlayer, int x, int y) {\r\n        if (getAcutalSequenceNr() == 0) {\r\n            actualPlayer.setStart_x(x);\r\n            actualPlayer.setStart_y(y);\r\n        }\r\n        // Ansonsten muss die Position im entsprechenden Ereignis gesetzt\r\n        // werden\r\n        // Startposition darf nur im Angreifer/Verteidiger-Modus ge�ndert werden\r\n        fireModelChanged();\r\n    }\r\n\r\n    public boolean isSaved() {\r\n        boolean changed = false;\r\n        if (lastSavedModel != null) {\r\n            //Spielzugnamen vergleichen\r\n            if (lastSavedModel.getMoveName() != null) {\r\n                if (getMoveName() == null || !lastSavedModel.getMoveName().equals(getMoveName())) {\r\n                    return false;\r\n                }\r\n            } else if (getMoveName() != null) {\r\n                //alt: kein Name <-> neu: Name vorhanden\r\n                return false;\r\n            }\r\n            //Ueberprüfen ob Angreifer und Verteidiger unterschiedlich\r\n            // zuerst Spielerlisten vergleichen\r\n            if (changedPlayerList(getOffenders().toArray(new Player[getOffenders().size()]), lastSavedModel.getOffenders().toArray(new Player[lastSavedModel.getOffenders().size()])) || changedPlayerList(getDefenders().toArray(new Player[getDefenders().size()]), lastSavedModel.getDefenders().toArray(new Player[lastSavedModel.getDefenders().size()]))) {\r\n                changed = true;\r\n            } else {\r\n                List<MoveEvent> newEvents = getEvents();\r\n                List<MoveEvent> oldEvents = lastSavedModel.getEvents();\r\n                if (newEvents.size() == oldEvents.size()) {\r\n                    for (int i = 0; i < newEvents.size(); i++) {\r\n                        if (!newEvents.get(i).equals(oldEvents.get(i))) {\r\n                            changed = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                } else {\r\n                    changed = true;\r\n                }\r\n            }\r\n            if (!changed && (getFirstBallOwner() != null || lastSavedModel.getFirstBallOwner() != null)) {\r\n                changed = (getFirstBallOwner() == null) ^ (lastSavedModel.getFirstBallOwner() == null);\r\n                if (!changed) {\r\n                    changed = !getFirstBallOwner().equals(lastSavedModel.getFirstBallOwner());\r\n                }\r\n            }\r\n            // wurde Kommentar geändert?\r\n            if (!changed) {\r\n                if (comment == null || comment.equals(\"\")) {\r\n                    if (lastSavedModel.getComment() != null && !lastSavedModel.getComment().equals(\"\")) {\r\n                        changed = true;\r\n                    }\r\n                } else if (lastSavedModel.getComment() != null) {\r\n                    if (!lastSavedModel.getComment().equals(comment)) {\r\n                        changed = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return !changed;\r\n    }\r\n\r\n    private boolean changedPlayerList(Player[] newList, Player[] oldList) {\r\n        boolean changed = false;\r\n        int size = newList.length;\r\n        int sizeOld = oldList.length;\r\n        if (size == sizeOld) {\r\n            for (int i = 0; i < size; i++) {\r\n                if (!newList[i].equals(oldList[i])) {\r\n                    changed = true;\r\n                    break;\r\n                }\r\n            }\r\n        } else {\r\n            changed = true;\r\n        }\r\n        return changed;\r\n    }\r\n\r\n    public void initWithLoadedModel(HandballModel loadedModel) {\r\n        initModel();\r\n        offenders = loadedModel.getOffenders();\r\n        defenders = loadedModel.getDefenders();\r\n        events = loadedModel.getSortedEvents();\r\n        Offender.setCounter(determineMaxPlayerNumber(offenders));\r\n        Defender.setCounter(determineMaxPlayerNumber(defenders));\r\n        setFirstBallOwner(loadedModel.getFirstBallOwner());\r\n        setState(loadedModel.getState());\r\n        setActualMoveEvent(loadedModel.getActualMoveEvent());\r\n        setComment(loadedModel.getComment());\r\n        // zur Sicherheit\r\n        if (getComment() == null) {\r\n            setComment(\"\");\r\n        }\r\n        setMoveName(loadedModel.getMoveName());\r\n        markAsSaved(loadedModel);\r\n        fireModelChanged();\r\n    }\r\n\r\n    private int determineMaxPlayerNumber(List players) {\r\n        int max = 0;\r\n        for (Object o : players) {\r\n            if (o instanceof Player) {\r\n                Player player = (Player) o;\r\n                if (player.getPlayerNumber() > max) {\r\n                    max = player.getPlayerNumber();\r\n                }\r\n            }\r\n        }\r\n        return max;\r\n    }\r\n\r\n    public void markAsSaved(HandballModel model) {\r\n        try {\r\n            lastSavedModel = (HandballModel) Main.deepCopy(model);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            lastSavedModel = null;\r\n        }\r\n    }\r\n\r\n    public void setDelay(int eventIndex, int delay) {\r\n        getEvents().get(eventIndex).setDelay(delay);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setBallOwner(Offender ballOwner) {\r\n        if (this.ballOwner != null) {\r\n            this.ballOwner.setHasBall(false);\r\n        }\r\n        this.ballOwner = ballOwner;\r\n        if (ballOwner != null) {\r\n            ballOwner.setHasBall(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setBallOwnerSilent(Offender ballOwner) {\r\n        if (this.ballOwner != null) {\r\n            this.ballOwner.setHasBall(false);\r\n        }\r\n        this.ballOwner = ballOwner;\r\n        if (ballOwner != null) {\r\n            ballOwner.setHasBall(true);\r\n        }\r\n        // fireModelChanged();\r\n    }\r\n\r\n    public void startAnimation(boolean onlyActualSequence) {\r\n        setState(State.ANIMATION_RUNNING);\r\n        MoveEvent event = actualEvent;\r\n        if (event == null) {\r\n            event = getEvents().get(0);\r\n        }\r\n        setActualMoveEvent(event);\r\n        animationSequenz = event.getSequenceNr();\r\n        animationModel = new AnimationModel(event, this, onlyActualSequence);\r\n        runningAnimator = new Animator(this);\r\n        computePlayerPositions(animationSequenz);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void pauseAnimation(boolean pause) {\r\n        if (pause) {\r\n            runningAnimator.setPause(true);\r\n        } else {\r\n            runningAnimator.setPause(false);\r\n        }\r\n    }\r\n\r\n    public void initAnimation() {\r\n    }\r\n\r\n    public boolean nextAnimationStep() {\r\n        boolean finished = animationModel.nextStep();\r\n        if (finished) {\r\n            if (animationModel.isOnlyOneSequence()) {\r\n                setState(State.ANIMATION);\r\n                // n�chste Sequzenz ausw�hlen (einfaches sequentielles Anschauen des Spielzugs)\r\n                int nextSeq = (getAcutalSequenceNr() == getHighestSequenceNumber()) ? getAcutalSequenceNr() : getAcutalSequenceNr() + 1;\r\n                List<MoveEvent> nextSeqEvents = getMoveEvents(nextSeq);\r\n                if (nextSeqEvents.get(0) != null) {\r\n                    setActualMoveEvent(nextSeqEvents.get(0));\r\n                }\r\n            } else {\r\n                setState(State.FULL_ANIMATION_ENDED);\r\n            }\r\n        } else {\r\n            fireModelChanged();\r\n        }\r\n        return finished;\r\n    }\r\n\r\n    public void stopAnimation() {\r\n        setState(State.ANIMATION);\r\n        runningAnimator = null;\r\n        setActualMoveEvent(getActualMoveEvent());\r\n    }\r\n\r\n    public boolean isMarkedPlayerAddable() {\r\n        int seq = getAcutalSequenceNr();\r\n        return !events.contains(new MoveEvent(markedPlayer, seq));\r\n    }\r\n\r\n    public boolean passEventDefined(int seq) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() == seq && event instanceof PassEvent) {\r\n                defined = true;\r\n                break;\r\n            }\r\n            if (event.getSequenceNr() > seq) {\r\n                break;\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public boolean passEventDefined() {\r\n        return passEventDefined(getAcutalSequenceNr());\r\n    }\r\n\r\n    public boolean passEventDefinedAfter(int seq) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if ((event instanceof PassEvent) && (event.getSequenceNr() > seq)) {\r\n                defined = true;\r\n                break;\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public boolean eventDefinedAfter(int seq) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() > seq) {\r\n                defined = true;\r\n                break;\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public Ball getBall() {\r\n        return ball;\r\n    }\r\n\r\n    public void setFirstBallOwner(Offender offender) {\r\n        this.firstBallOwner = offender;\r\n        setBallOwner(offender);\r\n        if (firstBallOwner == null) {\r\n            resetBallPosition();\r\n        }\r\n    }\r\n\r\n    public Offender getFirstBallOwner() {\r\n        return firstBallOwner;\r\n    }\r\n\r\n    public boolean hasPlayerBallInNextSequence(Player player) {\r\n        PassEvent pass = null;\r\n        int seq = getAcutalSequenceNr();\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() == seq && event instanceof PassEvent) {\r\n                pass = (PassEvent) event;\r\n                break;\r\n            }\r\n            if (event.getSequenceNr() > seq) {\r\n                break;\r\n            }\r\n        }\r\n        if (pass != null && pass.getDestinationPlayer() != null) {\r\n            return pass.getDestinationPlayer().equals(player) && !passEventDefined(seq + 1);\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public boolean isBallSet() {\r\n        return ballOwner != null;\r\n    }\r\n\r\n    public boolean isGoalPassSet() {\r\n        boolean defined = false;\r\n        for (MoveEvent event : getEvents()) {\r\n            if (event instanceof PassEvent) {\r\n                PassEvent pass = (PassEvent) event;\r\n                if (pass.isGoalPass()) {\r\n                    defined = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public void moveBallTo(int x, int y) {\r\n        ball.setCurrent_x(x);\r\n        ball.setCurrent_y(y);\r\n    }\r\n\r\n    public List<MoveEvent> getActualMoveEvents() {\r\n        return getMoveEvents(getAcutalSequenceNr());\r\n    }\r\n\r\n    public List<MoveEvent> getMoveEvents(int sequenceNr) {\r\n        List<MoveEvent> sequenceEvents = new ArrayList<MoveEvent>();\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() == sequenceNr) {\r\n                sequenceEvents.add(event);\r\n            } else if (event.getSequenceNr() > getAcutalSequenceNr()) {\r\n                break;\r\n            }\r\n        }\r\n        return sequenceEvents;\r\n    }\r\n\r\n    /**\r\n     * Löscht das Aktuelle Ereignis und ALLE Folgenden\r\n     */\r\n    public void removeEventsAfter() {\r\n        MoveEvent event = getActualMoveEvent();\r\n        List<MoveEvent> toDeleteEvents = new ArrayList<MoveEvent>();\r\n        int sequenceNr = event.getSequenceNr();\r\n        // zu loeschende Events sammeln\r\n        for (MoveEvent evt : getEvents()) {\r\n            if (evt.getSequenceNr() > sequenceNr) {\r\n                // Event ist hoeher, also loeschen\r\n                toDeleteEvents.add(evt);\r\n            }\r\n        }\r\n        toDeleteEvents.add(event);\r\n        // gesammelte Events loeschen\r\n        for (MoveEvent deleteEvent : toDeleteEvents) {\r\n            removeMoveEvent(deleteEvent);\r\n        }\r\n        setActualMoveEvent((getEvents().size() > 0) ? getEvents().get(getEvents().size() - 1) : null);\r\n        fireModelChanged();\r\n    }\r\n\r\n    /**\r\n     * Löscht die Ereignisse (auch P�sse) des �bergebenen Spielers. Und die\r\n     * evtl. davon abh�ngigen Folgep�sse\r\n     *\r\n     * @param player\r\n     */\r\n    private void removeEventsOfPlayer(Player player) {\r\n        List<MoveEvent> toDeleteEvents = new ArrayList<MoveEvent>();\r\n        boolean playerInvolved = false;\r\n        // zu loeschende Events sammeln\r\n        for (MoveEvent evt : getEvents()) {\r\n            // Pass?\r\n            if (evt instanceof PassEvent) {\r\n                PassEvent pass = (PassEvent) evt;\r\n                // War ein Pass zu dem Spieler? oder Spieler passt selbst?\r\n                if (pass.getDestinationPlayer().equals(player) || pass.getPlayer().equals(player)) {\r\n                    playerInvolved = true;\r\n                }\r\n                // War Spieler an einem Pass beteiligt?\r\n                if (playerInvolved) {\r\n                    toDeleteEvents.add(pass);\r\n                    continue;\r\n                }\r\n            }\r\n            if (evt.getPlayer().equals(player)) {\r\n                toDeleteEvents.add(evt);\r\n            }\r\n        }\r\n        // gesammelte Events loeschen\r\n        for (MoveEvent deleteEvent : toDeleteEvents) {\r\n            removeMoveEvent(deleteEvent);\r\n        }\r\n        setActualMoveEvent((getEvents().size() > 0) ? getEvents().get(getEvents().size() - 1) : null);\r\n    }\r\n\r\n    public boolean eventDefinedWithPlayer(Player player) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if (event.getPlayer().equals(player)) {\r\n                defined = true;\r\n                break;\r\n            }\r\n            if (event instanceof PassEvent) {\r\n                PassEvent pass = (PassEvent) event;\r\n                if (pass.getDestinationPlayer().equals(player)) {\r\n                    defined = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public int getHighestSequenceNumber() {\r\n        if (events.size() == 0) {\r\n            return 0;\r\n        } else {\r\n            return events.last().getSequenceNr();\r\n        }\r\n    }\r\n\r\n    public String getMoveName() {\r\n        return moveName;\r\n    }\r\n\r\n    public void setMoveName(String moveName) {\r\n        this.moveName = moveName;\r\n        if (Main.getWindow() != null) {\r\n            StringBuffer buffer = new StringBuffer(APP_NAME);\r\n            buffer.append(\" - \");\r\n            if (moveName == null || moveName.equals(\"\")) {\r\n                buffer.append(\"Unbenannt\");\r\n                // Titelleiste aktualisieren\r\n            } else {\r\n                buffer.append(moveName);\r\n            }\r\n            if (!isSaved()) {\r\n                buffer.append(\"*\");\r\n            }\r\n            Main.getWindow().setTitle(buffer.toString());\r\n        }\r\n    }\r\n\r\n    public String getComment() {\r\n        if (comment == null) {\r\n            comment = \"\";\r\n        }\r\n        return comment;\r\n    }\r\n\r\n    public void setComment(String comment) {\r\n        this.comment = comment;\r\n        fireModelChanged();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/model/HandballModelTest13.java",
		"test_prompt": "// HandballModelTest13.java\npackage visu.handball.moves.model;\n\nimport java.awt.geom.Point2D;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\nimport javax.swing.JOptionPane;\nimport visu.handball.moves.Main;\nimport visu.handball.moves.model.animation.AnimationModel;\nimport visu.handball.moves.model.animation.Animator;\nimport visu.handball.moves.model.player.Ball;\nimport visu.handball.moves.model.player.Defender;\nimport visu.handball.moves.model.player.HighlightableItem;\nimport visu.handball.moves.model.player.MovePoint;\nimport visu.handball.moves.model.player.Offender;\nimport visu.handball.moves.model.player.Player;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HandballModel}.\n* It contains ten unit test cases for the {@link HandballModel#isGoalPassSet()} method.\n*/\nclass HandballModelTest13 {"
	},
	{
		"original_code": "// HandballModel.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.model;\r\n\r\nimport java.awt.geom.Point2D;\r\nimport java.io.Serializable;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.SortedSet;\r\nimport java.util.TreeSet;\r\nimport javax.swing.JOptionPane;\r\nimport visu.handball.moves.Main;\r\nimport visu.handball.moves.model.animation.AnimationModel;\r\nimport visu.handball.moves.model.animation.Animator;\r\nimport visu.handball.moves.model.player.Ball;\r\nimport visu.handball.moves.model.player.Defender;\r\nimport visu.handball.moves.model.player.HighlightableItem;\r\nimport visu.handball.moves.model.player.MovePoint;\r\nimport visu.handball.moves.model.player.Offender;\r\nimport visu.handball.moves.model.player.Player;\r\n\r\npublic class HandballModel implements Serializable {\r\n\r\n    private static final long serialVersionUID = -5372891552466311536L;\r\n\r\n    public enum State {\r\n\r\n        INITIAL,\r\n        PLACE_OFFENDERS,\r\n        PLACE_DEFENDERS,\r\n        PLACE_BALL,\r\n        EDIT,\r\n        EDIT_EVENT,\r\n        ANIMATION,\r\n        ANIMATION_RUNNING,\r\n        FULL_ANIMATION_ENDED\r\n    }\r\n\r\n    private static final int MAX_OFFENDERS = 6;\r\n\r\n    private static final int MAX_DEFENDERS = 6;\r\n\r\n    private static final int MARK_RADIUS = 12;\r\n\r\n    private static final String APP_NAME = \"jHandballMoves\";\r\n\r\n    private transient List<HandballModelListener> listeners;\r\n\r\n    private transient List<PlayerRemovedListener> playerRemoveListener;\r\n\r\n    private List<Defender> defenders;\r\n\r\n    private List<Offender> offenders;\r\n\r\n    private SortedSet<MoveEvent> events;\r\n\r\n    private State state;\r\n\r\n    private MoveEvent actualEvent;\r\n\r\n    private Player markedPlayer;\r\n\r\n    private HighlightableItem hightlightedItem;\r\n\r\n    private Offender ballOwner;\r\n\r\n    private Ball ball;\r\n\r\n    private Offender firstBallOwner;\r\n\r\n    private transient Animator runningAnimator;\r\n\r\n    private int animationSequenz;\r\n\r\n    private transient AnimationModel animationModel;\r\n\r\n    private transient HandballModel lastSavedModel;\r\n\r\n    private String comment;\r\n\r\n    private String moveName;\r\n\r\n    public HandballModel() {\r\n        listeners = new ArrayList<HandballModelListener>();\r\n        playerRemoveListener = new ArrayList<PlayerRemovedListener>();\r\n        initModel();\r\n    }\r\n\r\n    public void initModel() {\r\n        defenders = new ArrayList<Defender>();\r\n        Defender.setCounter(0);\r\n        offenders = new ArrayList<Offender>();\r\n        Offender.setCounter(0);\r\n        events = new TreeSet<MoveEvent>();\r\n        // Workaround wegen ToolBar\r\n        state = State.PLACE_OFFENDERS;\r\n        actualEvent = null;\r\n        markedPlayer = null;\r\n        firstBallOwner = null;\r\n        comment = \"\";\r\n        moveName = \"\";\r\n        resetBallPosition();\r\n        try {\r\n            lastSavedModel = (HandballModel) Main.deepCopy(this);\r\n        } catch (Exception e) {\r\n            lastSavedModel = null;\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    private void resetBallPosition() {\r\n        ball = new Ball(-500, -500);\r\n    }\r\n\r\n    public void addOffender(int x, int y) {\r\n        if (offenders.size() == MAX_OFFENDERS) {\r\n            JOptionPane.showMessageDialog(Main.getWindow(), \"Sie haben schon \" + MAX_OFFENDERS + \" Angreifer angelegt.\", \"Info:\", JOptionPane.INFORMATION_MESSAGE);\r\n        } else {\r\n            offenders.add(new Offender(x, y));\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void removePlayer(Player toRemove) {\r\n        if (eventDefinedWithPlayer(toRemove)) {\r\n            removeEventsOfPlayer(toRemove);\r\n        }\r\n        if (toRemove instanceof Offender) {\r\n            removeOffender((Offender) toRemove);\r\n        } else {\r\n            removeDefender((Defender) toRemove);\r\n        }\r\n    }\r\n\r\n    private void removeOffender(Offender toRemove) {\r\n        if (getFirstBallOwner() != null && getFirstBallOwner().equals(toRemove)) {\r\n            setFirstBallOwner(null);\r\n        }\r\n        offenders.remove(toRemove);\r\n        if ((getDefenders().size() + getOffenders().size()) == 0) {\r\n            markedPlayer = null;\r\n        }\r\n        // Spielernummer aktualisieren\r\n        Offender.setCounter(determineMaxPlayerNumber(offenders));\r\n        fireOffenderRemoved(toRemove);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void addDefender(int x, int y) {\r\n        if (defenders.size() == MAX_DEFENDERS) {\r\n            JOptionPane.showMessageDialog(Main.getWindow(), \"Sie haben schon \" + MAX_OFFENDERS + \" Verteidiger angelegt.\", \"Info:\", JOptionPane.INFORMATION_MESSAGE);\r\n        } else {\r\n            defenders.add(new Defender(x, y));\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    private void removeDefender(Defender toRemove) {\r\n        defenders.remove(toRemove);\r\n        if ((getDefenders().size() + getOffenders().size()) == 0) {\r\n            markedPlayer = null;\r\n        }\r\n        Defender.setCounter(determineMaxPlayerNumber(defenders));\r\n        fireDefenderRemoved(toRemove);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public boolean addListener(HandballModelListener o) {\r\n        return listeners.add(o);\r\n    }\r\n\r\n    public boolean removeListener(HandballModelListener o) {\r\n        return listeners.remove(o);\r\n    }\r\n\r\n    public boolean addPlayerRemovedListener(PlayerRemovedListener o) {\r\n        return playerRemoveListener.add(o);\r\n    }\r\n\r\n    public boolean removePlayerRemovedListener(PlayerRemovedListener o) {\r\n        return playerRemoveListener.remove(o);\r\n    }\r\n\r\n    private void fireModelChanged() {\r\n        setMoveName(getMoveName());\r\n        for (HandballModelListener listener : listeners) {\r\n            listener.modelChanged();\r\n        }\r\n    }\r\n\r\n    private void fireOffenderRemoved(Offender offender) {\r\n        for (PlayerRemovedListener listener : playerRemoveListener) {\r\n            listener.offenderRemoved(offender);\r\n        }\r\n    }\r\n\r\n    private void fireDefenderRemoved(Defender defender) {\r\n        for (PlayerRemovedListener listener : playerRemoveListener) {\r\n            listener.defenderRemoved(defender);\r\n        }\r\n    }\r\n\r\n    public List<Defender> getDefenders() {\r\n        return defenders;\r\n    }\r\n\r\n    public List<Offender> getOffenders() {\r\n        return offenders;\r\n    }\r\n\r\n    public State getState() {\r\n        return state;\r\n    }\r\n\r\n    public void setState(State state) {\r\n        if (state == State.EDIT) {\r\n            if (getActualMoveEvent() == null) {\r\n                // Wenn leer, dann Null, sonst letztes Move Event setzen\r\n                setActualMoveEvent(getEvents().isEmpty() ? null : (getEvents().get(getEvents().size() - 1)));\r\n            } else {\r\n                setActualMoveEvent(getActualMoveEvent());\r\n            }\r\n        }\r\n        if (state == State.PLACE_DEFENDERS || state == State.PLACE_OFFENDERS) {\r\n            if (getFirstBallOwner() != null) {\r\n                setBallOwner(getFirstBallOwner());\r\n            }\r\n            setActualMoveEvent(null);\r\n        }\r\n        this.state = state;\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void addMoveEvent(MoveEvent event) {\r\n        events.add(event);\r\n        if (state == State.EDIT) {\r\n            setActualMoveEvent(event);\r\n            state = State.EDIT_EVENT;\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void removeMoveEvent(MoveEvent event) {\r\n        events.remove(event);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public List<MoveEvent> getEvents() {\r\n        List<MoveEvent> list = new ArrayList<MoveEvent>(events);\r\n        return list;\r\n    }\r\n\r\n    public SortedSet<MoveEvent> getSortedEvents() {\r\n        return events;\r\n    }\r\n\r\n    public int getAcutalSequenceNr() {\r\n        if (actualEvent == null)\r\n            return 0;\r\n        else {\r\n            return actualEvent.getSequenceNr();\r\n        }\r\n    }\r\n\r\n    public void setActualMoveEvent(MoveEvent event) {\r\n        if (this.actualEvent != null) {\r\n            this.actualEvent.setMarked(false);\r\n        }\r\n        this.actualEvent = event;\r\n        computePlayerPositions();\r\n        // aktuellen Spieler setzen\r\n        setMarkedPlayer((event == null) ? null : event.getPlayer());\r\n        if (actualEvent != null) {\r\n            if (!actualEvent.isDestinationPointSet()) {\r\n                state = State.EDIT_EVENT;\r\n            } else {\r\n                if (state == State.FULL_ANIMATION_ENDED) {\r\n                    state = State.ANIMATION;\r\n                } else if (state != State.ANIMATION && state != State.ANIMATION_RUNNING) {\r\n                    state = State.EDIT;\r\n                }\r\n            }\r\n            actualEvent.setMarked(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setDestinationPointForEvent(MoveEvent event, int x, int y, boolean temp) {\r\n        event.setDestinationPoint(x, y, temp);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setControlPointForEvent(MoveEvent event, int x, int y, boolean temp) {\r\n        event.setControlPoint(x, y, temp);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setMovePointTo(MovePoint point, int x, int y) {\r\n        actualEvent.setPoint(point, x, y);\r\n        fireModelChanged();\r\n    }\r\n\r\n    private void computePlayerPositions() {\r\n        computePlayerPositions(getAcutalSequenceNr());\r\n    }\r\n\r\n    public void computePlayerPositions(int seqNr) {\r\n        // Spieler Positionen auf Ausgangsstellung\r\n        for (Player offender : offenders) {\r\n            offender.resetPosition();\r\n        }\r\n        for (Player defender : defenders) {\r\n            defender.resetPosition();\r\n        }\r\n        if (seqNr == 1) {\r\n            setBallOwner(firstBallOwner);\r\n        }\r\n        // alle Events mit kleinerer Sequenznummer verarbeiten\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() < seqNr) {\r\n                if (event instanceof PassEvent) {\r\n                    // Ball an anderen Spieler �bertragen\r\n                    setBallOwner(((PassEvent) event).getDestinationPlayer());\r\n                } else {\r\n                    if (event.getDestinationX() > -1 && event.getDestinationY() > -1) {\r\n                        event.getPlayer().setCurrentPosition(event.getDestinationX(), event.getDestinationY());\r\n                    }\r\n                }\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    public MoveEvent getActualMoveEvent() {\r\n        return actualEvent;\r\n    }\r\n\r\n    public Player getMarkedPlayer() {\r\n        return markedPlayer;\r\n    }\r\n\r\n    public void setMarkedPlayer(Player markedPlayer) {\r\n        // alten markierten Spieler demarkieren\r\n        if (this.markedPlayer != null) {\r\n            this.markedPlayer.setMarked(false);\r\n        }\r\n        // evtl. neuen Spieler markieren\r\n        this.markedPlayer = markedPlayer;\r\n        if (markedPlayer != null) {\r\n            markedPlayer.setMarked(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setHighLightedItem(HighlightableItem item) {\r\n        if (this.hightlightedItem != null) {\r\n            // altes Item zur�cksetzen\r\n            this.hightlightedItem.setHighlight(false);\r\n        }\r\n        this.hightlightedItem = item;\r\n        if (item != null) {\r\n            hightlightedItem.setHighlight(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public HighlightableItem getHightligtedItem() {\r\n        return hightlightedItem;\r\n    }\r\n\r\n    public Player getNearestPlayer(int x, int y) {\r\n        List<Player> all = new ArrayList<Player>(offenders);\r\n        all.addAll(defenders);\r\n        return findNearestPlayer(x, y, all);\r\n    }\r\n\r\n    public Offender getNearestOffender(int x, int y) {\r\n        List<Player> all = new ArrayList<Player>(offenders);\r\n        return (Offender) findNearestPlayer(x, y, all);\r\n    }\r\n\r\n    private Player findNearestPlayer(int x, int y, List<Player> players) {\r\n        double entfernung = Double.MAX_VALUE;\r\n        Player temp = null;\r\n        for (Player player : players) {\r\n            int player_x = player.getCurrent_x();\r\n            int player_y = player.getCurrent_y();\r\n            double tempEntfernung = Point2D.distance(x, y, player_x, player_y);\r\n            // Wenn naeher als der MARK_RADIUS\r\n            if (!(tempEntfernung > MARK_RADIUS)) {\r\n                if (tempEntfernung < entfernung) {\r\n                    temp = player;\r\n                    entfernung = tempEntfernung;\r\n                }\r\n            }\r\n        }\r\n        return temp;\r\n    }\r\n\r\n    public MovePoint getNearestMovePoint(int x, int y) {\r\n        MovePoint point = null;\r\n        if (actualEvent != null) {\r\n            double entfernung = Double.MAX_VALUE;\r\n            if (actualEvent.isDestinationPointSet()) {\r\n                int destination_x = actualEvent.getDestinationX();\r\n                int destination_y = actualEvent.getDestinationY();\r\n                double tempEntfernung = Point2D.distance(x, y, destination_x, destination_y);\r\n                // Wenn naeher als der MARK_RADIUS\r\n                if (!(tempEntfernung > MARK_RADIUS)) {\r\n                    if (tempEntfernung < entfernung) {\r\n                        point = actualEvent.getDestinationPoint();\r\n                        entfernung = tempEntfernung;\r\n                    }\r\n                }\r\n            }\r\n            if (actualEvent.isControlPointSet()) {\r\n                int controlPoint_x = actualEvent.getControlPointX();\r\n                int controlPoint_y = actualEvent.getControlPointY();\r\n                double tempEntfernung = Point2D.distance(x, y, controlPoint_x, controlPoint_y);\r\n                // Wenn naeher als der MARK_RADIUS\r\n                if (!(tempEntfernung > MARK_RADIUS)) {\r\n                    if (tempEntfernung < entfernung) {\r\n                        point = actualEvent.getControlPoint();\r\n                        entfernung = tempEntfernung;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return point;\r\n    }\r\n\r\n    public HighlightableItem getNearestHighlightableItem(int x, int y) {\r\n        HighlightableItem temp = null;\r\n        temp = getNearestMovePoint(x, y);\r\n        if (temp == null) {\r\n            temp = getNearestPlayer(x, y);\r\n        }\r\n        return temp;\r\n    }\r\n\r\n    public void movePlayerTo(Player actualPlayer, int x, int y) {\r\n        if (getAcutalSequenceNr() == 0) {\r\n            actualPlayer.setStart_x(x);\r\n            actualPlayer.setStart_y(y);\r\n        }\r\n        // Ansonsten muss die Position im entsprechenden Ereignis gesetzt\r\n        // werden\r\n        // Startposition darf nur im Angreifer/Verteidiger-Modus ge�ndert werden\r\n        fireModelChanged();\r\n    }\r\n\r\n    public boolean isSaved() {\r\n        boolean changed = false;\r\n        if (lastSavedModel != null) {\r\n            //Spielzugnamen vergleichen\r\n            if (lastSavedModel.getMoveName() != null) {\r\n                if (getMoveName() == null || !lastSavedModel.getMoveName().equals(getMoveName())) {\r\n                    return false;\r\n                }\r\n            } else if (getMoveName() != null) {\r\n                //alt: kein Name <-> neu: Name vorhanden\r\n                return false;\r\n            }\r\n            //Ueberprüfen ob Angreifer und Verteidiger unterschiedlich\r\n            // zuerst Spielerlisten vergleichen\r\n            if (changedPlayerList(getOffenders().toArray(new Player[getOffenders().size()]), lastSavedModel.getOffenders().toArray(new Player[lastSavedModel.getOffenders().size()])) || changedPlayerList(getDefenders().toArray(new Player[getDefenders().size()]), lastSavedModel.getDefenders().toArray(new Player[lastSavedModel.getDefenders().size()]))) {\r\n                changed = true;\r\n            } else {\r\n                List<MoveEvent> newEvents = getEvents();\r\n                List<MoveEvent> oldEvents = lastSavedModel.getEvents();\r\n                if (newEvents.size() == oldEvents.size()) {\r\n                    for (int i = 0; i < newEvents.size(); i++) {\r\n                        if (!newEvents.get(i).equals(oldEvents.get(i))) {\r\n                            changed = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                } else {\r\n                    changed = true;\r\n                }\r\n            }\r\n            if (!changed && (getFirstBallOwner() != null || lastSavedModel.getFirstBallOwner() != null)) {\r\n                changed = (getFirstBallOwner() == null) ^ (lastSavedModel.getFirstBallOwner() == null);\r\n                if (!changed) {\r\n                    changed = !getFirstBallOwner().equals(lastSavedModel.getFirstBallOwner());\r\n                }\r\n            }\r\n            // wurde Kommentar geändert?\r\n            if (!changed) {\r\n                if (comment == null || comment.equals(\"\")) {\r\n                    if (lastSavedModel.getComment() != null && !lastSavedModel.getComment().equals(\"\")) {\r\n                        changed = true;\r\n                    }\r\n                } else if (lastSavedModel.getComment() != null) {\r\n                    if (!lastSavedModel.getComment().equals(comment)) {\r\n                        changed = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return !changed;\r\n    }\r\n\r\n    private boolean changedPlayerList(Player[] newList, Player[] oldList) {\r\n        boolean changed = false;\r\n        int size = newList.length;\r\n        int sizeOld = oldList.length;\r\n        if (size == sizeOld) {\r\n            for (int i = 0; i < size; i++) {\r\n                if (!newList[i].equals(oldList[i])) {\r\n                    changed = true;\r\n                    break;\r\n                }\r\n            }\r\n        } else {\r\n            changed = true;\r\n        }\r\n        return changed;\r\n    }\r\n\r\n    public void initWithLoadedModel(HandballModel loadedModel) {\r\n        initModel();\r\n        offenders = loadedModel.getOffenders();\r\n        defenders = loadedModel.getDefenders();\r\n        events = loadedModel.getSortedEvents();\r\n        Offender.setCounter(determineMaxPlayerNumber(offenders));\r\n        Defender.setCounter(determineMaxPlayerNumber(defenders));\r\n        setFirstBallOwner(loadedModel.getFirstBallOwner());\r\n        setState(loadedModel.getState());\r\n        setActualMoveEvent(loadedModel.getActualMoveEvent());\r\n        setComment(loadedModel.getComment());\r\n        // zur Sicherheit\r\n        if (getComment() == null) {\r\n            setComment(\"\");\r\n        }\r\n        setMoveName(loadedModel.getMoveName());\r\n        markAsSaved(loadedModel);\r\n        fireModelChanged();\r\n    }\r\n\r\n    private int determineMaxPlayerNumber(List players) {\r\n        int max = 0;\r\n        for (Object o : players) {\r\n            if (o instanceof Player) {\r\n                Player player = (Player) o;\r\n                if (player.getPlayerNumber() > max) {\r\n                    max = player.getPlayerNumber();\r\n                }\r\n            }\r\n        }\r\n        return max;\r\n    }\r\n\r\n    public void markAsSaved(HandballModel model) {\r\n        try {\r\n            lastSavedModel = (HandballModel) Main.deepCopy(model);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            lastSavedModel = null;\r\n        }\r\n    }\r\n\r\n    public void setDelay(int eventIndex, int delay) {\r\n        getEvents().get(eventIndex).setDelay(delay);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setBallOwner(Offender ballOwner) {\r\n        if (this.ballOwner != null) {\r\n            this.ballOwner.setHasBall(false);\r\n        }\r\n        this.ballOwner = ballOwner;\r\n        if (ballOwner != null) {\r\n            ballOwner.setHasBall(true);\r\n        }\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void setBallOwnerSilent(Offender ballOwner) {\r\n        if (this.ballOwner != null) {\r\n            this.ballOwner.setHasBall(false);\r\n        }\r\n        this.ballOwner = ballOwner;\r\n        if (ballOwner != null) {\r\n            ballOwner.setHasBall(true);\r\n        }\r\n        // fireModelChanged();\r\n    }\r\n\r\n    public void startAnimation(boolean onlyActualSequence) {\r\n        setState(State.ANIMATION_RUNNING);\r\n        MoveEvent event = actualEvent;\r\n        if (event == null) {\r\n            event = getEvents().get(0);\r\n        }\r\n        setActualMoveEvent(event);\r\n        animationSequenz = event.getSequenceNr();\r\n        animationModel = new AnimationModel(event, this, onlyActualSequence);\r\n        runningAnimator = new Animator(this);\r\n        computePlayerPositions(animationSequenz);\r\n        fireModelChanged();\r\n    }\r\n\r\n    public void pauseAnimation(boolean pause) {\r\n        if (pause) {\r\n            runningAnimator.setPause(true);\r\n        } else {\r\n            runningAnimator.setPause(false);\r\n        }\r\n    }\r\n\r\n    public void initAnimation() {\r\n    }\r\n\r\n    public boolean nextAnimationStep() {\r\n        boolean finished = animationModel.nextStep();\r\n        if (finished) {\r\n            if (animationModel.isOnlyOneSequence()) {\r\n                setState(State.ANIMATION);\r\n                // n�chste Sequzenz ausw�hlen (einfaches sequentielles Anschauen des Spielzugs)\r\n                int nextSeq = (getAcutalSequenceNr() == getHighestSequenceNumber()) ? getAcutalSequenceNr() : getAcutalSequenceNr() + 1;\r\n                List<MoveEvent> nextSeqEvents = getMoveEvents(nextSeq);\r\n                if (nextSeqEvents.get(0) != null) {\r\n                    setActualMoveEvent(nextSeqEvents.get(0));\r\n                }\r\n            } else {\r\n                setState(State.FULL_ANIMATION_ENDED);\r\n            }\r\n        } else {\r\n            fireModelChanged();\r\n        }\r\n        return finished;\r\n    }\r\n\r\n    public void stopAnimation() {\r\n        setState(State.ANIMATION);\r\n        runningAnimator = null;\r\n        setActualMoveEvent(getActualMoveEvent());\r\n    }\r\n\r\n    public boolean isMarkedPlayerAddable() {\r\n        int seq = getAcutalSequenceNr();\r\n        return !events.contains(new MoveEvent(markedPlayer, seq));\r\n    }\r\n\r\n    public boolean passEventDefined(int seq) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() == seq && event instanceof PassEvent) {\r\n                defined = true;\r\n                break;\r\n            }\r\n            if (event.getSequenceNr() > seq) {\r\n                break;\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public boolean passEventDefined() {\r\n        return passEventDefined(getAcutalSequenceNr());\r\n    }\r\n\r\n    public boolean passEventDefinedAfter(int seq) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if ((event instanceof PassEvent) && (event.getSequenceNr() > seq)) {\r\n                defined = true;\r\n                break;\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public boolean eventDefinedAfter(int seq) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() > seq) {\r\n                defined = true;\r\n                break;\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public Ball getBall() {\r\n        return ball;\r\n    }\r\n\r\n    public void setFirstBallOwner(Offender offender) {\r\n        this.firstBallOwner = offender;\r\n        setBallOwner(offender);\r\n        if (firstBallOwner == null) {\r\n            resetBallPosition();\r\n        }\r\n    }\r\n\r\n    public Offender getFirstBallOwner() {\r\n        return firstBallOwner;\r\n    }\r\n\r\n    public boolean hasPlayerBallInNextSequence(Player player) {\r\n        PassEvent pass = null;\r\n        int seq = getAcutalSequenceNr();\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() == seq && event instanceof PassEvent) {\r\n                pass = (PassEvent) event;\r\n                break;\r\n            }\r\n            if (event.getSequenceNr() > seq) {\r\n                break;\r\n            }\r\n        }\r\n        if (pass != null && pass.getDestinationPlayer() != null) {\r\n            return pass.getDestinationPlayer().equals(player) && !passEventDefined(seq + 1);\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public boolean isBallSet() {\r\n        return ballOwner != null;\r\n    }\r\n\r\n    public boolean isGoalPassSet() {\r\n        boolean defined = false;\r\n        for (MoveEvent event : getEvents()) {\r\n            if (event instanceof PassEvent) {\r\n                PassEvent pass = (PassEvent) event;\r\n                if (pass.isGoalPass()) {\r\n                    defined = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public void moveBallTo(int x, int y) {\r\n        ball.setCurrent_x(x);\r\n        ball.setCurrent_y(y);\r\n    }\r\n\r\n    public List<MoveEvent> getActualMoveEvents() {\r\n        return getMoveEvents(getAcutalSequenceNr());\r\n    }\r\n\r\n    public List<MoveEvent> getMoveEvents(int sequenceNr) {\r\n        List<MoveEvent> sequenceEvents = new ArrayList<MoveEvent>();\r\n        for (MoveEvent event : events) {\r\n            if (event.getSequenceNr() == sequenceNr) {\r\n                sequenceEvents.add(event);\r\n            } else if (event.getSequenceNr() > getAcutalSequenceNr()) {\r\n                break;\r\n            }\r\n        }\r\n        return sequenceEvents;\r\n    }\r\n\r\n    /**\r\n     * Löscht das Aktuelle Ereignis und ALLE Folgenden\r\n     */\r\n    public void removeEventsAfter() {\r\n        MoveEvent event = getActualMoveEvent();\r\n        List<MoveEvent> toDeleteEvents = new ArrayList<MoveEvent>();\r\n        int sequenceNr = event.getSequenceNr();\r\n        // zu loeschende Events sammeln\r\n        for (MoveEvent evt : getEvents()) {\r\n            if (evt.getSequenceNr() > sequenceNr) {\r\n                // Event ist hoeher, also loeschen\r\n                toDeleteEvents.add(evt);\r\n            }\r\n        }\r\n        toDeleteEvents.add(event);\r\n        // gesammelte Events loeschen\r\n        for (MoveEvent deleteEvent : toDeleteEvents) {\r\n            removeMoveEvent(deleteEvent);\r\n        }\r\n        setActualMoveEvent((getEvents().size() > 0) ? getEvents().get(getEvents().size() - 1) : null);\r\n        fireModelChanged();\r\n    }\r\n\r\n    /**\r\n     * Löscht die Ereignisse (auch P�sse) des �bergebenen Spielers. Und die\r\n     * evtl. davon abh�ngigen Folgep�sse\r\n     *\r\n     * @param player\r\n     */\r\n    private void removeEventsOfPlayer(Player player) {\r\n        List<MoveEvent> toDeleteEvents = new ArrayList<MoveEvent>();\r\n        boolean playerInvolved = false;\r\n        // zu loeschende Events sammeln\r\n        for (MoveEvent evt : getEvents()) {\r\n            // Pass?\r\n            if (evt instanceof PassEvent) {\r\n                PassEvent pass = (PassEvent) evt;\r\n                // War ein Pass zu dem Spieler? oder Spieler passt selbst?\r\n                if (pass.getDestinationPlayer().equals(player) || pass.getPlayer().equals(player)) {\r\n                    playerInvolved = true;\r\n                }\r\n                // War Spieler an einem Pass beteiligt?\r\n                if (playerInvolved) {\r\n                    toDeleteEvents.add(pass);\r\n                    continue;\r\n                }\r\n            }\r\n            if (evt.getPlayer().equals(player)) {\r\n                toDeleteEvents.add(evt);\r\n            }\r\n        }\r\n        // gesammelte Events loeschen\r\n        for (MoveEvent deleteEvent : toDeleteEvents) {\r\n            removeMoveEvent(deleteEvent);\r\n        }\r\n        setActualMoveEvent((getEvents().size() > 0) ? getEvents().get(getEvents().size() - 1) : null);\r\n    }\r\n\r\n    public boolean eventDefinedWithPlayer(Player player) {\r\n        boolean defined = false;\r\n        for (MoveEvent event : events) {\r\n            if (event.getPlayer().equals(player)) {\r\n                defined = true;\r\n                break;\r\n            }\r\n            if (event instanceof PassEvent) {\r\n                PassEvent pass = (PassEvent) event;\r\n                if (pass.getDestinationPlayer().equals(player)) {\r\n                    defined = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return defined;\r\n    }\r\n\r\n    public int getHighestSequenceNumber() {\r\n        if (events.size() == 0) {\r\n            return 0;\r\n        } else {\r\n            return events.last().getSequenceNr();\r\n        }\r\n    }\r\n\r\n    public String getMoveName() {\r\n        return moveName;\r\n    }\r\n\r\n    public void setMoveName(String moveName) {\r\n        this.moveName = moveName;\r\n        if (Main.getWindow() != null) {\r\n            StringBuffer buffer = new StringBuffer(APP_NAME);\r\n            buffer.append(\" - \");\r\n            if (moveName == null || moveName.equals(\"\")) {\r\n                buffer.append(\"Unbenannt\");\r\n                // Titelleiste aktualisieren\r\n            } else {\r\n                buffer.append(moveName);\r\n            }\r\n            if (!isSaved()) {\r\n                buffer.append(\"*\");\r\n            }\r\n            Main.getWindow().setTitle(buffer.toString());\r\n        }\r\n    }\r\n\r\n    public String getComment() {\r\n        if (comment == null) {\r\n            comment = \"\";\r\n        }\r\n        return comment;\r\n    }\r\n\r\n    public void setComment(String comment) {\r\n        this.comment = comment;\r\n        fireModelChanged();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/model/HandballModelTest14.java",
		"test_prompt": "// HandballModelTest14.java\npackage visu.handball.moves.model;\n\nimport java.awt.geom.Point2D;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\nimport javax.swing.JOptionPane;\nimport visu.handball.moves.Main;\nimport visu.handball.moves.model.animation.AnimationModel;\nimport visu.handball.moves.model.animation.Animator;\nimport visu.handball.moves.model.player.Ball;\nimport visu.handball.moves.model.player.Defender;\nimport visu.handball.moves.model.player.HighlightableItem;\nimport visu.handball.moves.model.player.MovePoint;\nimport visu.handball.moves.model.player.Offender;\nimport visu.handball.moves.model.player.Player;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HandballModel}.\n* It contains ten unit test cases for the {@link HandballModel#eventDefinedWithPlayer(Player)} method.\n*/\nclass HandballModelTest14 {"
	},
	{
		"original_code": "// PassEvent.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.model;\r\n\r\nimport visu.handball.moves.model.player.Offender;\r\nimport visu.handball.moves.model.player.Player;\r\n\r\npublic class PassEvent extends MoveEvent {\r\n\r\n    private static final long serialVersionUID = -5172891552466311536L;\r\n\r\n    private Offender destinationPlayer;\r\n\r\n    private boolean goalPass;\r\n\r\n    public PassEvent(Player fromPlayer, int nr, int delay) {\r\n        super(fromPlayer, nr, delay);\r\n        this.destinationPlayer = null;\r\n        controlPoint = null;\r\n        destinationPointTemporary = true;\r\n        goalPass = false;\r\n    }\r\n\r\n    public void setDestinationPlayer(Offender destinationPlayer, boolean temp) {\r\n        this.destinationPlayer = destinationPlayer;\r\n        destinationPointTemporary = temp;\r\n    }\r\n\r\n    public Offender getDestinationPlayer() {\r\n        return destinationPlayer;\r\n    }\r\n\r\n    public boolean isGoalPass() {\r\n        return goalPass;\r\n    }\r\n\r\n    public void setGoalPass(boolean goalPass) {\r\n        this.goalPass = goalPass;\r\n        if (goalPass) {\r\n            destinationPointTemporary = false;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        String str = \"\";\r\n        if (goalPass) {\r\n            str = \"Torwurf\";\r\n        } else if (destinationPlayer == null) {\r\n            str = \"Passweg nicht definiert\";\r\n        } else {\r\n            str = \"Pass zu Spieler \\\" \" + destinationPlayer + \"\\\"\";\r\n        }\r\n        return str;\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(Object obj) {\r\n        if (this == obj) {\r\n            return true;\r\n        }\r\n        if (obj == null) {\r\n            return false;\r\n        }\r\n        if (obj.getClass() != getClass())\r\n            return false;\r\n        PassEvent other = (PassEvent) obj;\r\n        if (other.getDestinationPoint() == null ^ this.getDestinationPoint() == null) {\r\n            return false;\r\n        }\r\n        if (other.getDestinationPoint() == null) {\r\n            // hier ist dann auch this.getDestinationPoint == null\r\n            if (other.getDelay() != this.getDelay() || !other.getPlayer().equals(this.getPlayer()) || other.getSequenceNr() != this.getSequenceNr() || other.isGoalPass() != this.isGoalPass() || (other.getDestinationPlayer() == null ^ this.getDestinationPlayer() == null)) {\r\n                return false;\r\n            }\r\n        } else if (other.getDestinationX() != this.getDestinationX() || other.getDestinationY() != this.getDestinationY() || other.getDelay() != this.getDelay() || !other.getPlayer().equals(this.getPlayer()) || other.getSequenceNr() != this.getSequenceNr() || other.isGoalPass() != this.isGoalPass() || (other.getDestinationPlayer() == null ^ this.getDestinationPlayer() == null)) {\r\n            return false;\r\n        }\r\n        if (other.getDestinationPlayer() != null && this.getDestinationPlayer() != null) {\r\n            if (!other.getDestinationPlayer().equals(this.getDestinationPlayer())) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/model/PassEventTest0.java",
		"test_prompt": "// PassEventTest0.java\npackage visu.handball.moves.model;\n\nimport visu.handball.moves.model.player.Offender;\nimport visu.handball.moves.model.player.Player;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PassEvent}.\n* It contains ten unit test cases for the {@link PassEvent#isGoalPass()} method.\n*/\nclass PassEventTest0 {"
	},
	{
		"original_code": "// PassEvent.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.model;\r\n\r\nimport visu.handball.moves.model.player.Offender;\r\nimport visu.handball.moves.model.player.Player;\r\n\r\npublic class PassEvent extends MoveEvent {\r\n\r\n    private static final long serialVersionUID = -5172891552466311536L;\r\n\r\n    private Offender destinationPlayer;\r\n\r\n    private boolean goalPass;\r\n\r\n    public PassEvent(Player fromPlayer, int nr, int delay) {\r\n        super(fromPlayer, nr, delay);\r\n        this.destinationPlayer = null;\r\n        controlPoint = null;\r\n        destinationPointTemporary = true;\r\n        goalPass = false;\r\n    }\r\n\r\n    public void setDestinationPlayer(Offender destinationPlayer, boolean temp) {\r\n        this.destinationPlayer = destinationPlayer;\r\n        destinationPointTemporary = temp;\r\n    }\r\n\r\n    public Offender getDestinationPlayer() {\r\n        return destinationPlayer;\r\n    }\r\n\r\n    public boolean isGoalPass() {\r\n        return goalPass;\r\n    }\r\n\r\n    public void setGoalPass(boolean goalPass) {\r\n        this.goalPass = goalPass;\r\n        if (goalPass) {\r\n            destinationPointTemporary = false;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        String str = \"\";\r\n        if (goalPass) {\r\n            str = \"Torwurf\";\r\n        } else if (destinationPlayer == null) {\r\n            str = \"Passweg nicht definiert\";\r\n        } else {\r\n            str = \"Pass zu Spieler \\\" \" + destinationPlayer + \"\\\"\";\r\n        }\r\n        return str;\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(Object obj) {\r\n        if (this == obj) {\r\n            return true;\r\n        }\r\n        if (obj == null) {\r\n            return false;\r\n        }\r\n        if (obj.getClass() != getClass())\r\n            return false;\r\n        PassEvent other = (PassEvent) obj;\r\n        if (other.getDestinationPoint() == null ^ this.getDestinationPoint() == null) {\r\n            return false;\r\n        }\r\n        if (other.getDestinationPoint() == null) {\r\n            // hier ist dann auch this.getDestinationPoint == null\r\n            if (other.getDelay() != this.getDelay() || !other.getPlayer().equals(this.getPlayer()) || other.getSequenceNr() != this.getSequenceNr() || other.isGoalPass() != this.isGoalPass() || (other.getDestinationPlayer() == null ^ this.getDestinationPlayer() == null)) {\r\n                return false;\r\n            }\r\n        } else if (other.getDestinationX() != this.getDestinationX() || other.getDestinationY() != this.getDestinationY() || other.getDelay() != this.getDelay() || !other.getPlayer().equals(this.getPlayer()) || other.getSequenceNr() != this.getSequenceNr() || other.isGoalPass() != this.isGoalPass() || (other.getDestinationPlayer() == null ^ this.getDestinationPlayer() == null)) {\r\n            return false;\r\n        }\r\n        if (other.getDestinationPlayer() != null && this.getDestinationPlayer() != null) {\r\n            if (!other.getDestinationPlayer().equals(this.getDestinationPlayer())) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/model/PassEventTest1.java",
		"test_prompt": "// PassEventTest1.java\npackage visu.handball.moves.model;\n\nimport visu.handball.moves.model.player.Offender;\nimport visu.handball.moves.model.player.Player;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PassEvent}.\n* It contains ten unit test cases for the {@link PassEvent#equals(Object)} method.\n*/\nclass PassEventTest1 {"
	},
	{
		"original_code": "// Circle.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.model.player;\r\n\r\nimport java.io.Serializable;\r\n\r\npublic class Circle implements HighlightableItem, Serializable {\r\n\r\n    private static final long serialVersionUID = -5372891552466311536L;\r\n\r\n    private int current_x;\r\n\r\n    private int current_y;\r\n\r\n    private int radius;\r\n\r\n    private boolean highlighted = false;\r\n\r\n    public Circle(int current_x, int current_y, int radius) {\r\n        this.current_x = current_x;\r\n        this.current_y = current_y;\r\n        this.radius = radius;\r\n    }\r\n\r\n    public int getCurrent_x() {\r\n        return current_x;\r\n    }\r\n\r\n    public void setCurrent_x(int current_x) {\r\n        this.current_x = current_x;\r\n    }\r\n\r\n    public int getCurrent_y() {\r\n        return current_y;\r\n    }\r\n\r\n    public void setCurrent_y(int current_y) {\r\n        this.current_y = current_y;\r\n    }\r\n\r\n    public int getRadius() {\r\n        return radius;\r\n    }\r\n\r\n    public void setHighlight(boolean hightligt) {\r\n        highlighted = hightligt;\r\n    }\r\n\r\n    public boolean isHighlighted() {\r\n        return highlighted;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/model/player/CircleTest.java",
		"test_prompt": "// CircleTest.java\npackage visu.handball.moves.model.player;\n\nimport java.io.Serializable;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Circle}.\n* It contains ten unit test cases for the {@link Circle#isHighlighted()} method.\n*/\nclass CircleTest {"
	},
	{
		"original_code": "// Player.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.model.player;\r\n\r\nimport java.io.Serializable;\r\n\r\npublic abstract class Player implements HighlightableItem, Serializable {\r\n\r\n    private static final long serialVersionUID = -5372891552466311536L;\r\n\r\n    private int start_x;\r\n\r\n    private int start_y;\r\n\r\n    private int current_x;\r\n\r\n    private int current_y;\r\n\r\n    private int playerNumber;\r\n\r\n    private boolean hasBall;\r\n\r\n    protected boolean hightlighted;\r\n\r\n    protected boolean marked;\r\n\r\n    public Player(int start_x, int start_y, int playerNumber) {\r\n        this.start_x = start_x;\r\n        this.start_y = start_y;\r\n        this.current_x = start_x;\r\n        this.current_y = start_y;\r\n        this.playerNumber = playerNumber;\r\n        this.hasBall = false;\r\n    }\r\n\r\n    public int getCurrent_x() {\r\n        return current_x;\r\n    }\r\n\r\n    public void setCurrent_x(int current_x) {\r\n        this.current_x = current_x;\r\n    }\r\n\r\n    public int getCurrent_y() {\r\n        return current_y;\r\n    }\r\n\r\n    public void setCurrent_y(int current_y) {\r\n        this.current_y = current_y;\r\n    }\r\n\r\n    public void setCurrentPosition(int x, int y) {\r\n        this.current_x = x;\r\n        this.current_y = y;\r\n    }\r\n\r\n    public boolean hasBall() {\r\n        return hasBall;\r\n    }\r\n\r\n    public void setHasBall(boolean hasBall) {\r\n        this.hasBall = hasBall;\r\n    }\r\n\r\n    public int getPlayerNumber() {\r\n        return playerNumber;\r\n    }\r\n\r\n    public int getStart_x() {\r\n        return start_x;\r\n    }\r\n\r\n    public int getStart_y() {\r\n        return start_y;\r\n    }\r\n\r\n    public void setStart_x(int start_x) {\r\n        this.start_x = start_x;\r\n        this.current_x = start_x;\r\n    }\r\n\r\n    public void setStart_y(int start_y) {\r\n        this.start_y = start_y;\r\n        this.current_y = start_y;\r\n    }\r\n\r\n    public void setStartPosition(int x, int y) {\r\n        setStart_x(x);\r\n        setStart_y(y);\r\n    }\r\n\r\n    public void resetPosition() {\r\n        current_x = start_x;\r\n        current_y = start_y;\r\n    }\r\n\r\n    public void setMarked(boolean marked) {\r\n        this.marked = marked;\r\n    }\r\n\r\n    public void setHighlight(boolean hightligt) {\r\n        this.hightlighted = hightligt;\r\n    }\r\n\r\n    public boolean isHightlighted() {\r\n        return hightlighted;\r\n    }\r\n\r\n    public boolean isMarked() {\r\n        return marked;\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(Object obj) {\r\n        if (this == obj) {\r\n            return true;\r\n        }\r\n        if (obj == null) {\r\n            return false;\r\n        }\r\n        if (obj.getClass() != getClass())\r\n            return false;\r\n        Player other = (Player) obj;\r\n        if (other.isMarked() != this.isMarked() || other.hasBall != this.hasBall() || other.getStart_x() != this.getStart_x() || other.getStart_y() != this.getStart_y() || other.getPlayerNumber() != this.getPlayerNumber()) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/model/player/PlayerTest0.java",
		"test_prompt": "// PlayerTest0.java\npackage visu.handball.moves.model.player;\n\nimport java.io.Serializable;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Player}.\n* It contains ten unit test cases for the {@link Player#hasBall()} method.\n*/\nclass PlayerTest0 {"
	},
	{
		"original_code": "// Player.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.model.player;\r\n\r\nimport java.io.Serializable;\r\n\r\npublic abstract class Player implements HighlightableItem, Serializable {\r\n\r\n    private static final long serialVersionUID = -5372891552466311536L;\r\n\r\n    private int start_x;\r\n\r\n    private int start_y;\r\n\r\n    private int current_x;\r\n\r\n    private int current_y;\r\n\r\n    private int playerNumber;\r\n\r\n    private boolean hasBall;\r\n\r\n    protected boolean hightlighted;\r\n\r\n    protected boolean marked;\r\n\r\n    public Player(int start_x, int start_y, int playerNumber) {\r\n        this.start_x = start_x;\r\n        this.start_y = start_y;\r\n        this.current_x = start_x;\r\n        this.current_y = start_y;\r\n        this.playerNumber = playerNumber;\r\n        this.hasBall = false;\r\n    }\r\n\r\n    public int getCurrent_x() {\r\n        return current_x;\r\n    }\r\n\r\n    public void setCurrent_x(int current_x) {\r\n        this.current_x = current_x;\r\n    }\r\n\r\n    public int getCurrent_y() {\r\n        return current_y;\r\n    }\r\n\r\n    public void setCurrent_y(int current_y) {\r\n        this.current_y = current_y;\r\n    }\r\n\r\n    public void setCurrentPosition(int x, int y) {\r\n        this.current_x = x;\r\n        this.current_y = y;\r\n    }\r\n\r\n    public boolean hasBall() {\r\n        return hasBall;\r\n    }\r\n\r\n    public void setHasBall(boolean hasBall) {\r\n        this.hasBall = hasBall;\r\n    }\r\n\r\n    public int getPlayerNumber() {\r\n        return playerNumber;\r\n    }\r\n\r\n    public int getStart_x() {\r\n        return start_x;\r\n    }\r\n\r\n    public int getStart_y() {\r\n        return start_y;\r\n    }\r\n\r\n    public void setStart_x(int start_x) {\r\n        this.start_x = start_x;\r\n        this.current_x = start_x;\r\n    }\r\n\r\n    public void setStart_y(int start_y) {\r\n        this.start_y = start_y;\r\n        this.current_y = start_y;\r\n    }\r\n\r\n    public void setStartPosition(int x, int y) {\r\n        setStart_x(x);\r\n        setStart_y(y);\r\n    }\r\n\r\n    public void resetPosition() {\r\n        current_x = start_x;\r\n        current_y = start_y;\r\n    }\r\n\r\n    public void setMarked(boolean marked) {\r\n        this.marked = marked;\r\n    }\r\n\r\n    public void setHighlight(boolean hightligt) {\r\n        this.hightlighted = hightligt;\r\n    }\r\n\r\n    public boolean isHightlighted() {\r\n        return hightlighted;\r\n    }\r\n\r\n    public boolean isMarked() {\r\n        return marked;\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(Object obj) {\r\n        if (this == obj) {\r\n            return true;\r\n        }\r\n        if (obj == null) {\r\n            return false;\r\n        }\r\n        if (obj.getClass() != getClass())\r\n            return false;\r\n        Player other = (Player) obj;\r\n        if (other.isMarked() != this.isMarked() || other.hasBall != this.hasBall() || other.getStart_x() != this.getStart_x() || other.getStart_y() != this.getStart_y() || other.getPlayerNumber() != this.getPlayerNumber()) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/model/player/PlayerTest1.java",
		"test_prompt": "// PlayerTest1.java\npackage visu.handball.moves.model.player;\n\nimport java.io.Serializable;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Player}.\n* It contains ten unit test cases for the {@link Player#isHightlighted()} method.\n*/\nclass PlayerTest1 {"
	},
	{
		"original_code": "// Player.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.model.player;\r\n\r\nimport java.io.Serializable;\r\n\r\npublic abstract class Player implements HighlightableItem, Serializable {\r\n\r\n    private static final long serialVersionUID = -5372891552466311536L;\r\n\r\n    private int start_x;\r\n\r\n    private int start_y;\r\n\r\n    private int current_x;\r\n\r\n    private int current_y;\r\n\r\n    private int playerNumber;\r\n\r\n    private boolean hasBall;\r\n\r\n    protected boolean hightlighted;\r\n\r\n    protected boolean marked;\r\n\r\n    public Player(int start_x, int start_y, int playerNumber) {\r\n        this.start_x = start_x;\r\n        this.start_y = start_y;\r\n        this.current_x = start_x;\r\n        this.current_y = start_y;\r\n        this.playerNumber = playerNumber;\r\n        this.hasBall = false;\r\n    }\r\n\r\n    public int getCurrent_x() {\r\n        return current_x;\r\n    }\r\n\r\n    public void setCurrent_x(int current_x) {\r\n        this.current_x = current_x;\r\n    }\r\n\r\n    public int getCurrent_y() {\r\n        return current_y;\r\n    }\r\n\r\n    public void setCurrent_y(int current_y) {\r\n        this.current_y = current_y;\r\n    }\r\n\r\n    public void setCurrentPosition(int x, int y) {\r\n        this.current_x = x;\r\n        this.current_y = y;\r\n    }\r\n\r\n    public boolean hasBall() {\r\n        return hasBall;\r\n    }\r\n\r\n    public void setHasBall(boolean hasBall) {\r\n        this.hasBall = hasBall;\r\n    }\r\n\r\n    public int getPlayerNumber() {\r\n        return playerNumber;\r\n    }\r\n\r\n    public int getStart_x() {\r\n        return start_x;\r\n    }\r\n\r\n    public int getStart_y() {\r\n        return start_y;\r\n    }\r\n\r\n    public void setStart_x(int start_x) {\r\n        this.start_x = start_x;\r\n        this.current_x = start_x;\r\n    }\r\n\r\n    public void setStart_y(int start_y) {\r\n        this.start_y = start_y;\r\n        this.current_y = start_y;\r\n    }\r\n\r\n    public void setStartPosition(int x, int y) {\r\n        setStart_x(x);\r\n        setStart_y(y);\r\n    }\r\n\r\n    public void resetPosition() {\r\n        current_x = start_x;\r\n        current_y = start_y;\r\n    }\r\n\r\n    public void setMarked(boolean marked) {\r\n        this.marked = marked;\r\n    }\r\n\r\n    public void setHighlight(boolean hightligt) {\r\n        this.hightlighted = hightligt;\r\n    }\r\n\r\n    public boolean isHightlighted() {\r\n        return hightlighted;\r\n    }\r\n\r\n    public boolean isMarked() {\r\n        return marked;\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(Object obj) {\r\n        if (this == obj) {\r\n            return true;\r\n        }\r\n        if (obj == null) {\r\n            return false;\r\n        }\r\n        if (obj.getClass() != getClass())\r\n            return false;\r\n        Player other = (Player) obj;\r\n        if (other.isMarked() != this.isMarked() || other.hasBall != this.hasBall() || other.getStart_x() != this.getStart_x() || other.getStart_y() != this.getStart_y() || other.getPlayerNumber() != this.getPlayerNumber()) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/model/player/PlayerTest2.java",
		"test_prompt": "// PlayerTest2.java\npackage visu.handball.moves.model.player;\n\nimport java.io.Serializable;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Player}.\n* It contains ten unit test cases for the {@link Player#isMarked()} method.\n*/\nclass PlayerTest2 {"
	},
	{
		"original_code": "// Player.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.model.player;\r\n\r\nimport java.io.Serializable;\r\n\r\npublic abstract class Player implements HighlightableItem, Serializable {\r\n\r\n    private static final long serialVersionUID = -5372891552466311536L;\r\n\r\n    private int start_x;\r\n\r\n    private int start_y;\r\n\r\n    private int current_x;\r\n\r\n    private int current_y;\r\n\r\n    private int playerNumber;\r\n\r\n    private boolean hasBall;\r\n\r\n    protected boolean hightlighted;\r\n\r\n    protected boolean marked;\r\n\r\n    public Player(int start_x, int start_y, int playerNumber) {\r\n        this.start_x = start_x;\r\n        this.start_y = start_y;\r\n        this.current_x = start_x;\r\n        this.current_y = start_y;\r\n        this.playerNumber = playerNumber;\r\n        this.hasBall = false;\r\n    }\r\n\r\n    public int getCurrent_x() {\r\n        return current_x;\r\n    }\r\n\r\n    public void setCurrent_x(int current_x) {\r\n        this.current_x = current_x;\r\n    }\r\n\r\n    public int getCurrent_y() {\r\n        return current_y;\r\n    }\r\n\r\n    public void setCurrent_y(int current_y) {\r\n        this.current_y = current_y;\r\n    }\r\n\r\n    public void setCurrentPosition(int x, int y) {\r\n        this.current_x = x;\r\n        this.current_y = y;\r\n    }\r\n\r\n    public boolean hasBall() {\r\n        return hasBall;\r\n    }\r\n\r\n    public void setHasBall(boolean hasBall) {\r\n        this.hasBall = hasBall;\r\n    }\r\n\r\n    public int getPlayerNumber() {\r\n        return playerNumber;\r\n    }\r\n\r\n    public int getStart_x() {\r\n        return start_x;\r\n    }\r\n\r\n    public int getStart_y() {\r\n        return start_y;\r\n    }\r\n\r\n    public void setStart_x(int start_x) {\r\n        this.start_x = start_x;\r\n        this.current_x = start_x;\r\n    }\r\n\r\n    public void setStart_y(int start_y) {\r\n        this.start_y = start_y;\r\n        this.current_y = start_y;\r\n    }\r\n\r\n    public void setStartPosition(int x, int y) {\r\n        setStart_x(x);\r\n        setStart_y(y);\r\n    }\r\n\r\n    public void resetPosition() {\r\n        current_x = start_x;\r\n        current_y = start_y;\r\n    }\r\n\r\n    public void setMarked(boolean marked) {\r\n        this.marked = marked;\r\n    }\r\n\r\n    public void setHighlight(boolean hightligt) {\r\n        this.hightlighted = hightligt;\r\n    }\r\n\r\n    public boolean isHightlighted() {\r\n        return hightlighted;\r\n    }\r\n\r\n    public boolean isMarked() {\r\n        return marked;\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(Object obj) {\r\n        if (this == obj) {\r\n            return true;\r\n        }\r\n        if (obj == null) {\r\n            return false;\r\n        }\r\n        if (obj.getClass() != getClass())\r\n            return false;\r\n        Player other = (Player) obj;\r\n        if (other.isMarked() != this.isMarked() || other.hasBall != this.hasBall() || other.getStart_x() != this.getStart_x() || other.getStart_y() != this.getStart_y() || other.getPlayerNumber() != this.getPlayerNumber()) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/model/player/PlayerTest3.java",
		"test_prompt": "// PlayerTest3.java\npackage visu.handball.moves.model.player;\n\nimport java.io.Serializable;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Player}.\n* It contains ten unit test cases for the {@link Player#equals(Object)} method.\n*/\nclass PlayerTest3 {"
	},
	{
		"original_code": "// ColoredShape.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.views;\r\n\r\nimport java.awt.BasicStroke;\r\nimport java.awt.Color;\r\nimport java.awt.Graphics2D;\r\nimport java.awt.Shape;\r\n\r\npublic class ColoredShape {\r\n\r\n    private Shape shape;\r\n\r\n    private Color color;\r\n\r\n    private boolean fill;\r\n\r\n    private BasicStroke stroke;\r\n\r\n    public ColoredShape(Shape shape, Color color, boolean fill) {\r\n        this.shape = shape;\r\n        this.color = color;\r\n        this.fill = fill;\r\n    }\r\n\r\n    public ColoredShape(Shape shape, Color color, boolean fill, BasicStroke stroke) {\r\n        this.shape = shape;\r\n        this.color = color;\r\n        this.fill = fill;\r\n        this.stroke = stroke;\r\n    }\r\n\r\n    public Color getColor() {\r\n        return color;\r\n    }\r\n\r\n    public void setColor(Color color) {\r\n        this.color = color;\r\n    }\r\n\r\n    public Shape getShape() {\r\n        return shape;\r\n    }\r\n\r\n    public void setShape(Shape shape) {\r\n        this.shape = shape;\r\n    }\r\n\r\n    public boolean isFill() {\r\n        return fill;\r\n    }\r\n\r\n    public void setFill(boolean fill) {\r\n        this.fill = fill;\r\n    }\r\n\r\n    public BasicStroke getStroke() {\r\n        return stroke;\r\n    }\r\n\r\n    public void setStroke(BasicStroke stroke) {\r\n        this.stroke = stroke;\r\n    }\r\n\r\n    public void drawShape(Graphics2D g2d) {\r\n        g2d.setColor(getColor());\r\n        if (getStroke() != null) {\r\n            g2d.setStroke(getStroke());\r\n        }\r\n        if (isFill()) {\r\n            g2d.fill(getShape());\r\n        }\r\n        g2d.draw(getShape());\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/views/ColoredShapeTest.java",
		"test_prompt": "// ColoredShapeTest.java\npackage visu.handball.moves.views;\n\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Graphics2D;\nimport java.awt.Shape;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ColoredShape}.\n* It contains ten unit test cases for the {@link ColoredShape#isFill()} method.\n*/\nclass ColoredShapeTest {"
	},
	{
		"original_code": "// AnimatedImageLabel.java\n/*\n * Created on 20.02.2007\n * Created by Thomas Halm\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n */\npackage visu.handball.moves.views;\n\nimport java.awt.Dimension;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.Image;\nimport java.awt.MediaTracker;\nimport java.awt.Toolkit;\nimport java.awt.color.ColorSpace;\nimport java.awt.image.BufferedImage;\nimport java.awt.image.ColorConvertOp;\nimport java.net.URL;\nimport javax.swing.JLabel;\nimport javax.swing.SwingUtilities;\n\npublic class AnimatedImageLabel extends JLabel implements Runnable {\n\n    private Image displayImage;\n\n    private BufferedImage bi;\n\n    private BufferedImage bi_gray;\n\n    private int colorWidth;\n\n    private boolean stopAnimation;\n\n    public AnimatedImageLabel(URL imageUrl) {\n        loadImage(imageUrl);\n        setSize(displayImage.getWidth(this), displayImage.getWidth(this));\n        setPreferredSize(new Dimension(displayImage.getWidth(this), displayImage.getHeight(this)));\n        createBufferedImage();\n    }\n\n    public void loadImage(URL imageUrl) {\n        displayImage = Toolkit.getDefaultToolkit().getImage(imageUrl);\n        MediaTracker mt = new MediaTracker(this);\n        mt.addImage(displayImage, 1);\n        try {\n            mt.waitForAll();\n        } catch (Exception e) {\n            System.out.println(\"Exception while loading.\");\n        }\n        if (displayImage.getWidth(this) == -1) {\n            System.out.println(\"No image\");\n            System.exit(0);\n        }\n    }\n\n    public void createBufferedImage() {\n        bi = new BufferedImage(displayImage.getWidth(this), displayImage.getHeight(this), BufferedImage.TYPE_INT_RGB);\n        // Kopie von bi erstellen\n        bi_gray = new BufferedImage(bi.getWidth(), bi.getHeight(), bi.getType());\n        Graphics g2d = bi.createGraphics();\n        // Grafik in das BufferedImage einfügen\n        g2d.drawImage(displayImage, 0, 0, this);\n        // graues Bild aus Original erstellen\n        ColorConvertOp colorConvert = new ColorConvertOp(ColorSpace.getInstance(ColorSpace.CS_GRAY), null);\n        colorConvert.filter(bi, bi_gray);\n    }\n\n    public void update(Graphics g) {\n        g.clearRect(0, 0, getWidth(), getHeight());\n        paintComponent(g);\n    }\n\n    public void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        Graphics2D g2D = (Graphics2D) g;\n        // zuerst vollständiges graues Bild zeichnen\n        g2D.drawImage(bi_gray, 0, 0, this);\n        // Clipping erstellen von links nach rechts, bis colorWidth\n        g2D.setClip(0, 0, colorWidth, displayImage.getHeight(this));\n        // Farbiges Bild wird in Clipping-Area gezeichnet\n        g2D.drawImage(bi, 0, 0, this);\n    }\n\n    public boolean next() {\n        if (colorWidth < displayImage.getWidth(this)) {\n            colorWidth++;\n            return true;\n        }\n        return false;\n    }\n\n    public void run() {\n        while (next() && !stopAnimation) {\n            SwingUtilities.invokeLater(new Runnable() {\n\n                public void run() {\n                    updateUI();\n                }\n            });\n            try {\n                Thread.sleep(20);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public synchronized void startAnimation() {\n        new Thread(this).start();\n    }\n\n    public synchronized void stopAnimation() {\n        stopAnimation = true;\n        notify();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/views/AnimatedImageLabelTest.java",
		"test_prompt": "// AnimatedImageLabelTest.java\npackage visu.handball.moves.views;\n\nimport java.awt.Dimension;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.Image;\nimport java.awt.MediaTracker;\nimport java.awt.Toolkit;\nimport java.awt.color.ColorSpace;\nimport java.awt.image.BufferedImage;\nimport java.awt.image.ColorConvertOp;\nimport java.net.URL;\nimport javax.swing.JLabel;\nimport javax.swing.SwingUtilities;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AnimatedImageLabel}.\n* It contains ten unit test cases for the {@link AnimatedImageLabel#next()} method.\n*/\nclass AnimatedImageLabelTest {"
	},
	{
		"original_code": "// Field.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.views;\r\n\r\nimport java.awt.Dimension;\r\nimport java.awt.Graphics;\r\nimport java.awt.Graphics2D;\r\nimport java.awt.Point;\r\nimport java.awt.RenderingHints;\r\nimport javax.swing.JPanel;\r\nimport visu.handball.moves.model.ColorModel;\r\nimport visu.handball.moves.model.ColorModelListener;\r\nimport visu.handball.moves.model.HandballModel;\r\nimport visu.handball.moves.model.HandballModelListener;\r\n\r\n/**\r\n * Klasse zur Darstellung einer Spielfeld-Hälfte\r\n *\r\n * @author Tommy\r\n */\r\npublic class Field extends JPanel implements HandballModelListener, ColorModelListener {\r\n\r\n    private HandballModel handballModel;\r\n\r\n    private OffenderDrawer offenderDrawer;\r\n\r\n    private DefenderDrawer defenderDrawer;\r\n\r\n    private FieldDrawer fieldDrawer;\r\n\r\n    private EventDrawer eventDrawer;\r\n\r\n    private BallDrawer ballDrawer;\r\n\r\n    public Field(HandballModel handballModel, ColorModel colorModel) {\r\n        this.handballModel = handballModel;\r\n        handballModel.addListener(this);\r\n        colorModel.addColorModelListener(this);\r\n        fieldDrawer = new FieldDrawer(colorModel);\r\n        offenderDrawer = new OffenderDrawer(handballModel, colorModel);\r\n        defenderDrawer = new DefenderDrawer(handballModel, colorModel);\r\n        eventDrawer = new EventDrawer(handballModel, colorModel);\r\n        ballDrawer = new BallDrawer(colorModel);\r\n        setPreferredSize(new Dimension(FieldDrawer.PANEL_WIDTH, FieldDrawer.PANEL_HEIGHT));\r\n    }\r\n\r\n    protected void paintComponent(Graphics g) {\r\n        super.paintComponent(g);\r\n        Graphics2D g2d = (Graphics2D) g;\r\n        // Kantenglaettung einschalten\r\n        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\r\n        fieldDrawer.draw(g2d);\r\n        offenderDrawer.draw(g2d);\r\n        defenderDrawer.draw(g2d);\r\n        if (handballModel.getState() == HandballModel.State.EDIT || handballModel.getState() == HandballModel.State.EDIT_EVENT || handballModel.getState() == HandballModel.State.ANIMATION) {\r\n            eventDrawer.setPrintMode(handballModel.getState() == HandballModel.State.ANIMATION);\r\n            eventDrawer.draw(g2d);\r\n        }\r\n        if (!handballModel.isBallSet()) {\r\n            ballDrawer.drawCircle(g2d, handballModel.getBall());\r\n        }\r\n    }\r\n\r\n    public boolean insideGoal(int x, int y) {\r\n        return fieldDrawer.insideGoal(x, y);\r\n    }\r\n\r\n    public Point getGoalMiddle() {\r\n        return fieldDrawer.getGoalMiddle();\r\n    }\r\n\r\n    public boolean insideSixMeter(int x, int y) {\r\n        return fieldDrawer.insideSixMeter(x, y);\r\n    }\r\n\r\n    public void modelChanged() {\r\n        repaint();\r\n    }\r\n\r\n    public void colorModelChanged(ColorModel colorModel) {\r\n        fieldDrawer.updateColors(colorModel);\r\n        defenderDrawer.updateColors(colorModel);\r\n        offenderDrawer.updateColors(colorModel);\r\n        eventDrawer.updateColors(colorModel);\r\n        ballDrawer.updateColors(colorModel);\r\n        repaint();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/views/FieldTest0.java",
		"test_prompt": "// FieldTest0.java\npackage visu.handball.moves.views;\n\nimport java.awt.Dimension;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.Point;\nimport java.awt.RenderingHints;\nimport javax.swing.JPanel;\nimport visu.handball.moves.model.ColorModel;\nimport visu.handball.moves.model.ColorModelListener;\nimport visu.handball.moves.model.HandballModel;\nimport visu.handball.moves.model.HandballModelListener;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Field}.\n* It contains ten unit test cases for the {@link Field#insideGoal(int, int)} method.\n*/\nclass FieldTest0 {"
	},
	{
		"original_code": "// Field.java\n/*\r\n * Created on 31.08.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.views;\r\n\r\nimport java.awt.Dimension;\r\nimport java.awt.Graphics;\r\nimport java.awt.Graphics2D;\r\nimport java.awt.Point;\r\nimport java.awt.RenderingHints;\r\nimport javax.swing.JPanel;\r\nimport visu.handball.moves.model.ColorModel;\r\nimport visu.handball.moves.model.ColorModelListener;\r\nimport visu.handball.moves.model.HandballModel;\r\nimport visu.handball.moves.model.HandballModelListener;\r\n\r\n/**\r\n * Klasse zur Darstellung einer Spielfeld-Hälfte\r\n *\r\n * @author Tommy\r\n */\r\npublic class Field extends JPanel implements HandballModelListener, ColorModelListener {\r\n\r\n    private HandballModel handballModel;\r\n\r\n    private OffenderDrawer offenderDrawer;\r\n\r\n    private DefenderDrawer defenderDrawer;\r\n\r\n    private FieldDrawer fieldDrawer;\r\n\r\n    private EventDrawer eventDrawer;\r\n\r\n    private BallDrawer ballDrawer;\r\n\r\n    public Field(HandballModel handballModel, ColorModel colorModel) {\r\n        this.handballModel = handballModel;\r\n        handballModel.addListener(this);\r\n        colorModel.addColorModelListener(this);\r\n        fieldDrawer = new FieldDrawer(colorModel);\r\n        offenderDrawer = new OffenderDrawer(handballModel, colorModel);\r\n        defenderDrawer = new DefenderDrawer(handballModel, colorModel);\r\n        eventDrawer = new EventDrawer(handballModel, colorModel);\r\n        ballDrawer = new BallDrawer(colorModel);\r\n        setPreferredSize(new Dimension(FieldDrawer.PANEL_WIDTH, FieldDrawer.PANEL_HEIGHT));\r\n    }\r\n\r\n    protected void paintComponent(Graphics g) {\r\n        super.paintComponent(g);\r\n        Graphics2D g2d = (Graphics2D) g;\r\n        // Kantenglaettung einschalten\r\n        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\r\n        fieldDrawer.draw(g2d);\r\n        offenderDrawer.draw(g2d);\r\n        defenderDrawer.draw(g2d);\r\n        if (handballModel.getState() == HandballModel.State.EDIT || handballModel.getState() == HandballModel.State.EDIT_EVENT || handballModel.getState() == HandballModel.State.ANIMATION) {\r\n            eventDrawer.setPrintMode(handballModel.getState() == HandballModel.State.ANIMATION);\r\n            eventDrawer.draw(g2d);\r\n        }\r\n        if (!handballModel.isBallSet()) {\r\n            ballDrawer.drawCircle(g2d, handballModel.getBall());\r\n        }\r\n    }\r\n\r\n    public boolean insideGoal(int x, int y) {\r\n        return fieldDrawer.insideGoal(x, y);\r\n    }\r\n\r\n    public Point getGoalMiddle() {\r\n        return fieldDrawer.getGoalMiddle();\r\n    }\r\n\r\n    public boolean insideSixMeter(int x, int y) {\r\n        return fieldDrawer.insideSixMeter(x, y);\r\n    }\r\n\r\n    public void modelChanged() {\r\n        repaint();\r\n    }\r\n\r\n    public void colorModelChanged(ColorModel colorModel) {\r\n        fieldDrawer.updateColors(colorModel);\r\n        defenderDrawer.updateColors(colorModel);\r\n        offenderDrawer.updateColors(colorModel);\r\n        eventDrawer.updateColors(colorModel);\r\n        ballDrawer.updateColors(colorModel);\r\n        repaint();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/views/FieldTest1.java",
		"test_prompt": "// FieldTest1.java\npackage visu.handball.moves.views;\n\nimport java.awt.Dimension;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.Point;\nimport java.awt.RenderingHints;\nimport javax.swing.JPanel;\nimport visu.handball.moves.model.ColorModel;\nimport visu.handball.moves.model.ColorModelListener;\nimport visu.handball.moves.model.HandballModel;\nimport visu.handball.moves.model.HandballModelListener;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Field}.\n* It contains ten unit test cases for the {@link Field#insideSixMeter(int, int)} method.\n*/\nclass FieldTest1 {"
	},
	{
		"original_code": "// FieldDrawer.java\n/*\r\n * Created on 02.10.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.views;\r\n\r\nimport java.awt.BasicStroke;\r\nimport java.awt.Color;\r\nimport java.awt.Graphics2D;\r\nimport java.awt.Point;\r\nimport java.awt.Stroke;\r\nimport java.awt.geom.Arc2D;\r\nimport java.awt.geom.Line2D;\r\nimport java.awt.geom.Point2D;\r\nimport java.awt.geom.Rectangle2D;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport visu.handball.moves.model.ColorModel;\r\n\r\npublic class FieldDrawer {\r\n\r\n    /*\r\n\t * absolute Groesse des Panels\r\n\t */\r\n    public static final int PANEL_WIDTH = 500;\r\n\r\n    public static final int PANEL_HEIGHT = 550;\r\n\r\n    /*\r\n\t * Maße einer Handball-Spielfeld-Haelfte (relativ)\r\n\t */\r\n    private static final int FIELD_WIDTH = 20;\r\n\r\n    private static final int GOAL_WIDTH = 3;\r\n\r\n    private static final int SIX_METER = 6;\r\n\r\n    private static final int NINE_METER = 9;\r\n\r\n    private static final int SPACE = 40;\r\n\r\n    private static final int LINE_THICKNESS = 10;\r\n\r\n    private List<ColoredShape> fieldLinesShapes;\r\n\r\n    private ColoredShape background;\r\n\r\n    private Rectangle2D goal;\r\n\r\n    private Point2D linkerPfosten;\r\n\r\n    private Point2D rechterPfosten;\r\n\r\n    private double sixMeterPixel;\r\n\r\n    public FieldDrawer(ColorModel colorModel) {\r\n        createFieldShapes(colorModel);\r\n    }\r\n\r\n    private void createFieldShapes(ColorModel colorModel) {\r\n        Color fieldColor = colorModel.getFieldColor();\r\n        Color lineColor = colorModel.getLineColor();\r\n        fieldLinesShapes = new ArrayList<ColoredShape>();\r\n        // Spielfeld-Hintergrund\r\n        Rectangle2D bg = new Rectangle2D.Double(0, 0, PANEL_WIDTH, PANEL_HEIGHT);\r\n        background = new ColoredShape(bg, fieldColor, true);\r\n        // Spielfeld-Linien\r\n        BasicStroke lineStroke = new BasicStroke(LINE_THICKNESS);\r\n        int fieldWidth = PANEL_WIDTH - 2 * SPACE;\r\n        Rectangle2D aussen = new Rectangle2D.Double(SPACE, SPACE, fieldWidth, fieldWidth);\r\n        fieldLinesShapes.add(new ColoredShape(aussen, lineColor, false, lineStroke));\r\n        Line2D aussenLinie = new Line2D.Double(SPACE, fieldWidth + SPACE, SPACE, PANEL_HEIGHT);\r\n        fieldLinesShapes.add(new ColoredShape(aussenLinie, lineColor, false, lineStroke));\r\n        aussenLinie = new Line2D.Double(PANEL_WIDTH - SPACE, fieldWidth + SPACE, PANEL_WIDTH - SPACE, PANEL_HEIGHT);\r\n        fieldLinesShapes.add(new ColoredShape(aussenLinie, lineColor, false, lineStroke));\r\n        int x_center = (PANEL_WIDTH) / 2;\r\n        // Relative Torbreite berechnen\r\n        float relation = (float) GOAL_WIDTH / FIELD_WIDTH;\r\n        int goalWidth = (int) ((fieldWidth) * relation);\r\n        int x_goalStart = x_center - goalWidth / 2;\r\n        goal = new Rectangle2D.Double(x_goalStart, 10, goalWidth, 30);\r\n        rechterPfosten = new Point2D.Double(x_goalStart, SPACE);\r\n        linkerPfosten = new Point2D.Double(x_goalStart + goalWidth, SPACE);\r\n        fieldLinesShapes.add(new ColoredShape(goal, lineColor, false, lineStroke));\r\n        // 6-Meter zeichnen\r\n        relation = (float) SIX_METER / FIELD_WIDTH;\r\n        int radius = (int) ((fieldWidth) * relation);\r\n        sixMeterPixel = radius;\r\n        Arc2D viertel = new Arc2D.Double(x_goalStart - radius, -radius + SPACE, 2 * radius, 2 * radius, 180, 90, Arc2D.OPEN);\r\n        fieldLinesShapes.add(new ColoredShape(viertel, lineColor, false, lineStroke));\r\n        Line2D line = new Line2D.Double(x_goalStart, SPACE + radius, x_goalStart + goalWidth, SPACE + radius);\r\n        fieldLinesShapes.add(new ColoredShape(line, lineColor, false, lineStroke));\r\n        viertel = new Arc2D.Double(x_goalStart + goalWidth - radius, -radius + SPACE, 2 * radius, 2 * radius, 270, 90, Arc2D.OPEN);\r\n        fieldLinesShapes.add(new ColoredShape(viertel, lineColor, false, lineStroke));\r\n        // 9-Meter zeichen\r\n        float[] dash = { 10.0f };\r\n        BasicStroke dashed = new BasicStroke(3.0f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0f, dash, 0.0f);\r\n        relation = (float) NINE_METER / FIELD_WIDTH;\r\n        radius = (int) ((fieldWidth) * relation);\r\n        // Neun-Meter wird keine 90 Grad gezeichent\r\n        double diff = Math.acos((fieldWidth / 2 - goalWidth / 2) / (float) radius);\r\n        double degress = Math.toDegrees(diff);\r\n        viertel = new Arc2D.Double(x_goalStart - radius, -radius + SPACE, 2 * radius, 2 * radius, 180 + degress, 90 - degress, Arc2D.OPEN);\r\n        fieldLinesShapes.add(new ColoredShape(viertel, lineColor, false, dashed));\r\n        line = new Line2D.Double(x_goalStart, SPACE + radius, x_goalStart + goalWidth, SPACE + radius);\r\n        fieldLinesShapes.add(new ColoredShape(line, lineColor, false, dashed));\r\n        viertel = new Arc2D.Double(x_goalStart + goalWidth - radius, -radius + SPACE, 2 * radius, 2 * radius, 270, 90 - degress, Arc2D.OPEN);\r\n        fieldLinesShapes.add(new ColoredShape(viertel, lineColor, false, dashed));\r\n    }\r\n\r\n    public void draw(Graphics2D g2d) {\r\n        Color tempColor = g2d.getColor();\r\n        Stroke tempStroke = g2d.getStroke();\r\n        background.drawShape(g2d);\r\n        for (ColoredShape shape : fieldLinesShapes) {\r\n            shape.drawShape(g2d);\r\n        }\r\n        g2d.setColor(tempColor);\r\n        g2d.setStroke(tempStroke);\r\n    }\r\n\r\n    public void updateColors(ColorModel colorModel) {\r\n        background.setColor(colorModel.getFieldColor());\r\n        for (ColoredShape shape : fieldLinesShapes) {\r\n            shape.setColor(colorModel.getLineColor());\r\n        }\r\n    }\r\n\r\n    public boolean insideGoal(int x, int y) {\r\n        return goal.contains(x, y);\r\n    }\r\n\r\n    public Point getGoalMiddle() {\r\n        return new Point((int) goal.getCenterX(), (int) goal.getCenterY());\r\n    }\r\n\r\n    public boolean insideSixMeter(int x, int y) {\r\n        if (linkerPfosten.distance(x, y) < sixMeterPixel || rechterPfosten.distance(x, y) < sixMeterPixel) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/views/FieldDrawerTest0.java",
		"test_prompt": "// FieldDrawerTest0.java\npackage visu.handball.moves.views;\n\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Graphics2D;\nimport java.awt.Point;\nimport java.awt.Stroke;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.ArrayList;\nimport java.util.List;\nimport visu.handball.moves.model.ColorModel;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FieldDrawer}.\n* It contains ten unit test cases for the {@link FieldDrawer#insideGoal(int, int)} method.\n*/\nclass FieldDrawerTest0 {"
	},
	{
		"original_code": "// FieldDrawer.java\n/*\r\n * Created on 02.10.2006\r\n * Created by Richard Doerfler, Thomas Halm\r\n * Copyright (C) 2006  Richard Doerfler, Thomas Halm\r\n *\r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n */\r\npackage visu.handball.moves.views;\r\n\r\nimport java.awt.BasicStroke;\r\nimport java.awt.Color;\r\nimport java.awt.Graphics2D;\r\nimport java.awt.Point;\r\nimport java.awt.Stroke;\r\nimport java.awt.geom.Arc2D;\r\nimport java.awt.geom.Line2D;\r\nimport java.awt.geom.Point2D;\r\nimport java.awt.geom.Rectangle2D;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport visu.handball.moves.model.ColorModel;\r\n\r\npublic class FieldDrawer {\r\n\r\n    /*\r\n\t * absolute Groesse des Panels\r\n\t */\r\n    public static final int PANEL_WIDTH = 500;\r\n\r\n    public static final int PANEL_HEIGHT = 550;\r\n\r\n    /*\r\n\t * Maße einer Handball-Spielfeld-Haelfte (relativ)\r\n\t */\r\n    private static final int FIELD_WIDTH = 20;\r\n\r\n    private static final int GOAL_WIDTH = 3;\r\n\r\n    private static final int SIX_METER = 6;\r\n\r\n    private static final int NINE_METER = 9;\r\n\r\n    private static final int SPACE = 40;\r\n\r\n    private static final int LINE_THICKNESS = 10;\r\n\r\n    private List<ColoredShape> fieldLinesShapes;\r\n\r\n    private ColoredShape background;\r\n\r\n    private Rectangle2D goal;\r\n\r\n    private Point2D linkerPfosten;\r\n\r\n    private Point2D rechterPfosten;\r\n\r\n    private double sixMeterPixel;\r\n\r\n    public FieldDrawer(ColorModel colorModel) {\r\n        createFieldShapes(colorModel);\r\n    }\r\n\r\n    private void createFieldShapes(ColorModel colorModel) {\r\n        Color fieldColor = colorModel.getFieldColor();\r\n        Color lineColor = colorModel.getLineColor();\r\n        fieldLinesShapes = new ArrayList<ColoredShape>();\r\n        // Spielfeld-Hintergrund\r\n        Rectangle2D bg = new Rectangle2D.Double(0, 0, PANEL_WIDTH, PANEL_HEIGHT);\r\n        background = new ColoredShape(bg, fieldColor, true);\r\n        // Spielfeld-Linien\r\n        BasicStroke lineStroke = new BasicStroke(LINE_THICKNESS);\r\n        int fieldWidth = PANEL_WIDTH - 2 * SPACE;\r\n        Rectangle2D aussen = new Rectangle2D.Double(SPACE, SPACE, fieldWidth, fieldWidth);\r\n        fieldLinesShapes.add(new ColoredShape(aussen, lineColor, false, lineStroke));\r\n        Line2D aussenLinie = new Line2D.Double(SPACE, fieldWidth + SPACE, SPACE, PANEL_HEIGHT);\r\n        fieldLinesShapes.add(new ColoredShape(aussenLinie, lineColor, false, lineStroke));\r\n        aussenLinie = new Line2D.Double(PANEL_WIDTH - SPACE, fieldWidth + SPACE, PANEL_WIDTH - SPACE, PANEL_HEIGHT);\r\n        fieldLinesShapes.add(new ColoredShape(aussenLinie, lineColor, false, lineStroke));\r\n        int x_center = (PANEL_WIDTH) / 2;\r\n        // Relative Torbreite berechnen\r\n        float relation = (float) GOAL_WIDTH / FIELD_WIDTH;\r\n        int goalWidth = (int) ((fieldWidth) * relation);\r\n        int x_goalStart = x_center - goalWidth / 2;\r\n        goal = new Rectangle2D.Double(x_goalStart, 10, goalWidth, 30);\r\n        rechterPfosten = new Point2D.Double(x_goalStart, SPACE);\r\n        linkerPfosten = new Point2D.Double(x_goalStart + goalWidth, SPACE);\r\n        fieldLinesShapes.add(new ColoredShape(goal, lineColor, false, lineStroke));\r\n        // 6-Meter zeichnen\r\n        relation = (float) SIX_METER / FIELD_WIDTH;\r\n        int radius = (int) ((fieldWidth) * relation);\r\n        sixMeterPixel = radius;\r\n        Arc2D viertel = new Arc2D.Double(x_goalStart - radius, -radius + SPACE, 2 * radius, 2 * radius, 180, 90, Arc2D.OPEN);\r\n        fieldLinesShapes.add(new ColoredShape(viertel, lineColor, false, lineStroke));\r\n        Line2D line = new Line2D.Double(x_goalStart, SPACE + radius, x_goalStart + goalWidth, SPACE + radius);\r\n        fieldLinesShapes.add(new ColoredShape(line, lineColor, false, lineStroke));\r\n        viertel = new Arc2D.Double(x_goalStart + goalWidth - radius, -radius + SPACE, 2 * radius, 2 * radius, 270, 90, Arc2D.OPEN);\r\n        fieldLinesShapes.add(new ColoredShape(viertel, lineColor, false, lineStroke));\r\n        // 9-Meter zeichen\r\n        float[] dash = { 10.0f };\r\n        BasicStroke dashed = new BasicStroke(3.0f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0f, dash, 0.0f);\r\n        relation = (float) NINE_METER / FIELD_WIDTH;\r\n        radius = (int) ((fieldWidth) * relation);\r\n        // Neun-Meter wird keine 90 Grad gezeichent\r\n        double diff = Math.acos((fieldWidth / 2 - goalWidth / 2) / (float) radius);\r\n        double degress = Math.toDegrees(diff);\r\n        viertel = new Arc2D.Double(x_goalStart - radius, -radius + SPACE, 2 * radius, 2 * radius, 180 + degress, 90 - degress, Arc2D.OPEN);\r\n        fieldLinesShapes.add(new ColoredShape(viertel, lineColor, false, dashed));\r\n        line = new Line2D.Double(x_goalStart, SPACE + radius, x_goalStart + goalWidth, SPACE + radius);\r\n        fieldLinesShapes.add(new ColoredShape(line, lineColor, false, dashed));\r\n        viertel = new Arc2D.Double(x_goalStart + goalWidth - radius, -radius + SPACE, 2 * radius, 2 * radius, 270, 90 - degress, Arc2D.OPEN);\r\n        fieldLinesShapes.add(new ColoredShape(viertel, lineColor, false, dashed));\r\n    }\r\n\r\n    public void draw(Graphics2D g2d) {\r\n        Color tempColor = g2d.getColor();\r\n        Stroke tempStroke = g2d.getStroke();\r\n        background.drawShape(g2d);\r\n        for (ColoredShape shape : fieldLinesShapes) {\r\n            shape.drawShape(g2d);\r\n        }\r\n        g2d.setColor(tempColor);\r\n        g2d.setStroke(tempStroke);\r\n    }\r\n\r\n    public void updateColors(ColorModel colorModel) {\r\n        background.setColor(colorModel.getFieldColor());\r\n        for (ColoredShape shape : fieldLinesShapes) {\r\n            shape.setColor(colorModel.getLineColor());\r\n        }\r\n    }\r\n\r\n    public boolean insideGoal(int x, int y) {\r\n        return goal.contains(x, y);\r\n    }\r\n\r\n    public Point getGoalMiddle() {\r\n        return new Point((int) goal.getCenterX(), (int) goal.getCenterY());\r\n    }\r\n\r\n    public boolean insideSixMeter(int x, int y) {\r\n        if (linkerPfosten.distance(x, y) < sixMeterPixel || rechterPfosten.distance(x, y) < sixMeterPixel) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/56_jhandballmoves/src/main/java/visu/handball/moves/views/FieldDrawerTest1.java",
		"test_prompt": "// FieldDrawerTest1.java\npackage visu.handball.moves.views;\n\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Graphics2D;\nimport java.awt.Point;\nimport java.awt.Stroke;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.ArrayList;\nimport java.util.List;\nimport visu.handball.moves.model.ColorModel;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FieldDrawer}.\n* It contains ten unit test cases for the {@link FieldDrawer#insideSixMeter(int, int)} method.\n*/\nclass FieldDrawerTest1 {"
	}
]