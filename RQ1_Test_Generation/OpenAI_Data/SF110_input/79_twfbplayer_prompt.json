[
	{
		"original_code": "// CombatantStatistic.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\n\n/**\n * A statistic for combatants\n *\n * TODO use separate classes for calculating and storing the statistics, so\n * statistics i.e. can be serialized\n *\n * @author daniel\n */\npublic class CombatantStatistic implements StaticStatistics {\n\n    private final int numberOfRounds;\n\n    private final Map<CombatantStatType, DataSet> allData = new HashMap<CombatantStatType, DataSet>();\n\n    /**\n     * create statistics for the given number of rounds.\n     *\n     * @param numberOfRounds\n     */\n    public CombatantStatistic(final int numberOfRounds) {\n        this.numberOfRounds = numberOfRounds;\n    }\n\n    /**\n     * @param type\n     *            what kind of data is given as value?\n     * @param side\n     *            at which the combatant of the value fights\n     * @param value\n     */\n    public void addData(final CombatantStatType type, final CombatantSide side, final int value) {\n        ensureTypExists(type);\n        final Integer storedValue;\n        // fix class, because in the data it starts at -1 but we start with 0\n        if (type == CombatantStatType.charclass) {\n            storedValue = Integer.valueOf(value + 1);\n        } else {\n            storedValue = Integer.valueOf(value);\n        }\n        allData.get(type).addData(side, storedValue);\n    }\n\n    /**\n     * @param type\n     */\n    private void ensureTypExists(final CombatantStatType type) {\n        if (!allData.containsKey(type)) {\n            allData.put(type, new DataSet());\n        }\n    }\n\n    private double aggregate(final CombatantStatType stat, final CombatantSide side, final DataAggregationType function) {\n        // some data may not be present in old logs (ie. since 1.29 charlevel\n        // and charclass were added)\n        if (!allData.containsKey(stat)) {\n            return 0;\n        }\n        final DataSet statData = allData.get(stat);\n        assert statData != null : \"data must be present!\";\n        return statData.aggregate(side, function);\n    }\n\n    private double getAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AVERAGE);\n    }\n\n    private double getSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.SUM);\n    }\n\n    private double getCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AMOUNT);\n    }\n\n    private double getPositiveAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AVERAGE);\n    }\n\n    private double getPositiveSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_SUM);\n    }\n\n    private double getPositiveCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AMOUNT);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfPlayers(final CombatantSide side) {\n        // just a stat that is available for all combatants\n        return (int) Math.round(getCount(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#survivedPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int survivedPlayers(final CombatantSide side) {\n        return (int) Math.round(getPositiveCount(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double initialHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageWeaponDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageWeaponDamage(final CombatantSide side) {\n        final DataSet allMinDamage = allData.get(CombatantStatType.weaponmindmg);\n        final DataSet allMaxDamage = allData.get(CombatantStatType.weaponmaxdmg);\n        if (allMinDamage == null || allMaxDamage == null) {\n            // TODO logging: LOG.warn(\"no weapon damage data available!\");\n            // no weapon data available\n            return 0;\n        }\n        // use double precision for calculating average\n        final double avgMinDamage = allMinDamage.aggregate(side, DataAggregationType.AVERAGE);\n        final double avgMaxDamage = allMaxDamage.aggregate(side, DataAggregationType.AVERAGE);\n        return (avgMinDamage + avgMaxDamage) / 2.0;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double causedDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.totalcauseddamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int shotsFiredWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side) + getSum(CombatantStatType.misscount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int hitsWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLifetime(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLifetime(final CombatantSide side) {\n        final int totalPlayers = (int) getCount(CombatantStatType.diedwhen, side);\n        if (totalPlayers == 0) {\n            return 0.0;\n        }\n        final int diedPlayers = (int) getPositiveCount(CombatantStatType.diedwhen, side);\n        final int survivedPlayers = totalPlayers - diedPlayers;\n        final double diedInRound = getPositiveAverage(CombatantStatType.diedwhen, side);\n        return (diedPlayers * diedInRound + survivedPlayers * numberOfRounds) / totalPlayers;\n    }\n\n    private int numberOfClass(final CharacterClass charClass, final CombatantSide side) {\n        final DataSet data = allData.get(CombatantStatType.charclass);\n        // only available since v1.29\n        if (data == null) {\n            return 0;\n        }\n        final Integer value = Integer.valueOf(charClass.ordinal());\n        return data.countOfValuesWith(value, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfAdventurers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfAdventurers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.ADVENTURER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfDuelants(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfDuelants(final CombatantSide side) {\n        return numberOfClass(CharacterClass.DUELANT, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfGreenhorns(CombatantSide)\n     */\n    public int numberOfGreenhorns(final CombatantSide side) {\n        return numberOfClass(CharacterClass.GREENHORN, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfSoldiers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfSoldiers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.SOLDIER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfWorkers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfWorkers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.WORKER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLevel(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLevel(final CombatantSide side) {\n        return getAverage(CombatantStatType.charlevel, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int initialHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getPositiveAverage(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getPositiveSum(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int causedDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.totalcauseddamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double shotsFiredPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side) + getAverage(CombatantStatType.misscount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double hitsPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double takenDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.takendamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int takenDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.takendamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageHitDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageHitDamage(final CombatantSide side) {\n        // don't count the misses\n        final double teamHits = hitsWholeSide(side);\n        if (teamHits == 0) {\n            return 0;\n        }\n        final double teamDamage = causedDamageWholeSide(side);\n        final double totalCalculated = teamDamage / teamHits;\n        return totalCalculated;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double dodgesPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.dodgecount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int dodgesWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.dodgecount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistribution(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Number> healthDistribution(final CombatantSide side) {\n        // initialize map\n        final SortedMap<Number, Number> result = new TreeMap<Number, Number>();\n        final int maxHP = 14000;\n        final int step = 1000;\n        for (int limit = step; limit <= maxHP; limit += step) {\n            result.put(Integer.valueOf(limit), new AtomicInteger());\n        }\n        // fill with values\n        final CombatantStatType stat = CombatantStatType.starthp;\n        if (allData.containsKey(stat)) {\n            final DataSet statData = allData.get(stat);\n            final List<Integer> data = statData.getSideData(side);\n            for (final Integer value : data) {\n                Number key = getUpperLimit(value.intValue(), step);\n                if (!result.containsKey(key)) {\n                    // out of range, put it to the last value\n                    key = result.lastKey();\n                }\n                ((AtomicInteger) result.get(key)).incrementAndGet();\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistributionRelative(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Double> healthDistributionRelative(final CombatantSide side) {\n        final SortedMap<Number, Number> distribution = healthDistribution(side);\n        final TreeMap<Number, Double> result = new TreeMap<Number, Double>();\n        final double totalPlayers = numberOfPlayers(side);\n        for (final Entry<Number, Number> mapping : distribution.entrySet()) {\n            final double currentPlayers = mapping.getValue().doubleValue();\n            final Double percentage = Double.valueOf(currentPlayers / totalPlayers * 100.0);\n            result.put(mapping.getKey(), percentage);\n        }\n        return result;\n    }\n\n    /**\n     * @param value\n     * @param step\n     * @return\n     */\n    private Number getUpperLimit(final int value, final int step) {\n        int limit = 0;\n        while (value > limit) {\n            limit += step;\n        }\n        return Integer.valueOf(limit);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/CombatantStatistic_0Test.java",
		"test_prompt": "// CombatantStatistic_0Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CombatantStatistic}.\n* It contains ten unit test cases for the {@link CombatantStatistic#numberOfPlayers(CombatantSide)} method.\n*/\nclass CombatantStatistic_0Test {"
	},
	{
		"original_code": "// CombatantStatistic.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\n\n/**\n * A statistic for combatants\n *\n * TODO use separate classes for calculating and storing the statistics, so\n * statistics i.e. can be serialized\n *\n * @author daniel\n */\npublic class CombatantStatistic implements StaticStatistics {\n\n    private final int numberOfRounds;\n\n    private final Map<CombatantStatType, DataSet> allData = new HashMap<CombatantStatType, DataSet>();\n\n    /**\n     * create statistics for the given number of rounds.\n     *\n     * @param numberOfRounds\n     */\n    public CombatantStatistic(final int numberOfRounds) {\n        this.numberOfRounds = numberOfRounds;\n    }\n\n    /**\n     * @param type\n     *            what kind of data is given as value?\n     * @param side\n     *            at which the combatant of the value fights\n     * @param value\n     */\n    public void addData(final CombatantStatType type, final CombatantSide side, final int value) {\n        ensureTypExists(type);\n        final Integer storedValue;\n        // fix class, because in the data it starts at -1 but we start with 0\n        if (type == CombatantStatType.charclass) {\n            storedValue = Integer.valueOf(value + 1);\n        } else {\n            storedValue = Integer.valueOf(value);\n        }\n        allData.get(type).addData(side, storedValue);\n    }\n\n    /**\n     * @param type\n     */\n    private void ensureTypExists(final CombatantStatType type) {\n        if (!allData.containsKey(type)) {\n            allData.put(type, new DataSet());\n        }\n    }\n\n    private double aggregate(final CombatantStatType stat, final CombatantSide side, final DataAggregationType function) {\n        // some data may not be present in old logs (ie. since 1.29 charlevel\n        // and charclass were added)\n        if (!allData.containsKey(stat)) {\n            return 0;\n        }\n        final DataSet statData = allData.get(stat);\n        assert statData != null : \"data must be present!\";\n        return statData.aggregate(side, function);\n    }\n\n    private double getAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AVERAGE);\n    }\n\n    private double getSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.SUM);\n    }\n\n    private double getCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AMOUNT);\n    }\n\n    private double getPositiveAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AVERAGE);\n    }\n\n    private double getPositiveSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_SUM);\n    }\n\n    private double getPositiveCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AMOUNT);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfPlayers(final CombatantSide side) {\n        // just a stat that is available for all combatants\n        return (int) Math.round(getCount(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#survivedPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int survivedPlayers(final CombatantSide side) {\n        return (int) Math.round(getPositiveCount(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double initialHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageWeaponDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageWeaponDamage(final CombatantSide side) {\n        final DataSet allMinDamage = allData.get(CombatantStatType.weaponmindmg);\n        final DataSet allMaxDamage = allData.get(CombatantStatType.weaponmaxdmg);\n        if (allMinDamage == null || allMaxDamage == null) {\n            // TODO logging: LOG.warn(\"no weapon damage data available!\");\n            // no weapon data available\n            return 0;\n        }\n        // use double precision for calculating average\n        final double avgMinDamage = allMinDamage.aggregate(side, DataAggregationType.AVERAGE);\n        final double avgMaxDamage = allMaxDamage.aggregate(side, DataAggregationType.AVERAGE);\n        return (avgMinDamage + avgMaxDamage) / 2.0;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double causedDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.totalcauseddamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int shotsFiredWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side) + getSum(CombatantStatType.misscount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int hitsWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLifetime(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLifetime(final CombatantSide side) {\n        final int totalPlayers = (int) getCount(CombatantStatType.diedwhen, side);\n        if (totalPlayers == 0) {\n            return 0.0;\n        }\n        final int diedPlayers = (int) getPositiveCount(CombatantStatType.diedwhen, side);\n        final int survivedPlayers = totalPlayers - diedPlayers;\n        final double diedInRound = getPositiveAverage(CombatantStatType.diedwhen, side);\n        return (diedPlayers * diedInRound + survivedPlayers * numberOfRounds) / totalPlayers;\n    }\n\n    private int numberOfClass(final CharacterClass charClass, final CombatantSide side) {\n        final DataSet data = allData.get(CombatantStatType.charclass);\n        // only available since v1.29\n        if (data == null) {\n            return 0;\n        }\n        final Integer value = Integer.valueOf(charClass.ordinal());\n        return data.countOfValuesWith(value, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfAdventurers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfAdventurers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.ADVENTURER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfDuelants(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfDuelants(final CombatantSide side) {\n        return numberOfClass(CharacterClass.DUELANT, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfGreenhorns(CombatantSide)\n     */\n    public int numberOfGreenhorns(final CombatantSide side) {\n        return numberOfClass(CharacterClass.GREENHORN, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfSoldiers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfSoldiers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.SOLDIER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfWorkers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfWorkers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.WORKER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLevel(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLevel(final CombatantSide side) {\n        return getAverage(CombatantStatType.charlevel, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int initialHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getPositiveAverage(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getPositiveSum(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int causedDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.totalcauseddamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double shotsFiredPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side) + getAverage(CombatantStatType.misscount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double hitsPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double takenDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.takendamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int takenDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.takendamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageHitDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageHitDamage(final CombatantSide side) {\n        // don't count the misses\n        final double teamHits = hitsWholeSide(side);\n        if (teamHits == 0) {\n            return 0;\n        }\n        final double teamDamage = causedDamageWholeSide(side);\n        final double totalCalculated = teamDamage / teamHits;\n        return totalCalculated;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double dodgesPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.dodgecount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int dodgesWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.dodgecount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistribution(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Number> healthDistribution(final CombatantSide side) {\n        // initialize map\n        final SortedMap<Number, Number> result = new TreeMap<Number, Number>();\n        final int maxHP = 14000;\n        final int step = 1000;\n        for (int limit = step; limit <= maxHP; limit += step) {\n            result.put(Integer.valueOf(limit), new AtomicInteger());\n        }\n        // fill with values\n        final CombatantStatType stat = CombatantStatType.starthp;\n        if (allData.containsKey(stat)) {\n            final DataSet statData = allData.get(stat);\n            final List<Integer> data = statData.getSideData(side);\n            for (final Integer value : data) {\n                Number key = getUpperLimit(value.intValue(), step);\n                if (!result.containsKey(key)) {\n                    // out of range, put it to the last value\n                    key = result.lastKey();\n                }\n                ((AtomicInteger) result.get(key)).incrementAndGet();\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistributionRelative(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Double> healthDistributionRelative(final CombatantSide side) {\n        final SortedMap<Number, Number> distribution = healthDistribution(side);\n        final TreeMap<Number, Double> result = new TreeMap<Number, Double>();\n        final double totalPlayers = numberOfPlayers(side);\n        for (final Entry<Number, Number> mapping : distribution.entrySet()) {\n            final double currentPlayers = mapping.getValue().doubleValue();\n            final Double percentage = Double.valueOf(currentPlayers / totalPlayers * 100.0);\n            result.put(mapping.getKey(), percentage);\n        }\n        return result;\n    }\n\n    /**\n     * @param value\n     * @param step\n     * @return\n     */\n    private Number getUpperLimit(final int value, final int step) {\n        int limit = 0;\n        while (value > limit) {\n            limit += step;\n        }\n        return Integer.valueOf(limit);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/CombatantStatistic_1Test.java",
		"test_prompt": "// CombatantStatistic_1Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CombatantStatistic}.\n* It contains ten unit test cases for the {@link CombatantStatistic#survivedPlayers(CombatantSide)} method.\n*/\nclass CombatantStatistic_1Test {"
	},
	{
		"original_code": "// CombatantStatistic.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\n\n/**\n * A statistic for combatants\n *\n * TODO use separate classes for calculating and storing the statistics, so\n * statistics i.e. can be serialized\n *\n * @author daniel\n */\npublic class CombatantStatistic implements StaticStatistics {\n\n    private final int numberOfRounds;\n\n    private final Map<CombatantStatType, DataSet> allData = new HashMap<CombatantStatType, DataSet>();\n\n    /**\n     * create statistics for the given number of rounds.\n     *\n     * @param numberOfRounds\n     */\n    public CombatantStatistic(final int numberOfRounds) {\n        this.numberOfRounds = numberOfRounds;\n    }\n\n    /**\n     * @param type\n     *            what kind of data is given as value?\n     * @param side\n     *            at which the combatant of the value fights\n     * @param value\n     */\n    public void addData(final CombatantStatType type, final CombatantSide side, final int value) {\n        ensureTypExists(type);\n        final Integer storedValue;\n        // fix class, because in the data it starts at -1 but we start with 0\n        if (type == CombatantStatType.charclass) {\n            storedValue = Integer.valueOf(value + 1);\n        } else {\n            storedValue = Integer.valueOf(value);\n        }\n        allData.get(type).addData(side, storedValue);\n    }\n\n    /**\n     * @param type\n     */\n    private void ensureTypExists(final CombatantStatType type) {\n        if (!allData.containsKey(type)) {\n            allData.put(type, new DataSet());\n        }\n    }\n\n    private double aggregate(final CombatantStatType stat, final CombatantSide side, final DataAggregationType function) {\n        // some data may not be present in old logs (ie. since 1.29 charlevel\n        // and charclass were added)\n        if (!allData.containsKey(stat)) {\n            return 0;\n        }\n        final DataSet statData = allData.get(stat);\n        assert statData != null : \"data must be present!\";\n        return statData.aggregate(side, function);\n    }\n\n    private double getAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AVERAGE);\n    }\n\n    private double getSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.SUM);\n    }\n\n    private double getCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AMOUNT);\n    }\n\n    private double getPositiveAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AVERAGE);\n    }\n\n    private double getPositiveSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_SUM);\n    }\n\n    private double getPositiveCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AMOUNT);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfPlayers(final CombatantSide side) {\n        // just a stat that is available for all combatants\n        return (int) Math.round(getCount(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#survivedPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int survivedPlayers(final CombatantSide side) {\n        return (int) Math.round(getPositiveCount(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double initialHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageWeaponDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageWeaponDamage(final CombatantSide side) {\n        final DataSet allMinDamage = allData.get(CombatantStatType.weaponmindmg);\n        final DataSet allMaxDamage = allData.get(CombatantStatType.weaponmaxdmg);\n        if (allMinDamage == null || allMaxDamage == null) {\n            // TODO logging: LOG.warn(\"no weapon damage data available!\");\n            // no weapon data available\n            return 0;\n        }\n        // use double precision for calculating average\n        final double avgMinDamage = allMinDamage.aggregate(side, DataAggregationType.AVERAGE);\n        final double avgMaxDamage = allMaxDamage.aggregate(side, DataAggregationType.AVERAGE);\n        return (avgMinDamage + avgMaxDamage) / 2.0;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double causedDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.totalcauseddamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int shotsFiredWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side) + getSum(CombatantStatType.misscount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int hitsWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLifetime(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLifetime(final CombatantSide side) {\n        final int totalPlayers = (int) getCount(CombatantStatType.diedwhen, side);\n        if (totalPlayers == 0) {\n            return 0.0;\n        }\n        final int diedPlayers = (int) getPositiveCount(CombatantStatType.diedwhen, side);\n        final int survivedPlayers = totalPlayers - diedPlayers;\n        final double diedInRound = getPositiveAverage(CombatantStatType.diedwhen, side);\n        return (diedPlayers * diedInRound + survivedPlayers * numberOfRounds) / totalPlayers;\n    }\n\n    private int numberOfClass(final CharacterClass charClass, final CombatantSide side) {\n        final DataSet data = allData.get(CombatantStatType.charclass);\n        // only available since v1.29\n        if (data == null) {\n            return 0;\n        }\n        final Integer value = Integer.valueOf(charClass.ordinal());\n        return data.countOfValuesWith(value, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfAdventurers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfAdventurers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.ADVENTURER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfDuelants(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfDuelants(final CombatantSide side) {\n        return numberOfClass(CharacterClass.DUELANT, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfGreenhorns(CombatantSide)\n     */\n    public int numberOfGreenhorns(final CombatantSide side) {\n        return numberOfClass(CharacterClass.GREENHORN, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfSoldiers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfSoldiers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.SOLDIER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfWorkers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfWorkers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.WORKER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLevel(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLevel(final CombatantSide side) {\n        return getAverage(CombatantStatType.charlevel, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int initialHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getPositiveAverage(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getPositiveSum(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int causedDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.totalcauseddamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double shotsFiredPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side) + getAverage(CombatantStatType.misscount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double hitsPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double takenDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.takendamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int takenDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.takendamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageHitDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageHitDamage(final CombatantSide side) {\n        // don't count the misses\n        final double teamHits = hitsWholeSide(side);\n        if (teamHits == 0) {\n            return 0;\n        }\n        final double teamDamage = causedDamageWholeSide(side);\n        final double totalCalculated = teamDamage / teamHits;\n        return totalCalculated;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double dodgesPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.dodgecount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int dodgesWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.dodgecount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistribution(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Number> healthDistribution(final CombatantSide side) {\n        // initialize map\n        final SortedMap<Number, Number> result = new TreeMap<Number, Number>();\n        final int maxHP = 14000;\n        final int step = 1000;\n        for (int limit = step; limit <= maxHP; limit += step) {\n            result.put(Integer.valueOf(limit), new AtomicInteger());\n        }\n        // fill with values\n        final CombatantStatType stat = CombatantStatType.starthp;\n        if (allData.containsKey(stat)) {\n            final DataSet statData = allData.get(stat);\n            final List<Integer> data = statData.getSideData(side);\n            for (final Integer value : data) {\n                Number key = getUpperLimit(value.intValue(), step);\n                if (!result.containsKey(key)) {\n                    // out of range, put it to the last value\n                    key = result.lastKey();\n                }\n                ((AtomicInteger) result.get(key)).incrementAndGet();\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistributionRelative(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Double> healthDistributionRelative(final CombatantSide side) {\n        final SortedMap<Number, Number> distribution = healthDistribution(side);\n        final TreeMap<Number, Double> result = new TreeMap<Number, Double>();\n        final double totalPlayers = numberOfPlayers(side);\n        for (final Entry<Number, Number> mapping : distribution.entrySet()) {\n            final double currentPlayers = mapping.getValue().doubleValue();\n            final Double percentage = Double.valueOf(currentPlayers / totalPlayers * 100.0);\n            result.put(mapping.getKey(), percentage);\n        }\n        return result;\n    }\n\n    /**\n     * @param value\n     * @param step\n     * @return\n     */\n    private Number getUpperLimit(final int value, final int step) {\n        int limit = 0;\n        while (value > limit) {\n            limit += step;\n        }\n        return Integer.valueOf(limit);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/CombatantStatistic_2Test.java",
		"test_prompt": "// CombatantStatistic_2Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CombatantStatistic}.\n* It contains ten unit test cases for the {@link CombatantStatistic#initialHealthPerPlayer(CombatantSide)} method.\n*/\nclass CombatantStatistic_2Test {"
	},
	{
		"original_code": "// CombatantStatistic.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\n\n/**\n * A statistic for combatants\n *\n * TODO use separate classes for calculating and storing the statistics, so\n * statistics i.e. can be serialized\n *\n * @author daniel\n */\npublic class CombatantStatistic implements StaticStatistics {\n\n    private final int numberOfRounds;\n\n    private final Map<CombatantStatType, DataSet> allData = new HashMap<CombatantStatType, DataSet>();\n\n    /**\n     * create statistics for the given number of rounds.\n     *\n     * @param numberOfRounds\n     */\n    public CombatantStatistic(final int numberOfRounds) {\n        this.numberOfRounds = numberOfRounds;\n    }\n\n    /**\n     * @param type\n     *            what kind of data is given as value?\n     * @param side\n     *            at which the combatant of the value fights\n     * @param value\n     */\n    public void addData(final CombatantStatType type, final CombatantSide side, final int value) {\n        ensureTypExists(type);\n        final Integer storedValue;\n        // fix class, because in the data it starts at -1 but we start with 0\n        if (type == CombatantStatType.charclass) {\n            storedValue = Integer.valueOf(value + 1);\n        } else {\n            storedValue = Integer.valueOf(value);\n        }\n        allData.get(type).addData(side, storedValue);\n    }\n\n    /**\n     * @param type\n     */\n    private void ensureTypExists(final CombatantStatType type) {\n        if (!allData.containsKey(type)) {\n            allData.put(type, new DataSet());\n        }\n    }\n\n    private double aggregate(final CombatantStatType stat, final CombatantSide side, final DataAggregationType function) {\n        // some data may not be present in old logs (ie. since 1.29 charlevel\n        // and charclass were added)\n        if (!allData.containsKey(stat)) {\n            return 0;\n        }\n        final DataSet statData = allData.get(stat);\n        assert statData != null : \"data must be present!\";\n        return statData.aggregate(side, function);\n    }\n\n    private double getAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AVERAGE);\n    }\n\n    private double getSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.SUM);\n    }\n\n    private double getCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AMOUNT);\n    }\n\n    private double getPositiveAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AVERAGE);\n    }\n\n    private double getPositiveSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_SUM);\n    }\n\n    private double getPositiveCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AMOUNT);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfPlayers(final CombatantSide side) {\n        // just a stat that is available for all combatants\n        return (int) Math.round(getCount(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#survivedPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int survivedPlayers(final CombatantSide side) {\n        return (int) Math.round(getPositiveCount(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double initialHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageWeaponDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageWeaponDamage(final CombatantSide side) {\n        final DataSet allMinDamage = allData.get(CombatantStatType.weaponmindmg);\n        final DataSet allMaxDamage = allData.get(CombatantStatType.weaponmaxdmg);\n        if (allMinDamage == null || allMaxDamage == null) {\n            // TODO logging: LOG.warn(\"no weapon damage data available!\");\n            // no weapon data available\n            return 0;\n        }\n        // use double precision for calculating average\n        final double avgMinDamage = allMinDamage.aggregate(side, DataAggregationType.AVERAGE);\n        final double avgMaxDamage = allMaxDamage.aggregate(side, DataAggregationType.AVERAGE);\n        return (avgMinDamage + avgMaxDamage) / 2.0;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double causedDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.totalcauseddamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int shotsFiredWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side) + getSum(CombatantStatType.misscount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int hitsWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLifetime(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLifetime(final CombatantSide side) {\n        final int totalPlayers = (int) getCount(CombatantStatType.diedwhen, side);\n        if (totalPlayers == 0) {\n            return 0.0;\n        }\n        final int diedPlayers = (int) getPositiveCount(CombatantStatType.diedwhen, side);\n        final int survivedPlayers = totalPlayers - diedPlayers;\n        final double diedInRound = getPositiveAverage(CombatantStatType.diedwhen, side);\n        return (diedPlayers * diedInRound + survivedPlayers * numberOfRounds) / totalPlayers;\n    }\n\n    private int numberOfClass(final CharacterClass charClass, final CombatantSide side) {\n        final DataSet data = allData.get(CombatantStatType.charclass);\n        // only available since v1.29\n        if (data == null) {\n            return 0;\n        }\n        final Integer value = Integer.valueOf(charClass.ordinal());\n        return data.countOfValuesWith(value, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfAdventurers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfAdventurers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.ADVENTURER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfDuelants(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfDuelants(final CombatantSide side) {\n        return numberOfClass(CharacterClass.DUELANT, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfGreenhorns(CombatantSide)\n     */\n    public int numberOfGreenhorns(final CombatantSide side) {\n        return numberOfClass(CharacterClass.GREENHORN, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfSoldiers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfSoldiers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.SOLDIER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfWorkers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfWorkers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.WORKER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLevel(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLevel(final CombatantSide side) {\n        return getAverage(CombatantStatType.charlevel, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int initialHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getPositiveAverage(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getPositiveSum(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int causedDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.totalcauseddamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double shotsFiredPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side) + getAverage(CombatantStatType.misscount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double hitsPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double takenDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.takendamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int takenDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.takendamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageHitDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageHitDamage(final CombatantSide side) {\n        // don't count the misses\n        final double teamHits = hitsWholeSide(side);\n        if (teamHits == 0) {\n            return 0;\n        }\n        final double teamDamage = causedDamageWholeSide(side);\n        final double totalCalculated = teamDamage / teamHits;\n        return totalCalculated;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double dodgesPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.dodgecount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int dodgesWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.dodgecount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistribution(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Number> healthDistribution(final CombatantSide side) {\n        // initialize map\n        final SortedMap<Number, Number> result = new TreeMap<Number, Number>();\n        final int maxHP = 14000;\n        final int step = 1000;\n        for (int limit = step; limit <= maxHP; limit += step) {\n            result.put(Integer.valueOf(limit), new AtomicInteger());\n        }\n        // fill with values\n        final CombatantStatType stat = CombatantStatType.starthp;\n        if (allData.containsKey(stat)) {\n            final DataSet statData = allData.get(stat);\n            final List<Integer> data = statData.getSideData(side);\n            for (final Integer value : data) {\n                Number key = getUpperLimit(value.intValue(), step);\n                if (!result.containsKey(key)) {\n                    // out of range, put it to the last value\n                    key = result.lastKey();\n                }\n                ((AtomicInteger) result.get(key)).incrementAndGet();\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistributionRelative(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Double> healthDistributionRelative(final CombatantSide side) {\n        final SortedMap<Number, Number> distribution = healthDistribution(side);\n        final TreeMap<Number, Double> result = new TreeMap<Number, Double>();\n        final double totalPlayers = numberOfPlayers(side);\n        for (final Entry<Number, Number> mapping : distribution.entrySet()) {\n            final double currentPlayers = mapping.getValue().doubleValue();\n            final Double percentage = Double.valueOf(currentPlayers / totalPlayers * 100.0);\n            result.put(mapping.getKey(), percentage);\n        }\n        return result;\n    }\n\n    /**\n     * @param value\n     * @param step\n     * @return\n     */\n    private Number getUpperLimit(final int value, final int step) {\n        int limit = 0;\n        while (value > limit) {\n            limit += step;\n        }\n        return Integer.valueOf(limit);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/CombatantStatistic_3Test.java",
		"test_prompt": "// CombatantStatistic_3Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CombatantStatistic}.\n* It contains ten unit test cases for the {@link CombatantStatistic#averageWeaponDamage(CombatantSide)} method.\n*/\nclass CombatantStatistic_3Test {"
	},
	{
		"original_code": "// CombatantStatistic.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\n\n/**\n * A statistic for combatants\n *\n * TODO use separate classes for calculating and storing the statistics, so\n * statistics i.e. can be serialized\n *\n * @author daniel\n */\npublic class CombatantStatistic implements StaticStatistics {\n\n    private final int numberOfRounds;\n\n    private final Map<CombatantStatType, DataSet> allData = new HashMap<CombatantStatType, DataSet>();\n\n    /**\n     * create statistics for the given number of rounds.\n     *\n     * @param numberOfRounds\n     */\n    public CombatantStatistic(final int numberOfRounds) {\n        this.numberOfRounds = numberOfRounds;\n    }\n\n    /**\n     * @param type\n     *            what kind of data is given as value?\n     * @param side\n     *            at which the combatant of the value fights\n     * @param value\n     */\n    public void addData(final CombatantStatType type, final CombatantSide side, final int value) {\n        ensureTypExists(type);\n        final Integer storedValue;\n        // fix class, because in the data it starts at -1 but we start with 0\n        if (type == CombatantStatType.charclass) {\n            storedValue = Integer.valueOf(value + 1);\n        } else {\n            storedValue = Integer.valueOf(value);\n        }\n        allData.get(type).addData(side, storedValue);\n    }\n\n    /**\n     * @param type\n     */\n    private void ensureTypExists(final CombatantStatType type) {\n        if (!allData.containsKey(type)) {\n            allData.put(type, new DataSet());\n        }\n    }\n\n    private double aggregate(final CombatantStatType stat, final CombatantSide side, final DataAggregationType function) {\n        // some data may not be present in old logs (ie. since 1.29 charlevel\n        // and charclass were added)\n        if (!allData.containsKey(stat)) {\n            return 0;\n        }\n        final DataSet statData = allData.get(stat);\n        assert statData != null : \"data must be present!\";\n        return statData.aggregate(side, function);\n    }\n\n    private double getAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AVERAGE);\n    }\n\n    private double getSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.SUM);\n    }\n\n    private double getCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AMOUNT);\n    }\n\n    private double getPositiveAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AVERAGE);\n    }\n\n    private double getPositiveSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_SUM);\n    }\n\n    private double getPositiveCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AMOUNT);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfPlayers(final CombatantSide side) {\n        // just a stat that is available for all combatants\n        return (int) Math.round(getCount(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#survivedPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int survivedPlayers(final CombatantSide side) {\n        return (int) Math.round(getPositiveCount(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double initialHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageWeaponDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageWeaponDamage(final CombatantSide side) {\n        final DataSet allMinDamage = allData.get(CombatantStatType.weaponmindmg);\n        final DataSet allMaxDamage = allData.get(CombatantStatType.weaponmaxdmg);\n        if (allMinDamage == null || allMaxDamage == null) {\n            // TODO logging: LOG.warn(\"no weapon damage data available!\");\n            // no weapon data available\n            return 0;\n        }\n        // use double precision for calculating average\n        final double avgMinDamage = allMinDamage.aggregate(side, DataAggregationType.AVERAGE);\n        final double avgMaxDamage = allMaxDamage.aggregate(side, DataAggregationType.AVERAGE);\n        return (avgMinDamage + avgMaxDamage) / 2.0;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double causedDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.totalcauseddamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int shotsFiredWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side) + getSum(CombatantStatType.misscount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int hitsWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLifetime(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLifetime(final CombatantSide side) {\n        final int totalPlayers = (int) getCount(CombatantStatType.diedwhen, side);\n        if (totalPlayers == 0) {\n            return 0.0;\n        }\n        final int diedPlayers = (int) getPositiveCount(CombatantStatType.diedwhen, side);\n        final int survivedPlayers = totalPlayers - diedPlayers;\n        final double diedInRound = getPositiveAverage(CombatantStatType.diedwhen, side);\n        return (diedPlayers * diedInRound + survivedPlayers * numberOfRounds) / totalPlayers;\n    }\n\n    private int numberOfClass(final CharacterClass charClass, final CombatantSide side) {\n        final DataSet data = allData.get(CombatantStatType.charclass);\n        // only available since v1.29\n        if (data == null) {\n            return 0;\n        }\n        final Integer value = Integer.valueOf(charClass.ordinal());\n        return data.countOfValuesWith(value, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfAdventurers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfAdventurers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.ADVENTURER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfDuelants(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfDuelants(final CombatantSide side) {\n        return numberOfClass(CharacterClass.DUELANT, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfGreenhorns(CombatantSide)\n     */\n    public int numberOfGreenhorns(final CombatantSide side) {\n        return numberOfClass(CharacterClass.GREENHORN, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfSoldiers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfSoldiers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.SOLDIER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfWorkers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfWorkers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.WORKER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLevel(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLevel(final CombatantSide side) {\n        return getAverage(CombatantStatType.charlevel, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int initialHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getPositiveAverage(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getPositiveSum(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int causedDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.totalcauseddamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double shotsFiredPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side) + getAverage(CombatantStatType.misscount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double hitsPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double takenDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.takendamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int takenDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.takendamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageHitDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageHitDamage(final CombatantSide side) {\n        // don't count the misses\n        final double teamHits = hitsWholeSide(side);\n        if (teamHits == 0) {\n            return 0;\n        }\n        final double teamDamage = causedDamageWholeSide(side);\n        final double totalCalculated = teamDamage / teamHits;\n        return totalCalculated;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double dodgesPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.dodgecount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int dodgesWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.dodgecount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistribution(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Number> healthDistribution(final CombatantSide side) {\n        // initialize map\n        final SortedMap<Number, Number> result = new TreeMap<Number, Number>();\n        final int maxHP = 14000;\n        final int step = 1000;\n        for (int limit = step; limit <= maxHP; limit += step) {\n            result.put(Integer.valueOf(limit), new AtomicInteger());\n        }\n        // fill with values\n        final CombatantStatType stat = CombatantStatType.starthp;\n        if (allData.containsKey(stat)) {\n            final DataSet statData = allData.get(stat);\n            final List<Integer> data = statData.getSideData(side);\n            for (final Integer value : data) {\n                Number key = getUpperLimit(value.intValue(), step);\n                if (!result.containsKey(key)) {\n                    // out of range, put it to the last value\n                    key = result.lastKey();\n                }\n                ((AtomicInteger) result.get(key)).incrementAndGet();\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistributionRelative(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Double> healthDistributionRelative(final CombatantSide side) {\n        final SortedMap<Number, Number> distribution = healthDistribution(side);\n        final TreeMap<Number, Double> result = new TreeMap<Number, Double>();\n        final double totalPlayers = numberOfPlayers(side);\n        for (final Entry<Number, Number> mapping : distribution.entrySet()) {\n            final double currentPlayers = mapping.getValue().doubleValue();\n            final Double percentage = Double.valueOf(currentPlayers / totalPlayers * 100.0);\n            result.put(mapping.getKey(), percentage);\n        }\n        return result;\n    }\n\n    /**\n     * @param value\n     * @param step\n     * @return\n     */\n    private Number getUpperLimit(final int value, final int step) {\n        int limit = 0;\n        while (value > limit) {\n            limit += step;\n        }\n        return Integer.valueOf(limit);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/CombatantStatistic_4Test.java",
		"test_prompt": "// CombatantStatistic_4Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CombatantStatistic}.\n* It contains ten unit test cases for the {@link CombatantStatistic#causedDamagePerPlayer(CombatantSide)} method.\n*/\nclass CombatantStatistic_4Test {"
	},
	{
		"original_code": "// CombatantStatistic.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\n\n/**\n * A statistic for combatants\n *\n * TODO use separate classes for calculating and storing the statistics, so\n * statistics i.e. can be serialized\n *\n * @author daniel\n */\npublic class CombatantStatistic implements StaticStatistics {\n\n    private final int numberOfRounds;\n\n    private final Map<CombatantStatType, DataSet> allData = new HashMap<CombatantStatType, DataSet>();\n\n    /**\n     * create statistics for the given number of rounds.\n     *\n     * @param numberOfRounds\n     */\n    public CombatantStatistic(final int numberOfRounds) {\n        this.numberOfRounds = numberOfRounds;\n    }\n\n    /**\n     * @param type\n     *            what kind of data is given as value?\n     * @param side\n     *            at which the combatant of the value fights\n     * @param value\n     */\n    public void addData(final CombatantStatType type, final CombatantSide side, final int value) {\n        ensureTypExists(type);\n        final Integer storedValue;\n        // fix class, because in the data it starts at -1 but we start with 0\n        if (type == CombatantStatType.charclass) {\n            storedValue = Integer.valueOf(value + 1);\n        } else {\n            storedValue = Integer.valueOf(value);\n        }\n        allData.get(type).addData(side, storedValue);\n    }\n\n    /**\n     * @param type\n     */\n    private void ensureTypExists(final CombatantStatType type) {\n        if (!allData.containsKey(type)) {\n            allData.put(type, new DataSet());\n        }\n    }\n\n    private double aggregate(final CombatantStatType stat, final CombatantSide side, final DataAggregationType function) {\n        // some data may not be present in old logs (ie. since 1.29 charlevel\n        // and charclass were added)\n        if (!allData.containsKey(stat)) {\n            return 0;\n        }\n        final DataSet statData = allData.get(stat);\n        assert statData != null : \"data must be present!\";\n        return statData.aggregate(side, function);\n    }\n\n    private double getAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AVERAGE);\n    }\n\n    private double getSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.SUM);\n    }\n\n    private double getCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AMOUNT);\n    }\n\n    private double getPositiveAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AVERAGE);\n    }\n\n    private double getPositiveSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_SUM);\n    }\n\n    private double getPositiveCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AMOUNT);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfPlayers(final CombatantSide side) {\n        // just a stat that is available for all combatants\n        return (int) Math.round(getCount(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#survivedPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int survivedPlayers(final CombatantSide side) {\n        return (int) Math.round(getPositiveCount(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double initialHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageWeaponDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageWeaponDamage(final CombatantSide side) {\n        final DataSet allMinDamage = allData.get(CombatantStatType.weaponmindmg);\n        final DataSet allMaxDamage = allData.get(CombatantStatType.weaponmaxdmg);\n        if (allMinDamage == null || allMaxDamage == null) {\n            // TODO logging: LOG.warn(\"no weapon damage data available!\");\n            // no weapon data available\n            return 0;\n        }\n        // use double precision for calculating average\n        final double avgMinDamage = allMinDamage.aggregate(side, DataAggregationType.AVERAGE);\n        final double avgMaxDamage = allMaxDamage.aggregate(side, DataAggregationType.AVERAGE);\n        return (avgMinDamage + avgMaxDamage) / 2.0;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double causedDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.totalcauseddamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int shotsFiredWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side) + getSum(CombatantStatType.misscount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int hitsWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLifetime(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLifetime(final CombatantSide side) {\n        final int totalPlayers = (int) getCount(CombatantStatType.diedwhen, side);\n        if (totalPlayers == 0) {\n            return 0.0;\n        }\n        final int diedPlayers = (int) getPositiveCount(CombatantStatType.diedwhen, side);\n        final int survivedPlayers = totalPlayers - diedPlayers;\n        final double diedInRound = getPositiveAverage(CombatantStatType.diedwhen, side);\n        return (diedPlayers * diedInRound + survivedPlayers * numberOfRounds) / totalPlayers;\n    }\n\n    private int numberOfClass(final CharacterClass charClass, final CombatantSide side) {\n        final DataSet data = allData.get(CombatantStatType.charclass);\n        // only available since v1.29\n        if (data == null) {\n            return 0;\n        }\n        final Integer value = Integer.valueOf(charClass.ordinal());\n        return data.countOfValuesWith(value, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfAdventurers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfAdventurers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.ADVENTURER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfDuelants(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfDuelants(final CombatantSide side) {\n        return numberOfClass(CharacterClass.DUELANT, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfGreenhorns(CombatantSide)\n     */\n    public int numberOfGreenhorns(final CombatantSide side) {\n        return numberOfClass(CharacterClass.GREENHORN, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfSoldiers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfSoldiers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.SOLDIER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfWorkers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfWorkers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.WORKER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLevel(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLevel(final CombatantSide side) {\n        return getAverage(CombatantStatType.charlevel, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int initialHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getPositiveAverage(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getPositiveSum(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int causedDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.totalcauseddamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double shotsFiredPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side) + getAverage(CombatantStatType.misscount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double hitsPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double takenDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.takendamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int takenDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.takendamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageHitDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageHitDamage(final CombatantSide side) {\n        // don't count the misses\n        final double teamHits = hitsWholeSide(side);\n        if (teamHits == 0) {\n            return 0;\n        }\n        final double teamDamage = causedDamageWholeSide(side);\n        final double totalCalculated = teamDamage / teamHits;\n        return totalCalculated;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double dodgesPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.dodgecount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int dodgesWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.dodgecount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistribution(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Number> healthDistribution(final CombatantSide side) {\n        // initialize map\n        final SortedMap<Number, Number> result = new TreeMap<Number, Number>();\n        final int maxHP = 14000;\n        final int step = 1000;\n        for (int limit = step; limit <= maxHP; limit += step) {\n            result.put(Integer.valueOf(limit), new AtomicInteger());\n        }\n        // fill with values\n        final CombatantStatType stat = CombatantStatType.starthp;\n        if (allData.containsKey(stat)) {\n            final DataSet statData = allData.get(stat);\n            final List<Integer> data = statData.getSideData(side);\n            for (final Integer value : data) {\n                Number key = getUpperLimit(value.intValue(), step);\n                if (!result.containsKey(key)) {\n                    // out of range, put it to the last value\n                    key = result.lastKey();\n                }\n                ((AtomicInteger) result.get(key)).incrementAndGet();\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistributionRelative(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Double> healthDistributionRelative(final CombatantSide side) {\n        final SortedMap<Number, Number> distribution = healthDistribution(side);\n        final TreeMap<Number, Double> result = new TreeMap<Number, Double>();\n        final double totalPlayers = numberOfPlayers(side);\n        for (final Entry<Number, Number> mapping : distribution.entrySet()) {\n            final double currentPlayers = mapping.getValue().doubleValue();\n            final Double percentage = Double.valueOf(currentPlayers / totalPlayers * 100.0);\n            result.put(mapping.getKey(), percentage);\n        }\n        return result;\n    }\n\n    /**\n     * @param value\n     * @param step\n     * @return\n     */\n    private Number getUpperLimit(final int value, final int step) {\n        int limit = 0;\n        while (value > limit) {\n            limit += step;\n        }\n        return Integer.valueOf(limit);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/CombatantStatistic_5Test.java",
		"test_prompt": "// CombatantStatistic_5Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CombatantStatistic}.\n* It contains ten unit test cases for the {@link CombatantStatistic#shotsFiredWholeSide(CombatantSide)} method.\n*/\nclass CombatantStatistic_5Test {"
	},
	{
		"original_code": "// CombatantStatistic.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\n\n/**\n * A statistic for combatants\n *\n * TODO use separate classes for calculating and storing the statistics, so\n * statistics i.e. can be serialized\n *\n * @author daniel\n */\npublic class CombatantStatistic implements StaticStatistics {\n\n    private final int numberOfRounds;\n\n    private final Map<CombatantStatType, DataSet> allData = new HashMap<CombatantStatType, DataSet>();\n\n    /**\n     * create statistics for the given number of rounds.\n     *\n     * @param numberOfRounds\n     */\n    public CombatantStatistic(final int numberOfRounds) {\n        this.numberOfRounds = numberOfRounds;\n    }\n\n    /**\n     * @param type\n     *            what kind of data is given as value?\n     * @param side\n     *            at which the combatant of the value fights\n     * @param value\n     */\n    public void addData(final CombatantStatType type, final CombatantSide side, final int value) {\n        ensureTypExists(type);\n        final Integer storedValue;\n        // fix class, because in the data it starts at -1 but we start with 0\n        if (type == CombatantStatType.charclass) {\n            storedValue = Integer.valueOf(value + 1);\n        } else {\n            storedValue = Integer.valueOf(value);\n        }\n        allData.get(type).addData(side, storedValue);\n    }\n\n    /**\n     * @param type\n     */\n    private void ensureTypExists(final CombatantStatType type) {\n        if (!allData.containsKey(type)) {\n            allData.put(type, new DataSet());\n        }\n    }\n\n    private double aggregate(final CombatantStatType stat, final CombatantSide side, final DataAggregationType function) {\n        // some data may not be present in old logs (ie. since 1.29 charlevel\n        // and charclass were added)\n        if (!allData.containsKey(stat)) {\n            return 0;\n        }\n        final DataSet statData = allData.get(stat);\n        assert statData != null : \"data must be present!\";\n        return statData.aggregate(side, function);\n    }\n\n    private double getAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AVERAGE);\n    }\n\n    private double getSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.SUM);\n    }\n\n    private double getCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AMOUNT);\n    }\n\n    private double getPositiveAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AVERAGE);\n    }\n\n    private double getPositiveSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_SUM);\n    }\n\n    private double getPositiveCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AMOUNT);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfPlayers(final CombatantSide side) {\n        // just a stat that is available for all combatants\n        return (int) Math.round(getCount(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#survivedPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int survivedPlayers(final CombatantSide side) {\n        return (int) Math.round(getPositiveCount(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double initialHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageWeaponDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageWeaponDamage(final CombatantSide side) {\n        final DataSet allMinDamage = allData.get(CombatantStatType.weaponmindmg);\n        final DataSet allMaxDamage = allData.get(CombatantStatType.weaponmaxdmg);\n        if (allMinDamage == null || allMaxDamage == null) {\n            // TODO logging: LOG.warn(\"no weapon damage data available!\");\n            // no weapon data available\n            return 0;\n        }\n        // use double precision for calculating average\n        final double avgMinDamage = allMinDamage.aggregate(side, DataAggregationType.AVERAGE);\n        final double avgMaxDamage = allMaxDamage.aggregate(side, DataAggregationType.AVERAGE);\n        return (avgMinDamage + avgMaxDamage) / 2.0;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double causedDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.totalcauseddamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int shotsFiredWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side) + getSum(CombatantStatType.misscount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int hitsWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLifetime(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLifetime(final CombatantSide side) {\n        final int totalPlayers = (int) getCount(CombatantStatType.diedwhen, side);\n        if (totalPlayers == 0) {\n            return 0.0;\n        }\n        final int diedPlayers = (int) getPositiveCount(CombatantStatType.diedwhen, side);\n        final int survivedPlayers = totalPlayers - diedPlayers;\n        final double diedInRound = getPositiveAverage(CombatantStatType.diedwhen, side);\n        return (diedPlayers * diedInRound + survivedPlayers * numberOfRounds) / totalPlayers;\n    }\n\n    private int numberOfClass(final CharacterClass charClass, final CombatantSide side) {\n        final DataSet data = allData.get(CombatantStatType.charclass);\n        // only available since v1.29\n        if (data == null) {\n            return 0;\n        }\n        final Integer value = Integer.valueOf(charClass.ordinal());\n        return data.countOfValuesWith(value, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfAdventurers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfAdventurers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.ADVENTURER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfDuelants(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfDuelants(final CombatantSide side) {\n        return numberOfClass(CharacterClass.DUELANT, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfGreenhorns(CombatantSide)\n     */\n    public int numberOfGreenhorns(final CombatantSide side) {\n        return numberOfClass(CharacterClass.GREENHORN, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfSoldiers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfSoldiers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.SOLDIER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfWorkers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfWorkers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.WORKER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLevel(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLevel(final CombatantSide side) {\n        return getAverage(CombatantStatType.charlevel, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int initialHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getPositiveAverage(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getPositiveSum(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int causedDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.totalcauseddamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double shotsFiredPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side) + getAverage(CombatantStatType.misscount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double hitsPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double takenDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.takendamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int takenDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.takendamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageHitDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageHitDamage(final CombatantSide side) {\n        // don't count the misses\n        final double teamHits = hitsWholeSide(side);\n        if (teamHits == 0) {\n            return 0;\n        }\n        final double teamDamage = causedDamageWholeSide(side);\n        final double totalCalculated = teamDamage / teamHits;\n        return totalCalculated;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double dodgesPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.dodgecount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int dodgesWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.dodgecount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistribution(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Number> healthDistribution(final CombatantSide side) {\n        // initialize map\n        final SortedMap<Number, Number> result = new TreeMap<Number, Number>();\n        final int maxHP = 14000;\n        final int step = 1000;\n        for (int limit = step; limit <= maxHP; limit += step) {\n            result.put(Integer.valueOf(limit), new AtomicInteger());\n        }\n        // fill with values\n        final CombatantStatType stat = CombatantStatType.starthp;\n        if (allData.containsKey(stat)) {\n            final DataSet statData = allData.get(stat);\n            final List<Integer> data = statData.getSideData(side);\n            for (final Integer value : data) {\n                Number key = getUpperLimit(value.intValue(), step);\n                if (!result.containsKey(key)) {\n                    // out of range, put it to the last value\n                    key = result.lastKey();\n                }\n                ((AtomicInteger) result.get(key)).incrementAndGet();\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistributionRelative(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Double> healthDistributionRelative(final CombatantSide side) {\n        final SortedMap<Number, Number> distribution = healthDistribution(side);\n        final TreeMap<Number, Double> result = new TreeMap<Number, Double>();\n        final double totalPlayers = numberOfPlayers(side);\n        for (final Entry<Number, Number> mapping : distribution.entrySet()) {\n            final double currentPlayers = mapping.getValue().doubleValue();\n            final Double percentage = Double.valueOf(currentPlayers / totalPlayers * 100.0);\n            result.put(mapping.getKey(), percentage);\n        }\n        return result;\n    }\n\n    /**\n     * @param value\n     * @param step\n     * @return\n     */\n    private Number getUpperLimit(final int value, final int step) {\n        int limit = 0;\n        while (value > limit) {\n            limit += step;\n        }\n        return Integer.valueOf(limit);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/CombatantStatistic_6Test.java",
		"test_prompt": "// CombatantStatistic_6Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CombatantStatistic}.\n* It contains ten unit test cases for the {@link CombatantStatistic#hitsWholeSide(CombatantSide)} method.\n*/\nclass CombatantStatistic_6Test {"
	},
	{
		"original_code": "// CombatantStatistic.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\n\n/**\n * A statistic for combatants\n *\n * TODO use separate classes for calculating and storing the statistics, so\n * statistics i.e. can be serialized\n *\n * @author daniel\n */\npublic class CombatantStatistic implements StaticStatistics {\n\n    private final int numberOfRounds;\n\n    private final Map<CombatantStatType, DataSet> allData = new HashMap<CombatantStatType, DataSet>();\n\n    /**\n     * create statistics for the given number of rounds.\n     *\n     * @param numberOfRounds\n     */\n    public CombatantStatistic(final int numberOfRounds) {\n        this.numberOfRounds = numberOfRounds;\n    }\n\n    /**\n     * @param type\n     *            what kind of data is given as value?\n     * @param side\n     *            at which the combatant of the value fights\n     * @param value\n     */\n    public void addData(final CombatantStatType type, final CombatantSide side, final int value) {\n        ensureTypExists(type);\n        final Integer storedValue;\n        // fix class, because in the data it starts at -1 but we start with 0\n        if (type == CombatantStatType.charclass) {\n            storedValue = Integer.valueOf(value + 1);\n        } else {\n            storedValue = Integer.valueOf(value);\n        }\n        allData.get(type).addData(side, storedValue);\n    }\n\n    /**\n     * @param type\n     */\n    private void ensureTypExists(final CombatantStatType type) {\n        if (!allData.containsKey(type)) {\n            allData.put(type, new DataSet());\n        }\n    }\n\n    private double aggregate(final CombatantStatType stat, final CombatantSide side, final DataAggregationType function) {\n        // some data may not be present in old logs (ie. since 1.29 charlevel\n        // and charclass were added)\n        if (!allData.containsKey(stat)) {\n            return 0;\n        }\n        final DataSet statData = allData.get(stat);\n        assert statData != null : \"data must be present!\";\n        return statData.aggregate(side, function);\n    }\n\n    private double getAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AVERAGE);\n    }\n\n    private double getSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.SUM);\n    }\n\n    private double getCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AMOUNT);\n    }\n\n    private double getPositiveAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AVERAGE);\n    }\n\n    private double getPositiveSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_SUM);\n    }\n\n    private double getPositiveCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AMOUNT);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfPlayers(final CombatantSide side) {\n        // just a stat that is available for all combatants\n        return (int) Math.round(getCount(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#survivedPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int survivedPlayers(final CombatantSide side) {\n        return (int) Math.round(getPositiveCount(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double initialHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageWeaponDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageWeaponDamage(final CombatantSide side) {\n        final DataSet allMinDamage = allData.get(CombatantStatType.weaponmindmg);\n        final DataSet allMaxDamage = allData.get(CombatantStatType.weaponmaxdmg);\n        if (allMinDamage == null || allMaxDamage == null) {\n            // TODO logging: LOG.warn(\"no weapon damage data available!\");\n            // no weapon data available\n            return 0;\n        }\n        // use double precision for calculating average\n        final double avgMinDamage = allMinDamage.aggregate(side, DataAggregationType.AVERAGE);\n        final double avgMaxDamage = allMaxDamage.aggregate(side, DataAggregationType.AVERAGE);\n        return (avgMinDamage + avgMaxDamage) / 2.0;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double causedDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.totalcauseddamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int shotsFiredWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side) + getSum(CombatantStatType.misscount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int hitsWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLifetime(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLifetime(final CombatantSide side) {\n        final int totalPlayers = (int) getCount(CombatantStatType.diedwhen, side);\n        if (totalPlayers == 0) {\n            return 0.0;\n        }\n        final int diedPlayers = (int) getPositiveCount(CombatantStatType.diedwhen, side);\n        final int survivedPlayers = totalPlayers - diedPlayers;\n        final double diedInRound = getPositiveAverage(CombatantStatType.diedwhen, side);\n        return (diedPlayers * diedInRound + survivedPlayers * numberOfRounds) / totalPlayers;\n    }\n\n    private int numberOfClass(final CharacterClass charClass, final CombatantSide side) {\n        final DataSet data = allData.get(CombatantStatType.charclass);\n        // only available since v1.29\n        if (data == null) {\n            return 0;\n        }\n        final Integer value = Integer.valueOf(charClass.ordinal());\n        return data.countOfValuesWith(value, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfAdventurers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfAdventurers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.ADVENTURER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfDuelants(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfDuelants(final CombatantSide side) {\n        return numberOfClass(CharacterClass.DUELANT, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfGreenhorns(CombatantSide)\n     */\n    public int numberOfGreenhorns(final CombatantSide side) {\n        return numberOfClass(CharacterClass.GREENHORN, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfSoldiers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfSoldiers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.SOLDIER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfWorkers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfWorkers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.WORKER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLevel(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLevel(final CombatantSide side) {\n        return getAverage(CombatantStatType.charlevel, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int initialHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getPositiveAverage(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getPositiveSum(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int causedDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.totalcauseddamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double shotsFiredPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side) + getAverage(CombatantStatType.misscount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double hitsPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double takenDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.takendamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int takenDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.takendamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageHitDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageHitDamage(final CombatantSide side) {\n        // don't count the misses\n        final double teamHits = hitsWholeSide(side);\n        if (teamHits == 0) {\n            return 0;\n        }\n        final double teamDamage = causedDamageWholeSide(side);\n        final double totalCalculated = teamDamage / teamHits;\n        return totalCalculated;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double dodgesPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.dodgecount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int dodgesWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.dodgecount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistribution(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Number> healthDistribution(final CombatantSide side) {\n        // initialize map\n        final SortedMap<Number, Number> result = new TreeMap<Number, Number>();\n        final int maxHP = 14000;\n        final int step = 1000;\n        for (int limit = step; limit <= maxHP; limit += step) {\n            result.put(Integer.valueOf(limit), new AtomicInteger());\n        }\n        // fill with values\n        final CombatantStatType stat = CombatantStatType.starthp;\n        if (allData.containsKey(stat)) {\n            final DataSet statData = allData.get(stat);\n            final List<Integer> data = statData.getSideData(side);\n            for (final Integer value : data) {\n                Number key = getUpperLimit(value.intValue(), step);\n                if (!result.containsKey(key)) {\n                    // out of range, put it to the last value\n                    key = result.lastKey();\n                }\n                ((AtomicInteger) result.get(key)).incrementAndGet();\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistributionRelative(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Double> healthDistributionRelative(final CombatantSide side) {\n        final SortedMap<Number, Number> distribution = healthDistribution(side);\n        final TreeMap<Number, Double> result = new TreeMap<Number, Double>();\n        final double totalPlayers = numberOfPlayers(side);\n        for (final Entry<Number, Number> mapping : distribution.entrySet()) {\n            final double currentPlayers = mapping.getValue().doubleValue();\n            final Double percentage = Double.valueOf(currentPlayers / totalPlayers * 100.0);\n            result.put(mapping.getKey(), percentage);\n        }\n        return result;\n    }\n\n    /**\n     * @param value\n     * @param step\n     * @return\n     */\n    private Number getUpperLimit(final int value, final int step) {\n        int limit = 0;\n        while (value > limit) {\n            limit += step;\n        }\n        return Integer.valueOf(limit);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/CombatantStatistic_7Test.java",
		"test_prompt": "// CombatantStatistic_7Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CombatantStatistic}.\n* It contains ten unit test cases for the {@link CombatantStatistic#averageLifetime(CombatantSide)} method.\n*/\nclass CombatantStatistic_7Test {"
	},
	{
		"original_code": "// CombatantStatistic.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\n\n/**\n * A statistic for combatants\n *\n * TODO use separate classes for calculating and storing the statistics, so\n * statistics i.e. can be serialized\n *\n * @author daniel\n */\npublic class CombatantStatistic implements StaticStatistics {\n\n    private final int numberOfRounds;\n\n    private final Map<CombatantStatType, DataSet> allData = new HashMap<CombatantStatType, DataSet>();\n\n    /**\n     * create statistics for the given number of rounds.\n     *\n     * @param numberOfRounds\n     */\n    public CombatantStatistic(final int numberOfRounds) {\n        this.numberOfRounds = numberOfRounds;\n    }\n\n    /**\n     * @param type\n     *            what kind of data is given as value?\n     * @param side\n     *            at which the combatant of the value fights\n     * @param value\n     */\n    public void addData(final CombatantStatType type, final CombatantSide side, final int value) {\n        ensureTypExists(type);\n        final Integer storedValue;\n        // fix class, because in the data it starts at -1 but we start with 0\n        if (type == CombatantStatType.charclass) {\n            storedValue = Integer.valueOf(value + 1);\n        } else {\n            storedValue = Integer.valueOf(value);\n        }\n        allData.get(type).addData(side, storedValue);\n    }\n\n    /**\n     * @param type\n     */\n    private void ensureTypExists(final CombatantStatType type) {\n        if (!allData.containsKey(type)) {\n            allData.put(type, new DataSet());\n        }\n    }\n\n    private double aggregate(final CombatantStatType stat, final CombatantSide side, final DataAggregationType function) {\n        // some data may not be present in old logs (ie. since 1.29 charlevel\n        // and charclass were added)\n        if (!allData.containsKey(stat)) {\n            return 0;\n        }\n        final DataSet statData = allData.get(stat);\n        assert statData != null : \"data must be present!\";\n        return statData.aggregate(side, function);\n    }\n\n    private double getAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AVERAGE);\n    }\n\n    private double getSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.SUM);\n    }\n\n    private double getCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AMOUNT);\n    }\n\n    private double getPositiveAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AVERAGE);\n    }\n\n    private double getPositiveSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_SUM);\n    }\n\n    private double getPositiveCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AMOUNT);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfPlayers(final CombatantSide side) {\n        // just a stat that is available for all combatants\n        return (int) Math.round(getCount(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#survivedPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int survivedPlayers(final CombatantSide side) {\n        return (int) Math.round(getPositiveCount(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double initialHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageWeaponDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageWeaponDamage(final CombatantSide side) {\n        final DataSet allMinDamage = allData.get(CombatantStatType.weaponmindmg);\n        final DataSet allMaxDamage = allData.get(CombatantStatType.weaponmaxdmg);\n        if (allMinDamage == null || allMaxDamage == null) {\n            // TODO logging: LOG.warn(\"no weapon damage data available!\");\n            // no weapon data available\n            return 0;\n        }\n        // use double precision for calculating average\n        final double avgMinDamage = allMinDamage.aggregate(side, DataAggregationType.AVERAGE);\n        final double avgMaxDamage = allMaxDamage.aggregate(side, DataAggregationType.AVERAGE);\n        return (avgMinDamage + avgMaxDamage) / 2.0;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double causedDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.totalcauseddamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int shotsFiredWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side) + getSum(CombatantStatType.misscount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int hitsWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLifetime(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLifetime(final CombatantSide side) {\n        final int totalPlayers = (int) getCount(CombatantStatType.diedwhen, side);\n        if (totalPlayers == 0) {\n            return 0.0;\n        }\n        final int diedPlayers = (int) getPositiveCount(CombatantStatType.diedwhen, side);\n        final int survivedPlayers = totalPlayers - diedPlayers;\n        final double diedInRound = getPositiveAverage(CombatantStatType.diedwhen, side);\n        return (diedPlayers * diedInRound + survivedPlayers * numberOfRounds) / totalPlayers;\n    }\n\n    private int numberOfClass(final CharacterClass charClass, final CombatantSide side) {\n        final DataSet data = allData.get(CombatantStatType.charclass);\n        // only available since v1.29\n        if (data == null) {\n            return 0;\n        }\n        final Integer value = Integer.valueOf(charClass.ordinal());\n        return data.countOfValuesWith(value, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfAdventurers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfAdventurers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.ADVENTURER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfDuelants(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfDuelants(final CombatantSide side) {\n        return numberOfClass(CharacterClass.DUELANT, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfGreenhorns(CombatantSide)\n     */\n    public int numberOfGreenhorns(final CombatantSide side) {\n        return numberOfClass(CharacterClass.GREENHORN, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfSoldiers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfSoldiers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.SOLDIER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfWorkers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfWorkers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.WORKER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLevel(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLevel(final CombatantSide side) {\n        return getAverage(CombatantStatType.charlevel, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int initialHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getPositiveAverage(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getPositiveSum(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int causedDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.totalcauseddamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double shotsFiredPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side) + getAverage(CombatantStatType.misscount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double hitsPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double takenDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.takendamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int takenDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.takendamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageHitDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageHitDamage(final CombatantSide side) {\n        // don't count the misses\n        final double teamHits = hitsWholeSide(side);\n        if (teamHits == 0) {\n            return 0;\n        }\n        final double teamDamage = causedDamageWholeSide(side);\n        final double totalCalculated = teamDamage / teamHits;\n        return totalCalculated;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double dodgesPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.dodgecount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int dodgesWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.dodgecount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistribution(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Number> healthDistribution(final CombatantSide side) {\n        // initialize map\n        final SortedMap<Number, Number> result = new TreeMap<Number, Number>();\n        final int maxHP = 14000;\n        final int step = 1000;\n        for (int limit = step; limit <= maxHP; limit += step) {\n            result.put(Integer.valueOf(limit), new AtomicInteger());\n        }\n        // fill with values\n        final CombatantStatType stat = CombatantStatType.starthp;\n        if (allData.containsKey(stat)) {\n            final DataSet statData = allData.get(stat);\n            final List<Integer> data = statData.getSideData(side);\n            for (final Integer value : data) {\n                Number key = getUpperLimit(value.intValue(), step);\n                if (!result.containsKey(key)) {\n                    // out of range, put it to the last value\n                    key = result.lastKey();\n                }\n                ((AtomicInteger) result.get(key)).incrementAndGet();\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistributionRelative(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Double> healthDistributionRelative(final CombatantSide side) {\n        final SortedMap<Number, Number> distribution = healthDistribution(side);\n        final TreeMap<Number, Double> result = new TreeMap<Number, Double>();\n        final double totalPlayers = numberOfPlayers(side);\n        for (final Entry<Number, Number> mapping : distribution.entrySet()) {\n            final double currentPlayers = mapping.getValue().doubleValue();\n            final Double percentage = Double.valueOf(currentPlayers / totalPlayers * 100.0);\n            result.put(mapping.getKey(), percentage);\n        }\n        return result;\n    }\n\n    /**\n     * @param value\n     * @param step\n     * @return\n     */\n    private Number getUpperLimit(final int value, final int step) {\n        int limit = 0;\n        while (value > limit) {\n            limit += step;\n        }\n        return Integer.valueOf(limit);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/CombatantStatistic_8Test.java",
		"test_prompt": "// CombatantStatistic_8Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CombatantStatistic}.\n* It contains ten unit test cases for the {@link CombatantStatistic#numberOfAdventurers(CombatantSide)} method.\n*/\nclass CombatantStatistic_8Test {"
	},
	{
		"original_code": "// CombatantStatistic.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\n\n/**\n * A statistic for combatants\n *\n * TODO use separate classes for calculating and storing the statistics, so\n * statistics i.e. can be serialized\n *\n * @author daniel\n */\npublic class CombatantStatistic implements StaticStatistics {\n\n    private final int numberOfRounds;\n\n    private final Map<CombatantStatType, DataSet> allData = new HashMap<CombatantStatType, DataSet>();\n\n    /**\n     * create statistics for the given number of rounds.\n     *\n     * @param numberOfRounds\n     */\n    public CombatantStatistic(final int numberOfRounds) {\n        this.numberOfRounds = numberOfRounds;\n    }\n\n    /**\n     * @param type\n     *            what kind of data is given as value?\n     * @param side\n     *            at which the combatant of the value fights\n     * @param value\n     */\n    public void addData(final CombatantStatType type, final CombatantSide side, final int value) {\n        ensureTypExists(type);\n        final Integer storedValue;\n        // fix class, because in the data it starts at -1 but we start with 0\n        if (type == CombatantStatType.charclass) {\n            storedValue = Integer.valueOf(value + 1);\n        } else {\n            storedValue = Integer.valueOf(value);\n        }\n        allData.get(type).addData(side, storedValue);\n    }\n\n    /**\n     * @param type\n     */\n    private void ensureTypExists(final CombatantStatType type) {\n        if (!allData.containsKey(type)) {\n            allData.put(type, new DataSet());\n        }\n    }\n\n    private double aggregate(final CombatantStatType stat, final CombatantSide side, final DataAggregationType function) {\n        // some data may not be present in old logs (ie. since 1.29 charlevel\n        // and charclass were added)\n        if (!allData.containsKey(stat)) {\n            return 0;\n        }\n        final DataSet statData = allData.get(stat);\n        assert statData != null : \"data must be present!\";\n        return statData.aggregate(side, function);\n    }\n\n    private double getAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AVERAGE);\n    }\n\n    private double getSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.SUM);\n    }\n\n    private double getCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AMOUNT);\n    }\n\n    private double getPositiveAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AVERAGE);\n    }\n\n    private double getPositiveSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_SUM);\n    }\n\n    private double getPositiveCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AMOUNT);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfPlayers(final CombatantSide side) {\n        // just a stat that is available for all combatants\n        return (int) Math.round(getCount(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#survivedPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int survivedPlayers(final CombatantSide side) {\n        return (int) Math.round(getPositiveCount(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double initialHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageWeaponDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageWeaponDamage(final CombatantSide side) {\n        final DataSet allMinDamage = allData.get(CombatantStatType.weaponmindmg);\n        final DataSet allMaxDamage = allData.get(CombatantStatType.weaponmaxdmg);\n        if (allMinDamage == null || allMaxDamage == null) {\n            // TODO logging: LOG.warn(\"no weapon damage data available!\");\n            // no weapon data available\n            return 0;\n        }\n        // use double precision for calculating average\n        final double avgMinDamage = allMinDamage.aggregate(side, DataAggregationType.AVERAGE);\n        final double avgMaxDamage = allMaxDamage.aggregate(side, DataAggregationType.AVERAGE);\n        return (avgMinDamage + avgMaxDamage) / 2.0;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double causedDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.totalcauseddamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int shotsFiredWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side) + getSum(CombatantStatType.misscount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int hitsWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLifetime(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLifetime(final CombatantSide side) {\n        final int totalPlayers = (int) getCount(CombatantStatType.diedwhen, side);\n        if (totalPlayers == 0) {\n            return 0.0;\n        }\n        final int diedPlayers = (int) getPositiveCount(CombatantStatType.diedwhen, side);\n        final int survivedPlayers = totalPlayers - diedPlayers;\n        final double diedInRound = getPositiveAverage(CombatantStatType.diedwhen, side);\n        return (diedPlayers * diedInRound + survivedPlayers * numberOfRounds) / totalPlayers;\n    }\n\n    private int numberOfClass(final CharacterClass charClass, final CombatantSide side) {\n        final DataSet data = allData.get(CombatantStatType.charclass);\n        // only available since v1.29\n        if (data == null) {\n            return 0;\n        }\n        final Integer value = Integer.valueOf(charClass.ordinal());\n        return data.countOfValuesWith(value, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfAdventurers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfAdventurers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.ADVENTURER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfDuelants(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfDuelants(final CombatantSide side) {\n        return numberOfClass(CharacterClass.DUELANT, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfGreenhorns(CombatantSide)\n     */\n    public int numberOfGreenhorns(final CombatantSide side) {\n        return numberOfClass(CharacterClass.GREENHORN, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfSoldiers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfSoldiers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.SOLDIER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfWorkers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfWorkers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.WORKER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLevel(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLevel(final CombatantSide side) {\n        return getAverage(CombatantStatType.charlevel, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int initialHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getPositiveAverage(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getPositiveSum(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int causedDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.totalcauseddamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double shotsFiredPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side) + getAverage(CombatantStatType.misscount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double hitsPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double takenDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.takendamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int takenDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.takendamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageHitDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageHitDamage(final CombatantSide side) {\n        // don't count the misses\n        final double teamHits = hitsWholeSide(side);\n        if (teamHits == 0) {\n            return 0;\n        }\n        final double teamDamage = causedDamageWholeSide(side);\n        final double totalCalculated = teamDamage / teamHits;\n        return totalCalculated;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double dodgesPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.dodgecount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int dodgesWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.dodgecount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistribution(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Number> healthDistribution(final CombatantSide side) {\n        // initialize map\n        final SortedMap<Number, Number> result = new TreeMap<Number, Number>();\n        final int maxHP = 14000;\n        final int step = 1000;\n        for (int limit = step; limit <= maxHP; limit += step) {\n            result.put(Integer.valueOf(limit), new AtomicInteger());\n        }\n        // fill with values\n        final CombatantStatType stat = CombatantStatType.starthp;\n        if (allData.containsKey(stat)) {\n            final DataSet statData = allData.get(stat);\n            final List<Integer> data = statData.getSideData(side);\n            for (final Integer value : data) {\n                Number key = getUpperLimit(value.intValue(), step);\n                if (!result.containsKey(key)) {\n                    // out of range, put it to the last value\n                    key = result.lastKey();\n                }\n                ((AtomicInteger) result.get(key)).incrementAndGet();\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistributionRelative(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Double> healthDistributionRelative(final CombatantSide side) {\n        final SortedMap<Number, Number> distribution = healthDistribution(side);\n        final TreeMap<Number, Double> result = new TreeMap<Number, Double>();\n        final double totalPlayers = numberOfPlayers(side);\n        for (final Entry<Number, Number> mapping : distribution.entrySet()) {\n            final double currentPlayers = mapping.getValue().doubleValue();\n            final Double percentage = Double.valueOf(currentPlayers / totalPlayers * 100.0);\n            result.put(mapping.getKey(), percentage);\n        }\n        return result;\n    }\n\n    /**\n     * @param value\n     * @param step\n     * @return\n     */\n    private Number getUpperLimit(final int value, final int step) {\n        int limit = 0;\n        while (value > limit) {\n            limit += step;\n        }\n        return Integer.valueOf(limit);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/CombatantStatistic_9Test.java",
		"test_prompt": "// CombatantStatistic_9Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CombatantStatistic}.\n* It contains ten unit test cases for the {@link CombatantStatistic#numberOfDuelants(CombatantSide)} method.\n*/\nclass CombatantStatistic_9Test {"
	},
	{
		"original_code": "// CombatantStatistic.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\n\n/**\n * A statistic for combatants\n *\n * TODO use separate classes for calculating and storing the statistics, so\n * statistics i.e. can be serialized\n *\n * @author daniel\n */\npublic class CombatantStatistic implements StaticStatistics {\n\n    private final int numberOfRounds;\n\n    private final Map<CombatantStatType, DataSet> allData = new HashMap<CombatantStatType, DataSet>();\n\n    /**\n     * create statistics for the given number of rounds.\n     *\n     * @param numberOfRounds\n     */\n    public CombatantStatistic(final int numberOfRounds) {\n        this.numberOfRounds = numberOfRounds;\n    }\n\n    /**\n     * @param type\n     *            what kind of data is given as value?\n     * @param side\n     *            at which the combatant of the value fights\n     * @param value\n     */\n    public void addData(final CombatantStatType type, final CombatantSide side, final int value) {\n        ensureTypExists(type);\n        final Integer storedValue;\n        // fix class, because in the data it starts at -1 but we start with 0\n        if (type == CombatantStatType.charclass) {\n            storedValue = Integer.valueOf(value + 1);\n        } else {\n            storedValue = Integer.valueOf(value);\n        }\n        allData.get(type).addData(side, storedValue);\n    }\n\n    /**\n     * @param type\n     */\n    private void ensureTypExists(final CombatantStatType type) {\n        if (!allData.containsKey(type)) {\n            allData.put(type, new DataSet());\n        }\n    }\n\n    private double aggregate(final CombatantStatType stat, final CombatantSide side, final DataAggregationType function) {\n        // some data may not be present in old logs (ie. since 1.29 charlevel\n        // and charclass were added)\n        if (!allData.containsKey(stat)) {\n            return 0;\n        }\n        final DataSet statData = allData.get(stat);\n        assert statData != null : \"data must be present!\";\n        return statData.aggregate(side, function);\n    }\n\n    private double getAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AVERAGE);\n    }\n\n    private double getSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.SUM);\n    }\n\n    private double getCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AMOUNT);\n    }\n\n    private double getPositiveAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AVERAGE);\n    }\n\n    private double getPositiveSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_SUM);\n    }\n\n    private double getPositiveCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AMOUNT);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfPlayers(final CombatantSide side) {\n        // just a stat that is available for all combatants\n        return (int) Math.round(getCount(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#survivedPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int survivedPlayers(final CombatantSide side) {\n        return (int) Math.round(getPositiveCount(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double initialHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageWeaponDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageWeaponDamage(final CombatantSide side) {\n        final DataSet allMinDamage = allData.get(CombatantStatType.weaponmindmg);\n        final DataSet allMaxDamage = allData.get(CombatantStatType.weaponmaxdmg);\n        if (allMinDamage == null || allMaxDamage == null) {\n            // TODO logging: LOG.warn(\"no weapon damage data available!\");\n            // no weapon data available\n            return 0;\n        }\n        // use double precision for calculating average\n        final double avgMinDamage = allMinDamage.aggregate(side, DataAggregationType.AVERAGE);\n        final double avgMaxDamage = allMaxDamage.aggregate(side, DataAggregationType.AVERAGE);\n        return (avgMinDamage + avgMaxDamage) / 2.0;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double causedDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.totalcauseddamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int shotsFiredWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side) + getSum(CombatantStatType.misscount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int hitsWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLifetime(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLifetime(final CombatantSide side) {\n        final int totalPlayers = (int) getCount(CombatantStatType.diedwhen, side);\n        if (totalPlayers == 0) {\n            return 0.0;\n        }\n        final int diedPlayers = (int) getPositiveCount(CombatantStatType.diedwhen, side);\n        final int survivedPlayers = totalPlayers - diedPlayers;\n        final double diedInRound = getPositiveAverage(CombatantStatType.diedwhen, side);\n        return (diedPlayers * diedInRound + survivedPlayers * numberOfRounds) / totalPlayers;\n    }\n\n    private int numberOfClass(final CharacterClass charClass, final CombatantSide side) {\n        final DataSet data = allData.get(CombatantStatType.charclass);\n        // only available since v1.29\n        if (data == null) {\n            return 0;\n        }\n        final Integer value = Integer.valueOf(charClass.ordinal());\n        return data.countOfValuesWith(value, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfAdventurers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfAdventurers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.ADVENTURER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfDuelants(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfDuelants(final CombatantSide side) {\n        return numberOfClass(CharacterClass.DUELANT, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfGreenhorns(CombatantSide)\n     */\n    public int numberOfGreenhorns(final CombatantSide side) {\n        return numberOfClass(CharacterClass.GREENHORN, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfSoldiers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfSoldiers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.SOLDIER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfWorkers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfWorkers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.WORKER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLevel(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLevel(final CombatantSide side) {\n        return getAverage(CombatantStatType.charlevel, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int initialHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getPositiveAverage(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getPositiveSum(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int causedDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.totalcauseddamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double shotsFiredPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side) + getAverage(CombatantStatType.misscount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double hitsPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double takenDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.takendamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int takenDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.takendamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageHitDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageHitDamage(final CombatantSide side) {\n        // don't count the misses\n        final double teamHits = hitsWholeSide(side);\n        if (teamHits == 0) {\n            return 0;\n        }\n        final double teamDamage = causedDamageWholeSide(side);\n        final double totalCalculated = teamDamage / teamHits;\n        return totalCalculated;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double dodgesPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.dodgecount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int dodgesWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.dodgecount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistribution(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Number> healthDistribution(final CombatantSide side) {\n        // initialize map\n        final SortedMap<Number, Number> result = new TreeMap<Number, Number>();\n        final int maxHP = 14000;\n        final int step = 1000;\n        for (int limit = step; limit <= maxHP; limit += step) {\n            result.put(Integer.valueOf(limit), new AtomicInteger());\n        }\n        // fill with values\n        final CombatantStatType stat = CombatantStatType.starthp;\n        if (allData.containsKey(stat)) {\n            final DataSet statData = allData.get(stat);\n            final List<Integer> data = statData.getSideData(side);\n            for (final Integer value : data) {\n                Number key = getUpperLimit(value.intValue(), step);\n                if (!result.containsKey(key)) {\n                    // out of range, put it to the last value\n                    key = result.lastKey();\n                }\n                ((AtomicInteger) result.get(key)).incrementAndGet();\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistributionRelative(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Double> healthDistributionRelative(final CombatantSide side) {\n        final SortedMap<Number, Number> distribution = healthDistribution(side);\n        final TreeMap<Number, Double> result = new TreeMap<Number, Double>();\n        final double totalPlayers = numberOfPlayers(side);\n        for (final Entry<Number, Number> mapping : distribution.entrySet()) {\n            final double currentPlayers = mapping.getValue().doubleValue();\n            final Double percentage = Double.valueOf(currentPlayers / totalPlayers * 100.0);\n            result.put(mapping.getKey(), percentage);\n        }\n        return result;\n    }\n\n    /**\n     * @param value\n     * @param step\n     * @return\n     */\n    private Number getUpperLimit(final int value, final int step) {\n        int limit = 0;\n        while (value > limit) {\n            limit += step;\n        }\n        return Integer.valueOf(limit);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/CombatantStatistic_10Test.java",
		"test_prompt": "// CombatantStatistic_10Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CombatantStatistic}.\n* It contains ten unit test cases for the {@link CombatantStatistic#numberOfGreenhorns(CombatantSide)} method.\n*/\nclass CombatantStatistic_10Test {"
	},
	{
		"original_code": "// CombatantStatistic.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\n\n/**\n * A statistic for combatants\n *\n * TODO use separate classes for calculating and storing the statistics, so\n * statistics i.e. can be serialized\n *\n * @author daniel\n */\npublic class CombatantStatistic implements StaticStatistics {\n\n    private final int numberOfRounds;\n\n    private final Map<CombatantStatType, DataSet> allData = new HashMap<CombatantStatType, DataSet>();\n\n    /**\n     * create statistics for the given number of rounds.\n     *\n     * @param numberOfRounds\n     */\n    public CombatantStatistic(final int numberOfRounds) {\n        this.numberOfRounds = numberOfRounds;\n    }\n\n    /**\n     * @param type\n     *            what kind of data is given as value?\n     * @param side\n     *            at which the combatant of the value fights\n     * @param value\n     */\n    public void addData(final CombatantStatType type, final CombatantSide side, final int value) {\n        ensureTypExists(type);\n        final Integer storedValue;\n        // fix class, because in the data it starts at -1 but we start with 0\n        if (type == CombatantStatType.charclass) {\n            storedValue = Integer.valueOf(value + 1);\n        } else {\n            storedValue = Integer.valueOf(value);\n        }\n        allData.get(type).addData(side, storedValue);\n    }\n\n    /**\n     * @param type\n     */\n    private void ensureTypExists(final CombatantStatType type) {\n        if (!allData.containsKey(type)) {\n            allData.put(type, new DataSet());\n        }\n    }\n\n    private double aggregate(final CombatantStatType stat, final CombatantSide side, final DataAggregationType function) {\n        // some data may not be present in old logs (ie. since 1.29 charlevel\n        // and charclass were added)\n        if (!allData.containsKey(stat)) {\n            return 0;\n        }\n        final DataSet statData = allData.get(stat);\n        assert statData != null : \"data must be present!\";\n        return statData.aggregate(side, function);\n    }\n\n    private double getAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AVERAGE);\n    }\n\n    private double getSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.SUM);\n    }\n\n    private double getCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AMOUNT);\n    }\n\n    private double getPositiveAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AVERAGE);\n    }\n\n    private double getPositiveSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_SUM);\n    }\n\n    private double getPositiveCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AMOUNT);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfPlayers(final CombatantSide side) {\n        // just a stat that is available for all combatants\n        return (int) Math.round(getCount(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#survivedPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int survivedPlayers(final CombatantSide side) {\n        return (int) Math.round(getPositiveCount(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double initialHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageWeaponDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageWeaponDamage(final CombatantSide side) {\n        final DataSet allMinDamage = allData.get(CombatantStatType.weaponmindmg);\n        final DataSet allMaxDamage = allData.get(CombatantStatType.weaponmaxdmg);\n        if (allMinDamage == null || allMaxDamage == null) {\n            // TODO logging: LOG.warn(\"no weapon damage data available!\");\n            // no weapon data available\n            return 0;\n        }\n        // use double precision for calculating average\n        final double avgMinDamage = allMinDamage.aggregate(side, DataAggregationType.AVERAGE);\n        final double avgMaxDamage = allMaxDamage.aggregate(side, DataAggregationType.AVERAGE);\n        return (avgMinDamage + avgMaxDamage) / 2.0;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double causedDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.totalcauseddamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int shotsFiredWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side) + getSum(CombatantStatType.misscount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int hitsWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLifetime(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLifetime(final CombatantSide side) {\n        final int totalPlayers = (int) getCount(CombatantStatType.diedwhen, side);\n        if (totalPlayers == 0) {\n            return 0.0;\n        }\n        final int diedPlayers = (int) getPositiveCount(CombatantStatType.diedwhen, side);\n        final int survivedPlayers = totalPlayers - diedPlayers;\n        final double diedInRound = getPositiveAverage(CombatantStatType.diedwhen, side);\n        return (diedPlayers * diedInRound + survivedPlayers * numberOfRounds) / totalPlayers;\n    }\n\n    private int numberOfClass(final CharacterClass charClass, final CombatantSide side) {\n        final DataSet data = allData.get(CombatantStatType.charclass);\n        // only available since v1.29\n        if (data == null) {\n            return 0;\n        }\n        final Integer value = Integer.valueOf(charClass.ordinal());\n        return data.countOfValuesWith(value, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfAdventurers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfAdventurers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.ADVENTURER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfDuelants(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfDuelants(final CombatantSide side) {\n        return numberOfClass(CharacterClass.DUELANT, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfGreenhorns(CombatantSide)\n     */\n    public int numberOfGreenhorns(final CombatantSide side) {\n        return numberOfClass(CharacterClass.GREENHORN, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfSoldiers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfSoldiers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.SOLDIER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfWorkers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfWorkers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.WORKER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLevel(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLevel(final CombatantSide side) {\n        return getAverage(CombatantStatType.charlevel, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int initialHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getPositiveAverage(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getPositiveSum(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int causedDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.totalcauseddamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double shotsFiredPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side) + getAverage(CombatantStatType.misscount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double hitsPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double takenDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.takendamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int takenDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.takendamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageHitDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageHitDamage(final CombatantSide side) {\n        // don't count the misses\n        final double teamHits = hitsWholeSide(side);\n        if (teamHits == 0) {\n            return 0;\n        }\n        final double teamDamage = causedDamageWholeSide(side);\n        final double totalCalculated = teamDamage / teamHits;\n        return totalCalculated;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double dodgesPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.dodgecount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int dodgesWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.dodgecount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistribution(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Number> healthDistribution(final CombatantSide side) {\n        // initialize map\n        final SortedMap<Number, Number> result = new TreeMap<Number, Number>();\n        final int maxHP = 14000;\n        final int step = 1000;\n        for (int limit = step; limit <= maxHP; limit += step) {\n            result.put(Integer.valueOf(limit), new AtomicInteger());\n        }\n        // fill with values\n        final CombatantStatType stat = CombatantStatType.starthp;\n        if (allData.containsKey(stat)) {\n            final DataSet statData = allData.get(stat);\n            final List<Integer> data = statData.getSideData(side);\n            for (final Integer value : data) {\n                Number key = getUpperLimit(value.intValue(), step);\n                if (!result.containsKey(key)) {\n                    // out of range, put it to the last value\n                    key = result.lastKey();\n                }\n                ((AtomicInteger) result.get(key)).incrementAndGet();\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistributionRelative(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Double> healthDistributionRelative(final CombatantSide side) {\n        final SortedMap<Number, Number> distribution = healthDistribution(side);\n        final TreeMap<Number, Double> result = new TreeMap<Number, Double>();\n        final double totalPlayers = numberOfPlayers(side);\n        for (final Entry<Number, Number> mapping : distribution.entrySet()) {\n            final double currentPlayers = mapping.getValue().doubleValue();\n            final Double percentage = Double.valueOf(currentPlayers / totalPlayers * 100.0);\n            result.put(mapping.getKey(), percentage);\n        }\n        return result;\n    }\n\n    /**\n     * @param value\n     * @param step\n     * @return\n     */\n    private Number getUpperLimit(final int value, final int step) {\n        int limit = 0;\n        while (value > limit) {\n            limit += step;\n        }\n        return Integer.valueOf(limit);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/CombatantStatistic_11Test.java",
		"test_prompt": "// CombatantStatistic_11Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CombatantStatistic}.\n* It contains ten unit test cases for the {@link CombatantStatistic#numberOfSoldiers(CombatantSide)} method.\n*/\nclass CombatantStatistic_11Test {"
	},
	{
		"original_code": "// CombatantStatistic.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\n\n/**\n * A statistic for combatants\n *\n * TODO use separate classes for calculating and storing the statistics, so\n * statistics i.e. can be serialized\n *\n * @author daniel\n */\npublic class CombatantStatistic implements StaticStatistics {\n\n    private final int numberOfRounds;\n\n    private final Map<CombatantStatType, DataSet> allData = new HashMap<CombatantStatType, DataSet>();\n\n    /**\n     * create statistics for the given number of rounds.\n     *\n     * @param numberOfRounds\n     */\n    public CombatantStatistic(final int numberOfRounds) {\n        this.numberOfRounds = numberOfRounds;\n    }\n\n    /**\n     * @param type\n     *            what kind of data is given as value?\n     * @param side\n     *            at which the combatant of the value fights\n     * @param value\n     */\n    public void addData(final CombatantStatType type, final CombatantSide side, final int value) {\n        ensureTypExists(type);\n        final Integer storedValue;\n        // fix class, because in the data it starts at -1 but we start with 0\n        if (type == CombatantStatType.charclass) {\n            storedValue = Integer.valueOf(value + 1);\n        } else {\n            storedValue = Integer.valueOf(value);\n        }\n        allData.get(type).addData(side, storedValue);\n    }\n\n    /**\n     * @param type\n     */\n    private void ensureTypExists(final CombatantStatType type) {\n        if (!allData.containsKey(type)) {\n            allData.put(type, new DataSet());\n        }\n    }\n\n    private double aggregate(final CombatantStatType stat, final CombatantSide side, final DataAggregationType function) {\n        // some data may not be present in old logs (ie. since 1.29 charlevel\n        // and charclass were added)\n        if (!allData.containsKey(stat)) {\n            return 0;\n        }\n        final DataSet statData = allData.get(stat);\n        assert statData != null : \"data must be present!\";\n        return statData.aggregate(side, function);\n    }\n\n    private double getAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AVERAGE);\n    }\n\n    private double getSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.SUM);\n    }\n\n    private double getCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AMOUNT);\n    }\n\n    private double getPositiveAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AVERAGE);\n    }\n\n    private double getPositiveSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_SUM);\n    }\n\n    private double getPositiveCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AMOUNT);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfPlayers(final CombatantSide side) {\n        // just a stat that is available for all combatants\n        return (int) Math.round(getCount(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#survivedPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int survivedPlayers(final CombatantSide side) {\n        return (int) Math.round(getPositiveCount(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double initialHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageWeaponDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageWeaponDamage(final CombatantSide side) {\n        final DataSet allMinDamage = allData.get(CombatantStatType.weaponmindmg);\n        final DataSet allMaxDamage = allData.get(CombatantStatType.weaponmaxdmg);\n        if (allMinDamage == null || allMaxDamage == null) {\n            // TODO logging: LOG.warn(\"no weapon damage data available!\");\n            // no weapon data available\n            return 0;\n        }\n        // use double precision for calculating average\n        final double avgMinDamage = allMinDamage.aggregate(side, DataAggregationType.AVERAGE);\n        final double avgMaxDamage = allMaxDamage.aggregate(side, DataAggregationType.AVERAGE);\n        return (avgMinDamage + avgMaxDamage) / 2.0;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double causedDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.totalcauseddamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int shotsFiredWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side) + getSum(CombatantStatType.misscount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int hitsWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLifetime(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLifetime(final CombatantSide side) {\n        final int totalPlayers = (int) getCount(CombatantStatType.diedwhen, side);\n        if (totalPlayers == 0) {\n            return 0.0;\n        }\n        final int diedPlayers = (int) getPositiveCount(CombatantStatType.diedwhen, side);\n        final int survivedPlayers = totalPlayers - diedPlayers;\n        final double diedInRound = getPositiveAverage(CombatantStatType.diedwhen, side);\n        return (diedPlayers * diedInRound + survivedPlayers * numberOfRounds) / totalPlayers;\n    }\n\n    private int numberOfClass(final CharacterClass charClass, final CombatantSide side) {\n        final DataSet data = allData.get(CombatantStatType.charclass);\n        // only available since v1.29\n        if (data == null) {\n            return 0;\n        }\n        final Integer value = Integer.valueOf(charClass.ordinal());\n        return data.countOfValuesWith(value, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfAdventurers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfAdventurers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.ADVENTURER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfDuelants(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfDuelants(final CombatantSide side) {\n        return numberOfClass(CharacterClass.DUELANT, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfGreenhorns(CombatantSide)\n     */\n    public int numberOfGreenhorns(final CombatantSide side) {\n        return numberOfClass(CharacterClass.GREENHORN, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfSoldiers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfSoldiers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.SOLDIER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfWorkers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfWorkers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.WORKER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLevel(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLevel(final CombatantSide side) {\n        return getAverage(CombatantStatType.charlevel, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int initialHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getPositiveAverage(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getPositiveSum(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int causedDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.totalcauseddamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double shotsFiredPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side) + getAverage(CombatantStatType.misscount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double hitsPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double takenDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.takendamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int takenDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.takendamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageHitDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageHitDamage(final CombatantSide side) {\n        // don't count the misses\n        final double teamHits = hitsWholeSide(side);\n        if (teamHits == 0) {\n            return 0;\n        }\n        final double teamDamage = causedDamageWholeSide(side);\n        final double totalCalculated = teamDamage / teamHits;\n        return totalCalculated;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double dodgesPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.dodgecount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int dodgesWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.dodgecount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistribution(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Number> healthDistribution(final CombatantSide side) {\n        // initialize map\n        final SortedMap<Number, Number> result = new TreeMap<Number, Number>();\n        final int maxHP = 14000;\n        final int step = 1000;\n        for (int limit = step; limit <= maxHP; limit += step) {\n            result.put(Integer.valueOf(limit), new AtomicInteger());\n        }\n        // fill with values\n        final CombatantStatType stat = CombatantStatType.starthp;\n        if (allData.containsKey(stat)) {\n            final DataSet statData = allData.get(stat);\n            final List<Integer> data = statData.getSideData(side);\n            for (final Integer value : data) {\n                Number key = getUpperLimit(value.intValue(), step);\n                if (!result.containsKey(key)) {\n                    // out of range, put it to the last value\n                    key = result.lastKey();\n                }\n                ((AtomicInteger) result.get(key)).incrementAndGet();\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistributionRelative(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Double> healthDistributionRelative(final CombatantSide side) {\n        final SortedMap<Number, Number> distribution = healthDistribution(side);\n        final TreeMap<Number, Double> result = new TreeMap<Number, Double>();\n        final double totalPlayers = numberOfPlayers(side);\n        for (final Entry<Number, Number> mapping : distribution.entrySet()) {\n            final double currentPlayers = mapping.getValue().doubleValue();\n            final Double percentage = Double.valueOf(currentPlayers / totalPlayers * 100.0);\n            result.put(mapping.getKey(), percentage);\n        }\n        return result;\n    }\n\n    /**\n     * @param value\n     * @param step\n     * @return\n     */\n    private Number getUpperLimit(final int value, final int step) {\n        int limit = 0;\n        while (value > limit) {\n            limit += step;\n        }\n        return Integer.valueOf(limit);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/CombatantStatistic_12Test.java",
		"test_prompt": "// CombatantStatistic_12Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CombatantStatistic}.\n* It contains ten unit test cases for the {@link CombatantStatistic#numberOfWorkers(CombatantSide)} method.\n*/\nclass CombatantStatistic_12Test {"
	},
	{
		"original_code": "// CombatantStatistic.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\n\n/**\n * A statistic for combatants\n *\n * TODO use separate classes for calculating and storing the statistics, so\n * statistics i.e. can be serialized\n *\n * @author daniel\n */\npublic class CombatantStatistic implements StaticStatistics {\n\n    private final int numberOfRounds;\n\n    private final Map<CombatantStatType, DataSet> allData = new HashMap<CombatantStatType, DataSet>();\n\n    /**\n     * create statistics for the given number of rounds.\n     *\n     * @param numberOfRounds\n     */\n    public CombatantStatistic(final int numberOfRounds) {\n        this.numberOfRounds = numberOfRounds;\n    }\n\n    /**\n     * @param type\n     *            what kind of data is given as value?\n     * @param side\n     *            at which the combatant of the value fights\n     * @param value\n     */\n    public void addData(final CombatantStatType type, final CombatantSide side, final int value) {\n        ensureTypExists(type);\n        final Integer storedValue;\n        // fix class, because in the data it starts at -1 but we start with 0\n        if (type == CombatantStatType.charclass) {\n            storedValue = Integer.valueOf(value + 1);\n        } else {\n            storedValue = Integer.valueOf(value);\n        }\n        allData.get(type).addData(side, storedValue);\n    }\n\n    /**\n     * @param type\n     */\n    private void ensureTypExists(final CombatantStatType type) {\n        if (!allData.containsKey(type)) {\n            allData.put(type, new DataSet());\n        }\n    }\n\n    private double aggregate(final CombatantStatType stat, final CombatantSide side, final DataAggregationType function) {\n        // some data may not be present in old logs (ie. since 1.29 charlevel\n        // and charclass were added)\n        if (!allData.containsKey(stat)) {\n            return 0;\n        }\n        final DataSet statData = allData.get(stat);\n        assert statData != null : \"data must be present!\";\n        return statData.aggregate(side, function);\n    }\n\n    private double getAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AVERAGE);\n    }\n\n    private double getSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.SUM);\n    }\n\n    private double getCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AMOUNT);\n    }\n\n    private double getPositiveAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AVERAGE);\n    }\n\n    private double getPositiveSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_SUM);\n    }\n\n    private double getPositiveCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AMOUNT);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfPlayers(final CombatantSide side) {\n        // just a stat that is available for all combatants\n        return (int) Math.round(getCount(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#survivedPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int survivedPlayers(final CombatantSide side) {\n        return (int) Math.round(getPositiveCount(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double initialHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageWeaponDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageWeaponDamage(final CombatantSide side) {\n        final DataSet allMinDamage = allData.get(CombatantStatType.weaponmindmg);\n        final DataSet allMaxDamage = allData.get(CombatantStatType.weaponmaxdmg);\n        if (allMinDamage == null || allMaxDamage == null) {\n            // TODO logging: LOG.warn(\"no weapon damage data available!\");\n            // no weapon data available\n            return 0;\n        }\n        // use double precision for calculating average\n        final double avgMinDamage = allMinDamage.aggregate(side, DataAggregationType.AVERAGE);\n        final double avgMaxDamage = allMaxDamage.aggregate(side, DataAggregationType.AVERAGE);\n        return (avgMinDamage + avgMaxDamage) / 2.0;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double causedDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.totalcauseddamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int shotsFiredWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side) + getSum(CombatantStatType.misscount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int hitsWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLifetime(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLifetime(final CombatantSide side) {\n        final int totalPlayers = (int) getCount(CombatantStatType.diedwhen, side);\n        if (totalPlayers == 0) {\n            return 0.0;\n        }\n        final int diedPlayers = (int) getPositiveCount(CombatantStatType.diedwhen, side);\n        final int survivedPlayers = totalPlayers - diedPlayers;\n        final double diedInRound = getPositiveAverage(CombatantStatType.diedwhen, side);\n        return (diedPlayers * diedInRound + survivedPlayers * numberOfRounds) / totalPlayers;\n    }\n\n    private int numberOfClass(final CharacterClass charClass, final CombatantSide side) {\n        final DataSet data = allData.get(CombatantStatType.charclass);\n        // only available since v1.29\n        if (data == null) {\n            return 0;\n        }\n        final Integer value = Integer.valueOf(charClass.ordinal());\n        return data.countOfValuesWith(value, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfAdventurers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfAdventurers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.ADVENTURER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfDuelants(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfDuelants(final CombatantSide side) {\n        return numberOfClass(CharacterClass.DUELANT, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfGreenhorns(CombatantSide)\n     */\n    public int numberOfGreenhorns(final CombatantSide side) {\n        return numberOfClass(CharacterClass.GREENHORN, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfSoldiers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfSoldiers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.SOLDIER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfWorkers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfWorkers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.WORKER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLevel(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLevel(final CombatantSide side) {\n        return getAverage(CombatantStatType.charlevel, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int initialHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getPositiveAverage(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getPositiveSum(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int causedDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.totalcauseddamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double shotsFiredPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side) + getAverage(CombatantStatType.misscount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double hitsPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double takenDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.takendamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int takenDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.takendamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageHitDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageHitDamage(final CombatantSide side) {\n        // don't count the misses\n        final double teamHits = hitsWholeSide(side);\n        if (teamHits == 0) {\n            return 0;\n        }\n        final double teamDamage = causedDamageWholeSide(side);\n        final double totalCalculated = teamDamage / teamHits;\n        return totalCalculated;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double dodgesPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.dodgecount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int dodgesWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.dodgecount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistribution(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Number> healthDistribution(final CombatantSide side) {\n        // initialize map\n        final SortedMap<Number, Number> result = new TreeMap<Number, Number>();\n        final int maxHP = 14000;\n        final int step = 1000;\n        for (int limit = step; limit <= maxHP; limit += step) {\n            result.put(Integer.valueOf(limit), new AtomicInteger());\n        }\n        // fill with values\n        final CombatantStatType stat = CombatantStatType.starthp;\n        if (allData.containsKey(stat)) {\n            final DataSet statData = allData.get(stat);\n            final List<Integer> data = statData.getSideData(side);\n            for (final Integer value : data) {\n                Number key = getUpperLimit(value.intValue(), step);\n                if (!result.containsKey(key)) {\n                    // out of range, put it to the last value\n                    key = result.lastKey();\n                }\n                ((AtomicInteger) result.get(key)).incrementAndGet();\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistributionRelative(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Double> healthDistributionRelative(final CombatantSide side) {\n        final SortedMap<Number, Number> distribution = healthDistribution(side);\n        final TreeMap<Number, Double> result = new TreeMap<Number, Double>();\n        final double totalPlayers = numberOfPlayers(side);\n        for (final Entry<Number, Number> mapping : distribution.entrySet()) {\n            final double currentPlayers = mapping.getValue().doubleValue();\n            final Double percentage = Double.valueOf(currentPlayers / totalPlayers * 100.0);\n            result.put(mapping.getKey(), percentage);\n        }\n        return result;\n    }\n\n    /**\n     * @param value\n     * @param step\n     * @return\n     */\n    private Number getUpperLimit(final int value, final int step) {\n        int limit = 0;\n        while (value > limit) {\n            limit += step;\n        }\n        return Integer.valueOf(limit);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/CombatantStatistic_13Test.java",
		"test_prompt": "// CombatantStatistic_13Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CombatantStatistic}.\n* It contains ten unit test cases for the {@link CombatantStatistic#averageLevel(CombatantSide)} method.\n*/\nclass CombatantStatistic_13Test {"
	},
	{
		"original_code": "// CombatantStatistic.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\n\n/**\n * A statistic for combatants\n *\n * TODO use separate classes for calculating and storing the statistics, so\n * statistics i.e. can be serialized\n *\n * @author daniel\n */\npublic class CombatantStatistic implements StaticStatistics {\n\n    private final int numberOfRounds;\n\n    private final Map<CombatantStatType, DataSet> allData = new HashMap<CombatantStatType, DataSet>();\n\n    /**\n     * create statistics for the given number of rounds.\n     *\n     * @param numberOfRounds\n     */\n    public CombatantStatistic(final int numberOfRounds) {\n        this.numberOfRounds = numberOfRounds;\n    }\n\n    /**\n     * @param type\n     *            what kind of data is given as value?\n     * @param side\n     *            at which the combatant of the value fights\n     * @param value\n     */\n    public void addData(final CombatantStatType type, final CombatantSide side, final int value) {\n        ensureTypExists(type);\n        final Integer storedValue;\n        // fix class, because in the data it starts at -1 but we start with 0\n        if (type == CombatantStatType.charclass) {\n            storedValue = Integer.valueOf(value + 1);\n        } else {\n            storedValue = Integer.valueOf(value);\n        }\n        allData.get(type).addData(side, storedValue);\n    }\n\n    /**\n     * @param type\n     */\n    private void ensureTypExists(final CombatantStatType type) {\n        if (!allData.containsKey(type)) {\n            allData.put(type, new DataSet());\n        }\n    }\n\n    private double aggregate(final CombatantStatType stat, final CombatantSide side, final DataAggregationType function) {\n        // some data may not be present in old logs (ie. since 1.29 charlevel\n        // and charclass were added)\n        if (!allData.containsKey(stat)) {\n            return 0;\n        }\n        final DataSet statData = allData.get(stat);\n        assert statData != null : \"data must be present!\";\n        return statData.aggregate(side, function);\n    }\n\n    private double getAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AVERAGE);\n    }\n\n    private double getSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.SUM);\n    }\n\n    private double getCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AMOUNT);\n    }\n\n    private double getPositiveAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AVERAGE);\n    }\n\n    private double getPositiveSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_SUM);\n    }\n\n    private double getPositiveCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AMOUNT);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfPlayers(final CombatantSide side) {\n        // just a stat that is available for all combatants\n        return (int) Math.round(getCount(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#survivedPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int survivedPlayers(final CombatantSide side) {\n        return (int) Math.round(getPositiveCount(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double initialHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageWeaponDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageWeaponDamage(final CombatantSide side) {\n        final DataSet allMinDamage = allData.get(CombatantStatType.weaponmindmg);\n        final DataSet allMaxDamage = allData.get(CombatantStatType.weaponmaxdmg);\n        if (allMinDamage == null || allMaxDamage == null) {\n            // TODO logging: LOG.warn(\"no weapon damage data available!\");\n            // no weapon data available\n            return 0;\n        }\n        // use double precision for calculating average\n        final double avgMinDamage = allMinDamage.aggregate(side, DataAggregationType.AVERAGE);\n        final double avgMaxDamage = allMaxDamage.aggregate(side, DataAggregationType.AVERAGE);\n        return (avgMinDamage + avgMaxDamage) / 2.0;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double causedDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.totalcauseddamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int shotsFiredWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side) + getSum(CombatantStatType.misscount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int hitsWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLifetime(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLifetime(final CombatantSide side) {\n        final int totalPlayers = (int) getCount(CombatantStatType.diedwhen, side);\n        if (totalPlayers == 0) {\n            return 0.0;\n        }\n        final int diedPlayers = (int) getPositiveCount(CombatantStatType.diedwhen, side);\n        final int survivedPlayers = totalPlayers - diedPlayers;\n        final double diedInRound = getPositiveAverage(CombatantStatType.diedwhen, side);\n        return (diedPlayers * diedInRound + survivedPlayers * numberOfRounds) / totalPlayers;\n    }\n\n    private int numberOfClass(final CharacterClass charClass, final CombatantSide side) {\n        final DataSet data = allData.get(CombatantStatType.charclass);\n        // only available since v1.29\n        if (data == null) {\n            return 0;\n        }\n        final Integer value = Integer.valueOf(charClass.ordinal());\n        return data.countOfValuesWith(value, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfAdventurers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfAdventurers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.ADVENTURER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfDuelants(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfDuelants(final CombatantSide side) {\n        return numberOfClass(CharacterClass.DUELANT, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfGreenhorns(CombatantSide)\n     */\n    public int numberOfGreenhorns(final CombatantSide side) {\n        return numberOfClass(CharacterClass.GREENHORN, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfSoldiers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfSoldiers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.SOLDIER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfWorkers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfWorkers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.WORKER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLevel(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLevel(final CombatantSide side) {\n        return getAverage(CombatantStatType.charlevel, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int initialHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getPositiveAverage(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getPositiveSum(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int causedDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.totalcauseddamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double shotsFiredPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side) + getAverage(CombatantStatType.misscount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double hitsPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double takenDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.takendamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int takenDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.takendamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageHitDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageHitDamage(final CombatantSide side) {\n        // don't count the misses\n        final double teamHits = hitsWholeSide(side);\n        if (teamHits == 0) {\n            return 0;\n        }\n        final double teamDamage = causedDamageWholeSide(side);\n        final double totalCalculated = teamDamage / teamHits;\n        return totalCalculated;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double dodgesPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.dodgecount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int dodgesWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.dodgecount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistribution(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Number> healthDistribution(final CombatantSide side) {\n        // initialize map\n        final SortedMap<Number, Number> result = new TreeMap<Number, Number>();\n        final int maxHP = 14000;\n        final int step = 1000;\n        for (int limit = step; limit <= maxHP; limit += step) {\n            result.put(Integer.valueOf(limit), new AtomicInteger());\n        }\n        // fill with values\n        final CombatantStatType stat = CombatantStatType.starthp;\n        if (allData.containsKey(stat)) {\n            final DataSet statData = allData.get(stat);\n            final List<Integer> data = statData.getSideData(side);\n            for (final Integer value : data) {\n                Number key = getUpperLimit(value.intValue(), step);\n                if (!result.containsKey(key)) {\n                    // out of range, put it to the last value\n                    key = result.lastKey();\n                }\n                ((AtomicInteger) result.get(key)).incrementAndGet();\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistributionRelative(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Double> healthDistributionRelative(final CombatantSide side) {\n        final SortedMap<Number, Number> distribution = healthDistribution(side);\n        final TreeMap<Number, Double> result = new TreeMap<Number, Double>();\n        final double totalPlayers = numberOfPlayers(side);\n        for (final Entry<Number, Number> mapping : distribution.entrySet()) {\n            final double currentPlayers = mapping.getValue().doubleValue();\n            final Double percentage = Double.valueOf(currentPlayers / totalPlayers * 100.0);\n            result.put(mapping.getKey(), percentage);\n        }\n        return result;\n    }\n\n    /**\n     * @param value\n     * @param step\n     * @return\n     */\n    private Number getUpperLimit(final int value, final int step) {\n        int limit = 0;\n        while (value > limit) {\n            limit += step;\n        }\n        return Integer.valueOf(limit);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/CombatantStatistic_14Test.java",
		"test_prompt": "// CombatantStatistic_14Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CombatantStatistic}.\n* It contains ten unit test cases for the {@link CombatantStatistic#initialHealthWholeSide(CombatantSide)} method.\n*/\nclass CombatantStatistic_14Test {"
	},
	{
		"original_code": "// CombatantStatistic.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\n\n/**\n * A statistic for combatants\n *\n * TODO use separate classes for calculating and storing the statistics, so\n * statistics i.e. can be serialized\n *\n * @author daniel\n */\npublic class CombatantStatistic implements StaticStatistics {\n\n    private final int numberOfRounds;\n\n    private final Map<CombatantStatType, DataSet> allData = new HashMap<CombatantStatType, DataSet>();\n\n    /**\n     * create statistics for the given number of rounds.\n     *\n     * @param numberOfRounds\n     */\n    public CombatantStatistic(final int numberOfRounds) {\n        this.numberOfRounds = numberOfRounds;\n    }\n\n    /**\n     * @param type\n     *            what kind of data is given as value?\n     * @param side\n     *            at which the combatant of the value fights\n     * @param value\n     */\n    public void addData(final CombatantStatType type, final CombatantSide side, final int value) {\n        ensureTypExists(type);\n        final Integer storedValue;\n        // fix class, because in the data it starts at -1 but we start with 0\n        if (type == CombatantStatType.charclass) {\n            storedValue = Integer.valueOf(value + 1);\n        } else {\n            storedValue = Integer.valueOf(value);\n        }\n        allData.get(type).addData(side, storedValue);\n    }\n\n    /**\n     * @param type\n     */\n    private void ensureTypExists(final CombatantStatType type) {\n        if (!allData.containsKey(type)) {\n            allData.put(type, new DataSet());\n        }\n    }\n\n    private double aggregate(final CombatantStatType stat, final CombatantSide side, final DataAggregationType function) {\n        // some data may not be present in old logs (ie. since 1.29 charlevel\n        // and charclass were added)\n        if (!allData.containsKey(stat)) {\n            return 0;\n        }\n        final DataSet statData = allData.get(stat);\n        assert statData != null : \"data must be present!\";\n        return statData.aggregate(side, function);\n    }\n\n    private double getAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AVERAGE);\n    }\n\n    private double getSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.SUM);\n    }\n\n    private double getCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AMOUNT);\n    }\n\n    private double getPositiveAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AVERAGE);\n    }\n\n    private double getPositiveSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_SUM);\n    }\n\n    private double getPositiveCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AMOUNT);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfPlayers(final CombatantSide side) {\n        // just a stat that is available for all combatants\n        return (int) Math.round(getCount(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#survivedPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int survivedPlayers(final CombatantSide side) {\n        return (int) Math.round(getPositiveCount(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double initialHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageWeaponDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageWeaponDamage(final CombatantSide side) {\n        final DataSet allMinDamage = allData.get(CombatantStatType.weaponmindmg);\n        final DataSet allMaxDamage = allData.get(CombatantStatType.weaponmaxdmg);\n        if (allMinDamage == null || allMaxDamage == null) {\n            // TODO logging: LOG.warn(\"no weapon damage data available!\");\n            // no weapon data available\n            return 0;\n        }\n        // use double precision for calculating average\n        final double avgMinDamage = allMinDamage.aggregate(side, DataAggregationType.AVERAGE);\n        final double avgMaxDamage = allMaxDamage.aggregate(side, DataAggregationType.AVERAGE);\n        return (avgMinDamage + avgMaxDamage) / 2.0;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double causedDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.totalcauseddamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int shotsFiredWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side) + getSum(CombatantStatType.misscount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int hitsWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLifetime(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLifetime(final CombatantSide side) {\n        final int totalPlayers = (int) getCount(CombatantStatType.diedwhen, side);\n        if (totalPlayers == 0) {\n            return 0.0;\n        }\n        final int diedPlayers = (int) getPositiveCount(CombatantStatType.diedwhen, side);\n        final int survivedPlayers = totalPlayers - diedPlayers;\n        final double diedInRound = getPositiveAverage(CombatantStatType.diedwhen, side);\n        return (diedPlayers * diedInRound + survivedPlayers * numberOfRounds) / totalPlayers;\n    }\n\n    private int numberOfClass(final CharacterClass charClass, final CombatantSide side) {\n        final DataSet data = allData.get(CombatantStatType.charclass);\n        // only available since v1.29\n        if (data == null) {\n            return 0;\n        }\n        final Integer value = Integer.valueOf(charClass.ordinal());\n        return data.countOfValuesWith(value, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfAdventurers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfAdventurers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.ADVENTURER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfDuelants(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfDuelants(final CombatantSide side) {\n        return numberOfClass(CharacterClass.DUELANT, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfGreenhorns(CombatantSide)\n     */\n    public int numberOfGreenhorns(final CombatantSide side) {\n        return numberOfClass(CharacterClass.GREENHORN, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfSoldiers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfSoldiers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.SOLDIER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfWorkers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfWorkers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.WORKER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLevel(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLevel(final CombatantSide side) {\n        return getAverage(CombatantStatType.charlevel, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int initialHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getPositiveAverage(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getPositiveSum(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int causedDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.totalcauseddamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double shotsFiredPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side) + getAverage(CombatantStatType.misscount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double hitsPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double takenDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.takendamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int takenDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.takendamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageHitDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageHitDamage(final CombatantSide side) {\n        // don't count the misses\n        final double teamHits = hitsWholeSide(side);\n        if (teamHits == 0) {\n            return 0;\n        }\n        final double teamDamage = causedDamageWholeSide(side);\n        final double totalCalculated = teamDamage / teamHits;\n        return totalCalculated;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double dodgesPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.dodgecount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int dodgesWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.dodgecount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistribution(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Number> healthDistribution(final CombatantSide side) {\n        // initialize map\n        final SortedMap<Number, Number> result = new TreeMap<Number, Number>();\n        final int maxHP = 14000;\n        final int step = 1000;\n        for (int limit = step; limit <= maxHP; limit += step) {\n            result.put(Integer.valueOf(limit), new AtomicInteger());\n        }\n        // fill with values\n        final CombatantStatType stat = CombatantStatType.starthp;\n        if (allData.containsKey(stat)) {\n            final DataSet statData = allData.get(stat);\n            final List<Integer> data = statData.getSideData(side);\n            for (final Integer value : data) {\n                Number key = getUpperLimit(value.intValue(), step);\n                if (!result.containsKey(key)) {\n                    // out of range, put it to the last value\n                    key = result.lastKey();\n                }\n                ((AtomicInteger) result.get(key)).incrementAndGet();\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistributionRelative(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Double> healthDistributionRelative(final CombatantSide side) {\n        final SortedMap<Number, Number> distribution = healthDistribution(side);\n        final TreeMap<Number, Double> result = new TreeMap<Number, Double>();\n        final double totalPlayers = numberOfPlayers(side);\n        for (final Entry<Number, Number> mapping : distribution.entrySet()) {\n            final double currentPlayers = mapping.getValue().doubleValue();\n            final Double percentage = Double.valueOf(currentPlayers / totalPlayers * 100.0);\n            result.put(mapping.getKey(), percentage);\n        }\n        return result;\n    }\n\n    /**\n     * @param value\n     * @param step\n     * @return\n     */\n    private Number getUpperLimit(final int value, final int step) {\n        int limit = 0;\n        while (value > limit) {\n            limit += step;\n        }\n        return Integer.valueOf(limit);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/CombatantStatistic_15Test.java",
		"test_prompt": "// CombatantStatistic_15Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CombatantStatistic}.\n* It contains ten unit test cases for the {@link CombatantStatistic#endHealthPerPlayer(CombatantSide)} method.\n*/\nclass CombatantStatistic_15Test {"
	},
	{
		"original_code": "// CombatantStatistic.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\n\n/**\n * A statistic for combatants\n *\n * TODO use separate classes for calculating and storing the statistics, so\n * statistics i.e. can be serialized\n *\n * @author daniel\n */\npublic class CombatantStatistic implements StaticStatistics {\n\n    private final int numberOfRounds;\n\n    private final Map<CombatantStatType, DataSet> allData = new HashMap<CombatantStatType, DataSet>();\n\n    /**\n     * create statistics for the given number of rounds.\n     *\n     * @param numberOfRounds\n     */\n    public CombatantStatistic(final int numberOfRounds) {\n        this.numberOfRounds = numberOfRounds;\n    }\n\n    /**\n     * @param type\n     *            what kind of data is given as value?\n     * @param side\n     *            at which the combatant of the value fights\n     * @param value\n     */\n    public void addData(final CombatantStatType type, final CombatantSide side, final int value) {\n        ensureTypExists(type);\n        final Integer storedValue;\n        // fix class, because in the data it starts at -1 but we start with 0\n        if (type == CombatantStatType.charclass) {\n            storedValue = Integer.valueOf(value + 1);\n        } else {\n            storedValue = Integer.valueOf(value);\n        }\n        allData.get(type).addData(side, storedValue);\n    }\n\n    /**\n     * @param type\n     */\n    private void ensureTypExists(final CombatantStatType type) {\n        if (!allData.containsKey(type)) {\n            allData.put(type, new DataSet());\n        }\n    }\n\n    private double aggregate(final CombatantStatType stat, final CombatantSide side, final DataAggregationType function) {\n        // some data may not be present in old logs (ie. since 1.29 charlevel\n        // and charclass were added)\n        if (!allData.containsKey(stat)) {\n            return 0;\n        }\n        final DataSet statData = allData.get(stat);\n        assert statData != null : \"data must be present!\";\n        return statData.aggregate(side, function);\n    }\n\n    private double getAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AVERAGE);\n    }\n\n    private double getSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.SUM);\n    }\n\n    private double getCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AMOUNT);\n    }\n\n    private double getPositiveAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AVERAGE);\n    }\n\n    private double getPositiveSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_SUM);\n    }\n\n    private double getPositiveCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AMOUNT);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfPlayers(final CombatantSide side) {\n        // just a stat that is available for all combatants\n        return (int) Math.round(getCount(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#survivedPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int survivedPlayers(final CombatantSide side) {\n        return (int) Math.round(getPositiveCount(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double initialHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageWeaponDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageWeaponDamage(final CombatantSide side) {\n        final DataSet allMinDamage = allData.get(CombatantStatType.weaponmindmg);\n        final DataSet allMaxDamage = allData.get(CombatantStatType.weaponmaxdmg);\n        if (allMinDamage == null || allMaxDamage == null) {\n            // TODO logging: LOG.warn(\"no weapon damage data available!\");\n            // no weapon data available\n            return 0;\n        }\n        // use double precision for calculating average\n        final double avgMinDamage = allMinDamage.aggregate(side, DataAggregationType.AVERAGE);\n        final double avgMaxDamage = allMaxDamage.aggregate(side, DataAggregationType.AVERAGE);\n        return (avgMinDamage + avgMaxDamage) / 2.0;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double causedDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.totalcauseddamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int shotsFiredWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side) + getSum(CombatantStatType.misscount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int hitsWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLifetime(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLifetime(final CombatantSide side) {\n        final int totalPlayers = (int) getCount(CombatantStatType.diedwhen, side);\n        if (totalPlayers == 0) {\n            return 0.0;\n        }\n        final int diedPlayers = (int) getPositiveCount(CombatantStatType.diedwhen, side);\n        final int survivedPlayers = totalPlayers - diedPlayers;\n        final double diedInRound = getPositiveAverage(CombatantStatType.diedwhen, side);\n        return (diedPlayers * diedInRound + survivedPlayers * numberOfRounds) / totalPlayers;\n    }\n\n    private int numberOfClass(final CharacterClass charClass, final CombatantSide side) {\n        final DataSet data = allData.get(CombatantStatType.charclass);\n        // only available since v1.29\n        if (data == null) {\n            return 0;\n        }\n        final Integer value = Integer.valueOf(charClass.ordinal());\n        return data.countOfValuesWith(value, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfAdventurers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfAdventurers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.ADVENTURER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfDuelants(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfDuelants(final CombatantSide side) {\n        return numberOfClass(CharacterClass.DUELANT, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfGreenhorns(CombatantSide)\n     */\n    public int numberOfGreenhorns(final CombatantSide side) {\n        return numberOfClass(CharacterClass.GREENHORN, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfSoldiers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfSoldiers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.SOLDIER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfWorkers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfWorkers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.WORKER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLevel(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLevel(final CombatantSide side) {\n        return getAverage(CombatantStatType.charlevel, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int initialHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getPositiveAverage(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getPositiveSum(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int causedDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.totalcauseddamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double shotsFiredPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side) + getAverage(CombatantStatType.misscount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double hitsPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double takenDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.takendamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int takenDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.takendamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageHitDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageHitDamage(final CombatantSide side) {\n        // don't count the misses\n        final double teamHits = hitsWholeSide(side);\n        if (teamHits == 0) {\n            return 0;\n        }\n        final double teamDamage = causedDamageWholeSide(side);\n        final double totalCalculated = teamDamage / teamHits;\n        return totalCalculated;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double dodgesPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.dodgecount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int dodgesWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.dodgecount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistribution(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Number> healthDistribution(final CombatantSide side) {\n        // initialize map\n        final SortedMap<Number, Number> result = new TreeMap<Number, Number>();\n        final int maxHP = 14000;\n        final int step = 1000;\n        for (int limit = step; limit <= maxHP; limit += step) {\n            result.put(Integer.valueOf(limit), new AtomicInteger());\n        }\n        // fill with values\n        final CombatantStatType stat = CombatantStatType.starthp;\n        if (allData.containsKey(stat)) {\n            final DataSet statData = allData.get(stat);\n            final List<Integer> data = statData.getSideData(side);\n            for (final Integer value : data) {\n                Number key = getUpperLimit(value.intValue(), step);\n                if (!result.containsKey(key)) {\n                    // out of range, put it to the last value\n                    key = result.lastKey();\n                }\n                ((AtomicInteger) result.get(key)).incrementAndGet();\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistributionRelative(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Double> healthDistributionRelative(final CombatantSide side) {\n        final SortedMap<Number, Number> distribution = healthDistribution(side);\n        final TreeMap<Number, Double> result = new TreeMap<Number, Double>();\n        final double totalPlayers = numberOfPlayers(side);\n        for (final Entry<Number, Number> mapping : distribution.entrySet()) {\n            final double currentPlayers = mapping.getValue().doubleValue();\n            final Double percentage = Double.valueOf(currentPlayers / totalPlayers * 100.0);\n            result.put(mapping.getKey(), percentage);\n        }\n        return result;\n    }\n\n    /**\n     * @param value\n     * @param step\n     * @return\n     */\n    private Number getUpperLimit(final int value, final int step) {\n        int limit = 0;\n        while (value > limit) {\n            limit += step;\n        }\n        return Integer.valueOf(limit);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/CombatantStatistic_16Test.java",
		"test_prompt": "// CombatantStatistic_16Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CombatantStatistic}.\n* It contains ten unit test cases for the {@link CombatantStatistic#endHealthWholeSide(CombatantSide)} method.\n*/\nclass CombatantStatistic_16Test {"
	},
	{
		"original_code": "// CombatantStatistic.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\n\n/**\n * A statistic for combatants\n *\n * TODO use separate classes for calculating and storing the statistics, so\n * statistics i.e. can be serialized\n *\n * @author daniel\n */\npublic class CombatantStatistic implements StaticStatistics {\n\n    private final int numberOfRounds;\n\n    private final Map<CombatantStatType, DataSet> allData = new HashMap<CombatantStatType, DataSet>();\n\n    /**\n     * create statistics for the given number of rounds.\n     *\n     * @param numberOfRounds\n     */\n    public CombatantStatistic(final int numberOfRounds) {\n        this.numberOfRounds = numberOfRounds;\n    }\n\n    /**\n     * @param type\n     *            what kind of data is given as value?\n     * @param side\n     *            at which the combatant of the value fights\n     * @param value\n     */\n    public void addData(final CombatantStatType type, final CombatantSide side, final int value) {\n        ensureTypExists(type);\n        final Integer storedValue;\n        // fix class, because in the data it starts at -1 but we start with 0\n        if (type == CombatantStatType.charclass) {\n            storedValue = Integer.valueOf(value + 1);\n        } else {\n            storedValue = Integer.valueOf(value);\n        }\n        allData.get(type).addData(side, storedValue);\n    }\n\n    /**\n     * @param type\n     */\n    private void ensureTypExists(final CombatantStatType type) {\n        if (!allData.containsKey(type)) {\n            allData.put(type, new DataSet());\n        }\n    }\n\n    private double aggregate(final CombatantStatType stat, final CombatantSide side, final DataAggregationType function) {\n        // some data may not be present in old logs (ie. since 1.29 charlevel\n        // and charclass were added)\n        if (!allData.containsKey(stat)) {\n            return 0;\n        }\n        final DataSet statData = allData.get(stat);\n        assert statData != null : \"data must be present!\";\n        return statData.aggregate(side, function);\n    }\n\n    private double getAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AVERAGE);\n    }\n\n    private double getSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.SUM);\n    }\n\n    private double getCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AMOUNT);\n    }\n\n    private double getPositiveAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AVERAGE);\n    }\n\n    private double getPositiveSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_SUM);\n    }\n\n    private double getPositiveCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AMOUNT);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfPlayers(final CombatantSide side) {\n        // just a stat that is available for all combatants\n        return (int) Math.round(getCount(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#survivedPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int survivedPlayers(final CombatantSide side) {\n        return (int) Math.round(getPositiveCount(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double initialHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageWeaponDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageWeaponDamage(final CombatantSide side) {\n        final DataSet allMinDamage = allData.get(CombatantStatType.weaponmindmg);\n        final DataSet allMaxDamage = allData.get(CombatantStatType.weaponmaxdmg);\n        if (allMinDamage == null || allMaxDamage == null) {\n            // TODO logging: LOG.warn(\"no weapon damage data available!\");\n            // no weapon data available\n            return 0;\n        }\n        // use double precision for calculating average\n        final double avgMinDamage = allMinDamage.aggregate(side, DataAggregationType.AVERAGE);\n        final double avgMaxDamage = allMaxDamage.aggregate(side, DataAggregationType.AVERAGE);\n        return (avgMinDamage + avgMaxDamage) / 2.0;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double causedDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.totalcauseddamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int shotsFiredWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side) + getSum(CombatantStatType.misscount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int hitsWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLifetime(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLifetime(final CombatantSide side) {\n        final int totalPlayers = (int) getCount(CombatantStatType.diedwhen, side);\n        if (totalPlayers == 0) {\n            return 0.0;\n        }\n        final int diedPlayers = (int) getPositiveCount(CombatantStatType.diedwhen, side);\n        final int survivedPlayers = totalPlayers - diedPlayers;\n        final double diedInRound = getPositiveAverage(CombatantStatType.diedwhen, side);\n        return (diedPlayers * diedInRound + survivedPlayers * numberOfRounds) / totalPlayers;\n    }\n\n    private int numberOfClass(final CharacterClass charClass, final CombatantSide side) {\n        final DataSet data = allData.get(CombatantStatType.charclass);\n        // only available since v1.29\n        if (data == null) {\n            return 0;\n        }\n        final Integer value = Integer.valueOf(charClass.ordinal());\n        return data.countOfValuesWith(value, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfAdventurers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfAdventurers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.ADVENTURER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfDuelants(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfDuelants(final CombatantSide side) {\n        return numberOfClass(CharacterClass.DUELANT, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfGreenhorns(CombatantSide)\n     */\n    public int numberOfGreenhorns(final CombatantSide side) {\n        return numberOfClass(CharacterClass.GREENHORN, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfSoldiers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfSoldiers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.SOLDIER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfWorkers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfWorkers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.WORKER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLevel(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLevel(final CombatantSide side) {\n        return getAverage(CombatantStatType.charlevel, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int initialHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getPositiveAverage(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getPositiveSum(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int causedDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.totalcauseddamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double shotsFiredPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side) + getAverage(CombatantStatType.misscount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double hitsPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double takenDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.takendamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int takenDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.takendamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageHitDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageHitDamage(final CombatantSide side) {\n        // don't count the misses\n        final double teamHits = hitsWholeSide(side);\n        if (teamHits == 0) {\n            return 0;\n        }\n        final double teamDamage = causedDamageWholeSide(side);\n        final double totalCalculated = teamDamage / teamHits;\n        return totalCalculated;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double dodgesPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.dodgecount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int dodgesWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.dodgecount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistribution(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Number> healthDistribution(final CombatantSide side) {\n        // initialize map\n        final SortedMap<Number, Number> result = new TreeMap<Number, Number>();\n        final int maxHP = 14000;\n        final int step = 1000;\n        for (int limit = step; limit <= maxHP; limit += step) {\n            result.put(Integer.valueOf(limit), new AtomicInteger());\n        }\n        // fill with values\n        final CombatantStatType stat = CombatantStatType.starthp;\n        if (allData.containsKey(stat)) {\n            final DataSet statData = allData.get(stat);\n            final List<Integer> data = statData.getSideData(side);\n            for (final Integer value : data) {\n                Number key = getUpperLimit(value.intValue(), step);\n                if (!result.containsKey(key)) {\n                    // out of range, put it to the last value\n                    key = result.lastKey();\n                }\n                ((AtomicInteger) result.get(key)).incrementAndGet();\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistributionRelative(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Double> healthDistributionRelative(final CombatantSide side) {\n        final SortedMap<Number, Number> distribution = healthDistribution(side);\n        final TreeMap<Number, Double> result = new TreeMap<Number, Double>();\n        final double totalPlayers = numberOfPlayers(side);\n        for (final Entry<Number, Number> mapping : distribution.entrySet()) {\n            final double currentPlayers = mapping.getValue().doubleValue();\n            final Double percentage = Double.valueOf(currentPlayers / totalPlayers * 100.0);\n            result.put(mapping.getKey(), percentage);\n        }\n        return result;\n    }\n\n    /**\n     * @param value\n     * @param step\n     * @return\n     */\n    private Number getUpperLimit(final int value, final int step) {\n        int limit = 0;\n        while (value > limit) {\n            limit += step;\n        }\n        return Integer.valueOf(limit);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/CombatantStatistic_17Test.java",
		"test_prompt": "// CombatantStatistic_17Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CombatantStatistic}.\n* It contains ten unit test cases for the {@link CombatantStatistic#maxPossibleHealthPerPlayer(CombatantSide)} method.\n*/\nclass CombatantStatistic_17Test {"
	},
	{
		"original_code": "// CombatantStatistic.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\n\n/**\n * A statistic for combatants\n *\n * TODO use separate classes for calculating and storing the statistics, so\n * statistics i.e. can be serialized\n *\n * @author daniel\n */\npublic class CombatantStatistic implements StaticStatistics {\n\n    private final int numberOfRounds;\n\n    private final Map<CombatantStatType, DataSet> allData = new HashMap<CombatantStatType, DataSet>();\n\n    /**\n     * create statistics for the given number of rounds.\n     *\n     * @param numberOfRounds\n     */\n    public CombatantStatistic(final int numberOfRounds) {\n        this.numberOfRounds = numberOfRounds;\n    }\n\n    /**\n     * @param type\n     *            what kind of data is given as value?\n     * @param side\n     *            at which the combatant of the value fights\n     * @param value\n     */\n    public void addData(final CombatantStatType type, final CombatantSide side, final int value) {\n        ensureTypExists(type);\n        final Integer storedValue;\n        // fix class, because in the data it starts at -1 but we start with 0\n        if (type == CombatantStatType.charclass) {\n            storedValue = Integer.valueOf(value + 1);\n        } else {\n            storedValue = Integer.valueOf(value);\n        }\n        allData.get(type).addData(side, storedValue);\n    }\n\n    /**\n     * @param type\n     */\n    private void ensureTypExists(final CombatantStatType type) {\n        if (!allData.containsKey(type)) {\n            allData.put(type, new DataSet());\n        }\n    }\n\n    private double aggregate(final CombatantStatType stat, final CombatantSide side, final DataAggregationType function) {\n        // some data may not be present in old logs (ie. since 1.29 charlevel\n        // and charclass were added)\n        if (!allData.containsKey(stat)) {\n            return 0;\n        }\n        final DataSet statData = allData.get(stat);\n        assert statData != null : \"data must be present!\";\n        return statData.aggregate(side, function);\n    }\n\n    private double getAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AVERAGE);\n    }\n\n    private double getSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.SUM);\n    }\n\n    private double getCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AMOUNT);\n    }\n\n    private double getPositiveAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AVERAGE);\n    }\n\n    private double getPositiveSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_SUM);\n    }\n\n    private double getPositiveCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AMOUNT);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfPlayers(final CombatantSide side) {\n        // just a stat that is available for all combatants\n        return (int) Math.round(getCount(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#survivedPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int survivedPlayers(final CombatantSide side) {\n        return (int) Math.round(getPositiveCount(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double initialHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageWeaponDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageWeaponDamage(final CombatantSide side) {\n        final DataSet allMinDamage = allData.get(CombatantStatType.weaponmindmg);\n        final DataSet allMaxDamage = allData.get(CombatantStatType.weaponmaxdmg);\n        if (allMinDamage == null || allMaxDamage == null) {\n            // TODO logging: LOG.warn(\"no weapon damage data available!\");\n            // no weapon data available\n            return 0;\n        }\n        // use double precision for calculating average\n        final double avgMinDamage = allMinDamage.aggregate(side, DataAggregationType.AVERAGE);\n        final double avgMaxDamage = allMaxDamage.aggregate(side, DataAggregationType.AVERAGE);\n        return (avgMinDamage + avgMaxDamage) / 2.0;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double causedDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.totalcauseddamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int shotsFiredWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side) + getSum(CombatantStatType.misscount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int hitsWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLifetime(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLifetime(final CombatantSide side) {\n        final int totalPlayers = (int) getCount(CombatantStatType.diedwhen, side);\n        if (totalPlayers == 0) {\n            return 0.0;\n        }\n        final int diedPlayers = (int) getPositiveCount(CombatantStatType.diedwhen, side);\n        final int survivedPlayers = totalPlayers - diedPlayers;\n        final double diedInRound = getPositiveAverage(CombatantStatType.diedwhen, side);\n        return (diedPlayers * diedInRound + survivedPlayers * numberOfRounds) / totalPlayers;\n    }\n\n    private int numberOfClass(final CharacterClass charClass, final CombatantSide side) {\n        final DataSet data = allData.get(CombatantStatType.charclass);\n        // only available since v1.29\n        if (data == null) {\n            return 0;\n        }\n        final Integer value = Integer.valueOf(charClass.ordinal());\n        return data.countOfValuesWith(value, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfAdventurers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfAdventurers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.ADVENTURER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfDuelants(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfDuelants(final CombatantSide side) {\n        return numberOfClass(CharacterClass.DUELANT, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfGreenhorns(CombatantSide)\n     */\n    public int numberOfGreenhorns(final CombatantSide side) {\n        return numberOfClass(CharacterClass.GREENHORN, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfSoldiers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfSoldiers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.SOLDIER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfWorkers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfWorkers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.WORKER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLevel(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLevel(final CombatantSide side) {\n        return getAverage(CombatantStatType.charlevel, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int initialHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getPositiveAverage(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getPositiveSum(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int causedDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.totalcauseddamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double shotsFiredPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side) + getAverage(CombatantStatType.misscount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double hitsPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double takenDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.takendamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int takenDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.takendamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageHitDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageHitDamage(final CombatantSide side) {\n        // don't count the misses\n        final double teamHits = hitsWholeSide(side);\n        if (teamHits == 0) {\n            return 0;\n        }\n        final double teamDamage = causedDamageWholeSide(side);\n        final double totalCalculated = teamDamage / teamHits;\n        return totalCalculated;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double dodgesPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.dodgecount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int dodgesWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.dodgecount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistribution(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Number> healthDistribution(final CombatantSide side) {\n        // initialize map\n        final SortedMap<Number, Number> result = new TreeMap<Number, Number>();\n        final int maxHP = 14000;\n        final int step = 1000;\n        for (int limit = step; limit <= maxHP; limit += step) {\n            result.put(Integer.valueOf(limit), new AtomicInteger());\n        }\n        // fill with values\n        final CombatantStatType stat = CombatantStatType.starthp;\n        if (allData.containsKey(stat)) {\n            final DataSet statData = allData.get(stat);\n            final List<Integer> data = statData.getSideData(side);\n            for (final Integer value : data) {\n                Number key = getUpperLimit(value.intValue(), step);\n                if (!result.containsKey(key)) {\n                    // out of range, put it to the last value\n                    key = result.lastKey();\n                }\n                ((AtomicInteger) result.get(key)).incrementAndGet();\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistributionRelative(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Double> healthDistributionRelative(final CombatantSide side) {\n        final SortedMap<Number, Number> distribution = healthDistribution(side);\n        final TreeMap<Number, Double> result = new TreeMap<Number, Double>();\n        final double totalPlayers = numberOfPlayers(side);\n        for (final Entry<Number, Number> mapping : distribution.entrySet()) {\n            final double currentPlayers = mapping.getValue().doubleValue();\n            final Double percentage = Double.valueOf(currentPlayers / totalPlayers * 100.0);\n            result.put(mapping.getKey(), percentage);\n        }\n        return result;\n    }\n\n    /**\n     * @param value\n     * @param step\n     * @return\n     */\n    private Number getUpperLimit(final int value, final int step) {\n        int limit = 0;\n        while (value > limit) {\n            limit += step;\n        }\n        return Integer.valueOf(limit);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/CombatantStatistic_18Test.java",
		"test_prompt": "// CombatantStatistic_18Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CombatantStatistic}.\n* It contains ten unit test cases for the {@link CombatantStatistic#maxPossibleHealthWholeSide(CombatantSide)} method.\n*/\nclass CombatantStatistic_18Test {"
	},
	{
		"original_code": "// CombatantStatistic.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\n\n/**\n * A statistic for combatants\n *\n * TODO use separate classes for calculating and storing the statistics, so\n * statistics i.e. can be serialized\n *\n * @author daniel\n */\npublic class CombatantStatistic implements StaticStatistics {\n\n    private final int numberOfRounds;\n\n    private final Map<CombatantStatType, DataSet> allData = new HashMap<CombatantStatType, DataSet>();\n\n    /**\n     * create statistics for the given number of rounds.\n     *\n     * @param numberOfRounds\n     */\n    public CombatantStatistic(final int numberOfRounds) {\n        this.numberOfRounds = numberOfRounds;\n    }\n\n    /**\n     * @param type\n     *            what kind of data is given as value?\n     * @param side\n     *            at which the combatant of the value fights\n     * @param value\n     */\n    public void addData(final CombatantStatType type, final CombatantSide side, final int value) {\n        ensureTypExists(type);\n        final Integer storedValue;\n        // fix class, because in the data it starts at -1 but we start with 0\n        if (type == CombatantStatType.charclass) {\n            storedValue = Integer.valueOf(value + 1);\n        } else {\n            storedValue = Integer.valueOf(value);\n        }\n        allData.get(type).addData(side, storedValue);\n    }\n\n    /**\n     * @param type\n     */\n    private void ensureTypExists(final CombatantStatType type) {\n        if (!allData.containsKey(type)) {\n            allData.put(type, new DataSet());\n        }\n    }\n\n    private double aggregate(final CombatantStatType stat, final CombatantSide side, final DataAggregationType function) {\n        // some data may not be present in old logs (ie. since 1.29 charlevel\n        // and charclass were added)\n        if (!allData.containsKey(stat)) {\n            return 0;\n        }\n        final DataSet statData = allData.get(stat);\n        assert statData != null : \"data must be present!\";\n        return statData.aggregate(side, function);\n    }\n\n    private double getAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AVERAGE);\n    }\n\n    private double getSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.SUM);\n    }\n\n    private double getCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AMOUNT);\n    }\n\n    private double getPositiveAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AVERAGE);\n    }\n\n    private double getPositiveSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_SUM);\n    }\n\n    private double getPositiveCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AMOUNT);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfPlayers(final CombatantSide side) {\n        // just a stat that is available for all combatants\n        return (int) Math.round(getCount(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#survivedPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int survivedPlayers(final CombatantSide side) {\n        return (int) Math.round(getPositiveCount(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double initialHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageWeaponDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageWeaponDamage(final CombatantSide side) {\n        final DataSet allMinDamage = allData.get(CombatantStatType.weaponmindmg);\n        final DataSet allMaxDamage = allData.get(CombatantStatType.weaponmaxdmg);\n        if (allMinDamage == null || allMaxDamage == null) {\n            // TODO logging: LOG.warn(\"no weapon damage data available!\");\n            // no weapon data available\n            return 0;\n        }\n        // use double precision for calculating average\n        final double avgMinDamage = allMinDamage.aggregate(side, DataAggregationType.AVERAGE);\n        final double avgMaxDamage = allMaxDamage.aggregate(side, DataAggregationType.AVERAGE);\n        return (avgMinDamage + avgMaxDamage) / 2.0;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double causedDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.totalcauseddamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int shotsFiredWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side) + getSum(CombatantStatType.misscount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int hitsWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLifetime(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLifetime(final CombatantSide side) {\n        final int totalPlayers = (int) getCount(CombatantStatType.diedwhen, side);\n        if (totalPlayers == 0) {\n            return 0.0;\n        }\n        final int diedPlayers = (int) getPositiveCount(CombatantStatType.diedwhen, side);\n        final int survivedPlayers = totalPlayers - diedPlayers;\n        final double diedInRound = getPositiveAverage(CombatantStatType.diedwhen, side);\n        return (diedPlayers * diedInRound + survivedPlayers * numberOfRounds) / totalPlayers;\n    }\n\n    private int numberOfClass(final CharacterClass charClass, final CombatantSide side) {\n        final DataSet data = allData.get(CombatantStatType.charclass);\n        // only available since v1.29\n        if (data == null) {\n            return 0;\n        }\n        final Integer value = Integer.valueOf(charClass.ordinal());\n        return data.countOfValuesWith(value, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfAdventurers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfAdventurers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.ADVENTURER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfDuelants(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfDuelants(final CombatantSide side) {\n        return numberOfClass(CharacterClass.DUELANT, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfGreenhorns(CombatantSide)\n     */\n    public int numberOfGreenhorns(final CombatantSide side) {\n        return numberOfClass(CharacterClass.GREENHORN, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfSoldiers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfSoldiers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.SOLDIER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfWorkers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfWorkers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.WORKER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLevel(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLevel(final CombatantSide side) {\n        return getAverage(CombatantStatType.charlevel, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int initialHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getPositiveAverage(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getPositiveSum(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int causedDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.totalcauseddamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double shotsFiredPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side) + getAverage(CombatantStatType.misscount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double hitsPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double takenDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.takendamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int takenDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.takendamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageHitDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageHitDamage(final CombatantSide side) {\n        // don't count the misses\n        final double teamHits = hitsWholeSide(side);\n        if (teamHits == 0) {\n            return 0;\n        }\n        final double teamDamage = causedDamageWholeSide(side);\n        final double totalCalculated = teamDamage / teamHits;\n        return totalCalculated;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double dodgesPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.dodgecount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int dodgesWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.dodgecount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistribution(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Number> healthDistribution(final CombatantSide side) {\n        // initialize map\n        final SortedMap<Number, Number> result = new TreeMap<Number, Number>();\n        final int maxHP = 14000;\n        final int step = 1000;\n        for (int limit = step; limit <= maxHP; limit += step) {\n            result.put(Integer.valueOf(limit), new AtomicInteger());\n        }\n        // fill with values\n        final CombatantStatType stat = CombatantStatType.starthp;\n        if (allData.containsKey(stat)) {\n            final DataSet statData = allData.get(stat);\n            final List<Integer> data = statData.getSideData(side);\n            for (final Integer value : data) {\n                Number key = getUpperLimit(value.intValue(), step);\n                if (!result.containsKey(key)) {\n                    // out of range, put it to the last value\n                    key = result.lastKey();\n                }\n                ((AtomicInteger) result.get(key)).incrementAndGet();\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistributionRelative(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Double> healthDistributionRelative(final CombatantSide side) {\n        final SortedMap<Number, Number> distribution = healthDistribution(side);\n        final TreeMap<Number, Double> result = new TreeMap<Number, Double>();\n        final double totalPlayers = numberOfPlayers(side);\n        for (final Entry<Number, Number> mapping : distribution.entrySet()) {\n            final double currentPlayers = mapping.getValue().doubleValue();\n            final Double percentage = Double.valueOf(currentPlayers / totalPlayers * 100.0);\n            result.put(mapping.getKey(), percentage);\n        }\n        return result;\n    }\n\n    /**\n     * @param value\n     * @param step\n     * @return\n     */\n    private Number getUpperLimit(final int value, final int step) {\n        int limit = 0;\n        while (value > limit) {\n            limit += step;\n        }\n        return Integer.valueOf(limit);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/CombatantStatistic_19Test.java",
		"test_prompt": "// CombatantStatistic_19Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CombatantStatistic}.\n* It contains ten unit test cases for the {@link CombatantStatistic#causedDamageWholeSide(CombatantSide)} method.\n*/\nclass CombatantStatistic_19Test {"
	},
	{
		"original_code": "// CombatantStatistic.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\n\n/**\n * A statistic for combatants\n *\n * TODO use separate classes for calculating and storing the statistics, so\n * statistics i.e. can be serialized\n *\n * @author daniel\n */\npublic class CombatantStatistic implements StaticStatistics {\n\n    private final int numberOfRounds;\n\n    private final Map<CombatantStatType, DataSet> allData = new HashMap<CombatantStatType, DataSet>();\n\n    /**\n     * create statistics for the given number of rounds.\n     *\n     * @param numberOfRounds\n     */\n    public CombatantStatistic(final int numberOfRounds) {\n        this.numberOfRounds = numberOfRounds;\n    }\n\n    /**\n     * @param type\n     *            what kind of data is given as value?\n     * @param side\n     *            at which the combatant of the value fights\n     * @param value\n     */\n    public void addData(final CombatantStatType type, final CombatantSide side, final int value) {\n        ensureTypExists(type);\n        final Integer storedValue;\n        // fix class, because in the data it starts at -1 but we start with 0\n        if (type == CombatantStatType.charclass) {\n            storedValue = Integer.valueOf(value + 1);\n        } else {\n            storedValue = Integer.valueOf(value);\n        }\n        allData.get(type).addData(side, storedValue);\n    }\n\n    /**\n     * @param type\n     */\n    private void ensureTypExists(final CombatantStatType type) {\n        if (!allData.containsKey(type)) {\n            allData.put(type, new DataSet());\n        }\n    }\n\n    private double aggregate(final CombatantStatType stat, final CombatantSide side, final DataAggregationType function) {\n        // some data may not be present in old logs (ie. since 1.29 charlevel\n        // and charclass were added)\n        if (!allData.containsKey(stat)) {\n            return 0;\n        }\n        final DataSet statData = allData.get(stat);\n        assert statData != null : \"data must be present!\";\n        return statData.aggregate(side, function);\n    }\n\n    private double getAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AVERAGE);\n    }\n\n    private double getSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.SUM);\n    }\n\n    private double getCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AMOUNT);\n    }\n\n    private double getPositiveAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AVERAGE);\n    }\n\n    private double getPositiveSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_SUM);\n    }\n\n    private double getPositiveCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AMOUNT);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfPlayers(final CombatantSide side) {\n        // just a stat that is available for all combatants\n        return (int) Math.round(getCount(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#survivedPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int survivedPlayers(final CombatantSide side) {\n        return (int) Math.round(getPositiveCount(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double initialHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageWeaponDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageWeaponDamage(final CombatantSide side) {\n        final DataSet allMinDamage = allData.get(CombatantStatType.weaponmindmg);\n        final DataSet allMaxDamage = allData.get(CombatantStatType.weaponmaxdmg);\n        if (allMinDamage == null || allMaxDamage == null) {\n            // TODO logging: LOG.warn(\"no weapon damage data available!\");\n            // no weapon data available\n            return 0;\n        }\n        // use double precision for calculating average\n        final double avgMinDamage = allMinDamage.aggregate(side, DataAggregationType.AVERAGE);\n        final double avgMaxDamage = allMaxDamage.aggregate(side, DataAggregationType.AVERAGE);\n        return (avgMinDamage + avgMaxDamage) / 2.0;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double causedDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.totalcauseddamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int shotsFiredWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side) + getSum(CombatantStatType.misscount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int hitsWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLifetime(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLifetime(final CombatantSide side) {\n        final int totalPlayers = (int) getCount(CombatantStatType.diedwhen, side);\n        if (totalPlayers == 0) {\n            return 0.0;\n        }\n        final int diedPlayers = (int) getPositiveCount(CombatantStatType.diedwhen, side);\n        final int survivedPlayers = totalPlayers - diedPlayers;\n        final double diedInRound = getPositiveAverage(CombatantStatType.diedwhen, side);\n        return (diedPlayers * diedInRound + survivedPlayers * numberOfRounds) / totalPlayers;\n    }\n\n    private int numberOfClass(final CharacterClass charClass, final CombatantSide side) {\n        final DataSet data = allData.get(CombatantStatType.charclass);\n        // only available since v1.29\n        if (data == null) {\n            return 0;\n        }\n        final Integer value = Integer.valueOf(charClass.ordinal());\n        return data.countOfValuesWith(value, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfAdventurers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfAdventurers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.ADVENTURER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfDuelants(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfDuelants(final CombatantSide side) {\n        return numberOfClass(CharacterClass.DUELANT, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfGreenhorns(CombatantSide)\n     */\n    public int numberOfGreenhorns(final CombatantSide side) {\n        return numberOfClass(CharacterClass.GREENHORN, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfSoldiers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfSoldiers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.SOLDIER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfWorkers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfWorkers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.WORKER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLevel(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLevel(final CombatantSide side) {\n        return getAverage(CombatantStatType.charlevel, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int initialHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getPositiveAverage(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getPositiveSum(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int causedDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.totalcauseddamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double shotsFiredPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side) + getAverage(CombatantStatType.misscount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double hitsPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double takenDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.takendamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int takenDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.takendamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageHitDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageHitDamage(final CombatantSide side) {\n        // don't count the misses\n        final double teamHits = hitsWholeSide(side);\n        if (teamHits == 0) {\n            return 0;\n        }\n        final double teamDamage = causedDamageWholeSide(side);\n        final double totalCalculated = teamDamage / teamHits;\n        return totalCalculated;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double dodgesPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.dodgecount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int dodgesWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.dodgecount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistribution(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Number> healthDistribution(final CombatantSide side) {\n        // initialize map\n        final SortedMap<Number, Number> result = new TreeMap<Number, Number>();\n        final int maxHP = 14000;\n        final int step = 1000;\n        for (int limit = step; limit <= maxHP; limit += step) {\n            result.put(Integer.valueOf(limit), new AtomicInteger());\n        }\n        // fill with values\n        final CombatantStatType stat = CombatantStatType.starthp;\n        if (allData.containsKey(stat)) {\n            final DataSet statData = allData.get(stat);\n            final List<Integer> data = statData.getSideData(side);\n            for (final Integer value : data) {\n                Number key = getUpperLimit(value.intValue(), step);\n                if (!result.containsKey(key)) {\n                    // out of range, put it to the last value\n                    key = result.lastKey();\n                }\n                ((AtomicInteger) result.get(key)).incrementAndGet();\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistributionRelative(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Double> healthDistributionRelative(final CombatantSide side) {\n        final SortedMap<Number, Number> distribution = healthDistribution(side);\n        final TreeMap<Number, Double> result = new TreeMap<Number, Double>();\n        final double totalPlayers = numberOfPlayers(side);\n        for (final Entry<Number, Number> mapping : distribution.entrySet()) {\n            final double currentPlayers = mapping.getValue().doubleValue();\n            final Double percentage = Double.valueOf(currentPlayers / totalPlayers * 100.0);\n            result.put(mapping.getKey(), percentage);\n        }\n        return result;\n    }\n\n    /**\n     * @param value\n     * @param step\n     * @return\n     */\n    private Number getUpperLimit(final int value, final int step) {\n        int limit = 0;\n        while (value > limit) {\n            limit += step;\n        }\n        return Integer.valueOf(limit);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/CombatantStatistic_20Test.java",
		"test_prompt": "// CombatantStatistic_20Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CombatantStatistic}.\n* It contains ten unit test cases for the {@link CombatantStatistic#shotsFiredPerPlayer(CombatantSide)} method.\n*/\nclass CombatantStatistic_20Test {"
	},
	{
		"original_code": "// CombatantStatistic.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\n\n/**\n * A statistic for combatants\n *\n * TODO use separate classes for calculating and storing the statistics, so\n * statistics i.e. can be serialized\n *\n * @author daniel\n */\npublic class CombatantStatistic implements StaticStatistics {\n\n    private final int numberOfRounds;\n\n    private final Map<CombatantStatType, DataSet> allData = new HashMap<CombatantStatType, DataSet>();\n\n    /**\n     * create statistics for the given number of rounds.\n     *\n     * @param numberOfRounds\n     */\n    public CombatantStatistic(final int numberOfRounds) {\n        this.numberOfRounds = numberOfRounds;\n    }\n\n    /**\n     * @param type\n     *            what kind of data is given as value?\n     * @param side\n     *            at which the combatant of the value fights\n     * @param value\n     */\n    public void addData(final CombatantStatType type, final CombatantSide side, final int value) {\n        ensureTypExists(type);\n        final Integer storedValue;\n        // fix class, because in the data it starts at -1 but we start with 0\n        if (type == CombatantStatType.charclass) {\n            storedValue = Integer.valueOf(value + 1);\n        } else {\n            storedValue = Integer.valueOf(value);\n        }\n        allData.get(type).addData(side, storedValue);\n    }\n\n    /**\n     * @param type\n     */\n    private void ensureTypExists(final CombatantStatType type) {\n        if (!allData.containsKey(type)) {\n            allData.put(type, new DataSet());\n        }\n    }\n\n    private double aggregate(final CombatantStatType stat, final CombatantSide side, final DataAggregationType function) {\n        // some data may not be present in old logs (ie. since 1.29 charlevel\n        // and charclass were added)\n        if (!allData.containsKey(stat)) {\n            return 0;\n        }\n        final DataSet statData = allData.get(stat);\n        assert statData != null : \"data must be present!\";\n        return statData.aggregate(side, function);\n    }\n\n    private double getAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AVERAGE);\n    }\n\n    private double getSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.SUM);\n    }\n\n    private double getCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AMOUNT);\n    }\n\n    private double getPositiveAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AVERAGE);\n    }\n\n    private double getPositiveSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_SUM);\n    }\n\n    private double getPositiveCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AMOUNT);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfPlayers(final CombatantSide side) {\n        // just a stat that is available for all combatants\n        return (int) Math.round(getCount(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#survivedPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int survivedPlayers(final CombatantSide side) {\n        return (int) Math.round(getPositiveCount(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double initialHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageWeaponDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageWeaponDamage(final CombatantSide side) {\n        final DataSet allMinDamage = allData.get(CombatantStatType.weaponmindmg);\n        final DataSet allMaxDamage = allData.get(CombatantStatType.weaponmaxdmg);\n        if (allMinDamage == null || allMaxDamage == null) {\n            // TODO logging: LOG.warn(\"no weapon damage data available!\");\n            // no weapon data available\n            return 0;\n        }\n        // use double precision for calculating average\n        final double avgMinDamage = allMinDamage.aggregate(side, DataAggregationType.AVERAGE);\n        final double avgMaxDamage = allMaxDamage.aggregate(side, DataAggregationType.AVERAGE);\n        return (avgMinDamage + avgMaxDamage) / 2.0;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double causedDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.totalcauseddamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int shotsFiredWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side) + getSum(CombatantStatType.misscount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int hitsWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLifetime(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLifetime(final CombatantSide side) {\n        final int totalPlayers = (int) getCount(CombatantStatType.diedwhen, side);\n        if (totalPlayers == 0) {\n            return 0.0;\n        }\n        final int diedPlayers = (int) getPositiveCount(CombatantStatType.diedwhen, side);\n        final int survivedPlayers = totalPlayers - diedPlayers;\n        final double diedInRound = getPositiveAverage(CombatantStatType.diedwhen, side);\n        return (diedPlayers * diedInRound + survivedPlayers * numberOfRounds) / totalPlayers;\n    }\n\n    private int numberOfClass(final CharacterClass charClass, final CombatantSide side) {\n        final DataSet data = allData.get(CombatantStatType.charclass);\n        // only available since v1.29\n        if (data == null) {\n            return 0;\n        }\n        final Integer value = Integer.valueOf(charClass.ordinal());\n        return data.countOfValuesWith(value, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfAdventurers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfAdventurers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.ADVENTURER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfDuelants(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfDuelants(final CombatantSide side) {\n        return numberOfClass(CharacterClass.DUELANT, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfGreenhorns(CombatantSide)\n     */\n    public int numberOfGreenhorns(final CombatantSide side) {\n        return numberOfClass(CharacterClass.GREENHORN, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfSoldiers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfSoldiers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.SOLDIER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfWorkers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfWorkers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.WORKER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLevel(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLevel(final CombatantSide side) {\n        return getAverage(CombatantStatType.charlevel, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int initialHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getPositiveAverage(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getPositiveSum(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int causedDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.totalcauseddamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double shotsFiredPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side) + getAverage(CombatantStatType.misscount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double hitsPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double takenDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.takendamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int takenDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.takendamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageHitDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageHitDamage(final CombatantSide side) {\n        // don't count the misses\n        final double teamHits = hitsWholeSide(side);\n        if (teamHits == 0) {\n            return 0;\n        }\n        final double teamDamage = causedDamageWholeSide(side);\n        final double totalCalculated = teamDamage / teamHits;\n        return totalCalculated;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double dodgesPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.dodgecount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int dodgesWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.dodgecount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistribution(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Number> healthDistribution(final CombatantSide side) {\n        // initialize map\n        final SortedMap<Number, Number> result = new TreeMap<Number, Number>();\n        final int maxHP = 14000;\n        final int step = 1000;\n        for (int limit = step; limit <= maxHP; limit += step) {\n            result.put(Integer.valueOf(limit), new AtomicInteger());\n        }\n        // fill with values\n        final CombatantStatType stat = CombatantStatType.starthp;\n        if (allData.containsKey(stat)) {\n            final DataSet statData = allData.get(stat);\n            final List<Integer> data = statData.getSideData(side);\n            for (final Integer value : data) {\n                Number key = getUpperLimit(value.intValue(), step);\n                if (!result.containsKey(key)) {\n                    // out of range, put it to the last value\n                    key = result.lastKey();\n                }\n                ((AtomicInteger) result.get(key)).incrementAndGet();\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistributionRelative(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Double> healthDistributionRelative(final CombatantSide side) {\n        final SortedMap<Number, Number> distribution = healthDistribution(side);\n        final TreeMap<Number, Double> result = new TreeMap<Number, Double>();\n        final double totalPlayers = numberOfPlayers(side);\n        for (final Entry<Number, Number> mapping : distribution.entrySet()) {\n            final double currentPlayers = mapping.getValue().doubleValue();\n            final Double percentage = Double.valueOf(currentPlayers / totalPlayers * 100.0);\n            result.put(mapping.getKey(), percentage);\n        }\n        return result;\n    }\n\n    /**\n     * @param value\n     * @param step\n     * @return\n     */\n    private Number getUpperLimit(final int value, final int step) {\n        int limit = 0;\n        while (value > limit) {\n            limit += step;\n        }\n        return Integer.valueOf(limit);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/CombatantStatistic_21Test.java",
		"test_prompt": "// CombatantStatistic_21Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CombatantStatistic}.\n* It contains ten unit test cases for the {@link CombatantStatistic#hitsPerPlayer(CombatantSide)} method.\n*/\nclass CombatantStatistic_21Test {"
	},
	{
		"original_code": "// CombatantStatistic.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\n\n/**\n * A statistic for combatants\n *\n * TODO use separate classes for calculating and storing the statistics, so\n * statistics i.e. can be serialized\n *\n * @author daniel\n */\npublic class CombatantStatistic implements StaticStatistics {\n\n    private final int numberOfRounds;\n\n    private final Map<CombatantStatType, DataSet> allData = new HashMap<CombatantStatType, DataSet>();\n\n    /**\n     * create statistics for the given number of rounds.\n     *\n     * @param numberOfRounds\n     */\n    public CombatantStatistic(final int numberOfRounds) {\n        this.numberOfRounds = numberOfRounds;\n    }\n\n    /**\n     * @param type\n     *            what kind of data is given as value?\n     * @param side\n     *            at which the combatant of the value fights\n     * @param value\n     */\n    public void addData(final CombatantStatType type, final CombatantSide side, final int value) {\n        ensureTypExists(type);\n        final Integer storedValue;\n        // fix class, because in the data it starts at -1 but we start with 0\n        if (type == CombatantStatType.charclass) {\n            storedValue = Integer.valueOf(value + 1);\n        } else {\n            storedValue = Integer.valueOf(value);\n        }\n        allData.get(type).addData(side, storedValue);\n    }\n\n    /**\n     * @param type\n     */\n    private void ensureTypExists(final CombatantStatType type) {\n        if (!allData.containsKey(type)) {\n            allData.put(type, new DataSet());\n        }\n    }\n\n    private double aggregate(final CombatantStatType stat, final CombatantSide side, final DataAggregationType function) {\n        // some data may not be present in old logs (ie. since 1.29 charlevel\n        // and charclass were added)\n        if (!allData.containsKey(stat)) {\n            return 0;\n        }\n        final DataSet statData = allData.get(stat);\n        assert statData != null : \"data must be present!\";\n        return statData.aggregate(side, function);\n    }\n\n    private double getAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AVERAGE);\n    }\n\n    private double getSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.SUM);\n    }\n\n    private double getCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AMOUNT);\n    }\n\n    private double getPositiveAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AVERAGE);\n    }\n\n    private double getPositiveSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_SUM);\n    }\n\n    private double getPositiveCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AMOUNT);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfPlayers(final CombatantSide side) {\n        // just a stat that is available for all combatants\n        return (int) Math.round(getCount(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#survivedPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int survivedPlayers(final CombatantSide side) {\n        return (int) Math.round(getPositiveCount(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double initialHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageWeaponDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageWeaponDamage(final CombatantSide side) {\n        final DataSet allMinDamage = allData.get(CombatantStatType.weaponmindmg);\n        final DataSet allMaxDamage = allData.get(CombatantStatType.weaponmaxdmg);\n        if (allMinDamage == null || allMaxDamage == null) {\n            // TODO logging: LOG.warn(\"no weapon damage data available!\");\n            // no weapon data available\n            return 0;\n        }\n        // use double precision for calculating average\n        final double avgMinDamage = allMinDamage.aggregate(side, DataAggregationType.AVERAGE);\n        final double avgMaxDamage = allMaxDamage.aggregate(side, DataAggregationType.AVERAGE);\n        return (avgMinDamage + avgMaxDamage) / 2.0;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double causedDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.totalcauseddamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int shotsFiredWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side) + getSum(CombatantStatType.misscount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int hitsWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLifetime(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLifetime(final CombatantSide side) {\n        final int totalPlayers = (int) getCount(CombatantStatType.diedwhen, side);\n        if (totalPlayers == 0) {\n            return 0.0;\n        }\n        final int diedPlayers = (int) getPositiveCount(CombatantStatType.diedwhen, side);\n        final int survivedPlayers = totalPlayers - diedPlayers;\n        final double diedInRound = getPositiveAverage(CombatantStatType.diedwhen, side);\n        return (diedPlayers * diedInRound + survivedPlayers * numberOfRounds) / totalPlayers;\n    }\n\n    private int numberOfClass(final CharacterClass charClass, final CombatantSide side) {\n        final DataSet data = allData.get(CombatantStatType.charclass);\n        // only available since v1.29\n        if (data == null) {\n            return 0;\n        }\n        final Integer value = Integer.valueOf(charClass.ordinal());\n        return data.countOfValuesWith(value, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfAdventurers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfAdventurers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.ADVENTURER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfDuelants(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfDuelants(final CombatantSide side) {\n        return numberOfClass(CharacterClass.DUELANT, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfGreenhorns(CombatantSide)\n     */\n    public int numberOfGreenhorns(final CombatantSide side) {\n        return numberOfClass(CharacterClass.GREENHORN, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfSoldiers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfSoldiers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.SOLDIER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfWorkers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfWorkers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.WORKER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLevel(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLevel(final CombatantSide side) {\n        return getAverage(CombatantStatType.charlevel, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int initialHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getPositiveAverage(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getPositiveSum(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int causedDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.totalcauseddamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double shotsFiredPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side) + getAverage(CombatantStatType.misscount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double hitsPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double takenDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.takendamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int takenDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.takendamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageHitDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageHitDamage(final CombatantSide side) {\n        // don't count the misses\n        final double teamHits = hitsWholeSide(side);\n        if (teamHits == 0) {\n            return 0;\n        }\n        final double teamDamage = causedDamageWholeSide(side);\n        final double totalCalculated = teamDamage / teamHits;\n        return totalCalculated;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double dodgesPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.dodgecount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int dodgesWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.dodgecount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistribution(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Number> healthDistribution(final CombatantSide side) {\n        // initialize map\n        final SortedMap<Number, Number> result = new TreeMap<Number, Number>();\n        final int maxHP = 14000;\n        final int step = 1000;\n        for (int limit = step; limit <= maxHP; limit += step) {\n            result.put(Integer.valueOf(limit), new AtomicInteger());\n        }\n        // fill with values\n        final CombatantStatType stat = CombatantStatType.starthp;\n        if (allData.containsKey(stat)) {\n            final DataSet statData = allData.get(stat);\n            final List<Integer> data = statData.getSideData(side);\n            for (final Integer value : data) {\n                Number key = getUpperLimit(value.intValue(), step);\n                if (!result.containsKey(key)) {\n                    // out of range, put it to the last value\n                    key = result.lastKey();\n                }\n                ((AtomicInteger) result.get(key)).incrementAndGet();\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistributionRelative(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Double> healthDistributionRelative(final CombatantSide side) {\n        final SortedMap<Number, Number> distribution = healthDistribution(side);\n        final TreeMap<Number, Double> result = new TreeMap<Number, Double>();\n        final double totalPlayers = numberOfPlayers(side);\n        for (final Entry<Number, Number> mapping : distribution.entrySet()) {\n            final double currentPlayers = mapping.getValue().doubleValue();\n            final Double percentage = Double.valueOf(currentPlayers / totalPlayers * 100.0);\n            result.put(mapping.getKey(), percentage);\n        }\n        return result;\n    }\n\n    /**\n     * @param value\n     * @param step\n     * @return\n     */\n    private Number getUpperLimit(final int value, final int step) {\n        int limit = 0;\n        while (value > limit) {\n            limit += step;\n        }\n        return Integer.valueOf(limit);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/CombatantStatistic_22Test.java",
		"test_prompt": "// CombatantStatistic_22Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CombatantStatistic}.\n* It contains ten unit test cases for the {@link CombatantStatistic#takenDamagePerPlayer(CombatantSide)} method.\n*/\nclass CombatantStatistic_22Test {"
	},
	{
		"original_code": "// CombatantStatistic.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\n\n/**\n * A statistic for combatants\n *\n * TODO use separate classes for calculating and storing the statistics, so\n * statistics i.e. can be serialized\n *\n * @author daniel\n */\npublic class CombatantStatistic implements StaticStatistics {\n\n    private final int numberOfRounds;\n\n    private final Map<CombatantStatType, DataSet> allData = new HashMap<CombatantStatType, DataSet>();\n\n    /**\n     * create statistics for the given number of rounds.\n     *\n     * @param numberOfRounds\n     */\n    public CombatantStatistic(final int numberOfRounds) {\n        this.numberOfRounds = numberOfRounds;\n    }\n\n    /**\n     * @param type\n     *            what kind of data is given as value?\n     * @param side\n     *            at which the combatant of the value fights\n     * @param value\n     */\n    public void addData(final CombatantStatType type, final CombatantSide side, final int value) {\n        ensureTypExists(type);\n        final Integer storedValue;\n        // fix class, because in the data it starts at -1 but we start with 0\n        if (type == CombatantStatType.charclass) {\n            storedValue = Integer.valueOf(value + 1);\n        } else {\n            storedValue = Integer.valueOf(value);\n        }\n        allData.get(type).addData(side, storedValue);\n    }\n\n    /**\n     * @param type\n     */\n    private void ensureTypExists(final CombatantStatType type) {\n        if (!allData.containsKey(type)) {\n            allData.put(type, new DataSet());\n        }\n    }\n\n    private double aggregate(final CombatantStatType stat, final CombatantSide side, final DataAggregationType function) {\n        // some data may not be present in old logs (ie. since 1.29 charlevel\n        // and charclass were added)\n        if (!allData.containsKey(stat)) {\n            return 0;\n        }\n        final DataSet statData = allData.get(stat);\n        assert statData != null : \"data must be present!\";\n        return statData.aggregate(side, function);\n    }\n\n    private double getAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AVERAGE);\n    }\n\n    private double getSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.SUM);\n    }\n\n    private double getCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AMOUNT);\n    }\n\n    private double getPositiveAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AVERAGE);\n    }\n\n    private double getPositiveSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_SUM);\n    }\n\n    private double getPositiveCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AMOUNT);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfPlayers(final CombatantSide side) {\n        // just a stat that is available for all combatants\n        return (int) Math.round(getCount(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#survivedPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int survivedPlayers(final CombatantSide side) {\n        return (int) Math.round(getPositiveCount(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double initialHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageWeaponDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageWeaponDamage(final CombatantSide side) {\n        final DataSet allMinDamage = allData.get(CombatantStatType.weaponmindmg);\n        final DataSet allMaxDamage = allData.get(CombatantStatType.weaponmaxdmg);\n        if (allMinDamage == null || allMaxDamage == null) {\n            // TODO logging: LOG.warn(\"no weapon damage data available!\");\n            // no weapon data available\n            return 0;\n        }\n        // use double precision for calculating average\n        final double avgMinDamage = allMinDamage.aggregate(side, DataAggregationType.AVERAGE);\n        final double avgMaxDamage = allMaxDamage.aggregate(side, DataAggregationType.AVERAGE);\n        return (avgMinDamage + avgMaxDamage) / 2.0;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double causedDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.totalcauseddamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int shotsFiredWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side) + getSum(CombatantStatType.misscount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int hitsWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLifetime(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLifetime(final CombatantSide side) {\n        final int totalPlayers = (int) getCount(CombatantStatType.diedwhen, side);\n        if (totalPlayers == 0) {\n            return 0.0;\n        }\n        final int diedPlayers = (int) getPositiveCount(CombatantStatType.diedwhen, side);\n        final int survivedPlayers = totalPlayers - diedPlayers;\n        final double diedInRound = getPositiveAverage(CombatantStatType.diedwhen, side);\n        return (diedPlayers * diedInRound + survivedPlayers * numberOfRounds) / totalPlayers;\n    }\n\n    private int numberOfClass(final CharacterClass charClass, final CombatantSide side) {\n        final DataSet data = allData.get(CombatantStatType.charclass);\n        // only available since v1.29\n        if (data == null) {\n            return 0;\n        }\n        final Integer value = Integer.valueOf(charClass.ordinal());\n        return data.countOfValuesWith(value, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfAdventurers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfAdventurers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.ADVENTURER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfDuelants(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfDuelants(final CombatantSide side) {\n        return numberOfClass(CharacterClass.DUELANT, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfGreenhorns(CombatantSide)\n     */\n    public int numberOfGreenhorns(final CombatantSide side) {\n        return numberOfClass(CharacterClass.GREENHORN, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfSoldiers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfSoldiers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.SOLDIER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfWorkers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfWorkers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.WORKER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLevel(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLevel(final CombatantSide side) {\n        return getAverage(CombatantStatType.charlevel, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int initialHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getPositiveAverage(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getPositiveSum(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int causedDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.totalcauseddamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double shotsFiredPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side) + getAverage(CombatantStatType.misscount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double hitsPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double takenDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.takendamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int takenDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.takendamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageHitDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageHitDamage(final CombatantSide side) {\n        // don't count the misses\n        final double teamHits = hitsWholeSide(side);\n        if (teamHits == 0) {\n            return 0;\n        }\n        final double teamDamage = causedDamageWholeSide(side);\n        final double totalCalculated = teamDamage / teamHits;\n        return totalCalculated;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double dodgesPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.dodgecount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int dodgesWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.dodgecount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistribution(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Number> healthDistribution(final CombatantSide side) {\n        // initialize map\n        final SortedMap<Number, Number> result = new TreeMap<Number, Number>();\n        final int maxHP = 14000;\n        final int step = 1000;\n        for (int limit = step; limit <= maxHP; limit += step) {\n            result.put(Integer.valueOf(limit), new AtomicInteger());\n        }\n        // fill with values\n        final CombatantStatType stat = CombatantStatType.starthp;\n        if (allData.containsKey(stat)) {\n            final DataSet statData = allData.get(stat);\n            final List<Integer> data = statData.getSideData(side);\n            for (final Integer value : data) {\n                Number key = getUpperLimit(value.intValue(), step);\n                if (!result.containsKey(key)) {\n                    // out of range, put it to the last value\n                    key = result.lastKey();\n                }\n                ((AtomicInteger) result.get(key)).incrementAndGet();\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistributionRelative(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Double> healthDistributionRelative(final CombatantSide side) {\n        final SortedMap<Number, Number> distribution = healthDistribution(side);\n        final TreeMap<Number, Double> result = new TreeMap<Number, Double>();\n        final double totalPlayers = numberOfPlayers(side);\n        for (final Entry<Number, Number> mapping : distribution.entrySet()) {\n            final double currentPlayers = mapping.getValue().doubleValue();\n            final Double percentage = Double.valueOf(currentPlayers / totalPlayers * 100.0);\n            result.put(mapping.getKey(), percentage);\n        }\n        return result;\n    }\n\n    /**\n     * @param value\n     * @param step\n     * @return\n     */\n    private Number getUpperLimit(final int value, final int step) {\n        int limit = 0;\n        while (value > limit) {\n            limit += step;\n        }\n        return Integer.valueOf(limit);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/CombatantStatistic_23Test.java",
		"test_prompt": "// CombatantStatistic_23Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CombatantStatistic}.\n* It contains ten unit test cases for the {@link CombatantStatistic#takenDamageWholeSide(CombatantSide)} method.\n*/\nclass CombatantStatistic_23Test {"
	},
	{
		"original_code": "// CombatantStatistic.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\n\n/**\n * A statistic for combatants\n *\n * TODO use separate classes for calculating and storing the statistics, so\n * statistics i.e. can be serialized\n *\n * @author daniel\n */\npublic class CombatantStatistic implements StaticStatistics {\n\n    private final int numberOfRounds;\n\n    private final Map<CombatantStatType, DataSet> allData = new HashMap<CombatantStatType, DataSet>();\n\n    /**\n     * create statistics for the given number of rounds.\n     *\n     * @param numberOfRounds\n     */\n    public CombatantStatistic(final int numberOfRounds) {\n        this.numberOfRounds = numberOfRounds;\n    }\n\n    /**\n     * @param type\n     *            what kind of data is given as value?\n     * @param side\n     *            at which the combatant of the value fights\n     * @param value\n     */\n    public void addData(final CombatantStatType type, final CombatantSide side, final int value) {\n        ensureTypExists(type);\n        final Integer storedValue;\n        // fix class, because in the data it starts at -1 but we start with 0\n        if (type == CombatantStatType.charclass) {\n            storedValue = Integer.valueOf(value + 1);\n        } else {\n            storedValue = Integer.valueOf(value);\n        }\n        allData.get(type).addData(side, storedValue);\n    }\n\n    /**\n     * @param type\n     */\n    private void ensureTypExists(final CombatantStatType type) {\n        if (!allData.containsKey(type)) {\n            allData.put(type, new DataSet());\n        }\n    }\n\n    private double aggregate(final CombatantStatType stat, final CombatantSide side, final DataAggregationType function) {\n        // some data may not be present in old logs (ie. since 1.29 charlevel\n        // and charclass were added)\n        if (!allData.containsKey(stat)) {\n            return 0;\n        }\n        final DataSet statData = allData.get(stat);\n        assert statData != null : \"data must be present!\";\n        return statData.aggregate(side, function);\n    }\n\n    private double getAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AVERAGE);\n    }\n\n    private double getSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.SUM);\n    }\n\n    private double getCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AMOUNT);\n    }\n\n    private double getPositiveAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AVERAGE);\n    }\n\n    private double getPositiveSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_SUM);\n    }\n\n    private double getPositiveCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AMOUNT);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfPlayers(final CombatantSide side) {\n        // just a stat that is available for all combatants\n        return (int) Math.round(getCount(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#survivedPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int survivedPlayers(final CombatantSide side) {\n        return (int) Math.round(getPositiveCount(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double initialHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageWeaponDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageWeaponDamage(final CombatantSide side) {\n        final DataSet allMinDamage = allData.get(CombatantStatType.weaponmindmg);\n        final DataSet allMaxDamage = allData.get(CombatantStatType.weaponmaxdmg);\n        if (allMinDamage == null || allMaxDamage == null) {\n            // TODO logging: LOG.warn(\"no weapon damage data available!\");\n            // no weapon data available\n            return 0;\n        }\n        // use double precision for calculating average\n        final double avgMinDamage = allMinDamage.aggregate(side, DataAggregationType.AVERAGE);\n        final double avgMaxDamage = allMaxDamage.aggregate(side, DataAggregationType.AVERAGE);\n        return (avgMinDamage + avgMaxDamage) / 2.0;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double causedDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.totalcauseddamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int shotsFiredWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side) + getSum(CombatantStatType.misscount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int hitsWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLifetime(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLifetime(final CombatantSide side) {\n        final int totalPlayers = (int) getCount(CombatantStatType.diedwhen, side);\n        if (totalPlayers == 0) {\n            return 0.0;\n        }\n        final int diedPlayers = (int) getPositiveCount(CombatantStatType.diedwhen, side);\n        final int survivedPlayers = totalPlayers - diedPlayers;\n        final double diedInRound = getPositiveAverage(CombatantStatType.diedwhen, side);\n        return (diedPlayers * diedInRound + survivedPlayers * numberOfRounds) / totalPlayers;\n    }\n\n    private int numberOfClass(final CharacterClass charClass, final CombatantSide side) {\n        final DataSet data = allData.get(CombatantStatType.charclass);\n        // only available since v1.29\n        if (data == null) {\n            return 0;\n        }\n        final Integer value = Integer.valueOf(charClass.ordinal());\n        return data.countOfValuesWith(value, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfAdventurers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfAdventurers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.ADVENTURER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfDuelants(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfDuelants(final CombatantSide side) {\n        return numberOfClass(CharacterClass.DUELANT, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfGreenhorns(CombatantSide)\n     */\n    public int numberOfGreenhorns(final CombatantSide side) {\n        return numberOfClass(CharacterClass.GREENHORN, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfSoldiers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfSoldiers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.SOLDIER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfWorkers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfWorkers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.WORKER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLevel(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLevel(final CombatantSide side) {\n        return getAverage(CombatantStatType.charlevel, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int initialHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getPositiveAverage(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getPositiveSum(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int causedDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.totalcauseddamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double shotsFiredPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side) + getAverage(CombatantStatType.misscount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double hitsPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double takenDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.takendamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int takenDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.takendamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageHitDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageHitDamage(final CombatantSide side) {\n        // don't count the misses\n        final double teamHits = hitsWholeSide(side);\n        if (teamHits == 0) {\n            return 0;\n        }\n        final double teamDamage = causedDamageWholeSide(side);\n        final double totalCalculated = teamDamage / teamHits;\n        return totalCalculated;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double dodgesPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.dodgecount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int dodgesWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.dodgecount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistribution(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Number> healthDistribution(final CombatantSide side) {\n        // initialize map\n        final SortedMap<Number, Number> result = new TreeMap<Number, Number>();\n        final int maxHP = 14000;\n        final int step = 1000;\n        for (int limit = step; limit <= maxHP; limit += step) {\n            result.put(Integer.valueOf(limit), new AtomicInteger());\n        }\n        // fill with values\n        final CombatantStatType stat = CombatantStatType.starthp;\n        if (allData.containsKey(stat)) {\n            final DataSet statData = allData.get(stat);\n            final List<Integer> data = statData.getSideData(side);\n            for (final Integer value : data) {\n                Number key = getUpperLimit(value.intValue(), step);\n                if (!result.containsKey(key)) {\n                    // out of range, put it to the last value\n                    key = result.lastKey();\n                }\n                ((AtomicInteger) result.get(key)).incrementAndGet();\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistributionRelative(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Double> healthDistributionRelative(final CombatantSide side) {\n        final SortedMap<Number, Number> distribution = healthDistribution(side);\n        final TreeMap<Number, Double> result = new TreeMap<Number, Double>();\n        final double totalPlayers = numberOfPlayers(side);\n        for (final Entry<Number, Number> mapping : distribution.entrySet()) {\n            final double currentPlayers = mapping.getValue().doubleValue();\n            final Double percentage = Double.valueOf(currentPlayers / totalPlayers * 100.0);\n            result.put(mapping.getKey(), percentage);\n        }\n        return result;\n    }\n\n    /**\n     * @param value\n     * @param step\n     * @return\n     */\n    private Number getUpperLimit(final int value, final int step) {\n        int limit = 0;\n        while (value > limit) {\n            limit += step;\n        }\n        return Integer.valueOf(limit);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/CombatantStatistic_24Test.java",
		"test_prompt": "// CombatantStatistic_24Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CombatantStatistic}.\n* It contains ten unit test cases for the {@link CombatantStatistic#averageHitDamage(CombatantSide)} method.\n*/\nclass CombatantStatistic_24Test {"
	},
	{
		"original_code": "// CombatantStatistic.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\n\n/**\n * A statistic for combatants\n *\n * TODO use separate classes for calculating and storing the statistics, so\n * statistics i.e. can be serialized\n *\n * @author daniel\n */\npublic class CombatantStatistic implements StaticStatistics {\n\n    private final int numberOfRounds;\n\n    private final Map<CombatantStatType, DataSet> allData = new HashMap<CombatantStatType, DataSet>();\n\n    /**\n     * create statistics for the given number of rounds.\n     *\n     * @param numberOfRounds\n     */\n    public CombatantStatistic(final int numberOfRounds) {\n        this.numberOfRounds = numberOfRounds;\n    }\n\n    /**\n     * @param type\n     *            what kind of data is given as value?\n     * @param side\n     *            at which the combatant of the value fights\n     * @param value\n     */\n    public void addData(final CombatantStatType type, final CombatantSide side, final int value) {\n        ensureTypExists(type);\n        final Integer storedValue;\n        // fix class, because in the data it starts at -1 but we start with 0\n        if (type == CombatantStatType.charclass) {\n            storedValue = Integer.valueOf(value + 1);\n        } else {\n            storedValue = Integer.valueOf(value);\n        }\n        allData.get(type).addData(side, storedValue);\n    }\n\n    /**\n     * @param type\n     */\n    private void ensureTypExists(final CombatantStatType type) {\n        if (!allData.containsKey(type)) {\n            allData.put(type, new DataSet());\n        }\n    }\n\n    private double aggregate(final CombatantStatType stat, final CombatantSide side, final DataAggregationType function) {\n        // some data may not be present in old logs (ie. since 1.29 charlevel\n        // and charclass were added)\n        if (!allData.containsKey(stat)) {\n            return 0;\n        }\n        final DataSet statData = allData.get(stat);\n        assert statData != null : \"data must be present!\";\n        return statData.aggregate(side, function);\n    }\n\n    private double getAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AVERAGE);\n    }\n\n    private double getSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.SUM);\n    }\n\n    private double getCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AMOUNT);\n    }\n\n    private double getPositiveAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AVERAGE);\n    }\n\n    private double getPositiveSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_SUM);\n    }\n\n    private double getPositiveCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AMOUNT);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfPlayers(final CombatantSide side) {\n        // just a stat that is available for all combatants\n        return (int) Math.round(getCount(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#survivedPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int survivedPlayers(final CombatantSide side) {\n        return (int) Math.round(getPositiveCount(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double initialHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageWeaponDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageWeaponDamage(final CombatantSide side) {\n        final DataSet allMinDamage = allData.get(CombatantStatType.weaponmindmg);\n        final DataSet allMaxDamage = allData.get(CombatantStatType.weaponmaxdmg);\n        if (allMinDamage == null || allMaxDamage == null) {\n            // TODO logging: LOG.warn(\"no weapon damage data available!\");\n            // no weapon data available\n            return 0;\n        }\n        // use double precision for calculating average\n        final double avgMinDamage = allMinDamage.aggregate(side, DataAggregationType.AVERAGE);\n        final double avgMaxDamage = allMaxDamage.aggregate(side, DataAggregationType.AVERAGE);\n        return (avgMinDamage + avgMaxDamage) / 2.0;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double causedDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.totalcauseddamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int shotsFiredWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side) + getSum(CombatantStatType.misscount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int hitsWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLifetime(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLifetime(final CombatantSide side) {\n        final int totalPlayers = (int) getCount(CombatantStatType.diedwhen, side);\n        if (totalPlayers == 0) {\n            return 0.0;\n        }\n        final int diedPlayers = (int) getPositiveCount(CombatantStatType.diedwhen, side);\n        final int survivedPlayers = totalPlayers - diedPlayers;\n        final double diedInRound = getPositiveAverage(CombatantStatType.diedwhen, side);\n        return (diedPlayers * diedInRound + survivedPlayers * numberOfRounds) / totalPlayers;\n    }\n\n    private int numberOfClass(final CharacterClass charClass, final CombatantSide side) {\n        final DataSet data = allData.get(CombatantStatType.charclass);\n        // only available since v1.29\n        if (data == null) {\n            return 0;\n        }\n        final Integer value = Integer.valueOf(charClass.ordinal());\n        return data.countOfValuesWith(value, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfAdventurers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfAdventurers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.ADVENTURER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfDuelants(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfDuelants(final CombatantSide side) {\n        return numberOfClass(CharacterClass.DUELANT, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfGreenhorns(CombatantSide)\n     */\n    public int numberOfGreenhorns(final CombatantSide side) {\n        return numberOfClass(CharacterClass.GREENHORN, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfSoldiers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfSoldiers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.SOLDIER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfWorkers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfWorkers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.WORKER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLevel(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLevel(final CombatantSide side) {\n        return getAverage(CombatantStatType.charlevel, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int initialHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getPositiveAverage(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getPositiveSum(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int causedDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.totalcauseddamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double shotsFiredPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side) + getAverage(CombatantStatType.misscount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double hitsPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double takenDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.takendamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int takenDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.takendamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageHitDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageHitDamage(final CombatantSide side) {\n        // don't count the misses\n        final double teamHits = hitsWholeSide(side);\n        if (teamHits == 0) {\n            return 0;\n        }\n        final double teamDamage = causedDamageWholeSide(side);\n        final double totalCalculated = teamDamage / teamHits;\n        return totalCalculated;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double dodgesPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.dodgecount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int dodgesWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.dodgecount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistribution(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Number> healthDistribution(final CombatantSide side) {\n        // initialize map\n        final SortedMap<Number, Number> result = new TreeMap<Number, Number>();\n        final int maxHP = 14000;\n        final int step = 1000;\n        for (int limit = step; limit <= maxHP; limit += step) {\n            result.put(Integer.valueOf(limit), new AtomicInteger());\n        }\n        // fill with values\n        final CombatantStatType stat = CombatantStatType.starthp;\n        if (allData.containsKey(stat)) {\n            final DataSet statData = allData.get(stat);\n            final List<Integer> data = statData.getSideData(side);\n            for (final Integer value : data) {\n                Number key = getUpperLimit(value.intValue(), step);\n                if (!result.containsKey(key)) {\n                    // out of range, put it to the last value\n                    key = result.lastKey();\n                }\n                ((AtomicInteger) result.get(key)).incrementAndGet();\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistributionRelative(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Double> healthDistributionRelative(final CombatantSide side) {\n        final SortedMap<Number, Number> distribution = healthDistribution(side);\n        final TreeMap<Number, Double> result = new TreeMap<Number, Double>();\n        final double totalPlayers = numberOfPlayers(side);\n        for (final Entry<Number, Number> mapping : distribution.entrySet()) {\n            final double currentPlayers = mapping.getValue().doubleValue();\n            final Double percentage = Double.valueOf(currentPlayers / totalPlayers * 100.0);\n            result.put(mapping.getKey(), percentage);\n        }\n        return result;\n    }\n\n    /**\n     * @param value\n     * @param step\n     * @return\n     */\n    private Number getUpperLimit(final int value, final int step) {\n        int limit = 0;\n        while (value > limit) {\n            limit += step;\n        }\n        return Integer.valueOf(limit);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/CombatantStatistic_25Test.java",
		"test_prompt": "// CombatantStatistic_25Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CombatantStatistic}.\n* It contains ten unit test cases for the {@link CombatantStatistic#dodgesPerPlayer(CombatantSide)} method.\n*/\nclass CombatantStatistic_25Test {"
	},
	{
		"original_code": "// CombatantStatistic.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\n\n/**\n * A statistic for combatants\n *\n * TODO use separate classes for calculating and storing the statistics, so\n * statistics i.e. can be serialized\n *\n * @author daniel\n */\npublic class CombatantStatistic implements StaticStatistics {\n\n    private final int numberOfRounds;\n\n    private final Map<CombatantStatType, DataSet> allData = new HashMap<CombatantStatType, DataSet>();\n\n    /**\n     * create statistics for the given number of rounds.\n     *\n     * @param numberOfRounds\n     */\n    public CombatantStatistic(final int numberOfRounds) {\n        this.numberOfRounds = numberOfRounds;\n    }\n\n    /**\n     * @param type\n     *            what kind of data is given as value?\n     * @param side\n     *            at which the combatant of the value fights\n     * @param value\n     */\n    public void addData(final CombatantStatType type, final CombatantSide side, final int value) {\n        ensureTypExists(type);\n        final Integer storedValue;\n        // fix class, because in the data it starts at -1 but we start with 0\n        if (type == CombatantStatType.charclass) {\n            storedValue = Integer.valueOf(value + 1);\n        } else {\n            storedValue = Integer.valueOf(value);\n        }\n        allData.get(type).addData(side, storedValue);\n    }\n\n    /**\n     * @param type\n     */\n    private void ensureTypExists(final CombatantStatType type) {\n        if (!allData.containsKey(type)) {\n            allData.put(type, new DataSet());\n        }\n    }\n\n    private double aggregate(final CombatantStatType stat, final CombatantSide side, final DataAggregationType function) {\n        // some data may not be present in old logs (ie. since 1.29 charlevel\n        // and charclass were added)\n        if (!allData.containsKey(stat)) {\n            return 0;\n        }\n        final DataSet statData = allData.get(stat);\n        assert statData != null : \"data must be present!\";\n        return statData.aggregate(side, function);\n    }\n\n    private double getAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AVERAGE);\n    }\n\n    private double getSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.SUM);\n    }\n\n    private double getCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AMOUNT);\n    }\n\n    private double getPositiveAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AVERAGE);\n    }\n\n    private double getPositiveSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_SUM);\n    }\n\n    private double getPositiveCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AMOUNT);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfPlayers(final CombatantSide side) {\n        // just a stat that is available for all combatants\n        return (int) Math.round(getCount(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#survivedPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int survivedPlayers(final CombatantSide side) {\n        return (int) Math.round(getPositiveCount(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double initialHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageWeaponDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageWeaponDamage(final CombatantSide side) {\n        final DataSet allMinDamage = allData.get(CombatantStatType.weaponmindmg);\n        final DataSet allMaxDamage = allData.get(CombatantStatType.weaponmaxdmg);\n        if (allMinDamage == null || allMaxDamage == null) {\n            // TODO logging: LOG.warn(\"no weapon damage data available!\");\n            // no weapon data available\n            return 0;\n        }\n        // use double precision for calculating average\n        final double avgMinDamage = allMinDamage.aggregate(side, DataAggregationType.AVERAGE);\n        final double avgMaxDamage = allMaxDamage.aggregate(side, DataAggregationType.AVERAGE);\n        return (avgMinDamage + avgMaxDamage) / 2.0;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double causedDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.totalcauseddamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int shotsFiredWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side) + getSum(CombatantStatType.misscount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int hitsWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLifetime(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLifetime(final CombatantSide side) {\n        final int totalPlayers = (int) getCount(CombatantStatType.diedwhen, side);\n        if (totalPlayers == 0) {\n            return 0.0;\n        }\n        final int diedPlayers = (int) getPositiveCount(CombatantStatType.diedwhen, side);\n        final int survivedPlayers = totalPlayers - diedPlayers;\n        final double diedInRound = getPositiveAverage(CombatantStatType.diedwhen, side);\n        return (diedPlayers * diedInRound + survivedPlayers * numberOfRounds) / totalPlayers;\n    }\n\n    private int numberOfClass(final CharacterClass charClass, final CombatantSide side) {\n        final DataSet data = allData.get(CombatantStatType.charclass);\n        // only available since v1.29\n        if (data == null) {\n            return 0;\n        }\n        final Integer value = Integer.valueOf(charClass.ordinal());\n        return data.countOfValuesWith(value, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfAdventurers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfAdventurers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.ADVENTURER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfDuelants(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfDuelants(final CombatantSide side) {\n        return numberOfClass(CharacterClass.DUELANT, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfGreenhorns(CombatantSide)\n     */\n    public int numberOfGreenhorns(final CombatantSide side) {\n        return numberOfClass(CharacterClass.GREENHORN, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfSoldiers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfSoldiers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.SOLDIER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfWorkers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfWorkers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.WORKER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLevel(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLevel(final CombatantSide side) {\n        return getAverage(CombatantStatType.charlevel, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int initialHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getPositiveAverage(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getPositiveSum(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int causedDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.totalcauseddamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double shotsFiredPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side) + getAverage(CombatantStatType.misscount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double hitsPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double takenDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.takendamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int takenDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.takendamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageHitDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageHitDamage(final CombatantSide side) {\n        // don't count the misses\n        final double teamHits = hitsWholeSide(side);\n        if (teamHits == 0) {\n            return 0;\n        }\n        final double teamDamage = causedDamageWholeSide(side);\n        final double totalCalculated = teamDamage / teamHits;\n        return totalCalculated;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double dodgesPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.dodgecount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int dodgesWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.dodgecount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistribution(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Number> healthDistribution(final CombatantSide side) {\n        // initialize map\n        final SortedMap<Number, Number> result = new TreeMap<Number, Number>();\n        final int maxHP = 14000;\n        final int step = 1000;\n        for (int limit = step; limit <= maxHP; limit += step) {\n            result.put(Integer.valueOf(limit), new AtomicInteger());\n        }\n        // fill with values\n        final CombatantStatType stat = CombatantStatType.starthp;\n        if (allData.containsKey(stat)) {\n            final DataSet statData = allData.get(stat);\n            final List<Integer> data = statData.getSideData(side);\n            for (final Integer value : data) {\n                Number key = getUpperLimit(value.intValue(), step);\n                if (!result.containsKey(key)) {\n                    // out of range, put it to the last value\n                    key = result.lastKey();\n                }\n                ((AtomicInteger) result.get(key)).incrementAndGet();\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistributionRelative(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Double> healthDistributionRelative(final CombatantSide side) {\n        final SortedMap<Number, Number> distribution = healthDistribution(side);\n        final TreeMap<Number, Double> result = new TreeMap<Number, Double>();\n        final double totalPlayers = numberOfPlayers(side);\n        for (final Entry<Number, Number> mapping : distribution.entrySet()) {\n            final double currentPlayers = mapping.getValue().doubleValue();\n            final Double percentage = Double.valueOf(currentPlayers / totalPlayers * 100.0);\n            result.put(mapping.getKey(), percentage);\n        }\n        return result;\n    }\n\n    /**\n     * @param value\n     * @param step\n     * @return\n     */\n    private Number getUpperLimit(final int value, final int step) {\n        int limit = 0;\n        while (value > limit) {\n            limit += step;\n        }\n        return Integer.valueOf(limit);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/CombatantStatistic_26Test.java",
		"test_prompt": "// CombatantStatistic_26Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CombatantStatistic}.\n* It contains ten unit test cases for the {@link CombatantStatistic#dodgesWholeSide(CombatantSide)} method.\n*/\nclass CombatantStatistic_26Test {"
	},
	{
		"original_code": "// CombatantStatistic.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\n\n/**\n * A statistic for combatants\n *\n * TODO use separate classes for calculating and storing the statistics, so\n * statistics i.e. can be serialized\n *\n * @author daniel\n */\npublic class CombatantStatistic implements StaticStatistics {\n\n    private final int numberOfRounds;\n\n    private final Map<CombatantStatType, DataSet> allData = new HashMap<CombatantStatType, DataSet>();\n\n    /**\n     * create statistics for the given number of rounds.\n     *\n     * @param numberOfRounds\n     */\n    public CombatantStatistic(final int numberOfRounds) {\n        this.numberOfRounds = numberOfRounds;\n    }\n\n    /**\n     * @param type\n     *            what kind of data is given as value?\n     * @param side\n     *            at which the combatant of the value fights\n     * @param value\n     */\n    public void addData(final CombatantStatType type, final CombatantSide side, final int value) {\n        ensureTypExists(type);\n        final Integer storedValue;\n        // fix class, because in the data it starts at -1 but we start with 0\n        if (type == CombatantStatType.charclass) {\n            storedValue = Integer.valueOf(value + 1);\n        } else {\n            storedValue = Integer.valueOf(value);\n        }\n        allData.get(type).addData(side, storedValue);\n    }\n\n    /**\n     * @param type\n     */\n    private void ensureTypExists(final CombatantStatType type) {\n        if (!allData.containsKey(type)) {\n            allData.put(type, new DataSet());\n        }\n    }\n\n    private double aggregate(final CombatantStatType stat, final CombatantSide side, final DataAggregationType function) {\n        // some data may not be present in old logs (ie. since 1.29 charlevel\n        // and charclass were added)\n        if (!allData.containsKey(stat)) {\n            return 0;\n        }\n        final DataSet statData = allData.get(stat);\n        assert statData != null : \"data must be present!\";\n        return statData.aggregate(side, function);\n    }\n\n    private double getAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AVERAGE);\n    }\n\n    private double getSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.SUM);\n    }\n\n    private double getCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AMOUNT);\n    }\n\n    private double getPositiveAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AVERAGE);\n    }\n\n    private double getPositiveSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_SUM);\n    }\n\n    private double getPositiveCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AMOUNT);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfPlayers(final CombatantSide side) {\n        // just a stat that is available for all combatants\n        return (int) Math.round(getCount(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#survivedPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int survivedPlayers(final CombatantSide side) {\n        return (int) Math.round(getPositiveCount(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double initialHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageWeaponDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageWeaponDamage(final CombatantSide side) {\n        final DataSet allMinDamage = allData.get(CombatantStatType.weaponmindmg);\n        final DataSet allMaxDamage = allData.get(CombatantStatType.weaponmaxdmg);\n        if (allMinDamage == null || allMaxDamage == null) {\n            // TODO logging: LOG.warn(\"no weapon damage data available!\");\n            // no weapon data available\n            return 0;\n        }\n        // use double precision for calculating average\n        final double avgMinDamage = allMinDamage.aggregate(side, DataAggregationType.AVERAGE);\n        final double avgMaxDamage = allMaxDamage.aggregate(side, DataAggregationType.AVERAGE);\n        return (avgMinDamage + avgMaxDamage) / 2.0;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double causedDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.totalcauseddamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int shotsFiredWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side) + getSum(CombatantStatType.misscount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int hitsWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLifetime(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLifetime(final CombatantSide side) {\n        final int totalPlayers = (int) getCount(CombatantStatType.diedwhen, side);\n        if (totalPlayers == 0) {\n            return 0.0;\n        }\n        final int diedPlayers = (int) getPositiveCount(CombatantStatType.diedwhen, side);\n        final int survivedPlayers = totalPlayers - diedPlayers;\n        final double diedInRound = getPositiveAverage(CombatantStatType.diedwhen, side);\n        return (diedPlayers * diedInRound + survivedPlayers * numberOfRounds) / totalPlayers;\n    }\n\n    private int numberOfClass(final CharacterClass charClass, final CombatantSide side) {\n        final DataSet data = allData.get(CombatantStatType.charclass);\n        // only available since v1.29\n        if (data == null) {\n            return 0;\n        }\n        final Integer value = Integer.valueOf(charClass.ordinal());\n        return data.countOfValuesWith(value, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfAdventurers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfAdventurers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.ADVENTURER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfDuelants(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfDuelants(final CombatantSide side) {\n        return numberOfClass(CharacterClass.DUELANT, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfGreenhorns(CombatantSide)\n     */\n    public int numberOfGreenhorns(final CombatantSide side) {\n        return numberOfClass(CharacterClass.GREENHORN, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfSoldiers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfSoldiers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.SOLDIER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfWorkers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfWorkers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.WORKER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLevel(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLevel(final CombatantSide side) {\n        return getAverage(CombatantStatType.charlevel, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int initialHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getPositiveAverage(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getPositiveSum(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int causedDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.totalcauseddamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double shotsFiredPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side) + getAverage(CombatantStatType.misscount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double hitsPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double takenDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.takendamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int takenDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.takendamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageHitDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageHitDamage(final CombatantSide side) {\n        // don't count the misses\n        final double teamHits = hitsWholeSide(side);\n        if (teamHits == 0) {\n            return 0;\n        }\n        final double teamDamage = causedDamageWholeSide(side);\n        final double totalCalculated = teamDamage / teamHits;\n        return totalCalculated;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double dodgesPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.dodgecount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int dodgesWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.dodgecount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistribution(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Number> healthDistribution(final CombatantSide side) {\n        // initialize map\n        final SortedMap<Number, Number> result = new TreeMap<Number, Number>();\n        final int maxHP = 14000;\n        final int step = 1000;\n        for (int limit = step; limit <= maxHP; limit += step) {\n            result.put(Integer.valueOf(limit), new AtomicInteger());\n        }\n        // fill with values\n        final CombatantStatType stat = CombatantStatType.starthp;\n        if (allData.containsKey(stat)) {\n            final DataSet statData = allData.get(stat);\n            final List<Integer> data = statData.getSideData(side);\n            for (final Integer value : data) {\n                Number key = getUpperLimit(value.intValue(), step);\n                if (!result.containsKey(key)) {\n                    // out of range, put it to the last value\n                    key = result.lastKey();\n                }\n                ((AtomicInteger) result.get(key)).incrementAndGet();\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistributionRelative(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Double> healthDistributionRelative(final CombatantSide side) {\n        final SortedMap<Number, Number> distribution = healthDistribution(side);\n        final TreeMap<Number, Double> result = new TreeMap<Number, Double>();\n        final double totalPlayers = numberOfPlayers(side);\n        for (final Entry<Number, Number> mapping : distribution.entrySet()) {\n            final double currentPlayers = mapping.getValue().doubleValue();\n            final Double percentage = Double.valueOf(currentPlayers / totalPlayers * 100.0);\n            result.put(mapping.getKey(), percentage);\n        }\n        return result;\n    }\n\n    /**\n     * @param value\n     * @param step\n     * @return\n     */\n    private Number getUpperLimit(final int value, final int step) {\n        int limit = 0;\n        while (value > limit) {\n            limit += step;\n        }\n        return Integer.valueOf(limit);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/CombatantStatistic_27Test.java",
		"test_prompt": "// CombatantStatistic_27Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CombatantStatistic}.\n* It contains ten unit test cases for the {@link CombatantStatistic#healthDistribution(CombatantSide)} method.\n*/\nclass CombatantStatistic_27Test {"
	},
	{
		"original_code": "// CombatantStatistic.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\n\n/**\n * A statistic for combatants\n *\n * TODO use separate classes for calculating and storing the statistics, so\n * statistics i.e. can be serialized\n *\n * @author daniel\n */\npublic class CombatantStatistic implements StaticStatistics {\n\n    private final int numberOfRounds;\n\n    private final Map<CombatantStatType, DataSet> allData = new HashMap<CombatantStatType, DataSet>();\n\n    /**\n     * create statistics for the given number of rounds.\n     *\n     * @param numberOfRounds\n     */\n    public CombatantStatistic(final int numberOfRounds) {\n        this.numberOfRounds = numberOfRounds;\n    }\n\n    /**\n     * @param type\n     *            what kind of data is given as value?\n     * @param side\n     *            at which the combatant of the value fights\n     * @param value\n     */\n    public void addData(final CombatantStatType type, final CombatantSide side, final int value) {\n        ensureTypExists(type);\n        final Integer storedValue;\n        // fix class, because in the data it starts at -1 but we start with 0\n        if (type == CombatantStatType.charclass) {\n            storedValue = Integer.valueOf(value + 1);\n        } else {\n            storedValue = Integer.valueOf(value);\n        }\n        allData.get(type).addData(side, storedValue);\n    }\n\n    /**\n     * @param type\n     */\n    private void ensureTypExists(final CombatantStatType type) {\n        if (!allData.containsKey(type)) {\n            allData.put(type, new DataSet());\n        }\n    }\n\n    private double aggregate(final CombatantStatType stat, final CombatantSide side, final DataAggregationType function) {\n        // some data may not be present in old logs (ie. since 1.29 charlevel\n        // and charclass were added)\n        if (!allData.containsKey(stat)) {\n            return 0;\n        }\n        final DataSet statData = allData.get(stat);\n        assert statData != null : \"data must be present!\";\n        return statData.aggregate(side, function);\n    }\n\n    private double getAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AVERAGE);\n    }\n\n    private double getSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.SUM);\n    }\n\n    private double getCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.AMOUNT);\n    }\n\n    private double getPositiveAverage(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AVERAGE);\n    }\n\n    private double getPositiveSum(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_SUM);\n    }\n\n    private double getPositiveCount(final CombatantStatType stat, final CombatantSide side) {\n        return aggregate(stat, side, DataAggregationType.POSITIVE_AMOUNT);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfPlayers(final CombatantSide side) {\n        // just a stat that is available for all combatants\n        return (int) Math.round(getCount(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#survivedPlayers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int survivedPlayers(final CombatantSide side) {\n        return (int) Math.round(getPositiveCount(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double initialHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageWeaponDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageWeaponDamage(final CombatantSide side) {\n        final DataSet allMinDamage = allData.get(CombatantStatType.weaponmindmg);\n        final DataSet allMaxDamage = allData.get(CombatantStatType.weaponmaxdmg);\n        if (allMinDamage == null || allMaxDamage == null) {\n            // TODO logging: LOG.warn(\"no weapon damage data available!\");\n            // no weapon data available\n            return 0;\n        }\n        // use double precision for calculating average\n        final double avgMinDamage = allMinDamage.aggregate(side, DataAggregationType.AVERAGE);\n        final double avgMaxDamage = allMaxDamage.aggregate(side, DataAggregationType.AVERAGE);\n        return (avgMinDamage + avgMaxDamage) / 2.0;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double causedDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.totalcauseddamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int shotsFiredWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side) + getSum(CombatantStatType.misscount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int hitsWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.hitcount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLifetime(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLifetime(final CombatantSide side) {\n        final int totalPlayers = (int) getCount(CombatantStatType.diedwhen, side);\n        if (totalPlayers == 0) {\n            return 0.0;\n        }\n        final int diedPlayers = (int) getPositiveCount(CombatantStatType.diedwhen, side);\n        final int survivedPlayers = totalPlayers - diedPlayers;\n        final double diedInRound = getPositiveAverage(CombatantStatType.diedwhen, side);\n        return (diedPlayers * diedInRound + survivedPlayers * numberOfRounds) / totalPlayers;\n    }\n\n    private int numberOfClass(final CharacterClass charClass, final CombatantSide side) {\n        final DataSet data = allData.get(CombatantStatType.charclass);\n        // only available since v1.29\n        if (data == null) {\n            return 0;\n        }\n        final Integer value = Integer.valueOf(charClass.ordinal());\n        return data.countOfValuesWith(value, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfAdventurers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfAdventurers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.ADVENTURER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfDuelants(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfDuelants(final CombatantSide side) {\n        return numberOfClass(CharacterClass.DUELANT, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfGreenhorns(CombatantSide)\n     */\n    public int numberOfGreenhorns(final CombatantSide side) {\n        return numberOfClass(CharacterClass.GREENHORN, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfSoldiers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfSoldiers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.SOLDIER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#numberOfWorkers(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfWorkers(final CombatantSide side) {\n        return numberOfClass(CharacterClass.WORKER, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageLevel(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageLevel(final CombatantSide side) {\n        return getAverage(CombatantStatType.charlevel, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#initialHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int initialHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.starthp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getPositiveAverage(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#endHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int endHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getPositiveSum(CombatantStatType.finishedhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthPerPlayer(final CombatantSide side) {\n        return (int) Math.round(getAverage(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#maxPossibleHealthWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int maxPossibleHealthWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.maxhp, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#causedDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int causedDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.totalcauseddamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#shotsFiredPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double shotsFiredPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side) + getAverage(CombatantStatType.misscount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#hitsPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double hitsPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.hitcount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamagePerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double takenDamagePerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.takendamage, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#takenDamageWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int takenDamageWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.takendamage, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#averageHitDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageHitDamage(final CombatantSide side) {\n        // don't count the misses\n        final double teamHits = hitsWholeSide(side);\n        if (teamHits == 0) {\n            return 0;\n        }\n        final double teamDamage = causedDamageWholeSide(side);\n        final double totalCalculated = teamDamage / teamHits;\n        return totalCalculated;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double dodgesPerPlayer(final CombatantSide side) {\n        return getAverage(CombatantStatType.dodgecount, side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#dodgesWholeSide(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int dodgesWholeSide(final CombatantSide side) {\n        return (int) Math.round(getSum(CombatantStatType.dodgecount, side));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistribution(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Number> healthDistribution(final CombatantSide side) {\n        // initialize map\n        final SortedMap<Number, Number> result = new TreeMap<Number, Number>();\n        final int maxHP = 14000;\n        final int step = 1000;\n        for (int limit = step; limit <= maxHP; limit += step) {\n            result.put(Integer.valueOf(limit), new AtomicInteger());\n        }\n        // fill with values\n        final CombatantStatType stat = CombatantStatType.starthp;\n        if (allData.containsKey(stat)) {\n            final DataSet statData = allData.get(stat);\n            final List<Integer> data = statData.getSideData(side);\n            for (final Integer value : data) {\n                Number key = getUpperLimit(value.intValue(), step);\n                if (!result.containsKey(key)) {\n                    // out of range, put it to the last value\n                    key = result.lastKey();\n                }\n                ((AtomicInteger) result.get(key)).incrementAndGet();\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.StaticStatistics#healthDistributionRelative(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public SortedMap<Number, Double> healthDistributionRelative(final CombatantSide side) {\n        final SortedMap<Number, Number> distribution = healthDistribution(side);\n        final TreeMap<Number, Double> result = new TreeMap<Number, Double>();\n        final double totalPlayers = numberOfPlayers(side);\n        for (final Entry<Number, Number> mapping : distribution.entrySet()) {\n            final double currentPlayers = mapping.getValue().doubleValue();\n            final Double percentage = Double.valueOf(currentPlayers / totalPlayers * 100.0);\n            result.put(mapping.getKey(), percentage);\n        }\n        return result;\n    }\n\n    /**\n     * @param value\n     * @param step\n     * @return\n     */\n    private Number getUpperLimit(final int value, final int step) {\n        int limit = 0;\n        while (value > limit) {\n            limit += step;\n        }\n        return Integer.valueOf(limit);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/CombatantStatistic_28Test.java",
		"test_prompt": "// CombatantStatistic_28Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CombatantStatistic}.\n* It contains ten unit test cases for the {@link CombatantStatistic#healthDistributionRelative(CombatantSide)} method.\n*/\nclass CombatantStatistic_28Test {"
	},
	{
		"original_code": "// BattleStatistics.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\n\n/**\n * @author daniel\n */\npublic class BattleStatistics implements DynamicStatistics, CombatantObserver {\n\n    private static final transient Logger LOG = Logger.getLogger(BattleStatistics.class.getName());\n\n    private final Map<Combatant, OnlineCounter> onliners = new HashMap<Combatant, OnlineCounter>();\n\n    private final Map<CombatantSide, List<CriticalHit>> critHits = new HashMap<CombatantSide, List<CriticalHit>>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            critHits.put(side, new ArrayList<CriticalHit>());\n        }\n    }\n\n    private final Map<CombatantSide, Set<PositionSwitch>> swapList = new HashMap<CombatantSide, Set<PositionSwitch>>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            swapList.put(side, new HashSet<PositionSwitch>());\n        }\n    }\n\n    private final AllCombatantSidesCounter crits = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter moves = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter swaps = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter attackBonuses = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter defenseBonuses = new AllCombatantSidesCounter();\n\n    private final Map<Combatant, Counter> shots = new HashMap<Combatant, Counter>();\n\n    private final Map<CombatantSide, RoundStatistics> shotsPerRound = new HashMap<CombatantSide, RoundStatistics>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            shotsPerRound.put(side, new RoundStatistics(\"shots\", \"shots\"));\n        }\n    }\n\n    private final Map<CombatantSide, RoundStatistics> hitsPerRound = new HashMap<CombatantSide, RoundStatistics>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            hitsPerRound.put(side, new RoundStatistics(\"hits\", \"hits\"));\n        }\n    }\n\n    private final Map<CombatantSide, AtomicInteger> shotRoundCounter = new HashMap<CombatantSide, AtomicInteger>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            shotRoundCounter.put(side, new AtomicInteger());\n        }\n    }\n\n    private final Map<CombatantSide, AtomicInteger> hitRoundCounter = new HashMap<CombatantSide, AtomicInteger>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            hitRoundCounter.put(side, new AtomicInteger());\n        }\n    }\n\n    private final Map<Combatant, Counter> victims = new HashMap<Combatant, Counter>();\n\n    private final List<Combatant> turnOrder = new LinkedList<Combatant>();\n\n    private final List<AllCombatantSidesCounter> actorsPerRound = new ArrayList<AllCombatantSidesCounter>(50);\n\n    private final Map<Area, AreaStatistic> fieldStats = new HashMap<Area, AreaStatistic>();\n\n    private final int _numberOfDefenders;\n\n    private final int _numberOfAttacker;\n\n    private int currentRoundNo = 0;\n\n    private Boolean firstRound = null;\n\n    private AllCombatantSidesCounter actorsThisRound = new AllCombatantSidesCounter();\n\n    /**\n     * set the current round. all following method calls will belong to this\n     * round till this method is called again with another parameter.\n     *\n     * @param no\n     */\n    public void setRound(final int no) {\n        if (firstRound == null) {\n            firstRound = Boolean.TRUE;\n        } else if (firstRound.booleanValue()) {\n            firstRound = Boolean.FALSE;\n            // the turn order is determined only in the first round\n            for (final Combatant player : onliners.keySet()) {\n                if (!turnOrder.contains(player)) {\n                    LOG.info(\"could not determine turn order for \" + player);\n                }\n            }\n        }\n        addAndResetRoundCounter(shotRoundCounter, shotsPerRound);\n        addAndResetRoundCounter(hitRoundCounter, hitsPerRound);\n        actorsPerRound.add(actorsThisRound);\n        actorsThisRound = new AllCombatantSidesCounter();\n        currentRoundNo = no;\n    }\n\n    /**\n     * this adds the counters for the last round to the total counts per round\n     * and resets the given counter\n     *\n     * @param roundCounter\n     * @param allRounds\n     */\n    void addAndResetRoundCounter(final Map<CombatantSide, AtomicInteger> roundCounter, final Map<CombatantSide, RoundStatistics> allRounds) {\n        for (final Entry<CombatantSide, AtomicInteger> mapping : roundCounter.entrySet()) {\n            final CombatantSide side = mapping.getKey();\n            final AtomicInteger roundShots = mapping.getValue();\n            allRounds.get(side).addValue(roundShots.get());\n            // reset for next round\n            roundShots.set(0);\n        }\n    }\n\n    /**\n     * @param combatant\n     * @return\n     */\n    int combatantLifetime(final Combatant combatant) {\n        final OnlineCounter onAndOffline = onliners.get(combatant);\n        if (onAndOffline == null) {\n            return 0;\n        }\n        return onAndOffline.sumOfEvents();\n    }\n\n    /**\n     * @param numberOfAttacker\n     * @param numberOfDefenders\n     */\n    public BattleStatistics(final int numberOfAttacker, final int numberOfDefenders) {\n        _numberOfAttacker = numberOfAttacker;\n        _numberOfDefenders = numberOfDefenders;\n    }\n\n    /**\n     * @param number\n     * @return\n     */\n    int round(final double number) {\n        return (int) Math.round(number);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#percentAbleToShoot(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int percentAbleToShoot(final CombatantSide side) {\n        double sum = 0;\n        int players = 0;\n        for (final Entry<Combatant, Counter> playerShots : shots.entrySet()) {\n            final Combatant combatant = playerShots.getKey();\n            if (isOnSide(side, combatant)) {\n                final int lifetime = combatantLifetime(combatant);\n                final int roundsShooting = playerShots.getValue().getValue();\n                sum += roundsShooting * 100.0 / lifetime;\n                players++;\n            }\n        }\n        if (players == 0) {\n            return 0;\n        }\n        return round(sum / players);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#amountOfAttackBonus(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int amountOfAttackBonus(final CombatantSide side) {\n        return attackBonuses.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#amountOfDefenseBonus(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int amountOfDefenseBonus(final CombatantSide side) {\n        return defenseBonuses.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfMovesPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double numberOfMovesPerPlayer(final CombatantSide side) {\n        double result = 0;\n        switch(side) {\n            case ATTACKER:\n                result = moves.getSideValue(side) / (double) _numberOfAttacker;\n                break;\n            case DEFENDER:\n                result = moves.getSideValue(side) / (double) _numberOfDefenders;\n                break;\n            default:\n                result = moves.getSideValue(null) / (double) (_numberOfAttacker + _numberOfDefenders);\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfOffliners(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfOffliners(final CombatantSide side) {\n        int offliner = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (counter.wasOffline()) {\n                    offliner++;\n                }\n            }\n        }\n        return offliner;\n    }\n\n    /**\n     * @param side\n     * @param combatant\n     * @return\n     */\n    private boolean isOnSide(final CombatantSide side, final Combatant combatant) {\n        return side == null || side.equals(combatant.getSide());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#roundsTillOnline(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double roundsTillOnline(final CombatantSide side) {\n        int combatants = 0;\n        int rounds = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (!counter.wasOffline()) {\n                    combatants++;\n                    rounds += counter.firstOnline();\n                }\n            }\n        }\n        // avoid division by zero\n        if (combatants == 0) {\n            return 0;\n        }\n        return ((double) rounds / (double) combatants);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#averageRoundsOnline(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageRoundsOnline(final CombatantSide side) {\n        double combatants = 0;\n        double rounds = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (!counter.wasOffline()) {\n                    combatants++;\n                    rounds += counter.onlineEvents();\n                }\n            }\n        }\n        // avoid division by zero\n        if (combatants == 0.0) {\n            return 0.0;\n        }\n        return rounds / combatants;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#hasMoved(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Area)\n     */\n    public void hasMoved(final Combatant combatant, final Area newPos) {\n        moves.incrementSide(combatant);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#newDestination(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Area)\n     */\n    public void newDestination(final Combatant combatant, final Area destination) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#aimsAt(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void aimsAt(final Combatant combatant, final Combatant target) {\n        incrementCombatantCounter(shots, combatant);\n        incrementCombatantCounter(victims, target);\n        shotRoundCounter.get(combatant.getSide()).incrementAndGet();\n        final Area field = target._getLocation();\n        getFieldStat(field).addShot();\n    }\n\n    private void incrementCombatantCounter(final Map<Combatant, Counter> combatantCounters, final Combatant combatant) {\n        if (!combatantCounters.containsKey(combatant)) {\n            combatantCounters.put(combatant, new Counter());\n        }\n        combatantCounters.get(combatant).increment();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isHit(de.outstare.fortbattleplayer.model.Combatant,\n     *      int, int)\n     */\n    public void isHit(final Combatant combatant, final int damage, final int oldHealthAmount) {\n        hitRoundCounter.get(combatant.getSide()).incrementAndGet();\n        final Area field = combatant._getLocation();\n        getFieldStat(field).addHit();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isDead(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void isDead(final Combatant combatant) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isAlive(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void isAlive(final Combatant combatant) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isOnline(de.outstare.fortbattleplayer.model.Combatant,\n     *      boolean)\n     */\n    public void isOnline(final Combatant combatant, final boolean changed) {\n        // count all events\n        if (!onliners.containsKey(combatant)) {\n            onliners.put(combatant, new OnlineCounter());\n        }\n        if (combatant.isOnline()) {\n            onliners.get(combatant).addOnline();\n        } else {\n            onliners.get(combatant).addOffline();\n        }\n        // the online event is triggered every round for a player (hopefully)\n        combatantTurn(combatant);\n    }\n\n    /**\n     * no special action, just to track the state every round\n     *\n     * @param combatant\n     */\n    private void combatantTurn(final Combatant combatant) {\n        final SectorBonus bonus = combatant.getSectorBonus();\n        attackBonuses.incrementBy(bonus.attackBonus, combatant);\n        defenseBonuses.incrementBy(bonus.defendBonus, combatant);\n        if (firstRound != null && firstRound.booleanValue()) {\n            turnOrder.add(combatant);\n        }\n        if (LOG.isLoggable(Level.FINE)) {\n            if ((firstRound == null || !firstRound.booleanValue()) && !turnOrder.contains(combatant) && currentRoundNo > 1) {\n                LOG.fine(\"---- not in order: \" + combatant);\n            }\n        }\n        actorsThisRound.incrementSide(combatant);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#targetNoOne(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public String targetNoOne(final CombatantSide side) {\n        String result = \"\";\n        int max = 0;\n        for (final Entry<Combatant, Counter> victim : victims.entrySet()) {\n            final Combatant combatant = victim.getKey();\n            if (isOnSide(side, combatant)) {\n                final int receivedShots = victim.getValue().getValue();\n                if (receivedShots > max) {\n                    max = receivedShots;\n                    result = combatant.getName() + \"(\" + receivedShots + \")\";\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfBayonets(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfBayonets(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.BayonetCounter());\n    }\n\n    /**\n     * @param side\n     * @param counter\n     * @return\n     */\n    int countWeaponMods(final CombatantSide side, final WeaponModCounter counter) {\n        // because every player should have an online/offline event, we look at\n        // the online data hoping to get all players\n        final Set<Combatant> players = onliners.keySet();\n        int bayonets = 0;\n        for (final Combatant combatant : players) {\n            if (isOnSide(side, combatant)) {\n                final Weapon playerWeapon = combatant.getWeapon();\n                // TODO let the counter count\n                if (counter.counts(playerWeapon)) {\n                    bayonets++;\n                }\n            }\n        }\n        return bayonets;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfGraphitLubricants(CombatantSide)\n     */\n    public int numberOfGraphitLubricants(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.GraphitLubricantCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfFettesOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfFettesOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.FettesOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfSchmierOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfSchmierOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.SchmierOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfShinyOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfShinyOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.ShinyOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfLoadingChamerOrEnhancedPatrons(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfLoadingChamerOrEnhancedPatrons(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.LoadingchamberOrEnhancedPatronsCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfHipFlasks(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfHipFlasks(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.HipFlaskCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#hasSwappedPosition()\n     */\n    public void hasSwappedPosition(final Combatant combatant, final Combatant swappedWith) {\n        swaps.incrementSide(combatant);\n        final PositionSwitch swap = new PositionSwitch(currentRoundNo, combatant, swappedWith);\n        assert swapList.get(combatant.getSide()) != null;\n        swapList.get(combatant.getSide()).add(swap);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#totalSwaps(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int totalSwaps(final CombatantSide side) {\n        return swaps.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#switchedPosList(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public Set<PositionSwitch> switchedPosList(final CombatantSide side) {\n        final Set<PositionSwitch> allSwaps;\n        if (side == null) {\n            allSwaps = new HashSet<PositionSwitch>();\n            for (final Set<PositionSwitch> sideSwitches : swapList.values()) {\n                allSwaps.addAll(sideSwitches);\n            }\n        } else {\n            allSwaps = swapList.get(side);\n        }\n        return allSwaps;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#criticalShot(de.outstare.fortbattleplayer.model.Combatant,\n     *      Combatant, int)\n     */\n    public void criticalShot(final Combatant combatant, final Combatant victim, final int damage) {\n        final CriticalHit crit = new CriticalHit(combatant, victim, damage, currentRoundNo);\n        critHits.get(combatant.getSide()).add(crit);\n        crits.incrementSide(combatant);\n        final Area field = victim._getLocation();\n        getFieldStat(field).addCrit();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#critList(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public List<CriticalHit> critList(final CombatantSide side) {\n        final List<CriticalHit> allCrits;\n        if (side == null) {\n            allCrits = new ArrayList<CriticalHit>();\n            for (final List<CriticalHit> sideCrits : critHits.values()) {\n                allCrits.addAll(sideCrits);\n            }\n        } else {\n            allCrits = critHits.get(side);\n        }\n        return allCrits;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#criticalHits(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int criticalHits(final CombatantSide side) {\n        return crits.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#criticalHitDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public long criticalHitDamage(final CombatantSide side) {\n        long sum = 0;\n        for (final CriticalHit crit : critList(side)) {\n            sum += crit.critOnlyDamage;\n        }\n        return sum;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#turnOrder(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public List<Combatant> turnOrder(final CombatantSide side) {\n        final List<Combatant> sidePlayers = new ArrayList<Combatant>(turnOrder.size() / 2);\n        for (final Combatant player : turnOrder) {\n            if (side == null || player.getSide() == side) {\n                sidePlayers.add(player);\n            }\n        }\n        return sidePlayers;\n    }\n\n    /**\n     * @return the number of shots per round\n     */\n    public Map<CombatantSide, ? extends LabeledData> getShotsPerRound() {\n        return shotsPerRound;\n    }\n\n    /**\n     * @return the number of hits per round\n     */\n    public Map<CombatantSide, ? extends LabeledData> getHitsPerRound() {\n        return hitsPerRound;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#getNotShootersPerRound()\n     */\n    public Map<CombatantSide, ? extends LabeledData> getNotShootersPerRound() {\n        final Map<CombatantSide, RoundStatistics> nonShootersPerRound = new HashMap<CombatantSide, RoundStatistics>();\n        for (final CombatantSide side : CombatantSide.values()) {\n            final RoundStatistics nonShooters = new RoundStatistics(\"Not shooting\", \"players\");\n            nonShootersPerRound.put(side, nonShooters);\n            final LabeledData shotRoundCounts = shotsPerRound.get(side);\n            if (shotRoundCounts != null) {\n                final double[] shotCounts = shotRoundCounts.toArray();\n                if (actorsPerRound.size() == shotCounts.length) {\n                    for (int i = 0; i < shotCounts.length; i++) {\n                        final int actors = actorsPerRound.get(i).getSideValue(side);\n                        final double numberNotShooting = actors - shotCounts[i];\n                        nonShooters.addValue(numberNotShooting);\n                    }\n                } else {\n                    LOG.warning(\"round statistics for players and shots differ!\");\n                }\n            } else {\n                LOG.warning(\"no data for players and shots for side \" + side);\n            }\n        }\n        return nonShootersPerRound;\n    }\n\n    private AreaStatistic getFieldStat(final Area area) {\n        if (!fieldStats.containsKey(area)) {\n            fieldStats.put(area, new AreaStatistic(area));\n        }\n        return fieldStats.get(area);\n    }\n\n    /**\n     * @return statistics for every field\n     */\n    public Map<Area, AreaStatistic> getFieldStatistics() {\n        return fieldStats;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/BattleStatistics_0Test.java",
		"test_prompt": "// BattleStatistics_0Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BattleStatistics}.\n* It contains ten unit test cases for the {@link BattleStatistics#percentAbleToShoot(CombatantSide)} method.\n*/\nclass BattleStatistics_0Test {"
	},
	{
		"original_code": "// BattleStatistics.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\n\n/**\n * @author daniel\n */\npublic class BattleStatistics implements DynamicStatistics, CombatantObserver {\n\n    private static final transient Logger LOG = Logger.getLogger(BattleStatistics.class.getName());\n\n    private final Map<Combatant, OnlineCounter> onliners = new HashMap<Combatant, OnlineCounter>();\n\n    private final Map<CombatantSide, List<CriticalHit>> critHits = new HashMap<CombatantSide, List<CriticalHit>>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            critHits.put(side, new ArrayList<CriticalHit>());\n        }\n    }\n\n    private final Map<CombatantSide, Set<PositionSwitch>> swapList = new HashMap<CombatantSide, Set<PositionSwitch>>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            swapList.put(side, new HashSet<PositionSwitch>());\n        }\n    }\n\n    private final AllCombatantSidesCounter crits = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter moves = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter swaps = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter attackBonuses = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter defenseBonuses = new AllCombatantSidesCounter();\n\n    private final Map<Combatant, Counter> shots = new HashMap<Combatant, Counter>();\n\n    private final Map<CombatantSide, RoundStatistics> shotsPerRound = new HashMap<CombatantSide, RoundStatistics>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            shotsPerRound.put(side, new RoundStatistics(\"shots\", \"shots\"));\n        }\n    }\n\n    private final Map<CombatantSide, RoundStatistics> hitsPerRound = new HashMap<CombatantSide, RoundStatistics>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            hitsPerRound.put(side, new RoundStatistics(\"hits\", \"hits\"));\n        }\n    }\n\n    private final Map<CombatantSide, AtomicInteger> shotRoundCounter = new HashMap<CombatantSide, AtomicInteger>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            shotRoundCounter.put(side, new AtomicInteger());\n        }\n    }\n\n    private final Map<CombatantSide, AtomicInteger> hitRoundCounter = new HashMap<CombatantSide, AtomicInteger>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            hitRoundCounter.put(side, new AtomicInteger());\n        }\n    }\n\n    private final Map<Combatant, Counter> victims = new HashMap<Combatant, Counter>();\n\n    private final List<Combatant> turnOrder = new LinkedList<Combatant>();\n\n    private final List<AllCombatantSidesCounter> actorsPerRound = new ArrayList<AllCombatantSidesCounter>(50);\n\n    private final Map<Area, AreaStatistic> fieldStats = new HashMap<Area, AreaStatistic>();\n\n    private final int _numberOfDefenders;\n\n    private final int _numberOfAttacker;\n\n    private int currentRoundNo = 0;\n\n    private Boolean firstRound = null;\n\n    private AllCombatantSidesCounter actorsThisRound = new AllCombatantSidesCounter();\n\n    /**\n     * set the current round. all following method calls will belong to this\n     * round till this method is called again with another parameter.\n     *\n     * @param no\n     */\n    public void setRound(final int no) {\n        if (firstRound == null) {\n            firstRound = Boolean.TRUE;\n        } else if (firstRound.booleanValue()) {\n            firstRound = Boolean.FALSE;\n            // the turn order is determined only in the first round\n            for (final Combatant player : onliners.keySet()) {\n                if (!turnOrder.contains(player)) {\n                    LOG.info(\"could not determine turn order for \" + player);\n                }\n            }\n        }\n        addAndResetRoundCounter(shotRoundCounter, shotsPerRound);\n        addAndResetRoundCounter(hitRoundCounter, hitsPerRound);\n        actorsPerRound.add(actorsThisRound);\n        actorsThisRound = new AllCombatantSidesCounter();\n        currentRoundNo = no;\n    }\n\n    /**\n     * this adds the counters for the last round to the total counts per round\n     * and resets the given counter\n     *\n     * @param roundCounter\n     * @param allRounds\n     */\n    void addAndResetRoundCounter(final Map<CombatantSide, AtomicInteger> roundCounter, final Map<CombatantSide, RoundStatistics> allRounds) {\n        for (final Entry<CombatantSide, AtomicInteger> mapping : roundCounter.entrySet()) {\n            final CombatantSide side = mapping.getKey();\n            final AtomicInteger roundShots = mapping.getValue();\n            allRounds.get(side).addValue(roundShots.get());\n            // reset for next round\n            roundShots.set(0);\n        }\n    }\n\n    /**\n     * @param combatant\n     * @return\n     */\n    int combatantLifetime(final Combatant combatant) {\n        final OnlineCounter onAndOffline = onliners.get(combatant);\n        if (onAndOffline == null) {\n            return 0;\n        }\n        return onAndOffline.sumOfEvents();\n    }\n\n    /**\n     * @param numberOfAttacker\n     * @param numberOfDefenders\n     */\n    public BattleStatistics(final int numberOfAttacker, final int numberOfDefenders) {\n        _numberOfAttacker = numberOfAttacker;\n        _numberOfDefenders = numberOfDefenders;\n    }\n\n    /**\n     * @param number\n     * @return\n     */\n    int round(final double number) {\n        return (int) Math.round(number);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#percentAbleToShoot(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int percentAbleToShoot(final CombatantSide side) {\n        double sum = 0;\n        int players = 0;\n        for (final Entry<Combatant, Counter> playerShots : shots.entrySet()) {\n            final Combatant combatant = playerShots.getKey();\n            if (isOnSide(side, combatant)) {\n                final int lifetime = combatantLifetime(combatant);\n                final int roundsShooting = playerShots.getValue().getValue();\n                sum += roundsShooting * 100.0 / lifetime;\n                players++;\n            }\n        }\n        if (players == 0) {\n            return 0;\n        }\n        return round(sum / players);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#amountOfAttackBonus(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int amountOfAttackBonus(final CombatantSide side) {\n        return attackBonuses.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#amountOfDefenseBonus(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int amountOfDefenseBonus(final CombatantSide side) {\n        return defenseBonuses.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfMovesPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double numberOfMovesPerPlayer(final CombatantSide side) {\n        double result = 0;\n        switch(side) {\n            case ATTACKER:\n                result = moves.getSideValue(side) / (double) _numberOfAttacker;\n                break;\n            case DEFENDER:\n                result = moves.getSideValue(side) / (double) _numberOfDefenders;\n                break;\n            default:\n                result = moves.getSideValue(null) / (double) (_numberOfAttacker + _numberOfDefenders);\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfOffliners(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfOffliners(final CombatantSide side) {\n        int offliner = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (counter.wasOffline()) {\n                    offliner++;\n                }\n            }\n        }\n        return offliner;\n    }\n\n    /**\n     * @param side\n     * @param combatant\n     * @return\n     */\n    private boolean isOnSide(final CombatantSide side, final Combatant combatant) {\n        return side == null || side.equals(combatant.getSide());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#roundsTillOnline(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double roundsTillOnline(final CombatantSide side) {\n        int combatants = 0;\n        int rounds = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (!counter.wasOffline()) {\n                    combatants++;\n                    rounds += counter.firstOnline();\n                }\n            }\n        }\n        // avoid division by zero\n        if (combatants == 0) {\n            return 0;\n        }\n        return ((double) rounds / (double) combatants);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#averageRoundsOnline(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageRoundsOnline(final CombatantSide side) {\n        double combatants = 0;\n        double rounds = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (!counter.wasOffline()) {\n                    combatants++;\n                    rounds += counter.onlineEvents();\n                }\n            }\n        }\n        // avoid division by zero\n        if (combatants == 0.0) {\n            return 0.0;\n        }\n        return rounds / combatants;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#hasMoved(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Area)\n     */\n    public void hasMoved(final Combatant combatant, final Area newPos) {\n        moves.incrementSide(combatant);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#newDestination(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Area)\n     */\n    public void newDestination(final Combatant combatant, final Area destination) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#aimsAt(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void aimsAt(final Combatant combatant, final Combatant target) {\n        incrementCombatantCounter(shots, combatant);\n        incrementCombatantCounter(victims, target);\n        shotRoundCounter.get(combatant.getSide()).incrementAndGet();\n        final Area field = target._getLocation();\n        getFieldStat(field).addShot();\n    }\n\n    private void incrementCombatantCounter(final Map<Combatant, Counter> combatantCounters, final Combatant combatant) {\n        if (!combatantCounters.containsKey(combatant)) {\n            combatantCounters.put(combatant, new Counter());\n        }\n        combatantCounters.get(combatant).increment();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isHit(de.outstare.fortbattleplayer.model.Combatant,\n     *      int, int)\n     */\n    public void isHit(final Combatant combatant, final int damage, final int oldHealthAmount) {\n        hitRoundCounter.get(combatant.getSide()).incrementAndGet();\n        final Area field = combatant._getLocation();\n        getFieldStat(field).addHit();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isDead(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void isDead(final Combatant combatant) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isAlive(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void isAlive(final Combatant combatant) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isOnline(de.outstare.fortbattleplayer.model.Combatant,\n     *      boolean)\n     */\n    public void isOnline(final Combatant combatant, final boolean changed) {\n        // count all events\n        if (!onliners.containsKey(combatant)) {\n            onliners.put(combatant, new OnlineCounter());\n        }\n        if (combatant.isOnline()) {\n            onliners.get(combatant).addOnline();\n        } else {\n            onliners.get(combatant).addOffline();\n        }\n        // the online event is triggered every round for a player (hopefully)\n        combatantTurn(combatant);\n    }\n\n    /**\n     * no special action, just to track the state every round\n     *\n     * @param combatant\n     */\n    private void combatantTurn(final Combatant combatant) {\n        final SectorBonus bonus = combatant.getSectorBonus();\n        attackBonuses.incrementBy(bonus.attackBonus, combatant);\n        defenseBonuses.incrementBy(bonus.defendBonus, combatant);\n        if (firstRound != null && firstRound.booleanValue()) {\n            turnOrder.add(combatant);\n        }\n        if (LOG.isLoggable(Level.FINE)) {\n            if ((firstRound == null || !firstRound.booleanValue()) && !turnOrder.contains(combatant) && currentRoundNo > 1) {\n                LOG.fine(\"---- not in order: \" + combatant);\n            }\n        }\n        actorsThisRound.incrementSide(combatant);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#targetNoOne(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public String targetNoOne(final CombatantSide side) {\n        String result = \"\";\n        int max = 0;\n        for (final Entry<Combatant, Counter> victim : victims.entrySet()) {\n            final Combatant combatant = victim.getKey();\n            if (isOnSide(side, combatant)) {\n                final int receivedShots = victim.getValue().getValue();\n                if (receivedShots > max) {\n                    max = receivedShots;\n                    result = combatant.getName() + \"(\" + receivedShots + \")\";\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfBayonets(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfBayonets(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.BayonetCounter());\n    }\n\n    /**\n     * @param side\n     * @param counter\n     * @return\n     */\n    int countWeaponMods(final CombatantSide side, final WeaponModCounter counter) {\n        // because every player should have an online/offline event, we look at\n        // the online data hoping to get all players\n        final Set<Combatant> players = onliners.keySet();\n        int bayonets = 0;\n        for (final Combatant combatant : players) {\n            if (isOnSide(side, combatant)) {\n                final Weapon playerWeapon = combatant.getWeapon();\n                // TODO let the counter count\n                if (counter.counts(playerWeapon)) {\n                    bayonets++;\n                }\n            }\n        }\n        return bayonets;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfGraphitLubricants(CombatantSide)\n     */\n    public int numberOfGraphitLubricants(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.GraphitLubricantCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfFettesOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfFettesOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.FettesOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfSchmierOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfSchmierOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.SchmierOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfShinyOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfShinyOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.ShinyOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfLoadingChamerOrEnhancedPatrons(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfLoadingChamerOrEnhancedPatrons(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.LoadingchamberOrEnhancedPatronsCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfHipFlasks(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfHipFlasks(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.HipFlaskCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#hasSwappedPosition()\n     */\n    public void hasSwappedPosition(final Combatant combatant, final Combatant swappedWith) {\n        swaps.incrementSide(combatant);\n        final PositionSwitch swap = new PositionSwitch(currentRoundNo, combatant, swappedWith);\n        assert swapList.get(combatant.getSide()) != null;\n        swapList.get(combatant.getSide()).add(swap);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#totalSwaps(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int totalSwaps(final CombatantSide side) {\n        return swaps.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#switchedPosList(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public Set<PositionSwitch> switchedPosList(final CombatantSide side) {\n        final Set<PositionSwitch> allSwaps;\n        if (side == null) {\n            allSwaps = new HashSet<PositionSwitch>();\n            for (final Set<PositionSwitch> sideSwitches : swapList.values()) {\n                allSwaps.addAll(sideSwitches);\n            }\n        } else {\n            allSwaps = swapList.get(side);\n        }\n        return allSwaps;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#criticalShot(de.outstare.fortbattleplayer.model.Combatant,\n     *      Combatant, int)\n     */\n    public void criticalShot(final Combatant combatant, final Combatant victim, final int damage) {\n        final CriticalHit crit = new CriticalHit(combatant, victim, damage, currentRoundNo);\n        critHits.get(combatant.getSide()).add(crit);\n        crits.incrementSide(combatant);\n        final Area field = victim._getLocation();\n        getFieldStat(field).addCrit();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#critList(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public List<CriticalHit> critList(final CombatantSide side) {\n        final List<CriticalHit> allCrits;\n        if (side == null) {\n            allCrits = new ArrayList<CriticalHit>();\n            for (final List<CriticalHit> sideCrits : critHits.values()) {\n                allCrits.addAll(sideCrits);\n            }\n        } else {\n            allCrits = critHits.get(side);\n        }\n        return allCrits;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#criticalHits(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int criticalHits(final CombatantSide side) {\n        return crits.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#criticalHitDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public long criticalHitDamage(final CombatantSide side) {\n        long sum = 0;\n        for (final CriticalHit crit : critList(side)) {\n            sum += crit.critOnlyDamage;\n        }\n        return sum;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#turnOrder(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public List<Combatant> turnOrder(final CombatantSide side) {\n        final List<Combatant> sidePlayers = new ArrayList<Combatant>(turnOrder.size() / 2);\n        for (final Combatant player : turnOrder) {\n            if (side == null || player.getSide() == side) {\n                sidePlayers.add(player);\n            }\n        }\n        return sidePlayers;\n    }\n\n    /**\n     * @return the number of shots per round\n     */\n    public Map<CombatantSide, ? extends LabeledData> getShotsPerRound() {\n        return shotsPerRound;\n    }\n\n    /**\n     * @return the number of hits per round\n     */\n    public Map<CombatantSide, ? extends LabeledData> getHitsPerRound() {\n        return hitsPerRound;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#getNotShootersPerRound()\n     */\n    public Map<CombatantSide, ? extends LabeledData> getNotShootersPerRound() {\n        final Map<CombatantSide, RoundStatistics> nonShootersPerRound = new HashMap<CombatantSide, RoundStatistics>();\n        for (final CombatantSide side : CombatantSide.values()) {\n            final RoundStatistics nonShooters = new RoundStatistics(\"Not shooting\", \"players\");\n            nonShootersPerRound.put(side, nonShooters);\n            final LabeledData shotRoundCounts = shotsPerRound.get(side);\n            if (shotRoundCounts != null) {\n                final double[] shotCounts = shotRoundCounts.toArray();\n                if (actorsPerRound.size() == shotCounts.length) {\n                    for (int i = 0; i < shotCounts.length; i++) {\n                        final int actors = actorsPerRound.get(i).getSideValue(side);\n                        final double numberNotShooting = actors - shotCounts[i];\n                        nonShooters.addValue(numberNotShooting);\n                    }\n                } else {\n                    LOG.warning(\"round statistics for players and shots differ!\");\n                }\n            } else {\n                LOG.warning(\"no data for players and shots for side \" + side);\n            }\n        }\n        return nonShootersPerRound;\n    }\n\n    private AreaStatistic getFieldStat(final Area area) {\n        if (!fieldStats.containsKey(area)) {\n            fieldStats.put(area, new AreaStatistic(area));\n        }\n        return fieldStats.get(area);\n    }\n\n    /**\n     * @return statistics for every field\n     */\n    public Map<Area, AreaStatistic> getFieldStatistics() {\n        return fieldStats;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/BattleStatistics_1Test.java",
		"test_prompt": "// BattleStatistics_1Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BattleStatistics}.\n* It contains ten unit test cases for the {@link BattleStatistics#amountOfAttackBonus(CombatantSide)} method.\n*/\nclass BattleStatistics_1Test {"
	},
	{
		"original_code": "// BattleStatistics.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\n\n/**\n * @author daniel\n */\npublic class BattleStatistics implements DynamicStatistics, CombatantObserver {\n\n    private static final transient Logger LOG = Logger.getLogger(BattleStatistics.class.getName());\n\n    private final Map<Combatant, OnlineCounter> onliners = new HashMap<Combatant, OnlineCounter>();\n\n    private final Map<CombatantSide, List<CriticalHit>> critHits = new HashMap<CombatantSide, List<CriticalHit>>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            critHits.put(side, new ArrayList<CriticalHit>());\n        }\n    }\n\n    private final Map<CombatantSide, Set<PositionSwitch>> swapList = new HashMap<CombatantSide, Set<PositionSwitch>>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            swapList.put(side, new HashSet<PositionSwitch>());\n        }\n    }\n\n    private final AllCombatantSidesCounter crits = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter moves = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter swaps = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter attackBonuses = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter defenseBonuses = new AllCombatantSidesCounter();\n\n    private final Map<Combatant, Counter> shots = new HashMap<Combatant, Counter>();\n\n    private final Map<CombatantSide, RoundStatistics> shotsPerRound = new HashMap<CombatantSide, RoundStatistics>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            shotsPerRound.put(side, new RoundStatistics(\"shots\", \"shots\"));\n        }\n    }\n\n    private final Map<CombatantSide, RoundStatistics> hitsPerRound = new HashMap<CombatantSide, RoundStatistics>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            hitsPerRound.put(side, new RoundStatistics(\"hits\", \"hits\"));\n        }\n    }\n\n    private final Map<CombatantSide, AtomicInteger> shotRoundCounter = new HashMap<CombatantSide, AtomicInteger>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            shotRoundCounter.put(side, new AtomicInteger());\n        }\n    }\n\n    private final Map<CombatantSide, AtomicInteger> hitRoundCounter = new HashMap<CombatantSide, AtomicInteger>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            hitRoundCounter.put(side, new AtomicInteger());\n        }\n    }\n\n    private final Map<Combatant, Counter> victims = new HashMap<Combatant, Counter>();\n\n    private final List<Combatant> turnOrder = new LinkedList<Combatant>();\n\n    private final List<AllCombatantSidesCounter> actorsPerRound = new ArrayList<AllCombatantSidesCounter>(50);\n\n    private final Map<Area, AreaStatistic> fieldStats = new HashMap<Area, AreaStatistic>();\n\n    private final int _numberOfDefenders;\n\n    private final int _numberOfAttacker;\n\n    private int currentRoundNo = 0;\n\n    private Boolean firstRound = null;\n\n    private AllCombatantSidesCounter actorsThisRound = new AllCombatantSidesCounter();\n\n    /**\n     * set the current round. all following method calls will belong to this\n     * round till this method is called again with another parameter.\n     *\n     * @param no\n     */\n    public void setRound(final int no) {\n        if (firstRound == null) {\n            firstRound = Boolean.TRUE;\n        } else if (firstRound.booleanValue()) {\n            firstRound = Boolean.FALSE;\n            // the turn order is determined only in the first round\n            for (final Combatant player : onliners.keySet()) {\n                if (!turnOrder.contains(player)) {\n                    LOG.info(\"could not determine turn order for \" + player);\n                }\n            }\n        }\n        addAndResetRoundCounter(shotRoundCounter, shotsPerRound);\n        addAndResetRoundCounter(hitRoundCounter, hitsPerRound);\n        actorsPerRound.add(actorsThisRound);\n        actorsThisRound = new AllCombatantSidesCounter();\n        currentRoundNo = no;\n    }\n\n    /**\n     * this adds the counters for the last round to the total counts per round\n     * and resets the given counter\n     *\n     * @param roundCounter\n     * @param allRounds\n     */\n    void addAndResetRoundCounter(final Map<CombatantSide, AtomicInteger> roundCounter, final Map<CombatantSide, RoundStatistics> allRounds) {\n        for (final Entry<CombatantSide, AtomicInteger> mapping : roundCounter.entrySet()) {\n            final CombatantSide side = mapping.getKey();\n            final AtomicInteger roundShots = mapping.getValue();\n            allRounds.get(side).addValue(roundShots.get());\n            // reset for next round\n            roundShots.set(0);\n        }\n    }\n\n    /**\n     * @param combatant\n     * @return\n     */\n    int combatantLifetime(final Combatant combatant) {\n        final OnlineCounter onAndOffline = onliners.get(combatant);\n        if (onAndOffline == null) {\n            return 0;\n        }\n        return onAndOffline.sumOfEvents();\n    }\n\n    /**\n     * @param numberOfAttacker\n     * @param numberOfDefenders\n     */\n    public BattleStatistics(final int numberOfAttacker, final int numberOfDefenders) {\n        _numberOfAttacker = numberOfAttacker;\n        _numberOfDefenders = numberOfDefenders;\n    }\n\n    /**\n     * @param number\n     * @return\n     */\n    int round(final double number) {\n        return (int) Math.round(number);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#percentAbleToShoot(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int percentAbleToShoot(final CombatantSide side) {\n        double sum = 0;\n        int players = 0;\n        for (final Entry<Combatant, Counter> playerShots : shots.entrySet()) {\n            final Combatant combatant = playerShots.getKey();\n            if (isOnSide(side, combatant)) {\n                final int lifetime = combatantLifetime(combatant);\n                final int roundsShooting = playerShots.getValue().getValue();\n                sum += roundsShooting * 100.0 / lifetime;\n                players++;\n            }\n        }\n        if (players == 0) {\n            return 0;\n        }\n        return round(sum / players);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#amountOfAttackBonus(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int amountOfAttackBonus(final CombatantSide side) {\n        return attackBonuses.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#amountOfDefenseBonus(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int amountOfDefenseBonus(final CombatantSide side) {\n        return defenseBonuses.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfMovesPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double numberOfMovesPerPlayer(final CombatantSide side) {\n        double result = 0;\n        switch(side) {\n            case ATTACKER:\n                result = moves.getSideValue(side) / (double) _numberOfAttacker;\n                break;\n            case DEFENDER:\n                result = moves.getSideValue(side) / (double) _numberOfDefenders;\n                break;\n            default:\n                result = moves.getSideValue(null) / (double) (_numberOfAttacker + _numberOfDefenders);\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfOffliners(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfOffliners(final CombatantSide side) {\n        int offliner = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (counter.wasOffline()) {\n                    offliner++;\n                }\n            }\n        }\n        return offliner;\n    }\n\n    /**\n     * @param side\n     * @param combatant\n     * @return\n     */\n    private boolean isOnSide(final CombatantSide side, final Combatant combatant) {\n        return side == null || side.equals(combatant.getSide());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#roundsTillOnline(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double roundsTillOnline(final CombatantSide side) {\n        int combatants = 0;\n        int rounds = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (!counter.wasOffline()) {\n                    combatants++;\n                    rounds += counter.firstOnline();\n                }\n            }\n        }\n        // avoid division by zero\n        if (combatants == 0) {\n            return 0;\n        }\n        return ((double) rounds / (double) combatants);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#averageRoundsOnline(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageRoundsOnline(final CombatantSide side) {\n        double combatants = 0;\n        double rounds = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (!counter.wasOffline()) {\n                    combatants++;\n                    rounds += counter.onlineEvents();\n                }\n            }\n        }\n        // avoid division by zero\n        if (combatants == 0.0) {\n            return 0.0;\n        }\n        return rounds / combatants;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#hasMoved(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Area)\n     */\n    public void hasMoved(final Combatant combatant, final Area newPos) {\n        moves.incrementSide(combatant);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#newDestination(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Area)\n     */\n    public void newDestination(final Combatant combatant, final Area destination) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#aimsAt(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void aimsAt(final Combatant combatant, final Combatant target) {\n        incrementCombatantCounter(shots, combatant);\n        incrementCombatantCounter(victims, target);\n        shotRoundCounter.get(combatant.getSide()).incrementAndGet();\n        final Area field = target._getLocation();\n        getFieldStat(field).addShot();\n    }\n\n    private void incrementCombatantCounter(final Map<Combatant, Counter> combatantCounters, final Combatant combatant) {\n        if (!combatantCounters.containsKey(combatant)) {\n            combatantCounters.put(combatant, new Counter());\n        }\n        combatantCounters.get(combatant).increment();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isHit(de.outstare.fortbattleplayer.model.Combatant,\n     *      int, int)\n     */\n    public void isHit(final Combatant combatant, final int damage, final int oldHealthAmount) {\n        hitRoundCounter.get(combatant.getSide()).incrementAndGet();\n        final Area field = combatant._getLocation();\n        getFieldStat(field).addHit();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isDead(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void isDead(final Combatant combatant) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isAlive(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void isAlive(final Combatant combatant) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isOnline(de.outstare.fortbattleplayer.model.Combatant,\n     *      boolean)\n     */\n    public void isOnline(final Combatant combatant, final boolean changed) {\n        // count all events\n        if (!onliners.containsKey(combatant)) {\n            onliners.put(combatant, new OnlineCounter());\n        }\n        if (combatant.isOnline()) {\n            onliners.get(combatant).addOnline();\n        } else {\n            onliners.get(combatant).addOffline();\n        }\n        // the online event is triggered every round for a player (hopefully)\n        combatantTurn(combatant);\n    }\n\n    /**\n     * no special action, just to track the state every round\n     *\n     * @param combatant\n     */\n    private void combatantTurn(final Combatant combatant) {\n        final SectorBonus bonus = combatant.getSectorBonus();\n        attackBonuses.incrementBy(bonus.attackBonus, combatant);\n        defenseBonuses.incrementBy(bonus.defendBonus, combatant);\n        if (firstRound != null && firstRound.booleanValue()) {\n            turnOrder.add(combatant);\n        }\n        if (LOG.isLoggable(Level.FINE)) {\n            if ((firstRound == null || !firstRound.booleanValue()) && !turnOrder.contains(combatant) && currentRoundNo > 1) {\n                LOG.fine(\"---- not in order: \" + combatant);\n            }\n        }\n        actorsThisRound.incrementSide(combatant);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#targetNoOne(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public String targetNoOne(final CombatantSide side) {\n        String result = \"\";\n        int max = 0;\n        for (final Entry<Combatant, Counter> victim : victims.entrySet()) {\n            final Combatant combatant = victim.getKey();\n            if (isOnSide(side, combatant)) {\n                final int receivedShots = victim.getValue().getValue();\n                if (receivedShots > max) {\n                    max = receivedShots;\n                    result = combatant.getName() + \"(\" + receivedShots + \")\";\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfBayonets(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfBayonets(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.BayonetCounter());\n    }\n\n    /**\n     * @param side\n     * @param counter\n     * @return\n     */\n    int countWeaponMods(final CombatantSide side, final WeaponModCounter counter) {\n        // because every player should have an online/offline event, we look at\n        // the online data hoping to get all players\n        final Set<Combatant> players = onliners.keySet();\n        int bayonets = 0;\n        for (final Combatant combatant : players) {\n            if (isOnSide(side, combatant)) {\n                final Weapon playerWeapon = combatant.getWeapon();\n                // TODO let the counter count\n                if (counter.counts(playerWeapon)) {\n                    bayonets++;\n                }\n            }\n        }\n        return bayonets;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfGraphitLubricants(CombatantSide)\n     */\n    public int numberOfGraphitLubricants(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.GraphitLubricantCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfFettesOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfFettesOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.FettesOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfSchmierOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfSchmierOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.SchmierOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfShinyOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfShinyOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.ShinyOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfLoadingChamerOrEnhancedPatrons(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfLoadingChamerOrEnhancedPatrons(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.LoadingchamberOrEnhancedPatronsCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfHipFlasks(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfHipFlasks(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.HipFlaskCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#hasSwappedPosition()\n     */\n    public void hasSwappedPosition(final Combatant combatant, final Combatant swappedWith) {\n        swaps.incrementSide(combatant);\n        final PositionSwitch swap = new PositionSwitch(currentRoundNo, combatant, swappedWith);\n        assert swapList.get(combatant.getSide()) != null;\n        swapList.get(combatant.getSide()).add(swap);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#totalSwaps(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int totalSwaps(final CombatantSide side) {\n        return swaps.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#switchedPosList(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public Set<PositionSwitch> switchedPosList(final CombatantSide side) {\n        final Set<PositionSwitch> allSwaps;\n        if (side == null) {\n            allSwaps = new HashSet<PositionSwitch>();\n            for (final Set<PositionSwitch> sideSwitches : swapList.values()) {\n                allSwaps.addAll(sideSwitches);\n            }\n        } else {\n            allSwaps = swapList.get(side);\n        }\n        return allSwaps;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#criticalShot(de.outstare.fortbattleplayer.model.Combatant,\n     *      Combatant, int)\n     */\n    public void criticalShot(final Combatant combatant, final Combatant victim, final int damage) {\n        final CriticalHit crit = new CriticalHit(combatant, victim, damage, currentRoundNo);\n        critHits.get(combatant.getSide()).add(crit);\n        crits.incrementSide(combatant);\n        final Area field = victim._getLocation();\n        getFieldStat(field).addCrit();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#critList(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public List<CriticalHit> critList(final CombatantSide side) {\n        final List<CriticalHit> allCrits;\n        if (side == null) {\n            allCrits = new ArrayList<CriticalHit>();\n            for (final List<CriticalHit> sideCrits : critHits.values()) {\n                allCrits.addAll(sideCrits);\n            }\n        } else {\n            allCrits = critHits.get(side);\n        }\n        return allCrits;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#criticalHits(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int criticalHits(final CombatantSide side) {\n        return crits.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#criticalHitDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public long criticalHitDamage(final CombatantSide side) {\n        long sum = 0;\n        for (final CriticalHit crit : critList(side)) {\n            sum += crit.critOnlyDamage;\n        }\n        return sum;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#turnOrder(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public List<Combatant> turnOrder(final CombatantSide side) {\n        final List<Combatant> sidePlayers = new ArrayList<Combatant>(turnOrder.size() / 2);\n        for (final Combatant player : turnOrder) {\n            if (side == null || player.getSide() == side) {\n                sidePlayers.add(player);\n            }\n        }\n        return sidePlayers;\n    }\n\n    /**\n     * @return the number of shots per round\n     */\n    public Map<CombatantSide, ? extends LabeledData> getShotsPerRound() {\n        return shotsPerRound;\n    }\n\n    /**\n     * @return the number of hits per round\n     */\n    public Map<CombatantSide, ? extends LabeledData> getHitsPerRound() {\n        return hitsPerRound;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#getNotShootersPerRound()\n     */\n    public Map<CombatantSide, ? extends LabeledData> getNotShootersPerRound() {\n        final Map<CombatantSide, RoundStatistics> nonShootersPerRound = new HashMap<CombatantSide, RoundStatistics>();\n        for (final CombatantSide side : CombatantSide.values()) {\n            final RoundStatistics nonShooters = new RoundStatistics(\"Not shooting\", \"players\");\n            nonShootersPerRound.put(side, nonShooters);\n            final LabeledData shotRoundCounts = shotsPerRound.get(side);\n            if (shotRoundCounts != null) {\n                final double[] shotCounts = shotRoundCounts.toArray();\n                if (actorsPerRound.size() == shotCounts.length) {\n                    for (int i = 0; i < shotCounts.length; i++) {\n                        final int actors = actorsPerRound.get(i).getSideValue(side);\n                        final double numberNotShooting = actors - shotCounts[i];\n                        nonShooters.addValue(numberNotShooting);\n                    }\n                } else {\n                    LOG.warning(\"round statistics for players and shots differ!\");\n                }\n            } else {\n                LOG.warning(\"no data for players and shots for side \" + side);\n            }\n        }\n        return nonShootersPerRound;\n    }\n\n    private AreaStatistic getFieldStat(final Area area) {\n        if (!fieldStats.containsKey(area)) {\n            fieldStats.put(area, new AreaStatistic(area));\n        }\n        return fieldStats.get(area);\n    }\n\n    /**\n     * @return statistics for every field\n     */\n    public Map<Area, AreaStatistic> getFieldStatistics() {\n        return fieldStats;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/BattleStatistics_2Test.java",
		"test_prompt": "// BattleStatistics_2Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BattleStatistics}.\n* It contains ten unit test cases for the {@link BattleStatistics#amountOfDefenseBonus(CombatantSide)} method.\n*/\nclass BattleStatistics_2Test {"
	},
	{
		"original_code": "// BattleStatistics.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\n\n/**\n * @author daniel\n */\npublic class BattleStatistics implements DynamicStatistics, CombatantObserver {\n\n    private static final transient Logger LOG = Logger.getLogger(BattleStatistics.class.getName());\n\n    private final Map<Combatant, OnlineCounter> onliners = new HashMap<Combatant, OnlineCounter>();\n\n    private final Map<CombatantSide, List<CriticalHit>> critHits = new HashMap<CombatantSide, List<CriticalHit>>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            critHits.put(side, new ArrayList<CriticalHit>());\n        }\n    }\n\n    private final Map<CombatantSide, Set<PositionSwitch>> swapList = new HashMap<CombatantSide, Set<PositionSwitch>>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            swapList.put(side, new HashSet<PositionSwitch>());\n        }\n    }\n\n    private final AllCombatantSidesCounter crits = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter moves = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter swaps = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter attackBonuses = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter defenseBonuses = new AllCombatantSidesCounter();\n\n    private final Map<Combatant, Counter> shots = new HashMap<Combatant, Counter>();\n\n    private final Map<CombatantSide, RoundStatistics> shotsPerRound = new HashMap<CombatantSide, RoundStatistics>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            shotsPerRound.put(side, new RoundStatistics(\"shots\", \"shots\"));\n        }\n    }\n\n    private final Map<CombatantSide, RoundStatistics> hitsPerRound = new HashMap<CombatantSide, RoundStatistics>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            hitsPerRound.put(side, new RoundStatistics(\"hits\", \"hits\"));\n        }\n    }\n\n    private final Map<CombatantSide, AtomicInteger> shotRoundCounter = new HashMap<CombatantSide, AtomicInteger>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            shotRoundCounter.put(side, new AtomicInteger());\n        }\n    }\n\n    private final Map<CombatantSide, AtomicInteger> hitRoundCounter = new HashMap<CombatantSide, AtomicInteger>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            hitRoundCounter.put(side, new AtomicInteger());\n        }\n    }\n\n    private final Map<Combatant, Counter> victims = new HashMap<Combatant, Counter>();\n\n    private final List<Combatant> turnOrder = new LinkedList<Combatant>();\n\n    private final List<AllCombatantSidesCounter> actorsPerRound = new ArrayList<AllCombatantSidesCounter>(50);\n\n    private final Map<Area, AreaStatistic> fieldStats = new HashMap<Area, AreaStatistic>();\n\n    private final int _numberOfDefenders;\n\n    private final int _numberOfAttacker;\n\n    private int currentRoundNo = 0;\n\n    private Boolean firstRound = null;\n\n    private AllCombatantSidesCounter actorsThisRound = new AllCombatantSidesCounter();\n\n    /**\n     * set the current round. all following method calls will belong to this\n     * round till this method is called again with another parameter.\n     *\n     * @param no\n     */\n    public void setRound(final int no) {\n        if (firstRound == null) {\n            firstRound = Boolean.TRUE;\n        } else if (firstRound.booleanValue()) {\n            firstRound = Boolean.FALSE;\n            // the turn order is determined only in the first round\n            for (final Combatant player : onliners.keySet()) {\n                if (!turnOrder.contains(player)) {\n                    LOG.info(\"could not determine turn order for \" + player);\n                }\n            }\n        }\n        addAndResetRoundCounter(shotRoundCounter, shotsPerRound);\n        addAndResetRoundCounter(hitRoundCounter, hitsPerRound);\n        actorsPerRound.add(actorsThisRound);\n        actorsThisRound = new AllCombatantSidesCounter();\n        currentRoundNo = no;\n    }\n\n    /**\n     * this adds the counters for the last round to the total counts per round\n     * and resets the given counter\n     *\n     * @param roundCounter\n     * @param allRounds\n     */\n    void addAndResetRoundCounter(final Map<CombatantSide, AtomicInteger> roundCounter, final Map<CombatantSide, RoundStatistics> allRounds) {\n        for (final Entry<CombatantSide, AtomicInteger> mapping : roundCounter.entrySet()) {\n            final CombatantSide side = mapping.getKey();\n            final AtomicInteger roundShots = mapping.getValue();\n            allRounds.get(side).addValue(roundShots.get());\n            // reset for next round\n            roundShots.set(0);\n        }\n    }\n\n    /**\n     * @param combatant\n     * @return\n     */\n    int combatantLifetime(final Combatant combatant) {\n        final OnlineCounter onAndOffline = onliners.get(combatant);\n        if (onAndOffline == null) {\n            return 0;\n        }\n        return onAndOffline.sumOfEvents();\n    }\n\n    /**\n     * @param numberOfAttacker\n     * @param numberOfDefenders\n     */\n    public BattleStatistics(final int numberOfAttacker, final int numberOfDefenders) {\n        _numberOfAttacker = numberOfAttacker;\n        _numberOfDefenders = numberOfDefenders;\n    }\n\n    /**\n     * @param number\n     * @return\n     */\n    int round(final double number) {\n        return (int) Math.round(number);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#percentAbleToShoot(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int percentAbleToShoot(final CombatantSide side) {\n        double sum = 0;\n        int players = 0;\n        for (final Entry<Combatant, Counter> playerShots : shots.entrySet()) {\n            final Combatant combatant = playerShots.getKey();\n            if (isOnSide(side, combatant)) {\n                final int lifetime = combatantLifetime(combatant);\n                final int roundsShooting = playerShots.getValue().getValue();\n                sum += roundsShooting * 100.0 / lifetime;\n                players++;\n            }\n        }\n        if (players == 0) {\n            return 0;\n        }\n        return round(sum / players);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#amountOfAttackBonus(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int amountOfAttackBonus(final CombatantSide side) {\n        return attackBonuses.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#amountOfDefenseBonus(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int amountOfDefenseBonus(final CombatantSide side) {\n        return defenseBonuses.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfMovesPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double numberOfMovesPerPlayer(final CombatantSide side) {\n        double result = 0;\n        switch(side) {\n            case ATTACKER:\n                result = moves.getSideValue(side) / (double) _numberOfAttacker;\n                break;\n            case DEFENDER:\n                result = moves.getSideValue(side) / (double) _numberOfDefenders;\n                break;\n            default:\n                result = moves.getSideValue(null) / (double) (_numberOfAttacker + _numberOfDefenders);\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfOffliners(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfOffliners(final CombatantSide side) {\n        int offliner = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (counter.wasOffline()) {\n                    offliner++;\n                }\n            }\n        }\n        return offliner;\n    }\n\n    /**\n     * @param side\n     * @param combatant\n     * @return\n     */\n    private boolean isOnSide(final CombatantSide side, final Combatant combatant) {\n        return side == null || side.equals(combatant.getSide());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#roundsTillOnline(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double roundsTillOnline(final CombatantSide side) {\n        int combatants = 0;\n        int rounds = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (!counter.wasOffline()) {\n                    combatants++;\n                    rounds += counter.firstOnline();\n                }\n            }\n        }\n        // avoid division by zero\n        if (combatants == 0) {\n            return 0;\n        }\n        return ((double) rounds / (double) combatants);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#averageRoundsOnline(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageRoundsOnline(final CombatantSide side) {\n        double combatants = 0;\n        double rounds = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (!counter.wasOffline()) {\n                    combatants++;\n                    rounds += counter.onlineEvents();\n                }\n            }\n        }\n        // avoid division by zero\n        if (combatants == 0.0) {\n            return 0.0;\n        }\n        return rounds / combatants;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#hasMoved(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Area)\n     */\n    public void hasMoved(final Combatant combatant, final Area newPos) {\n        moves.incrementSide(combatant);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#newDestination(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Area)\n     */\n    public void newDestination(final Combatant combatant, final Area destination) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#aimsAt(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void aimsAt(final Combatant combatant, final Combatant target) {\n        incrementCombatantCounter(shots, combatant);\n        incrementCombatantCounter(victims, target);\n        shotRoundCounter.get(combatant.getSide()).incrementAndGet();\n        final Area field = target._getLocation();\n        getFieldStat(field).addShot();\n    }\n\n    private void incrementCombatantCounter(final Map<Combatant, Counter> combatantCounters, final Combatant combatant) {\n        if (!combatantCounters.containsKey(combatant)) {\n            combatantCounters.put(combatant, new Counter());\n        }\n        combatantCounters.get(combatant).increment();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isHit(de.outstare.fortbattleplayer.model.Combatant,\n     *      int, int)\n     */\n    public void isHit(final Combatant combatant, final int damage, final int oldHealthAmount) {\n        hitRoundCounter.get(combatant.getSide()).incrementAndGet();\n        final Area field = combatant._getLocation();\n        getFieldStat(field).addHit();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isDead(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void isDead(final Combatant combatant) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isAlive(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void isAlive(final Combatant combatant) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isOnline(de.outstare.fortbattleplayer.model.Combatant,\n     *      boolean)\n     */\n    public void isOnline(final Combatant combatant, final boolean changed) {\n        // count all events\n        if (!onliners.containsKey(combatant)) {\n            onliners.put(combatant, new OnlineCounter());\n        }\n        if (combatant.isOnline()) {\n            onliners.get(combatant).addOnline();\n        } else {\n            onliners.get(combatant).addOffline();\n        }\n        // the online event is triggered every round for a player (hopefully)\n        combatantTurn(combatant);\n    }\n\n    /**\n     * no special action, just to track the state every round\n     *\n     * @param combatant\n     */\n    private void combatantTurn(final Combatant combatant) {\n        final SectorBonus bonus = combatant.getSectorBonus();\n        attackBonuses.incrementBy(bonus.attackBonus, combatant);\n        defenseBonuses.incrementBy(bonus.defendBonus, combatant);\n        if (firstRound != null && firstRound.booleanValue()) {\n            turnOrder.add(combatant);\n        }\n        if (LOG.isLoggable(Level.FINE)) {\n            if ((firstRound == null || !firstRound.booleanValue()) && !turnOrder.contains(combatant) && currentRoundNo > 1) {\n                LOG.fine(\"---- not in order: \" + combatant);\n            }\n        }\n        actorsThisRound.incrementSide(combatant);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#targetNoOne(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public String targetNoOne(final CombatantSide side) {\n        String result = \"\";\n        int max = 0;\n        for (final Entry<Combatant, Counter> victim : victims.entrySet()) {\n            final Combatant combatant = victim.getKey();\n            if (isOnSide(side, combatant)) {\n                final int receivedShots = victim.getValue().getValue();\n                if (receivedShots > max) {\n                    max = receivedShots;\n                    result = combatant.getName() + \"(\" + receivedShots + \")\";\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfBayonets(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfBayonets(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.BayonetCounter());\n    }\n\n    /**\n     * @param side\n     * @param counter\n     * @return\n     */\n    int countWeaponMods(final CombatantSide side, final WeaponModCounter counter) {\n        // because every player should have an online/offline event, we look at\n        // the online data hoping to get all players\n        final Set<Combatant> players = onliners.keySet();\n        int bayonets = 0;\n        for (final Combatant combatant : players) {\n            if (isOnSide(side, combatant)) {\n                final Weapon playerWeapon = combatant.getWeapon();\n                // TODO let the counter count\n                if (counter.counts(playerWeapon)) {\n                    bayonets++;\n                }\n            }\n        }\n        return bayonets;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfGraphitLubricants(CombatantSide)\n     */\n    public int numberOfGraphitLubricants(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.GraphitLubricantCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfFettesOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfFettesOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.FettesOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfSchmierOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfSchmierOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.SchmierOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfShinyOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfShinyOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.ShinyOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfLoadingChamerOrEnhancedPatrons(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfLoadingChamerOrEnhancedPatrons(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.LoadingchamberOrEnhancedPatronsCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfHipFlasks(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfHipFlasks(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.HipFlaskCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#hasSwappedPosition()\n     */\n    public void hasSwappedPosition(final Combatant combatant, final Combatant swappedWith) {\n        swaps.incrementSide(combatant);\n        final PositionSwitch swap = new PositionSwitch(currentRoundNo, combatant, swappedWith);\n        assert swapList.get(combatant.getSide()) != null;\n        swapList.get(combatant.getSide()).add(swap);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#totalSwaps(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int totalSwaps(final CombatantSide side) {\n        return swaps.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#switchedPosList(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public Set<PositionSwitch> switchedPosList(final CombatantSide side) {\n        final Set<PositionSwitch> allSwaps;\n        if (side == null) {\n            allSwaps = new HashSet<PositionSwitch>();\n            for (final Set<PositionSwitch> sideSwitches : swapList.values()) {\n                allSwaps.addAll(sideSwitches);\n            }\n        } else {\n            allSwaps = swapList.get(side);\n        }\n        return allSwaps;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#criticalShot(de.outstare.fortbattleplayer.model.Combatant,\n     *      Combatant, int)\n     */\n    public void criticalShot(final Combatant combatant, final Combatant victim, final int damage) {\n        final CriticalHit crit = new CriticalHit(combatant, victim, damage, currentRoundNo);\n        critHits.get(combatant.getSide()).add(crit);\n        crits.incrementSide(combatant);\n        final Area field = victim._getLocation();\n        getFieldStat(field).addCrit();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#critList(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public List<CriticalHit> critList(final CombatantSide side) {\n        final List<CriticalHit> allCrits;\n        if (side == null) {\n            allCrits = new ArrayList<CriticalHit>();\n            for (final List<CriticalHit> sideCrits : critHits.values()) {\n                allCrits.addAll(sideCrits);\n            }\n        } else {\n            allCrits = critHits.get(side);\n        }\n        return allCrits;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#criticalHits(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int criticalHits(final CombatantSide side) {\n        return crits.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#criticalHitDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public long criticalHitDamage(final CombatantSide side) {\n        long sum = 0;\n        for (final CriticalHit crit : critList(side)) {\n            sum += crit.critOnlyDamage;\n        }\n        return sum;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#turnOrder(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public List<Combatant> turnOrder(final CombatantSide side) {\n        final List<Combatant> sidePlayers = new ArrayList<Combatant>(turnOrder.size() / 2);\n        for (final Combatant player : turnOrder) {\n            if (side == null || player.getSide() == side) {\n                sidePlayers.add(player);\n            }\n        }\n        return sidePlayers;\n    }\n\n    /**\n     * @return the number of shots per round\n     */\n    public Map<CombatantSide, ? extends LabeledData> getShotsPerRound() {\n        return shotsPerRound;\n    }\n\n    /**\n     * @return the number of hits per round\n     */\n    public Map<CombatantSide, ? extends LabeledData> getHitsPerRound() {\n        return hitsPerRound;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#getNotShootersPerRound()\n     */\n    public Map<CombatantSide, ? extends LabeledData> getNotShootersPerRound() {\n        final Map<CombatantSide, RoundStatistics> nonShootersPerRound = new HashMap<CombatantSide, RoundStatistics>();\n        for (final CombatantSide side : CombatantSide.values()) {\n            final RoundStatistics nonShooters = new RoundStatistics(\"Not shooting\", \"players\");\n            nonShootersPerRound.put(side, nonShooters);\n            final LabeledData shotRoundCounts = shotsPerRound.get(side);\n            if (shotRoundCounts != null) {\n                final double[] shotCounts = shotRoundCounts.toArray();\n                if (actorsPerRound.size() == shotCounts.length) {\n                    for (int i = 0; i < shotCounts.length; i++) {\n                        final int actors = actorsPerRound.get(i).getSideValue(side);\n                        final double numberNotShooting = actors - shotCounts[i];\n                        nonShooters.addValue(numberNotShooting);\n                    }\n                } else {\n                    LOG.warning(\"round statistics for players and shots differ!\");\n                }\n            } else {\n                LOG.warning(\"no data for players and shots for side \" + side);\n            }\n        }\n        return nonShootersPerRound;\n    }\n\n    private AreaStatistic getFieldStat(final Area area) {\n        if (!fieldStats.containsKey(area)) {\n            fieldStats.put(area, new AreaStatistic(area));\n        }\n        return fieldStats.get(area);\n    }\n\n    /**\n     * @return statistics for every field\n     */\n    public Map<Area, AreaStatistic> getFieldStatistics() {\n        return fieldStats;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/BattleStatistics_3Test.java",
		"test_prompt": "// BattleStatistics_3Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BattleStatistics}.\n* It contains ten unit test cases for the {@link BattleStatistics#numberOfMovesPerPlayer(CombatantSide)} method.\n*/\nclass BattleStatistics_3Test {"
	},
	{
		"original_code": "// BattleStatistics.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\n\n/**\n * @author daniel\n */\npublic class BattleStatistics implements DynamicStatistics, CombatantObserver {\n\n    private static final transient Logger LOG = Logger.getLogger(BattleStatistics.class.getName());\n\n    private final Map<Combatant, OnlineCounter> onliners = new HashMap<Combatant, OnlineCounter>();\n\n    private final Map<CombatantSide, List<CriticalHit>> critHits = new HashMap<CombatantSide, List<CriticalHit>>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            critHits.put(side, new ArrayList<CriticalHit>());\n        }\n    }\n\n    private final Map<CombatantSide, Set<PositionSwitch>> swapList = new HashMap<CombatantSide, Set<PositionSwitch>>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            swapList.put(side, new HashSet<PositionSwitch>());\n        }\n    }\n\n    private final AllCombatantSidesCounter crits = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter moves = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter swaps = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter attackBonuses = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter defenseBonuses = new AllCombatantSidesCounter();\n\n    private final Map<Combatant, Counter> shots = new HashMap<Combatant, Counter>();\n\n    private final Map<CombatantSide, RoundStatistics> shotsPerRound = new HashMap<CombatantSide, RoundStatistics>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            shotsPerRound.put(side, new RoundStatistics(\"shots\", \"shots\"));\n        }\n    }\n\n    private final Map<CombatantSide, RoundStatistics> hitsPerRound = new HashMap<CombatantSide, RoundStatistics>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            hitsPerRound.put(side, new RoundStatistics(\"hits\", \"hits\"));\n        }\n    }\n\n    private final Map<CombatantSide, AtomicInteger> shotRoundCounter = new HashMap<CombatantSide, AtomicInteger>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            shotRoundCounter.put(side, new AtomicInteger());\n        }\n    }\n\n    private final Map<CombatantSide, AtomicInteger> hitRoundCounter = new HashMap<CombatantSide, AtomicInteger>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            hitRoundCounter.put(side, new AtomicInteger());\n        }\n    }\n\n    private final Map<Combatant, Counter> victims = new HashMap<Combatant, Counter>();\n\n    private final List<Combatant> turnOrder = new LinkedList<Combatant>();\n\n    private final List<AllCombatantSidesCounter> actorsPerRound = new ArrayList<AllCombatantSidesCounter>(50);\n\n    private final Map<Area, AreaStatistic> fieldStats = new HashMap<Area, AreaStatistic>();\n\n    private final int _numberOfDefenders;\n\n    private final int _numberOfAttacker;\n\n    private int currentRoundNo = 0;\n\n    private Boolean firstRound = null;\n\n    private AllCombatantSidesCounter actorsThisRound = new AllCombatantSidesCounter();\n\n    /**\n     * set the current round. all following method calls will belong to this\n     * round till this method is called again with another parameter.\n     *\n     * @param no\n     */\n    public void setRound(final int no) {\n        if (firstRound == null) {\n            firstRound = Boolean.TRUE;\n        } else if (firstRound.booleanValue()) {\n            firstRound = Boolean.FALSE;\n            // the turn order is determined only in the first round\n            for (final Combatant player : onliners.keySet()) {\n                if (!turnOrder.contains(player)) {\n                    LOG.info(\"could not determine turn order for \" + player);\n                }\n            }\n        }\n        addAndResetRoundCounter(shotRoundCounter, shotsPerRound);\n        addAndResetRoundCounter(hitRoundCounter, hitsPerRound);\n        actorsPerRound.add(actorsThisRound);\n        actorsThisRound = new AllCombatantSidesCounter();\n        currentRoundNo = no;\n    }\n\n    /**\n     * this adds the counters for the last round to the total counts per round\n     * and resets the given counter\n     *\n     * @param roundCounter\n     * @param allRounds\n     */\n    void addAndResetRoundCounter(final Map<CombatantSide, AtomicInteger> roundCounter, final Map<CombatantSide, RoundStatistics> allRounds) {\n        for (final Entry<CombatantSide, AtomicInteger> mapping : roundCounter.entrySet()) {\n            final CombatantSide side = mapping.getKey();\n            final AtomicInteger roundShots = mapping.getValue();\n            allRounds.get(side).addValue(roundShots.get());\n            // reset for next round\n            roundShots.set(0);\n        }\n    }\n\n    /**\n     * @param combatant\n     * @return\n     */\n    int combatantLifetime(final Combatant combatant) {\n        final OnlineCounter onAndOffline = onliners.get(combatant);\n        if (onAndOffline == null) {\n            return 0;\n        }\n        return onAndOffline.sumOfEvents();\n    }\n\n    /**\n     * @param numberOfAttacker\n     * @param numberOfDefenders\n     */\n    public BattleStatistics(final int numberOfAttacker, final int numberOfDefenders) {\n        _numberOfAttacker = numberOfAttacker;\n        _numberOfDefenders = numberOfDefenders;\n    }\n\n    /**\n     * @param number\n     * @return\n     */\n    int round(final double number) {\n        return (int) Math.round(number);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#percentAbleToShoot(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int percentAbleToShoot(final CombatantSide side) {\n        double sum = 0;\n        int players = 0;\n        for (final Entry<Combatant, Counter> playerShots : shots.entrySet()) {\n            final Combatant combatant = playerShots.getKey();\n            if (isOnSide(side, combatant)) {\n                final int lifetime = combatantLifetime(combatant);\n                final int roundsShooting = playerShots.getValue().getValue();\n                sum += roundsShooting * 100.0 / lifetime;\n                players++;\n            }\n        }\n        if (players == 0) {\n            return 0;\n        }\n        return round(sum / players);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#amountOfAttackBonus(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int amountOfAttackBonus(final CombatantSide side) {\n        return attackBonuses.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#amountOfDefenseBonus(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int amountOfDefenseBonus(final CombatantSide side) {\n        return defenseBonuses.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfMovesPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double numberOfMovesPerPlayer(final CombatantSide side) {\n        double result = 0;\n        switch(side) {\n            case ATTACKER:\n                result = moves.getSideValue(side) / (double) _numberOfAttacker;\n                break;\n            case DEFENDER:\n                result = moves.getSideValue(side) / (double) _numberOfDefenders;\n                break;\n            default:\n                result = moves.getSideValue(null) / (double) (_numberOfAttacker + _numberOfDefenders);\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfOffliners(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfOffliners(final CombatantSide side) {\n        int offliner = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (counter.wasOffline()) {\n                    offliner++;\n                }\n            }\n        }\n        return offliner;\n    }\n\n    /**\n     * @param side\n     * @param combatant\n     * @return\n     */\n    private boolean isOnSide(final CombatantSide side, final Combatant combatant) {\n        return side == null || side.equals(combatant.getSide());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#roundsTillOnline(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double roundsTillOnline(final CombatantSide side) {\n        int combatants = 0;\n        int rounds = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (!counter.wasOffline()) {\n                    combatants++;\n                    rounds += counter.firstOnline();\n                }\n            }\n        }\n        // avoid division by zero\n        if (combatants == 0) {\n            return 0;\n        }\n        return ((double) rounds / (double) combatants);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#averageRoundsOnline(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageRoundsOnline(final CombatantSide side) {\n        double combatants = 0;\n        double rounds = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (!counter.wasOffline()) {\n                    combatants++;\n                    rounds += counter.onlineEvents();\n                }\n            }\n        }\n        // avoid division by zero\n        if (combatants == 0.0) {\n            return 0.0;\n        }\n        return rounds / combatants;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#hasMoved(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Area)\n     */\n    public void hasMoved(final Combatant combatant, final Area newPos) {\n        moves.incrementSide(combatant);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#newDestination(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Area)\n     */\n    public void newDestination(final Combatant combatant, final Area destination) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#aimsAt(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void aimsAt(final Combatant combatant, final Combatant target) {\n        incrementCombatantCounter(shots, combatant);\n        incrementCombatantCounter(victims, target);\n        shotRoundCounter.get(combatant.getSide()).incrementAndGet();\n        final Area field = target._getLocation();\n        getFieldStat(field).addShot();\n    }\n\n    private void incrementCombatantCounter(final Map<Combatant, Counter> combatantCounters, final Combatant combatant) {\n        if (!combatantCounters.containsKey(combatant)) {\n            combatantCounters.put(combatant, new Counter());\n        }\n        combatantCounters.get(combatant).increment();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isHit(de.outstare.fortbattleplayer.model.Combatant,\n     *      int, int)\n     */\n    public void isHit(final Combatant combatant, final int damage, final int oldHealthAmount) {\n        hitRoundCounter.get(combatant.getSide()).incrementAndGet();\n        final Area field = combatant._getLocation();\n        getFieldStat(field).addHit();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isDead(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void isDead(final Combatant combatant) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isAlive(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void isAlive(final Combatant combatant) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isOnline(de.outstare.fortbattleplayer.model.Combatant,\n     *      boolean)\n     */\n    public void isOnline(final Combatant combatant, final boolean changed) {\n        // count all events\n        if (!onliners.containsKey(combatant)) {\n            onliners.put(combatant, new OnlineCounter());\n        }\n        if (combatant.isOnline()) {\n            onliners.get(combatant).addOnline();\n        } else {\n            onliners.get(combatant).addOffline();\n        }\n        // the online event is triggered every round for a player (hopefully)\n        combatantTurn(combatant);\n    }\n\n    /**\n     * no special action, just to track the state every round\n     *\n     * @param combatant\n     */\n    private void combatantTurn(final Combatant combatant) {\n        final SectorBonus bonus = combatant.getSectorBonus();\n        attackBonuses.incrementBy(bonus.attackBonus, combatant);\n        defenseBonuses.incrementBy(bonus.defendBonus, combatant);\n        if (firstRound != null && firstRound.booleanValue()) {\n            turnOrder.add(combatant);\n        }\n        if (LOG.isLoggable(Level.FINE)) {\n            if ((firstRound == null || !firstRound.booleanValue()) && !turnOrder.contains(combatant) && currentRoundNo > 1) {\n                LOG.fine(\"---- not in order: \" + combatant);\n            }\n        }\n        actorsThisRound.incrementSide(combatant);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#targetNoOne(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public String targetNoOne(final CombatantSide side) {\n        String result = \"\";\n        int max = 0;\n        for (final Entry<Combatant, Counter> victim : victims.entrySet()) {\n            final Combatant combatant = victim.getKey();\n            if (isOnSide(side, combatant)) {\n                final int receivedShots = victim.getValue().getValue();\n                if (receivedShots > max) {\n                    max = receivedShots;\n                    result = combatant.getName() + \"(\" + receivedShots + \")\";\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfBayonets(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfBayonets(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.BayonetCounter());\n    }\n\n    /**\n     * @param side\n     * @param counter\n     * @return\n     */\n    int countWeaponMods(final CombatantSide side, final WeaponModCounter counter) {\n        // because every player should have an online/offline event, we look at\n        // the online data hoping to get all players\n        final Set<Combatant> players = onliners.keySet();\n        int bayonets = 0;\n        for (final Combatant combatant : players) {\n            if (isOnSide(side, combatant)) {\n                final Weapon playerWeapon = combatant.getWeapon();\n                // TODO let the counter count\n                if (counter.counts(playerWeapon)) {\n                    bayonets++;\n                }\n            }\n        }\n        return bayonets;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfGraphitLubricants(CombatantSide)\n     */\n    public int numberOfGraphitLubricants(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.GraphitLubricantCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfFettesOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfFettesOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.FettesOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfSchmierOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfSchmierOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.SchmierOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfShinyOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfShinyOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.ShinyOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfLoadingChamerOrEnhancedPatrons(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfLoadingChamerOrEnhancedPatrons(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.LoadingchamberOrEnhancedPatronsCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfHipFlasks(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfHipFlasks(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.HipFlaskCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#hasSwappedPosition()\n     */\n    public void hasSwappedPosition(final Combatant combatant, final Combatant swappedWith) {\n        swaps.incrementSide(combatant);\n        final PositionSwitch swap = new PositionSwitch(currentRoundNo, combatant, swappedWith);\n        assert swapList.get(combatant.getSide()) != null;\n        swapList.get(combatant.getSide()).add(swap);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#totalSwaps(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int totalSwaps(final CombatantSide side) {\n        return swaps.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#switchedPosList(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public Set<PositionSwitch> switchedPosList(final CombatantSide side) {\n        final Set<PositionSwitch> allSwaps;\n        if (side == null) {\n            allSwaps = new HashSet<PositionSwitch>();\n            for (final Set<PositionSwitch> sideSwitches : swapList.values()) {\n                allSwaps.addAll(sideSwitches);\n            }\n        } else {\n            allSwaps = swapList.get(side);\n        }\n        return allSwaps;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#criticalShot(de.outstare.fortbattleplayer.model.Combatant,\n     *      Combatant, int)\n     */\n    public void criticalShot(final Combatant combatant, final Combatant victim, final int damage) {\n        final CriticalHit crit = new CriticalHit(combatant, victim, damage, currentRoundNo);\n        critHits.get(combatant.getSide()).add(crit);\n        crits.incrementSide(combatant);\n        final Area field = victim._getLocation();\n        getFieldStat(field).addCrit();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#critList(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public List<CriticalHit> critList(final CombatantSide side) {\n        final List<CriticalHit> allCrits;\n        if (side == null) {\n            allCrits = new ArrayList<CriticalHit>();\n            for (final List<CriticalHit> sideCrits : critHits.values()) {\n                allCrits.addAll(sideCrits);\n            }\n        } else {\n            allCrits = critHits.get(side);\n        }\n        return allCrits;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#criticalHits(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int criticalHits(final CombatantSide side) {\n        return crits.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#criticalHitDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public long criticalHitDamage(final CombatantSide side) {\n        long sum = 0;\n        for (final CriticalHit crit : critList(side)) {\n            sum += crit.critOnlyDamage;\n        }\n        return sum;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#turnOrder(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public List<Combatant> turnOrder(final CombatantSide side) {\n        final List<Combatant> sidePlayers = new ArrayList<Combatant>(turnOrder.size() / 2);\n        for (final Combatant player : turnOrder) {\n            if (side == null || player.getSide() == side) {\n                sidePlayers.add(player);\n            }\n        }\n        return sidePlayers;\n    }\n\n    /**\n     * @return the number of shots per round\n     */\n    public Map<CombatantSide, ? extends LabeledData> getShotsPerRound() {\n        return shotsPerRound;\n    }\n\n    /**\n     * @return the number of hits per round\n     */\n    public Map<CombatantSide, ? extends LabeledData> getHitsPerRound() {\n        return hitsPerRound;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#getNotShootersPerRound()\n     */\n    public Map<CombatantSide, ? extends LabeledData> getNotShootersPerRound() {\n        final Map<CombatantSide, RoundStatistics> nonShootersPerRound = new HashMap<CombatantSide, RoundStatistics>();\n        for (final CombatantSide side : CombatantSide.values()) {\n            final RoundStatistics nonShooters = new RoundStatistics(\"Not shooting\", \"players\");\n            nonShootersPerRound.put(side, nonShooters);\n            final LabeledData shotRoundCounts = shotsPerRound.get(side);\n            if (shotRoundCounts != null) {\n                final double[] shotCounts = shotRoundCounts.toArray();\n                if (actorsPerRound.size() == shotCounts.length) {\n                    for (int i = 0; i < shotCounts.length; i++) {\n                        final int actors = actorsPerRound.get(i).getSideValue(side);\n                        final double numberNotShooting = actors - shotCounts[i];\n                        nonShooters.addValue(numberNotShooting);\n                    }\n                } else {\n                    LOG.warning(\"round statistics for players and shots differ!\");\n                }\n            } else {\n                LOG.warning(\"no data for players and shots for side \" + side);\n            }\n        }\n        return nonShootersPerRound;\n    }\n\n    private AreaStatistic getFieldStat(final Area area) {\n        if (!fieldStats.containsKey(area)) {\n            fieldStats.put(area, new AreaStatistic(area));\n        }\n        return fieldStats.get(area);\n    }\n\n    /**\n     * @return statistics for every field\n     */\n    public Map<Area, AreaStatistic> getFieldStatistics() {\n        return fieldStats;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/BattleStatistics_4Test.java",
		"test_prompt": "// BattleStatistics_4Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BattleStatistics}.\n* It contains ten unit test cases for the {@link BattleStatistics#numberOfOffliners(CombatantSide)} method.\n*/\nclass BattleStatistics_4Test {"
	},
	{
		"original_code": "// BattleStatistics.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\n\n/**\n * @author daniel\n */\npublic class BattleStatistics implements DynamicStatistics, CombatantObserver {\n\n    private static final transient Logger LOG = Logger.getLogger(BattleStatistics.class.getName());\n\n    private final Map<Combatant, OnlineCounter> onliners = new HashMap<Combatant, OnlineCounter>();\n\n    private final Map<CombatantSide, List<CriticalHit>> critHits = new HashMap<CombatantSide, List<CriticalHit>>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            critHits.put(side, new ArrayList<CriticalHit>());\n        }\n    }\n\n    private final Map<CombatantSide, Set<PositionSwitch>> swapList = new HashMap<CombatantSide, Set<PositionSwitch>>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            swapList.put(side, new HashSet<PositionSwitch>());\n        }\n    }\n\n    private final AllCombatantSidesCounter crits = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter moves = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter swaps = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter attackBonuses = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter defenseBonuses = new AllCombatantSidesCounter();\n\n    private final Map<Combatant, Counter> shots = new HashMap<Combatant, Counter>();\n\n    private final Map<CombatantSide, RoundStatistics> shotsPerRound = new HashMap<CombatantSide, RoundStatistics>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            shotsPerRound.put(side, new RoundStatistics(\"shots\", \"shots\"));\n        }\n    }\n\n    private final Map<CombatantSide, RoundStatistics> hitsPerRound = new HashMap<CombatantSide, RoundStatistics>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            hitsPerRound.put(side, new RoundStatistics(\"hits\", \"hits\"));\n        }\n    }\n\n    private final Map<CombatantSide, AtomicInteger> shotRoundCounter = new HashMap<CombatantSide, AtomicInteger>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            shotRoundCounter.put(side, new AtomicInteger());\n        }\n    }\n\n    private final Map<CombatantSide, AtomicInteger> hitRoundCounter = new HashMap<CombatantSide, AtomicInteger>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            hitRoundCounter.put(side, new AtomicInteger());\n        }\n    }\n\n    private final Map<Combatant, Counter> victims = new HashMap<Combatant, Counter>();\n\n    private final List<Combatant> turnOrder = new LinkedList<Combatant>();\n\n    private final List<AllCombatantSidesCounter> actorsPerRound = new ArrayList<AllCombatantSidesCounter>(50);\n\n    private final Map<Area, AreaStatistic> fieldStats = new HashMap<Area, AreaStatistic>();\n\n    private final int _numberOfDefenders;\n\n    private final int _numberOfAttacker;\n\n    private int currentRoundNo = 0;\n\n    private Boolean firstRound = null;\n\n    private AllCombatantSidesCounter actorsThisRound = new AllCombatantSidesCounter();\n\n    /**\n     * set the current round. all following method calls will belong to this\n     * round till this method is called again with another parameter.\n     *\n     * @param no\n     */\n    public void setRound(final int no) {\n        if (firstRound == null) {\n            firstRound = Boolean.TRUE;\n        } else if (firstRound.booleanValue()) {\n            firstRound = Boolean.FALSE;\n            // the turn order is determined only in the first round\n            for (final Combatant player : onliners.keySet()) {\n                if (!turnOrder.contains(player)) {\n                    LOG.info(\"could not determine turn order for \" + player);\n                }\n            }\n        }\n        addAndResetRoundCounter(shotRoundCounter, shotsPerRound);\n        addAndResetRoundCounter(hitRoundCounter, hitsPerRound);\n        actorsPerRound.add(actorsThisRound);\n        actorsThisRound = new AllCombatantSidesCounter();\n        currentRoundNo = no;\n    }\n\n    /**\n     * this adds the counters for the last round to the total counts per round\n     * and resets the given counter\n     *\n     * @param roundCounter\n     * @param allRounds\n     */\n    void addAndResetRoundCounter(final Map<CombatantSide, AtomicInteger> roundCounter, final Map<CombatantSide, RoundStatistics> allRounds) {\n        for (final Entry<CombatantSide, AtomicInteger> mapping : roundCounter.entrySet()) {\n            final CombatantSide side = mapping.getKey();\n            final AtomicInteger roundShots = mapping.getValue();\n            allRounds.get(side).addValue(roundShots.get());\n            // reset for next round\n            roundShots.set(0);\n        }\n    }\n\n    /**\n     * @param combatant\n     * @return\n     */\n    int combatantLifetime(final Combatant combatant) {\n        final OnlineCounter onAndOffline = onliners.get(combatant);\n        if (onAndOffline == null) {\n            return 0;\n        }\n        return onAndOffline.sumOfEvents();\n    }\n\n    /**\n     * @param numberOfAttacker\n     * @param numberOfDefenders\n     */\n    public BattleStatistics(final int numberOfAttacker, final int numberOfDefenders) {\n        _numberOfAttacker = numberOfAttacker;\n        _numberOfDefenders = numberOfDefenders;\n    }\n\n    /**\n     * @param number\n     * @return\n     */\n    int round(final double number) {\n        return (int) Math.round(number);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#percentAbleToShoot(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int percentAbleToShoot(final CombatantSide side) {\n        double sum = 0;\n        int players = 0;\n        for (final Entry<Combatant, Counter> playerShots : shots.entrySet()) {\n            final Combatant combatant = playerShots.getKey();\n            if (isOnSide(side, combatant)) {\n                final int lifetime = combatantLifetime(combatant);\n                final int roundsShooting = playerShots.getValue().getValue();\n                sum += roundsShooting * 100.0 / lifetime;\n                players++;\n            }\n        }\n        if (players == 0) {\n            return 0;\n        }\n        return round(sum / players);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#amountOfAttackBonus(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int amountOfAttackBonus(final CombatantSide side) {\n        return attackBonuses.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#amountOfDefenseBonus(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int amountOfDefenseBonus(final CombatantSide side) {\n        return defenseBonuses.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfMovesPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double numberOfMovesPerPlayer(final CombatantSide side) {\n        double result = 0;\n        switch(side) {\n            case ATTACKER:\n                result = moves.getSideValue(side) / (double) _numberOfAttacker;\n                break;\n            case DEFENDER:\n                result = moves.getSideValue(side) / (double) _numberOfDefenders;\n                break;\n            default:\n                result = moves.getSideValue(null) / (double) (_numberOfAttacker + _numberOfDefenders);\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfOffliners(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfOffliners(final CombatantSide side) {\n        int offliner = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (counter.wasOffline()) {\n                    offliner++;\n                }\n            }\n        }\n        return offliner;\n    }\n\n    /**\n     * @param side\n     * @param combatant\n     * @return\n     */\n    private boolean isOnSide(final CombatantSide side, final Combatant combatant) {\n        return side == null || side.equals(combatant.getSide());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#roundsTillOnline(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double roundsTillOnline(final CombatantSide side) {\n        int combatants = 0;\n        int rounds = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (!counter.wasOffline()) {\n                    combatants++;\n                    rounds += counter.firstOnline();\n                }\n            }\n        }\n        // avoid division by zero\n        if (combatants == 0) {\n            return 0;\n        }\n        return ((double) rounds / (double) combatants);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#averageRoundsOnline(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageRoundsOnline(final CombatantSide side) {\n        double combatants = 0;\n        double rounds = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (!counter.wasOffline()) {\n                    combatants++;\n                    rounds += counter.onlineEvents();\n                }\n            }\n        }\n        // avoid division by zero\n        if (combatants == 0.0) {\n            return 0.0;\n        }\n        return rounds / combatants;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#hasMoved(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Area)\n     */\n    public void hasMoved(final Combatant combatant, final Area newPos) {\n        moves.incrementSide(combatant);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#newDestination(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Area)\n     */\n    public void newDestination(final Combatant combatant, final Area destination) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#aimsAt(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void aimsAt(final Combatant combatant, final Combatant target) {\n        incrementCombatantCounter(shots, combatant);\n        incrementCombatantCounter(victims, target);\n        shotRoundCounter.get(combatant.getSide()).incrementAndGet();\n        final Area field = target._getLocation();\n        getFieldStat(field).addShot();\n    }\n\n    private void incrementCombatantCounter(final Map<Combatant, Counter> combatantCounters, final Combatant combatant) {\n        if (!combatantCounters.containsKey(combatant)) {\n            combatantCounters.put(combatant, new Counter());\n        }\n        combatantCounters.get(combatant).increment();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isHit(de.outstare.fortbattleplayer.model.Combatant,\n     *      int, int)\n     */\n    public void isHit(final Combatant combatant, final int damage, final int oldHealthAmount) {\n        hitRoundCounter.get(combatant.getSide()).incrementAndGet();\n        final Area field = combatant._getLocation();\n        getFieldStat(field).addHit();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isDead(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void isDead(final Combatant combatant) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isAlive(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void isAlive(final Combatant combatant) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isOnline(de.outstare.fortbattleplayer.model.Combatant,\n     *      boolean)\n     */\n    public void isOnline(final Combatant combatant, final boolean changed) {\n        // count all events\n        if (!onliners.containsKey(combatant)) {\n            onliners.put(combatant, new OnlineCounter());\n        }\n        if (combatant.isOnline()) {\n            onliners.get(combatant).addOnline();\n        } else {\n            onliners.get(combatant).addOffline();\n        }\n        // the online event is triggered every round for a player (hopefully)\n        combatantTurn(combatant);\n    }\n\n    /**\n     * no special action, just to track the state every round\n     *\n     * @param combatant\n     */\n    private void combatantTurn(final Combatant combatant) {\n        final SectorBonus bonus = combatant.getSectorBonus();\n        attackBonuses.incrementBy(bonus.attackBonus, combatant);\n        defenseBonuses.incrementBy(bonus.defendBonus, combatant);\n        if (firstRound != null && firstRound.booleanValue()) {\n            turnOrder.add(combatant);\n        }\n        if (LOG.isLoggable(Level.FINE)) {\n            if ((firstRound == null || !firstRound.booleanValue()) && !turnOrder.contains(combatant) && currentRoundNo > 1) {\n                LOG.fine(\"---- not in order: \" + combatant);\n            }\n        }\n        actorsThisRound.incrementSide(combatant);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#targetNoOne(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public String targetNoOne(final CombatantSide side) {\n        String result = \"\";\n        int max = 0;\n        for (final Entry<Combatant, Counter> victim : victims.entrySet()) {\n            final Combatant combatant = victim.getKey();\n            if (isOnSide(side, combatant)) {\n                final int receivedShots = victim.getValue().getValue();\n                if (receivedShots > max) {\n                    max = receivedShots;\n                    result = combatant.getName() + \"(\" + receivedShots + \")\";\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfBayonets(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfBayonets(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.BayonetCounter());\n    }\n\n    /**\n     * @param side\n     * @param counter\n     * @return\n     */\n    int countWeaponMods(final CombatantSide side, final WeaponModCounter counter) {\n        // because every player should have an online/offline event, we look at\n        // the online data hoping to get all players\n        final Set<Combatant> players = onliners.keySet();\n        int bayonets = 0;\n        for (final Combatant combatant : players) {\n            if (isOnSide(side, combatant)) {\n                final Weapon playerWeapon = combatant.getWeapon();\n                // TODO let the counter count\n                if (counter.counts(playerWeapon)) {\n                    bayonets++;\n                }\n            }\n        }\n        return bayonets;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfGraphitLubricants(CombatantSide)\n     */\n    public int numberOfGraphitLubricants(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.GraphitLubricantCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfFettesOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfFettesOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.FettesOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfSchmierOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfSchmierOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.SchmierOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfShinyOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfShinyOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.ShinyOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfLoadingChamerOrEnhancedPatrons(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfLoadingChamerOrEnhancedPatrons(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.LoadingchamberOrEnhancedPatronsCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfHipFlasks(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfHipFlasks(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.HipFlaskCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#hasSwappedPosition()\n     */\n    public void hasSwappedPosition(final Combatant combatant, final Combatant swappedWith) {\n        swaps.incrementSide(combatant);\n        final PositionSwitch swap = new PositionSwitch(currentRoundNo, combatant, swappedWith);\n        assert swapList.get(combatant.getSide()) != null;\n        swapList.get(combatant.getSide()).add(swap);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#totalSwaps(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int totalSwaps(final CombatantSide side) {\n        return swaps.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#switchedPosList(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public Set<PositionSwitch> switchedPosList(final CombatantSide side) {\n        final Set<PositionSwitch> allSwaps;\n        if (side == null) {\n            allSwaps = new HashSet<PositionSwitch>();\n            for (final Set<PositionSwitch> sideSwitches : swapList.values()) {\n                allSwaps.addAll(sideSwitches);\n            }\n        } else {\n            allSwaps = swapList.get(side);\n        }\n        return allSwaps;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#criticalShot(de.outstare.fortbattleplayer.model.Combatant,\n     *      Combatant, int)\n     */\n    public void criticalShot(final Combatant combatant, final Combatant victim, final int damage) {\n        final CriticalHit crit = new CriticalHit(combatant, victim, damage, currentRoundNo);\n        critHits.get(combatant.getSide()).add(crit);\n        crits.incrementSide(combatant);\n        final Area field = victim._getLocation();\n        getFieldStat(field).addCrit();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#critList(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public List<CriticalHit> critList(final CombatantSide side) {\n        final List<CriticalHit> allCrits;\n        if (side == null) {\n            allCrits = new ArrayList<CriticalHit>();\n            for (final List<CriticalHit> sideCrits : critHits.values()) {\n                allCrits.addAll(sideCrits);\n            }\n        } else {\n            allCrits = critHits.get(side);\n        }\n        return allCrits;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#criticalHits(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int criticalHits(final CombatantSide side) {\n        return crits.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#criticalHitDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public long criticalHitDamage(final CombatantSide side) {\n        long sum = 0;\n        for (final CriticalHit crit : critList(side)) {\n            sum += crit.critOnlyDamage;\n        }\n        return sum;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#turnOrder(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public List<Combatant> turnOrder(final CombatantSide side) {\n        final List<Combatant> sidePlayers = new ArrayList<Combatant>(turnOrder.size() / 2);\n        for (final Combatant player : turnOrder) {\n            if (side == null || player.getSide() == side) {\n                sidePlayers.add(player);\n            }\n        }\n        return sidePlayers;\n    }\n\n    /**\n     * @return the number of shots per round\n     */\n    public Map<CombatantSide, ? extends LabeledData> getShotsPerRound() {\n        return shotsPerRound;\n    }\n\n    /**\n     * @return the number of hits per round\n     */\n    public Map<CombatantSide, ? extends LabeledData> getHitsPerRound() {\n        return hitsPerRound;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#getNotShootersPerRound()\n     */\n    public Map<CombatantSide, ? extends LabeledData> getNotShootersPerRound() {\n        final Map<CombatantSide, RoundStatistics> nonShootersPerRound = new HashMap<CombatantSide, RoundStatistics>();\n        for (final CombatantSide side : CombatantSide.values()) {\n            final RoundStatistics nonShooters = new RoundStatistics(\"Not shooting\", \"players\");\n            nonShootersPerRound.put(side, nonShooters);\n            final LabeledData shotRoundCounts = shotsPerRound.get(side);\n            if (shotRoundCounts != null) {\n                final double[] shotCounts = shotRoundCounts.toArray();\n                if (actorsPerRound.size() == shotCounts.length) {\n                    for (int i = 0; i < shotCounts.length; i++) {\n                        final int actors = actorsPerRound.get(i).getSideValue(side);\n                        final double numberNotShooting = actors - shotCounts[i];\n                        nonShooters.addValue(numberNotShooting);\n                    }\n                } else {\n                    LOG.warning(\"round statistics for players and shots differ!\");\n                }\n            } else {\n                LOG.warning(\"no data for players and shots for side \" + side);\n            }\n        }\n        return nonShootersPerRound;\n    }\n\n    private AreaStatistic getFieldStat(final Area area) {\n        if (!fieldStats.containsKey(area)) {\n            fieldStats.put(area, new AreaStatistic(area));\n        }\n        return fieldStats.get(area);\n    }\n\n    /**\n     * @return statistics for every field\n     */\n    public Map<Area, AreaStatistic> getFieldStatistics() {\n        return fieldStats;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/BattleStatistics_5Test.java",
		"test_prompt": "// BattleStatistics_5Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BattleStatistics}.\n* It contains ten unit test cases for the {@link BattleStatistics#roundsTillOnline(CombatantSide)} method.\n*/\nclass BattleStatistics_5Test {"
	},
	{
		"original_code": "// BattleStatistics.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\n\n/**\n * @author daniel\n */\npublic class BattleStatistics implements DynamicStatistics, CombatantObserver {\n\n    private static final transient Logger LOG = Logger.getLogger(BattleStatistics.class.getName());\n\n    private final Map<Combatant, OnlineCounter> onliners = new HashMap<Combatant, OnlineCounter>();\n\n    private final Map<CombatantSide, List<CriticalHit>> critHits = new HashMap<CombatantSide, List<CriticalHit>>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            critHits.put(side, new ArrayList<CriticalHit>());\n        }\n    }\n\n    private final Map<CombatantSide, Set<PositionSwitch>> swapList = new HashMap<CombatantSide, Set<PositionSwitch>>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            swapList.put(side, new HashSet<PositionSwitch>());\n        }\n    }\n\n    private final AllCombatantSidesCounter crits = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter moves = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter swaps = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter attackBonuses = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter defenseBonuses = new AllCombatantSidesCounter();\n\n    private final Map<Combatant, Counter> shots = new HashMap<Combatant, Counter>();\n\n    private final Map<CombatantSide, RoundStatistics> shotsPerRound = new HashMap<CombatantSide, RoundStatistics>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            shotsPerRound.put(side, new RoundStatistics(\"shots\", \"shots\"));\n        }\n    }\n\n    private final Map<CombatantSide, RoundStatistics> hitsPerRound = new HashMap<CombatantSide, RoundStatistics>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            hitsPerRound.put(side, new RoundStatistics(\"hits\", \"hits\"));\n        }\n    }\n\n    private final Map<CombatantSide, AtomicInteger> shotRoundCounter = new HashMap<CombatantSide, AtomicInteger>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            shotRoundCounter.put(side, new AtomicInteger());\n        }\n    }\n\n    private final Map<CombatantSide, AtomicInteger> hitRoundCounter = new HashMap<CombatantSide, AtomicInteger>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            hitRoundCounter.put(side, new AtomicInteger());\n        }\n    }\n\n    private final Map<Combatant, Counter> victims = new HashMap<Combatant, Counter>();\n\n    private final List<Combatant> turnOrder = new LinkedList<Combatant>();\n\n    private final List<AllCombatantSidesCounter> actorsPerRound = new ArrayList<AllCombatantSidesCounter>(50);\n\n    private final Map<Area, AreaStatistic> fieldStats = new HashMap<Area, AreaStatistic>();\n\n    private final int _numberOfDefenders;\n\n    private final int _numberOfAttacker;\n\n    private int currentRoundNo = 0;\n\n    private Boolean firstRound = null;\n\n    private AllCombatantSidesCounter actorsThisRound = new AllCombatantSidesCounter();\n\n    /**\n     * set the current round. all following method calls will belong to this\n     * round till this method is called again with another parameter.\n     *\n     * @param no\n     */\n    public void setRound(final int no) {\n        if (firstRound == null) {\n            firstRound = Boolean.TRUE;\n        } else if (firstRound.booleanValue()) {\n            firstRound = Boolean.FALSE;\n            // the turn order is determined only in the first round\n            for (final Combatant player : onliners.keySet()) {\n                if (!turnOrder.contains(player)) {\n                    LOG.info(\"could not determine turn order for \" + player);\n                }\n            }\n        }\n        addAndResetRoundCounter(shotRoundCounter, shotsPerRound);\n        addAndResetRoundCounter(hitRoundCounter, hitsPerRound);\n        actorsPerRound.add(actorsThisRound);\n        actorsThisRound = new AllCombatantSidesCounter();\n        currentRoundNo = no;\n    }\n\n    /**\n     * this adds the counters for the last round to the total counts per round\n     * and resets the given counter\n     *\n     * @param roundCounter\n     * @param allRounds\n     */\n    void addAndResetRoundCounter(final Map<CombatantSide, AtomicInteger> roundCounter, final Map<CombatantSide, RoundStatistics> allRounds) {\n        for (final Entry<CombatantSide, AtomicInteger> mapping : roundCounter.entrySet()) {\n            final CombatantSide side = mapping.getKey();\n            final AtomicInteger roundShots = mapping.getValue();\n            allRounds.get(side).addValue(roundShots.get());\n            // reset for next round\n            roundShots.set(0);\n        }\n    }\n\n    /**\n     * @param combatant\n     * @return\n     */\n    int combatantLifetime(final Combatant combatant) {\n        final OnlineCounter onAndOffline = onliners.get(combatant);\n        if (onAndOffline == null) {\n            return 0;\n        }\n        return onAndOffline.sumOfEvents();\n    }\n\n    /**\n     * @param numberOfAttacker\n     * @param numberOfDefenders\n     */\n    public BattleStatistics(final int numberOfAttacker, final int numberOfDefenders) {\n        _numberOfAttacker = numberOfAttacker;\n        _numberOfDefenders = numberOfDefenders;\n    }\n\n    /**\n     * @param number\n     * @return\n     */\n    int round(final double number) {\n        return (int) Math.round(number);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#percentAbleToShoot(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int percentAbleToShoot(final CombatantSide side) {\n        double sum = 0;\n        int players = 0;\n        for (final Entry<Combatant, Counter> playerShots : shots.entrySet()) {\n            final Combatant combatant = playerShots.getKey();\n            if (isOnSide(side, combatant)) {\n                final int lifetime = combatantLifetime(combatant);\n                final int roundsShooting = playerShots.getValue().getValue();\n                sum += roundsShooting * 100.0 / lifetime;\n                players++;\n            }\n        }\n        if (players == 0) {\n            return 0;\n        }\n        return round(sum / players);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#amountOfAttackBonus(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int amountOfAttackBonus(final CombatantSide side) {\n        return attackBonuses.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#amountOfDefenseBonus(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int amountOfDefenseBonus(final CombatantSide side) {\n        return defenseBonuses.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfMovesPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double numberOfMovesPerPlayer(final CombatantSide side) {\n        double result = 0;\n        switch(side) {\n            case ATTACKER:\n                result = moves.getSideValue(side) / (double) _numberOfAttacker;\n                break;\n            case DEFENDER:\n                result = moves.getSideValue(side) / (double) _numberOfDefenders;\n                break;\n            default:\n                result = moves.getSideValue(null) / (double) (_numberOfAttacker + _numberOfDefenders);\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfOffliners(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfOffliners(final CombatantSide side) {\n        int offliner = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (counter.wasOffline()) {\n                    offliner++;\n                }\n            }\n        }\n        return offliner;\n    }\n\n    /**\n     * @param side\n     * @param combatant\n     * @return\n     */\n    private boolean isOnSide(final CombatantSide side, final Combatant combatant) {\n        return side == null || side.equals(combatant.getSide());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#roundsTillOnline(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double roundsTillOnline(final CombatantSide side) {\n        int combatants = 0;\n        int rounds = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (!counter.wasOffline()) {\n                    combatants++;\n                    rounds += counter.firstOnline();\n                }\n            }\n        }\n        // avoid division by zero\n        if (combatants == 0) {\n            return 0;\n        }\n        return ((double) rounds / (double) combatants);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#averageRoundsOnline(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageRoundsOnline(final CombatantSide side) {\n        double combatants = 0;\n        double rounds = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (!counter.wasOffline()) {\n                    combatants++;\n                    rounds += counter.onlineEvents();\n                }\n            }\n        }\n        // avoid division by zero\n        if (combatants == 0.0) {\n            return 0.0;\n        }\n        return rounds / combatants;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#hasMoved(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Area)\n     */\n    public void hasMoved(final Combatant combatant, final Area newPos) {\n        moves.incrementSide(combatant);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#newDestination(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Area)\n     */\n    public void newDestination(final Combatant combatant, final Area destination) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#aimsAt(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void aimsAt(final Combatant combatant, final Combatant target) {\n        incrementCombatantCounter(shots, combatant);\n        incrementCombatantCounter(victims, target);\n        shotRoundCounter.get(combatant.getSide()).incrementAndGet();\n        final Area field = target._getLocation();\n        getFieldStat(field).addShot();\n    }\n\n    private void incrementCombatantCounter(final Map<Combatant, Counter> combatantCounters, final Combatant combatant) {\n        if (!combatantCounters.containsKey(combatant)) {\n            combatantCounters.put(combatant, new Counter());\n        }\n        combatantCounters.get(combatant).increment();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isHit(de.outstare.fortbattleplayer.model.Combatant,\n     *      int, int)\n     */\n    public void isHit(final Combatant combatant, final int damage, final int oldHealthAmount) {\n        hitRoundCounter.get(combatant.getSide()).incrementAndGet();\n        final Area field = combatant._getLocation();\n        getFieldStat(field).addHit();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isDead(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void isDead(final Combatant combatant) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isAlive(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void isAlive(final Combatant combatant) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isOnline(de.outstare.fortbattleplayer.model.Combatant,\n     *      boolean)\n     */\n    public void isOnline(final Combatant combatant, final boolean changed) {\n        // count all events\n        if (!onliners.containsKey(combatant)) {\n            onliners.put(combatant, new OnlineCounter());\n        }\n        if (combatant.isOnline()) {\n            onliners.get(combatant).addOnline();\n        } else {\n            onliners.get(combatant).addOffline();\n        }\n        // the online event is triggered every round for a player (hopefully)\n        combatantTurn(combatant);\n    }\n\n    /**\n     * no special action, just to track the state every round\n     *\n     * @param combatant\n     */\n    private void combatantTurn(final Combatant combatant) {\n        final SectorBonus bonus = combatant.getSectorBonus();\n        attackBonuses.incrementBy(bonus.attackBonus, combatant);\n        defenseBonuses.incrementBy(bonus.defendBonus, combatant);\n        if (firstRound != null && firstRound.booleanValue()) {\n            turnOrder.add(combatant);\n        }\n        if (LOG.isLoggable(Level.FINE)) {\n            if ((firstRound == null || !firstRound.booleanValue()) && !turnOrder.contains(combatant) && currentRoundNo > 1) {\n                LOG.fine(\"---- not in order: \" + combatant);\n            }\n        }\n        actorsThisRound.incrementSide(combatant);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#targetNoOne(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public String targetNoOne(final CombatantSide side) {\n        String result = \"\";\n        int max = 0;\n        for (final Entry<Combatant, Counter> victim : victims.entrySet()) {\n            final Combatant combatant = victim.getKey();\n            if (isOnSide(side, combatant)) {\n                final int receivedShots = victim.getValue().getValue();\n                if (receivedShots > max) {\n                    max = receivedShots;\n                    result = combatant.getName() + \"(\" + receivedShots + \")\";\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfBayonets(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfBayonets(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.BayonetCounter());\n    }\n\n    /**\n     * @param side\n     * @param counter\n     * @return\n     */\n    int countWeaponMods(final CombatantSide side, final WeaponModCounter counter) {\n        // because every player should have an online/offline event, we look at\n        // the online data hoping to get all players\n        final Set<Combatant> players = onliners.keySet();\n        int bayonets = 0;\n        for (final Combatant combatant : players) {\n            if (isOnSide(side, combatant)) {\n                final Weapon playerWeapon = combatant.getWeapon();\n                // TODO let the counter count\n                if (counter.counts(playerWeapon)) {\n                    bayonets++;\n                }\n            }\n        }\n        return bayonets;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfGraphitLubricants(CombatantSide)\n     */\n    public int numberOfGraphitLubricants(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.GraphitLubricantCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfFettesOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfFettesOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.FettesOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfSchmierOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfSchmierOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.SchmierOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfShinyOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfShinyOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.ShinyOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfLoadingChamerOrEnhancedPatrons(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfLoadingChamerOrEnhancedPatrons(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.LoadingchamberOrEnhancedPatronsCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfHipFlasks(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfHipFlasks(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.HipFlaskCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#hasSwappedPosition()\n     */\n    public void hasSwappedPosition(final Combatant combatant, final Combatant swappedWith) {\n        swaps.incrementSide(combatant);\n        final PositionSwitch swap = new PositionSwitch(currentRoundNo, combatant, swappedWith);\n        assert swapList.get(combatant.getSide()) != null;\n        swapList.get(combatant.getSide()).add(swap);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#totalSwaps(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int totalSwaps(final CombatantSide side) {\n        return swaps.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#switchedPosList(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public Set<PositionSwitch> switchedPosList(final CombatantSide side) {\n        final Set<PositionSwitch> allSwaps;\n        if (side == null) {\n            allSwaps = new HashSet<PositionSwitch>();\n            for (final Set<PositionSwitch> sideSwitches : swapList.values()) {\n                allSwaps.addAll(sideSwitches);\n            }\n        } else {\n            allSwaps = swapList.get(side);\n        }\n        return allSwaps;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#criticalShot(de.outstare.fortbattleplayer.model.Combatant,\n     *      Combatant, int)\n     */\n    public void criticalShot(final Combatant combatant, final Combatant victim, final int damage) {\n        final CriticalHit crit = new CriticalHit(combatant, victim, damage, currentRoundNo);\n        critHits.get(combatant.getSide()).add(crit);\n        crits.incrementSide(combatant);\n        final Area field = victim._getLocation();\n        getFieldStat(field).addCrit();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#critList(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public List<CriticalHit> critList(final CombatantSide side) {\n        final List<CriticalHit> allCrits;\n        if (side == null) {\n            allCrits = new ArrayList<CriticalHit>();\n            for (final List<CriticalHit> sideCrits : critHits.values()) {\n                allCrits.addAll(sideCrits);\n            }\n        } else {\n            allCrits = critHits.get(side);\n        }\n        return allCrits;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#criticalHits(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int criticalHits(final CombatantSide side) {\n        return crits.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#criticalHitDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public long criticalHitDamage(final CombatantSide side) {\n        long sum = 0;\n        for (final CriticalHit crit : critList(side)) {\n            sum += crit.critOnlyDamage;\n        }\n        return sum;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#turnOrder(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public List<Combatant> turnOrder(final CombatantSide side) {\n        final List<Combatant> sidePlayers = new ArrayList<Combatant>(turnOrder.size() / 2);\n        for (final Combatant player : turnOrder) {\n            if (side == null || player.getSide() == side) {\n                sidePlayers.add(player);\n            }\n        }\n        return sidePlayers;\n    }\n\n    /**\n     * @return the number of shots per round\n     */\n    public Map<CombatantSide, ? extends LabeledData> getShotsPerRound() {\n        return shotsPerRound;\n    }\n\n    /**\n     * @return the number of hits per round\n     */\n    public Map<CombatantSide, ? extends LabeledData> getHitsPerRound() {\n        return hitsPerRound;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#getNotShootersPerRound()\n     */\n    public Map<CombatantSide, ? extends LabeledData> getNotShootersPerRound() {\n        final Map<CombatantSide, RoundStatistics> nonShootersPerRound = new HashMap<CombatantSide, RoundStatistics>();\n        for (final CombatantSide side : CombatantSide.values()) {\n            final RoundStatistics nonShooters = new RoundStatistics(\"Not shooting\", \"players\");\n            nonShootersPerRound.put(side, nonShooters);\n            final LabeledData shotRoundCounts = shotsPerRound.get(side);\n            if (shotRoundCounts != null) {\n                final double[] shotCounts = shotRoundCounts.toArray();\n                if (actorsPerRound.size() == shotCounts.length) {\n                    for (int i = 0; i < shotCounts.length; i++) {\n                        final int actors = actorsPerRound.get(i).getSideValue(side);\n                        final double numberNotShooting = actors - shotCounts[i];\n                        nonShooters.addValue(numberNotShooting);\n                    }\n                } else {\n                    LOG.warning(\"round statistics for players and shots differ!\");\n                }\n            } else {\n                LOG.warning(\"no data for players and shots for side \" + side);\n            }\n        }\n        return nonShootersPerRound;\n    }\n\n    private AreaStatistic getFieldStat(final Area area) {\n        if (!fieldStats.containsKey(area)) {\n            fieldStats.put(area, new AreaStatistic(area));\n        }\n        return fieldStats.get(area);\n    }\n\n    /**\n     * @return statistics for every field\n     */\n    public Map<Area, AreaStatistic> getFieldStatistics() {\n        return fieldStats;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/BattleStatistics_6Test.java",
		"test_prompt": "// BattleStatistics_6Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BattleStatistics}.\n* It contains ten unit test cases for the {@link BattleStatistics#averageRoundsOnline(CombatantSide)} method.\n*/\nclass BattleStatistics_6Test {"
	},
	{
		"original_code": "// BattleStatistics.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\n\n/**\n * @author daniel\n */\npublic class BattleStatistics implements DynamicStatistics, CombatantObserver {\n\n    private static final transient Logger LOG = Logger.getLogger(BattleStatistics.class.getName());\n\n    private final Map<Combatant, OnlineCounter> onliners = new HashMap<Combatant, OnlineCounter>();\n\n    private final Map<CombatantSide, List<CriticalHit>> critHits = new HashMap<CombatantSide, List<CriticalHit>>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            critHits.put(side, new ArrayList<CriticalHit>());\n        }\n    }\n\n    private final Map<CombatantSide, Set<PositionSwitch>> swapList = new HashMap<CombatantSide, Set<PositionSwitch>>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            swapList.put(side, new HashSet<PositionSwitch>());\n        }\n    }\n\n    private final AllCombatantSidesCounter crits = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter moves = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter swaps = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter attackBonuses = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter defenseBonuses = new AllCombatantSidesCounter();\n\n    private final Map<Combatant, Counter> shots = new HashMap<Combatant, Counter>();\n\n    private final Map<CombatantSide, RoundStatistics> shotsPerRound = new HashMap<CombatantSide, RoundStatistics>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            shotsPerRound.put(side, new RoundStatistics(\"shots\", \"shots\"));\n        }\n    }\n\n    private final Map<CombatantSide, RoundStatistics> hitsPerRound = new HashMap<CombatantSide, RoundStatistics>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            hitsPerRound.put(side, new RoundStatistics(\"hits\", \"hits\"));\n        }\n    }\n\n    private final Map<CombatantSide, AtomicInteger> shotRoundCounter = new HashMap<CombatantSide, AtomicInteger>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            shotRoundCounter.put(side, new AtomicInteger());\n        }\n    }\n\n    private final Map<CombatantSide, AtomicInteger> hitRoundCounter = new HashMap<CombatantSide, AtomicInteger>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            hitRoundCounter.put(side, new AtomicInteger());\n        }\n    }\n\n    private final Map<Combatant, Counter> victims = new HashMap<Combatant, Counter>();\n\n    private final List<Combatant> turnOrder = new LinkedList<Combatant>();\n\n    private final List<AllCombatantSidesCounter> actorsPerRound = new ArrayList<AllCombatantSidesCounter>(50);\n\n    private final Map<Area, AreaStatistic> fieldStats = new HashMap<Area, AreaStatistic>();\n\n    private final int _numberOfDefenders;\n\n    private final int _numberOfAttacker;\n\n    private int currentRoundNo = 0;\n\n    private Boolean firstRound = null;\n\n    private AllCombatantSidesCounter actorsThisRound = new AllCombatantSidesCounter();\n\n    /**\n     * set the current round. all following method calls will belong to this\n     * round till this method is called again with another parameter.\n     *\n     * @param no\n     */\n    public void setRound(final int no) {\n        if (firstRound == null) {\n            firstRound = Boolean.TRUE;\n        } else if (firstRound.booleanValue()) {\n            firstRound = Boolean.FALSE;\n            // the turn order is determined only in the first round\n            for (final Combatant player : onliners.keySet()) {\n                if (!turnOrder.contains(player)) {\n                    LOG.info(\"could not determine turn order for \" + player);\n                }\n            }\n        }\n        addAndResetRoundCounter(shotRoundCounter, shotsPerRound);\n        addAndResetRoundCounter(hitRoundCounter, hitsPerRound);\n        actorsPerRound.add(actorsThisRound);\n        actorsThisRound = new AllCombatantSidesCounter();\n        currentRoundNo = no;\n    }\n\n    /**\n     * this adds the counters for the last round to the total counts per round\n     * and resets the given counter\n     *\n     * @param roundCounter\n     * @param allRounds\n     */\n    void addAndResetRoundCounter(final Map<CombatantSide, AtomicInteger> roundCounter, final Map<CombatantSide, RoundStatistics> allRounds) {\n        for (final Entry<CombatantSide, AtomicInteger> mapping : roundCounter.entrySet()) {\n            final CombatantSide side = mapping.getKey();\n            final AtomicInteger roundShots = mapping.getValue();\n            allRounds.get(side).addValue(roundShots.get());\n            // reset for next round\n            roundShots.set(0);\n        }\n    }\n\n    /**\n     * @param combatant\n     * @return\n     */\n    int combatantLifetime(final Combatant combatant) {\n        final OnlineCounter onAndOffline = onliners.get(combatant);\n        if (onAndOffline == null) {\n            return 0;\n        }\n        return onAndOffline.sumOfEvents();\n    }\n\n    /**\n     * @param numberOfAttacker\n     * @param numberOfDefenders\n     */\n    public BattleStatistics(final int numberOfAttacker, final int numberOfDefenders) {\n        _numberOfAttacker = numberOfAttacker;\n        _numberOfDefenders = numberOfDefenders;\n    }\n\n    /**\n     * @param number\n     * @return\n     */\n    int round(final double number) {\n        return (int) Math.round(number);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#percentAbleToShoot(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int percentAbleToShoot(final CombatantSide side) {\n        double sum = 0;\n        int players = 0;\n        for (final Entry<Combatant, Counter> playerShots : shots.entrySet()) {\n            final Combatant combatant = playerShots.getKey();\n            if (isOnSide(side, combatant)) {\n                final int lifetime = combatantLifetime(combatant);\n                final int roundsShooting = playerShots.getValue().getValue();\n                sum += roundsShooting * 100.0 / lifetime;\n                players++;\n            }\n        }\n        if (players == 0) {\n            return 0;\n        }\n        return round(sum / players);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#amountOfAttackBonus(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int amountOfAttackBonus(final CombatantSide side) {\n        return attackBonuses.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#amountOfDefenseBonus(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int amountOfDefenseBonus(final CombatantSide side) {\n        return defenseBonuses.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfMovesPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double numberOfMovesPerPlayer(final CombatantSide side) {\n        double result = 0;\n        switch(side) {\n            case ATTACKER:\n                result = moves.getSideValue(side) / (double) _numberOfAttacker;\n                break;\n            case DEFENDER:\n                result = moves.getSideValue(side) / (double) _numberOfDefenders;\n                break;\n            default:\n                result = moves.getSideValue(null) / (double) (_numberOfAttacker + _numberOfDefenders);\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfOffliners(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfOffliners(final CombatantSide side) {\n        int offliner = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (counter.wasOffline()) {\n                    offliner++;\n                }\n            }\n        }\n        return offliner;\n    }\n\n    /**\n     * @param side\n     * @param combatant\n     * @return\n     */\n    private boolean isOnSide(final CombatantSide side, final Combatant combatant) {\n        return side == null || side.equals(combatant.getSide());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#roundsTillOnline(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double roundsTillOnline(final CombatantSide side) {\n        int combatants = 0;\n        int rounds = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (!counter.wasOffline()) {\n                    combatants++;\n                    rounds += counter.firstOnline();\n                }\n            }\n        }\n        // avoid division by zero\n        if (combatants == 0) {\n            return 0;\n        }\n        return ((double) rounds / (double) combatants);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#averageRoundsOnline(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageRoundsOnline(final CombatantSide side) {\n        double combatants = 0;\n        double rounds = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (!counter.wasOffline()) {\n                    combatants++;\n                    rounds += counter.onlineEvents();\n                }\n            }\n        }\n        // avoid division by zero\n        if (combatants == 0.0) {\n            return 0.0;\n        }\n        return rounds / combatants;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#hasMoved(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Area)\n     */\n    public void hasMoved(final Combatant combatant, final Area newPos) {\n        moves.incrementSide(combatant);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#newDestination(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Area)\n     */\n    public void newDestination(final Combatant combatant, final Area destination) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#aimsAt(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void aimsAt(final Combatant combatant, final Combatant target) {\n        incrementCombatantCounter(shots, combatant);\n        incrementCombatantCounter(victims, target);\n        shotRoundCounter.get(combatant.getSide()).incrementAndGet();\n        final Area field = target._getLocation();\n        getFieldStat(field).addShot();\n    }\n\n    private void incrementCombatantCounter(final Map<Combatant, Counter> combatantCounters, final Combatant combatant) {\n        if (!combatantCounters.containsKey(combatant)) {\n            combatantCounters.put(combatant, new Counter());\n        }\n        combatantCounters.get(combatant).increment();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isHit(de.outstare.fortbattleplayer.model.Combatant,\n     *      int, int)\n     */\n    public void isHit(final Combatant combatant, final int damage, final int oldHealthAmount) {\n        hitRoundCounter.get(combatant.getSide()).incrementAndGet();\n        final Area field = combatant._getLocation();\n        getFieldStat(field).addHit();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isDead(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void isDead(final Combatant combatant) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isAlive(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void isAlive(final Combatant combatant) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isOnline(de.outstare.fortbattleplayer.model.Combatant,\n     *      boolean)\n     */\n    public void isOnline(final Combatant combatant, final boolean changed) {\n        // count all events\n        if (!onliners.containsKey(combatant)) {\n            onliners.put(combatant, new OnlineCounter());\n        }\n        if (combatant.isOnline()) {\n            onliners.get(combatant).addOnline();\n        } else {\n            onliners.get(combatant).addOffline();\n        }\n        // the online event is triggered every round for a player (hopefully)\n        combatantTurn(combatant);\n    }\n\n    /**\n     * no special action, just to track the state every round\n     *\n     * @param combatant\n     */\n    private void combatantTurn(final Combatant combatant) {\n        final SectorBonus bonus = combatant.getSectorBonus();\n        attackBonuses.incrementBy(bonus.attackBonus, combatant);\n        defenseBonuses.incrementBy(bonus.defendBonus, combatant);\n        if (firstRound != null && firstRound.booleanValue()) {\n            turnOrder.add(combatant);\n        }\n        if (LOG.isLoggable(Level.FINE)) {\n            if ((firstRound == null || !firstRound.booleanValue()) && !turnOrder.contains(combatant) && currentRoundNo > 1) {\n                LOG.fine(\"---- not in order: \" + combatant);\n            }\n        }\n        actorsThisRound.incrementSide(combatant);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#targetNoOne(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public String targetNoOne(final CombatantSide side) {\n        String result = \"\";\n        int max = 0;\n        for (final Entry<Combatant, Counter> victim : victims.entrySet()) {\n            final Combatant combatant = victim.getKey();\n            if (isOnSide(side, combatant)) {\n                final int receivedShots = victim.getValue().getValue();\n                if (receivedShots > max) {\n                    max = receivedShots;\n                    result = combatant.getName() + \"(\" + receivedShots + \")\";\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfBayonets(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfBayonets(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.BayonetCounter());\n    }\n\n    /**\n     * @param side\n     * @param counter\n     * @return\n     */\n    int countWeaponMods(final CombatantSide side, final WeaponModCounter counter) {\n        // because every player should have an online/offline event, we look at\n        // the online data hoping to get all players\n        final Set<Combatant> players = onliners.keySet();\n        int bayonets = 0;\n        for (final Combatant combatant : players) {\n            if (isOnSide(side, combatant)) {\n                final Weapon playerWeapon = combatant.getWeapon();\n                // TODO let the counter count\n                if (counter.counts(playerWeapon)) {\n                    bayonets++;\n                }\n            }\n        }\n        return bayonets;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfGraphitLubricants(CombatantSide)\n     */\n    public int numberOfGraphitLubricants(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.GraphitLubricantCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfFettesOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfFettesOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.FettesOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfSchmierOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfSchmierOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.SchmierOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfShinyOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfShinyOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.ShinyOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfLoadingChamerOrEnhancedPatrons(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfLoadingChamerOrEnhancedPatrons(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.LoadingchamberOrEnhancedPatronsCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfHipFlasks(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfHipFlasks(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.HipFlaskCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#hasSwappedPosition()\n     */\n    public void hasSwappedPosition(final Combatant combatant, final Combatant swappedWith) {\n        swaps.incrementSide(combatant);\n        final PositionSwitch swap = new PositionSwitch(currentRoundNo, combatant, swappedWith);\n        assert swapList.get(combatant.getSide()) != null;\n        swapList.get(combatant.getSide()).add(swap);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#totalSwaps(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int totalSwaps(final CombatantSide side) {\n        return swaps.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#switchedPosList(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public Set<PositionSwitch> switchedPosList(final CombatantSide side) {\n        final Set<PositionSwitch> allSwaps;\n        if (side == null) {\n            allSwaps = new HashSet<PositionSwitch>();\n            for (final Set<PositionSwitch> sideSwitches : swapList.values()) {\n                allSwaps.addAll(sideSwitches);\n            }\n        } else {\n            allSwaps = swapList.get(side);\n        }\n        return allSwaps;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#criticalShot(de.outstare.fortbattleplayer.model.Combatant,\n     *      Combatant, int)\n     */\n    public void criticalShot(final Combatant combatant, final Combatant victim, final int damage) {\n        final CriticalHit crit = new CriticalHit(combatant, victim, damage, currentRoundNo);\n        critHits.get(combatant.getSide()).add(crit);\n        crits.incrementSide(combatant);\n        final Area field = victim._getLocation();\n        getFieldStat(field).addCrit();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#critList(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public List<CriticalHit> critList(final CombatantSide side) {\n        final List<CriticalHit> allCrits;\n        if (side == null) {\n            allCrits = new ArrayList<CriticalHit>();\n            for (final List<CriticalHit> sideCrits : critHits.values()) {\n                allCrits.addAll(sideCrits);\n            }\n        } else {\n            allCrits = critHits.get(side);\n        }\n        return allCrits;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#criticalHits(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int criticalHits(final CombatantSide side) {\n        return crits.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#criticalHitDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public long criticalHitDamage(final CombatantSide side) {\n        long sum = 0;\n        for (final CriticalHit crit : critList(side)) {\n            sum += crit.critOnlyDamage;\n        }\n        return sum;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#turnOrder(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public List<Combatant> turnOrder(final CombatantSide side) {\n        final List<Combatant> sidePlayers = new ArrayList<Combatant>(turnOrder.size() / 2);\n        for (final Combatant player : turnOrder) {\n            if (side == null || player.getSide() == side) {\n                sidePlayers.add(player);\n            }\n        }\n        return sidePlayers;\n    }\n\n    /**\n     * @return the number of shots per round\n     */\n    public Map<CombatantSide, ? extends LabeledData> getShotsPerRound() {\n        return shotsPerRound;\n    }\n\n    /**\n     * @return the number of hits per round\n     */\n    public Map<CombatantSide, ? extends LabeledData> getHitsPerRound() {\n        return hitsPerRound;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#getNotShootersPerRound()\n     */\n    public Map<CombatantSide, ? extends LabeledData> getNotShootersPerRound() {\n        final Map<CombatantSide, RoundStatistics> nonShootersPerRound = new HashMap<CombatantSide, RoundStatistics>();\n        for (final CombatantSide side : CombatantSide.values()) {\n            final RoundStatistics nonShooters = new RoundStatistics(\"Not shooting\", \"players\");\n            nonShootersPerRound.put(side, nonShooters);\n            final LabeledData shotRoundCounts = shotsPerRound.get(side);\n            if (shotRoundCounts != null) {\n                final double[] shotCounts = shotRoundCounts.toArray();\n                if (actorsPerRound.size() == shotCounts.length) {\n                    for (int i = 0; i < shotCounts.length; i++) {\n                        final int actors = actorsPerRound.get(i).getSideValue(side);\n                        final double numberNotShooting = actors - shotCounts[i];\n                        nonShooters.addValue(numberNotShooting);\n                    }\n                } else {\n                    LOG.warning(\"round statistics for players and shots differ!\");\n                }\n            } else {\n                LOG.warning(\"no data for players and shots for side \" + side);\n            }\n        }\n        return nonShootersPerRound;\n    }\n\n    private AreaStatistic getFieldStat(final Area area) {\n        if (!fieldStats.containsKey(area)) {\n            fieldStats.put(area, new AreaStatistic(area));\n        }\n        return fieldStats.get(area);\n    }\n\n    /**\n     * @return statistics for every field\n     */\n    public Map<Area, AreaStatistic> getFieldStatistics() {\n        return fieldStats;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/BattleStatistics_7Test.java",
		"test_prompt": "// BattleStatistics_7Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BattleStatistics}.\n* It contains ten unit test cases for the {@link BattleStatistics#targetNoOne(CombatantSide)} method.\n*/\nclass BattleStatistics_7Test {"
	},
	{
		"original_code": "// BattleStatistics.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\n\n/**\n * @author daniel\n */\npublic class BattleStatistics implements DynamicStatistics, CombatantObserver {\n\n    private static final transient Logger LOG = Logger.getLogger(BattleStatistics.class.getName());\n\n    private final Map<Combatant, OnlineCounter> onliners = new HashMap<Combatant, OnlineCounter>();\n\n    private final Map<CombatantSide, List<CriticalHit>> critHits = new HashMap<CombatantSide, List<CriticalHit>>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            critHits.put(side, new ArrayList<CriticalHit>());\n        }\n    }\n\n    private final Map<CombatantSide, Set<PositionSwitch>> swapList = new HashMap<CombatantSide, Set<PositionSwitch>>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            swapList.put(side, new HashSet<PositionSwitch>());\n        }\n    }\n\n    private final AllCombatantSidesCounter crits = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter moves = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter swaps = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter attackBonuses = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter defenseBonuses = new AllCombatantSidesCounter();\n\n    private final Map<Combatant, Counter> shots = new HashMap<Combatant, Counter>();\n\n    private final Map<CombatantSide, RoundStatistics> shotsPerRound = new HashMap<CombatantSide, RoundStatistics>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            shotsPerRound.put(side, new RoundStatistics(\"shots\", \"shots\"));\n        }\n    }\n\n    private final Map<CombatantSide, RoundStatistics> hitsPerRound = new HashMap<CombatantSide, RoundStatistics>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            hitsPerRound.put(side, new RoundStatistics(\"hits\", \"hits\"));\n        }\n    }\n\n    private final Map<CombatantSide, AtomicInteger> shotRoundCounter = new HashMap<CombatantSide, AtomicInteger>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            shotRoundCounter.put(side, new AtomicInteger());\n        }\n    }\n\n    private final Map<CombatantSide, AtomicInteger> hitRoundCounter = new HashMap<CombatantSide, AtomicInteger>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            hitRoundCounter.put(side, new AtomicInteger());\n        }\n    }\n\n    private final Map<Combatant, Counter> victims = new HashMap<Combatant, Counter>();\n\n    private final List<Combatant> turnOrder = new LinkedList<Combatant>();\n\n    private final List<AllCombatantSidesCounter> actorsPerRound = new ArrayList<AllCombatantSidesCounter>(50);\n\n    private final Map<Area, AreaStatistic> fieldStats = new HashMap<Area, AreaStatistic>();\n\n    private final int _numberOfDefenders;\n\n    private final int _numberOfAttacker;\n\n    private int currentRoundNo = 0;\n\n    private Boolean firstRound = null;\n\n    private AllCombatantSidesCounter actorsThisRound = new AllCombatantSidesCounter();\n\n    /**\n     * set the current round. all following method calls will belong to this\n     * round till this method is called again with another parameter.\n     *\n     * @param no\n     */\n    public void setRound(final int no) {\n        if (firstRound == null) {\n            firstRound = Boolean.TRUE;\n        } else if (firstRound.booleanValue()) {\n            firstRound = Boolean.FALSE;\n            // the turn order is determined only in the first round\n            for (final Combatant player : onliners.keySet()) {\n                if (!turnOrder.contains(player)) {\n                    LOG.info(\"could not determine turn order for \" + player);\n                }\n            }\n        }\n        addAndResetRoundCounter(shotRoundCounter, shotsPerRound);\n        addAndResetRoundCounter(hitRoundCounter, hitsPerRound);\n        actorsPerRound.add(actorsThisRound);\n        actorsThisRound = new AllCombatantSidesCounter();\n        currentRoundNo = no;\n    }\n\n    /**\n     * this adds the counters for the last round to the total counts per round\n     * and resets the given counter\n     *\n     * @param roundCounter\n     * @param allRounds\n     */\n    void addAndResetRoundCounter(final Map<CombatantSide, AtomicInteger> roundCounter, final Map<CombatantSide, RoundStatistics> allRounds) {\n        for (final Entry<CombatantSide, AtomicInteger> mapping : roundCounter.entrySet()) {\n            final CombatantSide side = mapping.getKey();\n            final AtomicInteger roundShots = mapping.getValue();\n            allRounds.get(side).addValue(roundShots.get());\n            // reset for next round\n            roundShots.set(0);\n        }\n    }\n\n    /**\n     * @param combatant\n     * @return\n     */\n    int combatantLifetime(final Combatant combatant) {\n        final OnlineCounter onAndOffline = onliners.get(combatant);\n        if (onAndOffline == null) {\n            return 0;\n        }\n        return onAndOffline.sumOfEvents();\n    }\n\n    /**\n     * @param numberOfAttacker\n     * @param numberOfDefenders\n     */\n    public BattleStatistics(final int numberOfAttacker, final int numberOfDefenders) {\n        _numberOfAttacker = numberOfAttacker;\n        _numberOfDefenders = numberOfDefenders;\n    }\n\n    /**\n     * @param number\n     * @return\n     */\n    int round(final double number) {\n        return (int) Math.round(number);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#percentAbleToShoot(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int percentAbleToShoot(final CombatantSide side) {\n        double sum = 0;\n        int players = 0;\n        for (final Entry<Combatant, Counter> playerShots : shots.entrySet()) {\n            final Combatant combatant = playerShots.getKey();\n            if (isOnSide(side, combatant)) {\n                final int lifetime = combatantLifetime(combatant);\n                final int roundsShooting = playerShots.getValue().getValue();\n                sum += roundsShooting * 100.0 / lifetime;\n                players++;\n            }\n        }\n        if (players == 0) {\n            return 0;\n        }\n        return round(sum / players);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#amountOfAttackBonus(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int amountOfAttackBonus(final CombatantSide side) {\n        return attackBonuses.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#amountOfDefenseBonus(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int amountOfDefenseBonus(final CombatantSide side) {\n        return defenseBonuses.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfMovesPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double numberOfMovesPerPlayer(final CombatantSide side) {\n        double result = 0;\n        switch(side) {\n            case ATTACKER:\n                result = moves.getSideValue(side) / (double) _numberOfAttacker;\n                break;\n            case DEFENDER:\n                result = moves.getSideValue(side) / (double) _numberOfDefenders;\n                break;\n            default:\n                result = moves.getSideValue(null) / (double) (_numberOfAttacker + _numberOfDefenders);\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfOffliners(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfOffliners(final CombatantSide side) {\n        int offliner = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (counter.wasOffline()) {\n                    offliner++;\n                }\n            }\n        }\n        return offliner;\n    }\n\n    /**\n     * @param side\n     * @param combatant\n     * @return\n     */\n    private boolean isOnSide(final CombatantSide side, final Combatant combatant) {\n        return side == null || side.equals(combatant.getSide());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#roundsTillOnline(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double roundsTillOnline(final CombatantSide side) {\n        int combatants = 0;\n        int rounds = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (!counter.wasOffline()) {\n                    combatants++;\n                    rounds += counter.firstOnline();\n                }\n            }\n        }\n        // avoid division by zero\n        if (combatants == 0) {\n            return 0;\n        }\n        return ((double) rounds / (double) combatants);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#averageRoundsOnline(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageRoundsOnline(final CombatantSide side) {\n        double combatants = 0;\n        double rounds = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (!counter.wasOffline()) {\n                    combatants++;\n                    rounds += counter.onlineEvents();\n                }\n            }\n        }\n        // avoid division by zero\n        if (combatants == 0.0) {\n            return 0.0;\n        }\n        return rounds / combatants;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#hasMoved(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Area)\n     */\n    public void hasMoved(final Combatant combatant, final Area newPos) {\n        moves.incrementSide(combatant);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#newDestination(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Area)\n     */\n    public void newDestination(final Combatant combatant, final Area destination) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#aimsAt(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void aimsAt(final Combatant combatant, final Combatant target) {\n        incrementCombatantCounter(shots, combatant);\n        incrementCombatantCounter(victims, target);\n        shotRoundCounter.get(combatant.getSide()).incrementAndGet();\n        final Area field = target._getLocation();\n        getFieldStat(field).addShot();\n    }\n\n    private void incrementCombatantCounter(final Map<Combatant, Counter> combatantCounters, final Combatant combatant) {\n        if (!combatantCounters.containsKey(combatant)) {\n            combatantCounters.put(combatant, new Counter());\n        }\n        combatantCounters.get(combatant).increment();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isHit(de.outstare.fortbattleplayer.model.Combatant,\n     *      int, int)\n     */\n    public void isHit(final Combatant combatant, final int damage, final int oldHealthAmount) {\n        hitRoundCounter.get(combatant.getSide()).incrementAndGet();\n        final Area field = combatant._getLocation();\n        getFieldStat(field).addHit();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isDead(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void isDead(final Combatant combatant) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isAlive(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void isAlive(final Combatant combatant) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isOnline(de.outstare.fortbattleplayer.model.Combatant,\n     *      boolean)\n     */\n    public void isOnline(final Combatant combatant, final boolean changed) {\n        // count all events\n        if (!onliners.containsKey(combatant)) {\n            onliners.put(combatant, new OnlineCounter());\n        }\n        if (combatant.isOnline()) {\n            onliners.get(combatant).addOnline();\n        } else {\n            onliners.get(combatant).addOffline();\n        }\n        // the online event is triggered every round for a player (hopefully)\n        combatantTurn(combatant);\n    }\n\n    /**\n     * no special action, just to track the state every round\n     *\n     * @param combatant\n     */\n    private void combatantTurn(final Combatant combatant) {\n        final SectorBonus bonus = combatant.getSectorBonus();\n        attackBonuses.incrementBy(bonus.attackBonus, combatant);\n        defenseBonuses.incrementBy(bonus.defendBonus, combatant);\n        if (firstRound != null && firstRound.booleanValue()) {\n            turnOrder.add(combatant);\n        }\n        if (LOG.isLoggable(Level.FINE)) {\n            if ((firstRound == null || !firstRound.booleanValue()) && !turnOrder.contains(combatant) && currentRoundNo > 1) {\n                LOG.fine(\"---- not in order: \" + combatant);\n            }\n        }\n        actorsThisRound.incrementSide(combatant);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#targetNoOne(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public String targetNoOne(final CombatantSide side) {\n        String result = \"\";\n        int max = 0;\n        for (final Entry<Combatant, Counter> victim : victims.entrySet()) {\n            final Combatant combatant = victim.getKey();\n            if (isOnSide(side, combatant)) {\n                final int receivedShots = victim.getValue().getValue();\n                if (receivedShots > max) {\n                    max = receivedShots;\n                    result = combatant.getName() + \"(\" + receivedShots + \")\";\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfBayonets(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfBayonets(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.BayonetCounter());\n    }\n\n    /**\n     * @param side\n     * @param counter\n     * @return\n     */\n    int countWeaponMods(final CombatantSide side, final WeaponModCounter counter) {\n        // because every player should have an online/offline event, we look at\n        // the online data hoping to get all players\n        final Set<Combatant> players = onliners.keySet();\n        int bayonets = 0;\n        for (final Combatant combatant : players) {\n            if (isOnSide(side, combatant)) {\n                final Weapon playerWeapon = combatant.getWeapon();\n                // TODO let the counter count\n                if (counter.counts(playerWeapon)) {\n                    bayonets++;\n                }\n            }\n        }\n        return bayonets;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfGraphitLubricants(CombatantSide)\n     */\n    public int numberOfGraphitLubricants(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.GraphitLubricantCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfFettesOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfFettesOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.FettesOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfSchmierOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfSchmierOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.SchmierOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfShinyOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfShinyOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.ShinyOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfLoadingChamerOrEnhancedPatrons(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfLoadingChamerOrEnhancedPatrons(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.LoadingchamberOrEnhancedPatronsCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfHipFlasks(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfHipFlasks(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.HipFlaskCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#hasSwappedPosition()\n     */\n    public void hasSwappedPosition(final Combatant combatant, final Combatant swappedWith) {\n        swaps.incrementSide(combatant);\n        final PositionSwitch swap = new PositionSwitch(currentRoundNo, combatant, swappedWith);\n        assert swapList.get(combatant.getSide()) != null;\n        swapList.get(combatant.getSide()).add(swap);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#totalSwaps(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int totalSwaps(final CombatantSide side) {\n        return swaps.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#switchedPosList(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public Set<PositionSwitch> switchedPosList(final CombatantSide side) {\n        final Set<PositionSwitch> allSwaps;\n        if (side == null) {\n            allSwaps = new HashSet<PositionSwitch>();\n            for (final Set<PositionSwitch> sideSwitches : swapList.values()) {\n                allSwaps.addAll(sideSwitches);\n            }\n        } else {\n            allSwaps = swapList.get(side);\n        }\n        return allSwaps;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#criticalShot(de.outstare.fortbattleplayer.model.Combatant,\n     *      Combatant, int)\n     */\n    public void criticalShot(final Combatant combatant, final Combatant victim, final int damage) {\n        final CriticalHit crit = new CriticalHit(combatant, victim, damage, currentRoundNo);\n        critHits.get(combatant.getSide()).add(crit);\n        crits.incrementSide(combatant);\n        final Area field = victim._getLocation();\n        getFieldStat(field).addCrit();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#critList(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public List<CriticalHit> critList(final CombatantSide side) {\n        final List<CriticalHit> allCrits;\n        if (side == null) {\n            allCrits = new ArrayList<CriticalHit>();\n            for (final List<CriticalHit> sideCrits : critHits.values()) {\n                allCrits.addAll(sideCrits);\n            }\n        } else {\n            allCrits = critHits.get(side);\n        }\n        return allCrits;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#criticalHits(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int criticalHits(final CombatantSide side) {\n        return crits.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#criticalHitDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public long criticalHitDamage(final CombatantSide side) {\n        long sum = 0;\n        for (final CriticalHit crit : critList(side)) {\n            sum += crit.critOnlyDamage;\n        }\n        return sum;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#turnOrder(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public List<Combatant> turnOrder(final CombatantSide side) {\n        final List<Combatant> sidePlayers = new ArrayList<Combatant>(turnOrder.size() / 2);\n        for (final Combatant player : turnOrder) {\n            if (side == null || player.getSide() == side) {\n                sidePlayers.add(player);\n            }\n        }\n        return sidePlayers;\n    }\n\n    /**\n     * @return the number of shots per round\n     */\n    public Map<CombatantSide, ? extends LabeledData> getShotsPerRound() {\n        return shotsPerRound;\n    }\n\n    /**\n     * @return the number of hits per round\n     */\n    public Map<CombatantSide, ? extends LabeledData> getHitsPerRound() {\n        return hitsPerRound;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#getNotShootersPerRound()\n     */\n    public Map<CombatantSide, ? extends LabeledData> getNotShootersPerRound() {\n        final Map<CombatantSide, RoundStatistics> nonShootersPerRound = new HashMap<CombatantSide, RoundStatistics>();\n        for (final CombatantSide side : CombatantSide.values()) {\n            final RoundStatistics nonShooters = new RoundStatistics(\"Not shooting\", \"players\");\n            nonShootersPerRound.put(side, nonShooters);\n            final LabeledData shotRoundCounts = shotsPerRound.get(side);\n            if (shotRoundCounts != null) {\n                final double[] shotCounts = shotRoundCounts.toArray();\n                if (actorsPerRound.size() == shotCounts.length) {\n                    for (int i = 0; i < shotCounts.length; i++) {\n                        final int actors = actorsPerRound.get(i).getSideValue(side);\n                        final double numberNotShooting = actors - shotCounts[i];\n                        nonShooters.addValue(numberNotShooting);\n                    }\n                } else {\n                    LOG.warning(\"round statistics for players and shots differ!\");\n                }\n            } else {\n                LOG.warning(\"no data for players and shots for side \" + side);\n            }\n        }\n        return nonShootersPerRound;\n    }\n\n    private AreaStatistic getFieldStat(final Area area) {\n        if (!fieldStats.containsKey(area)) {\n            fieldStats.put(area, new AreaStatistic(area));\n        }\n        return fieldStats.get(area);\n    }\n\n    /**\n     * @return statistics for every field\n     */\n    public Map<Area, AreaStatistic> getFieldStatistics() {\n        return fieldStats;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/BattleStatistics_8Test.java",
		"test_prompt": "// BattleStatistics_8Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BattleStatistics}.\n* It contains ten unit test cases for the {@link BattleStatistics#numberOfBayonets(CombatantSide)} method.\n*/\nclass BattleStatistics_8Test {"
	},
	{
		"original_code": "// BattleStatistics.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\n\n/**\n * @author daniel\n */\npublic class BattleStatistics implements DynamicStatistics, CombatantObserver {\n\n    private static final transient Logger LOG = Logger.getLogger(BattleStatistics.class.getName());\n\n    private final Map<Combatant, OnlineCounter> onliners = new HashMap<Combatant, OnlineCounter>();\n\n    private final Map<CombatantSide, List<CriticalHit>> critHits = new HashMap<CombatantSide, List<CriticalHit>>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            critHits.put(side, new ArrayList<CriticalHit>());\n        }\n    }\n\n    private final Map<CombatantSide, Set<PositionSwitch>> swapList = new HashMap<CombatantSide, Set<PositionSwitch>>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            swapList.put(side, new HashSet<PositionSwitch>());\n        }\n    }\n\n    private final AllCombatantSidesCounter crits = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter moves = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter swaps = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter attackBonuses = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter defenseBonuses = new AllCombatantSidesCounter();\n\n    private final Map<Combatant, Counter> shots = new HashMap<Combatant, Counter>();\n\n    private final Map<CombatantSide, RoundStatistics> shotsPerRound = new HashMap<CombatantSide, RoundStatistics>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            shotsPerRound.put(side, new RoundStatistics(\"shots\", \"shots\"));\n        }\n    }\n\n    private final Map<CombatantSide, RoundStatistics> hitsPerRound = new HashMap<CombatantSide, RoundStatistics>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            hitsPerRound.put(side, new RoundStatistics(\"hits\", \"hits\"));\n        }\n    }\n\n    private final Map<CombatantSide, AtomicInteger> shotRoundCounter = new HashMap<CombatantSide, AtomicInteger>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            shotRoundCounter.put(side, new AtomicInteger());\n        }\n    }\n\n    private final Map<CombatantSide, AtomicInteger> hitRoundCounter = new HashMap<CombatantSide, AtomicInteger>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            hitRoundCounter.put(side, new AtomicInteger());\n        }\n    }\n\n    private final Map<Combatant, Counter> victims = new HashMap<Combatant, Counter>();\n\n    private final List<Combatant> turnOrder = new LinkedList<Combatant>();\n\n    private final List<AllCombatantSidesCounter> actorsPerRound = new ArrayList<AllCombatantSidesCounter>(50);\n\n    private final Map<Area, AreaStatistic> fieldStats = new HashMap<Area, AreaStatistic>();\n\n    private final int _numberOfDefenders;\n\n    private final int _numberOfAttacker;\n\n    private int currentRoundNo = 0;\n\n    private Boolean firstRound = null;\n\n    private AllCombatantSidesCounter actorsThisRound = new AllCombatantSidesCounter();\n\n    /**\n     * set the current round. all following method calls will belong to this\n     * round till this method is called again with another parameter.\n     *\n     * @param no\n     */\n    public void setRound(final int no) {\n        if (firstRound == null) {\n            firstRound = Boolean.TRUE;\n        } else if (firstRound.booleanValue()) {\n            firstRound = Boolean.FALSE;\n            // the turn order is determined only in the first round\n            for (final Combatant player : onliners.keySet()) {\n                if (!turnOrder.contains(player)) {\n                    LOG.info(\"could not determine turn order for \" + player);\n                }\n            }\n        }\n        addAndResetRoundCounter(shotRoundCounter, shotsPerRound);\n        addAndResetRoundCounter(hitRoundCounter, hitsPerRound);\n        actorsPerRound.add(actorsThisRound);\n        actorsThisRound = new AllCombatantSidesCounter();\n        currentRoundNo = no;\n    }\n\n    /**\n     * this adds the counters for the last round to the total counts per round\n     * and resets the given counter\n     *\n     * @param roundCounter\n     * @param allRounds\n     */\n    void addAndResetRoundCounter(final Map<CombatantSide, AtomicInteger> roundCounter, final Map<CombatantSide, RoundStatistics> allRounds) {\n        for (final Entry<CombatantSide, AtomicInteger> mapping : roundCounter.entrySet()) {\n            final CombatantSide side = mapping.getKey();\n            final AtomicInteger roundShots = mapping.getValue();\n            allRounds.get(side).addValue(roundShots.get());\n            // reset for next round\n            roundShots.set(0);\n        }\n    }\n\n    /**\n     * @param combatant\n     * @return\n     */\n    int combatantLifetime(final Combatant combatant) {\n        final OnlineCounter onAndOffline = onliners.get(combatant);\n        if (onAndOffline == null) {\n            return 0;\n        }\n        return onAndOffline.sumOfEvents();\n    }\n\n    /**\n     * @param numberOfAttacker\n     * @param numberOfDefenders\n     */\n    public BattleStatistics(final int numberOfAttacker, final int numberOfDefenders) {\n        _numberOfAttacker = numberOfAttacker;\n        _numberOfDefenders = numberOfDefenders;\n    }\n\n    /**\n     * @param number\n     * @return\n     */\n    int round(final double number) {\n        return (int) Math.round(number);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#percentAbleToShoot(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int percentAbleToShoot(final CombatantSide side) {\n        double sum = 0;\n        int players = 0;\n        for (final Entry<Combatant, Counter> playerShots : shots.entrySet()) {\n            final Combatant combatant = playerShots.getKey();\n            if (isOnSide(side, combatant)) {\n                final int lifetime = combatantLifetime(combatant);\n                final int roundsShooting = playerShots.getValue().getValue();\n                sum += roundsShooting * 100.0 / lifetime;\n                players++;\n            }\n        }\n        if (players == 0) {\n            return 0;\n        }\n        return round(sum / players);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#amountOfAttackBonus(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int amountOfAttackBonus(final CombatantSide side) {\n        return attackBonuses.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#amountOfDefenseBonus(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int amountOfDefenseBonus(final CombatantSide side) {\n        return defenseBonuses.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfMovesPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double numberOfMovesPerPlayer(final CombatantSide side) {\n        double result = 0;\n        switch(side) {\n            case ATTACKER:\n                result = moves.getSideValue(side) / (double) _numberOfAttacker;\n                break;\n            case DEFENDER:\n                result = moves.getSideValue(side) / (double) _numberOfDefenders;\n                break;\n            default:\n                result = moves.getSideValue(null) / (double) (_numberOfAttacker + _numberOfDefenders);\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfOffliners(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfOffliners(final CombatantSide side) {\n        int offliner = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (counter.wasOffline()) {\n                    offliner++;\n                }\n            }\n        }\n        return offliner;\n    }\n\n    /**\n     * @param side\n     * @param combatant\n     * @return\n     */\n    private boolean isOnSide(final CombatantSide side, final Combatant combatant) {\n        return side == null || side.equals(combatant.getSide());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#roundsTillOnline(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double roundsTillOnline(final CombatantSide side) {\n        int combatants = 0;\n        int rounds = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (!counter.wasOffline()) {\n                    combatants++;\n                    rounds += counter.firstOnline();\n                }\n            }\n        }\n        // avoid division by zero\n        if (combatants == 0) {\n            return 0;\n        }\n        return ((double) rounds / (double) combatants);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#averageRoundsOnline(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageRoundsOnline(final CombatantSide side) {\n        double combatants = 0;\n        double rounds = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (!counter.wasOffline()) {\n                    combatants++;\n                    rounds += counter.onlineEvents();\n                }\n            }\n        }\n        // avoid division by zero\n        if (combatants == 0.0) {\n            return 0.0;\n        }\n        return rounds / combatants;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#hasMoved(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Area)\n     */\n    public void hasMoved(final Combatant combatant, final Area newPos) {\n        moves.incrementSide(combatant);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#newDestination(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Area)\n     */\n    public void newDestination(final Combatant combatant, final Area destination) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#aimsAt(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void aimsAt(final Combatant combatant, final Combatant target) {\n        incrementCombatantCounter(shots, combatant);\n        incrementCombatantCounter(victims, target);\n        shotRoundCounter.get(combatant.getSide()).incrementAndGet();\n        final Area field = target._getLocation();\n        getFieldStat(field).addShot();\n    }\n\n    private void incrementCombatantCounter(final Map<Combatant, Counter> combatantCounters, final Combatant combatant) {\n        if (!combatantCounters.containsKey(combatant)) {\n            combatantCounters.put(combatant, new Counter());\n        }\n        combatantCounters.get(combatant).increment();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isHit(de.outstare.fortbattleplayer.model.Combatant,\n     *      int, int)\n     */\n    public void isHit(final Combatant combatant, final int damage, final int oldHealthAmount) {\n        hitRoundCounter.get(combatant.getSide()).incrementAndGet();\n        final Area field = combatant._getLocation();\n        getFieldStat(field).addHit();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isDead(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void isDead(final Combatant combatant) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isAlive(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void isAlive(final Combatant combatant) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isOnline(de.outstare.fortbattleplayer.model.Combatant,\n     *      boolean)\n     */\n    public void isOnline(final Combatant combatant, final boolean changed) {\n        // count all events\n        if (!onliners.containsKey(combatant)) {\n            onliners.put(combatant, new OnlineCounter());\n        }\n        if (combatant.isOnline()) {\n            onliners.get(combatant).addOnline();\n        } else {\n            onliners.get(combatant).addOffline();\n        }\n        // the online event is triggered every round for a player (hopefully)\n        combatantTurn(combatant);\n    }\n\n    /**\n     * no special action, just to track the state every round\n     *\n     * @param combatant\n     */\n    private void combatantTurn(final Combatant combatant) {\n        final SectorBonus bonus = combatant.getSectorBonus();\n        attackBonuses.incrementBy(bonus.attackBonus, combatant);\n        defenseBonuses.incrementBy(bonus.defendBonus, combatant);\n        if (firstRound != null && firstRound.booleanValue()) {\n            turnOrder.add(combatant);\n        }\n        if (LOG.isLoggable(Level.FINE)) {\n            if ((firstRound == null || !firstRound.booleanValue()) && !turnOrder.contains(combatant) && currentRoundNo > 1) {\n                LOG.fine(\"---- not in order: \" + combatant);\n            }\n        }\n        actorsThisRound.incrementSide(combatant);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#targetNoOne(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public String targetNoOne(final CombatantSide side) {\n        String result = \"\";\n        int max = 0;\n        for (final Entry<Combatant, Counter> victim : victims.entrySet()) {\n            final Combatant combatant = victim.getKey();\n            if (isOnSide(side, combatant)) {\n                final int receivedShots = victim.getValue().getValue();\n                if (receivedShots > max) {\n                    max = receivedShots;\n                    result = combatant.getName() + \"(\" + receivedShots + \")\";\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfBayonets(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfBayonets(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.BayonetCounter());\n    }\n\n    /**\n     * @param side\n     * @param counter\n     * @return\n     */\n    int countWeaponMods(final CombatantSide side, final WeaponModCounter counter) {\n        // because every player should have an online/offline event, we look at\n        // the online data hoping to get all players\n        final Set<Combatant> players = onliners.keySet();\n        int bayonets = 0;\n        for (final Combatant combatant : players) {\n            if (isOnSide(side, combatant)) {\n                final Weapon playerWeapon = combatant.getWeapon();\n                // TODO let the counter count\n                if (counter.counts(playerWeapon)) {\n                    bayonets++;\n                }\n            }\n        }\n        return bayonets;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfGraphitLubricants(CombatantSide)\n     */\n    public int numberOfGraphitLubricants(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.GraphitLubricantCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfFettesOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfFettesOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.FettesOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfSchmierOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfSchmierOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.SchmierOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfShinyOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfShinyOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.ShinyOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfLoadingChamerOrEnhancedPatrons(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfLoadingChamerOrEnhancedPatrons(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.LoadingchamberOrEnhancedPatronsCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfHipFlasks(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfHipFlasks(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.HipFlaskCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#hasSwappedPosition()\n     */\n    public void hasSwappedPosition(final Combatant combatant, final Combatant swappedWith) {\n        swaps.incrementSide(combatant);\n        final PositionSwitch swap = new PositionSwitch(currentRoundNo, combatant, swappedWith);\n        assert swapList.get(combatant.getSide()) != null;\n        swapList.get(combatant.getSide()).add(swap);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#totalSwaps(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int totalSwaps(final CombatantSide side) {\n        return swaps.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#switchedPosList(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public Set<PositionSwitch> switchedPosList(final CombatantSide side) {\n        final Set<PositionSwitch> allSwaps;\n        if (side == null) {\n            allSwaps = new HashSet<PositionSwitch>();\n            for (final Set<PositionSwitch> sideSwitches : swapList.values()) {\n                allSwaps.addAll(sideSwitches);\n            }\n        } else {\n            allSwaps = swapList.get(side);\n        }\n        return allSwaps;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#criticalShot(de.outstare.fortbattleplayer.model.Combatant,\n     *      Combatant, int)\n     */\n    public void criticalShot(final Combatant combatant, final Combatant victim, final int damage) {\n        final CriticalHit crit = new CriticalHit(combatant, victim, damage, currentRoundNo);\n        critHits.get(combatant.getSide()).add(crit);\n        crits.incrementSide(combatant);\n        final Area field = victim._getLocation();\n        getFieldStat(field).addCrit();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#critList(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public List<CriticalHit> critList(final CombatantSide side) {\n        final List<CriticalHit> allCrits;\n        if (side == null) {\n            allCrits = new ArrayList<CriticalHit>();\n            for (final List<CriticalHit> sideCrits : critHits.values()) {\n                allCrits.addAll(sideCrits);\n            }\n        } else {\n            allCrits = critHits.get(side);\n        }\n        return allCrits;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#criticalHits(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int criticalHits(final CombatantSide side) {\n        return crits.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#criticalHitDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public long criticalHitDamage(final CombatantSide side) {\n        long sum = 0;\n        for (final CriticalHit crit : critList(side)) {\n            sum += crit.critOnlyDamage;\n        }\n        return sum;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#turnOrder(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public List<Combatant> turnOrder(final CombatantSide side) {\n        final List<Combatant> sidePlayers = new ArrayList<Combatant>(turnOrder.size() / 2);\n        for (final Combatant player : turnOrder) {\n            if (side == null || player.getSide() == side) {\n                sidePlayers.add(player);\n            }\n        }\n        return sidePlayers;\n    }\n\n    /**\n     * @return the number of shots per round\n     */\n    public Map<CombatantSide, ? extends LabeledData> getShotsPerRound() {\n        return shotsPerRound;\n    }\n\n    /**\n     * @return the number of hits per round\n     */\n    public Map<CombatantSide, ? extends LabeledData> getHitsPerRound() {\n        return hitsPerRound;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#getNotShootersPerRound()\n     */\n    public Map<CombatantSide, ? extends LabeledData> getNotShootersPerRound() {\n        final Map<CombatantSide, RoundStatistics> nonShootersPerRound = new HashMap<CombatantSide, RoundStatistics>();\n        for (final CombatantSide side : CombatantSide.values()) {\n            final RoundStatistics nonShooters = new RoundStatistics(\"Not shooting\", \"players\");\n            nonShootersPerRound.put(side, nonShooters);\n            final LabeledData shotRoundCounts = shotsPerRound.get(side);\n            if (shotRoundCounts != null) {\n                final double[] shotCounts = shotRoundCounts.toArray();\n                if (actorsPerRound.size() == shotCounts.length) {\n                    for (int i = 0; i < shotCounts.length; i++) {\n                        final int actors = actorsPerRound.get(i).getSideValue(side);\n                        final double numberNotShooting = actors - shotCounts[i];\n                        nonShooters.addValue(numberNotShooting);\n                    }\n                } else {\n                    LOG.warning(\"round statistics for players and shots differ!\");\n                }\n            } else {\n                LOG.warning(\"no data for players and shots for side \" + side);\n            }\n        }\n        return nonShootersPerRound;\n    }\n\n    private AreaStatistic getFieldStat(final Area area) {\n        if (!fieldStats.containsKey(area)) {\n            fieldStats.put(area, new AreaStatistic(area));\n        }\n        return fieldStats.get(area);\n    }\n\n    /**\n     * @return statistics for every field\n     */\n    public Map<Area, AreaStatistic> getFieldStatistics() {\n        return fieldStats;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/BattleStatistics_9Test.java",
		"test_prompt": "// BattleStatistics_9Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BattleStatistics}.\n* It contains ten unit test cases for the {@link BattleStatistics#numberOfGraphitLubricants(CombatantSide)} method.\n*/\nclass BattleStatistics_9Test {"
	},
	{
		"original_code": "// BattleStatistics.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\n\n/**\n * @author daniel\n */\npublic class BattleStatistics implements DynamicStatistics, CombatantObserver {\n\n    private static final transient Logger LOG = Logger.getLogger(BattleStatistics.class.getName());\n\n    private final Map<Combatant, OnlineCounter> onliners = new HashMap<Combatant, OnlineCounter>();\n\n    private final Map<CombatantSide, List<CriticalHit>> critHits = new HashMap<CombatantSide, List<CriticalHit>>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            critHits.put(side, new ArrayList<CriticalHit>());\n        }\n    }\n\n    private final Map<CombatantSide, Set<PositionSwitch>> swapList = new HashMap<CombatantSide, Set<PositionSwitch>>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            swapList.put(side, new HashSet<PositionSwitch>());\n        }\n    }\n\n    private final AllCombatantSidesCounter crits = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter moves = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter swaps = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter attackBonuses = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter defenseBonuses = new AllCombatantSidesCounter();\n\n    private final Map<Combatant, Counter> shots = new HashMap<Combatant, Counter>();\n\n    private final Map<CombatantSide, RoundStatistics> shotsPerRound = new HashMap<CombatantSide, RoundStatistics>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            shotsPerRound.put(side, new RoundStatistics(\"shots\", \"shots\"));\n        }\n    }\n\n    private final Map<CombatantSide, RoundStatistics> hitsPerRound = new HashMap<CombatantSide, RoundStatistics>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            hitsPerRound.put(side, new RoundStatistics(\"hits\", \"hits\"));\n        }\n    }\n\n    private final Map<CombatantSide, AtomicInteger> shotRoundCounter = new HashMap<CombatantSide, AtomicInteger>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            shotRoundCounter.put(side, new AtomicInteger());\n        }\n    }\n\n    private final Map<CombatantSide, AtomicInteger> hitRoundCounter = new HashMap<CombatantSide, AtomicInteger>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            hitRoundCounter.put(side, new AtomicInteger());\n        }\n    }\n\n    private final Map<Combatant, Counter> victims = new HashMap<Combatant, Counter>();\n\n    private final List<Combatant> turnOrder = new LinkedList<Combatant>();\n\n    private final List<AllCombatantSidesCounter> actorsPerRound = new ArrayList<AllCombatantSidesCounter>(50);\n\n    private final Map<Area, AreaStatistic> fieldStats = new HashMap<Area, AreaStatistic>();\n\n    private final int _numberOfDefenders;\n\n    private final int _numberOfAttacker;\n\n    private int currentRoundNo = 0;\n\n    private Boolean firstRound = null;\n\n    private AllCombatantSidesCounter actorsThisRound = new AllCombatantSidesCounter();\n\n    /**\n     * set the current round. all following method calls will belong to this\n     * round till this method is called again with another parameter.\n     *\n     * @param no\n     */\n    public void setRound(final int no) {\n        if (firstRound == null) {\n            firstRound = Boolean.TRUE;\n        } else if (firstRound.booleanValue()) {\n            firstRound = Boolean.FALSE;\n            // the turn order is determined only in the first round\n            for (final Combatant player : onliners.keySet()) {\n                if (!turnOrder.contains(player)) {\n                    LOG.info(\"could not determine turn order for \" + player);\n                }\n            }\n        }\n        addAndResetRoundCounter(shotRoundCounter, shotsPerRound);\n        addAndResetRoundCounter(hitRoundCounter, hitsPerRound);\n        actorsPerRound.add(actorsThisRound);\n        actorsThisRound = new AllCombatantSidesCounter();\n        currentRoundNo = no;\n    }\n\n    /**\n     * this adds the counters for the last round to the total counts per round\n     * and resets the given counter\n     *\n     * @param roundCounter\n     * @param allRounds\n     */\n    void addAndResetRoundCounter(final Map<CombatantSide, AtomicInteger> roundCounter, final Map<CombatantSide, RoundStatistics> allRounds) {\n        for (final Entry<CombatantSide, AtomicInteger> mapping : roundCounter.entrySet()) {\n            final CombatantSide side = mapping.getKey();\n            final AtomicInteger roundShots = mapping.getValue();\n            allRounds.get(side).addValue(roundShots.get());\n            // reset for next round\n            roundShots.set(0);\n        }\n    }\n\n    /**\n     * @param combatant\n     * @return\n     */\n    int combatantLifetime(final Combatant combatant) {\n        final OnlineCounter onAndOffline = onliners.get(combatant);\n        if (onAndOffline == null) {\n            return 0;\n        }\n        return onAndOffline.sumOfEvents();\n    }\n\n    /**\n     * @param numberOfAttacker\n     * @param numberOfDefenders\n     */\n    public BattleStatistics(final int numberOfAttacker, final int numberOfDefenders) {\n        _numberOfAttacker = numberOfAttacker;\n        _numberOfDefenders = numberOfDefenders;\n    }\n\n    /**\n     * @param number\n     * @return\n     */\n    int round(final double number) {\n        return (int) Math.round(number);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#percentAbleToShoot(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int percentAbleToShoot(final CombatantSide side) {\n        double sum = 0;\n        int players = 0;\n        for (final Entry<Combatant, Counter> playerShots : shots.entrySet()) {\n            final Combatant combatant = playerShots.getKey();\n            if (isOnSide(side, combatant)) {\n                final int lifetime = combatantLifetime(combatant);\n                final int roundsShooting = playerShots.getValue().getValue();\n                sum += roundsShooting * 100.0 / lifetime;\n                players++;\n            }\n        }\n        if (players == 0) {\n            return 0;\n        }\n        return round(sum / players);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#amountOfAttackBonus(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int amountOfAttackBonus(final CombatantSide side) {\n        return attackBonuses.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#amountOfDefenseBonus(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int amountOfDefenseBonus(final CombatantSide side) {\n        return defenseBonuses.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfMovesPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double numberOfMovesPerPlayer(final CombatantSide side) {\n        double result = 0;\n        switch(side) {\n            case ATTACKER:\n                result = moves.getSideValue(side) / (double) _numberOfAttacker;\n                break;\n            case DEFENDER:\n                result = moves.getSideValue(side) / (double) _numberOfDefenders;\n                break;\n            default:\n                result = moves.getSideValue(null) / (double) (_numberOfAttacker + _numberOfDefenders);\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfOffliners(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfOffliners(final CombatantSide side) {\n        int offliner = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (counter.wasOffline()) {\n                    offliner++;\n                }\n            }\n        }\n        return offliner;\n    }\n\n    /**\n     * @param side\n     * @param combatant\n     * @return\n     */\n    private boolean isOnSide(final CombatantSide side, final Combatant combatant) {\n        return side == null || side.equals(combatant.getSide());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#roundsTillOnline(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double roundsTillOnline(final CombatantSide side) {\n        int combatants = 0;\n        int rounds = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (!counter.wasOffline()) {\n                    combatants++;\n                    rounds += counter.firstOnline();\n                }\n            }\n        }\n        // avoid division by zero\n        if (combatants == 0) {\n            return 0;\n        }\n        return ((double) rounds / (double) combatants);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#averageRoundsOnline(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageRoundsOnline(final CombatantSide side) {\n        double combatants = 0;\n        double rounds = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (!counter.wasOffline()) {\n                    combatants++;\n                    rounds += counter.onlineEvents();\n                }\n            }\n        }\n        // avoid division by zero\n        if (combatants == 0.0) {\n            return 0.0;\n        }\n        return rounds / combatants;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#hasMoved(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Area)\n     */\n    public void hasMoved(final Combatant combatant, final Area newPos) {\n        moves.incrementSide(combatant);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#newDestination(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Area)\n     */\n    public void newDestination(final Combatant combatant, final Area destination) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#aimsAt(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void aimsAt(final Combatant combatant, final Combatant target) {\n        incrementCombatantCounter(shots, combatant);\n        incrementCombatantCounter(victims, target);\n        shotRoundCounter.get(combatant.getSide()).incrementAndGet();\n        final Area field = target._getLocation();\n        getFieldStat(field).addShot();\n    }\n\n    private void incrementCombatantCounter(final Map<Combatant, Counter> combatantCounters, final Combatant combatant) {\n        if (!combatantCounters.containsKey(combatant)) {\n            combatantCounters.put(combatant, new Counter());\n        }\n        combatantCounters.get(combatant).increment();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isHit(de.outstare.fortbattleplayer.model.Combatant,\n     *      int, int)\n     */\n    public void isHit(final Combatant combatant, final int damage, final int oldHealthAmount) {\n        hitRoundCounter.get(combatant.getSide()).incrementAndGet();\n        final Area field = combatant._getLocation();\n        getFieldStat(field).addHit();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isDead(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void isDead(final Combatant combatant) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isAlive(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void isAlive(final Combatant combatant) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isOnline(de.outstare.fortbattleplayer.model.Combatant,\n     *      boolean)\n     */\n    public void isOnline(final Combatant combatant, final boolean changed) {\n        // count all events\n        if (!onliners.containsKey(combatant)) {\n            onliners.put(combatant, new OnlineCounter());\n        }\n        if (combatant.isOnline()) {\n            onliners.get(combatant).addOnline();\n        } else {\n            onliners.get(combatant).addOffline();\n        }\n        // the online event is triggered every round for a player (hopefully)\n        combatantTurn(combatant);\n    }\n\n    /**\n     * no special action, just to track the state every round\n     *\n     * @param combatant\n     */\n    private void combatantTurn(final Combatant combatant) {\n        final SectorBonus bonus = combatant.getSectorBonus();\n        attackBonuses.incrementBy(bonus.attackBonus, combatant);\n        defenseBonuses.incrementBy(bonus.defendBonus, combatant);\n        if (firstRound != null && firstRound.booleanValue()) {\n            turnOrder.add(combatant);\n        }\n        if (LOG.isLoggable(Level.FINE)) {\n            if ((firstRound == null || !firstRound.booleanValue()) && !turnOrder.contains(combatant) && currentRoundNo > 1) {\n                LOG.fine(\"---- not in order: \" + combatant);\n            }\n        }\n        actorsThisRound.incrementSide(combatant);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#targetNoOne(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public String targetNoOne(final CombatantSide side) {\n        String result = \"\";\n        int max = 0;\n        for (final Entry<Combatant, Counter> victim : victims.entrySet()) {\n            final Combatant combatant = victim.getKey();\n            if (isOnSide(side, combatant)) {\n                final int receivedShots = victim.getValue().getValue();\n                if (receivedShots > max) {\n                    max = receivedShots;\n                    result = combatant.getName() + \"(\" + receivedShots + \")\";\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfBayonets(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfBayonets(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.BayonetCounter());\n    }\n\n    /**\n     * @param side\n     * @param counter\n     * @return\n     */\n    int countWeaponMods(final CombatantSide side, final WeaponModCounter counter) {\n        // because every player should have an online/offline event, we look at\n        // the online data hoping to get all players\n        final Set<Combatant> players = onliners.keySet();\n        int bayonets = 0;\n        for (final Combatant combatant : players) {\n            if (isOnSide(side, combatant)) {\n                final Weapon playerWeapon = combatant.getWeapon();\n                // TODO let the counter count\n                if (counter.counts(playerWeapon)) {\n                    bayonets++;\n                }\n            }\n        }\n        return bayonets;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfGraphitLubricants(CombatantSide)\n     */\n    public int numberOfGraphitLubricants(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.GraphitLubricantCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfFettesOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfFettesOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.FettesOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfSchmierOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfSchmierOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.SchmierOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfShinyOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfShinyOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.ShinyOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfLoadingChamerOrEnhancedPatrons(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfLoadingChamerOrEnhancedPatrons(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.LoadingchamberOrEnhancedPatronsCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfHipFlasks(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfHipFlasks(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.HipFlaskCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#hasSwappedPosition()\n     */\n    public void hasSwappedPosition(final Combatant combatant, final Combatant swappedWith) {\n        swaps.incrementSide(combatant);\n        final PositionSwitch swap = new PositionSwitch(currentRoundNo, combatant, swappedWith);\n        assert swapList.get(combatant.getSide()) != null;\n        swapList.get(combatant.getSide()).add(swap);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#totalSwaps(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int totalSwaps(final CombatantSide side) {\n        return swaps.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#switchedPosList(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public Set<PositionSwitch> switchedPosList(final CombatantSide side) {\n        final Set<PositionSwitch> allSwaps;\n        if (side == null) {\n            allSwaps = new HashSet<PositionSwitch>();\n            for (final Set<PositionSwitch> sideSwitches : swapList.values()) {\n                allSwaps.addAll(sideSwitches);\n            }\n        } else {\n            allSwaps = swapList.get(side);\n        }\n        return allSwaps;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#criticalShot(de.outstare.fortbattleplayer.model.Combatant,\n     *      Combatant, int)\n     */\n    public void criticalShot(final Combatant combatant, final Combatant victim, final int damage) {\n        final CriticalHit crit = new CriticalHit(combatant, victim, damage, currentRoundNo);\n        critHits.get(combatant.getSide()).add(crit);\n        crits.incrementSide(combatant);\n        final Area field = victim._getLocation();\n        getFieldStat(field).addCrit();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#critList(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public List<CriticalHit> critList(final CombatantSide side) {\n        final List<CriticalHit> allCrits;\n        if (side == null) {\n            allCrits = new ArrayList<CriticalHit>();\n            for (final List<CriticalHit> sideCrits : critHits.values()) {\n                allCrits.addAll(sideCrits);\n            }\n        } else {\n            allCrits = critHits.get(side);\n        }\n        return allCrits;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#criticalHits(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int criticalHits(final CombatantSide side) {\n        return crits.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#criticalHitDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public long criticalHitDamage(final CombatantSide side) {\n        long sum = 0;\n        for (final CriticalHit crit : critList(side)) {\n            sum += crit.critOnlyDamage;\n        }\n        return sum;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#turnOrder(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public List<Combatant> turnOrder(final CombatantSide side) {\n        final List<Combatant> sidePlayers = new ArrayList<Combatant>(turnOrder.size() / 2);\n        for (final Combatant player : turnOrder) {\n            if (side == null || player.getSide() == side) {\n                sidePlayers.add(player);\n            }\n        }\n        return sidePlayers;\n    }\n\n    /**\n     * @return the number of shots per round\n     */\n    public Map<CombatantSide, ? extends LabeledData> getShotsPerRound() {\n        return shotsPerRound;\n    }\n\n    /**\n     * @return the number of hits per round\n     */\n    public Map<CombatantSide, ? extends LabeledData> getHitsPerRound() {\n        return hitsPerRound;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#getNotShootersPerRound()\n     */\n    public Map<CombatantSide, ? extends LabeledData> getNotShootersPerRound() {\n        final Map<CombatantSide, RoundStatistics> nonShootersPerRound = new HashMap<CombatantSide, RoundStatistics>();\n        for (final CombatantSide side : CombatantSide.values()) {\n            final RoundStatistics nonShooters = new RoundStatistics(\"Not shooting\", \"players\");\n            nonShootersPerRound.put(side, nonShooters);\n            final LabeledData shotRoundCounts = shotsPerRound.get(side);\n            if (shotRoundCounts != null) {\n                final double[] shotCounts = shotRoundCounts.toArray();\n                if (actorsPerRound.size() == shotCounts.length) {\n                    for (int i = 0; i < shotCounts.length; i++) {\n                        final int actors = actorsPerRound.get(i).getSideValue(side);\n                        final double numberNotShooting = actors - shotCounts[i];\n                        nonShooters.addValue(numberNotShooting);\n                    }\n                } else {\n                    LOG.warning(\"round statistics for players and shots differ!\");\n                }\n            } else {\n                LOG.warning(\"no data for players and shots for side \" + side);\n            }\n        }\n        return nonShootersPerRound;\n    }\n\n    private AreaStatistic getFieldStat(final Area area) {\n        if (!fieldStats.containsKey(area)) {\n            fieldStats.put(area, new AreaStatistic(area));\n        }\n        return fieldStats.get(area);\n    }\n\n    /**\n     * @return statistics for every field\n     */\n    public Map<Area, AreaStatistic> getFieldStatistics() {\n        return fieldStats;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/BattleStatistics_10Test.java",
		"test_prompt": "// BattleStatistics_10Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BattleStatistics}.\n* It contains ten unit test cases for the {@link BattleStatistics#numberOfFettesOil(CombatantSide)} method.\n*/\nclass BattleStatistics_10Test {"
	},
	{
		"original_code": "// BattleStatistics.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\n\n/**\n * @author daniel\n */\npublic class BattleStatistics implements DynamicStatistics, CombatantObserver {\n\n    private static final transient Logger LOG = Logger.getLogger(BattleStatistics.class.getName());\n\n    private final Map<Combatant, OnlineCounter> onliners = new HashMap<Combatant, OnlineCounter>();\n\n    private final Map<CombatantSide, List<CriticalHit>> critHits = new HashMap<CombatantSide, List<CriticalHit>>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            critHits.put(side, new ArrayList<CriticalHit>());\n        }\n    }\n\n    private final Map<CombatantSide, Set<PositionSwitch>> swapList = new HashMap<CombatantSide, Set<PositionSwitch>>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            swapList.put(side, new HashSet<PositionSwitch>());\n        }\n    }\n\n    private final AllCombatantSidesCounter crits = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter moves = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter swaps = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter attackBonuses = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter defenseBonuses = new AllCombatantSidesCounter();\n\n    private final Map<Combatant, Counter> shots = new HashMap<Combatant, Counter>();\n\n    private final Map<CombatantSide, RoundStatistics> shotsPerRound = new HashMap<CombatantSide, RoundStatistics>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            shotsPerRound.put(side, new RoundStatistics(\"shots\", \"shots\"));\n        }\n    }\n\n    private final Map<CombatantSide, RoundStatistics> hitsPerRound = new HashMap<CombatantSide, RoundStatistics>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            hitsPerRound.put(side, new RoundStatistics(\"hits\", \"hits\"));\n        }\n    }\n\n    private final Map<CombatantSide, AtomicInteger> shotRoundCounter = new HashMap<CombatantSide, AtomicInteger>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            shotRoundCounter.put(side, new AtomicInteger());\n        }\n    }\n\n    private final Map<CombatantSide, AtomicInteger> hitRoundCounter = new HashMap<CombatantSide, AtomicInteger>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            hitRoundCounter.put(side, new AtomicInteger());\n        }\n    }\n\n    private final Map<Combatant, Counter> victims = new HashMap<Combatant, Counter>();\n\n    private final List<Combatant> turnOrder = new LinkedList<Combatant>();\n\n    private final List<AllCombatantSidesCounter> actorsPerRound = new ArrayList<AllCombatantSidesCounter>(50);\n\n    private final Map<Area, AreaStatistic> fieldStats = new HashMap<Area, AreaStatistic>();\n\n    private final int _numberOfDefenders;\n\n    private final int _numberOfAttacker;\n\n    private int currentRoundNo = 0;\n\n    private Boolean firstRound = null;\n\n    private AllCombatantSidesCounter actorsThisRound = new AllCombatantSidesCounter();\n\n    /**\n     * set the current round. all following method calls will belong to this\n     * round till this method is called again with another parameter.\n     *\n     * @param no\n     */\n    public void setRound(final int no) {\n        if (firstRound == null) {\n            firstRound = Boolean.TRUE;\n        } else if (firstRound.booleanValue()) {\n            firstRound = Boolean.FALSE;\n            // the turn order is determined only in the first round\n            for (final Combatant player : onliners.keySet()) {\n                if (!turnOrder.contains(player)) {\n                    LOG.info(\"could not determine turn order for \" + player);\n                }\n            }\n        }\n        addAndResetRoundCounter(shotRoundCounter, shotsPerRound);\n        addAndResetRoundCounter(hitRoundCounter, hitsPerRound);\n        actorsPerRound.add(actorsThisRound);\n        actorsThisRound = new AllCombatantSidesCounter();\n        currentRoundNo = no;\n    }\n\n    /**\n     * this adds the counters for the last round to the total counts per round\n     * and resets the given counter\n     *\n     * @param roundCounter\n     * @param allRounds\n     */\n    void addAndResetRoundCounter(final Map<CombatantSide, AtomicInteger> roundCounter, final Map<CombatantSide, RoundStatistics> allRounds) {\n        for (final Entry<CombatantSide, AtomicInteger> mapping : roundCounter.entrySet()) {\n            final CombatantSide side = mapping.getKey();\n            final AtomicInteger roundShots = mapping.getValue();\n            allRounds.get(side).addValue(roundShots.get());\n            // reset for next round\n            roundShots.set(0);\n        }\n    }\n\n    /**\n     * @param combatant\n     * @return\n     */\n    int combatantLifetime(final Combatant combatant) {\n        final OnlineCounter onAndOffline = onliners.get(combatant);\n        if (onAndOffline == null) {\n            return 0;\n        }\n        return onAndOffline.sumOfEvents();\n    }\n\n    /**\n     * @param numberOfAttacker\n     * @param numberOfDefenders\n     */\n    public BattleStatistics(final int numberOfAttacker, final int numberOfDefenders) {\n        _numberOfAttacker = numberOfAttacker;\n        _numberOfDefenders = numberOfDefenders;\n    }\n\n    /**\n     * @param number\n     * @return\n     */\n    int round(final double number) {\n        return (int) Math.round(number);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#percentAbleToShoot(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int percentAbleToShoot(final CombatantSide side) {\n        double sum = 0;\n        int players = 0;\n        for (final Entry<Combatant, Counter> playerShots : shots.entrySet()) {\n            final Combatant combatant = playerShots.getKey();\n            if (isOnSide(side, combatant)) {\n                final int lifetime = combatantLifetime(combatant);\n                final int roundsShooting = playerShots.getValue().getValue();\n                sum += roundsShooting * 100.0 / lifetime;\n                players++;\n            }\n        }\n        if (players == 0) {\n            return 0;\n        }\n        return round(sum / players);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#amountOfAttackBonus(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int amountOfAttackBonus(final CombatantSide side) {\n        return attackBonuses.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#amountOfDefenseBonus(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int amountOfDefenseBonus(final CombatantSide side) {\n        return defenseBonuses.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfMovesPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double numberOfMovesPerPlayer(final CombatantSide side) {\n        double result = 0;\n        switch(side) {\n            case ATTACKER:\n                result = moves.getSideValue(side) / (double) _numberOfAttacker;\n                break;\n            case DEFENDER:\n                result = moves.getSideValue(side) / (double) _numberOfDefenders;\n                break;\n            default:\n                result = moves.getSideValue(null) / (double) (_numberOfAttacker + _numberOfDefenders);\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfOffliners(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfOffliners(final CombatantSide side) {\n        int offliner = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (counter.wasOffline()) {\n                    offliner++;\n                }\n            }\n        }\n        return offliner;\n    }\n\n    /**\n     * @param side\n     * @param combatant\n     * @return\n     */\n    private boolean isOnSide(final CombatantSide side, final Combatant combatant) {\n        return side == null || side.equals(combatant.getSide());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#roundsTillOnline(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double roundsTillOnline(final CombatantSide side) {\n        int combatants = 0;\n        int rounds = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (!counter.wasOffline()) {\n                    combatants++;\n                    rounds += counter.firstOnline();\n                }\n            }\n        }\n        // avoid division by zero\n        if (combatants == 0) {\n            return 0;\n        }\n        return ((double) rounds / (double) combatants);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#averageRoundsOnline(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageRoundsOnline(final CombatantSide side) {\n        double combatants = 0;\n        double rounds = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (!counter.wasOffline()) {\n                    combatants++;\n                    rounds += counter.onlineEvents();\n                }\n            }\n        }\n        // avoid division by zero\n        if (combatants == 0.0) {\n            return 0.0;\n        }\n        return rounds / combatants;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#hasMoved(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Area)\n     */\n    public void hasMoved(final Combatant combatant, final Area newPos) {\n        moves.incrementSide(combatant);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#newDestination(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Area)\n     */\n    public void newDestination(final Combatant combatant, final Area destination) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#aimsAt(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void aimsAt(final Combatant combatant, final Combatant target) {\n        incrementCombatantCounter(shots, combatant);\n        incrementCombatantCounter(victims, target);\n        shotRoundCounter.get(combatant.getSide()).incrementAndGet();\n        final Area field = target._getLocation();\n        getFieldStat(field).addShot();\n    }\n\n    private void incrementCombatantCounter(final Map<Combatant, Counter> combatantCounters, final Combatant combatant) {\n        if (!combatantCounters.containsKey(combatant)) {\n            combatantCounters.put(combatant, new Counter());\n        }\n        combatantCounters.get(combatant).increment();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isHit(de.outstare.fortbattleplayer.model.Combatant,\n     *      int, int)\n     */\n    public void isHit(final Combatant combatant, final int damage, final int oldHealthAmount) {\n        hitRoundCounter.get(combatant.getSide()).incrementAndGet();\n        final Area field = combatant._getLocation();\n        getFieldStat(field).addHit();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isDead(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void isDead(final Combatant combatant) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isAlive(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void isAlive(final Combatant combatant) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isOnline(de.outstare.fortbattleplayer.model.Combatant,\n     *      boolean)\n     */\n    public void isOnline(final Combatant combatant, final boolean changed) {\n        // count all events\n        if (!onliners.containsKey(combatant)) {\n            onliners.put(combatant, new OnlineCounter());\n        }\n        if (combatant.isOnline()) {\n            onliners.get(combatant).addOnline();\n        } else {\n            onliners.get(combatant).addOffline();\n        }\n        // the online event is triggered every round for a player (hopefully)\n        combatantTurn(combatant);\n    }\n\n    /**\n     * no special action, just to track the state every round\n     *\n     * @param combatant\n     */\n    private void combatantTurn(final Combatant combatant) {\n        final SectorBonus bonus = combatant.getSectorBonus();\n        attackBonuses.incrementBy(bonus.attackBonus, combatant);\n        defenseBonuses.incrementBy(bonus.defendBonus, combatant);\n        if (firstRound != null && firstRound.booleanValue()) {\n            turnOrder.add(combatant);\n        }\n        if (LOG.isLoggable(Level.FINE)) {\n            if ((firstRound == null || !firstRound.booleanValue()) && !turnOrder.contains(combatant) && currentRoundNo > 1) {\n                LOG.fine(\"---- not in order: \" + combatant);\n            }\n        }\n        actorsThisRound.incrementSide(combatant);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#targetNoOne(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public String targetNoOne(final CombatantSide side) {\n        String result = \"\";\n        int max = 0;\n        for (final Entry<Combatant, Counter> victim : victims.entrySet()) {\n            final Combatant combatant = victim.getKey();\n            if (isOnSide(side, combatant)) {\n                final int receivedShots = victim.getValue().getValue();\n                if (receivedShots > max) {\n                    max = receivedShots;\n                    result = combatant.getName() + \"(\" + receivedShots + \")\";\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfBayonets(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfBayonets(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.BayonetCounter());\n    }\n\n    /**\n     * @param side\n     * @param counter\n     * @return\n     */\n    int countWeaponMods(final CombatantSide side, final WeaponModCounter counter) {\n        // because every player should have an online/offline event, we look at\n        // the online data hoping to get all players\n        final Set<Combatant> players = onliners.keySet();\n        int bayonets = 0;\n        for (final Combatant combatant : players) {\n            if (isOnSide(side, combatant)) {\n                final Weapon playerWeapon = combatant.getWeapon();\n                // TODO let the counter count\n                if (counter.counts(playerWeapon)) {\n                    bayonets++;\n                }\n            }\n        }\n        return bayonets;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfGraphitLubricants(CombatantSide)\n     */\n    public int numberOfGraphitLubricants(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.GraphitLubricantCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfFettesOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfFettesOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.FettesOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfSchmierOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfSchmierOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.SchmierOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfShinyOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfShinyOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.ShinyOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfLoadingChamerOrEnhancedPatrons(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfLoadingChamerOrEnhancedPatrons(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.LoadingchamberOrEnhancedPatronsCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfHipFlasks(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfHipFlasks(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.HipFlaskCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#hasSwappedPosition()\n     */\n    public void hasSwappedPosition(final Combatant combatant, final Combatant swappedWith) {\n        swaps.incrementSide(combatant);\n        final PositionSwitch swap = new PositionSwitch(currentRoundNo, combatant, swappedWith);\n        assert swapList.get(combatant.getSide()) != null;\n        swapList.get(combatant.getSide()).add(swap);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#totalSwaps(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int totalSwaps(final CombatantSide side) {\n        return swaps.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#switchedPosList(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public Set<PositionSwitch> switchedPosList(final CombatantSide side) {\n        final Set<PositionSwitch> allSwaps;\n        if (side == null) {\n            allSwaps = new HashSet<PositionSwitch>();\n            for (final Set<PositionSwitch> sideSwitches : swapList.values()) {\n                allSwaps.addAll(sideSwitches);\n            }\n        } else {\n            allSwaps = swapList.get(side);\n        }\n        return allSwaps;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#criticalShot(de.outstare.fortbattleplayer.model.Combatant,\n     *      Combatant, int)\n     */\n    public void criticalShot(final Combatant combatant, final Combatant victim, final int damage) {\n        final CriticalHit crit = new CriticalHit(combatant, victim, damage, currentRoundNo);\n        critHits.get(combatant.getSide()).add(crit);\n        crits.incrementSide(combatant);\n        final Area field = victim._getLocation();\n        getFieldStat(field).addCrit();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#critList(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public List<CriticalHit> critList(final CombatantSide side) {\n        final List<CriticalHit> allCrits;\n        if (side == null) {\n            allCrits = new ArrayList<CriticalHit>();\n            for (final List<CriticalHit> sideCrits : critHits.values()) {\n                allCrits.addAll(sideCrits);\n            }\n        } else {\n            allCrits = critHits.get(side);\n        }\n        return allCrits;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#criticalHits(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int criticalHits(final CombatantSide side) {\n        return crits.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#criticalHitDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public long criticalHitDamage(final CombatantSide side) {\n        long sum = 0;\n        for (final CriticalHit crit : critList(side)) {\n            sum += crit.critOnlyDamage;\n        }\n        return sum;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#turnOrder(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public List<Combatant> turnOrder(final CombatantSide side) {\n        final List<Combatant> sidePlayers = new ArrayList<Combatant>(turnOrder.size() / 2);\n        for (final Combatant player : turnOrder) {\n            if (side == null || player.getSide() == side) {\n                sidePlayers.add(player);\n            }\n        }\n        return sidePlayers;\n    }\n\n    /**\n     * @return the number of shots per round\n     */\n    public Map<CombatantSide, ? extends LabeledData> getShotsPerRound() {\n        return shotsPerRound;\n    }\n\n    /**\n     * @return the number of hits per round\n     */\n    public Map<CombatantSide, ? extends LabeledData> getHitsPerRound() {\n        return hitsPerRound;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#getNotShootersPerRound()\n     */\n    public Map<CombatantSide, ? extends LabeledData> getNotShootersPerRound() {\n        final Map<CombatantSide, RoundStatistics> nonShootersPerRound = new HashMap<CombatantSide, RoundStatistics>();\n        for (final CombatantSide side : CombatantSide.values()) {\n            final RoundStatistics nonShooters = new RoundStatistics(\"Not shooting\", \"players\");\n            nonShootersPerRound.put(side, nonShooters);\n            final LabeledData shotRoundCounts = shotsPerRound.get(side);\n            if (shotRoundCounts != null) {\n                final double[] shotCounts = shotRoundCounts.toArray();\n                if (actorsPerRound.size() == shotCounts.length) {\n                    for (int i = 0; i < shotCounts.length; i++) {\n                        final int actors = actorsPerRound.get(i).getSideValue(side);\n                        final double numberNotShooting = actors - shotCounts[i];\n                        nonShooters.addValue(numberNotShooting);\n                    }\n                } else {\n                    LOG.warning(\"round statistics for players and shots differ!\");\n                }\n            } else {\n                LOG.warning(\"no data for players and shots for side \" + side);\n            }\n        }\n        return nonShootersPerRound;\n    }\n\n    private AreaStatistic getFieldStat(final Area area) {\n        if (!fieldStats.containsKey(area)) {\n            fieldStats.put(area, new AreaStatistic(area));\n        }\n        return fieldStats.get(area);\n    }\n\n    /**\n     * @return statistics for every field\n     */\n    public Map<Area, AreaStatistic> getFieldStatistics() {\n        return fieldStats;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/BattleStatistics_11Test.java",
		"test_prompt": "// BattleStatistics_11Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BattleStatistics}.\n* It contains ten unit test cases for the {@link BattleStatistics#numberOfSchmierOil(CombatantSide)} method.\n*/\nclass BattleStatistics_11Test {"
	},
	{
		"original_code": "// BattleStatistics.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\n\n/**\n * @author daniel\n */\npublic class BattleStatistics implements DynamicStatistics, CombatantObserver {\n\n    private static final transient Logger LOG = Logger.getLogger(BattleStatistics.class.getName());\n\n    private final Map<Combatant, OnlineCounter> onliners = new HashMap<Combatant, OnlineCounter>();\n\n    private final Map<CombatantSide, List<CriticalHit>> critHits = new HashMap<CombatantSide, List<CriticalHit>>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            critHits.put(side, new ArrayList<CriticalHit>());\n        }\n    }\n\n    private final Map<CombatantSide, Set<PositionSwitch>> swapList = new HashMap<CombatantSide, Set<PositionSwitch>>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            swapList.put(side, new HashSet<PositionSwitch>());\n        }\n    }\n\n    private final AllCombatantSidesCounter crits = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter moves = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter swaps = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter attackBonuses = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter defenseBonuses = new AllCombatantSidesCounter();\n\n    private final Map<Combatant, Counter> shots = new HashMap<Combatant, Counter>();\n\n    private final Map<CombatantSide, RoundStatistics> shotsPerRound = new HashMap<CombatantSide, RoundStatistics>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            shotsPerRound.put(side, new RoundStatistics(\"shots\", \"shots\"));\n        }\n    }\n\n    private final Map<CombatantSide, RoundStatistics> hitsPerRound = new HashMap<CombatantSide, RoundStatistics>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            hitsPerRound.put(side, new RoundStatistics(\"hits\", \"hits\"));\n        }\n    }\n\n    private final Map<CombatantSide, AtomicInteger> shotRoundCounter = new HashMap<CombatantSide, AtomicInteger>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            shotRoundCounter.put(side, new AtomicInteger());\n        }\n    }\n\n    private final Map<CombatantSide, AtomicInteger> hitRoundCounter = new HashMap<CombatantSide, AtomicInteger>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            hitRoundCounter.put(side, new AtomicInteger());\n        }\n    }\n\n    private final Map<Combatant, Counter> victims = new HashMap<Combatant, Counter>();\n\n    private final List<Combatant> turnOrder = new LinkedList<Combatant>();\n\n    private final List<AllCombatantSidesCounter> actorsPerRound = new ArrayList<AllCombatantSidesCounter>(50);\n\n    private final Map<Area, AreaStatistic> fieldStats = new HashMap<Area, AreaStatistic>();\n\n    private final int _numberOfDefenders;\n\n    private final int _numberOfAttacker;\n\n    private int currentRoundNo = 0;\n\n    private Boolean firstRound = null;\n\n    private AllCombatantSidesCounter actorsThisRound = new AllCombatantSidesCounter();\n\n    /**\n     * set the current round. all following method calls will belong to this\n     * round till this method is called again with another parameter.\n     *\n     * @param no\n     */\n    public void setRound(final int no) {\n        if (firstRound == null) {\n            firstRound = Boolean.TRUE;\n        } else if (firstRound.booleanValue()) {\n            firstRound = Boolean.FALSE;\n            // the turn order is determined only in the first round\n            for (final Combatant player : onliners.keySet()) {\n                if (!turnOrder.contains(player)) {\n                    LOG.info(\"could not determine turn order for \" + player);\n                }\n            }\n        }\n        addAndResetRoundCounter(shotRoundCounter, shotsPerRound);\n        addAndResetRoundCounter(hitRoundCounter, hitsPerRound);\n        actorsPerRound.add(actorsThisRound);\n        actorsThisRound = new AllCombatantSidesCounter();\n        currentRoundNo = no;\n    }\n\n    /**\n     * this adds the counters for the last round to the total counts per round\n     * and resets the given counter\n     *\n     * @param roundCounter\n     * @param allRounds\n     */\n    void addAndResetRoundCounter(final Map<CombatantSide, AtomicInteger> roundCounter, final Map<CombatantSide, RoundStatistics> allRounds) {\n        for (final Entry<CombatantSide, AtomicInteger> mapping : roundCounter.entrySet()) {\n            final CombatantSide side = mapping.getKey();\n            final AtomicInteger roundShots = mapping.getValue();\n            allRounds.get(side).addValue(roundShots.get());\n            // reset for next round\n            roundShots.set(0);\n        }\n    }\n\n    /**\n     * @param combatant\n     * @return\n     */\n    int combatantLifetime(final Combatant combatant) {\n        final OnlineCounter onAndOffline = onliners.get(combatant);\n        if (onAndOffline == null) {\n            return 0;\n        }\n        return onAndOffline.sumOfEvents();\n    }\n\n    /**\n     * @param numberOfAttacker\n     * @param numberOfDefenders\n     */\n    public BattleStatistics(final int numberOfAttacker, final int numberOfDefenders) {\n        _numberOfAttacker = numberOfAttacker;\n        _numberOfDefenders = numberOfDefenders;\n    }\n\n    /**\n     * @param number\n     * @return\n     */\n    int round(final double number) {\n        return (int) Math.round(number);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#percentAbleToShoot(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int percentAbleToShoot(final CombatantSide side) {\n        double sum = 0;\n        int players = 0;\n        for (final Entry<Combatant, Counter> playerShots : shots.entrySet()) {\n            final Combatant combatant = playerShots.getKey();\n            if (isOnSide(side, combatant)) {\n                final int lifetime = combatantLifetime(combatant);\n                final int roundsShooting = playerShots.getValue().getValue();\n                sum += roundsShooting * 100.0 / lifetime;\n                players++;\n            }\n        }\n        if (players == 0) {\n            return 0;\n        }\n        return round(sum / players);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#amountOfAttackBonus(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int amountOfAttackBonus(final CombatantSide side) {\n        return attackBonuses.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#amountOfDefenseBonus(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int amountOfDefenseBonus(final CombatantSide side) {\n        return defenseBonuses.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfMovesPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double numberOfMovesPerPlayer(final CombatantSide side) {\n        double result = 0;\n        switch(side) {\n            case ATTACKER:\n                result = moves.getSideValue(side) / (double) _numberOfAttacker;\n                break;\n            case DEFENDER:\n                result = moves.getSideValue(side) / (double) _numberOfDefenders;\n                break;\n            default:\n                result = moves.getSideValue(null) / (double) (_numberOfAttacker + _numberOfDefenders);\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfOffliners(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfOffliners(final CombatantSide side) {\n        int offliner = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (counter.wasOffline()) {\n                    offliner++;\n                }\n            }\n        }\n        return offliner;\n    }\n\n    /**\n     * @param side\n     * @param combatant\n     * @return\n     */\n    private boolean isOnSide(final CombatantSide side, final Combatant combatant) {\n        return side == null || side.equals(combatant.getSide());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#roundsTillOnline(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double roundsTillOnline(final CombatantSide side) {\n        int combatants = 0;\n        int rounds = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (!counter.wasOffline()) {\n                    combatants++;\n                    rounds += counter.firstOnline();\n                }\n            }\n        }\n        // avoid division by zero\n        if (combatants == 0) {\n            return 0;\n        }\n        return ((double) rounds / (double) combatants);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#averageRoundsOnline(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageRoundsOnline(final CombatantSide side) {\n        double combatants = 0;\n        double rounds = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (!counter.wasOffline()) {\n                    combatants++;\n                    rounds += counter.onlineEvents();\n                }\n            }\n        }\n        // avoid division by zero\n        if (combatants == 0.0) {\n            return 0.0;\n        }\n        return rounds / combatants;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#hasMoved(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Area)\n     */\n    public void hasMoved(final Combatant combatant, final Area newPos) {\n        moves.incrementSide(combatant);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#newDestination(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Area)\n     */\n    public void newDestination(final Combatant combatant, final Area destination) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#aimsAt(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void aimsAt(final Combatant combatant, final Combatant target) {\n        incrementCombatantCounter(shots, combatant);\n        incrementCombatantCounter(victims, target);\n        shotRoundCounter.get(combatant.getSide()).incrementAndGet();\n        final Area field = target._getLocation();\n        getFieldStat(field).addShot();\n    }\n\n    private void incrementCombatantCounter(final Map<Combatant, Counter> combatantCounters, final Combatant combatant) {\n        if (!combatantCounters.containsKey(combatant)) {\n            combatantCounters.put(combatant, new Counter());\n        }\n        combatantCounters.get(combatant).increment();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isHit(de.outstare.fortbattleplayer.model.Combatant,\n     *      int, int)\n     */\n    public void isHit(final Combatant combatant, final int damage, final int oldHealthAmount) {\n        hitRoundCounter.get(combatant.getSide()).incrementAndGet();\n        final Area field = combatant._getLocation();\n        getFieldStat(field).addHit();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isDead(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void isDead(final Combatant combatant) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isAlive(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void isAlive(final Combatant combatant) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isOnline(de.outstare.fortbattleplayer.model.Combatant,\n     *      boolean)\n     */\n    public void isOnline(final Combatant combatant, final boolean changed) {\n        // count all events\n        if (!onliners.containsKey(combatant)) {\n            onliners.put(combatant, new OnlineCounter());\n        }\n        if (combatant.isOnline()) {\n            onliners.get(combatant).addOnline();\n        } else {\n            onliners.get(combatant).addOffline();\n        }\n        // the online event is triggered every round for a player (hopefully)\n        combatantTurn(combatant);\n    }\n\n    /**\n     * no special action, just to track the state every round\n     *\n     * @param combatant\n     */\n    private void combatantTurn(final Combatant combatant) {\n        final SectorBonus bonus = combatant.getSectorBonus();\n        attackBonuses.incrementBy(bonus.attackBonus, combatant);\n        defenseBonuses.incrementBy(bonus.defendBonus, combatant);\n        if (firstRound != null && firstRound.booleanValue()) {\n            turnOrder.add(combatant);\n        }\n        if (LOG.isLoggable(Level.FINE)) {\n            if ((firstRound == null || !firstRound.booleanValue()) && !turnOrder.contains(combatant) && currentRoundNo > 1) {\n                LOG.fine(\"---- not in order: \" + combatant);\n            }\n        }\n        actorsThisRound.incrementSide(combatant);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#targetNoOne(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public String targetNoOne(final CombatantSide side) {\n        String result = \"\";\n        int max = 0;\n        for (final Entry<Combatant, Counter> victim : victims.entrySet()) {\n            final Combatant combatant = victim.getKey();\n            if (isOnSide(side, combatant)) {\n                final int receivedShots = victim.getValue().getValue();\n                if (receivedShots > max) {\n                    max = receivedShots;\n                    result = combatant.getName() + \"(\" + receivedShots + \")\";\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfBayonets(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfBayonets(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.BayonetCounter());\n    }\n\n    /**\n     * @param side\n     * @param counter\n     * @return\n     */\n    int countWeaponMods(final CombatantSide side, final WeaponModCounter counter) {\n        // because every player should have an online/offline event, we look at\n        // the online data hoping to get all players\n        final Set<Combatant> players = onliners.keySet();\n        int bayonets = 0;\n        for (final Combatant combatant : players) {\n            if (isOnSide(side, combatant)) {\n                final Weapon playerWeapon = combatant.getWeapon();\n                // TODO let the counter count\n                if (counter.counts(playerWeapon)) {\n                    bayonets++;\n                }\n            }\n        }\n        return bayonets;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfGraphitLubricants(CombatantSide)\n     */\n    public int numberOfGraphitLubricants(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.GraphitLubricantCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfFettesOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfFettesOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.FettesOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfSchmierOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfSchmierOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.SchmierOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfShinyOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfShinyOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.ShinyOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfLoadingChamerOrEnhancedPatrons(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfLoadingChamerOrEnhancedPatrons(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.LoadingchamberOrEnhancedPatronsCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfHipFlasks(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfHipFlasks(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.HipFlaskCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#hasSwappedPosition()\n     */\n    public void hasSwappedPosition(final Combatant combatant, final Combatant swappedWith) {\n        swaps.incrementSide(combatant);\n        final PositionSwitch swap = new PositionSwitch(currentRoundNo, combatant, swappedWith);\n        assert swapList.get(combatant.getSide()) != null;\n        swapList.get(combatant.getSide()).add(swap);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#totalSwaps(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int totalSwaps(final CombatantSide side) {\n        return swaps.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#switchedPosList(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public Set<PositionSwitch> switchedPosList(final CombatantSide side) {\n        final Set<PositionSwitch> allSwaps;\n        if (side == null) {\n            allSwaps = new HashSet<PositionSwitch>();\n            for (final Set<PositionSwitch> sideSwitches : swapList.values()) {\n                allSwaps.addAll(sideSwitches);\n            }\n        } else {\n            allSwaps = swapList.get(side);\n        }\n        return allSwaps;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#criticalShot(de.outstare.fortbattleplayer.model.Combatant,\n     *      Combatant, int)\n     */\n    public void criticalShot(final Combatant combatant, final Combatant victim, final int damage) {\n        final CriticalHit crit = new CriticalHit(combatant, victim, damage, currentRoundNo);\n        critHits.get(combatant.getSide()).add(crit);\n        crits.incrementSide(combatant);\n        final Area field = victim._getLocation();\n        getFieldStat(field).addCrit();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#critList(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public List<CriticalHit> critList(final CombatantSide side) {\n        final List<CriticalHit> allCrits;\n        if (side == null) {\n            allCrits = new ArrayList<CriticalHit>();\n            for (final List<CriticalHit> sideCrits : critHits.values()) {\n                allCrits.addAll(sideCrits);\n            }\n        } else {\n            allCrits = critHits.get(side);\n        }\n        return allCrits;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#criticalHits(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int criticalHits(final CombatantSide side) {\n        return crits.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#criticalHitDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public long criticalHitDamage(final CombatantSide side) {\n        long sum = 0;\n        for (final CriticalHit crit : critList(side)) {\n            sum += crit.critOnlyDamage;\n        }\n        return sum;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#turnOrder(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public List<Combatant> turnOrder(final CombatantSide side) {\n        final List<Combatant> sidePlayers = new ArrayList<Combatant>(turnOrder.size() / 2);\n        for (final Combatant player : turnOrder) {\n            if (side == null || player.getSide() == side) {\n                sidePlayers.add(player);\n            }\n        }\n        return sidePlayers;\n    }\n\n    /**\n     * @return the number of shots per round\n     */\n    public Map<CombatantSide, ? extends LabeledData> getShotsPerRound() {\n        return shotsPerRound;\n    }\n\n    /**\n     * @return the number of hits per round\n     */\n    public Map<CombatantSide, ? extends LabeledData> getHitsPerRound() {\n        return hitsPerRound;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#getNotShootersPerRound()\n     */\n    public Map<CombatantSide, ? extends LabeledData> getNotShootersPerRound() {\n        final Map<CombatantSide, RoundStatistics> nonShootersPerRound = new HashMap<CombatantSide, RoundStatistics>();\n        for (final CombatantSide side : CombatantSide.values()) {\n            final RoundStatistics nonShooters = new RoundStatistics(\"Not shooting\", \"players\");\n            nonShootersPerRound.put(side, nonShooters);\n            final LabeledData shotRoundCounts = shotsPerRound.get(side);\n            if (shotRoundCounts != null) {\n                final double[] shotCounts = shotRoundCounts.toArray();\n                if (actorsPerRound.size() == shotCounts.length) {\n                    for (int i = 0; i < shotCounts.length; i++) {\n                        final int actors = actorsPerRound.get(i).getSideValue(side);\n                        final double numberNotShooting = actors - shotCounts[i];\n                        nonShooters.addValue(numberNotShooting);\n                    }\n                } else {\n                    LOG.warning(\"round statistics for players and shots differ!\");\n                }\n            } else {\n                LOG.warning(\"no data for players and shots for side \" + side);\n            }\n        }\n        return nonShootersPerRound;\n    }\n\n    private AreaStatistic getFieldStat(final Area area) {\n        if (!fieldStats.containsKey(area)) {\n            fieldStats.put(area, new AreaStatistic(area));\n        }\n        return fieldStats.get(area);\n    }\n\n    /**\n     * @return statistics for every field\n     */\n    public Map<Area, AreaStatistic> getFieldStatistics() {\n        return fieldStats;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/BattleStatistics_12Test.java",
		"test_prompt": "// BattleStatistics_12Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BattleStatistics}.\n* It contains ten unit test cases for the {@link BattleStatistics#numberOfShinyOil(CombatantSide)} method.\n*/\nclass BattleStatistics_12Test {"
	},
	{
		"original_code": "// BattleStatistics.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\n\n/**\n * @author daniel\n */\npublic class BattleStatistics implements DynamicStatistics, CombatantObserver {\n\n    private static final transient Logger LOG = Logger.getLogger(BattleStatistics.class.getName());\n\n    private final Map<Combatant, OnlineCounter> onliners = new HashMap<Combatant, OnlineCounter>();\n\n    private final Map<CombatantSide, List<CriticalHit>> critHits = new HashMap<CombatantSide, List<CriticalHit>>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            critHits.put(side, new ArrayList<CriticalHit>());\n        }\n    }\n\n    private final Map<CombatantSide, Set<PositionSwitch>> swapList = new HashMap<CombatantSide, Set<PositionSwitch>>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            swapList.put(side, new HashSet<PositionSwitch>());\n        }\n    }\n\n    private final AllCombatantSidesCounter crits = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter moves = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter swaps = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter attackBonuses = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter defenseBonuses = new AllCombatantSidesCounter();\n\n    private final Map<Combatant, Counter> shots = new HashMap<Combatant, Counter>();\n\n    private final Map<CombatantSide, RoundStatistics> shotsPerRound = new HashMap<CombatantSide, RoundStatistics>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            shotsPerRound.put(side, new RoundStatistics(\"shots\", \"shots\"));\n        }\n    }\n\n    private final Map<CombatantSide, RoundStatistics> hitsPerRound = new HashMap<CombatantSide, RoundStatistics>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            hitsPerRound.put(side, new RoundStatistics(\"hits\", \"hits\"));\n        }\n    }\n\n    private final Map<CombatantSide, AtomicInteger> shotRoundCounter = new HashMap<CombatantSide, AtomicInteger>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            shotRoundCounter.put(side, new AtomicInteger());\n        }\n    }\n\n    private final Map<CombatantSide, AtomicInteger> hitRoundCounter = new HashMap<CombatantSide, AtomicInteger>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            hitRoundCounter.put(side, new AtomicInteger());\n        }\n    }\n\n    private final Map<Combatant, Counter> victims = new HashMap<Combatant, Counter>();\n\n    private final List<Combatant> turnOrder = new LinkedList<Combatant>();\n\n    private final List<AllCombatantSidesCounter> actorsPerRound = new ArrayList<AllCombatantSidesCounter>(50);\n\n    private final Map<Area, AreaStatistic> fieldStats = new HashMap<Area, AreaStatistic>();\n\n    private final int _numberOfDefenders;\n\n    private final int _numberOfAttacker;\n\n    private int currentRoundNo = 0;\n\n    private Boolean firstRound = null;\n\n    private AllCombatantSidesCounter actorsThisRound = new AllCombatantSidesCounter();\n\n    /**\n     * set the current round. all following method calls will belong to this\n     * round till this method is called again with another parameter.\n     *\n     * @param no\n     */\n    public void setRound(final int no) {\n        if (firstRound == null) {\n            firstRound = Boolean.TRUE;\n        } else if (firstRound.booleanValue()) {\n            firstRound = Boolean.FALSE;\n            // the turn order is determined only in the first round\n            for (final Combatant player : onliners.keySet()) {\n                if (!turnOrder.contains(player)) {\n                    LOG.info(\"could not determine turn order for \" + player);\n                }\n            }\n        }\n        addAndResetRoundCounter(shotRoundCounter, shotsPerRound);\n        addAndResetRoundCounter(hitRoundCounter, hitsPerRound);\n        actorsPerRound.add(actorsThisRound);\n        actorsThisRound = new AllCombatantSidesCounter();\n        currentRoundNo = no;\n    }\n\n    /**\n     * this adds the counters for the last round to the total counts per round\n     * and resets the given counter\n     *\n     * @param roundCounter\n     * @param allRounds\n     */\n    void addAndResetRoundCounter(final Map<CombatantSide, AtomicInteger> roundCounter, final Map<CombatantSide, RoundStatistics> allRounds) {\n        for (final Entry<CombatantSide, AtomicInteger> mapping : roundCounter.entrySet()) {\n            final CombatantSide side = mapping.getKey();\n            final AtomicInteger roundShots = mapping.getValue();\n            allRounds.get(side).addValue(roundShots.get());\n            // reset for next round\n            roundShots.set(0);\n        }\n    }\n\n    /**\n     * @param combatant\n     * @return\n     */\n    int combatantLifetime(final Combatant combatant) {\n        final OnlineCounter onAndOffline = onliners.get(combatant);\n        if (onAndOffline == null) {\n            return 0;\n        }\n        return onAndOffline.sumOfEvents();\n    }\n\n    /**\n     * @param numberOfAttacker\n     * @param numberOfDefenders\n     */\n    public BattleStatistics(final int numberOfAttacker, final int numberOfDefenders) {\n        _numberOfAttacker = numberOfAttacker;\n        _numberOfDefenders = numberOfDefenders;\n    }\n\n    /**\n     * @param number\n     * @return\n     */\n    int round(final double number) {\n        return (int) Math.round(number);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#percentAbleToShoot(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int percentAbleToShoot(final CombatantSide side) {\n        double sum = 0;\n        int players = 0;\n        for (final Entry<Combatant, Counter> playerShots : shots.entrySet()) {\n            final Combatant combatant = playerShots.getKey();\n            if (isOnSide(side, combatant)) {\n                final int lifetime = combatantLifetime(combatant);\n                final int roundsShooting = playerShots.getValue().getValue();\n                sum += roundsShooting * 100.0 / lifetime;\n                players++;\n            }\n        }\n        if (players == 0) {\n            return 0;\n        }\n        return round(sum / players);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#amountOfAttackBonus(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int amountOfAttackBonus(final CombatantSide side) {\n        return attackBonuses.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#amountOfDefenseBonus(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int amountOfDefenseBonus(final CombatantSide side) {\n        return defenseBonuses.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfMovesPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double numberOfMovesPerPlayer(final CombatantSide side) {\n        double result = 0;\n        switch(side) {\n            case ATTACKER:\n                result = moves.getSideValue(side) / (double) _numberOfAttacker;\n                break;\n            case DEFENDER:\n                result = moves.getSideValue(side) / (double) _numberOfDefenders;\n                break;\n            default:\n                result = moves.getSideValue(null) / (double) (_numberOfAttacker + _numberOfDefenders);\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfOffliners(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfOffliners(final CombatantSide side) {\n        int offliner = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (counter.wasOffline()) {\n                    offliner++;\n                }\n            }\n        }\n        return offliner;\n    }\n\n    /**\n     * @param side\n     * @param combatant\n     * @return\n     */\n    private boolean isOnSide(final CombatantSide side, final Combatant combatant) {\n        return side == null || side.equals(combatant.getSide());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#roundsTillOnline(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double roundsTillOnline(final CombatantSide side) {\n        int combatants = 0;\n        int rounds = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (!counter.wasOffline()) {\n                    combatants++;\n                    rounds += counter.firstOnline();\n                }\n            }\n        }\n        // avoid division by zero\n        if (combatants == 0) {\n            return 0;\n        }\n        return ((double) rounds / (double) combatants);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#averageRoundsOnline(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageRoundsOnline(final CombatantSide side) {\n        double combatants = 0;\n        double rounds = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (!counter.wasOffline()) {\n                    combatants++;\n                    rounds += counter.onlineEvents();\n                }\n            }\n        }\n        // avoid division by zero\n        if (combatants == 0.0) {\n            return 0.0;\n        }\n        return rounds / combatants;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#hasMoved(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Area)\n     */\n    public void hasMoved(final Combatant combatant, final Area newPos) {\n        moves.incrementSide(combatant);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#newDestination(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Area)\n     */\n    public void newDestination(final Combatant combatant, final Area destination) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#aimsAt(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void aimsAt(final Combatant combatant, final Combatant target) {\n        incrementCombatantCounter(shots, combatant);\n        incrementCombatantCounter(victims, target);\n        shotRoundCounter.get(combatant.getSide()).incrementAndGet();\n        final Area field = target._getLocation();\n        getFieldStat(field).addShot();\n    }\n\n    private void incrementCombatantCounter(final Map<Combatant, Counter> combatantCounters, final Combatant combatant) {\n        if (!combatantCounters.containsKey(combatant)) {\n            combatantCounters.put(combatant, new Counter());\n        }\n        combatantCounters.get(combatant).increment();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isHit(de.outstare.fortbattleplayer.model.Combatant,\n     *      int, int)\n     */\n    public void isHit(final Combatant combatant, final int damage, final int oldHealthAmount) {\n        hitRoundCounter.get(combatant.getSide()).incrementAndGet();\n        final Area field = combatant._getLocation();\n        getFieldStat(field).addHit();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isDead(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void isDead(final Combatant combatant) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isAlive(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void isAlive(final Combatant combatant) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isOnline(de.outstare.fortbattleplayer.model.Combatant,\n     *      boolean)\n     */\n    public void isOnline(final Combatant combatant, final boolean changed) {\n        // count all events\n        if (!onliners.containsKey(combatant)) {\n            onliners.put(combatant, new OnlineCounter());\n        }\n        if (combatant.isOnline()) {\n            onliners.get(combatant).addOnline();\n        } else {\n            onliners.get(combatant).addOffline();\n        }\n        // the online event is triggered every round for a player (hopefully)\n        combatantTurn(combatant);\n    }\n\n    /**\n     * no special action, just to track the state every round\n     *\n     * @param combatant\n     */\n    private void combatantTurn(final Combatant combatant) {\n        final SectorBonus bonus = combatant.getSectorBonus();\n        attackBonuses.incrementBy(bonus.attackBonus, combatant);\n        defenseBonuses.incrementBy(bonus.defendBonus, combatant);\n        if (firstRound != null && firstRound.booleanValue()) {\n            turnOrder.add(combatant);\n        }\n        if (LOG.isLoggable(Level.FINE)) {\n            if ((firstRound == null || !firstRound.booleanValue()) && !turnOrder.contains(combatant) && currentRoundNo > 1) {\n                LOG.fine(\"---- not in order: \" + combatant);\n            }\n        }\n        actorsThisRound.incrementSide(combatant);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#targetNoOne(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public String targetNoOne(final CombatantSide side) {\n        String result = \"\";\n        int max = 0;\n        for (final Entry<Combatant, Counter> victim : victims.entrySet()) {\n            final Combatant combatant = victim.getKey();\n            if (isOnSide(side, combatant)) {\n                final int receivedShots = victim.getValue().getValue();\n                if (receivedShots > max) {\n                    max = receivedShots;\n                    result = combatant.getName() + \"(\" + receivedShots + \")\";\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfBayonets(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfBayonets(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.BayonetCounter());\n    }\n\n    /**\n     * @param side\n     * @param counter\n     * @return\n     */\n    int countWeaponMods(final CombatantSide side, final WeaponModCounter counter) {\n        // because every player should have an online/offline event, we look at\n        // the online data hoping to get all players\n        final Set<Combatant> players = onliners.keySet();\n        int bayonets = 0;\n        for (final Combatant combatant : players) {\n            if (isOnSide(side, combatant)) {\n                final Weapon playerWeapon = combatant.getWeapon();\n                // TODO let the counter count\n                if (counter.counts(playerWeapon)) {\n                    bayonets++;\n                }\n            }\n        }\n        return bayonets;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfGraphitLubricants(CombatantSide)\n     */\n    public int numberOfGraphitLubricants(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.GraphitLubricantCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfFettesOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfFettesOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.FettesOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfSchmierOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfSchmierOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.SchmierOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfShinyOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfShinyOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.ShinyOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfLoadingChamerOrEnhancedPatrons(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfLoadingChamerOrEnhancedPatrons(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.LoadingchamberOrEnhancedPatronsCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfHipFlasks(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfHipFlasks(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.HipFlaskCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#hasSwappedPosition()\n     */\n    public void hasSwappedPosition(final Combatant combatant, final Combatant swappedWith) {\n        swaps.incrementSide(combatant);\n        final PositionSwitch swap = new PositionSwitch(currentRoundNo, combatant, swappedWith);\n        assert swapList.get(combatant.getSide()) != null;\n        swapList.get(combatant.getSide()).add(swap);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#totalSwaps(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int totalSwaps(final CombatantSide side) {\n        return swaps.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#switchedPosList(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public Set<PositionSwitch> switchedPosList(final CombatantSide side) {\n        final Set<PositionSwitch> allSwaps;\n        if (side == null) {\n            allSwaps = new HashSet<PositionSwitch>();\n            for (final Set<PositionSwitch> sideSwitches : swapList.values()) {\n                allSwaps.addAll(sideSwitches);\n            }\n        } else {\n            allSwaps = swapList.get(side);\n        }\n        return allSwaps;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#criticalShot(de.outstare.fortbattleplayer.model.Combatant,\n     *      Combatant, int)\n     */\n    public void criticalShot(final Combatant combatant, final Combatant victim, final int damage) {\n        final CriticalHit crit = new CriticalHit(combatant, victim, damage, currentRoundNo);\n        critHits.get(combatant.getSide()).add(crit);\n        crits.incrementSide(combatant);\n        final Area field = victim._getLocation();\n        getFieldStat(field).addCrit();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#critList(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public List<CriticalHit> critList(final CombatantSide side) {\n        final List<CriticalHit> allCrits;\n        if (side == null) {\n            allCrits = new ArrayList<CriticalHit>();\n            for (final List<CriticalHit> sideCrits : critHits.values()) {\n                allCrits.addAll(sideCrits);\n            }\n        } else {\n            allCrits = critHits.get(side);\n        }\n        return allCrits;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#criticalHits(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int criticalHits(final CombatantSide side) {\n        return crits.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#criticalHitDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public long criticalHitDamage(final CombatantSide side) {\n        long sum = 0;\n        for (final CriticalHit crit : critList(side)) {\n            sum += crit.critOnlyDamage;\n        }\n        return sum;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#turnOrder(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public List<Combatant> turnOrder(final CombatantSide side) {\n        final List<Combatant> sidePlayers = new ArrayList<Combatant>(turnOrder.size() / 2);\n        for (final Combatant player : turnOrder) {\n            if (side == null || player.getSide() == side) {\n                sidePlayers.add(player);\n            }\n        }\n        return sidePlayers;\n    }\n\n    /**\n     * @return the number of shots per round\n     */\n    public Map<CombatantSide, ? extends LabeledData> getShotsPerRound() {\n        return shotsPerRound;\n    }\n\n    /**\n     * @return the number of hits per round\n     */\n    public Map<CombatantSide, ? extends LabeledData> getHitsPerRound() {\n        return hitsPerRound;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#getNotShootersPerRound()\n     */\n    public Map<CombatantSide, ? extends LabeledData> getNotShootersPerRound() {\n        final Map<CombatantSide, RoundStatistics> nonShootersPerRound = new HashMap<CombatantSide, RoundStatistics>();\n        for (final CombatantSide side : CombatantSide.values()) {\n            final RoundStatistics nonShooters = new RoundStatistics(\"Not shooting\", \"players\");\n            nonShootersPerRound.put(side, nonShooters);\n            final LabeledData shotRoundCounts = shotsPerRound.get(side);\n            if (shotRoundCounts != null) {\n                final double[] shotCounts = shotRoundCounts.toArray();\n                if (actorsPerRound.size() == shotCounts.length) {\n                    for (int i = 0; i < shotCounts.length; i++) {\n                        final int actors = actorsPerRound.get(i).getSideValue(side);\n                        final double numberNotShooting = actors - shotCounts[i];\n                        nonShooters.addValue(numberNotShooting);\n                    }\n                } else {\n                    LOG.warning(\"round statistics for players and shots differ!\");\n                }\n            } else {\n                LOG.warning(\"no data for players and shots for side \" + side);\n            }\n        }\n        return nonShootersPerRound;\n    }\n\n    private AreaStatistic getFieldStat(final Area area) {\n        if (!fieldStats.containsKey(area)) {\n            fieldStats.put(area, new AreaStatistic(area));\n        }\n        return fieldStats.get(area);\n    }\n\n    /**\n     * @return statistics for every field\n     */\n    public Map<Area, AreaStatistic> getFieldStatistics() {\n        return fieldStats;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/BattleStatistics_13Test.java",
		"test_prompt": "// BattleStatistics_13Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BattleStatistics}.\n* It contains ten unit test cases for the {@link BattleStatistics#numberOfLoadingChamerOrEnhancedPatrons(CombatantSide)} method.\n*/\nclass BattleStatistics_13Test {"
	},
	{
		"original_code": "// BattleStatistics.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\n\n/**\n * @author daniel\n */\npublic class BattleStatistics implements DynamicStatistics, CombatantObserver {\n\n    private static final transient Logger LOG = Logger.getLogger(BattleStatistics.class.getName());\n\n    private final Map<Combatant, OnlineCounter> onliners = new HashMap<Combatant, OnlineCounter>();\n\n    private final Map<CombatantSide, List<CriticalHit>> critHits = new HashMap<CombatantSide, List<CriticalHit>>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            critHits.put(side, new ArrayList<CriticalHit>());\n        }\n    }\n\n    private final Map<CombatantSide, Set<PositionSwitch>> swapList = new HashMap<CombatantSide, Set<PositionSwitch>>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            swapList.put(side, new HashSet<PositionSwitch>());\n        }\n    }\n\n    private final AllCombatantSidesCounter crits = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter moves = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter swaps = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter attackBonuses = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter defenseBonuses = new AllCombatantSidesCounter();\n\n    private final Map<Combatant, Counter> shots = new HashMap<Combatant, Counter>();\n\n    private final Map<CombatantSide, RoundStatistics> shotsPerRound = new HashMap<CombatantSide, RoundStatistics>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            shotsPerRound.put(side, new RoundStatistics(\"shots\", \"shots\"));\n        }\n    }\n\n    private final Map<CombatantSide, RoundStatistics> hitsPerRound = new HashMap<CombatantSide, RoundStatistics>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            hitsPerRound.put(side, new RoundStatistics(\"hits\", \"hits\"));\n        }\n    }\n\n    private final Map<CombatantSide, AtomicInteger> shotRoundCounter = new HashMap<CombatantSide, AtomicInteger>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            shotRoundCounter.put(side, new AtomicInteger());\n        }\n    }\n\n    private final Map<CombatantSide, AtomicInteger> hitRoundCounter = new HashMap<CombatantSide, AtomicInteger>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            hitRoundCounter.put(side, new AtomicInteger());\n        }\n    }\n\n    private final Map<Combatant, Counter> victims = new HashMap<Combatant, Counter>();\n\n    private final List<Combatant> turnOrder = new LinkedList<Combatant>();\n\n    private final List<AllCombatantSidesCounter> actorsPerRound = new ArrayList<AllCombatantSidesCounter>(50);\n\n    private final Map<Area, AreaStatistic> fieldStats = new HashMap<Area, AreaStatistic>();\n\n    private final int _numberOfDefenders;\n\n    private final int _numberOfAttacker;\n\n    private int currentRoundNo = 0;\n\n    private Boolean firstRound = null;\n\n    private AllCombatantSidesCounter actorsThisRound = new AllCombatantSidesCounter();\n\n    /**\n     * set the current round. all following method calls will belong to this\n     * round till this method is called again with another parameter.\n     *\n     * @param no\n     */\n    public void setRound(final int no) {\n        if (firstRound == null) {\n            firstRound = Boolean.TRUE;\n        } else if (firstRound.booleanValue()) {\n            firstRound = Boolean.FALSE;\n            // the turn order is determined only in the first round\n            for (final Combatant player : onliners.keySet()) {\n                if (!turnOrder.contains(player)) {\n                    LOG.info(\"could not determine turn order for \" + player);\n                }\n            }\n        }\n        addAndResetRoundCounter(shotRoundCounter, shotsPerRound);\n        addAndResetRoundCounter(hitRoundCounter, hitsPerRound);\n        actorsPerRound.add(actorsThisRound);\n        actorsThisRound = new AllCombatantSidesCounter();\n        currentRoundNo = no;\n    }\n\n    /**\n     * this adds the counters for the last round to the total counts per round\n     * and resets the given counter\n     *\n     * @param roundCounter\n     * @param allRounds\n     */\n    void addAndResetRoundCounter(final Map<CombatantSide, AtomicInteger> roundCounter, final Map<CombatantSide, RoundStatistics> allRounds) {\n        for (final Entry<CombatantSide, AtomicInteger> mapping : roundCounter.entrySet()) {\n            final CombatantSide side = mapping.getKey();\n            final AtomicInteger roundShots = mapping.getValue();\n            allRounds.get(side).addValue(roundShots.get());\n            // reset for next round\n            roundShots.set(0);\n        }\n    }\n\n    /**\n     * @param combatant\n     * @return\n     */\n    int combatantLifetime(final Combatant combatant) {\n        final OnlineCounter onAndOffline = onliners.get(combatant);\n        if (onAndOffline == null) {\n            return 0;\n        }\n        return onAndOffline.sumOfEvents();\n    }\n\n    /**\n     * @param numberOfAttacker\n     * @param numberOfDefenders\n     */\n    public BattleStatistics(final int numberOfAttacker, final int numberOfDefenders) {\n        _numberOfAttacker = numberOfAttacker;\n        _numberOfDefenders = numberOfDefenders;\n    }\n\n    /**\n     * @param number\n     * @return\n     */\n    int round(final double number) {\n        return (int) Math.round(number);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#percentAbleToShoot(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int percentAbleToShoot(final CombatantSide side) {\n        double sum = 0;\n        int players = 0;\n        for (final Entry<Combatant, Counter> playerShots : shots.entrySet()) {\n            final Combatant combatant = playerShots.getKey();\n            if (isOnSide(side, combatant)) {\n                final int lifetime = combatantLifetime(combatant);\n                final int roundsShooting = playerShots.getValue().getValue();\n                sum += roundsShooting * 100.0 / lifetime;\n                players++;\n            }\n        }\n        if (players == 0) {\n            return 0;\n        }\n        return round(sum / players);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#amountOfAttackBonus(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int amountOfAttackBonus(final CombatantSide side) {\n        return attackBonuses.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#amountOfDefenseBonus(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int amountOfDefenseBonus(final CombatantSide side) {\n        return defenseBonuses.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfMovesPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double numberOfMovesPerPlayer(final CombatantSide side) {\n        double result = 0;\n        switch(side) {\n            case ATTACKER:\n                result = moves.getSideValue(side) / (double) _numberOfAttacker;\n                break;\n            case DEFENDER:\n                result = moves.getSideValue(side) / (double) _numberOfDefenders;\n                break;\n            default:\n                result = moves.getSideValue(null) / (double) (_numberOfAttacker + _numberOfDefenders);\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfOffliners(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfOffliners(final CombatantSide side) {\n        int offliner = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (counter.wasOffline()) {\n                    offliner++;\n                }\n            }\n        }\n        return offliner;\n    }\n\n    /**\n     * @param side\n     * @param combatant\n     * @return\n     */\n    private boolean isOnSide(final CombatantSide side, final Combatant combatant) {\n        return side == null || side.equals(combatant.getSide());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#roundsTillOnline(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double roundsTillOnline(final CombatantSide side) {\n        int combatants = 0;\n        int rounds = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (!counter.wasOffline()) {\n                    combatants++;\n                    rounds += counter.firstOnline();\n                }\n            }\n        }\n        // avoid division by zero\n        if (combatants == 0) {\n            return 0;\n        }\n        return ((double) rounds / (double) combatants);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#averageRoundsOnline(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageRoundsOnline(final CombatantSide side) {\n        double combatants = 0;\n        double rounds = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (!counter.wasOffline()) {\n                    combatants++;\n                    rounds += counter.onlineEvents();\n                }\n            }\n        }\n        // avoid division by zero\n        if (combatants == 0.0) {\n            return 0.0;\n        }\n        return rounds / combatants;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#hasMoved(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Area)\n     */\n    public void hasMoved(final Combatant combatant, final Area newPos) {\n        moves.incrementSide(combatant);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#newDestination(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Area)\n     */\n    public void newDestination(final Combatant combatant, final Area destination) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#aimsAt(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void aimsAt(final Combatant combatant, final Combatant target) {\n        incrementCombatantCounter(shots, combatant);\n        incrementCombatantCounter(victims, target);\n        shotRoundCounter.get(combatant.getSide()).incrementAndGet();\n        final Area field = target._getLocation();\n        getFieldStat(field).addShot();\n    }\n\n    private void incrementCombatantCounter(final Map<Combatant, Counter> combatantCounters, final Combatant combatant) {\n        if (!combatantCounters.containsKey(combatant)) {\n            combatantCounters.put(combatant, new Counter());\n        }\n        combatantCounters.get(combatant).increment();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isHit(de.outstare.fortbattleplayer.model.Combatant,\n     *      int, int)\n     */\n    public void isHit(final Combatant combatant, final int damage, final int oldHealthAmount) {\n        hitRoundCounter.get(combatant.getSide()).incrementAndGet();\n        final Area field = combatant._getLocation();\n        getFieldStat(field).addHit();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isDead(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void isDead(final Combatant combatant) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isAlive(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void isAlive(final Combatant combatant) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isOnline(de.outstare.fortbattleplayer.model.Combatant,\n     *      boolean)\n     */\n    public void isOnline(final Combatant combatant, final boolean changed) {\n        // count all events\n        if (!onliners.containsKey(combatant)) {\n            onliners.put(combatant, new OnlineCounter());\n        }\n        if (combatant.isOnline()) {\n            onliners.get(combatant).addOnline();\n        } else {\n            onliners.get(combatant).addOffline();\n        }\n        // the online event is triggered every round for a player (hopefully)\n        combatantTurn(combatant);\n    }\n\n    /**\n     * no special action, just to track the state every round\n     *\n     * @param combatant\n     */\n    private void combatantTurn(final Combatant combatant) {\n        final SectorBonus bonus = combatant.getSectorBonus();\n        attackBonuses.incrementBy(bonus.attackBonus, combatant);\n        defenseBonuses.incrementBy(bonus.defendBonus, combatant);\n        if (firstRound != null && firstRound.booleanValue()) {\n            turnOrder.add(combatant);\n        }\n        if (LOG.isLoggable(Level.FINE)) {\n            if ((firstRound == null || !firstRound.booleanValue()) && !turnOrder.contains(combatant) && currentRoundNo > 1) {\n                LOG.fine(\"---- not in order: \" + combatant);\n            }\n        }\n        actorsThisRound.incrementSide(combatant);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#targetNoOne(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public String targetNoOne(final CombatantSide side) {\n        String result = \"\";\n        int max = 0;\n        for (final Entry<Combatant, Counter> victim : victims.entrySet()) {\n            final Combatant combatant = victim.getKey();\n            if (isOnSide(side, combatant)) {\n                final int receivedShots = victim.getValue().getValue();\n                if (receivedShots > max) {\n                    max = receivedShots;\n                    result = combatant.getName() + \"(\" + receivedShots + \")\";\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfBayonets(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfBayonets(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.BayonetCounter());\n    }\n\n    /**\n     * @param side\n     * @param counter\n     * @return\n     */\n    int countWeaponMods(final CombatantSide side, final WeaponModCounter counter) {\n        // because every player should have an online/offline event, we look at\n        // the online data hoping to get all players\n        final Set<Combatant> players = onliners.keySet();\n        int bayonets = 0;\n        for (final Combatant combatant : players) {\n            if (isOnSide(side, combatant)) {\n                final Weapon playerWeapon = combatant.getWeapon();\n                // TODO let the counter count\n                if (counter.counts(playerWeapon)) {\n                    bayonets++;\n                }\n            }\n        }\n        return bayonets;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfGraphitLubricants(CombatantSide)\n     */\n    public int numberOfGraphitLubricants(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.GraphitLubricantCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfFettesOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfFettesOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.FettesOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfSchmierOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfSchmierOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.SchmierOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfShinyOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfShinyOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.ShinyOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfLoadingChamerOrEnhancedPatrons(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfLoadingChamerOrEnhancedPatrons(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.LoadingchamberOrEnhancedPatronsCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfHipFlasks(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfHipFlasks(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.HipFlaskCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#hasSwappedPosition()\n     */\n    public void hasSwappedPosition(final Combatant combatant, final Combatant swappedWith) {\n        swaps.incrementSide(combatant);\n        final PositionSwitch swap = new PositionSwitch(currentRoundNo, combatant, swappedWith);\n        assert swapList.get(combatant.getSide()) != null;\n        swapList.get(combatant.getSide()).add(swap);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#totalSwaps(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int totalSwaps(final CombatantSide side) {\n        return swaps.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#switchedPosList(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public Set<PositionSwitch> switchedPosList(final CombatantSide side) {\n        final Set<PositionSwitch> allSwaps;\n        if (side == null) {\n            allSwaps = new HashSet<PositionSwitch>();\n            for (final Set<PositionSwitch> sideSwitches : swapList.values()) {\n                allSwaps.addAll(sideSwitches);\n            }\n        } else {\n            allSwaps = swapList.get(side);\n        }\n        return allSwaps;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#criticalShot(de.outstare.fortbattleplayer.model.Combatant,\n     *      Combatant, int)\n     */\n    public void criticalShot(final Combatant combatant, final Combatant victim, final int damage) {\n        final CriticalHit crit = new CriticalHit(combatant, victim, damage, currentRoundNo);\n        critHits.get(combatant.getSide()).add(crit);\n        crits.incrementSide(combatant);\n        final Area field = victim._getLocation();\n        getFieldStat(field).addCrit();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#critList(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public List<CriticalHit> critList(final CombatantSide side) {\n        final List<CriticalHit> allCrits;\n        if (side == null) {\n            allCrits = new ArrayList<CriticalHit>();\n            for (final List<CriticalHit> sideCrits : critHits.values()) {\n                allCrits.addAll(sideCrits);\n            }\n        } else {\n            allCrits = critHits.get(side);\n        }\n        return allCrits;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#criticalHits(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int criticalHits(final CombatantSide side) {\n        return crits.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#criticalHitDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public long criticalHitDamage(final CombatantSide side) {\n        long sum = 0;\n        for (final CriticalHit crit : critList(side)) {\n            sum += crit.critOnlyDamage;\n        }\n        return sum;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#turnOrder(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public List<Combatant> turnOrder(final CombatantSide side) {\n        final List<Combatant> sidePlayers = new ArrayList<Combatant>(turnOrder.size() / 2);\n        for (final Combatant player : turnOrder) {\n            if (side == null || player.getSide() == side) {\n                sidePlayers.add(player);\n            }\n        }\n        return sidePlayers;\n    }\n\n    /**\n     * @return the number of shots per round\n     */\n    public Map<CombatantSide, ? extends LabeledData> getShotsPerRound() {\n        return shotsPerRound;\n    }\n\n    /**\n     * @return the number of hits per round\n     */\n    public Map<CombatantSide, ? extends LabeledData> getHitsPerRound() {\n        return hitsPerRound;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#getNotShootersPerRound()\n     */\n    public Map<CombatantSide, ? extends LabeledData> getNotShootersPerRound() {\n        final Map<CombatantSide, RoundStatistics> nonShootersPerRound = new HashMap<CombatantSide, RoundStatistics>();\n        for (final CombatantSide side : CombatantSide.values()) {\n            final RoundStatistics nonShooters = new RoundStatistics(\"Not shooting\", \"players\");\n            nonShootersPerRound.put(side, nonShooters);\n            final LabeledData shotRoundCounts = shotsPerRound.get(side);\n            if (shotRoundCounts != null) {\n                final double[] shotCounts = shotRoundCounts.toArray();\n                if (actorsPerRound.size() == shotCounts.length) {\n                    for (int i = 0; i < shotCounts.length; i++) {\n                        final int actors = actorsPerRound.get(i).getSideValue(side);\n                        final double numberNotShooting = actors - shotCounts[i];\n                        nonShooters.addValue(numberNotShooting);\n                    }\n                } else {\n                    LOG.warning(\"round statistics for players and shots differ!\");\n                }\n            } else {\n                LOG.warning(\"no data for players and shots for side \" + side);\n            }\n        }\n        return nonShootersPerRound;\n    }\n\n    private AreaStatistic getFieldStat(final Area area) {\n        if (!fieldStats.containsKey(area)) {\n            fieldStats.put(area, new AreaStatistic(area));\n        }\n        return fieldStats.get(area);\n    }\n\n    /**\n     * @return statistics for every field\n     */\n    public Map<Area, AreaStatistic> getFieldStatistics() {\n        return fieldStats;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/BattleStatistics_14Test.java",
		"test_prompt": "// BattleStatistics_14Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BattleStatistics}.\n* It contains ten unit test cases for the {@link BattleStatistics#numberOfHipFlasks(CombatantSide)} method.\n*/\nclass BattleStatistics_14Test {"
	},
	{
		"original_code": "// BattleStatistics.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\n\n/**\n * @author daniel\n */\npublic class BattleStatistics implements DynamicStatistics, CombatantObserver {\n\n    private static final transient Logger LOG = Logger.getLogger(BattleStatistics.class.getName());\n\n    private final Map<Combatant, OnlineCounter> onliners = new HashMap<Combatant, OnlineCounter>();\n\n    private final Map<CombatantSide, List<CriticalHit>> critHits = new HashMap<CombatantSide, List<CriticalHit>>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            critHits.put(side, new ArrayList<CriticalHit>());\n        }\n    }\n\n    private final Map<CombatantSide, Set<PositionSwitch>> swapList = new HashMap<CombatantSide, Set<PositionSwitch>>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            swapList.put(side, new HashSet<PositionSwitch>());\n        }\n    }\n\n    private final AllCombatantSidesCounter crits = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter moves = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter swaps = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter attackBonuses = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter defenseBonuses = new AllCombatantSidesCounter();\n\n    private final Map<Combatant, Counter> shots = new HashMap<Combatant, Counter>();\n\n    private final Map<CombatantSide, RoundStatistics> shotsPerRound = new HashMap<CombatantSide, RoundStatistics>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            shotsPerRound.put(side, new RoundStatistics(\"shots\", \"shots\"));\n        }\n    }\n\n    private final Map<CombatantSide, RoundStatistics> hitsPerRound = new HashMap<CombatantSide, RoundStatistics>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            hitsPerRound.put(side, new RoundStatistics(\"hits\", \"hits\"));\n        }\n    }\n\n    private final Map<CombatantSide, AtomicInteger> shotRoundCounter = new HashMap<CombatantSide, AtomicInteger>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            shotRoundCounter.put(side, new AtomicInteger());\n        }\n    }\n\n    private final Map<CombatantSide, AtomicInteger> hitRoundCounter = new HashMap<CombatantSide, AtomicInteger>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            hitRoundCounter.put(side, new AtomicInteger());\n        }\n    }\n\n    private final Map<Combatant, Counter> victims = new HashMap<Combatant, Counter>();\n\n    private final List<Combatant> turnOrder = new LinkedList<Combatant>();\n\n    private final List<AllCombatantSidesCounter> actorsPerRound = new ArrayList<AllCombatantSidesCounter>(50);\n\n    private final Map<Area, AreaStatistic> fieldStats = new HashMap<Area, AreaStatistic>();\n\n    private final int _numberOfDefenders;\n\n    private final int _numberOfAttacker;\n\n    private int currentRoundNo = 0;\n\n    private Boolean firstRound = null;\n\n    private AllCombatantSidesCounter actorsThisRound = new AllCombatantSidesCounter();\n\n    /**\n     * set the current round. all following method calls will belong to this\n     * round till this method is called again with another parameter.\n     *\n     * @param no\n     */\n    public void setRound(final int no) {\n        if (firstRound == null) {\n            firstRound = Boolean.TRUE;\n        } else if (firstRound.booleanValue()) {\n            firstRound = Boolean.FALSE;\n            // the turn order is determined only in the first round\n            for (final Combatant player : onliners.keySet()) {\n                if (!turnOrder.contains(player)) {\n                    LOG.info(\"could not determine turn order for \" + player);\n                }\n            }\n        }\n        addAndResetRoundCounter(shotRoundCounter, shotsPerRound);\n        addAndResetRoundCounter(hitRoundCounter, hitsPerRound);\n        actorsPerRound.add(actorsThisRound);\n        actorsThisRound = new AllCombatantSidesCounter();\n        currentRoundNo = no;\n    }\n\n    /**\n     * this adds the counters for the last round to the total counts per round\n     * and resets the given counter\n     *\n     * @param roundCounter\n     * @param allRounds\n     */\n    void addAndResetRoundCounter(final Map<CombatantSide, AtomicInteger> roundCounter, final Map<CombatantSide, RoundStatistics> allRounds) {\n        for (final Entry<CombatantSide, AtomicInteger> mapping : roundCounter.entrySet()) {\n            final CombatantSide side = mapping.getKey();\n            final AtomicInteger roundShots = mapping.getValue();\n            allRounds.get(side).addValue(roundShots.get());\n            // reset for next round\n            roundShots.set(0);\n        }\n    }\n\n    /**\n     * @param combatant\n     * @return\n     */\n    int combatantLifetime(final Combatant combatant) {\n        final OnlineCounter onAndOffline = onliners.get(combatant);\n        if (onAndOffline == null) {\n            return 0;\n        }\n        return onAndOffline.sumOfEvents();\n    }\n\n    /**\n     * @param numberOfAttacker\n     * @param numberOfDefenders\n     */\n    public BattleStatistics(final int numberOfAttacker, final int numberOfDefenders) {\n        _numberOfAttacker = numberOfAttacker;\n        _numberOfDefenders = numberOfDefenders;\n    }\n\n    /**\n     * @param number\n     * @return\n     */\n    int round(final double number) {\n        return (int) Math.round(number);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#percentAbleToShoot(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int percentAbleToShoot(final CombatantSide side) {\n        double sum = 0;\n        int players = 0;\n        for (final Entry<Combatant, Counter> playerShots : shots.entrySet()) {\n            final Combatant combatant = playerShots.getKey();\n            if (isOnSide(side, combatant)) {\n                final int lifetime = combatantLifetime(combatant);\n                final int roundsShooting = playerShots.getValue().getValue();\n                sum += roundsShooting * 100.0 / lifetime;\n                players++;\n            }\n        }\n        if (players == 0) {\n            return 0;\n        }\n        return round(sum / players);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#amountOfAttackBonus(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int amountOfAttackBonus(final CombatantSide side) {\n        return attackBonuses.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#amountOfDefenseBonus(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int amountOfDefenseBonus(final CombatantSide side) {\n        return defenseBonuses.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfMovesPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double numberOfMovesPerPlayer(final CombatantSide side) {\n        double result = 0;\n        switch(side) {\n            case ATTACKER:\n                result = moves.getSideValue(side) / (double) _numberOfAttacker;\n                break;\n            case DEFENDER:\n                result = moves.getSideValue(side) / (double) _numberOfDefenders;\n                break;\n            default:\n                result = moves.getSideValue(null) / (double) (_numberOfAttacker + _numberOfDefenders);\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfOffliners(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfOffliners(final CombatantSide side) {\n        int offliner = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (counter.wasOffline()) {\n                    offliner++;\n                }\n            }\n        }\n        return offliner;\n    }\n\n    /**\n     * @param side\n     * @param combatant\n     * @return\n     */\n    private boolean isOnSide(final CombatantSide side, final Combatant combatant) {\n        return side == null || side.equals(combatant.getSide());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#roundsTillOnline(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double roundsTillOnline(final CombatantSide side) {\n        int combatants = 0;\n        int rounds = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (!counter.wasOffline()) {\n                    combatants++;\n                    rounds += counter.firstOnline();\n                }\n            }\n        }\n        // avoid division by zero\n        if (combatants == 0) {\n            return 0;\n        }\n        return ((double) rounds / (double) combatants);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#averageRoundsOnline(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageRoundsOnline(final CombatantSide side) {\n        double combatants = 0;\n        double rounds = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (!counter.wasOffline()) {\n                    combatants++;\n                    rounds += counter.onlineEvents();\n                }\n            }\n        }\n        // avoid division by zero\n        if (combatants == 0.0) {\n            return 0.0;\n        }\n        return rounds / combatants;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#hasMoved(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Area)\n     */\n    public void hasMoved(final Combatant combatant, final Area newPos) {\n        moves.incrementSide(combatant);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#newDestination(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Area)\n     */\n    public void newDestination(final Combatant combatant, final Area destination) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#aimsAt(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void aimsAt(final Combatant combatant, final Combatant target) {\n        incrementCombatantCounter(shots, combatant);\n        incrementCombatantCounter(victims, target);\n        shotRoundCounter.get(combatant.getSide()).incrementAndGet();\n        final Area field = target._getLocation();\n        getFieldStat(field).addShot();\n    }\n\n    private void incrementCombatantCounter(final Map<Combatant, Counter> combatantCounters, final Combatant combatant) {\n        if (!combatantCounters.containsKey(combatant)) {\n            combatantCounters.put(combatant, new Counter());\n        }\n        combatantCounters.get(combatant).increment();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isHit(de.outstare.fortbattleplayer.model.Combatant,\n     *      int, int)\n     */\n    public void isHit(final Combatant combatant, final int damage, final int oldHealthAmount) {\n        hitRoundCounter.get(combatant.getSide()).incrementAndGet();\n        final Area field = combatant._getLocation();\n        getFieldStat(field).addHit();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isDead(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void isDead(final Combatant combatant) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isAlive(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void isAlive(final Combatant combatant) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isOnline(de.outstare.fortbattleplayer.model.Combatant,\n     *      boolean)\n     */\n    public void isOnline(final Combatant combatant, final boolean changed) {\n        // count all events\n        if (!onliners.containsKey(combatant)) {\n            onliners.put(combatant, new OnlineCounter());\n        }\n        if (combatant.isOnline()) {\n            onliners.get(combatant).addOnline();\n        } else {\n            onliners.get(combatant).addOffline();\n        }\n        // the online event is triggered every round for a player (hopefully)\n        combatantTurn(combatant);\n    }\n\n    /**\n     * no special action, just to track the state every round\n     *\n     * @param combatant\n     */\n    private void combatantTurn(final Combatant combatant) {\n        final SectorBonus bonus = combatant.getSectorBonus();\n        attackBonuses.incrementBy(bonus.attackBonus, combatant);\n        defenseBonuses.incrementBy(bonus.defendBonus, combatant);\n        if (firstRound != null && firstRound.booleanValue()) {\n            turnOrder.add(combatant);\n        }\n        if (LOG.isLoggable(Level.FINE)) {\n            if ((firstRound == null || !firstRound.booleanValue()) && !turnOrder.contains(combatant) && currentRoundNo > 1) {\n                LOG.fine(\"---- not in order: \" + combatant);\n            }\n        }\n        actorsThisRound.incrementSide(combatant);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#targetNoOne(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public String targetNoOne(final CombatantSide side) {\n        String result = \"\";\n        int max = 0;\n        for (final Entry<Combatant, Counter> victim : victims.entrySet()) {\n            final Combatant combatant = victim.getKey();\n            if (isOnSide(side, combatant)) {\n                final int receivedShots = victim.getValue().getValue();\n                if (receivedShots > max) {\n                    max = receivedShots;\n                    result = combatant.getName() + \"(\" + receivedShots + \")\";\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfBayonets(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfBayonets(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.BayonetCounter());\n    }\n\n    /**\n     * @param side\n     * @param counter\n     * @return\n     */\n    int countWeaponMods(final CombatantSide side, final WeaponModCounter counter) {\n        // because every player should have an online/offline event, we look at\n        // the online data hoping to get all players\n        final Set<Combatant> players = onliners.keySet();\n        int bayonets = 0;\n        for (final Combatant combatant : players) {\n            if (isOnSide(side, combatant)) {\n                final Weapon playerWeapon = combatant.getWeapon();\n                // TODO let the counter count\n                if (counter.counts(playerWeapon)) {\n                    bayonets++;\n                }\n            }\n        }\n        return bayonets;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfGraphitLubricants(CombatantSide)\n     */\n    public int numberOfGraphitLubricants(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.GraphitLubricantCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfFettesOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfFettesOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.FettesOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfSchmierOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfSchmierOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.SchmierOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfShinyOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfShinyOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.ShinyOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfLoadingChamerOrEnhancedPatrons(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfLoadingChamerOrEnhancedPatrons(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.LoadingchamberOrEnhancedPatronsCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfHipFlasks(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfHipFlasks(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.HipFlaskCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#hasSwappedPosition()\n     */\n    public void hasSwappedPosition(final Combatant combatant, final Combatant swappedWith) {\n        swaps.incrementSide(combatant);\n        final PositionSwitch swap = new PositionSwitch(currentRoundNo, combatant, swappedWith);\n        assert swapList.get(combatant.getSide()) != null;\n        swapList.get(combatant.getSide()).add(swap);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#totalSwaps(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int totalSwaps(final CombatantSide side) {\n        return swaps.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#switchedPosList(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public Set<PositionSwitch> switchedPosList(final CombatantSide side) {\n        final Set<PositionSwitch> allSwaps;\n        if (side == null) {\n            allSwaps = new HashSet<PositionSwitch>();\n            for (final Set<PositionSwitch> sideSwitches : swapList.values()) {\n                allSwaps.addAll(sideSwitches);\n            }\n        } else {\n            allSwaps = swapList.get(side);\n        }\n        return allSwaps;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#criticalShot(de.outstare.fortbattleplayer.model.Combatant,\n     *      Combatant, int)\n     */\n    public void criticalShot(final Combatant combatant, final Combatant victim, final int damage) {\n        final CriticalHit crit = new CriticalHit(combatant, victim, damage, currentRoundNo);\n        critHits.get(combatant.getSide()).add(crit);\n        crits.incrementSide(combatant);\n        final Area field = victim._getLocation();\n        getFieldStat(field).addCrit();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#critList(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public List<CriticalHit> critList(final CombatantSide side) {\n        final List<CriticalHit> allCrits;\n        if (side == null) {\n            allCrits = new ArrayList<CriticalHit>();\n            for (final List<CriticalHit> sideCrits : critHits.values()) {\n                allCrits.addAll(sideCrits);\n            }\n        } else {\n            allCrits = critHits.get(side);\n        }\n        return allCrits;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#criticalHits(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int criticalHits(final CombatantSide side) {\n        return crits.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#criticalHitDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public long criticalHitDamage(final CombatantSide side) {\n        long sum = 0;\n        for (final CriticalHit crit : critList(side)) {\n            sum += crit.critOnlyDamage;\n        }\n        return sum;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#turnOrder(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public List<Combatant> turnOrder(final CombatantSide side) {\n        final List<Combatant> sidePlayers = new ArrayList<Combatant>(turnOrder.size() / 2);\n        for (final Combatant player : turnOrder) {\n            if (side == null || player.getSide() == side) {\n                sidePlayers.add(player);\n            }\n        }\n        return sidePlayers;\n    }\n\n    /**\n     * @return the number of shots per round\n     */\n    public Map<CombatantSide, ? extends LabeledData> getShotsPerRound() {\n        return shotsPerRound;\n    }\n\n    /**\n     * @return the number of hits per round\n     */\n    public Map<CombatantSide, ? extends LabeledData> getHitsPerRound() {\n        return hitsPerRound;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#getNotShootersPerRound()\n     */\n    public Map<CombatantSide, ? extends LabeledData> getNotShootersPerRound() {\n        final Map<CombatantSide, RoundStatistics> nonShootersPerRound = new HashMap<CombatantSide, RoundStatistics>();\n        for (final CombatantSide side : CombatantSide.values()) {\n            final RoundStatistics nonShooters = new RoundStatistics(\"Not shooting\", \"players\");\n            nonShootersPerRound.put(side, nonShooters);\n            final LabeledData shotRoundCounts = shotsPerRound.get(side);\n            if (shotRoundCounts != null) {\n                final double[] shotCounts = shotRoundCounts.toArray();\n                if (actorsPerRound.size() == shotCounts.length) {\n                    for (int i = 0; i < shotCounts.length; i++) {\n                        final int actors = actorsPerRound.get(i).getSideValue(side);\n                        final double numberNotShooting = actors - shotCounts[i];\n                        nonShooters.addValue(numberNotShooting);\n                    }\n                } else {\n                    LOG.warning(\"round statistics for players and shots differ!\");\n                }\n            } else {\n                LOG.warning(\"no data for players and shots for side \" + side);\n            }\n        }\n        return nonShootersPerRound;\n    }\n\n    private AreaStatistic getFieldStat(final Area area) {\n        if (!fieldStats.containsKey(area)) {\n            fieldStats.put(area, new AreaStatistic(area));\n        }\n        return fieldStats.get(area);\n    }\n\n    /**\n     * @return statistics for every field\n     */\n    public Map<Area, AreaStatistic> getFieldStatistics() {\n        return fieldStats;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/BattleStatistics_15Test.java",
		"test_prompt": "// BattleStatistics_15Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BattleStatistics}.\n* It contains ten unit test cases for the {@link BattleStatistics#totalSwaps(CombatantSide)} method.\n*/\nclass BattleStatistics_15Test {"
	},
	{
		"original_code": "// BattleStatistics.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\n\n/**\n * @author daniel\n */\npublic class BattleStatistics implements DynamicStatistics, CombatantObserver {\n\n    private static final transient Logger LOG = Logger.getLogger(BattleStatistics.class.getName());\n\n    private final Map<Combatant, OnlineCounter> onliners = new HashMap<Combatant, OnlineCounter>();\n\n    private final Map<CombatantSide, List<CriticalHit>> critHits = new HashMap<CombatantSide, List<CriticalHit>>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            critHits.put(side, new ArrayList<CriticalHit>());\n        }\n    }\n\n    private final Map<CombatantSide, Set<PositionSwitch>> swapList = new HashMap<CombatantSide, Set<PositionSwitch>>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            swapList.put(side, new HashSet<PositionSwitch>());\n        }\n    }\n\n    private final AllCombatantSidesCounter crits = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter moves = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter swaps = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter attackBonuses = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter defenseBonuses = new AllCombatantSidesCounter();\n\n    private final Map<Combatant, Counter> shots = new HashMap<Combatant, Counter>();\n\n    private final Map<CombatantSide, RoundStatistics> shotsPerRound = new HashMap<CombatantSide, RoundStatistics>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            shotsPerRound.put(side, new RoundStatistics(\"shots\", \"shots\"));\n        }\n    }\n\n    private final Map<CombatantSide, RoundStatistics> hitsPerRound = new HashMap<CombatantSide, RoundStatistics>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            hitsPerRound.put(side, new RoundStatistics(\"hits\", \"hits\"));\n        }\n    }\n\n    private final Map<CombatantSide, AtomicInteger> shotRoundCounter = new HashMap<CombatantSide, AtomicInteger>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            shotRoundCounter.put(side, new AtomicInteger());\n        }\n    }\n\n    private final Map<CombatantSide, AtomicInteger> hitRoundCounter = new HashMap<CombatantSide, AtomicInteger>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            hitRoundCounter.put(side, new AtomicInteger());\n        }\n    }\n\n    private final Map<Combatant, Counter> victims = new HashMap<Combatant, Counter>();\n\n    private final List<Combatant> turnOrder = new LinkedList<Combatant>();\n\n    private final List<AllCombatantSidesCounter> actorsPerRound = new ArrayList<AllCombatantSidesCounter>(50);\n\n    private final Map<Area, AreaStatistic> fieldStats = new HashMap<Area, AreaStatistic>();\n\n    private final int _numberOfDefenders;\n\n    private final int _numberOfAttacker;\n\n    private int currentRoundNo = 0;\n\n    private Boolean firstRound = null;\n\n    private AllCombatantSidesCounter actorsThisRound = new AllCombatantSidesCounter();\n\n    /**\n     * set the current round. all following method calls will belong to this\n     * round till this method is called again with another parameter.\n     *\n     * @param no\n     */\n    public void setRound(final int no) {\n        if (firstRound == null) {\n            firstRound = Boolean.TRUE;\n        } else if (firstRound.booleanValue()) {\n            firstRound = Boolean.FALSE;\n            // the turn order is determined only in the first round\n            for (final Combatant player : onliners.keySet()) {\n                if (!turnOrder.contains(player)) {\n                    LOG.info(\"could not determine turn order for \" + player);\n                }\n            }\n        }\n        addAndResetRoundCounter(shotRoundCounter, shotsPerRound);\n        addAndResetRoundCounter(hitRoundCounter, hitsPerRound);\n        actorsPerRound.add(actorsThisRound);\n        actorsThisRound = new AllCombatantSidesCounter();\n        currentRoundNo = no;\n    }\n\n    /**\n     * this adds the counters for the last round to the total counts per round\n     * and resets the given counter\n     *\n     * @param roundCounter\n     * @param allRounds\n     */\n    void addAndResetRoundCounter(final Map<CombatantSide, AtomicInteger> roundCounter, final Map<CombatantSide, RoundStatistics> allRounds) {\n        for (final Entry<CombatantSide, AtomicInteger> mapping : roundCounter.entrySet()) {\n            final CombatantSide side = mapping.getKey();\n            final AtomicInteger roundShots = mapping.getValue();\n            allRounds.get(side).addValue(roundShots.get());\n            // reset for next round\n            roundShots.set(0);\n        }\n    }\n\n    /**\n     * @param combatant\n     * @return\n     */\n    int combatantLifetime(final Combatant combatant) {\n        final OnlineCounter onAndOffline = onliners.get(combatant);\n        if (onAndOffline == null) {\n            return 0;\n        }\n        return onAndOffline.sumOfEvents();\n    }\n\n    /**\n     * @param numberOfAttacker\n     * @param numberOfDefenders\n     */\n    public BattleStatistics(final int numberOfAttacker, final int numberOfDefenders) {\n        _numberOfAttacker = numberOfAttacker;\n        _numberOfDefenders = numberOfDefenders;\n    }\n\n    /**\n     * @param number\n     * @return\n     */\n    int round(final double number) {\n        return (int) Math.round(number);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#percentAbleToShoot(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int percentAbleToShoot(final CombatantSide side) {\n        double sum = 0;\n        int players = 0;\n        for (final Entry<Combatant, Counter> playerShots : shots.entrySet()) {\n            final Combatant combatant = playerShots.getKey();\n            if (isOnSide(side, combatant)) {\n                final int lifetime = combatantLifetime(combatant);\n                final int roundsShooting = playerShots.getValue().getValue();\n                sum += roundsShooting * 100.0 / lifetime;\n                players++;\n            }\n        }\n        if (players == 0) {\n            return 0;\n        }\n        return round(sum / players);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#amountOfAttackBonus(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int amountOfAttackBonus(final CombatantSide side) {\n        return attackBonuses.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#amountOfDefenseBonus(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int amountOfDefenseBonus(final CombatantSide side) {\n        return defenseBonuses.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfMovesPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double numberOfMovesPerPlayer(final CombatantSide side) {\n        double result = 0;\n        switch(side) {\n            case ATTACKER:\n                result = moves.getSideValue(side) / (double) _numberOfAttacker;\n                break;\n            case DEFENDER:\n                result = moves.getSideValue(side) / (double) _numberOfDefenders;\n                break;\n            default:\n                result = moves.getSideValue(null) / (double) (_numberOfAttacker + _numberOfDefenders);\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfOffliners(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfOffliners(final CombatantSide side) {\n        int offliner = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (counter.wasOffline()) {\n                    offliner++;\n                }\n            }\n        }\n        return offliner;\n    }\n\n    /**\n     * @param side\n     * @param combatant\n     * @return\n     */\n    private boolean isOnSide(final CombatantSide side, final Combatant combatant) {\n        return side == null || side.equals(combatant.getSide());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#roundsTillOnline(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double roundsTillOnline(final CombatantSide side) {\n        int combatants = 0;\n        int rounds = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (!counter.wasOffline()) {\n                    combatants++;\n                    rounds += counter.firstOnline();\n                }\n            }\n        }\n        // avoid division by zero\n        if (combatants == 0) {\n            return 0;\n        }\n        return ((double) rounds / (double) combatants);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#averageRoundsOnline(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageRoundsOnline(final CombatantSide side) {\n        double combatants = 0;\n        double rounds = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (!counter.wasOffline()) {\n                    combatants++;\n                    rounds += counter.onlineEvents();\n                }\n            }\n        }\n        // avoid division by zero\n        if (combatants == 0.0) {\n            return 0.0;\n        }\n        return rounds / combatants;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#hasMoved(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Area)\n     */\n    public void hasMoved(final Combatant combatant, final Area newPos) {\n        moves.incrementSide(combatant);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#newDestination(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Area)\n     */\n    public void newDestination(final Combatant combatant, final Area destination) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#aimsAt(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void aimsAt(final Combatant combatant, final Combatant target) {\n        incrementCombatantCounter(shots, combatant);\n        incrementCombatantCounter(victims, target);\n        shotRoundCounter.get(combatant.getSide()).incrementAndGet();\n        final Area field = target._getLocation();\n        getFieldStat(field).addShot();\n    }\n\n    private void incrementCombatantCounter(final Map<Combatant, Counter> combatantCounters, final Combatant combatant) {\n        if (!combatantCounters.containsKey(combatant)) {\n            combatantCounters.put(combatant, new Counter());\n        }\n        combatantCounters.get(combatant).increment();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isHit(de.outstare.fortbattleplayer.model.Combatant,\n     *      int, int)\n     */\n    public void isHit(final Combatant combatant, final int damage, final int oldHealthAmount) {\n        hitRoundCounter.get(combatant.getSide()).incrementAndGet();\n        final Area field = combatant._getLocation();\n        getFieldStat(field).addHit();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isDead(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void isDead(final Combatant combatant) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isAlive(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void isAlive(final Combatant combatant) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isOnline(de.outstare.fortbattleplayer.model.Combatant,\n     *      boolean)\n     */\n    public void isOnline(final Combatant combatant, final boolean changed) {\n        // count all events\n        if (!onliners.containsKey(combatant)) {\n            onliners.put(combatant, new OnlineCounter());\n        }\n        if (combatant.isOnline()) {\n            onliners.get(combatant).addOnline();\n        } else {\n            onliners.get(combatant).addOffline();\n        }\n        // the online event is triggered every round for a player (hopefully)\n        combatantTurn(combatant);\n    }\n\n    /**\n     * no special action, just to track the state every round\n     *\n     * @param combatant\n     */\n    private void combatantTurn(final Combatant combatant) {\n        final SectorBonus bonus = combatant.getSectorBonus();\n        attackBonuses.incrementBy(bonus.attackBonus, combatant);\n        defenseBonuses.incrementBy(bonus.defendBonus, combatant);\n        if (firstRound != null && firstRound.booleanValue()) {\n            turnOrder.add(combatant);\n        }\n        if (LOG.isLoggable(Level.FINE)) {\n            if ((firstRound == null || !firstRound.booleanValue()) && !turnOrder.contains(combatant) && currentRoundNo > 1) {\n                LOG.fine(\"---- not in order: \" + combatant);\n            }\n        }\n        actorsThisRound.incrementSide(combatant);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#targetNoOne(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public String targetNoOne(final CombatantSide side) {\n        String result = \"\";\n        int max = 0;\n        for (final Entry<Combatant, Counter> victim : victims.entrySet()) {\n            final Combatant combatant = victim.getKey();\n            if (isOnSide(side, combatant)) {\n                final int receivedShots = victim.getValue().getValue();\n                if (receivedShots > max) {\n                    max = receivedShots;\n                    result = combatant.getName() + \"(\" + receivedShots + \")\";\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfBayonets(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfBayonets(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.BayonetCounter());\n    }\n\n    /**\n     * @param side\n     * @param counter\n     * @return\n     */\n    int countWeaponMods(final CombatantSide side, final WeaponModCounter counter) {\n        // because every player should have an online/offline event, we look at\n        // the online data hoping to get all players\n        final Set<Combatant> players = onliners.keySet();\n        int bayonets = 0;\n        for (final Combatant combatant : players) {\n            if (isOnSide(side, combatant)) {\n                final Weapon playerWeapon = combatant.getWeapon();\n                // TODO let the counter count\n                if (counter.counts(playerWeapon)) {\n                    bayonets++;\n                }\n            }\n        }\n        return bayonets;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfGraphitLubricants(CombatantSide)\n     */\n    public int numberOfGraphitLubricants(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.GraphitLubricantCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfFettesOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfFettesOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.FettesOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfSchmierOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfSchmierOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.SchmierOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfShinyOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfShinyOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.ShinyOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfLoadingChamerOrEnhancedPatrons(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfLoadingChamerOrEnhancedPatrons(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.LoadingchamberOrEnhancedPatronsCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfHipFlasks(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfHipFlasks(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.HipFlaskCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#hasSwappedPosition()\n     */\n    public void hasSwappedPosition(final Combatant combatant, final Combatant swappedWith) {\n        swaps.incrementSide(combatant);\n        final PositionSwitch swap = new PositionSwitch(currentRoundNo, combatant, swappedWith);\n        assert swapList.get(combatant.getSide()) != null;\n        swapList.get(combatant.getSide()).add(swap);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#totalSwaps(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int totalSwaps(final CombatantSide side) {\n        return swaps.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#switchedPosList(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public Set<PositionSwitch> switchedPosList(final CombatantSide side) {\n        final Set<PositionSwitch> allSwaps;\n        if (side == null) {\n            allSwaps = new HashSet<PositionSwitch>();\n            for (final Set<PositionSwitch> sideSwitches : swapList.values()) {\n                allSwaps.addAll(sideSwitches);\n            }\n        } else {\n            allSwaps = swapList.get(side);\n        }\n        return allSwaps;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#criticalShot(de.outstare.fortbattleplayer.model.Combatant,\n     *      Combatant, int)\n     */\n    public void criticalShot(final Combatant combatant, final Combatant victim, final int damage) {\n        final CriticalHit crit = new CriticalHit(combatant, victim, damage, currentRoundNo);\n        critHits.get(combatant.getSide()).add(crit);\n        crits.incrementSide(combatant);\n        final Area field = victim._getLocation();\n        getFieldStat(field).addCrit();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#critList(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public List<CriticalHit> critList(final CombatantSide side) {\n        final List<CriticalHit> allCrits;\n        if (side == null) {\n            allCrits = new ArrayList<CriticalHit>();\n            for (final List<CriticalHit> sideCrits : critHits.values()) {\n                allCrits.addAll(sideCrits);\n            }\n        } else {\n            allCrits = critHits.get(side);\n        }\n        return allCrits;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#criticalHits(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int criticalHits(final CombatantSide side) {\n        return crits.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#criticalHitDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public long criticalHitDamage(final CombatantSide side) {\n        long sum = 0;\n        for (final CriticalHit crit : critList(side)) {\n            sum += crit.critOnlyDamage;\n        }\n        return sum;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#turnOrder(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public List<Combatant> turnOrder(final CombatantSide side) {\n        final List<Combatant> sidePlayers = new ArrayList<Combatant>(turnOrder.size() / 2);\n        for (final Combatant player : turnOrder) {\n            if (side == null || player.getSide() == side) {\n                sidePlayers.add(player);\n            }\n        }\n        return sidePlayers;\n    }\n\n    /**\n     * @return the number of shots per round\n     */\n    public Map<CombatantSide, ? extends LabeledData> getShotsPerRound() {\n        return shotsPerRound;\n    }\n\n    /**\n     * @return the number of hits per round\n     */\n    public Map<CombatantSide, ? extends LabeledData> getHitsPerRound() {\n        return hitsPerRound;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#getNotShootersPerRound()\n     */\n    public Map<CombatantSide, ? extends LabeledData> getNotShootersPerRound() {\n        final Map<CombatantSide, RoundStatistics> nonShootersPerRound = new HashMap<CombatantSide, RoundStatistics>();\n        for (final CombatantSide side : CombatantSide.values()) {\n            final RoundStatistics nonShooters = new RoundStatistics(\"Not shooting\", \"players\");\n            nonShootersPerRound.put(side, nonShooters);\n            final LabeledData shotRoundCounts = shotsPerRound.get(side);\n            if (shotRoundCounts != null) {\n                final double[] shotCounts = shotRoundCounts.toArray();\n                if (actorsPerRound.size() == shotCounts.length) {\n                    for (int i = 0; i < shotCounts.length; i++) {\n                        final int actors = actorsPerRound.get(i).getSideValue(side);\n                        final double numberNotShooting = actors - shotCounts[i];\n                        nonShooters.addValue(numberNotShooting);\n                    }\n                } else {\n                    LOG.warning(\"round statistics for players and shots differ!\");\n                }\n            } else {\n                LOG.warning(\"no data for players and shots for side \" + side);\n            }\n        }\n        return nonShootersPerRound;\n    }\n\n    private AreaStatistic getFieldStat(final Area area) {\n        if (!fieldStats.containsKey(area)) {\n            fieldStats.put(area, new AreaStatistic(area));\n        }\n        return fieldStats.get(area);\n    }\n\n    /**\n     * @return statistics for every field\n     */\n    public Map<Area, AreaStatistic> getFieldStatistics() {\n        return fieldStats;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/BattleStatistics_16Test.java",
		"test_prompt": "// BattleStatistics_16Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BattleStatistics}.\n* It contains ten unit test cases for the {@link BattleStatistics#switchedPosList(CombatantSide)} method.\n*/\nclass BattleStatistics_16Test {"
	},
	{
		"original_code": "// BattleStatistics.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\n\n/**\n * @author daniel\n */\npublic class BattleStatistics implements DynamicStatistics, CombatantObserver {\n\n    private static final transient Logger LOG = Logger.getLogger(BattleStatistics.class.getName());\n\n    private final Map<Combatant, OnlineCounter> onliners = new HashMap<Combatant, OnlineCounter>();\n\n    private final Map<CombatantSide, List<CriticalHit>> critHits = new HashMap<CombatantSide, List<CriticalHit>>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            critHits.put(side, new ArrayList<CriticalHit>());\n        }\n    }\n\n    private final Map<CombatantSide, Set<PositionSwitch>> swapList = new HashMap<CombatantSide, Set<PositionSwitch>>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            swapList.put(side, new HashSet<PositionSwitch>());\n        }\n    }\n\n    private final AllCombatantSidesCounter crits = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter moves = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter swaps = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter attackBonuses = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter defenseBonuses = new AllCombatantSidesCounter();\n\n    private final Map<Combatant, Counter> shots = new HashMap<Combatant, Counter>();\n\n    private final Map<CombatantSide, RoundStatistics> shotsPerRound = new HashMap<CombatantSide, RoundStatistics>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            shotsPerRound.put(side, new RoundStatistics(\"shots\", \"shots\"));\n        }\n    }\n\n    private final Map<CombatantSide, RoundStatistics> hitsPerRound = new HashMap<CombatantSide, RoundStatistics>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            hitsPerRound.put(side, new RoundStatistics(\"hits\", \"hits\"));\n        }\n    }\n\n    private final Map<CombatantSide, AtomicInteger> shotRoundCounter = new HashMap<CombatantSide, AtomicInteger>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            shotRoundCounter.put(side, new AtomicInteger());\n        }\n    }\n\n    private final Map<CombatantSide, AtomicInteger> hitRoundCounter = new HashMap<CombatantSide, AtomicInteger>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            hitRoundCounter.put(side, new AtomicInteger());\n        }\n    }\n\n    private final Map<Combatant, Counter> victims = new HashMap<Combatant, Counter>();\n\n    private final List<Combatant> turnOrder = new LinkedList<Combatant>();\n\n    private final List<AllCombatantSidesCounter> actorsPerRound = new ArrayList<AllCombatantSidesCounter>(50);\n\n    private final Map<Area, AreaStatistic> fieldStats = new HashMap<Area, AreaStatistic>();\n\n    private final int _numberOfDefenders;\n\n    private final int _numberOfAttacker;\n\n    private int currentRoundNo = 0;\n\n    private Boolean firstRound = null;\n\n    private AllCombatantSidesCounter actorsThisRound = new AllCombatantSidesCounter();\n\n    /**\n     * set the current round. all following method calls will belong to this\n     * round till this method is called again with another parameter.\n     *\n     * @param no\n     */\n    public void setRound(final int no) {\n        if (firstRound == null) {\n            firstRound = Boolean.TRUE;\n        } else if (firstRound.booleanValue()) {\n            firstRound = Boolean.FALSE;\n            // the turn order is determined only in the first round\n            for (final Combatant player : onliners.keySet()) {\n                if (!turnOrder.contains(player)) {\n                    LOG.info(\"could not determine turn order for \" + player);\n                }\n            }\n        }\n        addAndResetRoundCounter(shotRoundCounter, shotsPerRound);\n        addAndResetRoundCounter(hitRoundCounter, hitsPerRound);\n        actorsPerRound.add(actorsThisRound);\n        actorsThisRound = new AllCombatantSidesCounter();\n        currentRoundNo = no;\n    }\n\n    /**\n     * this adds the counters for the last round to the total counts per round\n     * and resets the given counter\n     *\n     * @param roundCounter\n     * @param allRounds\n     */\n    void addAndResetRoundCounter(final Map<CombatantSide, AtomicInteger> roundCounter, final Map<CombatantSide, RoundStatistics> allRounds) {\n        for (final Entry<CombatantSide, AtomicInteger> mapping : roundCounter.entrySet()) {\n            final CombatantSide side = mapping.getKey();\n            final AtomicInteger roundShots = mapping.getValue();\n            allRounds.get(side).addValue(roundShots.get());\n            // reset for next round\n            roundShots.set(0);\n        }\n    }\n\n    /**\n     * @param combatant\n     * @return\n     */\n    int combatantLifetime(final Combatant combatant) {\n        final OnlineCounter onAndOffline = onliners.get(combatant);\n        if (onAndOffline == null) {\n            return 0;\n        }\n        return onAndOffline.sumOfEvents();\n    }\n\n    /**\n     * @param numberOfAttacker\n     * @param numberOfDefenders\n     */\n    public BattleStatistics(final int numberOfAttacker, final int numberOfDefenders) {\n        _numberOfAttacker = numberOfAttacker;\n        _numberOfDefenders = numberOfDefenders;\n    }\n\n    /**\n     * @param number\n     * @return\n     */\n    int round(final double number) {\n        return (int) Math.round(number);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#percentAbleToShoot(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int percentAbleToShoot(final CombatantSide side) {\n        double sum = 0;\n        int players = 0;\n        for (final Entry<Combatant, Counter> playerShots : shots.entrySet()) {\n            final Combatant combatant = playerShots.getKey();\n            if (isOnSide(side, combatant)) {\n                final int lifetime = combatantLifetime(combatant);\n                final int roundsShooting = playerShots.getValue().getValue();\n                sum += roundsShooting * 100.0 / lifetime;\n                players++;\n            }\n        }\n        if (players == 0) {\n            return 0;\n        }\n        return round(sum / players);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#amountOfAttackBonus(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int amountOfAttackBonus(final CombatantSide side) {\n        return attackBonuses.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#amountOfDefenseBonus(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int amountOfDefenseBonus(final CombatantSide side) {\n        return defenseBonuses.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfMovesPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double numberOfMovesPerPlayer(final CombatantSide side) {\n        double result = 0;\n        switch(side) {\n            case ATTACKER:\n                result = moves.getSideValue(side) / (double) _numberOfAttacker;\n                break;\n            case DEFENDER:\n                result = moves.getSideValue(side) / (double) _numberOfDefenders;\n                break;\n            default:\n                result = moves.getSideValue(null) / (double) (_numberOfAttacker + _numberOfDefenders);\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfOffliners(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfOffliners(final CombatantSide side) {\n        int offliner = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (counter.wasOffline()) {\n                    offliner++;\n                }\n            }\n        }\n        return offliner;\n    }\n\n    /**\n     * @param side\n     * @param combatant\n     * @return\n     */\n    private boolean isOnSide(final CombatantSide side, final Combatant combatant) {\n        return side == null || side.equals(combatant.getSide());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#roundsTillOnline(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double roundsTillOnline(final CombatantSide side) {\n        int combatants = 0;\n        int rounds = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (!counter.wasOffline()) {\n                    combatants++;\n                    rounds += counter.firstOnline();\n                }\n            }\n        }\n        // avoid division by zero\n        if (combatants == 0) {\n            return 0;\n        }\n        return ((double) rounds / (double) combatants);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#averageRoundsOnline(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageRoundsOnline(final CombatantSide side) {\n        double combatants = 0;\n        double rounds = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (!counter.wasOffline()) {\n                    combatants++;\n                    rounds += counter.onlineEvents();\n                }\n            }\n        }\n        // avoid division by zero\n        if (combatants == 0.0) {\n            return 0.0;\n        }\n        return rounds / combatants;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#hasMoved(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Area)\n     */\n    public void hasMoved(final Combatant combatant, final Area newPos) {\n        moves.incrementSide(combatant);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#newDestination(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Area)\n     */\n    public void newDestination(final Combatant combatant, final Area destination) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#aimsAt(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void aimsAt(final Combatant combatant, final Combatant target) {\n        incrementCombatantCounter(shots, combatant);\n        incrementCombatantCounter(victims, target);\n        shotRoundCounter.get(combatant.getSide()).incrementAndGet();\n        final Area field = target._getLocation();\n        getFieldStat(field).addShot();\n    }\n\n    private void incrementCombatantCounter(final Map<Combatant, Counter> combatantCounters, final Combatant combatant) {\n        if (!combatantCounters.containsKey(combatant)) {\n            combatantCounters.put(combatant, new Counter());\n        }\n        combatantCounters.get(combatant).increment();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isHit(de.outstare.fortbattleplayer.model.Combatant,\n     *      int, int)\n     */\n    public void isHit(final Combatant combatant, final int damage, final int oldHealthAmount) {\n        hitRoundCounter.get(combatant.getSide()).incrementAndGet();\n        final Area field = combatant._getLocation();\n        getFieldStat(field).addHit();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isDead(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void isDead(final Combatant combatant) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isAlive(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void isAlive(final Combatant combatant) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isOnline(de.outstare.fortbattleplayer.model.Combatant,\n     *      boolean)\n     */\n    public void isOnline(final Combatant combatant, final boolean changed) {\n        // count all events\n        if (!onliners.containsKey(combatant)) {\n            onliners.put(combatant, new OnlineCounter());\n        }\n        if (combatant.isOnline()) {\n            onliners.get(combatant).addOnline();\n        } else {\n            onliners.get(combatant).addOffline();\n        }\n        // the online event is triggered every round for a player (hopefully)\n        combatantTurn(combatant);\n    }\n\n    /**\n     * no special action, just to track the state every round\n     *\n     * @param combatant\n     */\n    private void combatantTurn(final Combatant combatant) {\n        final SectorBonus bonus = combatant.getSectorBonus();\n        attackBonuses.incrementBy(bonus.attackBonus, combatant);\n        defenseBonuses.incrementBy(bonus.defendBonus, combatant);\n        if (firstRound != null && firstRound.booleanValue()) {\n            turnOrder.add(combatant);\n        }\n        if (LOG.isLoggable(Level.FINE)) {\n            if ((firstRound == null || !firstRound.booleanValue()) && !turnOrder.contains(combatant) && currentRoundNo > 1) {\n                LOG.fine(\"---- not in order: \" + combatant);\n            }\n        }\n        actorsThisRound.incrementSide(combatant);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#targetNoOne(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public String targetNoOne(final CombatantSide side) {\n        String result = \"\";\n        int max = 0;\n        for (final Entry<Combatant, Counter> victim : victims.entrySet()) {\n            final Combatant combatant = victim.getKey();\n            if (isOnSide(side, combatant)) {\n                final int receivedShots = victim.getValue().getValue();\n                if (receivedShots > max) {\n                    max = receivedShots;\n                    result = combatant.getName() + \"(\" + receivedShots + \")\";\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfBayonets(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfBayonets(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.BayonetCounter());\n    }\n\n    /**\n     * @param side\n     * @param counter\n     * @return\n     */\n    int countWeaponMods(final CombatantSide side, final WeaponModCounter counter) {\n        // because every player should have an online/offline event, we look at\n        // the online data hoping to get all players\n        final Set<Combatant> players = onliners.keySet();\n        int bayonets = 0;\n        for (final Combatant combatant : players) {\n            if (isOnSide(side, combatant)) {\n                final Weapon playerWeapon = combatant.getWeapon();\n                // TODO let the counter count\n                if (counter.counts(playerWeapon)) {\n                    bayonets++;\n                }\n            }\n        }\n        return bayonets;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfGraphitLubricants(CombatantSide)\n     */\n    public int numberOfGraphitLubricants(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.GraphitLubricantCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfFettesOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfFettesOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.FettesOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfSchmierOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfSchmierOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.SchmierOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfShinyOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfShinyOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.ShinyOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfLoadingChamerOrEnhancedPatrons(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfLoadingChamerOrEnhancedPatrons(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.LoadingchamberOrEnhancedPatronsCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfHipFlasks(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfHipFlasks(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.HipFlaskCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#hasSwappedPosition()\n     */\n    public void hasSwappedPosition(final Combatant combatant, final Combatant swappedWith) {\n        swaps.incrementSide(combatant);\n        final PositionSwitch swap = new PositionSwitch(currentRoundNo, combatant, swappedWith);\n        assert swapList.get(combatant.getSide()) != null;\n        swapList.get(combatant.getSide()).add(swap);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#totalSwaps(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int totalSwaps(final CombatantSide side) {\n        return swaps.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#switchedPosList(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public Set<PositionSwitch> switchedPosList(final CombatantSide side) {\n        final Set<PositionSwitch> allSwaps;\n        if (side == null) {\n            allSwaps = new HashSet<PositionSwitch>();\n            for (final Set<PositionSwitch> sideSwitches : swapList.values()) {\n                allSwaps.addAll(sideSwitches);\n            }\n        } else {\n            allSwaps = swapList.get(side);\n        }\n        return allSwaps;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#criticalShot(de.outstare.fortbattleplayer.model.Combatant,\n     *      Combatant, int)\n     */\n    public void criticalShot(final Combatant combatant, final Combatant victim, final int damage) {\n        final CriticalHit crit = new CriticalHit(combatant, victim, damage, currentRoundNo);\n        critHits.get(combatant.getSide()).add(crit);\n        crits.incrementSide(combatant);\n        final Area field = victim._getLocation();\n        getFieldStat(field).addCrit();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#critList(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public List<CriticalHit> critList(final CombatantSide side) {\n        final List<CriticalHit> allCrits;\n        if (side == null) {\n            allCrits = new ArrayList<CriticalHit>();\n            for (final List<CriticalHit> sideCrits : critHits.values()) {\n                allCrits.addAll(sideCrits);\n            }\n        } else {\n            allCrits = critHits.get(side);\n        }\n        return allCrits;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#criticalHits(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int criticalHits(final CombatantSide side) {\n        return crits.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#criticalHitDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public long criticalHitDamage(final CombatantSide side) {\n        long sum = 0;\n        for (final CriticalHit crit : critList(side)) {\n            sum += crit.critOnlyDamage;\n        }\n        return sum;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#turnOrder(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public List<Combatant> turnOrder(final CombatantSide side) {\n        final List<Combatant> sidePlayers = new ArrayList<Combatant>(turnOrder.size() / 2);\n        for (final Combatant player : turnOrder) {\n            if (side == null || player.getSide() == side) {\n                sidePlayers.add(player);\n            }\n        }\n        return sidePlayers;\n    }\n\n    /**\n     * @return the number of shots per round\n     */\n    public Map<CombatantSide, ? extends LabeledData> getShotsPerRound() {\n        return shotsPerRound;\n    }\n\n    /**\n     * @return the number of hits per round\n     */\n    public Map<CombatantSide, ? extends LabeledData> getHitsPerRound() {\n        return hitsPerRound;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#getNotShootersPerRound()\n     */\n    public Map<CombatantSide, ? extends LabeledData> getNotShootersPerRound() {\n        final Map<CombatantSide, RoundStatistics> nonShootersPerRound = new HashMap<CombatantSide, RoundStatistics>();\n        for (final CombatantSide side : CombatantSide.values()) {\n            final RoundStatistics nonShooters = new RoundStatistics(\"Not shooting\", \"players\");\n            nonShootersPerRound.put(side, nonShooters);\n            final LabeledData shotRoundCounts = shotsPerRound.get(side);\n            if (shotRoundCounts != null) {\n                final double[] shotCounts = shotRoundCounts.toArray();\n                if (actorsPerRound.size() == shotCounts.length) {\n                    for (int i = 0; i < shotCounts.length; i++) {\n                        final int actors = actorsPerRound.get(i).getSideValue(side);\n                        final double numberNotShooting = actors - shotCounts[i];\n                        nonShooters.addValue(numberNotShooting);\n                    }\n                } else {\n                    LOG.warning(\"round statistics for players and shots differ!\");\n                }\n            } else {\n                LOG.warning(\"no data for players and shots for side \" + side);\n            }\n        }\n        return nonShootersPerRound;\n    }\n\n    private AreaStatistic getFieldStat(final Area area) {\n        if (!fieldStats.containsKey(area)) {\n            fieldStats.put(area, new AreaStatistic(area));\n        }\n        return fieldStats.get(area);\n    }\n\n    /**\n     * @return statistics for every field\n     */\n    public Map<Area, AreaStatistic> getFieldStatistics() {\n        return fieldStats;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/BattleStatistics_17Test.java",
		"test_prompt": "// BattleStatistics_17Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BattleStatistics}.\n* It contains ten unit test cases for the {@link BattleStatistics#critList(CombatantSide)} method.\n*/\nclass BattleStatistics_17Test {"
	},
	{
		"original_code": "// BattleStatistics.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\n\n/**\n * @author daniel\n */\npublic class BattleStatistics implements DynamicStatistics, CombatantObserver {\n\n    private static final transient Logger LOG = Logger.getLogger(BattleStatistics.class.getName());\n\n    private final Map<Combatant, OnlineCounter> onliners = new HashMap<Combatant, OnlineCounter>();\n\n    private final Map<CombatantSide, List<CriticalHit>> critHits = new HashMap<CombatantSide, List<CriticalHit>>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            critHits.put(side, new ArrayList<CriticalHit>());\n        }\n    }\n\n    private final Map<CombatantSide, Set<PositionSwitch>> swapList = new HashMap<CombatantSide, Set<PositionSwitch>>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            swapList.put(side, new HashSet<PositionSwitch>());\n        }\n    }\n\n    private final AllCombatantSidesCounter crits = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter moves = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter swaps = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter attackBonuses = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter defenseBonuses = new AllCombatantSidesCounter();\n\n    private final Map<Combatant, Counter> shots = new HashMap<Combatant, Counter>();\n\n    private final Map<CombatantSide, RoundStatistics> shotsPerRound = new HashMap<CombatantSide, RoundStatistics>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            shotsPerRound.put(side, new RoundStatistics(\"shots\", \"shots\"));\n        }\n    }\n\n    private final Map<CombatantSide, RoundStatistics> hitsPerRound = new HashMap<CombatantSide, RoundStatistics>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            hitsPerRound.put(side, new RoundStatistics(\"hits\", \"hits\"));\n        }\n    }\n\n    private final Map<CombatantSide, AtomicInteger> shotRoundCounter = new HashMap<CombatantSide, AtomicInteger>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            shotRoundCounter.put(side, new AtomicInteger());\n        }\n    }\n\n    private final Map<CombatantSide, AtomicInteger> hitRoundCounter = new HashMap<CombatantSide, AtomicInteger>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            hitRoundCounter.put(side, new AtomicInteger());\n        }\n    }\n\n    private final Map<Combatant, Counter> victims = new HashMap<Combatant, Counter>();\n\n    private final List<Combatant> turnOrder = new LinkedList<Combatant>();\n\n    private final List<AllCombatantSidesCounter> actorsPerRound = new ArrayList<AllCombatantSidesCounter>(50);\n\n    private final Map<Area, AreaStatistic> fieldStats = new HashMap<Area, AreaStatistic>();\n\n    private final int _numberOfDefenders;\n\n    private final int _numberOfAttacker;\n\n    private int currentRoundNo = 0;\n\n    private Boolean firstRound = null;\n\n    private AllCombatantSidesCounter actorsThisRound = new AllCombatantSidesCounter();\n\n    /**\n     * set the current round. all following method calls will belong to this\n     * round till this method is called again with another parameter.\n     *\n     * @param no\n     */\n    public void setRound(final int no) {\n        if (firstRound == null) {\n            firstRound = Boolean.TRUE;\n        } else if (firstRound.booleanValue()) {\n            firstRound = Boolean.FALSE;\n            // the turn order is determined only in the first round\n            for (final Combatant player : onliners.keySet()) {\n                if (!turnOrder.contains(player)) {\n                    LOG.info(\"could not determine turn order for \" + player);\n                }\n            }\n        }\n        addAndResetRoundCounter(shotRoundCounter, shotsPerRound);\n        addAndResetRoundCounter(hitRoundCounter, hitsPerRound);\n        actorsPerRound.add(actorsThisRound);\n        actorsThisRound = new AllCombatantSidesCounter();\n        currentRoundNo = no;\n    }\n\n    /**\n     * this adds the counters for the last round to the total counts per round\n     * and resets the given counter\n     *\n     * @param roundCounter\n     * @param allRounds\n     */\n    void addAndResetRoundCounter(final Map<CombatantSide, AtomicInteger> roundCounter, final Map<CombatantSide, RoundStatistics> allRounds) {\n        for (final Entry<CombatantSide, AtomicInteger> mapping : roundCounter.entrySet()) {\n            final CombatantSide side = mapping.getKey();\n            final AtomicInteger roundShots = mapping.getValue();\n            allRounds.get(side).addValue(roundShots.get());\n            // reset for next round\n            roundShots.set(0);\n        }\n    }\n\n    /**\n     * @param combatant\n     * @return\n     */\n    int combatantLifetime(final Combatant combatant) {\n        final OnlineCounter onAndOffline = onliners.get(combatant);\n        if (onAndOffline == null) {\n            return 0;\n        }\n        return onAndOffline.sumOfEvents();\n    }\n\n    /**\n     * @param numberOfAttacker\n     * @param numberOfDefenders\n     */\n    public BattleStatistics(final int numberOfAttacker, final int numberOfDefenders) {\n        _numberOfAttacker = numberOfAttacker;\n        _numberOfDefenders = numberOfDefenders;\n    }\n\n    /**\n     * @param number\n     * @return\n     */\n    int round(final double number) {\n        return (int) Math.round(number);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#percentAbleToShoot(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int percentAbleToShoot(final CombatantSide side) {\n        double sum = 0;\n        int players = 0;\n        for (final Entry<Combatant, Counter> playerShots : shots.entrySet()) {\n            final Combatant combatant = playerShots.getKey();\n            if (isOnSide(side, combatant)) {\n                final int lifetime = combatantLifetime(combatant);\n                final int roundsShooting = playerShots.getValue().getValue();\n                sum += roundsShooting * 100.0 / lifetime;\n                players++;\n            }\n        }\n        if (players == 0) {\n            return 0;\n        }\n        return round(sum / players);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#amountOfAttackBonus(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int amountOfAttackBonus(final CombatantSide side) {\n        return attackBonuses.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#amountOfDefenseBonus(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int amountOfDefenseBonus(final CombatantSide side) {\n        return defenseBonuses.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfMovesPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double numberOfMovesPerPlayer(final CombatantSide side) {\n        double result = 0;\n        switch(side) {\n            case ATTACKER:\n                result = moves.getSideValue(side) / (double) _numberOfAttacker;\n                break;\n            case DEFENDER:\n                result = moves.getSideValue(side) / (double) _numberOfDefenders;\n                break;\n            default:\n                result = moves.getSideValue(null) / (double) (_numberOfAttacker + _numberOfDefenders);\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfOffliners(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfOffliners(final CombatantSide side) {\n        int offliner = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (counter.wasOffline()) {\n                    offliner++;\n                }\n            }\n        }\n        return offliner;\n    }\n\n    /**\n     * @param side\n     * @param combatant\n     * @return\n     */\n    private boolean isOnSide(final CombatantSide side, final Combatant combatant) {\n        return side == null || side.equals(combatant.getSide());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#roundsTillOnline(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double roundsTillOnline(final CombatantSide side) {\n        int combatants = 0;\n        int rounds = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (!counter.wasOffline()) {\n                    combatants++;\n                    rounds += counter.firstOnline();\n                }\n            }\n        }\n        // avoid division by zero\n        if (combatants == 0) {\n            return 0;\n        }\n        return ((double) rounds / (double) combatants);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#averageRoundsOnline(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageRoundsOnline(final CombatantSide side) {\n        double combatants = 0;\n        double rounds = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (!counter.wasOffline()) {\n                    combatants++;\n                    rounds += counter.onlineEvents();\n                }\n            }\n        }\n        // avoid division by zero\n        if (combatants == 0.0) {\n            return 0.0;\n        }\n        return rounds / combatants;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#hasMoved(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Area)\n     */\n    public void hasMoved(final Combatant combatant, final Area newPos) {\n        moves.incrementSide(combatant);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#newDestination(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Area)\n     */\n    public void newDestination(final Combatant combatant, final Area destination) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#aimsAt(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void aimsAt(final Combatant combatant, final Combatant target) {\n        incrementCombatantCounter(shots, combatant);\n        incrementCombatantCounter(victims, target);\n        shotRoundCounter.get(combatant.getSide()).incrementAndGet();\n        final Area field = target._getLocation();\n        getFieldStat(field).addShot();\n    }\n\n    private void incrementCombatantCounter(final Map<Combatant, Counter> combatantCounters, final Combatant combatant) {\n        if (!combatantCounters.containsKey(combatant)) {\n            combatantCounters.put(combatant, new Counter());\n        }\n        combatantCounters.get(combatant).increment();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isHit(de.outstare.fortbattleplayer.model.Combatant,\n     *      int, int)\n     */\n    public void isHit(final Combatant combatant, final int damage, final int oldHealthAmount) {\n        hitRoundCounter.get(combatant.getSide()).incrementAndGet();\n        final Area field = combatant._getLocation();\n        getFieldStat(field).addHit();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isDead(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void isDead(final Combatant combatant) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isAlive(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void isAlive(final Combatant combatant) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isOnline(de.outstare.fortbattleplayer.model.Combatant,\n     *      boolean)\n     */\n    public void isOnline(final Combatant combatant, final boolean changed) {\n        // count all events\n        if (!onliners.containsKey(combatant)) {\n            onliners.put(combatant, new OnlineCounter());\n        }\n        if (combatant.isOnline()) {\n            onliners.get(combatant).addOnline();\n        } else {\n            onliners.get(combatant).addOffline();\n        }\n        // the online event is triggered every round for a player (hopefully)\n        combatantTurn(combatant);\n    }\n\n    /**\n     * no special action, just to track the state every round\n     *\n     * @param combatant\n     */\n    private void combatantTurn(final Combatant combatant) {\n        final SectorBonus bonus = combatant.getSectorBonus();\n        attackBonuses.incrementBy(bonus.attackBonus, combatant);\n        defenseBonuses.incrementBy(bonus.defendBonus, combatant);\n        if (firstRound != null && firstRound.booleanValue()) {\n            turnOrder.add(combatant);\n        }\n        if (LOG.isLoggable(Level.FINE)) {\n            if ((firstRound == null || !firstRound.booleanValue()) && !turnOrder.contains(combatant) && currentRoundNo > 1) {\n                LOG.fine(\"---- not in order: \" + combatant);\n            }\n        }\n        actorsThisRound.incrementSide(combatant);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#targetNoOne(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public String targetNoOne(final CombatantSide side) {\n        String result = \"\";\n        int max = 0;\n        for (final Entry<Combatant, Counter> victim : victims.entrySet()) {\n            final Combatant combatant = victim.getKey();\n            if (isOnSide(side, combatant)) {\n                final int receivedShots = victim.getValue().getValue();\n                if (receivedShots > max) {\n                    max = receivedShots;\n                    result = combatant.getName() + \"(\" + receivedShots + \")\";\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfBayonets(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfBayonets(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.BayonetCounter());\n    }\n\n    /**\n     * @param side\n     * @param counter\n     * @return\n     */\n    int countWeaponMods(final CombatantSide side, final WeaponModCounter counter) {\n        // because every player should have an online/offline event, we look at\n        // the online data hoping to get all players\n        final Set<Combatant> players = onliners.keySet();\n        int bayonets = 0;\n        for (final Combatant combatant : players) {\n            if (isOnSide(side, combatant)) {\n                final Weapon playerWeapon = combatant.getWeapon();\n                // TODO let the counter count\n                if (counter.counts(playerWeapon)) {\n                    bayonets++;\n                }\n            }\n        }\n        return bayonets;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfGraphitLubricants(CombatantSide)\n     */\n    public int numberOfGraphitLubricants(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.GraphitLubricantCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfFettesOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfFettesOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.FettesOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfSchmierOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfSchmierOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.SchmierOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfShinyOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfShinyOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.ShinyOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfLoadingChamerOrEnhancedPatrons(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfLoadingChamerOrEnhancedPatrons(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.LoadingchamberOrEnhancedPatronsCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfHipFlasks(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfHipFlasks(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.HipFlaskCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#hasSwappedPosition()\n     */\n    public void hasSwappedPosition(final Combatant combatant, final Combatant swappedWith) {\n        swaps.incrementSide(combatant);\n        final PositionSwitch swap = new PositionSwitch(currentRoundNo, combatant, swappedWith);\n        assert swapList.get(combatant.getSide()) != null;\n        swapList.get(combatant.getSide()).add(swap);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#totalSwaps(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int totalSwaps(final CombatantSide side) {\n        return swaps.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#switchedPosList(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public Set<PositionSwitch> switchedPosList(final CombatantSide side) {\n        final Set<PositionSwitch> allSwaps;\n        if (side == null) {\n            allSwaps = new HashSet<PositionSwitch>();\n            for (final Set<PositionSwitch> sideSwitches : swapList.values()) {\n                allSwaps.addAll(sideSwitches);\n            }\n        } else {\n            allSwaps = swapList.get(side);\n        }\n        return allSwaps;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#criticalShot(de.outstare.fortbattleplayer.model.Combatant,\n     *      Combatant, int)\n     */\n    public void criticalShot(final Combatant combatant, final Combatant victim, final int damage) {\n        final CriticalHit crit = new CriticalHit(combatant, victim, damage, currentRoundNo);\n        critHits.get(combatant.getSide()).add(crit);\n        crits.incrementSide(combatant);\n        final Area field = victim._getLocation();\n        getFieldStat(field).addCrit();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#critList(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public List<CriticalHit> critList(final CombatantSide side) {\n        final List<CriticalHit> allCrits;\n        if (side == null) {\n            allCrits = new ArrayList<CriticalHit>();\n            for (final List<CriticalHit> sideCrits : critHits.values()) {\n                allCrits.addAll(sideCrits);\n            }\n        } else {\n            allCrits = critHits.get(side);\n        }\n        return allCrits;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#criticalHits(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int criticalHits(final CombatantSide side) {\n        return crits.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#criticalHitDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public long criticalHitDamage(final CombatantSide side) {\n        long sum = 0;\n        for (final CriticalHit crit : critList(side)) {\n            sum += crit.critOnlyDamage;\n        }\n        return sum;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#turnOrder(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public List<Combatant> turnOrder(final CombatantSide side) {\n        final List<Combatant> sidePlayers = new ArrayList<Combatant>(turnOrder.size() / 2);\n        for (final Combatant player : turnOrder) {\n            if (side == null || player.getSide() == side) {\n                sidePlayers.add(player);\n            }\n        }\n        return sidePlayers;\n    }\n\n    /**\n     * @return the number of shots per round\n     */\n    public Map<CombatantSide, ? extends LabeledData> getShotsPerRound() {\n        return shotsPerRound;\n    }\n\n    /**\n     * @return the number of hits per round\n     */\n    public Map<CombatantSide, ? extends LabeledData> getHitsPerRound() {\n        return hitsPerRound;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#getNotShootersPerRound()\n     */\n    public Map<CombatantSide, ? extends LabeledData> getNotShootersPerRound() {\n        final Map<CombatantSide, RoundStatistics> nonShootersPerRound = new HashMap<CombatantSide, RoundStatistics>();\n        for (final CombatantSide side : CombatantSide.values()) {\n            final RoundStatistics nonShooters = new RoundStatistics(\"Not shooting\", \"players\");\n            nonShootersPerRound.put(side, nonShooters);\n            final LabeledData shotRoundCounts = shotsPerRound.get(side);\n            if (shotRoundCounts != null) {\n                final double[] shotCounts = shotRoundCounts.toArray();\n                if (actorsPerRound.size() == shotCounts.length) {\n                    for (int i = 0; i < shotCounts.length; i++) {\n                        final int actors = actorsPerRound.get(i).getSideValue(side);\n                        final double numberNotShooting = actors - shotCounts[i];\n                        nonShooters.addValue(numberNotShooting);\n                    }\n                } else {\n                    LOG.warning(\"round statistics for players and shots differ!\");\n                }\n            } else {\n                LOG.warning(\"no data for players and shots for side \" + side);\n            }\n        }\n        return nonShootersPerRound;\n    }\n\n    private AreaStatistic getFieldStat(final Area area) {\n        if (!fieldStats.containsKey(area)) {\n            fieldStats.put(area, new AreaStatistic(area));\n        }\n        return fieldStats.get(area);\n    }\n\n    /**\n     * @return statistics for every field\n     */\n    public Map<Area, AreaStatistic> getFieldStatistics() {\n        return fieldStats;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/BattleStatistics_18Test.java",
		"test_prompt": "// BattleStatistics_18Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BattleStatistics}.\n* It contains ten unit test cases for the {@link BattleStatistics#criticalHits(CombatantSide)} method.\n*/\nclass BattleStatistics_18Test {"
	},
	{
		"original_code": "// BattleStatistics.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\n\n/**\n * @author daniel\n */\npublic class BattleStatistics implements DynamicStatistics, CombatantObserver {\n\n    private static final transient Logger LOG = Logger.getLogger(BattleStatistics.class.getName());\n\n    private final Map<Combatant, OnlineCounter> onliners = new HashMap<Combatant, OnlineCounter>();\n\n    private final Map<CombatantSide, List<CriticalHit>> critHits = new HashMap<CombatantSide, List<CriticalHit>>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            critHits.put(side, new ArrayList<CriticalHit>());\n        }\n    }\n\n    private final Map<CombatantSide, Set<PositionSwitch>> swapList = new HashMap<CombatantSide, Set<PositionSwitch>>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            swapList.put(side, new HashSet<PositionSwitch>());\n        }\n    }\n\n    private final AllCombatantSidesCounter crits = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter moves = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter swaps = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter attackBonuses = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter defenseBonuses = new AllCombatantSidesCounter();\n\n    private final Map<Combatant, Counter> shots = new HashMap<Combatant, Counter>();\n\n    private final Map<CombatantSide, RoundStatistics> shotsPerRound = new HashMap<CombatantSide, RoundStatistics>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            shotsPerRound.put(side, new RoundStatistics(\"shots\", \"shots\"));\n        }\n    }\n\n    private final Map<CombatantSide, RoundStatistics> hitsPerRound = new HashMap<CombatantSide, RoundStatistics>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            hitsPerRound.put(side, new RoundStatistics(\"hits\", \"hits\"));\n        }\n    }\n\n    private final Map<CombatantSide, AtomicInteger> shotRoundCounter = new HashMap<CombatantSide, AtomicInteger>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            shotRoundCounter.put(side, new AtomicInteger());\n        }\n    }\n\n    private final Map<CombatantSide, AtomicInteger> hitRoundCounter = new HashMap<CombatantSide, AtomicInteger>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            hitRoundCounter.put(side, new AtomicInteger());\n        }\n    }\n\n    private final Map<Combatant, Counter> victims = new HashMap<Combatant, Counter>();\n\n    private final List<Combatant> turnOrder = new LinkedList<Combatant>();\n\n    private final List<AllCombatantSidesCounter> actorsPerRound = new ArrayList<AllCombatantSidesCounter>(50);\n\n    private final Map<Area, AreaStatistic> fieldStats = new HashMap<Area, AreaStatistic>();\n\n    private final int _numberOfDefenders;\n\n    private final int _numberOfAttacker;\n\n    private int currentRoundNo = 0;\n\n    private Boolean firstRound = null;\n\n    private AllCombatantSidesCounter actorsThisRound = new AllCombatantSidesCounter();\n\n    /**\n     * set the current round. all following method calls will belong to this\n     * round till this method is called again with another parameter.\n     *\n     * @param no\n     */\n    public void setRound(final int no) {\n        if (firstRound == null) {\n            firstRound = Boolean.TRUE;\n        } else if (firstRound.booleanValue()) {\n            firstRound = Boolean.FALSE;\n            // the turn order is determined only in the first round\n            for (final Combatant player : onliners.keySet()) {\n                if (!turnOrder.contains(player)) {\n                    LOG.info(\"could not determine turn order for \" + player);\n                }\n            }\n        }\n        addAndResetRoundCounter(shotRoundCounter, shotsPerRound);\n        addAndResetRoundCounter(hitRoundCounter, hitsPerRound);\n        actorsPerRound.add(actorsThisRound);\n        actorsThisRound = new AllCombatantSidesCounter();\n        currentRoundNo = no;\n    }\n\n    /**\n     * this adds the counters for the last round to the total counts per round\n     * and resets the given counter\n     *\n     * @param roundCounter\n     * @param allRounds\n     */\n    void addAndResetRoundCounter(final Map<CombatantSide, AtomicInteger> roundCounter, final Map<CombatantSide, RoundStatistics> allRounds) {\n        for (final Entry<CombatantSide, AtomicInteger> mapping : roundCounter.entrySet()) {\n            final CombatantSide side = mapping.getKey();\n            final AtomicInteger roundShots = mapping.getValue();\n            allRounds.get(side).addValue(roundShots.get());\n            // reset for next round\n            roundShots.set(0);\n        }\n    }\n\n    /**\n     * @param combatant\n     * @return\n     */\n    int combatantLifetime(final Combatant combatant) {\n        final OnlineCounter onAndOffline = onliners.get(combatant);\n        if (onAndOffline == null) {\n            return 0;\n        }\n        return onAndOffline.sumOfEvents();\n    }\n\n    /**\n     * @param numberOfAttacker\n     * @param numberOfDefenders\n     */\n    public BattleStatistics(final int numberOfAttacker, final int numberOfDefenders) {\n        _numberOfAttacker = numberOfAttacker;\n        _numberOfDefenders = numberOfDefenders;\n    }\n\n    /**\n     * @param number\n     * @return\n     */\n    int round(final double number) {\n        return (int) Math.round(number);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#percentAbleToShoot(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int percentAbleToShoot(final CombatantSide side) {\n        double sum = 0;\n        int players = 0;\n        for (final Entry<Combatant, Counter> playerShots : shots.entrySet()) {\n            final Combatant combatant = playerShots.getKey();\n            if (isOnSide(side, combatant)) {\n                final int lifetime = combatantLifetime(combatant);\n                final int roundsShooting = playerShots.getValue().getValue();\n                sum += roundsShooting * 100.0 / lifetime;\n                players++;\n            }\n        }\n        if (players == 0) {\n            return 0;\n        }\n        return round(sum / players);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#amountOfAttackBonus(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int amountOfAttackBonus(final CombatantSide side) {\n        return attackBonuses.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#amountOfDefenseBonus(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int amountOfDefenseBonus(final CombatantSide side) {\n        return defenseBonuses.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfMovesPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double numberOfMovesPerPlayer(final CombatantSide side) {\n        double result = 0;\n        switch(side) {\n            case ATTACKER:\n                result = moves.getSideValue(side) / (double) _numberOfAttacker;\n                break;\n            case DEFENDER:\n                result = moves.getSideValue(side) / (double) _numberOfDefenders;\n                break;\n            default:\n                result = moves.getSideValue(null) / (double) (_numberOfAttacker + _numberOfDefenders);\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfOffliners(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfOffliners(final CombatantSide side) {\n        int offliner = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (counter.wasOffline()) {\n                    offliner++;\n                }\n            }\n        }\n        return offliner;\n    }\n\n    /**\n     * @param side\n     * @param combatant\n     * @return\n     */\n    private boolean isOnSide(final CombatantSide side, final Combatant combatant) {\n        return side == null || side.equals(combatant.getSide());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#roundsTillOnline(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double roundsTillOnline(final CombatantSide side) {\n        int combatants = 0;\n        int rounds = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (!counter.wasOffline()) {\n                    combatants++;\n                    rounds += counter.firstOnline();\n                }\n            }\n        }\n        // avoid division by zero\n        if (combatants == 0) {\n            return 0;\n        }\n        return ((double) rounds / (double) combatants);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#averageRoundsOnline(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageRoundsOnline(final CombatantSide side) {\n        double combatants = 0;\n        double rounds = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (!counter.wasOffline()) {\n                    combatants++;\n                    rounds += counter.onlineEvents();\n                }\n            }\n        }\n        // avoid division by zero\n        if (combatants == 0.0) {\n            return 0.0;\n        }\n        return rounds / combatants;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#hasMoved(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Area)\n     */\n    public void hasMoved(final Combatant combatant, final Area newPos) {\n        moves.incrementSide(combatant);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#newDestination(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Area)\n     */\n    public void newDestination(final Combatant combatant, final Area destination) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#aimsAt(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void aimsAt(final Combatant combatant, final Combatant target) {\n        incrementCombatantCounter(shots, combatant);\n        incrementCombatantCounter(victims, target);\n        shotRoundCounter.get(combatant.getSide()).incrementAndGet();\n        final Area field = target._getLocation();\n        getFieldStat(field).addShot();\n    }\n\n    private void incrementCombatantCounter(final Map<Combatant, Counter> combatantCounters, final Combatant combatant) {\n        if (!combatantCounters.containsKey(combatant)) {\n            combatantCounters.put(combatant, new Counter());\n        }\n        combatantCounters.get(combatant).increment();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isHit(de.outstare.fortbattleplayer.model.Combatant,\n     *      int, int)\n     */\n    public void isHit(final Combatant combatant, final int damage, final int oldHealthAmount) {\n        hitRoundCounter.get(combatant.getSide()).incrementAndGet();\n        final Area field = combatant._getLocation();\n        getFieldStat(field).addHit();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isDead(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void isDead(final Combatant combatant) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isAlive(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void isAlive(final Combatant combatant) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isOnline(de.outstare.fortbattleplayer.model.Combatant,\n     *      boolean)\n     */\n    public void isOnline(final Combatant combatant, final boolean changed) {\n        // count all events\n        if (!onliners.containsKey(combatant)) {\n            onliners.put(combatant, new OnlineCounter());\n        }\n        if (combatant.isOnline()) {\n            onliners.get(combatant).addOnline();\n        } else {\n            onliners.get(combatant).addOffline();\n        }\n        // the online event is triggered every round for a player (hopefully)\n        combatantTurn(combatant);\n    }\n\n    /**\n     * no special action, just to track the state every round\n     *\n     * @param combatant\n     */\n    private void combatantTurn(final Combatant combatant) {\n        final SectorBonus bonus = combatant.getSectorBonus();\n        attackBonuses.incrementBy(bonus.attackBonus, combatant);\n        defenseBonuses.incrementBy(bonus.defendBonus, combatant);\n        if (firstRound != null && firstRound.booleanValue()) {\n            turnOrder.add(combatant);\n        }\n        if (LOG.isLoggable(Level.FINE)) {\n            if ((firstRound == null || !firstRound.booleanValue()) && !turnOrder.contains(combatant) && currentRoundNo > 1) {\n                LOG.fine(\"---- not in order: \" + combatant);\n            }\n        }\n        actorsThisRound.incrementSide(combatant);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#targetNoOne(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public String targetNoOne(final CombatantSide side) {\n        String result = \"\";\n        int max = 0;\n        for (final Entry<Combatant, Counter> victim : victims.entrySet()) {\n            final Combatant combatant = victim.getKey();\n            if (isOnSide(side, combatant)) {\n                final int receivedShots = victim.getValue().getValue();\n                if (receivedShots > max) {\n                    max = receivedShots;\n                    result = combatant.getName() + \"(\" + receivedShots + \")\";\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfBayonets(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfBayonets(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.BayonetCounter());\n    }\n\n    /**\n     * @param side\n     * @param counter\n     * @return\n     */\n    int countWeaponMods(final CombatantSide side, final WeaponModCounter counter) {\n        // because every player should have an online/offline event, we look at\n        // the online data hoping to get all players\n        final Set<Combatant> players = onliners.keySet();\n        int bayonets = 0;\n        for (final Combatant combatant : players) {\n            if (isOnSide(side, combatant)) {\n                final Weapon playerWeapon = combatant.getWeapon();\n                // TODO let the counter count\n                if (counter.counts(playerWeapon)) {\n                    bayonets++;\n                }\n            }\n        }\n        return bayonets;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfGraphitLubricants(CombatantSide)\n     */\n    public int numberOfGraphitLubricants(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.GraphitLubricantCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfFettesOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfFettesOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.FettesOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfSchmierOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfSchmierOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.SchmierOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfShinyOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfShinyOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.ShinyOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfLoadingChamerOrEnhancedPatrons(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfLoadingChamerOrEnhancedPatrons(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.LoadingchamberOrEnhancedPatronsCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfHipFlasks(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfHipFlasks(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.HipFlaskCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#hasSwappedPosition()\n     */\n    public void hasSwappedPosition(final Combatant combatant, final Combatant swappedWith) {\n        swaps.incrementSide(combatant);\n        final PositionSwitch swap = new PositionSwitch(currentRoundNo, combatant, swappedWith);\n        assert swapList.get(combatant.getSide()) != null;\n        swapList.get(combatant.getSide()).add(swap);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#totalSwaps(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int totalSwaps(final CombatantSide side) {\n        return swaps.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#switchedPosList(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public Set<PositionSwitch> switchedPosList(final CombatantSide side) {\n        final Set<PositionSwitch> allSwaps;\n        if (side == null) {\n            allSwaps = new HashSet<PositionSwitch>();\n            for (final Set<PositionSwitch> sideSwitches : swapList.values()) {\n                allSwaps.addAll(sideSwitches);\n            }\n        } else {\n            allSwaps = swapList.get(side);\n        }\n        return allSwaps;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#criticalShot(de.outstare.fortbattleplayer.model.Combatant,\n     *      Combatant, int)\n     */\n    public void criticalShot(final Combatant combatant, final Combatant victim, final int damage) {\n        final CriticalHit crit = new CriticalHit(combatant, victim, damage, currentRoundNo);\n        critHits.get(combatant.getSide()).add(crit);\n        crits.incrementSide(combatant);\n        final Area field = victim._getLocation();\n        getFieldStat(field).addCrit();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#critList(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public List<CriticalHit> critList(final CombatantSide side) {\n        final List<CriticalHit> allCrits;\n        if (side == null) {\n            allCrits = new ArrayList<CriticalHit>();\n            for (final List<CriticalHit> sideCrits : critHits.values()) {\n                allCrits.addAll(sideCrits);\n            }\n        } else {\n            allCrits = critHits.get(side);\n        }\n        return allCrits;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#criticalHits(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int criticalHits(final CombatantSide side) {\n        return crits.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#criticalHitDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public long criticalHitDamage(final CombatantSide side) {\n        long sum = 0;\n        for (final CriticalHit crit : critList(side)) {\n            sum += crit.critOnlyDamage;\n        }\n        return sum;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#turnOrder(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public List<Combatant> turnOrder(final CombatantSide side) {\n        final List<Combatant> sidePlayers = new ArrayList<Combatant>(turnOrder.size() / 2);\n        for (final Combatant player : turnOrder) {\n            if (side == null || player.getSide() == side) {\n                sidePlayers.add(player);\n            }\n        }\n        return sidePlayers;\n    }\n\n    /**\n     * @return the number of shots per round\n     */\n    public Map<CombatantSide, ? extends LabeledData> getShotsPerRound() {\n        return shotsPerRound;\n    }\n\n    /**\n     * @return the number of hits per round\n     */\n    public Map<CombatantSide, ? extends LabeledData> getHitsPerRound() {\n        return hitsPerRound;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#getNotShootersPerRound()\n     */\n    public Map<CombatantSide, ? extends LabeledData> getNotShootersPerRound() {\n        final Map<CombatantSide, RoundStatistics> nonShootersPerRound = new HashMap<CombatantSide, RoundStatistics>();\n        for (final CombatantSide side : CombatantSide.values()) {\n            final RoundStatistics nonShooters = new RoundStatistics(\"Not shooting\", \"players\");\n            nonShootersPerRound.put(side, nonShooters);\n            final LabeledData shotRoundCounts = shotsPerRound.get(side);\n            if (shotRoundCounts != null) {\n                final double[] shotCounts = shotRoundCounts.toArray();\n                if (actorsPerRound.size() == shotCounts.length) {\n                    for (int i = 0; i < shotCounts.length; i++) {\n                        final int actors = actorsPerRound.get(i).getSideValue(side);\n                        final double numberNotShooting = actors - shotCounts[i];\n                        nonShooters.addValue(numberNotShooting);\n                    }\n                } else {\n                    LOG.warning(\"round statistics for players and shots differ!\");\n                }\n            } else {\n                LOG.warning(\"no data for players and shots for side \" + side);\n            }\n        }\n        return nonShootersPerRound;\n    }\n\n    private AreaStatistic getFieldStat(final Area area) {\n        if (!fieldStats.containsKey(area)) {\n            fieldStats.put(area, new AreaStatistic(area));\n        }\n        return fieldStats.get(area);\n    }\n\n    /**\n     * @return statistics for every field\n     */\n    public Map<Area, AreaStatistic> getFieldStatistics() {\n        return fieldStats;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/BattleStatistics_19Test.java",
		"test_prompt": "// BattleStatistics_19Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BattleStatistics}.\n* It contains ten unit test cases for the {@link BattleStatistics#criticalHitDamage(CombatantSide)} method.\n*/\nclass BattleStatistics_19Test {"
	},
	{
		"original_code": "// BattleStatistics.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\n\n/**\n * @author daniel\n */\npublic class BattleStatistics implements DynamicStatistics, CombatantObserver {\n\n    private static final transient Logger LOG = Logger.getLogger(BattleStatistics.class.getName());\n\n    private final Map<Combatant, OnlineCounter> onliners = new HashMap<Combatant, OnlineCounter>();\n\n    private final Map<CombatantSide, List<CriticalHit>> critHits = new HashMap<CombatantSide, List<CriticalHit>>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            critHits.put(side, new ArrayList<CriticalHit>());\n        }\n    }\n\n    private final Map<CombatantSide, Set<PositionSwitch>> swapList = new HashMap<CombatantSide, Set<PositionSwitch>>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            swapList.put(side, new HashSet<PositionSwitch>());\n        }\n    }\n\n    private final AllCombatantSidesCounter crits = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter moves = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter swaps = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter attackBonuses = new AllCombatantSidesCounter();\n\n    private final AllCombatantSidesCounter defenseBonuses = new AllCombatantSidesCounter();\n\n    private final Map<Combatant, Counter> shots = new HashMap<Combatant, Counter>();\n\n    private final Map<CombatantSide, RoundStatistics> shotsPerRound = new HashMap<CombatantSide, RoundStatistics>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            shotsPerRound.put(side, new RoundStatistics(\"shots\", \"shots\"));\n        }\n    }\n\n    private final Map<CombatantSide, RoundStatistics> hitsPerRound = new HashMap<CombatantSide, RoundStatistics>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            hitsPerRound.put(side, new RoundStatistics(\"hits\", \"hits\"));\n        }\n    }\n\n    private final Map<CombatantSide, AtomicInteger> shotRoundCounter = new HashMap<CombatantSide, AtomicInteger>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            shotRoundCounter.put(side, new AtomicInteger());\n        }\n    }\n\n    private final Map<CombatantSide, AtomicInteger> hitRoundCounter = new HashMap<CombatantSide, AtomicInteger>();\n\n    {\n        for (final CombatantSide side : CombatantSide.values()) {\n            hitRoundCounter.put(side, new AtomicInteger());\n        }\n    }\n\n    private final Map<Combatant, Counter> victims = new HashMap<Combatant, Counter>();\n\n    private final List<Combatant> turnOrder = new LinkedList<Combatant>();\n\n    private final List<AllCombatantSidesCounter> actorsPerRound = new ArrayList<AllCombatantSidesCounter>(50);\n\n    private final Map<Area, AreaStatistic> fieldStats = new HashMap<Area, AreaStatistic>();\n\n    private final int _numberOfDefenders;\n\n    private final int _numberOfAttacker;\n\n    private int currentRoundNo = 0;\n\n    private Boolean firstRound = null;\n\n    private AllCombatantSidesCounter actorsThisRound = new AllCombatantSidesCounter();\n\n    /**\n     * set the current round. all following method calls will belong to this\n     * round till this method is called again with another parameter.\n     *\n     * @param no\n     */\n    public void setRound(final int no) {\n        if (firstRound == null) {\n            firstRound = Boolean.TRUE;\n        } else if (firstRound.booleanValue()) {\n            firstRound = Boolean.FALSE;\n            // the turn order is determined only in the first round\n            for (final Combatant player : onliners.keySet()) {\n                if (!turnOrder.contains(player)) {\n                    LOG.info(\"could not determine turn order for \" + player);\n                }\n            }\n        }\n        addAndResetRoundCounter(shotRoundCounter, shotsPerRound);\n        addAndResetRoundCounter(hitRoundCounter, hitsPerRound);\n        actorsPerRound.add(actorsThisRound);\n        actorsThisRound = new AllCombatantSidesCounter();\n        currentRoundNo = no;\n    }\n\n    /**\n     * this adds the counters for the last round to the total counts per round\n     * and resets the given counter\n     *\n     * @param roundCounter\n     * @param allRounds\n     */\n    void addAndResetRoundCounter(final Map<CombatantSide, AtomicInteger> roundCounter, final Map<CombatantSide, RoundStatistics> allRounds) {\n        for (final Entry<CombatantSide, AtomicInteger> mapping : roundCounter.entrySet()) {\n            final CombatantSide side = mapping.getKey();\n            final AtomicInteger roundShots = mapping.getValue();\n            allRounds.get(side).addValue(roundShots.get());\n            // reset for next round\n            roundShots.set(0);\n        }\n    }\n\n    /**\n     * @param combatant\n     * @return\n     */\n    int combatantLifetime(final Combatant combatant) {\n        final OnlineCounter onAndOffline = onliners.get(combatant);\n        if (onAndOffline == null) {\n            return 0;\n        }\n        return onAndOffline.sumOfEvents();\n    }\n\n    /**\n     * @param numberOfAttacker\n     * @param numberOfDefenders\n     */\n    public BattleStatistics(final int numberOfAttacker, final int numberOfDefenders) {\n        _numberOfAttacker = numberOfAttacker;\n        _numberOfDefenders = numberOfDefenders;\n    }\n\n    /**\n     * @param number\n     * @return\n     */\n    int round(final double number) {\n        return (int) Math.round(number);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#percentAbleToShoot(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int percentAbleToShoot(final CombatantSide side) {\n        double sum = 0;\n        int players = 0;\n        for (final Entry<Combatant, Counter> playerShots : shots.entrySet()) {\n            final Combatant combatant = playerShots.getKey();\n            if (isOnSide(side, combatant)) {\n                final int lifetime = combatantLifetime(combatant);\n                final int roundsShooting = playerShots.getValue().getValue();\n                sum += roundsShooting * 100.0 / lifetime;\n                players++;\n            }\n        }\n        if (players == 0) {\n            return 0;\n        }\n        return round(sum / players);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#amountOfAttackBonus(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int amountOfAttackBonus(final CombatantSide side) {\n        return attackBonuses.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#amountOfDefenseBonus(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int amountOfDefenseBonus(final CombatantSide side) {\n        return defenseBonuses.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfMovesPerPlayer(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double numberOfMovesPerPlayer(final CombatantSide side) {\n        double result = 0;\n        switch(side) {\n            case ATTACKER:\n                result = moves.getSideValue(side) / (double) _numberOfAttacker;\n                break;\n            case DEFENDER:\n                result = moves.getSideValue(side) / (double) _numberOfDefenders;\n                break;\n            default:\n                result = moves.getSideValue(null) / (double) (_numberOfAttacker + _numberOfDefenders);\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfOffliners(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfOffliners(final CombatantSide side) {\n        int offliner = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (counter.wasOffline()) {\n                    offliner++;\n                }\n            }\n        }\n        return offliner;\n    }\n\n    /**\n     * @param side\n     * @param combatant\n     * @return\n     */\n    private boolean isOnSide(final CombatantSide side, final Combatant combatant) {\n        return side == null || side.equals(combatant.getSide());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#roundsTillOnline(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double roundsTillOnline(final CombatantSide side) {\n        int combatants = 0;\n        int rounds = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (!counter.wasOffline()) {\n                    combatants++;\n                    rounds += counter.firstOnline();\n                }\n            }\n        }\n        // avoid division by zero\n        if (combatants == 0) {\n            return 0;\n        }\n        return ((double) rounds / (double) combatants);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#averageRoundsOnline(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public double averageRoundsOnline(final CombatantSide side) {\n        double combatants = 0;\n        double rounds = 0;\n        for (final Entry<Combatant, OnlineCounter> playerStats : onliners.entrySet()) {\n            if (isOnSide(side, playerStats.getKey())) {\n                final OnlineCounter counter = playerStats.getValue();\n                if (!counter.wasOffline()) {\n                    combatants++;\n                    rounds += counter.onlineEvents();\n                }\n            }\n        }\n        // avoid division by zero\n        if (combatants == 0.0) {\n            return 0.0;\n        }\n        return rounds / combatants;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#hasMoved(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Area)\n     */\n    public void hasMoved(final Combatant combatant, final Area newPos) {\n        moves.incrementSide(combatant);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#newDestination(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Area)\n     */\n    public void newDestination(final Combatant combatant, final Area destination) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#aimsAt(de.outstare.fortbattleplayer.model.Combatant,\n     *      de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void aimsAt(final Combatant combatant, final Combatant target) {\n        incrementCombatantCounter(shots, combatant);\n        incrementCombatantCounter(victims, target);\n        shotRoundCounter.get(combatant.getSide()).incrementAndGet();\n        final Area field = target._getLocation();\n        getFieldStat(field).addShot();\n    }\n\n    private void incrementCombatantCounter(final Map<Combatant, Counter> combatantCounters, final Combatant combatant) {\n        if (!combatantCounters.containsKey(combatant)) {\n            combatantCounters.put(combatant, new Counter());\n        }\n        combatantCounters.get(combatant).increment();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isHit(de.outstare.fortbattleplayer.model.Combatant,\n     *      int, int)\n     */\n    public void isHit(final Combatant combatant, final int damage, final int oldHealthAmount) {\n        hitRoundCounter.get(combatant.getSide()).incrementAndGet();\n        final Area field = combatant._getLocation();\n        getFieldStat(field).addHit();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isDead(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void isDead(final Combatant combatant) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isAlive(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void isAlive(final Combatant combatant) {\n        // TODO Auto-generated method stub\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#isOnline(de.outstare.fortbattleplayer.model.Combatant,\n     *      boolean)\n     */\n    public void isOnline(final Combatant combatant, final boolean changed) {\n        // count all events\n        if (!onliners.containsKey(combatant)) {\n            onliners.put(combatant, new OnlineCounter());\n        }\n        if (combatant.isOnline()) {\n            onliners.get(combatant).addOnline();\n        } else {\n            onliners.get(combatant).addOffline();\n        }\n        // the online event is triggered every round for a player (hopefully)\n        combatantTurn(combatant);\n    }\n\n    /**\n     * no special action, just to track the state every round\n     *\n     * @param combatant\n     */\n    private void combatantTurn(final Combatant combatant) {\n        final SectorBonus bonus = combatant.getSectorBonus();\n        attackBonuses.incrementBy(bonus.attackBonus, combatant);\n        defenseBonuses.incrementBy(bonus.defendBonus, combatant);\n        if (firstRound != null && firstRound.booleanValue()) {\n            turnOrder.add(combatant);\n        }\n        if (LOG.isLoggable(Level.FINE)) {\n            if ((firstRound == null || !firstRound.booleanValue()) && !turnOrder.contains(combatant) && currentRoundNo > 1) {\n                LOG.fine(\"---- not in order: \" + combatant);\n            }\n        }\n        actorsThisRound.incrementSide(combatant);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#targetNoOne(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public String targetNoOne(final CombatantSide side) {\n        String result = \"\";\n        int max = 0;\n        for (final Entry<Combatant, Counter> victim : victims.entrySet()) {\n            final Combatant combatant = victim.getKey();\n            if (isOnSide(side, combatant)) {\n                final int receivedShots = victim.getValue().getValue();\n                if (receivedShots > max) {\n                    max = receivedShots;\n                    result = combatant.getName() + \"(\" + receivedShots + \")\";\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfBayonets(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfBayonets(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.BayonetCounter());\n    }\n\n    /**\n     * @param side\n     * @param counter\n     * @return\n     */\n    int countWeaponMods(final CombatantSide side, final WeaponModCounter counter) {\n        // because every player should have an online/offline event, we look at\n        // the online data hoping to get all players\n        final Set<Combatant> players = onliners.keySet();\n        int bayonets = 0;\n        for (final Combatant combatant : players) {\n            if (isOnSide(side, combatant)) {\n                final Weapon playerWeapon = combatant.getWeapon();\n                // TODO let the counter count\n                if (counter.counts(playerWeapon)) {\n                    bayonets++;\n                }\n            }\n        }\n        return bayonets;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfGraphitLubricants(CombatantSide)\n     */\n    public int numberOfGraphitLubricants(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.GraphitLubricantCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfFettesOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfFettesOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.FettesOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfSchmierOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfSchmierOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.SchmierOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfShinyOil(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfShinyOil(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.ShinyOilCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfLoadingChamerOrEnhancedPatrons(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfLoadingChamerOrEnhancedPatrons(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.LoadingchamberOrEnhancedPatronsCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#numberOfHipFlasks(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int numberOfHipFlasks(final CombatantSide side) {\n        return countWeaponMods(side, new WeaponModCounter.HipFlaskCounter());\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#hasSwappedPosition()\n     */\n    public void hasSwappedPosition(final Combatant combatant, final Combatant swappedWith) {\n        swaps.incrementSide(combatant);\n        final PositionSwitch swap = new PositionSwitch(currentRoundNo, combatant, swappedWith);\n        assert swapList.get(combatant.getSide()) != null;\n        swapList.get(combatant.getSide()).add(swap);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#totalSwaps(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int totalSwaps(final CombatantSide side) {\n        return swaps.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#switchedPosList(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public Set<PositionSwitch> switchedPosList(final CombatantSide side) {\n        final Set<PositionSwitch> allSwaps;\n        if (side == null) {\n            allSwaps = new HashSet<PositionSwitch>();\n            for (final Set<PositionSwitch> sideSwitches : swapList.values()) {\n                allSwaps.addAll(sideSwitches);\n            }\n        } else {\n            allSwaps = swapList.get(side);\n        }\n        return allSwaps;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.CombatantObserver#criticalShot(de.outstare.fortbattleplayer.model.Combatant,\n     *      Combatant, int)\n     */\n    public void criticalShot(final Combatant combatant, final Combatant victim, final int damage) {\n        final CriticalHit crit = new CriticalHit(combatant, victim, damage, currentRoundNo);\n        critHits.get(combatant.getSide()).add(crit);\n        crits.incrementSide(combatant);\n        final Area field = victim._getLocation();\n        getFieldStat(field).addCrit();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#critList(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public List<CriticalHit> critList(final CombatantSide side) {\n        final List<CriticalHit> allCrits;\n        if (side == null) {\n            allCrits = new ArrayList<CriticalHit>();\n            for (final List<CriticalHit> sideCrits : critHits.values()) {\n                allCrits.addAll(sideCrits);\n            }\n        } else {\n            allCrits = critHits.get(side);\n        }\n        return allCrits;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#criticalHits(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public int criticalHits(final CombatantSide side) {\n        return crits.getSideValue(side);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#criticalHitDamage(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public long criticalHitDamage(final CombatantSide side) {\n        long sum = 0;\n        for (final CriticalHit crit : critList(side)) {\n            sum += crit.critOnlyDamage;\n        }\n        return sum;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#turnOrder(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public List<Combatant> turnOrder(final CombatantSide side) {\n        final List<Combatant> sidePlayers = new ArrayList<Combatant>(turnOrder.size() / 2);\n        for (final Combatant player : turnOrder) {\n            if (side == null || player.getSide() == side) {\n                sidePlayers.add(player);\n            }\n        }\n        return sidePlayers;\n    }\n\n    /**\n     * @return the number of shots per round\n     */\n    public Map<CombatantSide, ? extends LabeledData> getShotsPerRound() {\n        return shotsPerRound;\n    }\n\n    /**\n     * @return the number of hits per round\n     */\n    public Map<CombatantSide, ? extends LabeledData> getHitsPerRound() {\n        return hitsPerRound;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.DynamicStatistics#getNotShootersPerRound()\n     */\n    public Map<CombatantSide, ? extends LabeledData> getNotShootersPerRound() {\n        final Map<CombatantSide, RoundStatistics> nonShootersPerRound = new HashMap<CombatantSide, RoundStatistics>();\n        for (final CombatantSide side : CombatantSide.values()) {\n            final RoundStatistics nonShooters = new RoundStatistics(\"Not shooting\", \"players\");\n            nonShootersPerRound.put(side, nonShooters);\n            final LabeledData shotRoundCounts = shotsPerRound.get(side);\n            if (shotRoundCounts != null) {\n                final double[] shotCounts = shotRoundCounts.toArray();\n                if (actorsPerRound.size() == shotCounts.length) {\n                    for (int i = 0; i < shotCounts.length; i++) {\n                        final int actors = actorsPerRound.get(i).getSideValue(side);\n                        final double numberNotShooting = actors - shotCounts[i];\n                        nonShooters.addValue(numberNotShooting);\n                    }\n                } else {\n                    LOG.warning(\"round statistics for players and shots differ!\");\n                }\n            } else {\n                LOG.warning(\"no data for players and shots for side \" + side);\n            }\n        }\n        return nonShootersPerRound;\n    }\n\n    private AreaStatistic getFieldStat(final Area area) {\n        if (!fieldStats.containsKey(area)) {\n            fieldStats.put(area, new AreaStatistic(area));\n        }\n        return fieldStats.get(area);\n    }\n\n    /**\n     * @return statistics for every field\n     */\n    public Map<Area, AreaStatistic> getFieldStatistics() {\n        return fieldStats;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/BattleStatistics_20Test.java",
		"test_prompt": "// BattleStatistics_20Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BattleStatistics}.\n* It contains ten unit test cases for the {@link BattleStatistics#turnOrder(CombatantSide)} method.\n*/\nclass BattleStatistics_20Test {"
	},
	{
		"original_code": "// PositionSwitch.java\npackage de.outstare.fortbattleplayer.statistics;\n\nimport de.outstare.fortbattleplayer.model.Combatant;\n\n/**\n * Two {@link Combatant}s switched positions.\n *\n * They will be sorted by round and playername\n *\n * @author daniel\n */\npublic class PositionSwitch implements Comparable<PositionSwitch> {\n\n    /**\n     * number of the round in which this swap occured\n     */\n    public final int round;\n\n    /**\n     * one of the switched players\n     */\n    public final Combatant player1;\n\n    /**\n     * the HP of player1\n     */\n    public final Integer health1;\n\n    /**\n     * the other combatant who switched places\n     */\n    public final Combatant player2;\n\n    /**\n     * the HP of player2\n     */\n    public final Integer health2;\n\n    /**\n     * @param round\n     * @param player1\n     * @param player2\n     */\n    PositionSwitch(final int round, final Combatant player1, final Combatant player2) {\n        this.round = round;\n        this.player1 = player1;\n        this.player2 = player2;\n        health1 = Integer.valueOf(player1._health());\n        health2 = Integer.valueOf(player2._health());\n    }\n\n    /**\n     * @see java.lang.Object#hashCode()\n     */\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((player1 == null) ? 0 : player1.hashCode());\n        result = prime * result + round;\n        return result;\n    }\n\n    /**\n     * @see java.lang.Object#equals(java.lang.Object)\n     */\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!(obj instanceof PositionSwitch)) {\n            return false;\n        }\n        final PositionSwitch other = (PositionSwitch) obj;\n        if (player1 == null) {\n            if (other.player1 != null) {\n                return false;\n            }\n        } else if (!player1.equals(other.player1)) {\n            return false;\n        }\n        if (round != other.round) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * @see java.lang.Comparable#compareTo(java.lang.Object)\n     */\n    public int compareTo(final PositionSwitch o) {\n        int order = -1;\n        if (equals(o)) {\n            order = 0;\n        } else if (round > o.round) {\n            order = 1;\n        } else if (round == o.round) {\n            order = player1.getName().compareTo(o.player1.getName());\n        }\n        return order;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/PositionSwitch_0Test.java",
		"test_prompt": "// PositionSwitch_0Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PositionSwitch}.\n* It contains ten unit test cases for the {@link PositionSwitch#hashCode()} method.\n*/\nclass PositionSwitch_0Test {"
	},
	{
		"original_code": "// PositionSwitch.java\npackage de.outstare.fortbattleplayer.statistics;\n\nimport de.outstare.fortbattleplayer.model.Combatant;\n\n/**\n * Two {@link Combatant}s switched positions.\n *\n * They will be sorted by round and playername\n *\n * @author daniel\n */\npublic class PositionSwitch implements Comparable<PositionSwitch> {\n\n    /**\n     * number of the round in which this swap occured\n     */\n    public final int round;\n\n    /**\n     * one of the switched players\n     */\n    public final Combatant player1;\n\n    /**\n     * the HP of player1\n     */\n    public final Integer health1;\n\n    /**\n     * the other combatant who switched places\n     */\n    public final Combatant player2;\n\n    /**\n     * the HP of player2\n     */\n    public final Integer health2;\n\n    /**\n     * @param round\n     * @param player1\n     * @param player2\n     */\n    PositionSwitch(final int round, final Combatant player1, final Combatant player2) {\n        this.round = round;\n        this.player1 = player1;\n        this.player2 = player2;\n        health1 = Integer.valueOf(player1._health());\n        health2 = Integer.valueOf(player2._health());\n    }\n\n    /**\n     * @see java.lang.Object#hashCode()\n     */\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((player1 == null) ? 0 : player1.hashCode());\n        result = prime * result + round;\n        return result;\n    }\n\n    /**\n     * @see java.lang.Object#equals(java.lang.Object)\n     */\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!(obj instanceof PositionSwitch)) {\n            return false;\n        }\n        final PositionSwitch other = (PositionSwitch) obj;\n        if (player1 == null) {\n            if (other.player1 != null) {\n                return false;\n            }\n        } else if (!player1.equals(other.player1)) {\n            return false;\n        }\n        if (round != other.round) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * @see java.lang.Comparable#compareTo(java.lang.Object)\n     */\n    public int compareTo(final PositionSwitch o) {\n        int order = -1;\n        if (equals(o)) {\n            order = 0;\n        } else if (round > o.round) {\n            order = 1;\n        } else if (round == o.round) {\n            order = player1.getName().compareTo(o.player1.getName());\n        }\n        return order;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/PositionSwitch_1Test.java",
		"test_prompt": "// PositionSwitch_1Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PositionSwitch}.\n* It contains ten unit test cases for the {@link PositionSwitch#equals(Object)} method.\n*/\nclass PositionSwitch_1Test {"
	},
	{
		"original_code": "// PositionSwitch.java\npackage de.outstare.fortbattleplayer.statistics;\n\nimport de.outstare.fortbattleplayer.model.Combatant;\n\n/**\n * Two {@link Combatant}s switched positions.\n *\n * They will be sorted by round and playername\n *\n * @author daniel\n */\npublic class PositionSwitch implements Comparable<PositionSwitch> {\n\n    /**\n     * number of the round in which this swap occured\n     */\n    public final int round;\n\n    /**\n     * one of the switched players\n     */\n    public final Combatant player1;\n\n    /**\n     * the HP of player1\n     */\n    public final Integer health1;\n\n    /**\n     * the other combatant who switched places\n     */\n    public final Combatant player2;\n\n    /**\n     * the HP of player2\n     */\n    public final Integer health2;\n\n    /**\n     * @param round\n     * @param player1\n     * @param player2\n     */\n    PositionSwitch(final int round, final Combatant player1, final Combatant player2) {\n        this.round = round;\n        this.player1 = player1;\n        this.player2 = player2;\n        health1 = Integer.valueOf(player1._health());\n        health2 = Integer.valueOf(player2._health());\n    }\n\n    /**\n     * @see java.lang.Object#hashCode()\n     */\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((player1 == null) ? 0 : player1.hashCode());\n        result = prime * result + round;\n        return result;\n    }\n\n    /**\n     * @see java.lang.Object#equals(java.lang.Object)\n     */\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!(obj instanceof PositionSwitch)) {\n            return false;\n        }\n        final PositionSwitch other = (PositionSwitch) obj;\n        if (player1 == null) {\n            if (other.player1 != null) {\n                return false;\n            }\n        } else if (!player1.equals(other.player1)) {\n            return false;\n        }\n        if (round != other.round) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * @see java.lang.Comparable#compareTo(java.lang.Object)\n     */\n    public int compareTo(final PositionSwitch o) {\n        int order = -1;\n        if (equals(o)) {\n            order = 0;\n        } else if (round > o.round) {\n            order = 1;\n        } else if (round == o.round) {\n            order = player1.getName().compareTo(o.player1.getName());\n        }\n        return order;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/PositionSwitch_2Test.java",
		"test_prompt": "// PositionSwitch_2Test.java\npackage de.outstare.fortbattleplayer.statistics;\n\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PositionSwitch}.\n* It contains ten unit test cases for the {@link PositionSwitch#compareTo(PositionSwitch)} method.\n*/\nclass PositionSwitch_2Test {"
	},
	{
		"original_code": "// RoundStatistics.java\npackage de.outstare.fortbattleplayer.statistics;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * A {@link RoundStatistics} has a value for each round of the battle.\n *\n * @author daniel\n */\nclass RoundStatistics implements LabeledData {\n\n    private final List<Double> values = new ArrayList<Double>();\n\n    private final String description;\n\n    private final String type;\n\n    /**\n     * @param name\n     *            what this statistic is\n     * @param type\n     *            of the values\n     */\n    RoundStatistics(final String name, final String type) {\n        assert name != null && type != null : \"parameters may not be null!\";\n        description = name;\n        this.type = type;\n    }\n\n    /**\n     * @param value\n     *            to add to this set of data\n     */\n    void addValue(final double value) {\n        values.add(Double.valueOf(value));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.LabeledData#getDescription()\n     */\n    public String getDescription() {\n        return description;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.LabeledData#getValueType()\n     */\n    public String getValueType() {\n        return type;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.statistics.LabeledData#toArray()\n     */\n    public double[] toArray() {\n        final double[] primitives = new double[values.size()];\n        int i = 0;\n        for (final Double value : values) {\n            primitives[i] = value.doubleValue();\n            i++;\n        }\n        return primitives;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/statistics/RoundStatistics.java",
		"test_prompt": "// RoundStatisticsTest.java\npackage de.outstare.fortbattleplayer.statistics;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RoundStatistics}.\n* It contains ten unit test cases for the {@link RoundStatistics#toArray()} method.\n*/\nclass RoundStatisticsTest {"
	},
	{
		"original_code": "// LogToText.java\npackage de.outstare.fortbattleplayer.parser;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.nio.CharBuffer;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\n/**\n * Converts the list of numbers to somewhat meaningfuller names\n *\n * @author daniel\n */\npublic class LogToText {\n\n    private static final String NEWLINE = System.getProperty(\"line.separator\");\n\n    private static boolean WRITE_EACH_ROUND_TO_FILE = false;\n\n    /**\n     * entry point\n     *\n     * @param args\n     */\n    public static void main(final String[] args) {\n        if (args.length == 0) {\n            System.out.println(\"Please give a file with fortbattle data! Optionally append the parameter '-r' to write each round to a separate file (named round<n>.txt)\");\n        } else {\n            final String filename = args[0];\n            if (args.length > 1 && \"-r\".equals(args[1])) {\n                WRITE_EACH_ROUND_TO_FILE = true;\n            }\n            final File file = new File(filename);\n            if (file.canRead() && file.isFile()) {\n                final LogToText parser = new LogToText();\n                JSONObject data;\n                try {\n                    data = parser.parseFile(file);\n                    System.out.println(parser.getLog(data));\n                } catch (final JSONException e) {\n                    e.printStackTrace();\n                } catch (final IOException e) {\n                    e.printStackTrace();\n                }\n            } else {\n                System.out.println(\"The given argument is not an readable file!\");\n            }\n        }\n    }\n\n    /**\n     * @param data\n     * @return\n     * @throws JSONException\n     */\n    private CharSequence getLog(final JSONObject data) throws JSONException {\n        final Map<Integer, String> players = getCombatants(data);\n        final String log = getTextLog(data, players);\n        return log;\n    }\n\n    /**\n     * @param data\n     * @param players\n     * @return\n     * @throws JSONException\n     */\n    private String getTextLog(final JSONObject data, final Map<Integer, String> players) throws JSONException {\n        final JSONArray typeNames = data.getJSONArray(\"logtypes\");\n        final JSONArray log = data.getJSONArray(\"log\");\n        final StringBuilder formattedLog = new StringBuilder();\n        try {\n            Writer output = null;\n            try {\n                if (WRITE_EACH_ROUND_TO_FILE) {\n                    output = new FileWriter(\"round0.txt\");\n                }\n                // System.out.println(\"formatting log data...\");\n                for (int i = 0; i < log.length(); i += 2) {\n                    final int typeValue = (int) log.getLong(i);\n                    final int value = (int) log.getLong(i + 1);\n                    try {\n                        final LogType type = LogType.valueOf(typeNames.getString(typeValue));\n                        final String formattedValue = formatValue(players, value, type);\n                        if (WRITE_EACH_ROUND_TO_FILE && output != null) {\n                            if (type == LogType.ROUNDSTART) {\n                                output.close();\n                                output = new FileWriter(\"round\" + value + \".txt\");\n                            }\n                            output.write(type.toString());\n                            output.write(' ');\n                            output.write(formattedValue);\n                            output.write('\\n');\n                        }\n                        appendLogLine(formattedLog, type, formattedValue);\n                    } catch (final IllegalArgumentException e) {\n                        System.err.println(\"unknown log type: \" + typeNames.getString(typeValue) + \" [\" + typeValue + \"]\");\n                        continue;\n                    }\n                }\n            } finally {\n                if (WRITE_EACH_ROUND_TO_FILE && output != null) {\n                    output.close();\n                }\n            }\n        } catch (final IOException e) {\n            e.printStackTrace();\n        }\n        return formattedLog.toString();\n    }\n\n    /**\n     * @param players\n     * @param value\n     * @param type\n     * @return\n     */\n    private String formatValue(final Map<Integer, String> players, final int value, final LogType type) {\n        String formattedValue;\n        switch(type) {\n            case SHOOTAT:\n            case CHARTURN:\n                formattedValue = players.get(Integer.valueOf(value));\n                break;\n            default:\n                formattedValue = Integer.toString(value);\n        }\n        return formattedValue;\n    }\n\n    /**\n     * @param formattedLog\n     * @param type\n     * @param formattedValue\n     */\n    private void appendLogLine(final StringBuilder formattedLog, final LogType type, final String formattedValue) {\n        formattedLog.append(type.toString());\n        formattedLog.append(' ');\n        formattedLog.append(formattedValue);\n        formattedLog.append(NEWLINE);\n    }\n\n    /**\n     * @param data\n     * @return\n     * @throws JSONException\n     */\n    private Map<Integer, String> getCombatants(final JSONObject data) throws JSONException {\n        final Map<Integer, String> combatants = new HashMap<Integer, String>();\n        final String[] playerArrays = new String[] { \"attackerlist\", \"defenderlist\" };\n        // System.out.println(\"reading player names...\");\n        for (final String playerArray : playerArrays) {\n            final JSONArray list = data.getJSONArray(playerArray);\n            for (int i = 0; i < list.length(); i++) {\n                final JSONObject playerData = list.getJSONObject(i);\n                final String playerName = playerData.getString(\"name\");\n                final Integer playerID = Integer.valueOf(playerData.getInt(\"westid\"));\n                combatants.put(playerID, playerName);\n            }\n        }\n        return combatants;\n    }\n\n    /**\n     * @param file\n     * @return the json data of the file\n     * @throws JSONException\n     * @throws IOException\n     */\n    public JSONObject parseFile(final File file) throws JSONException, IOException {\n        final String text = readFile(file);\n        return new JSONObject(text);\n    }\n\n    /**\n     * @param file\n     * @return\n     * @throws IOException\n     */\n    private String readFile(final File file) throws IOException {\n        final Reader reader = new BufferedReader(new FileReader(file));\n        try {\n            final CharBuffer buffer = CharBuffer.allocate((int) file.length());\n            int count;\n            // System.out.println(\"reading file...\");\n            do {\n                count = reader.read(buffer);\n            } while (count > 0);\n            buffer.position(0);\n            return buffer.toString();\n        } finally {\n            reader.close();\n        }\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/parser/LogToText.java",
		"test_prompt": "// LogToTextTest.java\npackage de.outstare.fortbattleplayer.parser;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.nio.CharBuffer;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link LogToText}.\n* It contains ten unit test cases for the {@link LogToText#parseFile(File)} method.\n*/\nclass LogToTextTest {"
	},
	{
		"original_code": "// BattleFieldLayoutManager.java\npackage de.outstare.fortbattleplayer.gui.battlefield;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.awt.Component;\nimport java.awt.Container;\nimport java.awt.Dimension;\nimport java.awt.GridLayout;\nimport java.awt.LayoutManager;\nimport java.awt.Point;\nimport java.awt.Rectangle;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Battlefield;\n\n/**\n * A BattleFieldLayoutManager sets the children into cells like a\n * {@link GridLayout}. But the cell is determined by the\n * {@link BattlefieldCell#getCellCoordinates()} (similar to\n * {@link Component#getLocation()}.\n *\n * @author daniel\n */\nclass BattleFieldLayoutManager implements LayoutManager {\n\n    private static final Logger LOG = Logger.getLogger(BattleFieldLayoutManager.class.getName());\n\n    final static int mimimum_cell_width = 3;\n\n    final static int mimimum_cell_height = 3;\n\n    final static int prefered_cell_width = 15;\n\n    final static int prefered_cell_height = 15;\n\n    private final int cellcount_x;\n\n    private final int cellcount_y;\n\n    /**\n     * @param battlefield\n     */\n    BattleFieldLayoutManager(final Battlefield battlefield) {\n        cellcount_x = battlefield.getWidth();\n        cellcount_y = battlefield.getHeight();\n    }\n\n    /**\n     * @see java.awt.LayoutManager#addLayoutComponent(java.lang.String,\n     *      java.awt.Component)\n     */\n    public void addLayoutComponent(final String name, final Component comp) {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * @see java.awt.LayoutManager#layoutContainer(java.awt.Container)\n     */\n    public void layoutContainer(final Container parent) {\n        final Dimension cellSize = calculateCellSize(parent);\n        synchronized (parent.getTreeLock()) {\n            for (final Component child : parent.getComponents()) {\n                if (!child.isVisible()) {\n                    continue;\n                }\n                if (child instanceof BattlefieldCell) {\n                    layoutCell(cellSize, (BattlefieldCell) child);\n                } else if (child instanceof PlayerDrawing) {\n                    // players may be childs when they are moving\n                    // they are not layout but directly painted in MoveAnimation\n                } else {\n                    LOG.warning(\"no BattlefieldCell - not layouting \" + child);\n                }\n            }\n        }\n    }\n\n    /**\n     * position and resize the given cell\n     *\n     * @param cellSize\n     * @param cell\n     */\n    private void layoutCell(final Dimension cellSize, final BattlefieldCell cell) {\n        final Point cellCoords = cell.getCellCoordinates();\n        final Point pixelCoords = new Point(cellCoords.x * cellSize.width, cellCoords.y * cellSize.height);\n        final Rectangle cellDrawingSpace = new Rectangle(pixelCoords, cellSize);\n        cell.setBounds(cellDrawingSpace);\n    }\n\n    /**\n     * @param parent\n     * @return the size in pixels of a drawn cell\n     */\n    private Dimension calculateCellSize(final Container parent) {\n        final int bfWidth = parent.getWidth();\n        final int bfHeight = parent.getHeight();\n        final int cellWidth = bfWidth / cellcount_x;\n        final int cellHeight = bfHeight / cellcount_y;\n        return new Dimension(cellWidth, cellHeight);\n    }\n\n    /**\n     * @see java.awt.LayoutManager#minimumLayoutSize(java.awt.Container)\n     */\n    public Dimension minimumLayoutSize(final Container parent) {\n        return new Dimension(mimimum_cell_width * cellcount_x, mimimum_cell_height * cellcount_y);\n    }\n\n    /**\n     * @see java.awt.LayoutManager#preferredLayoutSize(java.awt.Container)\n     */\n    public Dimension preferredLayoutSize(final Container parent) {\n        return new Dimension(prefered_cell_width * cellcount_x, prefered_cell_height * cellcount_y);\n    }\n\n    /**\n     * @see java.awt.LayoutManager#removeLayoutComponent(java.awt.Component)\n     */\n    public void removeLayoutComponent(final Component comp) {\n        // no components here\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/gui/battlefield/BattleFieldLayoutManager_0Test.java",
		"test_prompt": "// BattleFieldLayoutManager_0Test.java\npackage de.outstare.fortbattleplayer.gui.battlefield;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.awt.Component;\nimport java.awt.Container;\nimport java.awt.Dimension;\nimport java.awt.GridLayout;\nimport java.awt.LayoutManager;\nimport java.awt.Point;\nimport java.awt.Rectangle;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Battlefield;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BattleFieldLayoutManager}.\n* It contains ten unit test cases for the {@link BattleFieldLayoutManager#minimumLayoutSize(Container)} method.\n*/\nclass BattleFieldLayoutManager_0Test {"
	},
	{
		"original_code": "// BattleFieldLayoutManager.java\npackage de.outstare.fortbattleplayer.gui.battlefield;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.awt.Component;\nimport java.awt.Container;\nimport java.awt.Dimension;\nimport java.awt.GridLayout;\nimport java.awt.LayoutManager;\nimport java.awt.Point;\nimport java.awt.Rectangle;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Battlefield;\n\n/**\n * A BattleFieldLayoutManager sets the children into cells like a\n * {@link GridLayout}. But the cell is determined by the\n * {@link BattlefieldCell#getCellCoordinates()} (similar to\n * {@link Component#getLocation()}.\n *\n * @author daniel\n */\nclass BattleFieldLayoutManager implements LayoutManager {\n\n    private static final Logger LOG = Logger.getLogger(BattleFieldLayoutManager.class.getName());\n\n    final static int mimimum_cell_width = 3;\n\n    final static int mimimum_cell_height = 3;\n\n    final static int prefered_cell_width = 15;\n\n    final static int prefered_cell_height = 15;\n\n    private final int cellcount_x;\n\n    private final int cellcount_y;\n\n    /**\n     * @param battlefield\n     */\n    BattleFieldLayoutManager(final Battlefield battlefield) {\n        cellcount_x = battlefield.getWidth();\n        cellcount_y = battlefield.getHeight();\n    }\n\n    /**\n     * @see java.awt.LayoutManager#addLayoutComponent(java.lang.String,\n     *      java.awt.Component)\n     */\n    public void addLayoutComponent(final String name, final Component comp) {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * @see java.awt.LayoutManager#layoutContainer(java.awt.Container)\n     */\n    public void layoutContainer(final Container parent) {\n        final Dimension cellSize = calculateCellSize(parent);\n        synchronized (parent.getTreeLock()) {\n            for (final Component child : parent.getComponents()) {\n                if (!child.isVisible()) {\n                    continue;\n                }\n                if (child instanceof BattlefieldCell) {\n                    layoutCell(cellSize, (BattlefieldCell) child);\n                } else if (child instanceof PlayerDrawing) {\n                    // players may be childs when they are moving\n                    // they are not layout but directly painted in MoveAnimation\n                } else {\n                    LOG.warning(\"no BattlefieldCell - not layouting \" + child);\n                }\n            }\n        }\n    }\n\n    /**\n     * position and resize the given cell\n     *\n     * @param cellSize\n     * @param cell\n     */\n    private void layoutCell(final Dimension cellSize, final BattlefieldCell cell) {\n        final Point cellCoords = cell.getCellCoordinates();\n        final Point pixelCoords = new Point(cellCoords.x * cellSize.width, cellCoords.y * cellSize.height);\n        final Rectangle cellDrawingSpace = new Rectangle(pixelCoords, cellSize);\n        cell.setBounds(cellDrawingSpace);\n    }\n\n    /**\n     * @param parent\n     * @return the size in pixels of a drawn cell\n     */\n    private Dimension calculateCellSize(final Container parent) {\n        final int bfWidth = parent.getWidth();\n        final int bfHeight = parent.getHeight();\n        final int cellWidth = bfWidth / cellcount_x;\n        final int cellHeight = bfHeight / cellcount_y;\n        return new Dimension(cellWidth, cellHeight);\n    }\n\n    /**\n     * @see java.awt.LayoutManager#minimumLayoutSize(java.awt.Container)\n     */\n    public Dimension minimumLayoutSize(final Container parent) {\n        return new Dimension(mimimum_cell_width * cellcount_x, mimimum_cell_height * cellcount_y);\n    }\n\n    /**\n     * @see java.awt.LayoutManager#preferredLayoutSize(java.awt.Container)\n     */\n    public Dimension preferredLayoutSize(final Container parent) {\n        return new Dimension(prefered_cell_width * cellcount_x, prefered_cell_height * cellcount_y);\n    }\n\n    /**\n     * @see java.awt.LayoutManager#removeLayoutComponent(java.awt.Component)\n     */\n    public void removeLayoutComponent(final Component comp) {\n        // no components here\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/gui/battlefield/BattleFieldLayoutManager_1Test.java",
		"test_prompt": "// BattleFieldLayoutManager_1Test.java\npackage de.outstare.fortbattleplayer.gui.battlefield;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.awt.Component;\nimport java.awt.Container;\nimport java.awt.Dimension;\nimport java.awt.GridLayout;\nimport java.awt.LayoutManager;\nimport java.awt.Point;\nimport java.awt.Rectangle;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Battlefield;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BattleFieldLayoutManager}.\n* It contains ten unit test cases for the {@link BattleFieldLayoutManager#preferredLayoutSize(Container)} method.\n*/\nclass BattleFieldLayoutManager_1Test {"
	},
	{
		"original_code": "// Messages.java\npackage de.outstare.fortbattleplayer.gui;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.MissingResourceException;\nimport java.util.ResourceBundle;\n\n/**\n * @author daniel\n */\npublic class Messages {\n\n    //$NON-NLS-1$\n    private static final String BUNDLE_NAME = \"de.outstare.fortbattleplayer.gui.messages\";\n\n    private static final ResourceBundle RESOURCE_BUNDLE = ResourceBundle.getBundle(BUNDLE_NAME);\n\n    private Messages() {\n        // only static methods\n    }\n\n    /**\n     * @param key\n     * @return the text for the given key\n     */\n    public static String getString(final String key) {\n        try {\n            return RESOURCE_BUNDLE.getString(key);\n        } catch (final MissingResourceException e) {\n            return '!' + key + '!';\n        }\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/gui/Messages.java",
		"test_prompt": "// MessagesTest.java\npackage de.outstare.fortbattleplayer.gui;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.MissingResourceException;\nimport java.util.ResourceBundle;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Messages}.\n* It contains ten unit test cases for the {@link Messages#getString(String)} method.\n*/\nclass MessagesTest {"
	},
	{
		"original_code": "// GuiPlayer.java\npackage de.outstare.fortbattleplayer.gui;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.awt.BorderLayout;\nimport java.awt.Component;\nimport java.awt.GridLayout;\nimport java.awt.LayoutManager;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.util.HashSet;\nimport java.util.Locale;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport javax.swing.JButton;\nimport javax.swing.JComponent;\nimport javax.swing.JFrame;\nimport javax.swing.JInternalFrame;\nimport javax.swing.JPanel;\nimport org.json.JSONException;\nimport de.outstare.fortbattleplayer.gui.battlefield.BattlefieldDrawing;\nimport de.outstare.fortbattleplayer.gui.battlefield.PlayerDrawing;\nimport de.outstare.fortbattleplayer.gui.battlefield.PlayerDrawingDB;\nimport de.outstare.fortbattleplayer.gui.search.SearchPanel;\nimport de.outstare.fortbattleplayer.gui.statistics.DataPanel;\nimport de.outstare.fortbattleplayer.gui.statistics.StatisticsPanel;\nimport de.outstare.fortbattleplayer.model.Battlefield;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.Fortbattle;\nimport de.outstare.fortbattleplayer.player.Battleplan;\nimport de.outstare.fortbattleplayer.player.Battleplayer;\nimport de.outstare.fortbattleplayer.player.CombatantEventDispatcher;\nimport de.outstare.fortbattleplayer.statistics.AllStatistics;\n\n/**\n * A GuiPlayer shows a FortBattle. During execution the player visualizes the\n * battle. Meaning all events have to be handled to the gui.\n *\n * @author daniel\n */\npublic class GuiPlayer extends JInternalFrame implements PlayerDrawingDB {\n\n    /**\n     * shows either only the Center of the given panel or all parts\n     *\n     * @author daniel\n     */\n    private static class FullscreenSwitcher implements ActionListener {\n\n        private final JPanel _panel;\n\n        private final JButton _fsButton;\n\n        /**\n         * @param panel\n         *            with {@link BorderLayout}\n         * @param fsButton\n         */\n        FullscreenSwitcher(final JPanel panel, final JButton fsButton) {\n            _panel = panel;\n            _fsButton = fsButton;\n        }\n\n        public void actionPerformed(final ActionEvent e) {\n            boolean othersVisible;\n            if (Messages.getString(\"GuiPlayer.fullscreen\").equals(_fsButton.getText())) {\n                //$NON-NLS-1$\n                othersVisible = false;\n                //$NON-NLS-1$\n                _fsButton.setText(Messages.getString(\"GuiPlayer.showAll\"));\n            } else {\n                othersVisible = true;\n                //$NON-NLS-1$\n                _fsButton.setText(Messages.getString(\"GuiPlayer.fullscreen\"));\n            }\n            final LayoutManager mainLayout = _panel.getLayout();\n            if (mainLayout instanceof BorderLayout) {\n                final BorderLayout layout = (BorderLayout) mainLayout;\n                final String[] directions = new String[] { BorderLayout.NORTH, BorderLayout.LINE_START, BorderLayout.LINE_END, BorderLayout.SOUTH };\n                for (final String direction : directions) {\n                    final Component comp = layout.getLayoutComponent(direction);\n                    setVisible(comp, othersVisible);\n                }\n            }\n        }\n\n        /**\n         * checks if comp may be <code>null</code>\n         *\n         * @param comp\n         * @param isVisible\n         */\n        private void setVisible(final Component comp, final boolean isVisible) {\n            if (comp != null) {\n                comp.setVisible(isVisible);\n            }\n        }\n    }\n\n    private static final long serialVersionUID = -3770016315108490794L;\n\n    private static final transient Logger LOG = Logger.getLogger(GuiPlayer.class.getName());\n\n    private final Battleplayer controller;\n\n    private final Set<PlayerDrawing> players = new HashSet<PlayerDrawing>();\n\n    /**\n     * creates a new player for the given data\n     *\n     * @param battle\n     * @param version\n     *            to show to the user\n     * @throws JSONException\n     */\n    public GuiPlayer(final Fortbattle battle, final String version) {\n        //$NON-NLS-1$ //$NON-NLS-2$\n        super(Messages.getString(\"GuiPlayer.title\") + battle.getFortname() + \" - v\" + version);\n        final Battlefield battlefield = battle.getBattlefield();\n        final Set<Combatant> combatants = loadCombatants(battle);\n        final Battleplan plan = battle.getActions();\n        final CombatantEventDispatcher combatantEvents = new CombatantEventDispatcher(combatants);\n        final AllStatistics stats = battle.getStatistic();\n        final StatisticsPanel statsPanel = new StatisticsPanel(stats);\n        final DataPanel dataPanel = new DataPanel(stats);\n        controller = new Battleplayer(plan);\n        final JPanel statusPanel = createStatusPanel(combatants, combatantEvents);\n        final BattlefieldDrawing gui = new BattlefieldDrawing(battlefield, battle.getMapImage(), controller.config, stats.battle.getFieldStatistics());\n        final JPanel log = new LogPanel(controller, combatantEvents);\n        createCombatantDrawings(combatants, gui);\n        controller.addRoundListener(gui);\n        initFrame(gui, statusPanel, log, statsPanel, dataPanel);\n    }\n\n    /**\n     * @param combatants\n     * @param combatantEvents\n     * @return\n     */\n    private JPanel createStatusPanel(final Set<Combatant> combatants, final CombatantEventDispatcher combatantEvents) {\n        int countAttacker = 0;\n        int countDefenders = 0;\n        int hpAttackers = 0;\n        int hpDefenders = 0;\n        for (final Combatant combatant : combatants) {\n            switch(combatant.getSide()) {\n                case ATTACKER:\n                    countAttacker++;\n                    hpAttackers += combatant._health();\n                    break;\n                case DEFENDER:\n                    countDefenders++;\n                    hpDefenders += combatant._health();\n                    break;\n                default:\n                    //$NON-NLS-1$\n                    LOG.warning(\"unknown combatant side: \" + combatant.getSide());\n            }\n        }\n        final StatusPanel status = new StatusPanel(countAttacker, countDefenders, hpAttackers, hpDefenders);\n        combatantEvents.addCombatantObserver(status);\n        return status;\n    }\n\n    /**\n     * sets the gui stuff\n     *\n     * @param gui\n     * @param statusPanel\n     * @param log2\n     * @param statsPanel\n     */\n    private void initFrame(final BattlefieldDrawing gui, final JPanel statusPanel, final JPanel log, final JComponent statsPanel, final JPanel dataPanel) {\n        //$NON-NLS-1$\n        final JButton statsButton = new JButton(Messages.getString(\"GuiPlayer.statisticButton\"));\n        statsButton.addActionListener(new ActionListener() {\n\n            public void actionPerformed(final ActionEvent e) {\n                //$NON-NLS-1$\n                final JFrame popup = new PopupWindow(Messages.getString(\"GuiPlayer.statisticTitle\"), GuiPlayer.this);\n                popup.setContentPane(statsPanel);\n                popup.pack();\n                // move to center after resize\n                popup.setLocationRelativeTo(GuiPlayer.this);\n            }\n        });\n        final JPanel rightSide = new JPanel(new GridLayout(2, 1));\n        rightSide.add(statsButton);\n        rightSide.add(dataPanel);\n        setClosable(true);\n        setResizable(true);\n        setMaximizable(true);\n        final JPanel leftSide = new JPanel(new BorderLayout());\n        leftSide.add(statusPanel, BorderLayout.NORTH);\n        leftSide.add(new SearchPanel(this), BorderLayout.SOUTH);\n        // the panel is needed for correct repainting of the BattlefieldDrawing\n        final JPanel panel = new JPanel(new BorderLayout());\n        final JPanel center = new JPanel(new BorderLayout());\n        center.add(createFullscreenButton(panel), BorderLayout.NORTH);\n        center.add(gui, BorderLayout.CENTER);\n        panel.add(center, BorderLayout.CENTER);\n        panel.add(new ControlPanel(controller), BorderLayout.NORTH);\n        panel.add(rightSide, BorderLayout.LINE_END);\n        panel.add(leftSide, BorderLayout.LINE_START);\n        panel.add(log, BorderLayout.SOUTH);\n        setContentPane(panel);\n        setSize(600, 450);\n        setVisible(true);\n    }\n\n    /**\n     * @param panel\n     *            where only the center or all should be visible\n     * @return\n     */\n    private JComponent createFullscreenButton(final JPanel panel) {\n        //$NON-NLS-1$\n        final JButton fsButton = new JButton(Messages.getString(\"GuiPlayer.fullscreen\"));\n        fsButton.addActionListener(new FullscreenSwitcher(panel, fsButton));\n        return fsButton;\n    }\n\n    private Set<Combatant> loadCombatants(final Fortbattle battle) {\n        final Set<Combatant> allCombatants = new HashSet<Combatant>();\n        final Set<Combatant> attackers = battle.getAttackers();\n        for (final Combatant attacker : attackers) {\n            allCombatants.add(attacker);\n        }\n        final Set<Combatant> defenders = battle.getDefenders();\n        for (final Combatant defender : defenders) {\n            allCombatants.add(defender);\n        }\n        return allCombatants;\n    }\n\n    /**\n     * @param combatants\n     * @param battlefield\n     * @throws JSONException\n     */\n    private void createCombatantDrawings(final Set<Combatant> combatants, final BattlefieldDrawing battlefield) {\n        PlayerDrawing drawing = null;\n        for (final Combatant combatant : combatants) {\n            // the instance binds itself to the battlefield\n            drawing = new PlayerDrawing(combatant, battlefield);\n            addPlayer(drawing);\n        }\n    }\n\n    /**\n     * show the complete battle\n     */\n    public void play() {\n        controller.play();\n    }\n\n    /**\n     * stop the animation\n     */\n    public void stop() {\n        controller.stop();\n    }\n\n    /**\n     * @see javax.swing.JInternalFrame#dispose()\n     */\n    @Override\n    public void dispose() {\n        stop();\n        super.dispose();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.gui.battlefield.PlayerDrawingDB#addPlayer(de.outstare.fortbattleplayer.gui.battlefield.PlayerDrawing)\n     */\n    public void addPlayer(final PlayerDrawing drawing) {\n        players.add(drawing);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.gui.battlefield.PlayerDrawingDB#findUsers(java.lang.String)\n     */\n    public Set<PlayerDrawing> findUsers(final String namePart) {\n        final Set<PlayerDrawing> result = new HashSet<PlayerDrawing>();\n        final Locale locale = Locale.getDefault();\n        final String lowerCaseSearch = namePart.toLowerCase(locale);\n        LOG.info(\"searching user with \" + lowerCaseSearch);\n        for (final PlayerDrawing drawing : players) {\n            final String lowerCaseName = drawing.getCombatantName().toLowerCase(locale);\n            if (lowerCaseName.contains(lowerCaseSearch)) {\n                result.add(drawing);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.gui.battlefield.PlayerDrawingDB#findUsersWithWeapon(java.lang.String)\n     */\n    public Set<PlayerDrawing> findUsersWithWeapon(final String namePart) {\n        final Set<PlayerDrawing> result = new HashSet<PlayerDrawing>();\n        final Locale locale = Locale.getDefault();\n        final String lowerCaseSearch = namePart.toLowerCase(locale);\n        LOG.fine(\"searching weapon with \" + lowerCaseSearch);\n        for (final PlayerDrawing drawing : players) {\n            final String lowerCaseName = drawing.getGun().name().toLowerCase(locale);\n            if (lowerCaseName.contains(lowerCaseSearch)) {\n                result.add(drawing);\n            }\n        }\n        return result;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/gui/GuiPlayer_0Test.java",
		"test_prompt": "// GuiPlayer_0Test.java\npackage de.outstare.fortbattleplayer.gui;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.awt.BorderLayout;\nimport java.awt.Component;\nimport java.awt.GridLayout;\nimport java.awt.LayoutManager;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.util.HashSet;\nimport java.util.Locale;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport javax.swing.JButton;\nimport javax.swing.JComponent;\nimport javax.swing.JFrame;\nimport javax.swing.JInternalFrame;\nimport javax.swing.JPanel;\nimport org.json.JSONException;\nimport de.outstare.fortbattleplayer.gui.battlefield.BattlefieldDrawing;\nimport de.outstare.fortbattleplayer.gui.battlefield.PlayerDrawing;\nimport de.outstare.fortbattleplayer.gui.battlefield.PlayerDrawingDB;\nimport de.outstare.fortbattleplayer.gui.search.SearchPanel;\nimport de.outstare.fortbattleplayer.gui.statistics.DataPanel;\nimport de.outstare.fortbattleplayer.gui.statistics.StatisticsPanel;\nimport de.outstare.fortbattleplayer.model.Battlefield;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.Fortbattle;\nimport de.outstare.fortbattleplayer.player.Battleplan;\nimport de.outstare.fortbattleplayer.player.Battleplayer;\nimport de.outstare.fortbattleplayer.player.CombatantEventDispatcher;\nimport de.outstare.fortbattleplayer.statistics.AllStatistics;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GuiPlayer}.\n* It contains ten unit test cases for the {@link GuiPlayer#findUsers(String)} method.\n*/\nclass GuiPlayer_0Test {"
	},
	{
		"original_code": "// GuiPlayer.java\npackage de.outstare.fortbattleplayer.gui;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.awt.BorderLayout;\nimport java.awt.Component;\nimport java.awt.GridLayout;\nimport java.awt.LayoutManager;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.util.HashSet;\nimport java.util.Locale;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport javax.swing.JButton;\nimport javax.swing.JComponent;\nimport javax.swing.JFrame;\nimport javax.swing.JInternalFrame;\nimport javax.swing.JPanel;\nimport org.json.JSONException;\nimport de.outstare.fortbattleplayer.gui.battlefield.BattlefieldDrawing;\nimport de.outstare.fortbattleplayer.gui.battlefield.PlayerDrawing;\nimport de.outstare.fortbattleplayer.gui.battlefield.PlayerDrawingDB;\nimport de.outstare.fortbattleplayer.gui.search.SearchPanel;\nimport de.outstare.fortbattleplayer.gui.statistics.DataPanel;\nimport de.outstare.fortbattleplayer.gui.statistics.StatisticsPanel;\nimport de.outstare.fortbattleplayer.model.Battlefield;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.Fortbattle;\nimport de.outstare.fortbattleplayer.player.Battleplan;\nimport de.outstare.fortbattleplayer.player.Battleplayer;\nimport de.outstare.fortbattleplayer.player.CombatantEventDispatcher;\nimport de.outstare.fortbattleplayer.statistics.AllStatistics;\n\n/**\n * A GuiPlayer shows a FortBattle. During execution the player visualizes the\n * battle. Meaning all events have to be handled to the gui.\n *\n * @author daniel\n */\npublic class GuiPlayer extends JInternalFrame implements PlayerDrawingDB {\n\n    /**\n     * shows either only the Center of the given panel or all parts\n     *\n     * @author daniel\n     */\n    private static class FullscreenSwitcher implements ActionListener {\n\n        private final JPanel _panel;\n\n        private final JButton _fsButton;\n\n        /**\n         * @param panel\n         *            with {@link BorderLayout}\n         * @param fsButton\n         */\n        FullscreenSwitcher(final JPanel panel, final JButton fsButton) {\n            _panel = panel;\n            _fsButton = fsButton;\n        }\n\n        public void actionPerformed(final ActionEvent e) {\n            boolean othersVisible;\n            if (Messages.getString(\"GuiPlayer.fullscreen\").equals(_fsButton.getText())) {\n                //$NON-NLS-1$\n                othersVisible = false;\n                //$NON-NLS-1$\n                _fsButton.setText(Messages.getString(\"GuiPlayer.showAll\"));\n            } else {\n                othersVisible = true;\n                //$NON-NLS-1$\n                _fsButton.setText(Messages.getString(\"GuiPlayer.fullscreen\"));\n            }\n            final LayoutManager mainLayout = _panel.getLayout();\n            if (mainLayout instanceof BorderLayout) {\n                final BorderLayout layout = (BorderLayout) mainLayout;\n                final String[] directions = new String[] { BorderLayout.NORTH, BorderLayout.LINE_START, BorderLayout.LINE_END, BorderLayout.SOUTH };\n                for (final String direction : directions) {\n                    final Component comp = layout.getLayoutComponent(direction);\n                    setVisible(comp, othersVisible);\n                }\n            }\n        }\n\n        /**\n         * checks if comp may be <code>null</code>\n         *\n         * @param comp\n         * @param isVisible\n         */\n        private void setVisible(final Component comp, final boolean isVisible) {\n            if (comp != null) {\n                comp.setVisible(isVisible);\n            }\n        }\n    }\n\n    private static final long serialVersionUID = -3770016315108490794L;\n\n    private static final transient Logger LOG = Logger.getLogger(GuiPlayer.class.getName());\n\n    private final Battleplayer controller;\n\n    private final Set<PlayerDrawing> players = new HashSet<PlayerDrawing>();\n\n    /**\n     * creates a new player for the given data\n     *\n     * @param battle\n     * @param version\n     *            to show to the user\n     * @throws JSONException\n     */\n    public GuiPlayer(final Fortbattle battle, final String version) {\n        //$NON-NLS-1$ //$NON-NLS-2$\n        super(Messages.getString(\"GuiPlayer.title\") + battle.getFortname() + \" - v\" + version);\n        final Battlefield battlefield = battle.getBattlefield();\n        final Set<Combatant> combatants = loadCombatants(battle);\n        final Battleplan plan = battle.getActions();\n        final CombatantEventDispatcher combatantEvents = new CombatantEventDispatcher(combatants);\n        final AllStatistics stats = battle.getStatistic();\n        final StatisticsPanel statsPanel = new StatisticsPanel(stats);\n        final DataPanel dataPanel = new DataPanel(stats);\n        controller = new Battleplayer(plan);\n        final JPanel statusPanel = createStatusPanel(combatants, combatantEvents);\n        final BattlefieldDrawing gui = new BattlefieldDrawing(battlefield, battle.getMapImage(), controller.config, stats.battle.getFieldStatistics());\n        final JPanel log = new LogPanel(controller, combatantEvents);\n        createCombatantDrawings(combatants, gui);\n        controller.addRoundListener(gui);\n        initFrame(gui, statusPanel, log, statsPanel, dataPanel);\n    }\n\n    /**\n     * @param combatants\n     * @param combatantEvents\n     * @return\n     */\n    private JPanel createStatusPanel(final Set<Combatant> combatants, final CombatantEventDispatcher combatantEvents) {\n        int countAttacker = 0;\n        int countDefenders = 0;\n        int hpAttackers = 0;\n        int hpDefenders = 0;\n        for (final Combatant combatant : combatants) {\n            switch(combatant.getSide()) {\n                case ATTACKER:\n                    countAttacker++;\n                    hpAttackers += combatant._health();\n                    break;\n                case DEFENDER:\n                    countDefenders++;\n                    hpDefenders += combatant._health();\n                    break;\n                default:\n                    //$NON-NLS-1$\n                    LOG.warning(\"unknown combatant side: \" + combatant.getSide());\n            }\n        }\n        final StatusPanel status = new StatusPanel(countAttacker, countDefenders, hpAttackers, hpDefenders);\n        combatantEvents.addCombatantObserver(status);\n        return status;\n    }\n\n    /**\n     * sets the gui stuff\n     *\n     * @param gui\n     * @param statusPanel\n     * @param log2\n     * @param statsPanel\n     */\n    private void initFrame(final BattlefieldDrawing gui, final JPanel statusPanel, final JPanel log, final JComponent statsPanel, final JPanel dataPanel) {\n        //$NON-NLS-1$\n        final JButton statsButton = new JButton(Messages.getString(\"GuiPlayer.statisticButton\"));\n        statsButton.addActionListener(new ActionListener() {\n\n            public void actionPerformed(final ActionEvent e) {\n                //$NON-NLS-1$\n                final JFrame popup = new PopupWindow(Messages.getString(\"GuiPlayer.statisticTitle\"), GuiPlayer.this);\n                popup.setContentPane(statsPanel);\n                popup.pack();\n                // move to center after resize\n                popup.setLocationRelativeTo(GuiPlayer.this);\n            }\n        });\n        final JPanel rightSide = new JPanel(new GridLayout(2, 1));\n        rightSide.add(statsButton);\n        rightSide.add(dataPanel);\n        setClosable(true);\n        setResizable(true);\n        setMaximizable(true);\n        final JPanel leftSide = new JPanel(new BorderLayout());\n        leftSide.add(statusPanel, BorderLayout.NORTH);\n        leftSide.add(new SearchPanel(this), BorderLayout.SOUTH);\n        // the panel is needed for correct repainting of the BattlefieldDrawing\n        final JPanel panel = new JPanel(new BorderLayout());\n        final JPanel center = new JPanel(new BorderLayout());\n        center.add(createFullscreenButton(panel), BorderLayout.NORTH);\n        center.add(gui, BorderLayout.CENTER);\n        panel.add(center, BorderLayout.CENTER);\n        panel.add(new ControlPanel(controller), BorderLayout.NORTH);\n        panel.add(rightSide, BorderLayout.LINE_END);\n        panel.add(leftSide, BorderLayout.LINE_START);\n        panel.add(log, BorderLayout.SOUTH);\n        setContentPane(panel);\n        setSize(600, 450);\n        setVisible(true);\n    }\n\n    /**\n     * @param panel\n     *            where only the center or all should be visible\n     * @return\n     */\n    private JComponent createFullscreenButton(final JPanel panel) {\n        //$NON-NLS-1$\n        final JButton fsButton = new JButton(Messages.getString(\"GuiPlayer.fullscreen\"));\n        fsButton.addActionListener(new FullscreenSwitcher(panel, fsButton));\n        return fsButton;\n    }\n\n    private Set<Combatant> loadCombatants(final Fortbattle battle) {\n        final Set<Combatant> allCombatants = new HashSet<Combatant>();\n        final Set<Combatant> attackers = battle.getAttackers();\n        for (final Combatant attacker : attackers) {\n            allCombatants.add(attacker);\n        }\n        final Set<Combatant> defenders = battle.getDefenders();\n        for (final Combatant defender : defenders) {\n            allCombatants.add(defender);\n        }\n        return allCombatants;\n    }\n\n    /**\n     * @param combatants\n     * @param battlefield\n     * @throws JSONException\n     */\n    private void createCombatantDrawings(final Set<Combatant> combatants, final BattlefieldDrawing battlefield) {\n        PlayerDrawing drawing = null;\n        for (final Combatant combatant : combatants) {\n            // the instance binds itself to the battlefield\n            drawing = new PlayerDrawing(combatant, battlefield);\n            addPlayer(drawing);\n        }\n    }\n\n    /**\n     * show the complete battle\n     */\n    public void play() {\n        controller.play();\n    }\n\n    /**\n     * stop the animation\n     */\n    public void stop() {\n        controller.stop();\n    }\n\n    /**\n     * @see javax.swing.JInternalFrame#dispose()\n     */\n    @Override\n    public void dispose() {\n        stop();\n        super.dispose();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.gui.battlefield.PlayerDrawingDB#addPlayer(de.outstare.fortbattleplayer.gui.battlefield.PlayerDrawing)\n     */\n    public void addPlayer(final PlayerDrawing drawing) {\n        players.add(drawing);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.gui.battlefield.PlayerDrawingDB#findUsers(java.lang.String)\n     */\n    public Set<PlayerDrawing> findUsers(final String namePart) {\n        final Set<PlayerDrawing> result = new HashSet<PlayerDrawing>();\n        final Locale locale = Locale.getDefault();\n        final String lowerCaseSearch = namePart.toLowerCase(locale);\n        LOG.info(\"searching user with \" + lowerCaseSearch);\n        for (final PlayerDrawing drawing : players) {\n            final String lowerCaseName = drawing.getCombatantName().toLowerCase(locale);\n            if (lowerCaseName.contains(lowerCaseSearch)) {\n                result.add(drawing);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.gui.battlefield.PlayerDrawingDB#findUsersWithWeapon(java.lang.String)\n     */\n    public Set<PlayerDrawing> findUsersWithWeapon(final String namePart) {\n        final Set<PlayerDrawing> result = new HashSet<PlayerDrawing>();\n        final Locale locale = Locale.getDefault();\n        final String lowerCaseSearch = namePart.toLowerCase(locale);\n        LOG.fine(\"searching weapon with \" + lowerCaseSearch);\n        for (final PlayerDrawing drawing : players) {\n            final String lowerCaseName = drawing.getGun().name().toLowerCase(locale);\n            if (lowerCaseName.contains(lowerCaseSearch)) {\n                result.add(drawing);\n            }\n        }\n        return result;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/gui/GuiPlayer_1Test.java",
		"test_prompt": "// GuiPlayer_1Test.java\npackage de.outstare.fortbattleplayer.gui;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.awt.BorderLayout;\nimport java.awt.Component;\nimport java.awt.GridLayout;\nimport java.awt.LayoutManager;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.util.HashSet;\nimport java.util.Locale;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport javax.swing.JButton;\nimport javax.swing.JComponent;\nimport javax.swing.JFrame;\nimport javax.swing.JInternalFrame;\nimport javax.swing.JPanel;\nimport org.json.JSONException;\nimport de.outstare.fortbattleplayer.gui.battlefield.BattlefieldDrawing;\nimport de.outstare.fortbattleplayer.gui.battlefield.PlayerDrawing;\nimport de.outstare.fortbattleplayer.gui.battlefield.PlayerDrawingDB;\nimport de.outstare.fortbattleplayer.gui.search.SearchPanel;\nimport de.outstare.fortbattleplayer.gui.statistics.DataPanel;\nimport de.outstare.fortbattleplayer.gui.statistics.StatisticsPanel;\nimport de.outstare.fortbattleplayer.model.Battlefield;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.Fortbattle;\nimport de.outstare.fortbattleplayer.player.Battleplan;\nimport de.outstare.fortbattleplayer.player.Battleplayer;\nimport de.outstare.fortbattleplayer.player.CombatantEventDispatcher;\nimport de.outstare.fortbattleplayer.statistics.AllStatistics;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GuiPlayer}.\n* It contains ten unit test cases for the {@link GuiPlayer#findUsersWithWeapon(String)} method.\n*/\nclass GuiPlayer_1Test {"
	},
	{
		"original_code": "// SimpleSector.java\npackage de.outstare.fortbattleplayer.model.impl;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.Sector;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.SectorBonus.BonusType;\nimport de.outstare.fortbattleplayer.model.SectorObserver;\nimport de.outstare.fortbattleplayer.model.Weapon;\n\n/**\n * @author daniel\n */\npublic class SimpleSector implements Sector {\n\n    private final int height;\n\n    private final boolean defenderSpawn;\n\n    private final boolean attackerSpawn;\n\n    private final int attackBonus;\n\n    private final int defendBonus;\n\n    private final boolean flag;\n\n    private final int classBonus;\n\n    private final CharacterClass classType;\n\n    private CombatantSide occupier = null;\n\n    private int occupierCount = 0;\n\n    private final Set<Area> areas = new HashSet<Area>();\n\n    private final Set<SectorObserver> observers = new HashSet<SectorObserver>();\n\n    /**\n     * @param height\n     * @param defenderSpawn\n     * @param attackerSpawn\n     * @param attackerBonus\n     * @param defenderBonus\n     * @param flag\n     * @param classBonus\n     * @param bonusClass\n     */\n    public SimpleSector(final int height, final boolean defenderSpawn, final boolean attackerSpawn, final int attackerBonus, final int defenderBonus, final boolean flag, final int classBonus, final CharacterClass bonusClass) {\n        this.height = height;\n        this.defenderSpawn = defenderSpawn;\n        this.attackerSpawn = attackerSpawn;\n        attackBonus = attackerBonus;\n        defendBonus = defenderBonus;\n        this.flag = flag;\n        this.classBonus = classBonus;\n        classType = bonusClass;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#free()\n     */\n    public void free() {\n        if (occupierCount > 0) {\n            occupierCount--;\n        }\n        assert occupierCount >= 0 : \"more combatants lefts this sector than enter it\";\n        if (occupierCount == 0) {\n            occupier = null;\n            occupierChanged();\n        }\n    }\n\n    private void occupierChanged() {\n        // update borders to show change of occupier\n        for (final SectorObserver observer : observers) {\n            observer.occupierChanged();\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#gainControl(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public void gainControl(final CombatantSide side) {\n        occupierCount++;\n        if (occupier != side) {\n            occupier = side;\n            occupierChanged();\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#getOccupier()\n     */\n    public CombatantSide getOccupier() {\n        return occupier;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#isOccupied()\n     */\n    public boolean isOccupied() {\n        return occupier != null;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#getHeight()\n     */\n    public int getHeight() {\n        return height;\n    }\n\n    /**\n     * @return the defenderSpawn\n     */\n    public boolean isDefenderSpawn() {\n        return defenderSpawn;\n    }\n\n    /**\n     * @return the attackerSpawn\n     */\n    public boolean isAttackerSpawn() {\n        return attackerSpawn;\n    }\n\n    /**\n     * @return the flag\n     */\n    public boolean isFlag() {\n        return flag;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#getBonus(de.outstare.fortbattleplayer.model.CharacterClass)\n     */\n    public SectorBonus getBonus(final CharacterClass charClass) {\n        return new SectorBonus(getAttackBonus(charClass), getDefenseBonus(charClass), getDamageBonus());\n    }\n\n    /**\n     * @return\n     */\n    protected int getDamageBonus() {\n        return getBonusFromWeapons(BonusType.DAMAGE);\n    }\n\n    private int getBonusFromWeapons(final BonusType type) {\n        int bonus = 0;\n        for (final Area area : areas) {\n            if (area.isOccupied()) {\n                final Combatant combatant = area.getOccupier();\n                final Weapon weapon = combatant.getWeapon();\n                final int sectorBonus = weapon.getSectorBonus(type);\n                if (sectorBonus != 0) {\n                    // only count first Golden Gun\n                    bonus = sectorBonus;\n                    break;\n                }\n            }\n        }\n        return bonus;\n    }\n\n    /**\n     * @param charClass\n     * @return\n     */\n    protected int getAttackBonus(final CharacterClass charClass) {\n        int bonus = attackBonus + classBonus(charClass);\n        bonus += getBonusFromWeapons(BonusType.ATTACK);\n        return bonus;\n    }\n\n    /**\n     * @param charClass\n     * @return\n     */\n    protected int getDefenseBonus(final CharacterClass charClass) {\n        int bonus = defendBonus + classBonus(charClass);\n        bonus += getBonusFromWeapons(BonusType.DEFENSE);\n        return bonus;\n    }\n\n    /**\n     * @param charClass\n     * @return\n     */\n    protected int classBonus(final CharacterClass charClass) {\n        if (classType != charClass) {\n            return 0;\n        }\n        return classBonus;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#getAreas()\n     */\n    public Set<Area> getAreas() {\n        return areas;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#_addArea(de.outstare.fortbattleplayer.model.Area)\n     */\n    public void _addArea(final Area area) {\n        areas.add(area);\n    }\n\n    /**\n     * @see java.lang.Object#hashCode()\n     */\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((areas == null) ? 0 : areas.hashCode());\n        result = prime * result + attackBonus;\n        result = prime * result + (attackerSpawn ? 1231 : 1237);\n        result = prime * result + classBonus;\n        result = prime * result + ((classType == null) ? 0 : classType.hashCode());\n        result = prime * result + defendBonus;\n        result = prime * result + (defenderSpawn ? 1231 : 1237);\n        result = prime * result + (flag ? 1231 : 1237);\n        result = prime * result + height;\n        return result;\n    }\n\n    /**\n     * @see java.lang.Object#equals(java.lang.Object)\n     */\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!(obj instanceof SimpleSector)) {\n            return false;\n        }\n        final SimpleSector other = (SimpleSector) obj;\n        if (areas == null) {\n            if (other.areas != null) {\n                return false;\n            }\n        } else if (!areas.equals(other.areas)) {\n            return false;\n        }\n        if (attackBonus != other.attackBonus) {\n            return false;\n        }\n        if (attackerSpawn != other.attackerSpawn) {\n            return false;\n        }\n        if (classBonus != other.classBonus) {\n            return false;\n        }\n        if (classType != other.classType) {\n            return false;\n        }\n        if (defendBonus != other.defendBonus) {\n            return false;\n        }\n        if (defenderSpawn != other.defenderSpawn) {\n            return false;\n        }\n        if (flag != other.flag) {\n            return false;\n        }\n        if (height != other.height) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#addObserver(de.outstare.fortbattleplayer.model.SectorObserver)\n     */\n    public void addObserver(final SectorObserver observer) {\n        observers.add(observer);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#removeObserver(de.outstare.fortbattleplayer.model.SectorObserver)\n     */\n    public void removeObserver(final SectorObserver observer) {\n        observers.remove(observer);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/model/impl/SimpleSector_0Test.java",
		"test_prompt": "// SimpleSector_0Test.java\npackage de.outstare.fortbattleplayer.model.impl;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.Sector;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.SectorBonus.BonusType;\nimport de.outstare.fortbattleplayer.model.SectorObserver;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleSector}.\n* It contains ten unit test cases for the {@link SimpleSector#isOccupied()} method.\n*/\nclass SimpleSector_0Test {"
	},
	{
		"original_code": "// SimpleSector.java\npackage de.outstare.fortbattleplayer.model.impl;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.Sector;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.SectorBonus.BonusType;\nimport de.outstare.fortbattleplayer.model.SectorObserver;\nimport de.outstare.fortbattleplayer.model.Weapon;\n\n/**\n * @author daniel\n */\npublic class SimpleSector implements Sector {\n\n    private final int height;\n\n    private final boolean defenderSpawn;\n\n    private final boolean attackerSpawn;\n\n    private final int attackBonus;\n\n    private final int defendBonus;\n\n    private final boolean flag;\n\n    private final int classBonus;\n\n    private final CharacterClass classType;\n\n    private CombatantSide occupier = null;\n\n    private int occupierCount = 0;\n\n    private final Set<Area> areas = new HashSet<Area>();\n\n    private final Set<SectorObserver> observers = new HashSet<SectorObserver>();\n\n    /**\n     * @param height\n     * @param defenderSpawn\n     * @param attackerSpawn\n     * @param attackerBonus\n     * @param defenderBonus\n     * @param flag\n     * @param classBonus\n     * @param bonusClass\n     */\n    public SimpleSector(final int height, final boolean defenderSpawn, final boolean attackerSpawn, final int attackerBonus, final int defenderBonus, final boolean flag, final int classBonus, final CharacterClass bonusClass) {\n        this.height = height;\n        this.defenderSpawn = defenderSpawn;\n        this.attackerSpawn = attackerSpawn;\n        attackBonus = attackerBonus;\n        defendBonus = defenderBonus;\n        this.flag = flag;\n        this.classBonus = classBonus;\n        classType = bonusClass;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#free()\n     */\n    public void free() {\n        if (occupierCount > 0) {\n            occupierCount--;\n        }\n        assert occupierCount >= 0 : \"more combatants lefts this sector than enter it\";\n        if (occupierCount == 0) {\n            occupier = null;\n            occupierChanged();\n        }\n    }\n\n    private void occupierChanged() {\n        // update borders to show change of occupier\n        for (final SectorObserver observer : observers) {\n            observer.occupierChanged();\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#gainControl(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public void gainControl(final CombatantSide side) {\n        occupierCount++;\n        if (occupier != side) {\n            occupier = side;\n            occupierChanged();\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#getOccupier()\n     */\n    public CombatantSide getOccupier() {\n        return occupier;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#isOccupied()\n     */\n    public boolean isOccupied() {\n        return occupier != null;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#getHeight()\n     */\n    public int getHeight() {\n        return height;\n    }\n\n    /**\n     * @return the defenderSpawn\n     */\n    public boolean isDefenderSpawn() {\n        return defenderSpawn;\n    }\n\n    /**\n     * @return the attackerSpawn\n     */\n    public boolean isAttackerSpawn() {\n        return attackerSpawn;\n    }\n\n    /**\n     * @return the flag\n     */\n    public boolean isFlag() {\n        return flag;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#getBonus(de.outstare.fortbattleplayer.model.CharacterClass)\n     */\n    public SectorBonus getBonus(final CharacterClass charClass) {\n        return new SectorBonus(getAttackBonus(charClass), getDefenseBonus(charClass), getDamageBonus());\n    }\n\n    /**\n     * @return\n     */\n    protected int getDamageBonus() {\n        return getBonusFromWeapons(BonusType.DAMAGE);\n    }\n\n    private int getBonusFromWeapons(final BonusType type) {\n        int bonus = 0;\n        for (final Area area : areas) {\n            if (area.isOccupied()) {\n                final Combatant combatant = area.getOccupier();\n                final Weapon weapon = combatant.getWeapon();\n                final int sectorBonus = weapon.getSectorBonus(type);\n                if (sectorBonus != 0) {\n                    // only count first Golden Gun\n                    bonus = sectorBonus;\n                    break;\n                }\n            }\n        }\n        return bonus;\n    }\n\n    /**\n     * @param charClass\n     * @return\n     */\n    protected int getAttackBonus(final CharacterClass charClass) {\n        int bonus = attackBonus + classBonus(charClass);\n        bonus += getBonusFromWeapons(BonusType.ATTACK);\n        return bonus;\n    }\n\n    /**\n     * @param charClass\n     * @return\n     */\n    protected int getDefenseBonus(final CharacterClass charClass) {\n        int bonus = defendBonus + classBonus(charClass);\n        bonus += getBonusFromWeapons(BonusType.DEFENSE);\n        return bonus;\n    }\n\n    /**\n     * @param charClass\n     * @return\n     */\n    protected int classBonus(final CharacterClass charClass) {\n        if (classType != charClass) {\n            return 0;\n        }\n        return classBonus;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#getAreas()\n     */\n    public Set<Area> getAreas() {\n        return areas;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#_addArea(de.outstare.fortbattleplayer.model.Area)\n     */\n    public void _addArea(final Area area) {\n        areas.add(area);\n    }\n\n    /**\n     * @see java.lang.Object#hashCode()\n     */\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((areas == null) ? 0 : areas.hashCode());\n        result = prime * result + attackBonus;\n        result = prime * result + (attackerSpawn ? 1231 : 1237);\n        result = prime * result + classBonus;\n        result = prime * result + ((classType == null) ? 0 : classType.hashCode());\n        result = prime * result + defendBonus;\n        result = prime * result + (defenderSpawn ? 1231 : 1237);\n        result = prime * result + (flag ? 1231 : 1237);\n        result = prime * result + height;\n        return result;\n    }\n\n    /**\n     * @see java.lang.Object#equals(java.lang.Object)\n     */\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!(obj instanceof SimpleSector)) {\n            return false;\n        }\n        final SimpleSector other = (SimpleSector) obj;\n        if (areas == null) {\n            if (other.areas != null) {\n                return false;\n            }\n        } else if (!areas.equals(other.areas)) {\n            return false;\n        }\n        if (attackBonus != other.attackBonus) {\n            return false;\n        }\n        if (attackerSpawn != other.attackerSpawn) {\n            return false;\n        }\n        if (classBonus != other.classBonus) {\n            return false;\n        }\n        if (classType != other.classType) {\n            return false;\n        }\n        if (defendBonus != other.defendBonus) {\n            return false;\n        }\n        if (defenderSpawn != other.defenderSpawn) {\n            return false;\n        }\n        if (flag != other.flag) {\n            return false;\n        }\n        if (height != other.height) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#addObserver(de.outstare.fortbattleplayer.model.SectorObserver)\n     */\n    public void addObserver(final SectorObserver observer) {\n        observers.add(observer);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#removeObserver(de.outstare.fortbattleplayer.model.SectorObserver)\n     */\n    public void removeObserver(final SectorObserver observer) {\n        observers.remove(observer);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/model/impl/SimpleSector_1Test.java",
		"test_prompt": "// SimpleSector_1Test.java\npackage de.outstare.fortbattleplayer.model.impl;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.Sector;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.SectorBonus.BonusType;\nimport de.outstare.fortbattleplayer.model.SectorObserver;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleSector}.\n* It contains ten unit test cases for the {@link SimpleSector#isDefenderSpawn()} method.\n*/\nclass SimpleSector_1Test {"
	},
	{
		"original_code": "// SimpleSector.java\npackage de.outstare.fortbattleplayer.model.impl;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.Sector;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.SectorBonus.BonusType;\nimport de.outstare.fortbattleplayer.model.SectorObserver;\nimport de.outstare.fortbattleplayer.model.Weapon;\n\n/**\n * @author daniel\n */\npublic class SimpleSector implements Sector {\n\n    private final int height;\n\n    private final boolean defenderSpawn;\n\n    private final boolean attackerSpawn;\n\n    private final int attackBonus;\n\n    private final int defendBonus;\n\n    private final boolean flag;\n\n    private final int classBonus;\n\n    private final CharacterClass classType;\n\n    private CombatantSide occupier = null;\n\n    private int occupierCount = 0;\n\n    private final Set<Area> areas = new HashSet<Area>();\n\n    private final Set<SectorObserver> observers = new HashSet<SectorObserver>();\n\n    /**\n     * @param height\n     * @param defenderSpawn\n     * @param attackerSpawn\n     * @param attackerBonus\n     * @param defenderBonus\n     * @param flag\n     * @param classBonus\n     * @param bonusClass\n     */\n    public SimpleSector(final int height, final boolean defenderSpawn, final boolean attackerSpawn, final int attackerBonus, final int defenderBonus, final boolean flag, final int classBonus, final CharacterClass bonusClass) {\n        this.height = height;\n        this.defenderSpawn = defenderSpawn;\n        this.attackerSpawn = attackerSpawn;\n        attackBonus = attackerBonus;\n        defendBonus = defenderBonus;\n        this.flag = flag;\n        this.classBonus = classBonus;\n        classType = bonusClass;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#free()\n     */\n    public void free() {\n        if (occupierCount > 0) {\n            occupierCount--;\n        }\n        assert occupierCount >= 0 : \"more combatants lefts this sector than enter it\";\n        if (occupierCount == 0) {\n            occupier = null;\n            occupierChanged();\n        }\n    }\n\n    private void occupierChanged() {\n        // update borders to show change of occupier\n        for (final SectorObserver observer : observers) {\n            observer.occupierChanged();\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#gainControl(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public void gainControl(final CombatantSide side) {\n        occupierCount++;\n        if (occupier != side) {\n            occupier = side;\n            occupierChanged();\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#getOccupier()\n     */\n    public CombatantSide getOccupier() {\n        return occupier;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#isOccupied()\n     */\n    public boolean isOccupied() {\n        return occupier != null;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#getHeight()\n     */\n    public int getHeight() {\n        return height;\n    }\n\n    /**\n     * @return the defenderSpawn\n     */\n    public boolean isDefenderSpawn() {\n        return defenderSpawn;\n    }\n\n    /**\n     * @return the attackerSpawn\n     */\n    public boolean isAttackerSpawn() {\n        return attackerSpawn;\n    }\n\n    /**\n     * @return the flag\n     */\n    public boolean isFlag() {\n        return flag;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#getBonus(de.outstare.fortbattleplayer.model.CharacterClass)\n     */\n    public SectorBonus getBonus(final CharacterClass charClass) {\n        return new SectorBonus(getAttackBonus(charClass), getDefenseBonus(charClass), getDamageBonus());\n    }\n\n    /**\n     * @return\n     */\n    protected int getDamageBonus() {\n        return getBonusFromWeapons(BonusType.DAMAGE);\n    }\n\n    private int getBonusFromWeapons(final BonusType type) {\n        int bonus = 0;\n        for (final Area area : areas) {\n            if (area.isOccupied()) {\n                final Combatant combatant = area.getOccupier();\n                final Weapon weapon = combatant.getWeapon();\n                final int sectorBonus = weapon.getSectorBonus(type);\n                if (sectorBonus != 0) {\n                    // only count first Golden Gun\n                    bonus = sectorBonus;\n                    break;\n                }\n            }\n        }\n        return bonus;\n    }\n\n    /**\n     * @param charClass\n     * @return\n     */\n    protected int getAttackBonus(final CharacterClass charClass) {\n        int bonus = attackBonus + classBonus(charClass);\n        bonus += getBonusFromWeapons(BonusType.ATTACK);\n        return bonus;\n    }\n\n    /**\n     * @param charClass\n     * @return\n     */\n    protected int getDefenseBonus(final CharacterClass charClass) {\n        int bonus = defendBonus + classBonus(charClass);\n        bonus += getBonusFromWeapons(BonusType.DEFENSE);\n        return bonus;\n    }\n\n    /**\n     * @param charClass\n     * @return\n     */\n    protected int classBonus(final CharacterClass charClass) {\n        if (classType != charClass) {\n            return 0;\n        }\n        return classBonus;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#getAreas()\n     */\n    public Set<Area> getAreas() {\n        return areas;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#_addArea(de.outstare.fortbattleplayer.model.Area)\n     */\n    public void _addArea(final Area area) {\n        areas.add(area);\n    }\n\n    /**\n     * @see java.lang.Object#hashCode()\n     */\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((areas == null) ? 0 : areas.hashCode());\n        result = prime * result + attackBonus;\n        result = prime * result + (attackerSpawn ? 1231 : 1237);\n        result = prime * result + classBonus;\n        result = prime * result + ((classType == null) ? 0 : classType.hashCode());\n        result = prime * result + defendBonus;\n        result = prime * result + (defenderSpawn ? 1231 : 1237);\n        result = prime * result + (flag ? 1231 : 1237);\n        result = prime * result + height;\n        return result;\n    }\n\n    /**\n     * @see java.lang.Object#equals(java.lang.Object)\n     */\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!(obj instanceof SimpleSector)) {\n            return false;\n        }\n        final SimpleSector other = (SimpleSector) obj;\n        if (areas == null) {\n            if (other.areas != null) {\n                return false;\n            }\n        } else if (!areas.equals(other.areas)) {\n            return false;\n        }\n        if (attackBonus != other.attackBonus) {\n            return false;\n        }\n        if (attackerSpawn != other.attackerSpawn) {\n            return false;\n        }\n        if (classBonus != other.classBonus) {\n            return false;\n        }\n        if (classType != other.classType) {\n            return false;\n        }\n        if (defendBonus != other.defendBonus) {\n            return false;\n        }\n        if (defenderSpawn != other.defenderSpawn) {\n            return false;\n        }\n        if (flag != other.flag) {\n            return false;\n        }\n        if (height != other.height) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#addObserver(de.outstare.fortbattleplayer.model.SectorObserver)\n     */\n    public void addObserver(final SectorObserver observer) {\n        observers.add(observer);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#removeObserver(de.outstare.fortbattleplayer.model.SectorObserver)\n     */\n    public void removeObserver(final SectorObserver observer) {\n        observers.remove(observer);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/model/impl/SimpleSector_2Test.java",
		"test_prompt": "// SimpleSector_2Test.java\npackage de.outstare.fortbattleplayer.model.impl;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.Sector;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.SectorBonus.BonusType;\nimport de.outstare.fortbattleplayer.model.SectorObserver;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleSector}.\n* It contains ten unit test cases for the {@link SimpleSector#isAttackerSpawn()} method.\n*/\nclass SimpleSector_2Test {"
	},
	{
		"original_code": "// SimpleSector.java\npackage de.outstare.fortbattleplayer.model.impl;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.Sector;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.SectorBonus.BonusType;\nimport de.outstare.fortbattleplayer.model.SectorObserver;\nimport de.outstare.fortbattleplayer.model.Weapon;\n\n/**\n * @author daniel\n */\npublic class SimpleSector implements Sector {\n\n    private final int height;\n\n    private final boolean defenderSpawn;\n\n    private final boolean attackerSpawn;\n\n    private final int attackBonus;\n\n    private final int defendBonus;\n\n    private final boolean flag;\n\n    private final int classBonus;\n\n    private final CharacterClass classType;\n\n    private CombatantSide occupier = null;\n\n    private int occupierCount = 0;\n\n    private final Set<Area> areas = new HashSet<Area>();\n\n    private final Set<SectorObserver> observers = new HashSet<SectorObserver>();\n\n    /**\n     * @param height\n     * @param defenderSpawn\n     * @param attackerSpawn\n     * @param attackerBonus\n     * @param defenderBonus\n     * @param flag\n     * @param classBonus\n     * @param bonusClass\n     */\n    public SimpleSector(final int height, final boolean defenderSpawn, final boolean attackerSpawn, final int attackerBonus, final int defenderBonus, final boolean flag, final int classBonus, final CharacterClass bonusClass) {\n        this.height = height;\n        this.defenderSpawn = defenderSpawn;\n        this.attackerSpawn = attackerSpawn;\n        attackBonus = attackerBonus;\n        defendBonus = defenderBonus;\n        this.flag = flag;\n        this.classBonus = classBonus;\n        classType = bonusClass;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#free()\n     */\n    public void free() {\n        if (occupierCount > 0) {\n            occupierCount--;\n        }\n        assert occupierCount >= 0 : \"more combatants lefts this sector than enter it\";\n        if (occupierCount == 0) {\n            occupier = null;\n            occupierChanged();\n        }\n    }\n\n    private void occupierChanged() {\n        // update borders to show change of occupier\n        for (final SectorObserver observer : observers) {\n            observer.occupierChanged();\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#gainControl(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public void gainControl(final CombatantSide side) {\n        occupierCount++;\n        if (occupier != side) {\n            occupier = side;\n            occupierChanged();\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#getOccupier()\n     */\n    public CombatantSide getOccupier() {\n        return occupier;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#isOccupied()\n     */\n    public boolean isOccupied() {\n        return occupier != null;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#getHeight()\n     */\n    public int getHeight() {\n        return height;\n    }\n\n    /**\n     * @return the defenderSpawn\n     */\n    public boolean isDefenderSpawn() {\n        return defenderSpawn;\n    }\n\n    /**\n     * @return the attackerSpawn\n     */\n    public boolean isAttackerSpawn() {\n        return attackerSpawn;\n    }\n\n    /**\n     * @return the flag\n     */\n    public boolean isFlag() {\n        return flag;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#getBonus(de.outstare.fortbattleplayer.model.CharacterClass)\n     */\n    public SectorBonus getBonus(final CharacterClass charClass) {\n        return new SectorBonus(getAttackBonus(charClass), getDefenseBonus(charClass), getDamageBonus());\n    }\n\n    /**\n     * @return\n     */\n    protected int getDamageBonus() {\n        return getBonusFromWeapons(BonusType.DAMAGE);\n    }\n\n    private int getBonusFromWeapons(final BonusType type) {\n        int bonus = 0;\n        for (final Area area : areas) {\n            if (area.isOccupied()) {\n                final Combatant combatant = area.getOccupier();\n                final Weapon weapon = combatant.getWeapon();\n                final int sectorBonus = weapon.getSectorBonus(type);\n                if (sectorBonus != 0) {\n                    // only count first Golden Gun\n                    bonus = sectorBonus;\n                    break;\n                }\n            }\n        }\n        return bonus;\n    }\n\n    /**\n     * @param charClass\n     * @return\n     */\n    protected int getAttackBonus(final CharacterClass charClass) {\n        int bonus = attackBonus + classBonus(charClass);\n        bonus += getBonusFromWeapons(BonusType.ATTACK);\n        return bonus;\n    }\n\n    /**\n     * @param charClass\n     * @return\n     */\n    protected int getDefenseBonus(final CharacterClass charClass) {\n        int bonus = defendBonus + classBonus(charClass);\n        bonus += getBonusFromWeapons(BonusType.DEFENSE);\n        return bonus;\n    }\n\n    /**\n     * @param charClass\n     * @return\n     */\n    protected int classBonus(final CharacterClass charClass) {\n        if (classType != charClass) {\n            return 0;\n        }\n        return classBonus;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#getAreas()\n     */\n    public Set<Area> getAreas() {\n        return areas;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#_addArea(de.outstare.fortbattleplayer.model.Area)\n     */\n    public void _addArea(final Area area) {\n        areas.add(area);\n    }\n\n    /**\n     * @see java.lang.Object#hashCode()\n     */\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((areas == null) ? 0 : areas.hashCode());\n        result = prime * result + attackBonus;\n        result = prime * result + (attackerSpawn ? 1231 : 1237);\n        result = prime * result + classBonus;\n        result = prime * result + ((classType == null) ? 0 : classType.hashCode());\n        result = prime * result + defendBonus;\n        result = prime * result + (defenderSpawn ? 1231 : 1237);\n        result = prime * result + (flag ? 1231 : 1237);\n        result = prime * result + height;\n        return result;\n    }\n\n    /**\n     * @see java.lang.Object#equals(java.lang.Object)\n     */\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!(obj instanceof SimpleSector)) {\n            return false;\n        }\n        final SimpleSector other = (SimpleSector) obj;\n        if (areas == null) {\n            if (other.areas != null) {\n                return false;\n            }\n        } else if (!areas.equals(other.areas)) {\n            return false;\n        }\n        if (attackBonus != other.attackBonus) {\n            return false;\n        }\n        if (attackerSpawn != other.attackerSpawn) {\n            return false;\n        }\n        if (classBonus != other.classBonus) {\n            return false;\n        }\n        if (classType != other.classType) {\n            return false;\n        }\n        if (defendBonus != other.defendBonus) {\n            return false;\n        }\n        if (defenderSpawn != other.defenderSpawn) {\n            return false;\n        }\n        if (flag != other.flag) {\n            return false;\n        }\n        if (height != other.height) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#addObserver(de.outstare.fortbattleplayer.model.SectorObserver)\n     */\n    public void addObserver(final SectorObserver observer) {\n        observers.add(observer);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#removeObserver(de.outstare.fortbattleplayer.model.SectorObserver)\n     */\n    public void removeObserver(final SectorObserver observer) {\n        observers.remove(observer);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/model/impl/SimpleSector_3Test.java",
		"test_prompt": "// SimpleSector_3Test.java\npackage de.outstare.fortbattleplayer.model.impl;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.Sector;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.SectorBonus.BonusType;\nimport de.outstare.fortbattleplayer.model.SectorObserver;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleSector}.\n* It contains ten unit test cases for the {@link SimpleSector#isFlag()} method.\n*/\nclass SimpleSector_3Test {"
	},
	{
		"original_code": "// SimpleSector.java\npackage de.outstare.fortbattleplayer.model.impl;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.Sector;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.SectorBonus.BonusType;\nimport de.outstare.fortbattleplayer.model.SectorObserver;\nimport de.outstare.fortbattleplayer.model.Weapon;\n\n/**\n * @author daniel\n */\npublic class SimpleSector implements Sector {\n\n    private final int height;\n\n    private final boolean defenderSpawn;\n\n    private final boolean attackerSpawn;\n\n    private final int attackBonus;\n\n    private final int defendBonus;\n\n    private final boolean flag;\n\n    private final int classBonus;\n\n    private final CharacterClass classType;\n\n    private CombatantSide occupier = null;\n\n    private int occupierCount = 0;\n\n    private final Set<Area> areas = new HashSet<Area>();\n\n    private final Set<SectorObserver> observers = new HashSet<SectorObserver>();\n\n    /**\n     * @param height\n     * @param defenderSpawn\n     * @param attackerSpawn\n     * @param attackerBonus\n     * @param defenderBonus\n     * @param flag\n     * @param classBonus\n     * @param bonusClass\n     */\n    public SimpleSector(final int height, final boolean defenderSpawn, final boolean attackerSpawn, final int attackerBonus, final int defenderBonus, final boolean flag, final int classBonus, final CharacterClass bonusClass) {\n        this.height = height;\n        this.defenderSpawn = defenderSpawn;\n        this.attackerSpawn = attackerSpawn;\n        attackBonus = attackerBonus;\n        defendBonus = defenderBonus;\n        this.flag = flag;\n        this.classBonus = classBonus;\n        classType = bonusClass;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#free()\n     */\n    public void free() {\n        if (occupierCount > 0) {\n            occupierCount--;\n        }\n        assert occupierCount >= 0 : \"more combatants lefts this sector than enter it\";\n        if (occupierCount == 0) {\n            occupier = null;\n            occupierChanged();\n        }\n    }\n\n    private void occupierChanged() {\n        // update borders to show change of occupier\n        for (final SectorObserver observer : observers) {\n            observer.occupierChanged();\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#gainControl(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public void gainControl(final CombatantSide side) {\n        occupierCount++;\n        if (occupier != side) {\n            occupier = side;\n            occupierChanged();\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#getOccupier()\n     */\n    public CombatantSide getOccupier() {\n        return occupier;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#isOccupied()\n     */\n    public boolean isOccupied() {\n        return occupier != null;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#getHeight()\n     */\n    public int getHeight() {\n        return height;\n    }\n\n    /**\n     * @return the defenderSpawn\n     */\n    public boolean isDefenderSpawn() {\n        return defenderSpawn;\n    }\n\n    /**\n     * @return the attackerSpawn\n     */\n    public boolean isAttackerSpawn() {\n        return attackerSpawn;\n    }\n\n    /**\n     * @return the flag\n     */\n    public boolean isFlag() {\n        return flag;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#getBonus(de.outstare.fortbattleplayer.model.CharacterClass)\n     */\n    public SectorBonus getBonus(final CharacterClass charClass) {\n        return new SectorBonus(getAttackBonus(charClass), getDefenseBonus(charClass), getDamageBonus());\n    }\n\n    /**\n     * @return\n     */\n    protected int getDamageBonus() {\n        return getBonusFromWeapons(BonusType.DAMAGE);\n    }\n\n    private int getBonusFromWeapons(final BonusType type) {\n        int bonus = 0;\n        for (final Area area : areas) {\n            if (area.isOccupied()) {\n                final Combatant combatant = area.getOccupier();\n                final Weapon weapon = combatant.getWeapon();\n                final int sectorBonus = weapon.getSectorBonus(type);\n                if (sectorBonus != 0) {\n                    // only count first Golden Gun\n                    bonus = sectorBonus;\n                    break;\n                }\n            }\n        }\n        return bonus;\n    }\n\n    /**\n     * @param charClass\n     * @return\n     */\n    protected int getAttackBonus(final CharacterClass charClass) {\n        int bonus = attackBonus + classBonus(charClass);\n        bonus += getBonusFromWeapons(BonusType.ATTACK);\n        return bonus;\n    }\n\n    /**\n     * @param charClass\n     * @return\n     */\n    protected int getDefenseBonus(final CharacterClass charClass) {\n        int bonus = defendBonus + classBonus(charClass);\n        bonus += getBonusFromWeapons(BonusType.DEFENSE);\n        return bonus;\n    }\n\n    /**\n     * @param charClass\n     * @return\n     */\n    protected int classBonus(final CharacterClass charClass) {\n        if (classType != charClass) {\n            return 0;\n        }\n        return classBonus;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#getAreas()\n     */\n    public Set<Area> getAreas() {\n        return areas;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#_addArea(de.outstare.fortbattleplayer.model.Area)\n     */\n    public void _addArea(final Area area) {\n        areas.add(area);\n    }\n\n    /**\n     * @see java.lang.Object#hashCode()\n     */\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((areas == null) ? 0 : areas.hashCode());\n        result = prime * result + attackBonus;\n        result = prime * result + (attackerSpawn ? 1231 : 1237);\n        result = prime * result + classBonus;\n        result = prime * result + ((classType == null) ? 0 : classType.hashCode());\n        result = prime * result + defendBonus;\n        result = prime * result + (defenderSpawn ? 1231 : 1237);\n        result = prime * result + (flag ? 1231 : 1237);\n        result = prime * result + height;\n        return result;\n    }\n\n    /**\n     * @see java.lang.Object#equals(java.lang.Object)\n     */\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!(obj instanceof SimpleSector)) {\n            return false;\n        }\n        final SimpleSector other = (SimpleSector) obj;\n        if (areas == null) {\n            if (other.areas != null) {\n                return false;\n            }\n        } else if (!areas.equals(other.areas)) {\n            return false;\n        }\n        if (attackBonus != other.attackBonus) {\n            return false;\n        }\n        if (attackerSpawn != other.attackerSpawn) {\n            return false;\n        }\n        if (classBonus != other.classBonus) {\n            return false;\n        }\n        if (classType != other.classType) {\n            return false;\n        }\n        if (defendBonus != other.defendBonus) {\n            return false;\n        }\n        if (defenderSpawn != other.defenderSpawn) {\n            return false;\n        }\n        if (flag != other.flag) {\n            return false;\n        }\n        if (height != other.height) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#addObserver(de.outstare.fortbattleplayer.model.SectorObserver)\n     */\n    public void addObserver(final SectorObserver observer) {\n        observers.add(observer);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#removeObserver(de.outstare.fortbattleplayer.model.SectorObserver)\n     */\n    public void removeObserver(final SectorObserver observer) {\n        observers.remove(observer);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/model/impl/SimpleSector_4Test.java",
		"test_prompt": "// SimpleSector_4Test.java\npackage de.outstare.fortbattleplayer.model.impl;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.Sector;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.SectorBonus.BonusType;\nimport de.outstare.fortbattleplayer.model.SectorObserver;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleSector}.\n* It contains ten unit test cases for the {@link SimpleSector#hashCode()} method.\n*/\nclass SimpleSector_4Test {"
	},
	{
		"original_code": "// SimpleSector.java\npackage de.outstare.fortbattleplayer.model.impl;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.Sector;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.SectorBonus.BonusType;\nimport de.outstare.fortbattleplayer.model.SectorObserver;\nimport de.outstare.fortbattleplayer.model.Weapon;\n\n/**\n * @author daniel\n */\npublic class SimpleSector implements Sector {\n\n    private final int height;\n\n    private final boolean defenderSpawn;\n\n    private final boolean attackerSpawn;\n\n    private final int attackBonus;\n\n    private final int defendBonus;\n\n    private final boolean flag;\n\n    private final int classBonus;\n\n    private final CharacterClass classType;\n\n    private CombatantSide occupier = null;\n\n    private int occupierCount = 0;\n\n    private final Set<Area> areas = new HashSet<Area>();\n\n    private final Set<SectorObserver> observers = new HashSet<SectorObserver>();\n\n    /**\n     * @param height\n     * @param defenderSpawn\n     * @param attackerSpawn\n     * @param attackerBonus\n     * @param defenderBonus\n     * @param flag\n     * @param classBonus\n     * @param bonusClass\n     */\n    public SimpleSector(final int height, final boolean defenderSpawn, final boolean attackerSpawn, final int attackerBonus, final int defenderBonus, final boolean flag, final int classBonus, final CharacterClass bonusClass) {\n        this.height = height;\n        this.defenderSpawn = defenderSpawn;\n        this.attackerSpawn = attackerSpawn;\n        attackBonus = attackerBonus;\n        defendBonus = defenderBonus;\n        this.flag = flag;\n        this.classBonus = classBonus;\n        classType = bonusClass;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#free()\n     */\n    public void free() {\n        if (occupierCount > 0) {\n            occupierCount--;\n        }\n        assert occupierCount >= 0 : \"more combatants lefts this sector than enter it\";\n        if (occupierCount == 0) {\n            occupier = null;\n            occupierChanged();\n        }\n    }\n\n    private void occupierChanged() {\n        // update borders to show change of occupier\n        for (final SectorObserver observer : observers) {\n            observer.occupierChanged();\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#gainControl(de.outstare.fortbattleplayer.model.CombatantSide)\n     */\n    public void gainControl(final CombatantSide side) {\n        occupierCount++;\n        if (occupier != side) {\n            occupier = side;\n            occupierChanged();\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#getOccupier()\n     */\n    public CombatantSide getOccupier() {\n        return occupier;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#isOccupied()\n     */\n    public boolean isOccupied() {\n        return occupier != null;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#getHeight()\n     */\n    public int getHeight() {\n        return height;\n    }\n\n    /**\n     * @return the defenderSpawn\n     */\n    public boolean isDefenderSpawn() {\n        return defenderSpawn;\n    }\n\n    /**\n     * @return the attackerSpawn\n     */\n    public boolean isAttackerSpawn() {\n        return attackerSpawn;\n    }\n\n    /**\n     * @return the flag\n     */\n    public boolean isFlag() {\n        return flag;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#getBonus(de.outstare.fortbattleplayer.model.CharacterClass)\n     */\n    public SectorBonus getBonus(final CharacterClass charClass) {\n        return new SectorBonus(getAttackBonus(charClass), getDefenseBonus(charClass), getDamageBonus());\n    }\n\n    /**\n     * @return\n     */\n    protected int getDamageBonus() {\n        return getBonusFromWeapons(BonusType.DAMAGE);\n    }\n\n    private int getBonusFromWeapons(final BonusType type) {\n        int bonus = 0;\n        for (final Area area : areas) {\n            if (area.isOccupied()) {\n                final Combatant combatant = area.getOccupier();\n                final Weapon weapon = combatant.getWeapon();\n                final int sectorBonus = weapon.getSectorBonus(type);\n                if (sectorBonus != 0) {\n                    // only count first Golden Gun\n                    bonus = sectorBonus;\n                    break;\n                }\n            }\n        }\n        return bonus;\n    }\n\n    /**\n     * @param charClass\n     * @return\n     */\n    protected int getAttackBonus(final CharacterClass charClass) {\n        int bonus = attackBonus + classBonus(charClass);\n        bonus += getBonusFromWeapons(BonusType.ATTACK);\n        return bonus;\n    }\n\n    /**\n     * @param charClass\n     * @return\n     */\n    protected int getDefenseBonus(final CharacterClass charClass) {\n        int bonus = defendBonus + classBonus(charClass);\n        bonus += getBonusFromWeapons(BonusType.DEFENSE);\n        return bonus;\n    }\n\n    /**\n     * @param charClass\n     * @return\n     */\n    protected int classBonus(final CharacterClass charClass) {\n        if (classType != charClass) {\n            return 0;\n        }\n        return classBonus;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#getAreas()\n     */\n    public Set<Area> getAreas() {\n        return areas;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#_addArea(de.outstare.fortbattleplayer.model.Area)\n     */\n    public void _addArea(final Area area) {\n        areas.add(area);\n    }\n\n    /**\n     * @see java.lang.Object#hashCode()\n     */\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((areas == null) ? 0 : areas.hashCode());\n        result = prime * result + attackBonus;\n        result = prime * result + (attackerSpawn ? 1231 : 1237);\n        result = prime * result + classBonus;\n        result = prime * result + ((classType == null) ? 0 : classType.hashCode());\n        result = prime * result + defendBonus;\n        result = prime * result + (defenderSpawn ? 1231 : 1237);\n        result = prime * result + (flag ? 1231 : 1237);\n        result = prime * result + height;\n        return result;\n    }\n\n    /**\n     * @see java.lang.Object#equals(java.lang.Object)\n     */\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!(obj instanceof SimpleSector)) {\n            return false;\n        }\n        final SimpleSector other = (SimpleSector) obj;\n        if (areas == null) {\n            if (other.areas != null) {\n                return false;\n            }\n        } else if (!areas.equals(other.areas)) {\n            return false;\n        }\n        if (attackBonus != other.attackBonus) {\n            return false;\n        }\n        if (attackerSpawn != other.attackerSpawn) {\n            return false;\n        }\n        if (classBonus != other.classBonus) {\n            return false;\n        }\n        if (classType != other.classType) {\n            return false;\n        }\n        if (defendBonus != other.defendBonus) {\n            return false;\n        }\n        if (defenderSpawn != other.defenderSpawn) {\n            return false;\n        }\n        if (flag != other.flag) {\n            return false;\n        }\n        if (height != other.height) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#addObserver(de.outstare.fortbattleplayer.model.SectorObserver)\n     */\n    public void addObserver(final SectorObserver observer) {\n        observers.add(observer);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Sector#removeObserver(de.outstare.fortbattleplayer.model.SectorObserver)\n     */\n    public void removeObserver(final SectorObserver observer) {\n        observers.remove(observer);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/model/impl/SimpleSector_5Test.java",
		"test_prompt": "// SimpleSector_5Test.java\npackage de.outstare.fortbattleplayer.model.impl;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.Sector;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.SectorBonus.BonusType;\nimport de.outstare.fortbattleplayer.model.SectorObserver;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleSector}.\n* It contains ten unit test cases for the {@link SimpleSector#equals(Object)} method.\n*/\nclass SimpleSector_5Test {"
	},
	{
		"original_code": "// SimpleWeapon.java\npackage de.outstare.fortbattleplayer.model.impl;\n\nimport de.outstare.fortbattleplayer.model.SectorBonus.BonusType;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\nimport de.outstare.fortbattleplayer.model.WeaponModification;\n\n/**\n * A SimpleWeapon just holds the values for a {@link Weapon}\n *\n * @author daniel\n */\npublic class SimpleWeapon implements Weapon {\n\n    private final int _id;\n\n    private final String _name;\n\n    private final int _minDamage;\n\n    private final int _maxDamage;\n\n    private final WeaponModification _modification;\n\n    /**\n     * @param id\n     *            the unique ingame ID of this weapon\n     * @param name\n     *            not <code>null</code>\n     * @param minDamage\n     *            >= 0\n     * @param maxDamage\n     *            >= <code>minDamage</code>\n     */\n    public SimpleWeapon(final int id, final String name, final int minDamage, final int maxDamage) {\n        super();\n        if (name == null || minDamage < 0 || maxDamage < 0 || minDamage > maxDamage) {\n            throw new IllegalArgumentException(\"invalid parameters: \" + name + \", \" + minDamage + \",\" + maxDamage);\n        }\n        _id = id;\n        _name = name;\n        _minDamage = minDamage;\n        _maxDamage = maxDamage;\n        // TODO\n        _modification = null;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Weapon#getId()\n     */\n    public int getId() {\n        return _id;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Weapon#name()\n     */\n    public String name() {\n        assert _name != null : \"Nachbedingung nicht erfllt: _name != null\";\n        return _name;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Weapon#minDamage()\n     */\n    public int minDamage() {\n        assert _minDamage >= 0 : \"Nachbedingung nicht erfllt: _minDamage >= 0\";\n        return _minDamage;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Weapon#maxDamage()\n     */\n    public int maxDamage() {\n        assert _maxDamage >= _minDamage : \"Nachbedingung nicht erfllt: _maxDamage >= _minDamage\";\n        return _maxDamage;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Weapon#getSectorBonus(BonusType)\n     */\n    public int getSectorBonus(final BonusType type) {\n        switch(type) {\n            case ATTACK:\n                return getSectorBonusAttack();\n            case DEFENSE:\n                return getSectorBonusDefend();\n            case DAMAGE:\n                return getSectorBonusDamage();\n            default:\n                return 0;\n        }\n    }\n\n    /**\n     * @return\n     */\n    protected int getSectorBonusDamage() {\n        int bonusDamage;\n        if (isGoldenGun()) {\n            bonusDamage = WeaponData.GOLDEN_GUN_DAMAGE_BONUS;\n        } else {\n            bonusDamage = 0;\n        }\n        return bonusDamage;\n    }\n\n    /**\n     * @return\n     */\n    protected int getSectorBonusAttack() {\n        int bonusDamage;\n        if (isGoldenGun()) {\n            bonusDamage = WeaponData.GOLDEN_GUN_ATTACK_BONUS;\n        } else {\n            bonusDamage = 0;\n        }\n        return bonusDamage;\n    }\n\n    /**\n     * @return\n     */\n    private boolean isGoldenGun() {\n        return new JSWeaponData().isGoldenGun(this);\n    }\n\n    /**\n     * @return\n     */\n    protected int getSectorBonusDefend() {\n        int bonusDamage;\n        if (isGoldenGun()) {\n            bonusDamage = WeaponData.GOLDEN_GUN_DEFENSE_BONUS;\n        } else {\n            bonusDamage = 0;\n        }\n        return bonusDamage;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Weapon#averageDamage()\n     */\n    public int averageDamage() {\n        return (minDamage() + maxDamage()) / 2;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Weapon#getModification()\n     */\n    public WeaponModification getModification() {\n        return _modification;\n    }\n\n    /**\n     * @see java.lang.Object#toString()\n     */\n    @Override\n    public String toString() {\n        return \"Weapon \" + _name + \", min dmg: \" + _minDamage + \", max dmg: \" + _maxDamage;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/model/impl/SimpleWeapon_0Test.java",
		"test_prompt": "// SimpleWeapon_0Test.java\npackage de.outstare.fortbattleplayer.model.impl;\n\nimport de.outstare.fortbattleplayer.model.SectorBonus.BonusType;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\nimport de.outstare.fortbattleplayer.model.WeaponModification;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleWeapon}.\n* It contains ten unit test cases for the {@link SimpleWeapon#name()} method.\n*/\nclass SimpleWeapon_0Test {"
	},
	{
		"original_code": "// SimpleWeapon.java\npackage de.outstare.fortbattleplayer.model.impl;\n\nimport de.outstare.fortbattleplayer.model.SectorBonus.BonusType;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\nimport de.outstare.fortbattleplayer.model.WeaponModification;\n\n/**\n * A SimpleWeapon just holds the values for a {@link Weapon}\n *\n * @author daniel\n */\npublic class SimpleWeapon implements Weapon {\n\n    private final int _id;\n\n    private final String _name;\n\n    private final int _minDamage;\n\n    private final int _maxDamage;\n\n    private final WeaponModification _modification;\n\n    /**\n     * @param id\n     *            the unique ingame ID of this weapon\n     * @param name\n     *            not <code>null</code>\n     * @param minDamage\n     *            >= 0\n     * @param maxDamage\n     *            >= <code>minDamage</code>\n     */\n    public SimpleWeapon(final int id, final String name, final int minDamage, final int maxDamage) {\n        super();\n        if (name == null || minDamage < 0 || maxDamage < 0 || minDamage > maxDamage) {\n            throw new IllegalArgumentException(\"invalid parameters: \" + name + \", \" + minDamage + \",\" + maxDamage);\n        }\n        _id = id;\n        _name = name;\n        _minDamage = minDamage;\n        _maxDamage = maxDamage;\n        // TODO\n        _modification = null;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Weapon#getId()\n     */\n    public int getId() {\n        return _id;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Weapon#name()\n     */\n    public String name() {\n        assert _name != null : \"Nachbedingung nicht erfllt: _name != null\";\n        return _name;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Weapon#minDamage()\n     */\n    public int minDamage() {\n        assert _minDamage >= 0 : \"Nachbedingung nicht erfllt: _minDamage >= 0\";\n        return _minDamage;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Weapon#maxDamage()\n     */\n    public int maxDamage() {\n        assert _maxDamage >= _minDamage : \"Nachbedingung nicht erfllt: _maxDamage >= _minDamage\";\n        return _maxDamage;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Weapon#getSectorBonus(BonusType)\n     */\n    public int getSectorBonus(final BonusType type) {\n        switch(type) {\n            case ATTACK:\n                return getSectorBonusAttack();\n            case DEFENSE:\n                return getSectorBonusDefend();\n            case DAMAGE:\n                return getSectorBonusDamage();\n            default:\n                return 0;\n        }\n    }\n\n    /**\n     * @return\n     */\n    protected int getSectorBonusDamage() {\n        int bonusDamage;\n        if (isGoldenGun()) {\n            bonusDamage = WeaponData.GOLDEN_GUN_DAMAGE_BONUS;\n        } else {\n            bonusDamage = 0;\n        }\n        return bonusDamage;\n    }\n\n    /**\n     * @return\n     */\n    protected int getSectorBonusAttack() {\n        int bonusDamage;\n        if (isGoldenGun()) {\n            bonusDamage = WeaponData.GOLDEN_GUN_ATTACK_BONUS;\n        } else {\n            bonusDamage = 0;\n        }\n        return bonusDamage;\n    }\n\n    /**\n     * @return\n     */\n    private boolean isGoldenGun() {\n        return new JSWeaponData().isGoldenGun(this);\n    }\n\n    /**\n     * @return\n     */\n    protected int getSectorBonusDefend() {\n        int bonusDamage;\n        if (isGoldenGun()) {\n            bonusDamage = WeaponData.GOLDEN_GUN_DEFENSE_BONUS;\n        } else {\n            bonusDamage = 0;\n        }\n        return bonusDamage;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Weapon#averageDamage()\n     */\n    public int averageDamage() {\n        return (minDamage() + maxDamage()) / 2;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Weapon#getModification()\n     */\n    public WeaponModification getModification() {\n        return _modification;\n    }\n\n    /**\n     * @see java.lang.Object#toString()\n     */\n    @Override\n    public String toString() {\n        return \"Weapon \" + _name + \", min dmg: \" + _minDamage + \", max dmg: \" + _maxDamage;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/model/impl/SimpleWeapon_1Test.java",
		"test_prompt": "// SimpleWeapon_1Test.java\npackage de.outstare.fortbattleplayer.model.impl;\n\nimport de.outstare.fortbattleplayer.model.SectorBonus.BonusType;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\nimport de.outstare.fortbattleplayer.model.WeaponModification;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleWeapon}.\n* It contains ten unit test cases for the {@link SimpleWeapon#minDamage()} method.\n*/\nclass SimpleWeapon_1Test {"
	},
	{
		"original_code": "// SimpleWeapon.java\npackage de.outstare.fortbattleplayer.model.impl;\n\nimport de.outstare.fortbattleplayer.model.SectorBonus.BonusType;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\nimport de.outstare.fortbattleplayer.model.WeaponModification;\n\n/**\n * A SimpleWeapon just holds the values for a {@link Weapon}\n *\n * @author daniel\n */\npublic class SimpleWeapon implements Weapon {\n\n    private final int _id;\n\n    private final String _name;\n\n    private final int _minDamage;\n\n    private final int _maxDamage;\n\n    private final WeaponModification _modification;\n\n    /**\n     * @param id\n     *            the unique ingame ID of this weapon\n     * @param name\n     *            not <code>null</code>\n     * @param minDamage\n     *            >= 0\n     * @param maxDamage\n     *            >= <code>minDamage</code>\n     */\n    public SimpleWeapon(final int id, final String name, final int minDamage, final int maxDamage) {\n        super();\n        if (name == null || minDamage < 0 || maxDamage < 0 || minDamage > maxDamage) {\n            throw new IllegalArgumentException(\"invalid parameters: \" + name + \", \" + minDamage + \",\" + maxDamage);\n        }\n        _id = id;\n        _name = name;\n        _minDamage = minDamage;\n        _maxDamage = maxDamage;\n        // TODO\n        _modification = null;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Weapon#getId()\n     */\n    public int getId() {\n        return _id;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Weapon#name()\n     */\n    public String name() {\n        assert _name != null : \"Nachbedingung nicht erfllt: _name != null\";\n        return _name;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Weapon#minDamage()\n     */\n    public int minDamage() {\n        assert _minDamage >= 0 : \"Nachbedingung nicht erfllt: _minDamage >= 0\";\n        return _minDamage;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Weapon#maxDamage()\n     */\n    public int maxDamage() {\n        assert _maxDamage >= _minDamage : \"Nachbedingung nicht erfllt: _maxDamage >= _minDamage\";\n        return _maxDamage;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Weapon#getSectorBonus(BonusType)\n     */\n    public int getSectorBonus(final BonusType type) {\n        switch(type) {\n            case ATTACK:\n                return getSectorBonusAttack();\n            case DEFENSE:\n                return getSectorBonusDefend();\n            case DAMAGE:\n                return getSectorBonusDamage();\n            default:\n                return 0;\n        }\n    }\n\n    /**\n     * @return\n     */\n    protected int getSectorBonusDamage() {\n        int bonusDamage;\n        if (isGoldenGun()) {\n            bonusDamage = WeaponData.GOLDEN_GUN_DAMAGE_BONUS;\n        } else {\n            bonusDamage = 0;\n        }\n        return bonusDamage;\n    }\n\n    /**\n     * @return\n     */\n    protected int getSectorBonusAttack() {\n        int bonusDamage;\n        if (isGoldenGun()) {\n            bonusDamage = WeaponData.GOLDEN_GUN_ATTACK_BONUS;\n        } else {\n            bonusDamage = 0;\n        }\n        return bonusDamage;\n    }\n\n    /**\n     * @return\n     */\n    private boolean isGoldenGun() {\n        return new JSWeaponData().isGoldenGun(this);\n    }\n\n    /**\n     * @return\n     */\n    protected int getSectorBonusDefend() {\n        int bonusDamage;\n        if (isGoldenGun()) {\n            bonusDamage = WeaponData.GOLDEN_GUN_DEFENSE_BONUS;\n        } else {\n            bonusDamage = 0;\n        }\n        return bonusDamage;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Weapon#averageDamage()\n     */\n    public int averageDamage() {\n        return (minDamage() + maxDamage()) / 2;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Weapon#getModification()\n     */\n    public WeaponModification getModification() {\n        return _modification;\n    }\n\n    /**\n     * @see java.lang.Object#toString()\n     */\n    @Override\n    public String toString() {\n        return \"Weapon \" + _name + \", min dmg: \" + _minDamage + \", max dmg: \" + _maxDamage;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/model/impl/SimpleWeapon_2Test.java",
		"test_prompt": "// SimpleWeapon_2Test.java\npackage de.outstare.fortbattleplayer.model.impl;\n\nimport de.outstare.fortbattleplayer.model.SectorBonus.BonusType;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\nimport de.outstare.fortbattleplayer.model.WeaponModification;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleWeapon}.\n* It contains ten unit test cases for the {@link SimpleWeapon#maxDamage()} method.\n*/\nclass SimpleWeapon_2Test {"
	},
	{
		"original_code": "// SimpleWeapon.java\npackage de.outstare.fortbattleplayer.model.impl;\n\nimport de.outstare.fortbattleplayer.model.SectorBonus.BonusType;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\nimport de.outstare.fortbattleplayer.model.WeaponModification;\n\n/**\n * A SimpleWeapon just holds the values for a {@link Weapon}\n *\n * @author daniel\n */\npublic class SimpleWeapon implements Weapon {\n\n    private final int _id;\n\n    private final String _name;\n\n    private final int _minDamage;\n\n    private final int _maxDamage;\n\n    private final WeaponModification _modification;\n\n    /**\n     * @param id\n     *            the unique ingame ID of this weapon\n     * @param name\n     *            not <code>null</code>\n     * @param minDamage\n     *            >= 0\n     * @param maxDamage\n     *            >= <code>minDamage</code>\n     */\n    public SimpleWeapon(final int id, final String name, final int minDamage, final int maxDamage) {\n        super();\n        if (name == null || minDamage < 0 || maxDamage < 0 || minDamage > maxDamage) {\n            throw new IllegalArgumentException(\"invalid parameters: \" + name + \", \" + minDamage + \",\" + maxDamage);\n        }\n        _id = id;\n        _name = name;\n        _minDamage = minDamage;\n        _maxDamage = maxDamage;\n        // TODO\n        _modification = null;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Weapon#getId()\n     */\n    public int getId() {\n        return _id;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Weapon#name()\n     */\n    public String name() {\n        assert _name != null : \"Nachbedingung nicht erfllt: _name != null\";\n        return _name;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Weapon#minDamage()\n     */\n    public int minDamage() {\n        assert _minDamage >= 0 : \"Nachbedingung nicht erfllt: _minDamage >= 0\";\n        return _minDamage;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Weapon#maxDamage()\n     */\n    public int maxDamage() {\n        assert _maxDamage >= _minDamage : \"Nachbedingung nicht erfllt: _maxDamage >= _minDamage\";\n        return _maxDamage;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Weapon#getSectorBonus(BonusType)\n     */\n    public int getSectorBonus(final BonusType type) {\n        switch(type) {\n            case ATTACK:\n                return getSectorBonusAttack();\n            case DEFENSE:\n                return getSectorBonusDefend();\n            case DAMAGE:\n                return getSectorBonusDamage();\n            default:\n                return 0;\n        }\n    }\n\n    /**\n     * @return\n     */\n    protected int getSectorBonusDamage() {\n        int bonusDamage;\n        if (isGoldenGun()) {\n            bonusDamage = WeaponData.GOLDEN_GUN_DAMAGE_BONUS;\n        } else {\n            bonusDamage = 0;\n        }\n        return bonusDamage;\n    }\n\n    /**\n     * @return\n     */\n    protected int getSectorBonusAttack() {\n        int bonusDamage;\n        if (isGoldenGun()) {\n            bonusDamage = WeaponData.GOLDEN_GUN_ATTACK_BONUS;\n        } else {\n            bonusDamage = 0;\n        }\n        return bonusDamage;\n    }\n\n    /**\n     * @return\n     */\n    private boolean isGoldenGun() {\n        return new JSWeaponData().isGoldenGun(this);\n    }\n\n    /**\n     * @return\n     */\n    protected int getSectorBonusDefend() {\n        int bonusDamage;\n        if (isGoldenGun()) {\n            bonusDamage = WeaponData.GOLDEN_GUN_DEFENSE_BONUS;\n        } else {\n            bonusDamage = 0;\n        }\n        return bonusDamage;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Weapon#averageDamage()\n     */\n    public int averageDamage() {\n        return (minDamage() + maxDamage()) / 2;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Weapon#getModification()\n     */\n    public WeaponModification getModification() {\n        return _modification;\n    }\n\n    /**\n     * @see java.lang.Object#toString()\n     */\n    @Override\n    public String toString() {\n        return \"Weapon \" + _name + \", min dmg: \" + _minDamage + \", max dmg: \" + _maxDamage;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/model/impl/SimpleWeapon_3Test.java",
		"test_prompt": "// SimpleWeapon_3Test.java\npackage de.outstare.fortbattleplayer.model.impl;\n\nimport de.outstare.fortbattleplayer.model.SectorBonus.BonusType;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\nimport de.outstare.fortbattleplayer.model.WeaponModification;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleWeapon}.\n* It contains ten unit test cases for the {@link SimpleWeapon#averageDamage()} method.\n*/\nclass SimpleWeapon_3Test {"
	},
	{
		"original_code": "// JSWeaponData.java\npackage de.outstare.fortbattleplayer.model.impl;\n\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\n\n/**\n * A JSWeaponData uses the data from the JavaScript object \"ItemManager\".\n *\n * @author daniel\n */\npublic class JSWeaponData implements WeaponData {\n\n    private static final transient Logger LOG = Logger.getLogger(JSWeaponData.class.getName());\n\n    private static final String CSV_FILE_WEAPONS = \"/weaponData.csv\";\n\n    private static final String CSV_DELIMITER = \",\";\n\n    /**\n     * maps the id of a weapon to it's stats\n     */\n    protected final static Map<Integer, WeaponGameData> data = loadData(CSV_FILE_WEAPONS);\n\n    /**\n     * @param filename\n     * @return\n     */\n    private static Map<Integer, WeaponGameData> loadData(final String filename) {\n        final Map<Integer, WeaponGameData> result = new HashMap<Integer, WeaponGameData>();\n        try {\n            final InputStream fileInput = JSWeaponData.class.getResourceAsStream(filename);\n            if (fileInput == null) {\n                throw new FileNotFoundException(filename);\n            }\n            final BufferedReader input = new BufferedReader(new InputStreamReader(fileInput));\n            try {\n                String line;\n                while ((line = input.readLine()) != null) {\n                    if (\"\".equals(line.trim())) {\n                        continue;\n                    }\n                    final String[] values = line.split(CSV_DELIMITER);\n                    assert values.length >= 5 : \"csv has not at least 5 fields!\";\n                    final int id = Integer.valueOf(values[0]).intValue();\n                    final int minDmg = Integer.valueOf(values[1]).intValue();\n                    final int maxDmg = Integer.valueOf(values[2]).intValue();\n                    final int attBonus = Integer.valueOf(values[3]).intValue();\n                    final int deffBonus = Integer.valueOf(values[4]).intValue();\n                    final String weaponName;\n                    if (values.length > 5) {\n                        weaponName = values[5];\n                    } else {\n                        weaponName = \"\";\n                    }\n                    final WeaponGameData weapon = new WeaponGameData(id, minDmg, maxDmg, attBonus, deffBonus, weaponName);\n                    result.put(Integer.valueOf(id), weapon);\n                }\n                LOG.fine(\"successfully read \" + result.size() + \" weapon data from file \" + filename);\n            } finally {\n                input.close();\n                fileInput.close();\n            }\n        } catch (final FileNotFoundException e) {\n            LOG.severe(\"the CSV file with the bayonet damages was not found: \" + filename);\n            e.printStackTrace();\n        } catch (final IOException e) {\n            LOG.severe(\"failed to load CSV file with bayonet damages: \" + e.toString());\n            e.printStackTrace();\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#isGoldenGun(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean isGoldenGun(final Weapon weapon) {\n        final WeaponGameData weaponData = data.get(Integer.valueOf(weapon.getId()));\n        // System.out.println(\"data for \" + weapon.getId() + \" is \" +\n        // weaponData);\n        return weaponData != null && (weaponData.bonusOffense > 0 || weaponData.bonusDefense > 0);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#getGoldenGoldDmgBonus()\n     */\n    public int getGoldenGoldDmgBonus() {\n        return WeaponData.GOLDEN_GUN_DAMAGE_BONUS;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#getGoldenGoldAttBonus()\n     */\n    public int getGoldenGoldAttBonus() {\n        return WeaponData.GOLDEN_GUN_ATTACK_BONUS;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#getGoldenGoldDeffBonus()\n     */\n    public int getGoldenGoldDeffBonus() {\n        return WeaponData.GOLDEN_GUN_DEFENSE_BONUS;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasBayonet(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasBayonet(final Weapon weapon) {\n        return hasBonus(weapon, 25, 75);\n    }\n\n    /**\n     * @param weapon\n     * @param weaponData\n     * @param minDmgBonus\n     * @param maxDmgBonus\n     * @return\n     */\n    boolean hasBonus(final Weapon weapon, final int minDmgBonus, final int maxDmgBonus) {\n        final WeaponGameData weaponData = data.get(Integer.valueOf(weapon.getId()));\n        return weaponData != null && weapon.maxDamage() - weaponData.maxDamage == maxDmgBonus && weapon.minDamage() - weaponData.minDamage == minDmgBonus;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasGraphitLubricant(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasGraphitLubricant(final Weapon weapon) {\n        return hasBonus(weapon, 20, 40);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasFettesWeaponOil(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasFettesWeaponOil(final Weapon weapon) {\n        return hasBonus(weapon, 50, 50);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasSchmierendesWeaponOil(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasSchmierendesWeaponOil(final Weapon weapon) {\n        return hasBonus(weapon, 60, 60);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasShinyWeaponOil(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasShinyWeaponOil(final Weapon weapon) {\n        return hasBonus(weapon, 75, 75);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasHipFlask(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasHipFlask(final Weapon weapon) {\n        return hasBonus(weapon, 40, 40);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasLoadingchamberOrEnhancedPatrons(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasLoadingchamberOrEnhancedPatrons(final Weapon weapon) {\n        return hasBonus(weapon, 30, 30);\n    }\n\n    /**\n     * Parsed data from file.\n     *\n     * @author daniel\n     */\n    static class WeaponGameData {\n\n        @SuppressWarnings(\"javadoc\")\n        final int id;\n\n        @SuppressWarnings(\"javadoc\")\n        final int minDamage;\n\n        @SuppressWarnings(\"javadoc\")\n        final int maxDamage;\n\n        @SuppressWarnings(\"javadoc\")\n        final int bonusOffense;\n\n        @SuppressWarnings(\"javadoc\")\n        final int bonusDefense;\n\n        @SuppressWarnings(\"javadoc\")\n        final String name;\n\n        /**\n         * @param id\n         * @param minDamage\n         * @param maxDamage\n         * @param bonusOffense\n         * @param bonusDefense\n         * @param name\n         */\n        WeaponGameData(final int id, final int minDamage, final int maxDamage, final int bonusOffense, final int bonusDefense, final String name) {\n            this.id = id;\n            this.minDamage = minDamage;\n            this.maxDamage = maxDamage;\n            this.bonusOffense = bonusOffense;\n            this.bonusDefense = bonusDefense;\n            this.name = name;\n        }\n\n        /**\n         * @see java.lang.Object#hashCode()\n         */\n        @Override\n        public int hashCode() {\n            final int prime = 31;\n            int result = 1;\n            result = prime * result + bonusDefense;\n            result = prime * result + bonusOffense;\n            result = prime * result + id;\n            result = prime * result + maxDamage;\n            result = prime * result + minDamage;\n            result = prime * result + ((name == null) ? 0 : name.hashCode());\n            return result;\n        }\n\n        /**\n         * @see java.lang.Object#equals(java.lang.Object)\n         */\n        @Override\n        public boolean equals(final Object obj) {\n            if (this == obj) {\n                return true;\n            }\n            if (obj == null) {\n                return false;\n            }\n            if (!(obj instanceof WeaponGameData)) {\n                return false;\n            }\n            final WeaponGameData other = (WeaponGameData) obj;\n            if (bonusDefense != other.bonusDefense) {\n                return false;\n            }\n            if (bonusOffense != other.bonusOffense) {\n                return false;\n            }\n            if (id != other.id) {\n                return false;\n            }\n            if (maxDamage != other.maxDamage) {\n                return false;\n            }\n            if (minDamage != other.minDamage) {\n                return false;\n            }\n            if (name == null) {\n                if (other.name != null) {\n                    return false;\n                }\n            } else if (!name.equals(other.name)) {\n                return false;\n            }\n            return true;\n        }\n\n        /**\n         * @see java.lang.Object#toString()\n         */\n        @Override\n        public String toString() {\n            return \"WeaponGameData: minDmg=\" + minDamage + \", maxDmg=\" + maxDamage + \", offBonus=\" + bonusOffense + \", deffBonus=\" + bonusDefense + \", name=\" + name;\n        }\n    }\n\n    /**\n     * @param args\n     */\n    public static void main(final String[] args) {\n        System.out.println(data);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/model/impl/JSWeaponData_0Test.java",
		"test_prompt": "// JSWeaponData_0Test.java\npackage de.outstare.fortbattleplayer.model.impl;\n\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JSWeaponData}.\n* It contains ten unit test cases for the {@link JSWeaponData#isGoldenGun(Weapon)} method.\n*/\nclass JSWeaponData_0Test {"
	},
	{
		"original_code": "// JSWeaponData.java\npackage de.outstare.fortbattleplayer.model.impl;\n\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\n\n/**\n * A JSWeaponData uses the data from the JavaScript object \"ItemManager\".\n *\n * @author daniel\n */\npublic class JSWeaponData implements WeaponData {\n\n    private static final transient Logger LOG = Logger.getLogger(JSWeaponData.class.getName());\n\n    private static final String CSV_FILE_WEAPONS = \"/weaponData.csv\";\n\n    private static final String CSV_DELIMITER = \",\";\n\n    /**\n     * maps the id of a weapon to it's stats\n     */\n    protected final static Map<Integer, WeaponGameData> data = loadData(CSV_FILE_WEAPONS);\n\n    /**\n     * @param filename\n     * @return\n     */\n    private static Map<Integer, WeaponGameData> loadData(final String filename) {\n        final Map<Integer, WeaponGameData> result = new HashMap<Integer, WeaponGameData>();\n        try {\n            final InputStream fileInput = JSWeaponData.class.getResourceAsStream(filename);\n            if (fileInput == null) {\n                throw new FileNotFoundException(filename);\n            }\n            final BufferedReader input = new BufferedReader(new InputStreamReader(fileInput));\n            try {\n                String line;\n                while ((line = input.readLine()) != null) {\n                    if (\"\".equals(line.trim())) {\n                        continue;\n                    }\n                    final String[] values = line.split(CSV_DELIMITER);\n                    assert values.length >= 5 : \"csv has not at least 5 fields!\";\n                    final int id = Integer.valueOf(values[0]).intValue();\n                    final int minDmg = Integer.valueOf(values[1]).intValue();\n                    final int maxDmg = Integer.valueOf(values[2]).intValue();\n                    final int attBonus = Integer.valueOf(values[3]).intValue();\n                    final int deffBonus = Integer.valueOf(values[4]).intValue();\n                    final String weaponName;\n                    if (values.length > 5) {\n                        weaponName = values[5];\n                    } else {\n                        weaponName = \"\";\n                    }\n                    final WeaponGameData weapon = new WeaponGameData(id, minDmg, maxDmg, attBonus, deffBonus, weaponName);\n                    result.put(Integer.valueOf(id), weapon);\n                }\n                LOG.fine(\"successfully read \" + result.size() + \" weapon data from file \" + filename);\n            } finally {\n                input.close();\n                fileInput.close();\n            }\n        } catch (final FileNotFoundException e) {\n            LOG.severe(\"the CSV file with the bayonet damages was not found: \" + filename);\n            e.printStackTrace();\n        } catch (final IOException e) {\n            LOG.severe(\"failed to load CSV file with bayonet damages: \" + e.toString());\n            e.printStackTrace();\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#isGoldenGun(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean isGoldenGun(final Weapon weapon) {\n        final WeaponGameData weaponData = data.get(Integer.valueOf(weapon.getId()));\n        // System.out.println(\"data for \" + weapon.getId() + \" is \" +\n        // weaponData);\n        return weaponData != null && (weaponData.bonusOffense > 0 || weaponData.bonusDefense > 0);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#getGoldenGoldDmgBonus()\n     */\n    public int getGoldenGoldDmgBonus() {\n        return WeaponData.GOLDEN_GUN_DAMAGE_BONUS;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#getGoldenGoldAttBonus()\n     */\n    public int getGoldenGoldAttBonus() {\n        return WeaponData.GOLDEN_GUN_ATTACK_BONUS;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#getGoldenGoldDeffBonus()\n     */\n    public int getGoldenGoldDeffBonus() {\n        return WeaponData.GOLDEN_GUN_DEFENSE_BONUS;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasBayonet(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasBayonet(final Weapon weapon) {\n        return hasBonus(weapon, 25, 75);\n    }\n\n    /**\n     * @param weapon\n     * @param weaponData\n     * @param minDmgBonus\n     * @param maxDmgBonus\n     * @return\n     */\n    boolean hasBonus(final Weapon weapon, final int minDmgBonus, final int maxDmgBonus) {\n        final WeaponGameData weaponData = data.get(Integer.valueOf(weapon.getId()));\n        return weaponData != null && weapon.maxDamage() - weaponData.maxDamage == maxDmgBonus && weapon.minDamage() - weaponData.minDamage == minDmgBonus;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasGraphitLubricant(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasGraphitLubricant(final Weapon weapon) {\n        return hasBonus(weapon, 20, 40);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasFettesWeaponOil(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasFettesWeaponOil(final Weapon weapon) {\n        return hasBonus(weapon, 50, 50);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasSchmierendesWeaponOil(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasSchmierendesWeaponOil(final Weapon weapon) {\n        return hasBonus(weapon, 60, 60);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasShinyWeaponOil(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasShinyWeaponOil(final Weapon weapon) {\n        return hasBonus(weapon, 75, 75);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasHipFlask(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasHipFlask(final Weapon weapon) {\n        return hasBonus(weapon, 40, 40);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasLoadingchamberOrEnhancedPatrons(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasLoadingchamberOrEnhancedPatrons(final Weapon weapon) {\n        return hasBonus(weapon, 30, 30);\n    }\n\n    /**\n     * Parsed data from file.\n     *\n     * @author daniel\n     */\n    static class WeaponGameData {\n\n        @SuppressWarnings(\"javadoc\")\n        final int id;\n\n        @SuppressWarnings(\"javadoc\")\n        final int minDamage;\n\n        @SuppressWarnings(\"javadoc\")\n        final int maxDamage;\n\n        @SuppressWarnings(\"javadoc\")\n        final int bonusOffense;\n\n        @SuppressWarnings(\"javadoc\")\n        final int bonusDefense;\n\n        @SuppressWarnings(\"javadoc\")\n        final String name;\n\n        /**\n         * @param id\n         * @param minDamage\n         * @param maxDamage\n         * @param bonusOffense\n         * @param bonusDefense\n         * @param name\n         */\n        WeaponGameData(final int id, final int minDamage, final int maxDamage, final int bonusOffense, final int bonusDefense, final String name) {\n            this.id = id;\n            this.minDamage = minDamage;\n            this.maxDamage = maxDamage;\n            this.bonusOffense = bonusOffense;\n            this.bonusDefense = bonusDefense;\n            this.name = name;\n        }\n\n        /**\n         * @see java.lang.Object#hashCode()\n         */\n        @Override\n        public int hashCode() {\n            final int prime = 31;\n            int result = 1;\n            result = prime * result + bonusDefense;\n            result = prime * result + bonusOffense;\n            result = prime * result + id;\n            result = prime * result + maxDamage;\n            result = prime * result + minDamage;\n            result = prime * result + ((name == null) ? 0 : name.hashCode());\n            return result;\n        }\n\n        /**\n         * @see java.lang.Object#equals(java.lang.Object)\n         */\n        @Override\n        public boolean equals(final Object obj) {\n            if (this == obj) {\n                return true;\n            }\n            if (obj == null) {\n                return false;\n            }\n            if (!(obj instanceof WeaponGameData)) {\n                return false;\n            }\n            final WeaponGameData other = (WeaponGameData) obj;\n            if (bonusDefense != other.bonusDefense) {\n                return false;\n            }\n            if (bonusOffense != other.bonusOffense) {\n                return false;\n            }\n            if (id != other.id) {\n                return false;\n            }\n            if (maxDamage != other.maxDamage) {\n                return false;\n            }\n            if (minDamage != other.minDamage) {\n                return false;\n            }\n            if (name == null) {\n                if (other.name != null) {\n                    return false;\n                }\n            } else if (!name.equals(other.name)) {\n                return false;\n            }\n            return true;\n        }\n\n        /**\n         * @see java.lang.Object#toString()\n         */\n        @Override\n        public String toString() {\n            return \"WeaponGameData: minDmg=\" + minDamage + \", maxDmg=\" + maxDamage + \", offBonus=\" + bonusOffense + \", deffBonus=\" + bonusDefense + \", name=\" + name;\n        }\n    }\n\n    /**\n     * @param args\n     */\n    public static void main(final String[] args) {\n        System.out.println(data);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/model/impl/JSWeaponData_1Test.java",
		"test_prompt": "// JSWeaponData_1Test.java\npackage de.outstare.fortbattleplayer.model.impl;\n\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JSWeaponData}.\n* It contains ten unit test cases for the {@link JSWeaponData#hasBayonet(Weapon)} method.\n*/\nclass JSWeaponData_1Test {"
	},
	{
		"original_code": "// JSWeaponData.java\npackage de.outstare.fortbattleplayer.model.impl;\n\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\n\n/**\n * A JSWeaponData uses the data from the JavaScript object \"ItemManager\".\n *\n * @author daniel\n */\npublic class JSWeaponData implements WeaponData {\n\n    private static final transient Logger LOG = Logger.getLogger(JSWeaponData.class.getName());\n\n    private static final String CSV_FILE_WEAPONS = \"/weaponData.csv\";\n\n    private static final String CSV_DELIMITER = \",\";\n\n    /**\n     * maps the id of a weapon to it's stats\n     */\n    protected final static Map<Integer, WeaponGameData> data = loadData(CSV_FILE_WEAPONS);\n\n    /**\n     * @param filename\n     * @return\n     */\n    private static Map<Integer, WeaponGameData> loadData(final String filename) {\n        final Map<Integer, WeaponGameData> result = new HashMap<Integer, WeaponGameData>();\n        try {\n            final InputStream fileInput = JSWeaponData.class.getResourceAsStream(filename);\n            if (fileInput == null) {\n                throw new FileNotFoundException(filename);\n            }\n            final BufferedReader input = new BufferedReader(new InputStreamReader(fileInput));\n            try {\n                String line;\n                while ((line = input.readLine()) != null) {\n                    if (\"\".equals(line.trim())) {\n                        continue;\n                    }\n                    final String[] values = line.split(CSV_DELIMITER);\n                    assert values.length >= 5 : \"csv has not at least 5 fields!\";\n                    final int id = Integer.valueOf(values[0]).intValue();\n                    final int minDmg = Integer.valueOf(values[1]).intValue();\n                    final int maxDmg = Integer.valueOf(values[2]).intValue();\n                    final int attBonus = Integer.valueOf(values[3]).intValue();\n                    final int deffBonus = Integer.valueOf(values[4]).intValue();\n                    final String weaponName;\n                    if (values.length > 5) {\n                        weaponName = values[5];\n                    } else {\n                        weaponName = \"\";\n                    }\n                    final WeaponGameData weapon = new WeaponGameData(id, minDmg, maxDmg, attBonus, deffBonus, weaponName);\n                    result.put(Integer.valueOf(id), weapon);\n                }\n                LOG.fine(\"successfully read \" + result.size() + \" weapon data from file \" + filename);\n            } finally {\n                input.close();\n                fileInput.close();\n            }\n        } catch (final FileNotFoundException e) {\n            LOG.severe(\"the CSV file with the bayonet damages was not found: \" + filename);\n            e.printStackTrace();\n        } catch (final IOException e) {\n            LOG.severe(\"failed to load CSV file with bayonet damages: \" + e.toString());\n            e.printStackTrace();\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#isGoldenGun(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean isGoldenGun(final Weapon weapon) {\n        final WeaponGameData weaponData = data.get(Integer.valueOf(weapon.getId()));\n        // System.out.println(\"data for \" + weapon.getId() + \" is \" +\n        // weaponData);\n        return weaponData != null && (weaponData.bonusOffense > 0 || weaponData.bonusDefense > 0);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#getGoldenGoldDmgBonus()\n     */\n    public int getGoldenGoldDmgBonus() {\n        return WeaponData.GOLDEN_GUN_DAMAGE_BONUS;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#getGoldenGoldAttBonus()\n     */\n    public int getGoldenGoldAttBonus() {\n        return WeaponData.GOLDEN_GUN_ATTACK_BONUS;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#getGoldenGoldDeffBonus()\n     */\n    public int getGoldenGoldDeffBonus() {\n        return WeaponData.GOLDEN_GUN_DEFENSE_BONUS;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasBayonet(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasBayonet(final Weapon weapon) {\n        return hasBonus(weapon, 25, 75);\n    }\n\n    /**\n     * @param weapon\n     * @param weaponData\n     * @param minDmgBonus\n     * @param maxDmgBonus\n     * @return\n     */\n    boolean hasBonus(final Weapon weapon, final int minDmgBonus, final int maxDmgBonus) {\n        final WeaponGameData weaponData = data.get(Integer.valueOf(weapon.getId()));\n        return weaponData != null && weapon.maxDamage() - weaponData.maxDamage == maxDmgBonus && weapon.minDamage() - weaponData.minDamage == minDmgBonus;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasGraphitLubricant(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasGraphitLubricant(final Weapon weapon) {\n        return hasBonus(weapon, 20, 40);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasFettesWeaponOil(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasFettesWeaponOil(final Weapon weapon) {\n        return hasBonus(weapon, 50, 50);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasSchmierendesWeaponOil(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasSchmierendesWeaponOil(final Weapon weapon) {\n        return hasBonus(weapon, 60, 60);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasShinyWeaponOil(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasShinyWeaponOil(final Weapon weapon) {\n        return hasBonus(weapon, 75, 75);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasHipFlask(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasHipFlask(final Weapon weapon) {\n        return hasBonus(weapon, 40, 40);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasLoadingchamberOrEnhancedPatrons(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasLoadingchamberOrEnhancedPatrons(final Weapon weapon) {\n        return hasBonus(weapon, 30, 30);\n    }\n\n    /**\n     * Parsed data from file.\n     *\n     * @author daniel\n     */\n    static class WeaponGameData {\n\n        @SuppressWarnings(\"javadoc\")\n        final int id;\n\n        @SuppressWarnings(\"javadoc\")\n        final int minDamage;\n\n        @SuppressWarnings(\"javadoc\")\n        final int maxDamage;\n\n        @SuppressWarnings(\"javadoc\")\n        final int bonusOffense;\n\n        @SuppressWarnings(\"javadoc\")\n        final int bonusDefense;\n\n        @SuppressWarnings(\"javadoc\")\n        final String name;\n\n        /**\n         * @param id\n         * @param minDamage\n         * @param maxDamage\n         * @param bonusOffense\n         * @param bonusDefense\n         * @param name\n         */\n        WeaponGameData(final int id, final int minDamage, final int maxDamage, final int bonusOffense, final int bonusDefense, final String name) {\n            this.id = id;\n            this.minDamage = minDamage;\n            this.maxDamage = maxDamage;\n            this.bonusOffense = bonusOffense;\n            this.bonusDefense = bonusDefense;\n            this.name = name;\n        }\n\n        /**\n         * @see java.lang.Object#hashCode()\n         */\n        @Override\n        public int hashCode() {\n            final int prime = 31;\n            int result = 1;\n            result = prime * result + bonusDefense;\n            result = prime * result + bonusOffense;\n            result = prime * result + id;\n            result = prime * result + maxDamage;\n            result = prime * result + minDamage;\n            result = prime * result + ((name == null) ? 0 : name.hashCode());\n            return result;\n        }\n\n        /**\n         * @see java.lang.Object#equals(java.lang.Object)\n         */\n        @Override\n        public boolean equals(final Object obj) {\n            if (this == obj) {\n                return true;\n            }\n            if (obj == null) {\n                return false;\n            }\n            if (!(obj instanceof WeaponGameData)) {\n                return false;\n            }\n            final WeaponGameData other = (WeaponGameData) obj;\n            if (bonusDefense != other.bonusDefense) {\n                return false;\n            }\n            if (bonusOffense != other.bonusOffense) {\n                return false;\n            }\n            if (id != other.id) {\n                return false;\n            }\n            if (maxDamage != other.maxDamage) {\n                return false;\n            }\n            if (minDamage != other.minDamage) {\n                return false;\n            }\n            if (name == null) {\n                if (other.name != null) {\n                    return false;\n                }\n            } else if (!name.equals(other.name)) {\n                return false;\n            }\n            return true;\n        }\n\n        /**\n         * @see java.lang.Object#toString()\n         */\n        @Override\n        public String toString() {\n            return \"WeaponGameData: minDmg=\" + minDamage + \", maxDmg=\" + maxDamage + \", offBonus=\" + bonusOffense + \", deffBonus=\" + bonusDefense + \", name=\" + name;\n        }\n    }\n\n    /**\n     * @param args\n     */\n    public static void main(final String[] args) {\n        System.out.println(data);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/model/impl/JSWeaponData_2Test.java",
		"test_prompt": "// JSWeaponData_2Test.java\npackage de.outstare.fortbattleplayer.model.impl;\n\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JSWeaponData}.\n* It contains ten unit test cases for the {@link JSWeaponData#hasGraphitLubricant(Weapon)} method.\n*/\nclass JSWeaponData_2Test {"
	},
	{
		"original_code": "// JSWeaponData.java\npackage de.outstare.fortbattleplayer.model.impl;\n\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\n\n/**\n * A JSWeaponData uses the data from the JavaScript object \"ItemManager\".\n *\n * @author daniel\n */\npublic class JSWeaponData implements WeaponData {\n\n    private static final transient Logger LOG = Logger.getLogger(JSWeaponData.class.getName());\n\n    private static final String CSV_FILE_WEAPONS = \"/weaponData.csv\";\n\n    private static final String CSV_DELIMITER = \",\";\n\n    /**\n     * maps the id of a weapon to it's stats\n     */\n    protected final static Map<Integer, WeaponGameData> data = loadData(CSV_FILE_WEAPONS);\n\n    /**\n     * @param filename\n     * @return\n     */\n    private static Map<Integer, WeaponGameData> loadData(final String filename) {\n        final Map<Integer, WeaponGameData> result = new HashMap<Integer, WeaponGameData>();\n        try {\n            final InputStream fileInput = JSWeaponData.class.getResourceAsStream(filename);\n            if (fileInput == null) {\n                throw new FileNotFoundException(filename);\n            }\n            final BufferedReader input = new BufferedReader(new InputStreamReader(fileInput));\n            try {\n                String line;\n                while ((line = input.readLine()) != null) {\n                    if (\"\".equals(line.trim())) {\n                        continue;\n                    }\n                    final String[] values = line.split(CSV_DELIMITER);\n                    assert values.length >= 5 : \"csv has not at least 5 fields!\";\n                    final int id = Integer.valueOf(values[0]).intValue();\n                    final int minDmg = Integer.valueOf(values[1]).intValue();\n                    final int maxDmg = Integer.valueOf(values[2]).intValue();\n                    final int attBonus = Integer.valueOf(values[3]).intValue();\n                    final int deffBonus = Integer.valueOf(values[4]).intValue();\n                    final String weaponName;\n                    if (values.length > 5) {\n                        weaponName = values[5];\n                    } else {\n                        weaponName = \"\";\n                    }\n                    final WeaponGameData weapon = new WeaponGameData(id, minDmg, maxDmg, attBonus, deffBonus, weaponName);\n                    result.put(Integer.valueOf(id), weapon);\n                }\n                LOG.fine(\"successfully read \" + result.size() + \" weapon data from file \" + filename);\n            } finally {\n                input.close();\n                fileInput.close();\n            }\n        } catch (final FileNotFoundException e) {\n            LOG.severe(\"the CSV file with the bayonet damages was not found: \" + filename);\n            e.printStackTrace();\n        } catch (final IOException e) {\n            LOG.severe(\"failed to load CSV file with bayonet damages: \" + e.toString());\n            e.printStackTrace();\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#isGoldenGun(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean isGoldenGun(final Weapon weapon) {\n        final WeaponGameData weaponData = data.get(Integer.valueOf(weapon.getId()));\n        // System.out.println(\"data for \" + weapon.getId() + \" is \" +\n        // weaponData);\n        return weaponData != null && (weaponData.bonusOffense > 0 || weaponData.bonusDefense > 0);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#getGoldenGoldDmgBonus()\n     */\n    public int getGoldenGoldDmgBonus() {\n        return WeaponData.GOLDEN_GUN_DAMAGE_BONUS;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#getGoldenGoldAttBonus()\n     */\n    public int getGoldenGoldAttBonus() {\n        return WeaponData.GOLDEN_GUN_ATTACK_BONUS;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#getGoldenGoldDeffBonus()\n     */\n    public int getGoldenGoldDeffBonus() {\n        return WeaponData.GOLDEN_GUN_DEFENSE_BONUS;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasBayonet(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasBayonet(final Weapon weapon) {\n        return hasBonus(weapon, 25, 75);\n    }\n\n    /**\n     * @param weapon\n     * @param weaponData\n     * @param minDmgBonus\n     * @param maxDmgBonus\n     * @return\n     */\n    boolean hasBonus(final Weapon weapon, final int minDmgBonus, final int maxDmgBonus) {\n        final WeaponGameData weaponData = data.get(Integer.valueOf(weapon.getId()));\n        return weaponData != null && weapon.maxDamage() - weaponData.maxDamage == maxDmgBonus && weapon.minDamage() - weaponData.minDamage == minDmgBonus;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasGraphitLubricant(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasGraphitLubricant(final Weapon weapon) {\n        return hasBonus(weapon, 20, 40);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasFettesWeaponOil(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasFettesWeaponOil(final Weapon weapon) {\n        return hasBonus(weapon, 50, 50);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasSchmierendesWeaponOil(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasSchmierendesWeaponOil(final Weapon weapon) {\n        return hasBonus(weapon, 60, 60);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasShinyWeaponOil(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasShinyWeaponOil(final Weapon weapon) {\n        return hasBonus(weapon, 75, 75);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasHipFlask(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasHipFlask(final Weapon weapon) {\n        return hasBonus(weapon, 40, 40);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasLoadingchamberOrEnhancedPatrons(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasLoadingchamberOrEnhancedPatrons(final Weapon weapon) {\n        return hasBonus(weapon, 30, 30);\n    }\n\n    /**\n     * Parsed data from file.\n     *\n     * @author daniel\n     */\n    static class WeaponGameData {\n\n        @SuppressWarnings(\"javadoc\")\n        final int id;\n\n        @SuppressWarnings(\"javadoc\")\n        final int minDamage;\n\n        @SuppressWarnings(\"javadoc\")\n        final int maxDamage;\n\n        @SuppressWarnings(\"javadoc\")\n        final int bonusOffense;\n\n        @SuppressWarnings(\"javadoc\")\n        final int bonusDefense;\n\n        @SuppressWarnings(\"javadoc\")\n        final String name;\n\n        /**\n         * @param id\n         * @param minDamage\n         * @param maxDamage\n         * @param bonusOffense\n         * @param bonusDefense\n         * @param name\n         */\n        WeaponGameData(final int id, final int minDamage, final int maxDamage, final int bonusOffense, final int bonusDefense, final String name) {\n            this.id = id;\n            this.minDamage = minDamage;\n            this.maxDamage = maxDamage;\n            this.bonusOffense = bonusOffense;\n            this.bonusDefense = bonusDefense;\n            this.name = name;\n        }\n\n        /**\n         * @see java.lang.Object#hashCode()\n         */\n        @Override\n        public int hashCode() {\n            final int prime = 31;\n            int result = 1;\n            result = prime * result + bonusDefense;\n            result = prime * result + bonusOffense;\n            result = prime * result + id;\n            result = prime * result + maxDamage;\n            result = prime * result + minDamage;\n            result = prime * result + ((name == null) ? 0 : name.hashCode());\n            return result;\n        }\n\n        /**\n         * @see java.lang.Object#equals(java.lang.Object)\n         */\n        @Override\n        public boolean equals(final Object obj) {\n            if (this == obj) {\n                return true;\n            }\n            if (obj == null) {\n                return false;\n            }\n            if (!(obj instanceof WeaponGameData)) {\n                return false;\n            }\n            final WeaponGameData other = (WeaponGameData) obj;\n            if (bonusDefense != other.bonusDefense) {\n                return false;\n            }\n            if (bonusOffense != other.bonusOffense) {\n                return false;\n            }\n            if (id != other.id) {\n                return false;\n            }\n            if (maxDamage != other.maxDamage) {\n                return false;\n            }\n            if (minDamage != other.minDamage) {\n                return false;\n            }\n            if (name == null) {\n                if (other.name != null) {\n                    return false;\n                }\n            } else if (!name.equals(other.name)) {\n                return false;\n            }\n            return true;\n        }\n\n        /**\n         * @see java.lang.Object#toString()\n         */\n        @Override\n        public String toString() {\n            return \"WeaponGameData: minDmg=\" + minDamage + \", maxDmg=\" + maxDamage + \", offBonus=\" + bonusOffense + \", deffBonus=\" + bonusDefense + \", name=\" + name;\n        }\n    }\n\n    /**\n     * @param args\n     */\n    public static void main(final String[] args) {\n        System.out.println(data);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/model/impl/JSWeaponData_3Test.java",
		"test_prompt": "// JSWeaponData_3Test.java\npackage de.outstare.fortbattleplayer.model.impl;\n\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JSWeaponData}.\n* It contains ten unit test cases for the {@link JSWeaponData#hasFettesWeaponOil(Weapon)} method.\n*/\nclass JSWeaponData_3Test {"
	},
	{
		"original_code": "// JSWeaponData.java\npackage de.outstare.fortbattleplayer.model.impl;\n\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\n\n/**\n * A JSWeaponData uses the data from the JavaScript object \"ItemManager\".\n *\n * @author daniel\n */\npublic class JSWeaponData implements WeaponData {\n\n    private static final transient Logger LOG = Logger.getLogger(JSWeaponData.class.getName());\n\n    private static final String CSV_FILE_WEAPONS = \"/weaponData.csv\";\n\n    private static final String CSV_DELIMITER = \",\";\n\n    /**\n     * maps the id of a weapon to it's stats\n     */\n    protected final static Map<Integer, WeaponGameData> data = loadData(CSV_FILE_WEAPONS);\n\n    /**\n     * @param filename\n     * @return\n     */\n    private static Map<Integer, WeaponGameData> loadData(final String filename) {\n        final Map<Integer, WeaponGameData> result = new HashMap<Integer, WeaponGameData>();\n        try {\n            final InputStream fileInput = JSWeaponData.class.getResourceAsStream(filename);\n            if (fileInput == null) {\n                throw new FileNotFoundException(filename);\n            }\n            final BufferedReader input = new BufferedReader(new InputStreamReader(fileInput));\n            try {\n                String line;\n                while ((line = input.readLine()) != null) {\n                    if (\"\".equals(line.trim())) {\n                        continue;\n                    }\n                    final String[] values = line.split(CSV_DELIMITER);\n                    assert values.length >= 5 : \"csv has not at least 5 fields!\";\n                    final int id = Integer.valueOf(values[0]).intValue();\n                    final int minDmg = Integer.valueOf(values[1]).intValue();\n                    final int maxDmg = Integer.valueOf(values[2]).intValue();\n                    final int attBonus = Integer.valueOf(values[3]).intValue();\n                    final int deffBonus = Integer.valueOf(values[4]).intValue();\n                    final String weaponName;\n                    if (values.length > 5) {\n                        weaponName = values[5];\n                    } else {\n                        weaponName = \"\";\n                    }\n                    final WeaponGameData weapon = new WeaponGameData(id, minDmg, maxDmg, attBonus, deffBonus, weaponName);\n                    result.put(Integer.valueOf(id), weapon);\n                }\n                LOG.fine(\"successfully read \" + result.size() + \" weapon data from file \" + filename);\n            } finally {\n                input.close();\n                fileInput.close();\n            }\n        } catch (final FileNotFoundException e) {\n            LOG.severe(\"the CSV file with the bayonet damages was not found: \" + filename);\n            e.printStackTrace();\n        } catch (final IOException e) {\n            LOG.severe(\"failed to load CSV file with bayonet damages: \" + e.toString());\n            e.printStackTrace();\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#isGoldenGun(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean isGoldenGun(final Weapon weapon) {\n        final WeaponGameData weaponData = data.get(Integer.valueOf(weapon.getId()));\n        // System.out.println(\"data for \" + weapon.getId() + \" is \" +\n        // weaponData);\n        return weaponData != null && (weaponData.bonusOffense > 0 || weaponData.bonusDefense > 0);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#getGoldenGoldDmgBonus()\n     */\n    public int getGoldenGoldDmgBonus() {\n        return WeaponData.GOLDEN_GUN_DAMAGE_BONUS;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#getGoldenGoldAttBonus()\n     */\n    public int getGoldenGoldAttBonus() {\n        return WeaponData.GOLDEN_GUN_ATTACK_BONUS;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#getGoldenGoldDeffBonus()\n     */\n    public int getGoldenGoldDeffBonus() {\n        return WeaponData.GOLDEN_GUN_DEFENSE_BONUS;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasBayonet(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasBayonet(final Weapon weapon) {\n        return hasBonus(weapon, 25, 75);\n    }\n\n    /**\n     * @param weapon\n     * @param weaponData\n     * @param minDmgBonus\n     * @param maxDmgBonus\n     * @return\n     */\n    boolean hasBonus(final Weapon weapon, final int minDmgBonus, final int maxDmgBonus) {\n        final WeaponGameData weaponData = data.get(Integer.valueOf(weapon.getId()));\n        return weaponData != null && weapon.maxDamage() - weaponData.maxDamage == maxDmgBonus && weapon.minDamage() - weaponData.minDamage == minDmgBonus;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasGraphitLubricant(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasGraphitLubricant(final Weapon weapon) {\n        return hasBonus(weapon, 20, 40);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasFettesWeaponOil(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasFettesWeaponOil(final Weapon weapon) {\n        return hasBonus(weapon, 50, 50);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasSchmierendesWeaponOil(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasSchmierendesWeaponOil(final Weapon weapon) {\n        return hasBonus(weapon, 60, 60);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasShinyWeaponOil(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasShinyWeaponOil(final Weapon weapon) {\n        return hasBonus(weapon, 75, 75);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasHipFlask(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasHipFlask(final Weapon weapon) {\n        return hasBonus(weapon, 40, 40);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasLoadingchamberOrEnhancedPatrons(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasLoadingchamberOrEnhancedPatrons(final Weapon weapon) {\n        return hasBonus(weapon, 30, 30);\n    }\n\n    /**\n     * Parsed data from file.\n     *\n     * @author daniel\n     */\n    static class WeaponGameData {\n\n        @SuppressWarnings(\"javadoc\")\n        final int id;\n\n        @SuppressWarnings(\"javadoc\")\n        final int minDamage;\n\n        @SuppressWarnings(\"javadoc\")\n        final int maxDamage;\n\n        @SuppressWarnings(\"javadoc\")\n        final int bonusOffense;\n\n        @SuppressWarnings(\"javadoc\")\n        final int bonusDefense;\n\n        @SuppressWarnings(\"javadoc\")\n        final String name;\n\n        /**\n         * @param id\n         * @param minDamage\n         * @param maxDamage\n         * @param bonusOffense\n         * @param bonusDefense\n         * @param name\n         */\n        WeaponGameData(final int id, final int minDamage, final int maxDamage, final int bonusOffense, final int bonusDefense, final String name) {\n            this.id = id;\n            this.minDamage = minDamage;\n            this.maxDamage = maxDamage;\n            this.bonusOffense = bonusOffense;\n            this.bonusDefense = bonusDefense;\n            this.name = name;\n        }\n\n        /**\n         * @see java.lang.Object#hashCode()\n         */\n        @Override\n        public int hashCode() {\n            final int prime = 31;\n            int result = 1;\n            result = prime * result + bonusDefense;\n            result = prime * result + bonusOffense;\n            result = prime * result + id;\n            result = prime * result + maxDamage;\n            result = prime * result + minDamage;\n            result = prime * result + ((name == null) ? 0 : name.hashCode());\n            return result;\n        }\n\n        /**\n         * @see java.lang.Object#equals(java.lang.Object)\n         */\n        @Override\n        public boolean equals(final Object obj) {\n            if (this == obj) {\n                return true;\n            }\n            if (obj == null) {\n                return false;\n            }\n            if (!(obj instanceof WeaponGameData)) {\n                return false;\n            }\n            final WeaponGameData other = (WeaponGameData) obj;\n            if (bonusDefense != other.bonusDefense) {\n                return false;\n            }\n            if (bonusOffense != other.bonusOffense) {\n                return false;\n            }\n            if (id != other.id) {\n                return false;\n            }\n            if (maxDamage != other.maxDamage) {\n                return false;\n            }\n            if (minDamage != other.minDamage) {\n                return false;\n            }\n            if (name == null) {\n                if (other.name != null) {\n                    return false;\n                }\n            } else if (!name.equals(other.name)) {\n                return false;\n            }\n            return true;\n        }\n\n        /**\n         * @see java.lang.Object#toString()\n         */\n        @Override\n        public String toString() {\n            return \"WeaponGameData: minDmg=\" + minDamage + \", maxDmg=\" + maxDamage + \", offBonus=\" + bonusOffense + \", deffBonus=\" + bonusDefense + \", name=\" + name;\n        }\n    }\n\n    /**\n     * @param args\n     */\n    public static void main(final String[] args) {\n        System.out.println(data);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/model/impl/JSWeaponData_4Test.java",
		"test_prompt": "// JSWeaponData_4Test.java\npackage de.outstare.fortbattleplayer.model.impl;\n\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JSWeaponData}.\n* It contains ten unit test cases for the {@link JSWeaponData#hasSchmierendesWeaponOil(Weapon)} method.\n*/\nclass JSWeaponData_4Test {"
	},
	{
		"original_code": "// JSWeaponData.java\npackage de.outstare.fortbattleplayer.model.impl;\n\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\n\n/**\n * A JSWeaponData uses the data from the JavaScript object \"ItemManager\".\n *\n * @author daniel\n */\npublic class JSWeaponData implements WeaponData {\n\n    private static final transient Logger LOG = Logger.getLogger(JSWeaponData.class.getName());\n\n    private static final String CSV_FILE_WEAPONS = \"/weaponData.csv\";\n\n    private static final String CSV_DELIMITER = \",\";\n\n    /**\n     * maps the id of a weapon to it's stats\n     */\n    protected final static Map<Integer, WeaponGameData> data = loadData(CSV_FILE_WEAPONS);\n\n    /**\n     * @param filename\n     * @return\n     */\n    private static Map<Integer, WeaponGameData> loadData(final String filename) {\n        final Map<Integer, WeaponGameData> result = new HashMap<Integer, WeaponGameData>();\n        try {\n            final InputStream fileInput = JSWeaponData.class.getResourceAsStream(filename);\n            if (fileInput == null) {\n                throw new FileNotFoundException(filename);\n            }\n            final BufferedReader input = new BufferedReader(new InputStreamReader(fileInput));\n            try {\n                String line;\n                while ((line = input.readLine()) != null) {\n                    if (\"\".equals(line.trim())) {\n                        continue;\n                    }\n                    final String[] values = line.split(CSV_DELIMITER);\n                    assert values.length >= 5 : \"csv has not at least 5 fields!\";\n                    final int id = Integer.valueOf(values[0]).intValue();\n                    final int minDmg = Integer.valueOf(values[1]).intValue();\n                    final int maxDmg = Integer.valueOf(values[2]).intValue();\n                    final int attBonus = Integer.valueOf(values[3]).intValue();\n                    final int deffBonus = Integer.valueOf(values[4]).intValue();\n                    final String weaponName;\n                    if (values.length > 5) {\n                        weaponName = values[5];\n                    } else {\n                        weaponName = \"\";\n                    }\n                    final WeaponGameData weapon = new WeaponGameData(id, minDmg, maxDmg, attBonus, deffBonus, weaponName);\n                    result.put(Integer.valueOf(id), weapon);\n                }\n                LOG.fine(\"successfully read \" + result.size() + \" weapon data from file \" + filename);\n            } finally {\n                input.close();\n                fileInput.close();\n            }\n        } catch (final FileNotFoundException e) {\n            LOG.severe(\"the CSV file with the bayonet damages was not found: \" + filename);\n            e.printStackTrace();\n        } catch (final IOException e) {\n            LOG.severe(\"failed to load CSV file with bayonet damages: \" + e.toString());\n            e.printStackTrace();\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#isGoldenGun(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean isGoldenGun(final Weapon weapon) {\n        final WeaponGameData weaponData = data.get(Integer.valueOf(weapon.getId()));\n        // System.out.println(\"data for \" + weapon.getId() + \" is \" +\n        // weaponData);\n        return weaponData != null && (weaponData.bonusOffense > 0 || weaponData.bonusDefense > 0);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#getGoldenGoldDmgBonus()\n     */\n    public int getGoldenGoldDmgBonus() {\n        return WeaponData.GOLDEN_GUN_DAMAGE_BONUS;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#getGoldenGoldAttBonus()\n     */\n    public int getGoldenGoldAttBonus() {\n        return WeaponData.GOLDEN_GUN_ATTACK_BONUS;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#getGoldenGoldDeffBonus()\n     */\n    public int getGoldenGoldDeffBonus() {\n        return WeaponData.GOLDEN_GUN_DEFENSE_BONUS;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasBayonet(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasBayonet(final Weapon weapon) {\n        return hasBonus(weapon, 25, 75);\n    }\n\n    /**\n     * @param weapon\n     * @param weaponData\n     * @param minDmgBonus\n     * @param maxDmgBonus\n     * @return\n     */\n    boolean hasBonus(final Weapon weapon, final int minDmgBonus, final int maxDmgBonus) {\n        final WeaponGameData weaponData = data.get(Integer.valueOf(weapon.getId()));\n        return weaponData != null && weapon.maxDamage() - weaponData.maxDamage == maxDmgBonus && weapon.minDamage() - weaponData.minDamage == minDmgBonus;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasGraphitLubricant(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasGraphitLubricant(final Weapon weapon) {\n        return hasBonus(weapon, 20, 40);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasFettesWeaponOil(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasFettesWeaponOil(final Weapon weapon) {\n        return hasBonus(weapon, 50, 50);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasSchmierendesWeaponOil(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasSchmierendesWeaponOil(final Weapon weapon) {\n        return hasBonus(weapon, 60, 60);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasShinyWeaponOil(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasShinyWeaponOil(final Weapon weapon) {\n        return hasBonus(weapon, 75, 75);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasHipFlask(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasHipFlask(final Weapon weapon) {\n        return hasBonus(weapon, 40, 40);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasLoadingchamberOrEnhancedPatrons(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasLoadingchamberOrEnhancedPatrons(final Weapon weapon) {\n        return hasBonus(weapon, 30, 30);\n    }\n\n    /**\n     * Parsed data from file.\n     *\n     * @author daniel\n     */\n    static class WeaponGameData {\n\n        @SuppressWarnings(\"javadoc\")\n        final int id;\n\n        @SuppressWarnings(\"javadoc\")\n        final int minDamage;\n\n        @SuppressWarnings(\"javadoc\")\n        final int maxDamage;\n\n        @SuppressWarnings(\"javadoc\")\n        final int bonusOffense;\n\n        @SuppressWarnings(\"javadoc\")\n        final int bonusDefense;\n\n        @SuppressWarnings(\"javadoc\")\n        final String name;\n\n        /**\n         * @param id\n         * @param minDamage\n         * @param maxDamage\n         * @param bonusOffense\n         * @param bonusDefense\n         * @param name\n         */\n        WeaponGameData(final int id, final int minDamage, final int maxDamage, final int bonusOffense, final int bonusDefense, final String name) {\n            this.id = id;\n            this.minDamage = minDamage;\n            this.maxDamage = maxDamage;\n            this.bonusOffense = bonusOffense;\n            this.bonusDefense = bonusDefense;\n            this.name = name;\n        }\n\n        /**\n         * @see java.lang.Object#hashCode()\n         */\n        @Override\n        public int hashCode() {\n            final int prime = 31;\n            int result = 1;\n            result = prime * result + bonusDefense;\n            result = prime * result + bonusOffense;\n            result = prime * result + id;\n            result = prime * result + maxDamage;\n            result = prime * result + minDamage;\n            result = prime * result + ((name == null) ? 0 : name.hashCode());\n            return result;\n        }\n\n        /**\n         * @see java.lang.Object#equals(java.lang.Object)\n         */\n        @Override\n        public boolean equals(final Object obj) {\n            if (this == obj) {\n                return true;\n            }\n            if (obj == null) {\n                return false;\n            }\n            if (!(obj instanceof WeaponGameData)) {\n                return false;\n            }\n            final WeaponGameData other = (WeaponGameData) obj;\n            if (bonusDefense != other.bonusDefense) {\n                return false;\n            }\n            if (bonusOffense != other.bonusOffense) {\n                return false;\n            }\n            if (id != other.id) {\n                return false;\n            }\n            if (maxDamage != other.maxDamage) {\n                return false;\n            }\n            if (minDamage != other.minDamage) {\n                return false;\n            }\n            if (name == null) {\n                if (other.name != null) {\n                    return false;\n                }\n            } else if (!name.equals(other.name)) {\n                return false;\n            }\n            return true;\n        }\n\n        /**\n         * @see java.lang.Object#toString()\n         */\n        @Override\n        public String toString() {\n            return \"WeaponGameData: minDmg=\" + minDamage + \", maxDmg=\" + maxDamage + \", offBonus=\" + bonusOffense + \", deffBonus=\" + bonusDefense + \", name=\" + name;\n        }\n    }\n\n    /**\n     * @param args\n     */\n    public static void main(final String[] args) {\n        System.out.println(data);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/model/impl/JSWeaponData_5Test.java",
		"test_prompt": "// JSWeaponData_5Test.java\npackage de.outstare.fortbattleplayer.model.impl;\n\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JSWeaponData}.\n* It contains ten unit test cases for the {@link JSWeaponData#hasShinyWeaponOil(Weapon)} method.\n*/\nclass JSWeaponData_5Test {"
	},
	{
		"original_code": "// JSWeaponData.java\npackage de.outstare.fortbattleplayer.model.impl;\n\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\n\n/**\n * A JSWeaponData uses the data from the JavaScript object \"ItemManager\".\n *\n * @author daniel\n */\npublic class JSWeaponData implements WeaponData {\n\n    private static final transient Logger LOG = Logger.getLogger(JSWeaponData.class.getName());\n\n    private static final String CSV_FILE_WEAPONS = \"/weaponData.csv\";\n\n    private static final String CSV_DELIMITER = \",\";\n\n    /**\n     * maps the id of a weapon to it's stats\n     */\n    protected final static Map<Integer, WeaponGameData> data = loadData(CSV_FILE_WEAPONS);\n\n    /**\n     * @param filename\n     * @return\n     */\n    private static Map<Integer, WeaponGameData> loadData(final String filename) {\n        final Map<Integer, WeaponGameData> result = new HashMap<Integer, WeaponGameData>();\n        try {\n            final InputStream fileInput = JSWeaponData.class.getResourceAsStream(filename);\n            if (fileInput == null) {\n                throw new FileNotFoundException(filename);\n            }\n            final BufferedReader input = new BufferedReader(new InputStreamReader(fileInput));\n            try {\n                String line;\n                while ((line = input.readLine()) != null) {\n                    if (\"\".equals(line.trim())) {\n                        continue;\n                    }\n                    final String[] values = line.split(CSV_DELIMITER);\n                    assert values.length >= 5 : \"csv has not at least 5 fields!\";\n                    final int id = Integer.valueOf(values[0]).intValue();\n                    final int minDmg = Integer.valueOf(values[1]).intValue();\n                    final int maxDmg = Integer.valueOf(values[2]).intValue();\n                    final int attBonus = Integer.valueOf(values[3]).intValue();\n                    final int deffBonus = Integer.valueOf(values[4]).intValue();\n                    final String weaponName;\n                    if (values.length > 5) {\n                        weaponName = values[5];\n                    } else {\n                        weaponName = \"\";\n                    }\n                    final WeaponGameData weapon = new WeaponGameData(id, minDmg, maxDmg, attBonus, deffBonus, weaponName);\n                    result.put(Integer.valueOf(id), weapon);\n                }\n                LOG.fine(\"successfully read \" + result.size() + \" weapon data from file \" + filename);\n            } finally {\n                input.close();\n                fileInput.close();\n            }\n        } catch (final FileNotFoundException e) {\n            LOG.severe(\"the CSV file with the bayonet damages was not found: \" + filename);\n            e.printStackTrace();\n        } catch (final IOException e) {\n            LOG.severe(\"failed to load CSV file with bayonet damages: \" + e.toString());\n            e.printStackTrace();\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#isGoldenGun(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean isGoldenGun(final Weapon weapon) {\n        final WeaponGameData weaponData = data.get(Integer.valueOf(weapon.getId()));\n        // System.out.println(\"data for \" + weapon.getId() + \" is \" +\n        // weaponData);\n        return weaponData != null && (weaponData.bonusOffense > 0 || weaponData.bonusDefense > 0);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#getGoldenGoldDmgBonus()\n     */\n    public int getGoldenGoldDmgBonus() {\n        return WeaponData.GOLDEN_GUN_DAMAGE_BONUS;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#getGoldenGoldAttBonus()\n     */\n    public int getGoldenGoldAttBonus() {\n        return WeaponData.GOLDEN_GUN_ATTACK_BONUS;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#getGoldenGoldDeffBonus()\n     */\n    public int getGoldenGoldDeffBonus() {\n        return WeaponData.GOLDEN_GUN_DEFENSE_BONUS;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasBayonet(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasBayonet(final Weapon weapon) {\n        return hasBonus(weapon, 25, 75);\n    }\n\n    /**\n     * @param weapon\n     * @param weaponData\n     * @param minDmgBonus\n     * @param maxDmgBonus\n     * @return\n     */\n    boolean hasBonus(final Weapon weapon, final int minDmgBonus, final int maxDmgBonus) {\n        final WeaponGameData weaponData = data.get(Integer.valueOf(weapon.getId()));\n        return weaponData != null && weapon.maxDamage() - weaponData.maxDamage == maxDmgBonus && weapon.minDamage() - weaponData.minDamage == minDmgBonus;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasGraphitLubricant(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasGraphitLubricant(final Weapon weapon) {\n        return hasBonus(weapon, 20, 40);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasFettesWeaponOil(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasFettesWeaponOil(final Weapon weapon) {\n        return hasBonus(weapon, 50, 50);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasSchmierendesWeaponOil(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasSchmierendesWeaponOil(final Weapon weapon) {\n        return hasBonus(weapon, 60, 60);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasShinyWeaponOil(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasShinyWeaponOil(final Weapon weapon) {\n        return hasBonus(weapon, 75, 75);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasHipFlask(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasHipFlask(final Weapon weapon) {\n        return hasBonus(weapon, 40, 40);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasLoadingchamberOrEnhancedPatrons(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasLoadingchamberOrEnhancedPatrons(final Weapon weapon) {\n        return hasBonus(weapon, 30, 30);\n    }\n\n    /**\n     * Parsed data from file.\n     *\n     * @author daniel\n     */\n    static class WeaponGameData {\n\n        @SuppressWarnings(\"javadoc\")\n        final int id;\n\n        @SuppressWarnings(\"javadoc\")\n        final int minDamage;\n\n        @SuppressWarnings(\"javadoc\")\n        final int maxDamage;\n\n        @SuppressWarnings(\"javadoc\")\n        final int bonusOffense;\n\n        @SuppressWarnings(\"javadoc\")\n        final int bonusDefense;\n\n        @SuppressWarnings(\"javadoc\")\n        final String name;\n\n        /**\n         * @param id\n         * @param minDamage\n         * @param maxDamage\n         * @param bonusOffense\n         * @param bonusDefense\n         * @param name\n         */\n        WeaponGameData(final int id, final int minDamage, final int maxDamage, final int bonusOffense, final int bonusDefense, final String name) {\n            this.id = id;\n            this.minDamage = minDamage;\n            this.maxDamage = maxDamage;\n            this.bonusOffense = bonusOffense;\n            this.bonusDefense = bonusDefense;\n            this.name = name;\n        }\n\n        /**\n         * @see java.lang.Object#hashCode()\n         */\n        @Override\n        public int hashCode() {\n            final int prime = 31;\n            int result = 1;\n            result = prime * result + bonusDefense;\n            result = prime * result + bonusOffense;\n            result = prime * result + id;\n            result = prime * result + maxDamage;\n            result = prime * result + minDamage;\n            result = prime * result + ((name == null) ? 0 : name.hashCode());\n            return result;\n        }\n\n        /**\n         * @see java.lang.Object#equals(java.lang.Object)\n         */\n        @Override\n        public boolean equals(final Object obj) {\n            if (this == obj) {\n                return true;\n            }\n            if (obj == null) {\n                return false;\n            }\n            if (!(obj instanceof WeaponGameData)) {\n                return false;\n            }\n            final WeaponGameData other = (WeaponGameData) obj;\n            if (bonusDefense != other.bonusDefense) {\n                return false;\n            }\n            if (bonusOffense != other.bonusOffense) {\n                return false;\n            }\n            if (id != other.id) {\n                return false;\n            }\n            if (maxDamage != other.maxDamage) {\n                return false;\n            }\n            if (minDamage != other.minDamage) {\n                return false;\n            }\n            if (name == null) {\n                if (other.name != null) {\n                    return false;\n                }\n            } else if (!name.equals(other.name)) {\n                return false;\n            }\n            return true;\n        }\n\n        /**\n         * @see java.lang.Object#toString()\n         */\n        @Override\n        public String toString() {\n            return \"WeaponGameData: minDmg=\" + minDamage + \", maxDmg=\" + maxDamage + \", offBonus=\" + bonusOffense + \", deffBonus=\" + bonusDefense + \", name=\" + name;\n        }\n    }\n\n    /**\n     * @param args\n     */\n    public static void main(final String[] args) {\n        System.out.println(data);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/model/impl/JSWeaponData_6Test.java",
		"test_prompt": "// JSWeaponData_6Test.java\npackage de.outstare.fortbattleplayer.model.impl;\n\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JSWeaponData}.\n* It contains ten unit test cases for the {@link JSWeaponData#hasHipFlask(Weapon)} method.\n*/\nclass JSWeaponData_6Test {"
	},
	{
		"original_code": "// JSWeaponData.java\npackage de.outstare.fortbattleplayer.model.impl;\n\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\n\n/**\n * A JSWeaponData uses the data from the JavaScript object \"ItemManager\".\n *\n * @author daniel\n */\npublic class JSWeaponData implements WeaponData {\n\n    private static final transient Logger LOG = Logger.getLogger(JSWeaponData.class.getName());\n\n    private static final String CSV_FILE_WEAPONS = \"/weaponData.csv\";\n\n    private static final String CSV_DELIMITER = \",\";\n\n    /**\n     * maps the id of a weapon to it's stats\n     */\n    protected final static Map<Integer, WeaponGameData> data = loadData(CSV_FILE_WEAPONS);\n\n    /**\n     * @param filename\n     * @return\n     */\n    private static Map<Integer, WeaponGameData> loadData(final String filename) {\n        final Map<Integer, WeaponGameData> result = new HashMap<Integer, WeaponGameData>();\n        try {\n            final InputStream fileInput = JSWeaponData.class.getResourceAsStream(filename);\n            if (fileInput == null) {\n                throw new FileNotFoundException(filename);\n            }\n            final BufferedReader input = new BufferedReader(new InputStreamReader(fileInput));\n            try {\n                String line;\n                while ((line = input.readLine()) != null) {\n                    if (\"\".equals(line.trim())) {\n                        continue;\n                    }\n                    final String[] values = line.split(CSV_DELIMITER);\n                    assert values.length >= 5 : \"csv has not at least 5 fields!\";\n                    final int id = Integer.valueOf(values[0]).intValue();\n                    final int minDmg = Integer.valueOf(values[1]).intValue();\n                    final int maxDmg = Integer.valueOf(values[2]).intValue();\n                    final int attBonus = Integer.valueOf(values[3]).intValue();\n                    final int deffBonus = Integer.valueOf(values[4]).intValue();\n                    final String weaponName;\n                    if (values.length > 5) {\n                        weaponName = values[5];\n                    } else {\n                        weaponName = \"\";\n                    }\n                    final WeaponGameData weapon = new WeaponGameData(id, minDmg, maxDmg, attBonus, deffBonus, weaponName);\n                    result.put(Integer.valueOf(id), weapon);\n                }\n                LOG.fine(\"successfully read \" + result.size() + \" weapon data from file \" + filename);\n            } finally {\n                input.close();\n                fileInput.close();\n            }\n        } catch (final FileNotFoundException e) {\n            LOG.severe(\"the CSV file with the bayonet damages was not found: \" + filename);\n            e.printStackTrace();\n        } catch (final IOException e) {\n            LOG.severe(\"failed to load CSV file with bayonet damages: \" + e.toString());\n            e.printStackTrace();\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#isGoldenGun(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean isGoldenGun(final Weapon weapon) {\n        final WeaponGameData weaponData = data.get(Integer.valueOf(weapon.getId()));\n        // System.out.println(\"data for \" + weapon.getId() + \" is \" +\n        // weaponData);\n        return weaponData != null && (weaponData.bonusOffense > 0 || weaponData.bonusDefense > 0);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#getGoldenGoldDmgBonus()\n     */\n    public int getGoldenGoldDmgBonus() {\n        return WeaponData.GOLDEN_GUN_DAMAGE_BONUS;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#getGoldenGoldAttBonus()\n     */\n    public int getGoldenGoldAttBonus() {\n        return WeaponData.GOLDEN_GUN_ATTACK_BONUS;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#getGoldenGoldDeffBonus()\n     */\n    public int getGoldenGoldDeffBonus() {\n        return WeaponData.GOLDEN_GUN_DEFENSE_BONUS;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasBayonet(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasBayonet(final Weapon weapon) {\n        return hasBonus(weapon, 25, 75);\n    }\n\n    /**\n     * @param weapon\n     * @param weaponData\n     * @param minDmgBonus\n     * @param maxDmgBonus\n     * @return\n     */\n    boolean hasBonus(final Weapon weapon, final int minDmgBonus, final int maxDmgBonus) {\n        final WeaponGameData weaponData = data.get(Integer.valueOf(weapon.getId()));\n        return weaponData != null && weapon.maxDamage() - weaponData.maxDamage == maxDmgBonus && weapon.minDamage() - weaponData.minDamage == minDmgBonus;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasGraphitLubricant(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasGraphitLubricant(final Weapon weapon) {\n        return hasBonus(weapon, 20, 40);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasFettesWeaponOil(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasFettesWeaponOil(final Weapon weapon) {\n        return hasBonus(weapon, 50, 50);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasSchmierendesWeaponOil(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasSchmierendesWeaponOil(final Weapon weapon) {\n        return hasBonus(weapon, 60, 60);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasShinyWeaponOil(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasShinyWeaponOil(final Weapon weapon) {\n        return hasBonus(weapon, 75, 75);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasHipFlask(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasHipFlask(final Weapon weapon) {\n        return hasBonus(weapon, 40, 40);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasLoadingchamberOrEnhancedPatrons(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasLoadingchamberOrEnhancedPatrons(final Weapon weapon) {\n        return hasBonus(weapon, 30, 30);\n    }\n\n    /**\n     * Parsed data from file.\n     *\n     * @author daniel\n     */\n    static class WeaponGameData {\n\n        @SuppressWarnings(\"javadoc\")\n        final int id;\n\n        @SuppressWarnings(\"javadoc\")\n        final int minDamage;\n\n        @SuppressWarnings(\"javadoc\")\n        final int maxDamage;\n\n        @SuppressWarnings(\"javadoc\")\n        final int bonusOffense;\n\n        @SuppressWarnings(\"javadoc\")\n        final int bonusDefense;\n\n        @SuppressWarnings(\"javadoc\")\n        final String name;\n\n        /**\n         * @param id\n         * @param minDamage\n         * @param maxDamage\n         * @param bonusOffense\n         * @param bonusDefense\n         * @param name\n         */\n        WeaponGameData(final int id, final int minDamage, final int maxDamage, final int bonusOffense, final int bonusDefense, final String name) {\n            this.id = id;\n            this.minDamage = minDamage;\n            this.maxDamage = maxDamage;\n            this.bonusOffense = bonusOffense;\n            this.bonusDefense = bonusDefense;\n            this.name = name;\n        }\n\n        /**\n         * @see java.lang.Object#hashCode()\n         */\n        @Override\n        public int hashCode() {\n            final int prime = 31;\n            int result = 1;\n            result = prime * result + bonusDefense;\n            result = prime * result + bonusOffense;\n            result = prime * result + id;\n            result = prime * result + maxDamage;\n            result = prime * result + minDamage;\n            result = prime * result + ((name == null) ? 0 : name.hashCode());\n            return result;\n        }\n\n        /**\n         * @see java.lang.Object#equals(java.lang.Object)\n         */\n        @Override\n        public boolean equals(final Object obj) {\n            if (this == obj) {\n                return true;\n            }\n            if (obj == null) {\n                return false;\n            }\n            if (!(obj instanceof WeaponGameData)) {\n                return false;\n            }\n            final WeaponGameData other = (WeaponGameData) obj;\n            if (bonusDefense != other.bonusDefense) {\n                return false;\n            }\n            if (bonusOffense != other.bonusOffense) {\n                return false;\n            }\n            if (id != other.id) {\n                return false;\n            }\n            if (maxDamage != other.maxDamage) {\n                return false;\n            }\n            if (minDamage != other.minDamage) {\n                return false;\n            }\n            if (name == null) {\n                if (other.name != null) {\n                    return false;\n                }\n            } else if (!name.equals(other.name)) {\n                return false;\n            }\n            return true;\n        }\n\n        /**\n         * @see java.lang.Object#toString()\n         */\n        @Override\n        public String toString() {\n            return \"WeaponGameData: minDmg=\" + minDamage + \", maxDmg=\" + maxDamage + \", offBonus=\" + bonusOffense + \", deffBonus=\" + bonusDefense + \", name=\" + name;\n        }\n    }\n\n    /**\n     * @param args\n     */\n    public static void main(final String[] args) {\n        System.out.println(data);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/model/impl/JSWeaponData_7Test.java",
		"test_prompt": "// JSWeaponData_7Test.java\npackage de.outstare.fortbattleplayer.model.impl;\n\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JSWeaponData}.\n* It contains ten unit test cases for the {@link JSWeaponData#hasLoadingchamberOrEnhancedPatrons(Weapon)} method.\n*/\nclass JSWeaponData_7Test {"
	},
	{
		"original_code": "// SimpleBattleField.java\npackage de.outstare.fortbattleplayer.model.impl;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.awt.Point;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Battlefield;\nimport de.outstare.fortbattleplayer.model.Sector;\n\n/**\n * A simple {@link Battlefield} which just is a set of {@link Area}s with\n * x/y-coordinates\n *\n * @author daniel\n */\npublic class SimpleBattleField implements Battlefield {\n\n    private final Map<Point, Area> cells = new HashMap<Point, Area>();\n\n    private final Set<Sector> sectors = new HashSet<Sector>();\n\n    private final int width;\n\n    private final int height;\n\n    /**\n     * @param width\n     * @param height\n     * @param cells\n     * @param sectors\n     */\n    public SimpleBattleField(final int width, final int height, final Collection<Area> cells, final Collection<Sector> sectors) {\n        this.width = width;\n        this.height = height;\n        for (final Area cell : cells) {\n            this.cells.put(cell.getLocation(), cell);\n        }\n        this.sectors.addAll(sectors);\n    }\n\n    /**\n     * generates Areas for the whole battlefield with as a single sector\n     *\n     * @param width\n     * @param height\n     */\n    public SimpleBattleField(final int width, final int height) {\n        this(width, height, Collections.<Area>emptyList(), Collections.<Sector>emptyList());\n        final Sector theSector = new SimpleSector(0, false, false, 0, 0, false, 0, null);\n        sectors.add(theSector);\n        for (int y = 0; y < height; y++) {\n            for (int x = 0; x < width; x++) {\n                final Area cell = new SimpleArea(x, y, theSector);\n                cells.put(cell.getLocation(), cell);\n            }\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Battlefield#getHeight()\n     */\n    public int getHeight() {\n        return height;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Battlefield#getWidth()\n     */\n    public int getWidth() {\n        return width;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Battlefield#_getArea(int, int)\n     */\n    public Area _getArea(final int x, final int y) throws IllegalArgumentException {\n        if (x < 0 || x >= getWidth() || y < 0 || y >= getHeight()) {\n            throw new IllegalArgumentException(\"the given coordinates does not exist on this battlefield!\");\n        }\n        return cells.get(new Point(x, y));\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/model/impl/SimpleBattleField.java",
		"test_prompt": "// SimpleBattleFieldTest.java\npackage de.outstare.fortbattleplayer.model.impl;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.awt.Point;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Battlefield;\nimport de.outstare.fortbattleplayer.model.Sector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleBattleField}.\n* It contains ten unit test cases for the {@link SimpleBattleField#_getArea(int, int)} method.\n*/\nclass SimpleBattleFieldTest {"
	},
	{
		"original_code": "// SimpleArea.java\npackage de.outstare.fortbattleplayer.model.impl;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.awt.Point;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.Sector;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\n\n/**\n * A simple area which can hold one {@link Combatant}\n *\n * @author daniel\n */\npublic class SimpleArea implements Area {\n\n    private static final transient Logger LOG = Logger.getLogger(SimpleArea.class.getName());\n\n    private Combatant occupier;\n\n    private final Point location;\n\n    private final Sector sector;\n\n    /**\n     * Creates a new Area identified by the given coordinates\n     *\n     * @param x\n     * @param y\n     * @param sector\n     *            not <code>null</code>\n     */\n    public SimpleArea(final int x, final int y, final Sector sector) {\n        this(new Point(x, y), sector);\n    }\n\n    /**\n     * Creates a new Area identified by the given location\n     *\n     * @param location\n     * @param sector\n     *            not <code>null</code>\n     */\n    public SimpleArea(final Point location, final Sector sector) {\n        this.location = location;\n        this.sector = sector;\n        sector._addArea(this);\n    }\n\n    /**\n     * @see java.lang.Object#toString()\n     */\n    @Override\n    public String toString() {\n        return \"Area \" + location.x + \"/\" + location.y + \" [occupied by \" + occupier + \"]\";\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Area#free()\n     */\n    public void free() {\n        occupier = null;\n        sector.free();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Area#isOccupied()\n     */\n    public boolean isOccupied() {\n        return occupier != null;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Area#getOccupier()\n     */\n    public Combatant getOccupier() {\n        return occupier;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Area#occupy(de.outstare.fortbattleplayer.model.Combatant,\n     *      Area)\n     */\n    public Combatant occupy(final Combatant newOccupier, final Area oldPosition) {\n        Combatant oldOccupier = null;\n        // System.out.println(toString() + \" will be occupied by \" + newOccupier\n        // + \" from \" + oldPosition);\n        if (isOccupied() && !occupier.equals(newOccupier)) {\n            if (oldPosition == null) {\n                // IGNORE, because in the initial setup, multiple combatants may\n                // stay in the same area\n                // throw new IllegalStateException(\n                // \"This Area is already occupied and no Area for the current occupier was given!\");\n            } else if (oldPosition.isOccupied()) {\n                // IGNORE, for old battles with wrong start positions\n                // throw new IllegalArgumentException(toString() +\n                // \" cannot be occupied by \" + newOccupier.getName()\n                // + \" because \" + oldPosition.toString()\n                // +\n                // \" (the source Area of the occupier) is not free for the current occupier of this Area!\");\n            } else {\n                // swap places\n                // (TODO this is like a hack, but it is what The West does :-/)\n                oldOccupier = occupier;\n                LOG.fine(occupier.getName() + \" and \" + newOccupier + \" swapping positions\");\n                occupier.move(oldPosition);\n            }\n        }\n        occupier = newOccupier;\n        sector.gainControl(occupier.getSide());\n        return oldOccupier;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Area#getLocation()\n     */\n    public Point getLocation() {\n        return location;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Area#getHeight()\n     */\n    public int getHeight() {\n        return sector.getHeight();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Area#getSector()\n     */\n    public Sector getSector() {\n        assert sector != null : \"every area needs sector!\";\n        return sector;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Area#getSectorBonus(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public SectorBonus getSectorBonus(final Combatant combatant) {\n        return sector.getBonus(combatant.getCharacterClass());\n    }\n\n    /**\n     * @see java.lang.Object#hashCode()\n     */\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((location == null) ? 0 : location.hashCode());\n        return result;\n    }\n\n    /**\n     * @see java.lang.Object#equals(java.lang.Object)\n     */\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!(obj instanceof SimpleArea)) {\n            return false;\n        }\n        final SimpleArea other = (SimpleArea) obj;\n        if (location == null) {\n            if (other.location != null) {\n                return false;\n            }\n        } else if (!location.equals(other.location)) {\n            return false;\n        }\n        return true;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/model/impl/SimpleArea_0Test.java",
		"test_prompt": "// SimpleArea_0Test.java\npackage de.outstare.fortbattleplayer.model.impl;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.awt.Point;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.Sector;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleArea}.\n* It contains ten unit test cases for the {@link SimpleArea#isOccupied()} method.\n*/\nclass SimpleArea_0Test {"
	},
	{
		"original_code": "// SimpleArea.java\npackage de.outstare.fortbattleplayer.model.impl;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.awt.Point;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.Sector;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\n\n/**\n * A simple area which can hold one {@link Combatant}\n *\n * @author daniel\n */\npublic class SimpleArea implements Area {\n\n    private static final transient Logger LOG = Logger.getLogger(SimpleArea.class.getName());\n\n    private Combatant occupier;\n\n    private final Point location;\n\n    private final Sector sector;\n\n    /**\n     * Creates a new Area identified by the given coordinates\n     *\n     * @param x\n     * @param y\n     * @param sector\n     *            not <code>null</code>\n     */\n    public SimpleArea(final int x, final int y, final Sector sector) {\n        this(new Point(x, y), sector);\n    }\n\n    /**\n     * Creates a new Area identified by the given location\n     *\n     * @param location\n     * @param sector\n     *            not <code>null</code>\n     */\n    public SimpleArea(final Point location, final Sector sector) {\n        this.location = location;\n        this.sector = sector;\n        sector._addArea(this);\n    }\n\n    /**\n     * @see java.lang.Object#toString()\n     */\n    @Override\n    public String toString() {\n        return \"Area \" + location.x + \"/\" + location.y + \" [occupied by \" + occupier + \"]\";\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Area#free()\n     */\n    public void free() {\n        occupier = null;\n        sector.free();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Area#isOccupied()\n     */\n    public boolean isOccupied() {\n        return occupier != null;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Area#getOccupier()\n     */\n    public Combatant getOccupier() {\n        return occupier;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Area#occupy(de.outstare.fortbattleplayer.model.Combatant,\n     *      Area)\n     */\n    public Combatant occupy(final Combatant newOccupier, final Area oldPosition) {\n        Combatant oldOccupier = null;\n        // System.out.println(toString() + \" will be occupied by \" + newOccupier\n        // + \" from \" + oldPosition);\n        if (isOccupied() && !occupier.equals(newOccupier)) {\n            if (oldPosition == null) {\n                // IGNORE, because in the initial setup, multiple combatants may\n                // stay in the same area\n                // throw new IllegalStateException(\n                // \"This Area is already occupied and no Area for the current occupier was given!\");\n            } else if (oldPosition.isOccupied()) {\n                // IGNORE, for old battles with wrong start positions\n                // throw new IllegalArgumentException(toString() +\n                // \" cannot be occupied by \" + newOccupier.getName()\n                // + \" because \" + oldPosition.toString()\n                // +\n                // \" (the source Area of the occupier) is not free for the current occupier of this Area!\");\n            } else {\n                // swap places\n                // (TODO this is like a hack, but it is what The West does :-/)\n                oldOccupier = occupier;\n                LOG.fine(occupier.getName() + \" and \" + newOccupier + \" swapping positions\");\n                occupier.move(oldPosition);\n            }\n        }\n        occupier = newOccupier;\n        sector.gainControl(occupier.getSide());\n        return oldOccupier;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Area#getLocation()\n     */\n    public Point getLocation() {\n        return location;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Area#getHeight()\n     */\n    public int getHeight() {\n        return sector.getHeight();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Area#getSector()\n     */\n    public Sector getSector() {\n        assert sector != null : \"every area needs sector!\";\n        return sector;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Area#getSectorBonus(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public SectorBonus getSectorBonus(final Combatant combatant) {\n        return sector.getBonus(combatant.getCharacterClass());\n    }\n\n    /**\n     * @see java.lang.Object#hashCode()\n     */\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((location == null) ? 0 : location.hashCode());\n        return result;\n    }\n\n    /**\n     * @see java.lang.Object#equals(java.lang.Object)\n     */\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!(obj instanceof SimpleArea)) {\n            return false;\n        }\n        final SimpleArea other = (SimpleArea) obj;\n        if (location == null) {\n            if (other.location != null) {\n                return false;\n            }\n        } else if (!location.equals(other.location)) {\n            return false;\n        }\n        return true;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/model/impl/SimpleArea_1Test.java",
		"test_prompt": "// SimpleArea_1Test.java\npackage de.outstare.fortbattleplayer.model.impl;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.awt.Point;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.Sector;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleArea}.\n* It contains ten unit test cases for the {@link SimpleArea#occupy(Combatant, Area)} method.\n*/\nclass SimpleArea_1Test {"
	},
	{
		"original_code": "// SimpleArea.java\npackage de.outstare.fortbattleplayer.model.impl;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.awt.Point;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.Sector;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\n\n/**\n * A simple area which can hold one {@link Combatant}\n *\n * @author daniel\n */\npublic class SimpleArea implements Area {\n\n    private static final transient Logger LOG = Logger.getLogger(SimpleArea.class.getName());\n\n    private Combatant occupier;\n\n    private final Point location;\n\n    private final Sector sector;\n\n    /**\n     * Creates a new Area identified by the given coordinates\n     *\n     * @param x\n     * @param y\n     * @param sector\n     *            not <code>null</code>\n     */\n    public SimpleArea(final int x, final int y, final Sector sector) {\n        this(new Point(x, y), sector);\n    }\n\n    /**\n     * Creates a new Area identified by the given location\n     *\n     * @param location\n     * @param sector\n     *            not <code>null</code>\n     */\n    public SimpleArea(final Point location, final Sector sector) {\n        this.location = location;\n        this.sector = sector;\n        sector._addArea(this);\n    }\n\n    /**\n     * @see java.lang.Object#toString()\n     */\n    @Override\n    public String toString() {\n        return \"Area \" + location.x + \"/\" + location.y + \" [occupied by \" + occupier + \"]\";\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Area#free()\n     */\n    public void free() {\n        occupier = null;\n        sector.free();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Area#isOccupied()\n     */\n    public boolean isOccupied() {\n        return occupier != null;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Area#getOccupier()\n     */\n    public Combatant getOccupier() {\n        return occupier;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Area#occupy(de.outstare.fortbattleplayer.model.Combatant,\n     *      Area)\n     */\n    public Combatant occupy(final Combatant newOccupier, final Area oldPosition) {\n        Combatant oldOccupier = null;\n        // System.out.println(toString() + \" will be occupied by \" + newOccupier\n        // + \" from \" + oldPosition);\n        if (isOccupied() && !occupier.equals(newOccupier)) {\n            if (oldPosition == null) {\n                // IGNORE, because in the initial setup, multiple combatants may\n                // stay in the same area\n                // throw new IllegalStateException(\n                // \"This Area is already occupied and no Area for the current occupier was given!\");\n            } else if (oldPosition.isOccupied()) {\n                // IGNORE, for old battles with wrong start positions\n                // throw new IllegalArgumentException(toString() +\n                // \" cannot be occupied by \" + newOccupier.getName()\n                // + \" because \" + oldPosition.toString()\n                // +\n                // \" (the source Area of the occupier) is not free for the current occupier of this Area!\");\n            } else {\n                // swap places\n                // (TODO this is like a hack, but it is what The West does :-/)\n                oldOccupier = occupier;\n                LOG.fine(occupier.getName() + \" and \" + newOccupier + \" swapping positions\");\n                occupier.move(oldPosition);\n            }\n        }\n        occupier = newOccupier;\n        sector.gainControl(occupier.getSide());\n        return oldOccupier;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Area#getLocation()\n     */\n    public Point getLocation() {\n        return location;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Area#getHeight()\n     */\n    public int getHeight() {\n        return sector.getHeight();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Area#getSector()\n     */\n    public Sector getSector() {\n        assert sector != null : \"every area needs sector!\";\n        return sector;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Area#getSectorBonus(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public SectorBonus getSectorBonus(final Combatant combatant) {\n        return sector.getBonus(combatant.getCharacterClass());\n    }\n\n    /**\n     * @see java.lang.Object#hashCode()\n     */\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((location == null) ? 0 : location.hashCode());\n        return result;\n    }\n\n    /**\n     * @see java.lang.Object#equals(java.lang.Object)\n     */\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!(obj instanceof SimpleArea)) {\n            return false;\n        }\n        final SimpleArea other = (SimpleArea) obj;\n        if (location == null) {\n            if (other.location != null) {\n                return false;\n            }\n        } else if (!location.equals(other.location)) {\n            return false;\n        }\n        return true;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/model/impl/SimpleArea_2Test.java",
		"test_prompt": "// SimpleArea_2Test.java\npackage de.outstare.fortbattleplayer.model.impl;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.awt.Point;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.Sector;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleArea}.\n* It contains ten unit test cases for the {@link SimpleArea#hashCode()} method.\n*/\nclass SimpleArea_2Test {"
	},
	{
		"original_code": "// SimpleArea.java\npackage de.outstare.fortbattleplayer.model.impl;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.awt.Point;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.Sector;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\n\n/**\n * A simple area which can hold one {@link Combatant}\n *\n * @author daniel\n */\npublic class SimpleArea implements Area {\n\n    private static final transient Logger LOG = Logger.getLogger(SimpleArea.class.getName());\n\n    private Combatant occupier;\n\n    private final Point location;\n\n    private final Sector sector;\n\n    /**\n     * Creates a new Area identified by the given coordinates\n     *\n     * @param x\n     * @param y\n     * @param sector\n     *            not <code>null</code>\n     */\n    public SimpleArea(final int x, final int y, final Sector sector) {\n        this(new Point(x, y), sector);\n    }\n\n    /**\n     * Creates a new Area identified by the given location\n     *\n     * @param location\n     * @param sector\n     *            not <code>null</code>\n     */\n    public SimpleArea(final Point location, final Sector sector) {\n        this.location = location;\n        this.sector = sector;\n        sector._addArea(this);\n    }\n\n    /**\n     * @see java.lang.Object#toString()\n     */\n    @Override\n    public String toString() {\n        return \"Area \" + location.x + \"/\" + location.y + \" [occupied by \" + occupier + \"]\";\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Area#free()\n     */\n    public void free() {\n        occupier = null;\n        sector.free();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Area#isOccupied()\n     */\n    public boolean isOccupied() {\n        return occupier != null;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Area#getOccupier()\n     */\n    public Combatant getOccupier() {\n        return occupier;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Area#occupy(de.outstare.fortbattleplayer.model.Combatant,\n     *      Area)\n     */\n    public Combatant occupy(final Combatant newOccupier, final Area oldPosition) {\n        Combatant oldOccupier = null;\n        // System.out.println(toString() + \" will be occupied by \" + newOccupier\n        // + \" from \" + oldPosition);\n        if (isOccupied() && !occupier.equals(newOccupier)) {\n            if (oldPosition == null) {\n                // IGNORE, because in the initial setup, multiple combatants may\n                // stay in the same area\n                // throw new IllegalStateException(\n                // \"This Area is already occupied and no Area for the current occupier was given!\");\n            } else if (oldPosition.isOccupied()) {\n                // IGNORE, for old battles with wrong start positions\n                // throw new IllegalArgumentException(toString() +\n                // \" cannot be occupied by \" + newOccupier.getName()\n                // + \" because \" + oldPosition.toString()\n                // +\n                // \" (the source Area of the occupier) is not free for the current occupier of this Area!\");\n            } else {\n                // swap places\n                // (TODO this is like a hack, but it is what The West does :-/)\n                oldOccupier = occupier;\n                LOG.fine(occupier.getName() + \" and \" + newOccupier + \" swapping positions\");\n                occupier.move(oldPosition);\n            }\n        }\n        occupier = newOccupier;\n        sector.gainControl(occupier.getSide());\n        return oldOccupier;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Area#getLocation()\n     */\n    public Point getLocation() {\n        return location;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Area#getHeight()\n     */\n    public int getHeight() {\n        return sector.getHeight();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Area#getSector()\n     */\n    public Sector getSector() {\n        assert sector != null : \"every area needs sector!\";\n        return sector;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Area#getSectorBonus(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public SectorBonus getSectorBonus(final Combatant combatant) {\n        return sector.getBonus(combatant.getCharacterClass());\n    }\n\n    /**\n     * @see java.lang.Object#hashCode()\n     */\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((location == null) ? 0 : location.hashCode());\n        return result;\n    }\n\n    /**\n     * @see java.lang.Object#equals(java.lang.Object)\n     */\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!(obj instanceof SimpleArea)) {\n            return false;\n        }\n        final SimpleArea other = (SimpleArea) obj;\n        if (location == null) {\n            if (other.location != null) {\n                return false;\n            }\n        } else if (!location.equals(other.location)) {\n            return false;\n        }\n        return true;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/model/impl/SimpleArea_3Test.java",
		"test_prompt": "// SimpleArea_3Test.java\npackage de.outstare.fortbattleplayer.model.impl;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.awt.Point;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.Sector;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleArea}.\n* It contains ten unit test cases for the {@link SimpleArea#equals(Object)} method.\n*/\nclass SimpleArea_3Test {"
	},
	{
		"original_code": "// DamageWeaponData.java\npackage de.outstare.fortbattleplayer.model.impl;\n\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\n\n/**\n * {@link DamageWeaponData} determines {@link WeaponData} based on the damages\n * of the weapons\n *\n * @author daniel\n * @deprecated use {@link JSWeaponData} because it is much more accurate\n */\n@Deprecated\npublic class DamageWeaponData implements WeaponData {\n\n    private static final transient Logger LOG = Logger.getLogger(DamageWeaponData.class.getName());\n\n    private static final String CSV_FILE_DAMAGE_BAYONET = \"/bayonetdmg.csv\";\n\n    private static final String CSV_FILE_DAMAGE_GRAPHIT = \"/graphitdmg.csv\";\n\n    private static final String CSV_DELIMITER = \",\";\n\n    /**\n     * maps the max damage to the min damage\n     */\n    private static final Map<Integer, Set<Integer>> bayonetDamages;\n\n    /**\n     * maps the max damage to the min damage\n     */\n    private static final Map<Integer, Set<Integer>> graphitDamages;\n\n    // static constructor\n    static {\n        bayonetDamages = readCSVFile(CSV_FILE_DAMAGE_BAYONET);\n        graphitDamages = readCSVFile(CSV_FILE_DAMAGE_GRAPHIT);\n    }\n\n    /**\n     * @param filename\n     * @return\n     */\n    private static Map<Integer, Set<Integer>> readCSVFile(final String filename) {\n        final HashMap<Integer, Set<Integer>> result = new HashMap<Integer, Set<Integer>>();\n        try {\n            final InputStream fileInput = DamageWeaponData.class.getResourceAsStream(filename);\n            if (fileInput == null) {\n                throw new FileNotFoundException(filename);\n            }\n            final BufferedReader input = new BufferedReader(new InputStreamReader(fileInput));\n            try {\n                String line;\n                while ((line = input.readLine()) != null) {\n                    if (\"\".equals(line.trim())) {\n                        continue;\n                    }\n                    final String[] dmgParts = line.split(CSV_DELIMITER);\n                    assert dmgParts.length == 2 : \"csv has not 2 fields!\";\n                    final Integer minDmg = Integer.valueOf(dmgParts[0]);\n                    final Integer maxDmg = Integer.valueOf(dmgParts[1]);\n                    // map maxDmg to min\n                    if (!result.containsKey(maxDmg)) {\n                        result.put(maxDmg, new HashSet<Integer>());\n                    }\n                    result.get(maxDmg).add(minDmg);\n                }\n                LOG.fine(\"successfully read \" + result.size() + \" weapon damages from file \" + filename);\n            } finally {\n                input.close();\n                fileInput.close();\n            }\n        } catch (final FileNotFoundException e) {\n            LOG.severe(\"the CSV file with the bayonet damages was not found: \" + CSV_FILE_DAMAGE_BAYONET);\n            e.printStackTrace();\n        } catch (final IOException e) {\n            LOG.severe(\"failed to load CSV file with bayonet damages: \" + e.toString());\n            e.printStackTrace();\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#isGoldenGun(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean isGoldenGun(final Weapon weapon) {\n        assert weapon != null : \"pre condition violated: weapon != null\";\n        final Locale locale = Locale.getDefault();\n        return weapon.name().toLowerCase(locale).contains(WeaponData.GOLDEN_GUN.toLowerCase(locale));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#getGoldenGoldDmgBonus()\n     */\n    public int getGoldenGoldDmgBonus() {\n        return WeaponData.GOLDEN_GUN_DAMAGE_BONUS;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#getGoldenGoldAttBonus()\n     */\n    public int getGoldenGoldAttBonus() {\n        return WeaponData.GOLDEN_GUN_ATTACK_BONUS;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#getGoldenGoldDeffBonus()\n     */\n    public int getGoldenGoldDeffBonus() {\n        return WeaponData.GOLDEN_GUN_DEFENSE_BONUS;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasBayonet(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasBayonet(final Weapon weapon) {\n        return containsWeapon(bayonetDamages, weapon);\n    }\n\n    /**\n     * @param weapondamages\n     * @param weapon\n     * @return\n     */\n    private boolean containsWeapon(final Map<Integer, Set<Integer>> weapondamages, final Weapon weapon) {\n        final Integer weaponMaxDmg = Integer.valueOf(weapon.maxDamage());\n        final Integer weaponMinDmg = Integer.valueOf(weapon.minDamage());\n        boolean hasBajonett = false;\n        // the bayonet damages have to be distinct from the normal damages\n        if (weapondamages.containsKey(weaponMaxDmg)) {\n            final Set<Integer> minDiff = weapondamages.get(weaponMaxDmg);\n            if (minDiff.contains(weaponMinDmg)) {\n                hasBajonett = true;\n            }\n        }\n        return hasBajonett;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasGraphitLubricant(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasGraphitLubricant(final Weapon weapon) {\n        return containsWeapon(graphitDamages, weapon);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasFettesWeaponOil(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasFettesWeaponOil(final Weapon weapon) {\n        // TODO Auto-generated method stub\n        return false;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasSchmierendesWeaponOil(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasSchmierendesWeaponOil(final Weapon weapon) {\n        // TODO Auto-generated method stub\n        return false;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasShinyWeaponOil(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasShinyWeaponOil(final Weapon weapon) {\n        // TODO Auto-generated method stub\n        return false;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasLoadingchamberOrEnhancedPatrons(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasLoadingchamberOrEnhancedPatrons(final Weapon weapon) {\n        // TODO Auto-generated method stub\n        return false;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasHipFlask(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasHipFlask(final Weapon w) {\n        // TODO Auto-generated method stub\n        return false;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/model/impl/DamageWeaponData_0Test.java",
		"test_prompt": "// DamageWeaponData_0Test.java\npackage de.outstare.fortbattleplayer.model.impl;\n\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DamageWeaponData}.\n* It contains ten unit test cases for the {@link DamageWeaponData#isGoldenGun(Weapon)} method.\n*/\nclass DamageWeaponData_0Test {"
	},
	{
		"original_code": "// DamageWeaponData.java\npackage de.outstare.fortbattleplayer.model.impl;\n\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\n\n/**\n * {@link DamageWeaponData} determines {@link WeaponData} based on the damages\n * of the weapons\n *\n * @author daniel\n * @deprecated use {@link JSWeaponData} because it is much more accurate\n */\n@Deprecated\npublic class DamageWeaponData implements WeaponData {\n\n    private static final transient Logger LOG = Logger.getLogger(DamageWeaponData.class.getName());\n\n    private static final String CSV_FILE_DAMAGE_BAYONET = \"/bayonetdmg.csv\";\n\n    private static final String CSV_FILE_DAMAGE_GRAPHIT = \"/graphitdmg.csv\";\n\n    private static final String CSV_DELIMITER = \",\";\n\n    /**\n     * maps the max damage to the min damage\n     */\n    private static final Map<Integer, Set<Integer>> bayonetDamages;\n\n    /**\n     * maps the max damage to the min damage\n     */\n    private static final Map<Integer, Set<Integer>> graphitDamages;\n\n    // static constructor\n    static {\n        bayonetDamages = readCSVFile(CSV_FILE_DAMAGE_BAYONET);\n        graphitDamages = readCSVFile(CSV_FILE_DAMAGE_GRAPHIT);\n    }\n\n    /**\n     * @param filename\n     * @return\n     */\n    private static Map<Integer, Set<Integer>> readCSVFile(final String filename) {\n        final HashMap<Integer, Set<Integer>> result = new HashMap<Integer, Set<Integer>>();\n        try {\n            final InputStream fileInput = DamageWeaponData.class.getResourceAsStream(filename);\n            if (fileInput == null) {\n                throw new FileNotFoundException(filename);\n            }\n            final BufferedReader input = new BufferedReader(new InputStreamReader(fileInput));\n            try {\n                String line;\n                while ((line = input.readLine()) != null) {\n                    if (\"\".equals(line.trim())) {\n                        continue;\n                    }\n                    final String[] dmgParts = line.split(CSV_DELIMITER);\n                    assert dmgParts.length == 2 : \"csv has not 2 fields!\";\n                    final Integer minDmg = Integer.valueOf(dmgParts[0]);\n                    final Integer maxDmg = Integer.valueOf(dmgParts[1]);\n                    // map maxDmg to min\n                    if (!result.containsKey(maxDmg)) {\n                        result.put(maxDmg, new HashSet<Integer>());\n                    }\n                    result.get(maxDmg).add(minDmg);\n                }\n                LOG.fine(\"successfully read \" + result.size() + \" weapon damages from file \" + filename);\n            } finally {\n                input.close();\n                fileInput.close();\n            }\n        } catch (final FileNotFoundException e) {\n            LOG.severe(\"the CSV file with the bayonet damages was not found: \" + CSV_FILE_DAMAGE_BAYONET);\n            e.printStackTrace();\n        } catch (final IOException e) {\n            LOG.severe(\"failed to load CSV file with bayonet damages: \" + e.toString());\n            e.printStackTrace();\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#isGoldenGun(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean isGoldenGun(final Weapon weapon) {\n        assert weapon != null : \"pre condition violated: weapon != null\";\n        final Locale locale = Locale.getDefault();\n        return weapon.name().toLowerCase(locale).contains(WeaponData.GOLDEN_GUN.toLowerCase(locale));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#getGoldenGoldDmgBonus()\n     */\n    public int getGoldenGoldDmgBonus() {\n        return WeaponData.GOLDEN_GUN_DAMAGE_BONUS;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#getGoldenGoldAttBonus()\n     */\n    public int getGoldenGoldAttBonus() {\n        return WeaponData.GOLDEN_GUN_ATTACK_BONUS;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#getGoldenGoldDeffBonus()\n     */\n    public int getGoldenGoldDeffBonus() {\n        return WeaponData.GOLDEN_GUN_DEFENSE_BONUS;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasBayonet(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasBayonet(final Weapon weapon) {\n        return containsWeapon(bayonetDamages, weapon);\n    }\n\n    /**\n     * @param weapondamages\n     * @param weapon\n     * @return\n     */\n    private boolean containsWeapon(final Map<Integer, Set<Integer>> weapondamages, final Weapon weapon) {\n        final Integer weaponMaxDmg = Integer.valueOf(weapon.maxDamage());\n        final Integer weaponMinDmg = Integer.valueOf(weapon.minDamage());\n        boolean hasBajonett = false;\n        // the bayonet damages have to be distinct from the normal damages\n        if (weapondamages.containsKey(weaponMaxDmg)) {\n            final Set<Integer> minDiff = weapondamages.get(weaponMaxDmg);\n            if (minDiff.contains(weaponMinDmg)) {\n                hasBajonett = true;\n            }\n        }\n        return hasBajonett;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasGraphitLubricant(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasGraphitLubricant(final Weapon weapon) {\n        return containsWeapon(graphitDamages, weapon);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasFettesWeaponOil(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasFettesWeaponOil(final Weapon weapon) {\n        // TODO Auto-generated method stub\n        return false;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasSchmierendesWeaponOil(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasSchmierendesWeaponOil(final Weapon weapon) {\n        // TODO Auto-generated method stub\n        return false;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasShinyWeaponOil(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasShinyWeaponOil(final Weapon weapon) {\n        // TODO Auto-generated method stub\n        return false;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasLoadingchamberOrEnhancedPatrons(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasLoadingchamberOrEnhancedPatrons(final Weapon weapon) {\n        // TODO Auto-generated method stub\n        return false;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasHipFlask(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasHipFlask(final Weapon w) {\n        // TODO Auto-generated method stub\n        return false;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/model/impl/DamageWeaponData_1Test.java",
		"test_prompt": "// DamageWeaponData_1Test.java\npackage de.outstare.fortbattleplayer.model.impl;\n\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DamageWeaponData}.\n* It contains ten unit test cases for the {@link DamageWeaponData#hasBayonet(Weapon)} method.\n*/\nclass DamageWeaponData_1Test {"
	},
	{
		"original_code": "// DamageWeaponData.java\npackage de.outstare.fortbattleplayer.model.impl;\n\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\n\n/**\n * {@link DamageWeaponData} determines {@link WeaponData} based on the damages\n * of the weapons\n *\n * @author daniel\n * @deprecated use {@link JSWeaponData} because it is much more accurate\n */\n@Deprecated\npublic class DamageWeaponData implements WeaponData {\n\n    private static final transient Logger LOG = Logger.getLogger(DamageWeaponData.class.getName());\n\n    private static final String CSV_FILE_DAMAGE_BAYONET = \"/bayonetdmg.csv\";\n\n    private static final String CSV_FILE_DAMAGE_GRAPHIT = \"/graphitdmg.csv\";\n\n    private static final String CSV_DELIMITER = \",\";\n\n    /**\n     * maps the max damage to the min damage\n     */\n    private static final Map<Integer, Set<Integer>> bayonetDamages;\n\n    /**\n     * maps the max damage to the min damage\n     */\n    private static final Map<Integer, Set<Integer>> graphitDamages;\n\n    // static constructor\n    static {\n        bayonetDamages = readCSVFile(CSV_FILE_DAMAGE_BAYONET);\n        graphitDamages = readCSVFile(CSV_FILE_DAMAGE_GRAPHIT);\n    }\n\n    /**\n     * @param filename\n     * @return\n     */\n    private static Map<Integer, Set<Integer>> readCSVFile(final String filename) {\n        final HashMap<Integer, Set<Integer>> result = new HashMap<Integer, Set<Integer>>();\n        try {\n            final InputStream fileInput = DamageWeaponData.class.getResourceAsStream(filename);\n            if (fileInput == null) {\n                throw new FileNotFoundException(filename);\n            }\n            final BufferedReader input = new BufferedReader(new InputStreamReader(fileInput));\n            try {\n                String line;\n                while ((line = input.readLine()) != null) {\n                    if (\"\".equals(line.trim())) {\n                        continue;\n                    }\n                    final String[] dmgParts = line.split(CSV_DELIMITER);\n                    assert dmgParts.length == 2 : \"csv has not 2 fields!\";\n                    final Integer minDmg = Integer.valueOf(dmgParts[0]);\n                    final Integer maxDmg = Integer.valueOf(dmgParts[1]);\n                    // map maxDmg to min\n                    if (!result.containsKey(maxDmg)) {\n                        result.put(maxDmg, new HashSet<Integer>());\n                    }\n                    result.get(maxDmg).add(minDmg);\n                }\n                LOG.fine(\"successfully read \" + result.size() + \" weapon damages from file \" + filename);\n            } finally {\n                input.close();\n                fileInput.close();\n            }\n        } catch (final FileNotFoundException e) {\n            LOG.severe(\"the CSV file with the bayonet damages was not found: \" + CSV_FILE_DAMAGE_BAYONET);\n            e.printStackTrace();\n        } catch (final IOException e) {\n            LOG.severe(\"failed to load CSV file with bayonet damages: \" + e.toString());\n            e.printStackTrace();\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#isGoldenGun(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean isGoldenGun(final Weapon weapon) {\n        assert weapon != null : \"pre condition violated: weapon != null\";\n        final Locale locale = Locale.getDefault();\n        return weapon.name().toLowerCase(locale).contains(WeaponData.GOLDEN_GUN.toLowerCase(locale));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#getGoldenGoldDmgBonus()\n     */\n    public int getGoldenGoldDmgBonus() {\n        return WeaponData.GOLDEN_GUN_DAMAGE_BONUS;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#getGoldenGoldAttBonus()\n     */\n    public int getGoldenGoldAttBonus() {\n        return WeaponData.GOLDEN_GUN_ATTACK_BONUS;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#getGoldenGoldDeffBonus()\n     */\n    public int getGoldenGoldDeffBonus() {\n        return WeaponData.GOLDEN_GUN_DEFENSE_BONUS;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasBayonet(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasBayonet(final Weapon weapon) {\n        return containsWeapon(bayonetDamages, weapon);\n    }\n\n    /**\n     * @param weapondamages\n     * @param weapon\n     * @return\n     */\n    private boolean containsWeapon(final Map<Integer, Set<Integer>> weapondamages, final Weapon weapon) {\n        final Integer weaponMaxDmg = Integer.valueOf(weapon.maxDamage());\n        final Integer weaponMinDmg = Integer.valueOf(weapon.minDamage());\n        boolean hasBajonett = false;\n        // the bayonet damages have to be distinct from the normal damages\n        if (weapondamages.containsKey(weaponMaxDmg)) {\n            final Set<Integer> minDiff = weapondamages.get(weaponMaxDmg);\n            if (minDiff.contains(weaponMinDmg)) {\n                hasBajonett = true;\n            }\n        }\n        return hasBajonett;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasGraphitLubricant(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasGraphitLubricant(final Weapon weapon) {\n        return containsWeapon(graphitDamages, weapon);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasFettesWeaponOil(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasFettesWeaponOil(final Weapon weapon) {\n        // TODO Auto-generated method stub\n        return false;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasSchmierendesWeaponOil(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasSchmierendesWeaponOil(final Weapon weapon) {\n        // TODO Auto-generated method stub\n        return false;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasShinyWeaponOil(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasShinyWeaponOil(final Weapon weapon) {\n        // TODO Auto-generated method stub\n        return false;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasLoadingchamberOrEnhancedPatrons(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasLoadingchamberOrEnhancedPatrons(final Weapon weapon) {\n        // TODO Auto-generated method stub\n        return false;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasHipFlask(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasHipFlask(final Weapon w) {\n        // TODO Auto-generated method stub\n        return false;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/model/impl/DamageWeaponData_2Test.java",
		"test_prompt": "// DamageWeaponData_2Test.java\npackage de.outstare.fortbattleplayer.model.impl;\n\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DamageWeaponData}.\n* It contains ten unit test cases for the {@link DamageWeaponData#hasGraphitLubricant(Weapon)} method.\n*/\nclass DamageWeaponData_2Test {"
	},
	{
		"original_code": "// DamageWeaponData.java\npackage de.outstare.fortbattleplayer.model.impl;\n\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\n\n/**\n * {@link DamageWeaponData} determines {@link WeaponData} based on the damages\n * of the weapons\n *\n * @author daniel\n * @deprecated use {@link JSWeaponData} because it is much more accurate\n */\n@Deprecated\npublic class DamageWeaponData implements WeaponData {\n\n    private static final transient Logger LOG = Logger.getLogger(DamageWeaponData.class.getName());\n\n    private static final String CSV_FILE_DAMAGE_BAYONET = \"/bayonetdmg.csv\";\n\n    private static final String CSV_FILE_DAMAGE_GRAPHIT = \"/graphitdmg.csv\";\n\n    private static final String CSV_DELIMITER = \",\";\n\n    /**\n     * maps the max damage to the min damage\n     */\n    private static final Map<Integer, Set<Integer>> bayonetDamages;\n\n    /**\n     * maps the max damage to the min damage\n     */\n    private static final Map<Integer, Set<Integer>> graphitDamages;\n\n    // static constructor\n    static {\n        bayonetDamages = readCSVFile(CSV_FILE_DAMAGE_BAYONET);\n        graphitDamages = readCSVFile(CSV_FILE_DAMAGE_GRAPHIT);\n    }\n\n    /**\n     * @param filename\n     * @return\n     */\n    private static Map<Integer, Set<Integer>> readCSVFile(final String filename) {\n        final HashMap<Integer, Set<Integer>> result = new HashMap<Integer, Set<Integer>>();\n        try {\n            final InputStream fileInput = DamageWeaponData.class.getResourceAsStream(filename);\n            if (fileInput == null) {\n                throw new FileNotFoundException(filename);\n            }\n            final BufferedReader input = new BufferedReader(new InputStreamReader(fileInput));\n            try {\n                String line;\n                while ((line = input.readLine()) != null) {\n                    if (\"\".equals(line.trim())) {\n                        continue;\n                    }\n                    final String[] dmgParts = line.split(CSV_DELIMITER);\n                    assert dmgParts.length == 2 : \"csv has not 2 fields!\";\n                    final Integer minDmg = Integer.valueOf(dmgParts[0]);\n                    final Integer maxDmg = Integer.valueOf(dmgParts[1]);\n                    // map maxDmg to min\n                    if (!result.containsKey(maxDmg)) {\n                        result.put(maxDmg, new HashSet<Integer>());\n                    }\n                    result.get(maxDmg).add(minDmg);\n                }\n                LOG.fine(\"successfully read \" + result.size() + \" weapon damages from file \" + filename);\n            } finally {\n                input.close();\n                fileInput.close();\n            }\n        } catch (final FileNotFoundException e) {\n            LOG.severe(\"the CSV file with the bayonet damages was not found: \" + CSV_FILE_DAMAGE_BAYONET);\n            e.printStackTrace();\n        } catch (final IOException e) {\n            LOG.severe(\"failed to load CSV file with bayonet damages: \" + e.toString());\n            e.printStackTrace();\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#isGoldenGun(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean isGoldenGun(final Weapon weapon) {\n        assert weapon != null : \"pre condition violated: weapon != null\";\n        final Locale locale = Locale.getDefault();\n        return weapon.name().toLowerCase(locale).contains(WeaponData.GOLDEN_GUN.toLowerCase(locale));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#getGoldenGoldDmgBonus()\n     */\n    public int getGoldenGoldDmgBonus() {\n        return WeaponData.GOLDEN_GUN_DAMAGE_BONUS;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#getGoldenGoldAttBonus()\n     */\n    public int getGoldenGoldAttBonus() {\n        return WeaponData.GOLDEN_GUN_ATTACK_BONUS;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#getGoldenGoldDeffBonus()\n     */\n    public int getGoldenGoldDeffBonus() {\n        return WeaponData.GOLDEN_GUN_DEFENSE_BONUS;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasBayonet(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasBayonet(final Weapon weapon) {\n        return containsWeapon(bayonetDamages, weapon);\n    }\n\n    /**\n     * @param weapondamages\n     * @param weapon\n     * @return\n     */\n    private boolean containsWeapon(final Map<Integer, Set<Integer>> weapondamages, final Weapon weapon) {\n        final Integer weaponMaxDmg = Integer.valueOf(weapon.maxDamage());\n        final Integer weaponMinDmg = Integer.valueOf(weapon.minDamage());\n        boolean hasBajonett = false;\n        // the bayonet damages have to be distinct from the normal damages\n        if (weapondamages.containsKey(weaponMaxDmg)) {\n            final Set<Integer> minDiff = weapondamages.get(weaponMaxDmg);\n            if (minDiff.contains(weaponMinDmg)) {\n                hasBajonett = true;\n            }\n        }\n        return hasBajonett;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasGraphitLubricant(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasGraphitLubricant(final Weapon weapon) {\n        return containsWeapon(graphitDamages, weapon);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasFettesWeaponOil(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasFettesWeaponOil(final Weapon weapon) {\n        // TODO Auto-generated method stub\n        return false;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasSchmierendesWeaponOil(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasSchmierendesWeaponOil(final Weapon weapon) {\n        // TODO Auto-generated method stub\n        return false;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasShinyWeaponOil(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasShinyWeaponOil(final Weapon weapon) {\n        // TODO Auto-generated method stub\n        return false;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasLoadingchamberOrEnhancedPatrons(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasLoadingchamberOrEnhancedPatrons(final Weapon weapon) {\n        // TODO Auto-generated method stub\n        return false;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasHipFlask(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasHipFlask(final Weapon w) {\n        // TODO Auto-generated method stub\n        return false;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/model/impl/DamageWeaponData_3Test.java",
		"test_prompt": "// DamageWeaponData_3Test.java\npackage de.outstare.fortbattleplayer.model.impl;\n\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DamageWeaponData}.\n* It contains ten unit test cases for the {@link DamageWeaponData#hasFettesWeaponOil(Weapon)} method.\n*/\nclass DamageWeaponData_3Test {"
	},
	{
		"original_code": "// DamageWeaponData.java\npackage de.outstare.fortbattleplayer.model.impl;\n\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\n\n/**\n * {@link DamageWeaponData} determines {@link WeaponData} based on the damages\n * of the weapons\n *\n * @author daniel\n * @deprecated use {@link JSWeaponData} because it is much more accurate\n */\n@Deprecated\npublic class DamageWeaponData implements WeaponData {\n\n    private static final transient Logger LOG = Logger.getLogger(DamageWeaponData.class.getName());\n\n    private static final String CSV_FILE_DAMAGE_BAYONET = \"/bayonetdmg.csv\";\n\n    private static final String CSV_FILE_DAMAGE_GRAPHIT = \"/graphitdmg.csv\";\n\n    private static final String CSV_DELIMITER = \",\";\n\n    /**\n     * maps the max damage to the min damage\n     */\n    private static final Map<Integer, Set<Integer>> bayonetDamages;\n\n    /**\n     * maps the max damage to the min damage\n     */\n    private static final Map<Integer, Set<Integer>> graphitDamages;\n\n    // static constructor\n    static {\n        bayonetDamages = readCSVFile(CSV_FILE_DAMAGE_BAYONET);\n        graphitDamages = readCSVFile(CSV_FILE_DAMAGE_GRAPHIT);\n    }\n\n    /**\n     * @param filename\n     * @return\n     */\n    private static Map<Integer, Set<Integer>> readCSVFile(final String filename) {\n        final HashMap<Integer, Set<Integer>> result = new HashMap<Integer, Set<Integer>>();\n        try {\n            final InputStream fileInput = DamageWeaponData.class.getResourceAsStream(filename);\n            if (fileInput == null) {\n                throw new FileNotFoundException(filename);\n            }\n            final BufferedReader input = new BufferedReader(new InputStreamReader(fileInput));\n            try {\n                String line;\n                while ((line = input.readLine()) != null) {\n                    if (\"\".equals(line.trim())) {\n                        continue;\n                    }\n                    final String[] dmgParts = line.split(CSV_DELIMITER);\n                    assert dmgParts.length == 2 : \"csv has not 2 fields!\";\n                    final Integer minDmg = Integer.valueOf(dmgParts[0]);\n                    final Integer maxDmg = Integer.valueOf(dmgParts[1]);\n                    // map maxDmg to min\n                    if (!result.containsKey(maxDmg)) {\n                        result.put(maxDmg, new HashSet<Integer>());\n                    }\n                    result.get(maxDmg).add(minDmg);\n                }\n                LOG.fine(\"successfully read \" + result.size() + \" weapon damages from file \" + filename);\n            } finally {\n                input.close();\n                fileInput.close();\n            }\n        } catch (final FileNotFoundException e) {\n            LOG.severe(\"the CSV file with the bayonet damages was not found: \" + CSV_FILE_DAMAGE_BAYONET);\n            e.printStackTrace();\n        } catch (final IOException e) {\n            LOG.severe(\"failed to load CSV file with bayonet damages: \" + e.toString());\n            e.printStackTrace();\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#isGoldenGun(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean isGoldenGun(final Weapon weapon) {\n        assert weapon != null : \"pre condition violated: weapon != null\";\n        final Locale locale = Locale.getDefault();\n        return weapon.name().toLowerCase(locale).contains(WeaponData.GOLDEN_GUN.toLowerCase(locale));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#getGoldenGoldDmgBonus()\n     */\n    public int getGoldenGoldDmgBonus() {\n        return WeaponData.GOLDEN_GUN_DAMAGE_BONUS;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#getGoldenGoldAttBonus()\n     */\n    public int getGoldenGoldAttBonus() {\n        return WeaponData.GOLDEN_GUN_ATTACK_BONUS;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#getGoldenGoldDeffBonus()\n     */\n    public int getGoldenGoldDeffBonus() {\n        return WeaponData.GOLDEN_GUN_DEFENSE_BONUS;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasBayonet(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasBayonet(final Weapon weapon) {\n        return containsWeapon(bayonetDamages, weapon);\n    }\n\n    /**\n     * @param weapondamages\n     * @param weapon\n     * @return\n     */\n    private boolean containsWeapon(final Map<Integer, Set<Integer>> weapondamages, final Weapon weapon) {\n        final Integer weaponMaxDmg = Integer.valueOf(weapon.maxDamage());\n        final Integer weaponMinDmg = Integer.valueOf(weapon.minDamage());\n        boolean hasBajonett = false;\n        // the bayonet damages have to be distinct from the normal damages\n        if (weapondamages.containsKey(weaponMaxDmg)) {\n            final Set<Integer> minDiff = weapondamages.get(weaponMaxDmg);\n            if (minDiff.contains(weaponMinDmg)) {\n                hasBajonett = true;\n            }\n        }\n        return hasBajonett;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasGraphitLubricant(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasGraphitLubricant(final Weapon weapon) {\n        return containsWeapon(graphitDamages, weapon);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasFettesWeaponOil(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasFettesWeaponOil(final Weapon weapon) {\n        // TODO Auto-generated method stub\n        return false;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasSchmierendesWeaponOil(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasSchmierendesWeaponOil(final Weapon weapon) {\n        // TODO Auto-generated method stub\n        return false;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasShinyWeaponOil(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasShinyWeaponOil(final Weapon weapon) {\n        // TODO Auto-generated method stub\n        return false;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasLoadingchamberOrEnhancedPatrons(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasLoadingchamberOrEnhancedPatrons(final Weapon weapon) {\n        // TODO Auto-generated method stub\n        return false;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasHipFlask(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasHipFlask(final Weapon w) {\n        // TODO Auto-generated method stub\n        return false;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/model/impl/DamageWeaponData_4Test.java",
		"test_prompt": "// DamageWeaponData_4Test.java\npackage de.outstare.fortbattleplayer.model.impl;\n\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DamageWeaponData}.\n* It contains ten unit test cases for the {@link DamageWeaponData#hasSchmierendesWeaponOil(Weapon)} method.\n*/\nclass DamageWeaponData_4Test {"
	},
	{
		"original_code": "// DamageWeaponData.java\npackage de.outstare.fortbattleplayer.model.impl;\n\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\n\n/**\n * {@link DamageWeaponData} determines {@link WeaponData} based on the damages\n * of the weapons\n *\n * @author daniel\n * @deprecated use {@link JSWeaponData} because it is much more accurate\n */\n@Deprecated\npublic class DamageWeaponData implements WeaponData {\n\n    private static final transient Logger LOG = Logger.getLogger(DamageWeaponData.class.getName());\n\n    private static final String CSV_FILE_DAMAGE_BAYONET = \"/bayonetdmg.csv\";\n\n    private static final String CSV_FILE_DAMAGE_GRAPHIT = \"/graphitdmg.csv\";\n\n    private static final String CSV_DELIMITER = \",\";\n\n    /**\n     * maps the max damage to the min damage\n     */\n    private static final Map<Integer, Set<Integer>> bayonetDamages;\n\n    /**\n     * maps the max damage to the min damage\n     */\n    private static final Map<Integer, Set<Integer>> graphitDamages;\n\n    // static constructor\n    static {\n        bayonetDamages = readCSVFile(CSV_FILE_DAMAGE_BAYONET);\n        graphitDamages = readCSVFile(CSV_FILE_DAMAGE_GRAPHIT);\n    }\n\n    /**\n     * @param filename\n     * @return\n     */\n    private static Map<Integer, Set<Integer>> readCSVFile(final String filename) {\n        final HashMap<Integer, Set<Integer>> result = new HashMap<Integer, Set<Integer>>();\n        try {\n            final InputStream fileInput = DamageWeaponData.class.getResourceAsStream(filename);\n            if (fileInput == null) {\n                throw new FileNotFoundException(filename);\n            }\n            final BufferedReader input = new BufferedReader(new InputStreamReader(fileInput));\n            try {\n                String line;\n                while ((line = input.readLine()) != null) {\n                    if (\"\".equals(line.trim())) {\n                        continue;\n                    }\n                    final String[] dmgParts = line.split(CSV_DELIMITER);\n                    assert dmgParts.length == 2 : \"csv has not 2 fields!\";\n                    final Integer minDmg = Integer.valueOf(dmgParts[0]);\n                    final Integer maxDmg = Integer.valueOf(dmgParts[1]);\n                    // map maxDmg to min\n                    if (!result.containsKey(maxDmg)) {\n                        result.put(maxDmg, new HashSet<Integer>());\n                    }\n                    result.get(maxDmg).add(minDmg);\n                }\n                LOG.fine(\"successfully read \" + result.size() + \" weapon damages from file \" + filename);\n            } finally {\n                input.close();\n                fileInput.close();\n            }\n        } catch (final FileNotFoundException e) {\n            LOG.severe(\"the CSV file with the bayonet damages was not found: \" + CSV_FILE_DAMAGE_BAYONET);\n            e.printStackTrace();\n        } catch (final IOException e) {\n            LOG.severe(\"failed to load CSV file with bayonet damages: \" + e.toString());\n            e.printStackTrace();\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#isGoldenGun(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean isGoldenGun(final Weapon weapon) {\n        assert weapon != null : \"pre condition violated: weapon != null\";\n        final Locale locale = Locale.getDefault();\n        return weapon.name().toLowerCase(locale).contains(WeaponData.GOLDEN_GUN.toLowerCase(locale));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#getGoldenGoldDmgBonus()\n     */\n    public int getGoldenGoldDmgBonus() {\n        return WeaponData.GOLDEN_GUN_DAMAGE_BONUS;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#getGoldenGoldAttBonus()\n     */\n    public int getGoldenGoldAttBonus() {\n        return WeaponData.GOLDEN_GUN_ATTACK_BONUS;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#getGoldenGoldDeffBonus()\n     */\n    public int getGoldenGoldDeffBonus() {\n        return WeaponData.GOLDEN_GUN_DEFENSE_BONUS;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasBayonet(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasBayonet(final Weapon weapon) {\n        return containsWeapon(bayonetDamages, weapon);\n    }\n\n    /**\n     * @param weapondamages\n     * @param weapon\n     * @return\n     */\n    private boolean containsWeapon(final Map<Integer, Set<Integer>> weapondamages, final Weapon weapon) {\n        final Integer weaponMaxDmg = Integer.valueOf(weapon.maxDamage());\n        final Integer weaponMinDmg = Integer.valueOf(weapon.minDamage());\n        boolean hasBajonett = false;\n        // the bayonet damages have to be distinct from the normal damages\n        if (weapondamages.containsKey(weaponMaxDmg)) {\n            final Set<Integer> minDiff = weapondamages.get(weaponMaxDmg);\n            if (minDiff.contains(weaponMinDmg)) {\n                hasBajonett = true;\n            }\n        }\n        return hasBajonett;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasGraphitLubricant(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasGraphitLubricant(final Weapon weapon) {\n        return containsWeapon(graphitDamages, weapon);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasFettesWeaponOil(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasFettesWeaponOil(final Weapon weapon) {\n        // TODO Auto-generated method stub\n        return false;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasSchmierendesWeaponOil(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasSchmierendesWeaponOil(final Weapon weapon) {\n        // TODO Auto-generated method stub\n        return false;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasShinyWeaponOil(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasShinyWeaponOil(final Weapon weapon) {\n        // TODO Auto-generated method stub\n        return false;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasLoadingchamberOrEnhancedPatrons(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasLoadingchamberOrEnhancedPatrons(final Weapon weapon) {\n        // TODO Auto-generated method stub\n        return false;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasHipFlask(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasHipFlask(final Weapon w) {\n        // TODO Auto-generated method stub\n        return false;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/model/impl/DamageWeaponData_5Test.java",
		"test_prompt": "// DamageWeaponData_5Test.java\npackage de.outstare.fortbattleplayer.model.impl;\n\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DamageWeaponData}.\n* It contains ten unit test cases for the {@link DamageWeaponData#hasShinyWeaponOil(Weapon)} method.\n*/\nclass DamageWeaponData_5Test {"
	},
	{
		"original_code": "// DamageWeaponData.java\npackage de.outstare.fortbattleplayer.model.impl;\n\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\n\n/**\n * {@link DamageWeaponData} determines {@link WeaponData} based on the damages\n * of the weapons\n *\n * @author daniel\n * @deprecated use {@link JSWeaponData} because it is much more accurate\n */\n@Deprecated\npublic class DamageWeaponData implements WeaponData {\n\n    private static final transient Logger LOG = Logger.getLogger(DamageWeaponData.class.getName());\n\n    private static final String CSV_FILE_DAMAGE_BAYONET = \"/bayonetdmg.csv\";\n\n    private static final String CSV_FILE_DAMAGE_GRAPHIT = \"/graphitdmg.csv\";\n\n    private static final String CSV_DELIMITER = \",\";\n\n    /**\n     * maps the max damage to the min damage\n     */\n    private static final Map<Integer, Set<Integer>> bayonetDamages;\n\n    /**\n     * maps the max damage to the min damage\n     */\n    private static final Map<Integer, Set<Integer>> graphitDamages;\n\n    // static constructor\n    static {\n        bayonetDamages = readCSVFile(CSV_FILE_DAMAGE_BAYONET);\n        graphitDamages = readCSVFile(CSV_FILE_DAMAGE_GRAPHIT);\n    }\n\n    /**\n     * @param filename\n     * @return\n     */\n    private static Map<Integer, Set<Integer>> readCSVFile(final String filename) {\n        final HashMap<Integer, Set<Integer>> result = new HashMap<Integer, Set<Integer>>();\n        try {\n            final InputStream fileInput = DamageWeaponData.class.getResourceAsStream(filename);\n            if (fileInput == null) {\n                throw new FileNotFoundException(filename);\n            }\n            final BufferedReader input = new BufferedReader(new InputStreamReader(fileInput));\n            try {\n                String line;\n                while ((line = input.readLine()) != null) {\n                    if (\"\".equals(line.trim())) {\n                        continue;\n                    }\n                    final String[] dmgParts = line.split(CSV_DELIMITER);\n                    assert dmgParts.length == 2 : \"csv has not 2 fields!\";\n                    final Integer minDmg = Integer.valueOf(dmgParts[0]);\n                    final Integer maxDmg = Integer.valueOf(dmgParts[1]);\n                    // map maxDmg to min\n                    if (!result.containsKey(maxDmg)) {\n                        result.put(maxDmg, new HashSet<Integer>());\n                    }\n                    result.get(maxDmg).add(minDmg);\n                }\n                LOG.fine(\"successfully read \" + result.size() + \" weapon damages from file \" + filename);\n            } finally {\n                input.close();\n                fileInput.close();\n            }\n        } catch (final FileNotFoundException e) {\n            LOG.severe(\"the CSV file with the bayonet damages was not found: \" + CSV_FILE_DAMAGE_BAYONET);\n            e.printStackTrace();\n        } catch (final IOException e) {\n            LOG.severe(\"failed to load CSV file with bayonet damages: \" + e.toString());\n            e.printStackTrace();\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#isGoldenGun(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean isGoldenGun(final Weapon weapon) {\n        assert weapon != null : \"pre condition violated: weapon != null\";\n        final Locale locale = Locale.getDefault();\n        return weapon.name().toLowerCase(locale).contains(WeaponData.GOLDEN_GUN.toLowerCase(locale));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#getGoldenGoldDmgBonus()\n     */\n    public int getGoldenGoldDmgBonus() {\n        return WeaponData.GOLDEN_GUN_DAMAGE_BONUS;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#getGoldenGoldAttBonus()\n     */\n    public int getGoldenGoldAttBonus() {\n        return WeaponData.GOLDEN_GUN_ATTACK_BONUS;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#getGoldenGoldDeffBonus()\n     */\n    public int getGoldenGoldDeffBonus() {\n        return WeaponData.GOLDEN_GUN_DEFENSE_BONUS;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasBayonet(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasBayonet(final Weapon weapon) {\n        return containsWeapon(bayonetDamages, weapon);\n    }\n\n    /**\n     * @param weapondamages\n     * @param weapon\n     * @return\n     */\n    private boolean containsWeapon(final Map<Integer, Set<Integer>> weapondamages, final Weapon weapon) {\n        final Integer weaponMaxDmg = Integer.valueOf(weapon.maxDamage());\n        final Integer weaponMinDmg = Integer.valueOf(weapon.minDamage());\n        boolean hasBajonett = false;\n        // the bayonet damages have to be distinct from the normal damages\n        if (weapondamages.containsKey(weaponMaxDmg)) {\n            final Set<Integer> minDiff = weapondamages.get(weaponMaxDmg);\n            if (minDiff.contains(weaponMinDmg)) {\n                hasBajonett = true;\n            }\n        }\n        return hasBajonett;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasGraphitLubricant(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasGraphitLubricant(final Weapon weapon) {\n        return containsWeapon(graphitDamages, weapon);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasFettesWeaponOil(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasFettesWeaponOil(final Weapon weapon) {\n        // TODO Auto-generated method stub\n        return false;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasSchmierendesWeaponOil(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasSchmierendesWeaponOil(final Weapon weapon) {\n        // TODO Auto-generated method stub\n        return false;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasShinyWeaponOil(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasShinyWeaponOil(final Weapon weapon) {\n        // TODO Auto-generated method stub\n        return false;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasLoadingchamberOrEnhancedPatrons(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasLoadingchamberOrEnhancedPatrons(final Weapon weapon) {\n        // TODO Auto-generated method stub\n        return false;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasHipFlask(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasHipFlask(final Weapon w) {\n        // TODO Auto-generated method stub\n        return false;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/model/impl/DamageWeaponData_6Test.java",
		"test_prompt": "// DamageWeaponData_6Test.java\npackage de.outstare.fortbattleplayer.model.impl;\n\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DamageWeaponData}.\n* It contains ten unit test cases for the {@link DamageWeaponData#hasLoadingchamberOrEnhancedPatrons(Weapon)} method.\n*/\nclass DamageWeaponData_6Test {"
	},
	{
		"original_code": "// DamageWeaponData.java\npackage de.outstare.fortbattleplayer.model.impl;\n\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\n\n/**\n * {@link DamageWeaponData} determines {@link WeaponData} based on the damages\n * of the weapons\n *\n * @author daniel\n * @deprecated use {@link JSWeaponData} because it is much more accurate\n */\n@Deprecated\npublic class DamageWeaponData implements WeaponData {\n\n    private static final transient Logger LOG = Logger.getLogger(DamageWeaponData.class.getName());\n\n    private static final String CSV_FILE_DAMAGE_BAYONET = \"/bayonetdmg.csv\";\n\n    private static final String CSV_FILE_DAMAGE_GRAPHIT = \"/graphitdmg.csv\";\n\n    private static final String CSV_DELIMITER = \",\";\n\n    /**\n     * maps the max damage to the min damage\n     */\n    private static final Map<Integer, Set<Integer>> bayonetDamages;\n\n    /**\n     * maps the max damage to the min damage\n     */\n    private static final Map<Integer, Set<Integer>> graphitDamages;\n\n    // static constructor\n    static {\n        bayonetDamages = readCSVFile(CSV_FILE_DAMAGE_BAYONET);\n        graphitDamages = readCSVFile(CSV_FILE_DAMAGE_GRAPHIT);\n    }\n\n    /**\n     * @param filename\n     * @return\n     */\n    private static Map<Integer, Set<Integer>> readCSVFile(final String filename) {\n        final HashMap<Integer, Set<Integer>> result = new HashMap<Integer, Set<Integer>>();\n        try {\n            final InputStream fileInput = DamageWeaponData.class.getResourceAsStream(filename);\n            if (fileInput == null) {\n                throw new FileNotFoundException(filename);\n            }\n            final BufferedReader input = new BufferedReader(new InputStreamReader(fileInput));\n            try {\n                String line;\n                while ((line = input.readLine()) != null) {\n                    if (\"\".equals(line.trim())) {\n                        continue;\n                    }\n                    final String[] dmgParts = line.split(CSV_DELIMITER);\n                    assert dmgParts.length == 2 : \"csv has not 2 fields!\";\n                    final Integer minDmg = Integer.valueOf(dmgParts[0]);\n                    final Integer maxDmg = Integer.valueOf(dmgParts[1]);\n                    // map maxDmg to min\n                    if (!result.containsKey(maxDmg)) {\n                        result.put(maxDmg, new HashSet<Integer>());\n                    }\n                    result.get(maxDmg).add(minDmg);\n                }\n                LOG.fine(\"successfully read \" + result.size() + \" weapon damages from file \" + filename);\n            } finally {\n                input.close();\n                fileInput.close();\n            }\n        } catch (final FileNotFoundException e) {\n            LOG.severe(\"the CSV file with the bayonet damages was not found: \" + CSV_FILE_DAMAGE_BAYONET);\n            e.printStackTrace();\n        } catch (final IOException e) {\n            LOG.severe(\"failed to load CSV file with bayonet damages: \" + e.toString());\n            e.printStackTrace();\n        }\n        return result;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#isGoldenGun(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean isGoldenGun(final Weapon weapon) {\n        assert weapon != null : \"pre condition violated: weapon != null\";\n        final Locale locale = Locale.getDefault();\n        return weapon.name().toLowerCase(locale).contains(WeaponData.GOLDEN_GUN.toLowerCase(locale));\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#getGoldenGoldDmgBonus()\n     */\n    public int getGoldenGoldDmgBonus() {\n        return WeaponData.GOLDEN_GUN_DAMAGE_BONUS;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#getGoldenGoldAttBonus()\n     */\n    public int getGoldenGoldAttBonus() {\n        return WeaponData.GOLDEN_GUN_ATTACK_BONUS;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#getGoldenGoldDeffBonus()\n     */\n    public int getGoldenGoldDeffBonus() {\n        return WeaponData.GOLDEN_GUN_DEFENSE_BONUS;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasBayonet(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasBayonet(final Weapon weapon) {\n        return containsWeapon(bayonetDamages, weapon);\n    }\n\n    /**\n     * @param weapondamages\n     * @param weapon\n     * @return\n     */\n    private boolean containsWeapon(final Map<Integer, Set<Integer>> weapondamages, final Weapon weapon) {\n        final Integer weaponMaxDmg = Integer.valueOf(weapon.maxDamage());\n        final Integer weaponMinDmg = Integer.valueOf(weapon.minDamage());\n        boolean hasBajonett = false;\n        // the bayonet damages have to be distinct from the normal damages\n        if (weapondamages.containsKey(weaponMaxDmg)) {\n            final Set<Integer> minDiff = weapondamages.get(weaponMaxDmg);\n            if (minDiff.contains(weaponMinDmg)) {\n                hasBajonett = true;\n            }\n        }\n        return hasBajonett;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasGraphitLubricant(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasGraphitLubricant(final Weapon weapon) {\n        return containsWeapon(graphitDamages, weapon);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasFettesWeaponOil(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasFettesWeaponOil(final Weapon weapon) {\n        // TODO Auto-generated method stub\n        return false;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasSchmierendesWeaponOil(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasSchmierendesWeaponOil(final Weapon weapon) {\n        // TODO Auto-generated method stub\n        return false;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasShinyWeaponOil(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasShinyWeaponOil(final Weapon weapon) {\n        // TODO Auto-generated method stub\n        return false;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasLoadingchamberOrEnhancedPatrons(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasLoadingchamberOrEnhancedPatrons(final Weapon weapon) {\n        // TODO Auto-generated method stub\n        return false;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.WeaponData#hasHipFlask(de.outstare.fortbattleplayer.model.Weapon)\n     */\n    public boolean hasHipFlask(final Weapon w) {\n        // TODO Auto-generated method stub\n        return false;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/model/impl/DamageWeaponData_7Test.java",
		"test_prompt": "// DamageWeaponData_7Test.java\npackage de.outstare.fortbattleplayer.model.impl;\n\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DamageWeaponData}.\n* It contains ten unit test cases for the {@link DamageWeaponData#hasHipFlask(Weapon)} method.\n*/\nclass DamageWeaponData_7Test {"
	},
	{
		"original_code": "// SimpleCombatant.java\npackage de.outstare.fortbattleplayer.model.impl;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.CombatantState;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\n\n/**\n * A Combatant with basic attributes (position, health)\n *\n * @author daniel\n */\npublic class SimpleCombatant implements Combatant {\n\n    private static final transient Logger LOG = Logger.getLogger(SimpleCombatant.class.getName());\n\n    private final int maxHealth;\n\n    private final CombatantSide side;\n\n    private final String name;\n\n    private final String city;\n\n    private final Set<CombatantObserver> observers = new HashSet<CombatantObserver>();\n\n    private final Object stateChangeLock = new Object();\n\n    private final CharacterClass charClass;\n\n    private final Weapon weapon;\n\n    private CombatantState state;\n\n    private Combatant aimingAt = null;\n\n    /**\n     * Create a new {@link Combatant} at the given position and the given amount\n     * of health.\n     *\n     * @param side\n     *            not null\n     * @param initialState\n     *            not null\n     * @param maxHealth\n     *            > 0\n     * @param name\n     *            the name of the player of this Combatant\n     * @param characterClass\n     *            maybe null for old logs\n     * @param weapon\n     *            not null\n     * @param city\n     *            not null\n     */\n    public SimpleCombatant(final CombatantSide side, final CombatantState initialState, final int maxHealth, final String name, final CharacterClass characterClass, final Weapon weapon, final String city) {\n        assert side != null && initialState != null && weapon != null && city != null : \"parameters may not be null!\";\n        assert maxHealth > 0 : \"health must be positive!\";\n        assert maxHealth >= initialState.getHealth() && initialState.getHealth() > 0 : \"currentHealth must be inbetween 1 and max, is \" + initialState.getHealth();\n        this.side = side;\n        this.maxHealth = maxHealth;\n        this.name = name;\n        this.city = city;\n        state = initialState;\n        charClass = characterClass;\n        this.weapon = weapon;\n        // move to current location\n        state.getPosition().occupy(this, null);\n    }\n\n    /**\n     * @see java.lang.Object#toString()\n     */\n    @Override\n    public String toString() {\n        return getSide() + \" \" + name;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getName()\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getWeapon()\n     */\n    public Weapon getWeapon() {\n        return weapon;\n    }\n\n    /**\n     * internal method for graphical display\n     *\n     * @return the maximal health\n     */\n    public int _getMaxLP() {\n        return maxHealth;\n    }\n\n    /**\n     * internal method for graphical display\n     *\n     * @return the current health\n     */\n    public int _getCurrentLP() {\n        return state.getHealth();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#move(de.outstare.fortbattleplayer.model.Area)\n     */\n    public void move(final Area target) {\n        LOG.fine(name + \" moving to \" + target);\n        synchronized (stateChangeLock) {\n            final Area oldPosition = state.getPosition();\n            moveAway(oldPosition);\n            state = state.changePosition(target);\n            final Combatant swapped = target.occupy(this, oldPosition);\n            fireHasMoved();\n            if (swapped != null) {\n                fireHasSwapped(swapped);\n            }\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#shoot(de.outstare.fortbattleplayer.model.Area)\n     */\n    public void shoot(final int power) {\n        LOG.fine(name + \" shooting with \" + power);\n        aimingAt.hit(power);\n        final int sectorBonusDamage = state.getPosition().getSectorBonus(this).additionalDamage;\n        if (charClass == CharacterClass.DUELANT && power > weapon.maxDamage() + sectorBonusDamage) {\n            final double tenPercent = aimingAt._maxHealth() * 0.1;\n            if (power > weapon.minDamage() + tenPercent) {\n                fireCriticalShot(power);\n            } else {\n                LOG.fine(\"almost crit by \" + name + \": \" + power);\n            }\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#hit(int)\n     */\n    public boolean hit(final int damageAmount) {\n        LOG.fine(name + \" was hit and lost \" + damageAmount + \" health points\");\n        synchronized (stateChangeLock) {\n            final int oldHealth = state.getHealth();\n            state = state.reduceHealthBy(damageAmount);\n            fireWasHit(damageAmount, oldHealth);\n            if (state.getHealth() <= 0) {\n                moveAway(state.getPosition());\n                fireIsDead();\n            }\n            return state.getHealth() > 0;\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#aimAt(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void aimAt(final Combatant target) {\n        LOG.fine(name + \" aims at \" + target);\n        aimingAt = target;\n        fireAimingAt();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#setDestination(de.outstare.fortbattleplayer.model.Area)\n     */\n    public void setDestination(final Area destination) {\n        LOG.fine(name + \" wants to move to \" + destination);\n        synchronized (stateChangeLock) {\n            state = state.changeTarget(destination);\n            fireNewTarget();\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#addObserver(de.outstare.fortbattleplayer.model.CombatantObserver)\n     */\n    public void addObserver(final CombatantObserver observer) {\n        observers.add(observer);\n        // send current state\n        observer.hasMoved(this, state.getPosition());\n        if (aimingAt != null) {\n            observer.aimsAt(this, aimingAt);\n        }\n        if (state.getHealth() <= 0) {\n            observer.isDead(this);\n        } else {\n            observer.isAlive(this);\n        }\n        observer.isOnline(this, false);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#removeObserver(de.outstare.fortbattleplayer.model.CombatantObserver)\n     */\n    public void removeObserver(final CombatantObserver observer) {\n        observers.remove(observer);\n    }\n\n    /**\n     * notify all observers about the current position\n     */\n    protected void fireHasMoved() {\n        for (final CombatantObserver observer : observers) {\n            observer.hasMoved(this, state.getPosition());\n        }\n    }\n\n    /**\n     * notify all observers about the current position\n     *\n     * @param swappedWith\n     */\n    protected void fireHasSwapped(final Combatant swappedWith) {\n        for (final CombatantObserver observer : observers) {\n            observer.hasSwappedPosition(this, swappedWith);\n        }\n    }\n\n    /**\n     * notify all observers about the current position\n     */\n    protected void fireNewTarget() {\n        for (final CombatantObserver observer : observers) {\n            observer.newDestination(this, state.getTarget());\n        }\n    }\n\n    /**\n     * notify all observers that I shot at somebody.\n     */\n    protected void fireAimingAt() {\n        if (aimingAt != null) {\n            for (final CombatantObserver observer : observers) {\n                observer.aimsAt(this, aimingAt);\n            }\n        }\n    }\n\n    /**\n     * notify all observers about a loss of health\n     *\n     * @param damage\n     *            amount of healthpoints lost\n     * @param healthBefore\n     *            original health amount before it was decreased by\n     *            <code>damage</code>\n     */\n    protected void fireWasHit(final int damage, final int healthBefore) {\n        for (final CombatantObserver observer : observers) {\n            observer.isHit(this, damage, healthBefore);\n        }\n    }\n\n    /**\n     * notify all observers about our dead\n     */\n    protected void fireIsDead() {\n        for (final CombatantObserver observer : observers) {\n            observer.isDead(this);\n        }\n    }\n\n    /**\n     * notify all observers about our resurrection\n     */\n    protected void fireIsAlive() {\n        for (final CombatantObserver observer : observers) {\n            observer.isAlive(this);\n        }\n    }\n\n    /**\n     * notify all observers about changed online state\n     *\n     * @param changed\n     *            if the value was changed or only set\n     */\n    protected void fireOnlineChange(final boolean changed) {\n        for (final CombatantObserver observer : observers) {\n            observer.isOnline(this, changed);\n        }\n    }\n\n    /**\n     * notify all observers that i have done a critical shot\n     *\n     * @param damage\n     *            the actual caused damage\n     */\n    protected void fireCriticalShot(final int damage) {\n        for (final CombatantObserver observer : observers) {\n            observer.criticalShot(this, aimingAt, damage);\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_getLocation()\n     */\n    public Area _getLocation() {\n        return state.getPosition();\n    }\n\n    /**\n     * @return the side\n     */\n    public CombatantSide getSide() {\n        return side;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_health()\n     */\n    public int _health() {\n        return state.getHealth();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_maxHealth()\n     */\n    public int _maxHealth() {\n        return maxHealth;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_setState(de.outstare.fortbattleplayer.model.CombatantState)\n     */\n    public void _setState(final CombatantState newState) {\n        final CombatantState oldState = state;\n        // TODO maybe a PropertyChangeListener for the state\n        synchronized (stateChangeLock) {\n            state = newState;\n            // new pos has not to be null!\n            if (state.getPosition() != null) {\n                final Area oldPos = oldState.getPosition();\n                // fix for swapping:\n                // 1. go away from battlefield\n                moveAway(oldPos);\n                // 2. come from nowhere to new position (avoids swapping)\n                state.getPosition().occupy(this, null);\n                if (oldPos == null || !oldPos.equals(state.getPosition())) {\n                    fireHasMoved();\n                }\n            }\n            if (oldState.getHealth() != state.getHealth()) {\n                fireWasHit(oldState.getHealth() - state.getHealth(), oldState.getHealth());\n            }\n            if (state.getHealth() > 0 && oldState.getHealth() <= 0) {\n                fireIsAlive();\n            }\n            if (state.getHealth() <= 0 && oldState.getHealth() > 0) {\n                fireIsDead();\n            }\n            if (oldState.isGamerOnline() != state.isGamerOnline()) {\n                fireOnlineChange(true);\n            }\n            if (!oldState.getTarget().equals(state.getTarget())) {\n                fireNewTarget();\n            }\n        }\n    }\n\n    /**\n     * @param position\n     */\n    private void moveAway(final Area position) {\n        if (position != null && equals(position.getOccupier())) {\n            position.free();\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_state()\n     */\n    public CombatantState _state() {\n        return state;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#isOnline()\n     */\n    public boolean isOnline() {\n        return state.isGamerOnline();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#setOnline()\n     */\n    public void setOnline(final boolean isOnline) {\n        synchronized (stateChangeLock) {\n            final boolean changed = isOnline() != isOnline;\n            if (changed) {\n                LOG.fine(name + \" is now \" + (isOnline ? \"online\" : \"offline\"));\n                state = state.setOnline(isOnline);\n            }\n            fireOnlineChange(changed);\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getCharacterClass()\n     */\n    public CharacterClass getCharacterClass() {\n        return charClass;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getSectorBonus()\n     */\n    public SectorBonus getSectorBonus() {\n        return _getLocation().getSectorBonus(this);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getCity()\n     */\n    public String getCity() {\n        return city;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#usesBayonet()\n     */\n    public boolean usesBayonet() {\n        final WeaponData weaponData = new JSWeaponData();\n        return weaponData.hasBayonet(getWeapon());\n    }\n\n    /**\n     * @see java.lang.Object#hashCode()\n     */\n    @Override\n    public int hashCode() {\n        final int prime = 13;\n        int result = 1;\n        result = prime * result + ((name == null) ? 0 : name.hashCode());\n        result = prime * result + ((charClass == null) ? 0 : charClass.hashCode());\n        result = prime * result + ((city == null) ? 0 : city.hashCode());\n        return result;\n    }\n\n    /**\n     * @see java.lang.Object#equals(java.lang.Object)\n     */\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!(obj instanceof SimpleCombatant)) {\n            return false;\n        }\n        final SimpleCombatant other = (SimpleCombatant) obj;\n        if (name == null) {\n            if (other.name != null) {\n                return false;\n            }\n        } else if (!name.equals(other.name)) {\n            return false;\n        }\n        if (charClass != other.charClass) {\n            return false;\n        }\n        if (city == null) {\n            if (other.city != null) {\n                return false;\n            }\n        } else if (!city.equals(other.city)) {\n            return false;\n        }\n        return true;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/model/impl/SimpleCombatant_0Test.java",
		"test_prompt": "// SimpleCombatant_0Test.java\npackage de.outstare.fortbattleplayer.model.impl;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.CombatantState;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleCombatant}.\n* It contains ten unit test cases for the {@link SimpleCombatant#_getMaxLP()} method.\n*/\nclass SimpleCombatant_0Test {"
	},
	{
		"original_code": "// SimpleCombatant.java\npackage de.outstare.fortbattleplayer.model.impl;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.CombatantState;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\n\n/**\n * A Combatant with basic attributes (position, health)\n *\n * @author daniel\n */\npublic class SimpleCombatant implements Combatant {\n\n    private static final transient Logger LOG = Logger.getLogger(SimpleCombatant.class.getName());\n\n    private final int maxHealth;\n\n    private final CombatantSide side;\n\n    private final String name;\n\n    private final String city;\n\n    private final Set<CombatantObserver> observers = new HashSet<CombatantObserver>();\n\n    private final Object stateChangeLock = new Object();\n\n    private final CharacterClass charClass;\n\n    private final Weapon weapon;\n\n    private CombatantState state;\n\n    private Combatant aimingAt = null;\n\n    /**\n     * Create a new {@link Combatant} at the given position and the given amount\n     * of health.\n     *\n     * @param side\n     *            not null\n     * @param initialState\n     *            not null\n     * @param maxHealth\n     *            > 0\n     * @param name\n     *            the name of the player of this Combatant\n     * @param characterClass\n     *            maybe null for old logs\n     * @param weapon\n     *            not null\n     * @param city\n     *            not null\n     */\n    public SimpleCombatant(final CombatantSide side, final CombatantState initialState, final int maxHealth, final String name, final CharacterClass characterClass, final Weapon weapon, final String city) {\n        assert side != null && initialState != null && weapon != null && city != null : \"parameters may not be null!\";\n        assert maxHealth > 0 : \"health must be positive!\";\n        assert maxHealth >= initialState.getHealth() && initialState.getHealth() > 0 : \"currentHealth must be inbetween 1 and max, is \" + initialState.getHealth();\n        this.side = side;\n        this.maxHealth = maxHealth;\n        this.name = name;\n        this.city = city;\n        state = initialState;\n        charClass = characterClass;\n        this.weapon = weapon;\n        // move to current location\n        state.getPosition().occupy(this, null);\n    }\n\n    /**\n     * @see java.lang.Object#toString()\n     */\n    @Override\n    public String toString() {\n        return getSide() + \" \" + name;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getName()\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getWeapon()\n     */\n    public Weapon getWeapon() {\n        return weapon;\n    }\n\n    /**\n     * internal method for graphical display\n     *\n     * @return the maximal health\n     */\n    public int _getMaxLP() {\n        return maxHealth;\n    }\n\n    /**\n     * internal method for graphical display\n     *\n     * @return the current health\n     */\n    public int _getCurrentLP() {\n        return state.getHealth();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#move(de.outstare.fortbattleplayer.model.Area)\n     */\n    public void move(final Area target) {\n        LOG.fine(name + \" moving to \" + target);\n        synchronized (stateChangeLock) {\n            final Area oldPosition = state.getPosition();\n            moveAway(oldPosition);\n            state = state.changePosition(target);\n            final Combatant swapped = target.occupy(this, oldPosition);\n            fireHasMoved();\n            if (swapped != null) {\n                fireHasSwapped(swapped);\n            }\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#shoot(de.outstare.fortbattleplayer.model.Area)\n     */\n    public void shoot(final int power) {\n        LOG.fine(name + \" shooting with \" + power);\n        aimingAt.hit(power);\n        final int sectorBonusDamage = state.getPosition().getSectorBonus(this).additionalDamage;\n        if (charClass == CharacterClass.DUELANT && power > weapon.maxDamage() + sectorBonusDamage) {\n            final double tenPercent = aimingAt._maxHealth() * 0.1;\n            if (power > weapon.minDamage() + tenPercent) {\n                fireCriticalShot(power);\n            } else {\n                LOG.fine(\"almost crit by \" + name + \": \" + power);\n            }\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#hit(int)\n     */\n    public boolean hit(final int damageAmount) {\n        LOG.fine(name + \" was hit and lost \" + damageAmount + \" health points\");\n        synchronized (stateChangeLock) {\n            final int oldHealth = state.getHealth();\n            state = state.reduceHealthBy(damageAmount);\n            fireWasHit(damageAmount, oldHealth);\n            if (state.getHealth() <= 0) {\n                moveAway(state.getPosition());\n                fireIsDead();\n            }\n            return state.getHealth() > 0;\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#aimAt(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void aimAt(final Combatant target) {\n        LOG.fine(name + \" aims at \" + target);\n        aimingAt = target;\n        fireAimingAt();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#setDestination(de.outstare.fortbattleplayer.model.Area)\n     */\n    public void setDestination(final Area destination) {\n        LOG.fine(name + \" wants to move to \" + destination);\n        synchronized (stateChangeLock) {\n            state = state.changeTarget(destination);\n            fireNewTarget();\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#addObserver(de.outstare.fortbattleplayer.model.CombatantObserver)\n     */\n    public void addObserver(final CombatantObserver observer) {\n        observers.add(observer);\n        // send current state\n        observer.hasMoved(this, state.getPosition());\n        if (aimingAt != null) {\n            observer.aimsAt(this, aimingAt);\n        }\n        if (state.getHealth() <= 0) {\n            observer.isDead(this);\n        } else {\n            observer.isAlive(this);\n        }\n        observer.isOnline(this, false);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#removeObserver(de.outstare.fortbattleplayer.model.CombatantObserver)\n     */\n    public void removeObserver(final CombatantObserver observer) {\n        observers.remove(observer);\n    }\n\n    /**\n     * notify all observers about the current position\n     */\n    protected void fireHasMoved() {\n        for (final CombatantObserver observer : observers) {\n            observer.hasMoved(this, state.getPosition());\n        }\n    }\n\n    /**\n     * notify all observers about the current position\n     *\n     * @param swappedWith\n     */\n    protected void fireHasSwapped(final Combatant swappedWith) {\n        for (final CombatantObserver observer : observers) {\n            observer.hasSwappedPosition(this, swappedWith);\n        }\n    }\n\n    /**\n     * notify all observers about the current position\n     */\n    protected void fireNewTarget() {\n        for (final CombatantObserver observer : observers) {\n            observer.newDestination(this, state.getTarget());\n        }\n    }\n\n    /**\n     * notify all observers that I shot at somebody.\n     */\n    protected void fireAimingAt() {\n        if (aimingAt != null) {\n            for (final CombatantObserver observer : observers) {\n                observer.aimsAt(this, aimingAt);\n            }\n        }\n    }\n\n    /**\n     * notify all observers about a loss of health\n     *\n     * @param damage\n     *            amount of healthpoints lost\n     * @param healthBefore\n     *            original health amount before it was decreased by\n     *            <code>damage</code>\n     */\n    protected void fireWasHit(final int damage, final int healthBefore) {\n        for (final CombatantObserver observer : observers) {\n            observer.isHit(this, damage, healthBefore);\n        }\n    }\n\n    /**\n     * notify all observers about our dead\n     */\n    protected void fireIsDead() {\n        for (final CombatantObserver observer : observers) {\n            observer.isDead(this);\n        }\n    }\n\n    /**\n     * notify all observers about our resurrection\n     */\n    protected void fireIsAlive() {\n        for (final CombatantObserver observer : observers) {\n            observer.isAlive(this);\n        }\n    }\n\n    /**\n     * notify all observers about changed online state\n     *\n     * @param changed\n     *            if the value was changed or only set\n     */\n    protected void fireOnlineChange(final boolean changed) {\n        for (final CombatantObserver observer : observers) {\n            observer.isOnline(this, changed);\n        }\n    }\n\n    /**\n     * notify all observers that i have done a critical shot\n     *\n     * @param damage\n     *            the actual caused damage\n     */\n    protected void fireCriticalShot(final int damage) {\n        for (final CombatantObserver observer : observers) {\n            observer.criticalShot(this, aimingAt, damage);\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_getLocation()\n     */\n    public Area _getLocation() {\n        return state.getPosition();\n    }\n\n    /**\n     * @return the side\n     */\n    public CombatantSide getSide() {\n        return side;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_health()\n     */\n    public int _health() {\n        return state.getHealth();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_maxHealth()\n     */\n    public int _maxHealth() {\n        return maxHealth;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_setState(de.outstare.fortbattleplayer.model.CombatantState)\n     */\n    public void _setState(final CombatantState newState) {\n        final CombatantState oldState = state;\n        // TODO maybe a PropertyChangeListener for the state\n        synchronized (stateChangeLock) {\n            state = newState;\n            // new pos has not to be null!\n            if (state.getPosition() != null) {\n                final Area oldPos = oldState.getPosition();\n                // fix for swapping:\n                // 1. go away from battlefield\n                moveAway(oldPos);\n                // 2. come from nowhere to new position (avoids swapping)\n                state.getPosition().occupy(this, null);\n                if (oldPos == null || !oldPos.equals(state.getPosition())) {\n                    fireHasMoved();\n                }\n            }\n            if (oldState.getHealth() != state.getHealth()) {\n                fireWasHit(oldState.getHealth() - state.getHealth(), oldState.getHealth());\n            }\n            if (state.getHealth() > 0 && oldState.getHealth() <= 0) {\n                fireIsAlive();\n            }\n            if (state.getHealth() <= 0 && oldState.getHealth() > 0) {\n                fireIsDead();\n            }\n            if (oldState.isGamerOnline() != state.isGamerOnline()) {\n                fireOnlineChange(true);\n            }\n            if (!oldState.getTarget().equals(state.getTarget())) {\n                fireNewTarget();\n            }\n        }\n    }\n\n    /**\n     * @param position\n     */\n    private void moveAway(final Area position) {\n        if (position != null && equals(position.getOccupier())) {\n            position.free();\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_state()\n     */\n    public CombatantState _state() {\n        return state;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#isOnline()\n     */\n    public boolean isOnline() {\n        return state.isGamerOnline();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#setOnline()\n     */\n    public void setOnline(final boolean isOnline) {\n        synchronized (stateChangeLock) {\n            final boolean changed = isOnline() != isOnline;\n            if (changed) {\n                LOG.fine(name + \" is now \" + (isOnline ? \"online\" : \"offline\"));\n                state = state.setOnline(isOnline);\n            }\n            fireOnlineChange(changed);\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getCharacterClass()\n     */\n    public CharacterClass getCharacterClass() {\n        return charClass;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getSectorBonus()\n     */\n    public SectorBonus getSectorBonus() {\n        return _getLocation().getSectorBonus(this);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getCity()\n     */\n    public String getCity() {\n        return city;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#usesBayonet()\n     */\n    public boolean usesBayonet() {\n        final WeaponData weaponData = new JSWeaponData();\n        return weaponData.hasBayonet(getWeapon());\n    }\n\n    /**\n     * @see java.lang.Object#hashCode()\n     */\n    @Override\n    public int hashCode() {\n        final int prime = 13;\n        int result = 1;\n        result = prime * result + ((name == null) ? 0 : name.hashCode());\n        result = prime * result + ((charClass == null) ? 0 : charClass.hashCode());\n        result = prime * result + ((city == null) ? 0 : city.hashCode());\n        return result;\n    }\n\n    /**\n     * @see java.lang.Object#equals(java.lang.Object)\n     */\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!(obj instanceof SimpleCombatant)) {\n            return false;\n        }\n        final SimpleCombatant other = (SimpleCombatant) obj;\n        if (name == null) {\n            if (other.name != null) {\n                return false;\n            }\n        } else if (!name.equals(other.name)) {\n            return false;\n        }\n        if (charClass != other.charClass) {\n            return false;\n        }\n        if (city == null) {\n            if (other.city != null) {\n                return false;\n            }\n        } else if (!city.equals(other.city)) {\n            return false;\n        }\n        return true;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/model/impl/SimpleCombatant_1Test.java",
		"test_prompt": "// SimpleCombatant_1Test.java\npackage de.outstare.fortbattleplayer.model.impl;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.CombatantState;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleCombatant}.\n* It contains ten unit test cases for the {@link SimpleCombatant#_getCurrentLP()} method.\n*/\nclass SimpleCombatant_1Test {"
	},
	{
		"original_code": "// SimpleCombatant.java\npackage de.outstare.fortbattleplayer.model.impl;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.CombatantState;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\n\n/**\n * A Combatant with basic attributes (position, health)\n *\n * @author daniel\n */\npublic class SimpleCombatant implements Combatant {\n\n    private static final transient Logger LOG = Logger.getLogger(SimpleCombatant.class.getName());\n\n    private final int maxHealth;\n\n    private final CombatantSide side;\n\n    private final String name;\n\n    private final String city;\n\n    private final Set<CombatantObserver> observers = new HashSet<CombatantObserver>();\n\n    private final Object stateChangeLock = new Object();\n\n    private final CharacterClass charClass;\n\n    private final Weapon weapon;\n\n    private CombatantState state;\n\n    private Combatant aimingAt = null;\n\n    /**\n     * Create a new {@link Combatant} at the given position and the given amount\n     * of health.\n     *\n     * @param side\n     *            not null\n     * @param initialState\n     *            not null\n     * @param maxHealth\n     *            > 0\n     * @param name\n     *            the name of the player of this Combatant\n     * @param characterClass\n     *            maybe null for old logs\n     * @param weapon\n     *            not null\n     * @param city\n     *            not null\n     */\n    public SimpleCombatant(final CombatantSide side, final CombatantState initialState, final int maxHealth, final String name, final CharacterClass characterClass, final Weapon weapon, final String city) {\n        assert side != null && initialState != null && weapon != null && city != null : \"parameters may not be null!\";\n        assert maxHealth > 0 : \"health must be positive!\";\n        assert maxHealth >= initialState.getHealth() && initialState.getHealth() > 0 : \"currentHealth must be inbetween 1 and max, is \" + initialState.getHealth();\n        this.side = side;\n        this.maxHealth = maxHealth;\n        this.name = name;\n        this.city = city;\n        state = initialState;\n        charClass = characterClass;\n        this.weapon = weapon;\n        // move to current location\n        state.getPosition().occupy(this, null);\n    }\n\n    /**\n     * @see java.lang.Object#toString()\n     */\n    @Override\n    public String toString() {\n        return getSide() + \" \" + name;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getName()\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getWeapon()\n     */\n    public Weapon getWeapon() {\n        return weapon;\n    }\n\n    /**\n     * internal method for graphical display\n     *\n     * @return the maximal health\n     */\n    public int _getMaxLP() {\n        return maxHealth;\n    }\n\n    /**\n     * internal method for graphical display\n     *\n     * @return the current health\n     */\n    public int _getCurrentLP() {\n        return state.getHealth();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#move(de.outstare.fortbattleplayer.model.Area)\n     */\n    public void move(final Area target) {\n        LOG.fine(name + \" moving to \" + target);\n        synchronized (stateChangeLock) {\n            final Area oldPosition = state.getPosition();\n            moveAway(oldPosition);\n            state = state.changePosition(target);\n            final Combatant swapped = target.occupy(this, oldPosition);\n            fireHasMoved();\n            if (swapped != null) {\n                fireHasSwapped(swapped);\n            }\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#shoot(de.outstare.fortbattleplayer.model.Area)\n     */\n    public void shoot(final int power) {\n        LOG.fine(name + \" shooting with \" + power);\n        aimingAt.hit(power);\n        final int sectorBonusDamage = state.getPosition().getSectorBonus(this).additionalDamage;\n        if (charClass == CharacterClass.DUELANT && power > weapon.maxDamage() + sectorBonusDamage) {\n            final double tenPercent = aimingAt._maxHealth() * 0.1;\n            if (power > weapon.minDamage() + tenPercent) {\n                fireCriticalShot(power);\n            } else {\n                LOG.fine(\"almost crit by \" + name + \": \" + power);\n            }\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#hit(int)\n     */\n    public boolean hit(final int damageAmount) {\n        LOG.fine(name + \" was hit and lost \" + damageAmount + \" health points\");\n        synchronized (stateChangeLock) {\n            final int oldHealth = state.getHealth();\n            state = state.reduceHealthBy(damageAmount);\n            fireWasHit(damageAmount, oldHealth);\n            if (state.getHealth() <= 0) {\n                moveAway(state.getPosition());\n                fireIsDead();\n            }\n            return state.getHealth() > 0;\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#aimAt(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void aimAt(final Combatant target) {\n        LOG.fine(name + \" aims at \" + target);\n        aimingAt = target;\n        fireAimingAt();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#setDestination(de.outstare.fortbattleplayer.model.Area)\n     */\n    public void setDestination(final Area destination) {\n        LOG.fine(name + \" wants to move to \" + destination);\n        synchronized (stateChangeLock) {\n            state = state.changeTarget(destination);\n            fireNewTarget();\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#addObserver(de.outstare.fortbattleplayer.model.CombatantObserver)\n     */\n    public void addObserver(final CombatantObserver observer) {\n        observers.add(observer);\n        // send current state\n        observer.hasMoved(this, state.getPosition());\n        if (aimingAt != null) {\n            observer.aimsAt(this, aimingAt);\n        }\n        if (state.getHealth() <= 0) {\n            observer.isDead(this);\n        } else {\n            observer.isAlive(this);\n        }\n        observer.isOnline(this, false);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#removeObserver(de.outstare.fortbattleplayer.model.CombatantObserver)\n     */\n    public void removeObserver(final CombatantObserver observer) {\n        observers.remove(observer);\n    }\n\n    /**\n     * notify all observers about the current position\n     */\n    protected void fireHasMoved() {\n        for (final CombatantObserver observer : observers) {\n            observer.hasMoved(this, state.getPosition());\n        }\n    }\n\n    /**\n     * notify all observers about the current position\n     *\n     * @param swappedWith\n     */\n    protected void fireHasSwapped(final Combatant swappedWith) {\n        for (final CombatantObserver observer : observers) {\n            observer.hasSwappedPosition(this, swappedWith);\n        }\n    }\n\n    /**\n     * notify all observers about the current position\n     */\n    protected void fireNewTarget() {\n        for (final CombatantObserver observer : observers) {\n            observer.newDestination(this, state.getTarget());\n        }\n    }\n\n    /**\n     * notify all observers that I shot at somebody.\n     */\n    protected void fireAimingAt() {\n        if (aimingAt != null) {\n            for (final CombatantObserver observer : observers) {\n                observer.aimsAt(this, aimingAt);\n            }\n        }\n    }\n\n    /**\n     * notify all observers about a loss of health\n     *\n     * @param damage\n     *            amount of healthpoints lost\n     * @param healthBefore\n     *            original health amount before it was decreased by\n     *            <code>damage</code>\n     */\n    protected void fireWasHit(final int damage, final int healthBefore) {\n        for (final CombatantObserver observer : observers) {\n            observer.isHit(this, damage, healthBefore);\n        }\n    }\n\n    /**\n     * notify all observers about our dead\n     */\n    protected void fireIsDead() {\n        for (final CombatantObserver observer : observers) {\n            observer.isDead(this);\n        }\n    }\n\n    /**\n     * notify all observers about our resurrection\n     */\n    protected void fireIsAlive() {\n        for (final CombatantObserver observer : observers) {\n            observer.isAlive(this);\n        }\n    }\n\n    /**\n     * notify all observers about changed online state\n     *\n     * @param changed\n     *            if the value was changed or only set\n     */\n    protected void fireOnlineChange(final boolean changed) {\n        for (final CombatantObserver observer : observers) {\n            observer.isOnline(this, changed);\n        }\n    }\n\n    /**\n     * notify all observers that i have done a critical shot\n     *\n     * @param damage\n     *            the actual caused damage\n     */\n    protected void fireCriticalShot(final int damage) {\n        for (final CombatantObserver observer : observers) {\n            observer.criticalShot(this, aimingAt, damage);\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_getLocation()\n     */\n    public Area _getLocation() {\n        return state.getPosition();\n    }\n\n    /**\n     * @return the side\n     */\n    public CombatantSide getSide() {\n        return side;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_health()\n     */\n    public int _health() {\n        return state.getHealth();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_maxHealth()\n     */\n    public int _maxHealth() {\n        return maxHealth;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_setState(de.outstare.fortbattleplayer.model.CombatantState)\n     */\n    public void _setState(final CombatantState newState) {\n        final CombatantState oldState = state;\n        // TODO maybe a PropertyChangeListener for the state\n        synchronized (stateChangeLock) {\n            state = newState;\n            // new pos has not to be null!\n            if (state.getPosition() != null) {\n                final Area oldPos = oldState.getPosition();\n                // fix for swapping:\n                // 1. go away from battlefield\n                moveAway(oldPos);\n                // 2. come from nowhere to new position (avoids swapping)\n                state.getPosition().occupy(this, null);\n                if (oldPos == null || !oldPos.equals(state.getPosition())) {\n                    fireHasMoved();\n                }\n            }\n            if (oldState.getHealth() != state.getHealth()) {\n                fireWasHit(oldState.getHealth() - state.getHealth(), oldState.getHealth());\n            }\n            if (state.getHealth() > 0 && oldState.getHealth() <= 0) {\n                fireIsAlive();\n            }\n            if (state.getHealth() <= 0 && oldState.getHealth() > 0) {\n                fireIsDead();\n            }\n            if (oldState.isGamerOnline() != state.isGamerOnline()) {\n                fireOnlineChange(true);\n            }\n            if (!oldState.getTarget().equals(state.getTarget())) {\n                fireNewTarget();\n            }\n        }\n    }\n\n    /**\n     * @param position\n     */\n    private void moveAway(final Area position) {\n        if (position != null && equals(position.getOccupier())) {\n            position.free();\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_state()\n     */\n    public CombatantState _state() {\n        return state;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#isOnline()\n     */\n    public boolean isOnline() {\n        return state.isGamerOnline();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#setOnline()\n     */\n    public void setOnline(final boolean isOnline) {\n        synchronized (stateChangeLock) {\n            final boolean changed = isOnline() != isOnline;\n            if (changed) {\n                LOG.fine(name + \" is now \" + (isOnline ? \"online\" : \"offline\"));\n                state = state.setOnline(isOnline);\n            }\n            fireOnlineChange(changed);\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getCharacterClass()\n     */\n    public CharacterClass getCharacterClass() {\n        return charClass;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getSectorBonus()\n     */\n    public SectorBonus getSectorBonus() {\n        return _getLocation().getSectorBonus(this);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getCity()\n     */\n    public String getCity() {\n        return city;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#usesBayonet()\n     */\n    public boolean usesBayonet() {\n        final WeaponData weaponData = new JSWeaponData();\n        return weaponData.hasBayonet(getWeapon());\n    }\n\n    /**\n     * @see java.lang.Object#hashCode()\n     */\n    @Override\n    public int hashCode() {\n        final int prime = 13;\n        int result = 1;\n        result = prime * result + ((name == null) ? 0 : name.hashCode());\n        result = prime * result + ((charClass == null) ? 0 : charClass.hashCode());\n        result = prime * result + ((city == null) ? 0 : city.hashCode());\n        return result;\n    }\n\n    /**\n     * @see java.lang.Object#equals(java.lang.Object)\n     */\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!(obj instanceof SimpleCombatant)) {\n            return false;\n        }\n        final SimpleCombatant other = (SimpleCombatant) obj;\n        if (name == null) {\n            if (other.name != null) {\n                return false;\n            }\n        } else if (!name.equals(other.name)) {\n            return false;\n        }\n        if (charClass != other.charClass) {\n            return false;\n        }\n        if (city == null) {\n            if (other.city != null) {\n                return false;\n            }\n        } else if (!city.equals(other.city)) {\n            return false;\n        }\n        return true;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/model/impl/SimpleCombatant_2Test.java",
		"test_prompt": "// SimpleCombatant_2Test.java\npackage de.outstare.fortbattleplayer.model.impl;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.CombatantState;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleCombatant}.\n* It contains ten unit test cases for the {@link SimpleCombatant#hit(int)} method.\n*/\nclass SimpleCombatant_2Test {"
	},
	{
		"original_code": "// SimpleCombatant.java\npackage de.outstare.fortbattleplayer.model.impl;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.CombatantState;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\n\n/**\n * A Combatant with basic attributes (position, health)\n *\n * @author daniel\n */\npublic class SimpleCombatant implements Combatant {\n\n    private static final transient Logger LOG = Logger.getLogger(SimpleCombatant.class.getName());\n\n    private final int maxHealth;\n\n    private final CombatantSide side;\n\n    private final String name;\n\n    private final String city;\n\n    private final Set<CombatantObserver> observers = new HashSet<CombatantObserver>();\n\n    private final Object stateChangeLock = new Object();\n\n    private final CharacterClass charClass;\n\n    private final Weapon weapon;\n\n    private CombatantState state;\n\n    private Combatant aimingAt = null;\n\n    /**\n     * Create a new {@link Combatant} at the given position and the given amount\n     * of health.\n     *\n     * @param side\n     *            not null\n     * @param initialState\n     *            not null\n     * @param maxHealth\n     *            > 0\n     * @param name\n     *            the name of the player of this Combatant\n     * @param characterClass\n     *            maybe null for old logs\n     * @param weapon\n     *            not null\n     * @param city\n     *            not null\n     */\n    public SimpleCombatant(final CombatantSide side, final CombatantState initialState, final int maxHealth, final String name, final CharacterClass characterClass, final Weapon weapon, final String city) {\n        assert side != null && initialState != null && weapon != null && city != null : \"parameters may not be null!\";\n        assert maxHealth > 0 : \"health must be positive!\";\n        assert maxHealth >= initialState.getHealth() && initialState.getHealth() > 0 : \"currentHealth must be inbetween 1 and max, is \" + initialState.getHealth();\n        this.side = side;\n        this.maxHealth = maxHealth;\n        this.name = name;\n        this.city = city;\n        state = initialState;\n        charClass = characterClass;\n        this.weapon = weapon;\n        // move to current location\n        state.getPosition().occupy(this, null);\n    }\n\n    /**\n     * @see java.lang.Object#toString()\n     */\n    @Override\n    public String toString() {\n        return getSide() + \" \" + name;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getName()\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getWeapon()\n     */\n    public Weapon getWeapon() {\n        return weapon;\n    }\n\n    /**\n     * internal method for graphical display\n     *\n     * @return the maximal health\n     */\n    public int _getMaxLP() {\n        return maxHealth;\n    }\n\n    /**\n     * internal method for graphical display\n     *\n     * @return the current health\n     */\n    public int _getCurrentLP() {\n        return state.getHealth();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#move(de.outstare.fortbattleplayer.model.Area)\n     */\n    public void move(final Area target) {\n        LOG.fine(name + \" moving to \" + target);\n        synchronized (stateChangeLock) {\n            final Area oldPosition = state.getPosition();\n            moveAway(oldPosition);\n            state = state.changePosition(target);\n            final Combatant swapped = target.occupy(this, oldPosition);\n            fireHasMoved();\n            if (swapped != null) {\n                fireHasSwapped(swapped);\n            }\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#shoot(de.outstare.fortbattleplayer.model.Area)\n     */\n    public void shoot(final int power) {\n        LOG.fine(name + \" shooting with \" + power);\n        aimingAt.hit(power);\n        final int sectorBonusDamage = state.getPosition().getSectorBonus(this).additionalDamage;\n        if (charClass == CharacterClass.DUELANT && power > weapon.maxDamage() + sectorBonusDamage) {\n            final double tenPercent = aimingAt._maxHealth() * 0.1;\n            if (power > weapon.minDamage() + tenPercent) {\n                fireCriticalShot(power);\n            } else {\n                LOG.fine(\"almost crit by \" + name + \": \" + power);\n            }\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#hit(int)\n     */\n    public boolean hit(final int damageAmount) {\n        LOG.fine(name + \" was hit and lost \" + damageAmount + \" health points\");\n        synchronized (stateChangeLock) {\n            final int oldHealth = state.getHealth();\n            state = state.reduceHealthBy(damageAmount);\n            fireWasHit(damageAmount, oldHealth);\n            if (state.getHealth() <= 0) {\n                moveAway(state.getPosition());\n                fireIsDead();\n            }\n            return state.getHealth() > 0;\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#aimAt(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void aimAt(final Combatant target) {\n        LOG.fine(name + \" aims at \" + target);\n        aimingAt = target;\n        fireAimingAt();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#setDestination(de.outstare.fortbattleplayer.model.Area)\n     */\n    public void setDestination(final Area destination) {\n        LOG.fine(name + \" wants to move to \" + destination);\n        synchronized (stateChangeLock) {\n            state = state.changeTarget(destination);\n            fireNewTarget();\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#addObserver(de.outstare.fortbattleplayer.model.CombatantObserver)\n     */\n    public void addObserver(final CombatantObserver observer) {\n        observers.add(observer);\n        // send current state\n        observer.hasMoved(this, state.getPosition());\n        if (aimingAt != null) {\n            observer.aimsAt(this, aimingAt);\n        }\n        if (state.getHealth() <= 0) {\n            observer.isDead(this);\n        } else {\n            observer.isAlive(this);\n        }\n        observer.isOnline(this, false);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#removeObserver(de.outstare.fortbattleplayer.model.CombatantObserver)\n     */\n    public void removeObserver(final CombatantObserver observer) {\n        observers.remove(observer);\n    }\n\n    /**\n     * notify all observers about the current position\n     */\n    protected void fireHasMoved() {\n        for (final CombatantObserver observer : observers) {\n            observer.hasMoved(this, state.getPosition());\n        }\n    }\n\n    /**\n     * notify all observers about the current position\n     *\n     * @param swappedWith\n     */\n    protected void fireHasSwapped(final Combatant swappedWith) {\n        for (final CombatantObserver observer : observers) {\n            observer.hasSwappedPosition(this, swappedWith);\n        }\n    }\n\n    /**\n     * notify all observers about the current position\n     */\n    protected void fireNewTarget() {\n        for (final CombatantObserver observer : observers) {\n            observer.newDestination(this, state.getTarget());\n        }\n    }\n\n    /**\n     * notify all observers that I shot at somebody.\n     */\n    protected void fireAimingAt() {\n        if (aimingAt != null) {\n            for (final CombatantObserver observer : observers) {\n                observer.aimsAt(this, aimingAt);\n            }\n        }\n    }\n\n    /**\n     * notify all observers about a loss of health\n     *\n     * @param damage\n     *            amount of healthpoints lost\n     * @param healthBefore\n     *            original health amount before it was decreased by\n     *            <code>damage</code>\n     */\n    protected void fireWasHit(final int damage, final int healthBefore) {\n        for (final CombatantObserver observer : observers) {\n            observer.isHit(this, damage, healthBefore);\n        }\n    }\n\n    /**\n     * notify all observers about our dead\n     */\n    protected void fireIsDead() {\n        for (final CombatantObserver observer : observers) {\n            observer.isDead(this);\n        }\n    }\n\n    /**\n     * notify all observers about our resurrection\n     */\n    protected void fireIsAlive() {\n        for (final CombatantObserver observer : observers) {\n            observer.isAlive(this);\n        }\n    }\n\n    /**\n     * notify all observers about changed online state\n     *\n     * @param changed\n     *            if the value was changed or only set\n     */\n    protected void fireOnlineChange(final boolean changed) {\n        for (final CombatantObserver observer : observers) {\n            observer.isOnline(this, changed);\n        }\n    }\n\n    /**\n     * notify all observers that i have done a critical shot\n     *\n     * @param damage\n     *            the actual caused damage\n     */\n    protected void fireCriticalShot(final int damage) {\n        for (final CombatantObserver observer : observers) {\n            observer.criticalShot(this, aimingAt, damage);\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_getLocation()\n     */\n    public Area _getLocation() {\n        return state.getPosition();\n    }\n\n    /**\n     * @return the side\n     */\n    public CombatantSide getSide() {\n        return side;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_health()\n     */\n    public int _health() {\n        return state.getHealth();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_maxHealth()\n     */\n    public int _maxHealth() {\n        return maxHealth;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_setState(de.outstare.fortbattleplayer.model.CombatantState)\n     */\n    public void _setState(final CombatantState newState) {\n        final CombatantState oldState = state;\n        // TODO maybe a PropertyChangeListener for the state\n        synchronized (stateChangeLock) {\n            state = newState;\n            // new pos has not to be null!\n            if (state.getPosition() != null) {\n                final Area oldPos = oldState.getPosition();\n                // fix for swapping:\n                // 1. go away from battlefield\n                moveAway(oldPos);\n                // 2. come from nowhere to new position (avoids swapping)\n                state.getPosition().occupy(this, null);\n                if (oldPos == null || !oldPos.equals(state.getPosition())) {\n                    fireHasMoved();\n                }\n            }\n            if (oldState.getHealth() != state.getHealth()) {\n                fireWasHit(oldState.getHealth() - state.getHealth(), oldState.getHealth());\n            }\n            if (state.getHealth() > 0 && oldState.getHealth() <= 0) {\n                fireIsAlive();\n            }\n            if (state.getHealth() <= 0 && oldState.getHealth() > 0) {\n                fireIsDead();\n            }\n            if (oldState.isGamerOnline() != state.isGamerOnline()) {\n                fireOnlineChange(true);\n            }\n            if (!oldState.getTarget().equals(state.getTarget())) {\n                fireNewTarget();\n            }\n        }\n    }\n\n    /**\n     * @param position\n     */\n    private void moveAway(final Area position) {\n        if (position != null && equals(position.getOccupier())) {\n            position.free();\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_state()\n     */\n    public CombatantState _state() {\n        return state;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#isOnline()\n     */\n    public boolean isOnline() {\n        return state.isGamerOnline();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#setOnline()\n     */\n    public void setOnline(final boolean isOnline) {\n        synchronized (stateChangeLock) {\n            final boolean changed = isOnline() != isOnline;\n            if (changed) {\n                LOG.fine(name + \" is now \" + (isOnline ? \"online\" : \"offline\"));\n                state = state.setOnline(isOnline);\n            }\n            fireOnlineChange(changed);\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getCharacterClass()\n     */\n    public CharacterClass getCharacterClass() {\n        return charClass;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getSectorBonus()\n     */\n    public SectorBonus getSectorBonus() {\n        return _getLocation().getSectorBonus(this);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getCity()\n     */\n    public String getCity() {\n        return city;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#usesBayonet()\n     */\n    public boolean usesBayonet() {\n        final WeaponData weaponData = new JSWeaponData();\n        return weaponData.hasBayonet(getWeapon());\n    }\n\n    /**\n     * @see java.lang.Object#hashCode()\n     */\n    @Override\n    public int hashCode() {\n        final int prime = 13;\n        int result = 1;\n        result = prime * result + ((name == null) ? 0 : name.hashCode());\n        result = prime * result + ((charClass == null) ? 0 : charClass.hashCode());\n        result = prime * result + ((city == null) ? 0 : city.hashCode());\n        return result;\n    }\n\n    /**\n     * @see java.lang.Object#equals(java.lang.Object)\n     */\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!(obj instanceof SimpleCombatant)) {\n            return false;\n        }\n        final SimpleCombatant other = (SimpleCombatant) obj;\n        if (name == null) {\n            if (other.name != null) {\n                return false;\n            }\n        } else if (!name.equals(other.name)) {\n            return false;\n        }\n        if (charClass != other.charClass) {\n            return false;\n        }\n        if (city == null) {\n            if (other.city != null) {\n                return false;\n            }\n        } else if (!city.equals(other.city)) {\n            return false;\n        }\n        return true;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/model/impl/SimpleCombatant_3Test.java",
		"test_prompt": "// SimpleCombatant_3Test.java\npackage de.outstare.fortbattleplayer.model.impl;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.CombatantState;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleCombatant}.\n* It contains ten unit test cases for the {@link SimpleCombatant#_getLocation()} method.\n*/\nclass SimpleCombatant_3Test {"
	},
	{
		"original_code": "// SimpleCombatant.java\npackage de.outstare.fortbattleplayer.model.impl;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.CombatantState;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\n\n/**\n * A Combatant with basic attributes (position, health)\n *\n * @author daniel\n */\npublic class SimpleCombatant implements Combatant {\n\n    private static final transient Logger LOG = Logger.getLogger(SimpleCombatant.class.getName());\n\n    private final int maxHealth;\n\n    private final CombatantSide side;\n\n    private final String name;\n\n    private final String city;\n\n    private final Set<CombatantObserver> observers = new HashSet<CombatantObserver>();\n\n    private final Object stateChangeLock = new Object();\n\n    private final CharacterClass charClass;\n\n    private final Weapon weapon;\n\n    private CombatantState state;\n\n    private Combatant aimingAt = null;\n\n    /**\n     * Create a new {@link Combatant} at the given position and the given amount\n     * of health.\n     *\n     * @param side\n     *            not null\n     * @param initialState\n     *            not null\n     * @param maxHealth\n     *            > 0\n     * @param name\n     *            the name of the player of this Combatant\n     * @param characterClass\n     *            maybe null for old logs\n     * @param weapon\n     *            not null\n     * @param city\n     *            not null\n     */\n    public SimpleCombatant(final CombatantSide side, final CombatantState initialState, final int maxHealth, final String name, final CharacterClass characterClass, final Weapon weapon, final String city) {\n        assert side != null && initialState != null && weapon != null && city != null : \"parameters may not be null!\";\n        assert maxHealth > 0 : \"health must be positive!\";\n        assert maxHealth >= initialState.getHealth() && initialState.getHealth() > 0 : \"currentHealth must be inbetween 1 and max, is \" + initialState.getHealth();\n        this.side = side;\n        this.maxHealth = maxHealth;\n        this.name = name;\n        this.city = city;\n        state = initialState;\n        charClass = characterClass;\n        this.weapon = weapon;\n        // move to current location\n        state.getPosition().occupy(this, null);\n    }\n\n    /**\n     * @see java.lang.Object#toString()\n     */\n    @Override\n    public String toString() {\n        return getSide() + \" \" + name;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getName()\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getWeapon()\n     */\n    public Weapon getWeapon() {\n        return weapon;\n    }\n\n    /**\n     * internal method for graphical display\n     *\n     * @return the maximal health\n     */\n    public int _getMaxLP() {\n        return maxHealth;\n    }\n\n    /**\n     * internal method for graphical display\n     *\n     * @return the current health\n     */\n    public int _getCurrentLP() {\n        return state.getHealth();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#move(de.outstare.fortbattleplayer.model.Area)\n     */\n    public void move(final Area target) {\n        LOG.fine(name + \" moving to \" + target);\n        synchronized (stateChangeLock) {\n            final Area oldPosition = state.getPosition();\n            moveAway(oldPosition);\n            state = state.changePosition(target);\n            final Combatant swapped = target.occupy(this, oldPosition);\n            fireHasMoved();\n            if (swapped != null) {\n                fireHasSwapped(swapped);\n            }\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#shoot(de.outstare.fortbattleplayer.model.Area)\n     */\n    public void shoot(final int power) {\n        LOG.fine(name + \" shooting with \" + power);\n        aimingAt.hit(power);\n        final int sectorBonusDamage = state.getPosition().getSectorBonus(this).additionalDamage;\n        if (charClass == CharacterClass.DUELANT && power > weapon.maxDamage() + sectorBonusDamage) {\n            final double tenPercent = aimingAt._maxHealth() * 0.1;\n            if (power > weapon.minDamage() + tenPercent) {\n                fireCriticalShot(power);\n            } else {\n                LOG.fine(\"almost crit by \" + name + \": \" + power);\n            }\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#hit(int)\n     */\n    public boolean hit(final int damageAmount) {\n        LOG.fine(name + \" was hit and lost \" + damageAmount + \" health points\");\n        synchronized (stateChangeLock) {\n            final int oldHealth = state.getHealth();\n            state = state.reduceHealthBy(damageAmount);\n            fireWasHit(damageAmount, oldHealth);\n            if (state.getHealth() <= 0) {\n                moveAway(state.getPosition());\n                fireIsDead();\n            }\n            return state.getHealth() > 0;\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#aimAt(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void aimAt(final Combatant target) {\n        LOG.fine(name + \" aims at \" + target);\n        aimingAt = target;\n        fireAimingAt();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#setDestination(de.outstare.fortbattleplayer.model.Area)\n     */\n    public void setDestination(final Area destination) {\n        LOG.fine(name + \" wants to move to \" + destination);\n        synchronized (stateChangeLock) {\n            state = state.changeTarget(destination);\n            fireNewTarget();\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#addObserver(de.outstare.fortbattleplayer.model.CombatantObserver)\n     */\n    public void addObserver(final CombatantObserver observer) {\n        observers.add(observer);\n        // send current state\n        observer.hasMoved(this, state.getPosition());\n        if (aimingAt != null) {\n            observer.aimsAt(this, aimingAt);\n        }\n        if (state.getHealth() <= 0) {\n            observer.isDead(this);\n        } else {\n            observer.isAlive(this);\n        }\n        observer.isOnline(this, false);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#removeObserver(de.outstare.fortbattleplayer.model.CombatantObserver)\n     */\n    public void removeObserver(final CombatantObserver observer) {\n        observers.remove(observer);\n    }\n\n    /**\n     * notify all observers about the current position\n     */\n    protected void fireHasMoved() {\n        for (final CombatantObserver observer : observers) {\n            observer.hasMoved(this, state.getPosition());\n        }\n    }\n\n    /**\n     * notify all observers about the current position\n     *\n     * @param swappedWith\n     */\n    protected void fireHasSwapped(final Combatant swappedWith) {\n        for (final CombatantObserver observer : observers) {\n            observer.hasSwappedPosition(this, swappedWith);\n        }\n    }\n\n    /**\n     * notify all observers about the current position\n     */\n    protected void fireNewTarget() {\n        for (final CombatantObserver observer : observers) {\n            observer.newDestination(this, state.getTarget());\n        }\n    }\n\n    /**\n     * notify all observers that I shot at somebody.\n     */\n    protected void fireAimingAt() {\n        if (aimingAt != null) {\n            for (final CombatantObserver observer : observers) {\n                observer.aimsAt(this, aimingAt);\n            }\n        }\n    }\n\n    /**\n     * notify all observers about a loss of health\n     *\n     * @param damage\n     *            amount of healthpoints lost\n     * @param healthBefore\n     *            original health amount before it was decreased by\n     *            <code>damage</code>\n     */\n    protected void fireWasHit(final int damage, final int healthBefore) {\n        for (final CombatantObserver observer : observers) {\n            observer.isHit(this, damage, healthBefore);\n        }\n    }\n\n    /**\n     * notify all observers about our dead\n     */\n    protected void fireIsDead() {\n        for (final CombatantObserver observer : observers) {\n            observer.isDead(this);\n        }\n    }\n\n    /**\n     * notify all observers about our resurrection\n     */\n    protected void fireIsAlive() {\n        for (final CombatantObserver observer : observers) {\n            observer.isAlive(this);\n        }\n    }\n\n    /**\n     * notify all observers about changed online state\n     *\n     * @param changed\n     *            if the value was changed or only set\n     */\n    protected void fireOnlineChange(final boolean changed) {\n        for (final CombatantObserver observer : observers) {\n            observer.isOnline(this, changed);\n        }\n    }\n\n    /**\n     * notify all observers that i have done a critical shot\n     *\n     * @param damage\n     *            the actual caused damage\n     */\n    protected void fireCriticalShot(final int damage) {\n        for (final CombatantObserver observer : observers) {\n            observer.criticalShot(this, aimingAt, damage);\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_getLocation()\n     */\n    public Area _getLocation() {\n        return state.getPosition();\n    }\n\n    /**\n     * @return the side\n     */\n    public CombatantSide getSide() {\n        return side;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_health()\n     */\n    public int _health() {\n        return state.getHealth();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_maxHealth()\n     */\n    public int _maxHealth() {\n        return maxHealth;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_setState(de.outstare.fortbattleplayer.model.CombatantState)\n     */\n    public void _setState(final CombatantState newState) {\n        final CombatantState oldState = state;\n        // TODO maybe a PropertyChangeListener for the state\n        synchronized (stateChangeLock) {\n            state = newState;\n            // new pos has not to be null!\n            if (state.getPosition() != null) {\n                final Area oldPos = oldState.getPosition();\n                // fix for swapping:\n                // 1. go away from battlefield\n                moveAway(oldPos);\n                // 2. come from nowhere to new position (avoids swapping)\n                state.getPosition().occupy(this, null);\n                if (oldPos == null || !oldPos.equals(state.getPosition())) {\n                    fireHasMoved();\n                }\n            }\n            if (oldState.getHealth() != state.getHealth()) {\n                fireWasHit(oldState.getHealth() - state.getHealth(), oldState.getHealth());\n            }\n            if (state.getHealth() > 0 && oldState.getHealth() <= 0) {\n                fireIsAlive();\n            }\n            if (state.getHealth() <= 0 && oldState.getHealth() > 0) {\n                fireIsDead();\n            }\n            if (oldState.isGamerOnline() != state.isGamerOnline()) {\n                fireOnlineChange(true);\n            }\n            if (!oldState.getTarget().equals(state.getTarget())) {\n                fireNewTarget();\n            }\n        }\n    }\n\n    /**\n     * @param position\n     */\n    private void moveAway(final Area position) {\n        if (position != null && equals(position.getOccupier())) {\n            position.free();\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_state()\n     */\n    public CombatantState _state() {\n        return state;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#isOnline()\n     */\n    public boolean isOnline() {\n        return state.isGamerOnline();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#setOnline()\n     */\n    public void setOnline(final boolean isOnline) {\n        synchronized (stateChangeLock) {\n            final boolean changed = isOnline() != isOnline;\n            if (changed) {\n                LOG.fine(name + \" is now \" + (isOnline ? \"online\" : \"offline\"));\n                state = state.setOnline(isOnline);\n            }\n            fireOnlineChange(changed);\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getCharacterClass()\n     */\n    public CharacterClass getCharacterClass() {\n        return charClass;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getSectorBonus()\n     */\n    public SectorBonus getSectorBonus() {\n        return _getLocation().getSectorBonus(this);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getCity()\n     */\n    public String getCity() {\n        return city;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#usesBayonet()\n     */\n    public boolean usesBayonet() {\n        final WeaponData weaponData = new JSWeaponData();\n        return weaponData.hasBayonet(getWeapon());\n    }\n\n    /**\n     * @see java.lang.Object#hashCode()\n     */\n    @Override\n    public int hashCode() {\n        final int prime = 13;\n        int result = 1;\n        result = prime * result + ((name == null) ? 0 : name.hashCode());\n        result = prime * result + ((charClass == null) ? 0 : charClass.hashCode());\n        result = prime * result + ((city == null) ? 0 : city.hashCode());\n        return result;\n    }\n\n    /**\n     * @see java.lang.Object#equals(java.lang.Object)\n     */\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!(obj instanceof SimpleCombatant)) {\n            return false;\n        }\n        final SimpleCombatant other = (SimpleCombatant) obj;\n        if (name == null) {\n            if (other.name != null) {\n                return false;\n            }\n        } else if (!name.equals(other.name)) {\n            return false;\n        }\n        if (charClass != other.charClass) {\n            return false;\n        }\n        if (city == null) {\n            if (other.city != null) {\n                return false;\n            }\n        } else if (!city.equals(other.city)) {\n            return false;\n        }\n        return true;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/model/impl/SimpleCombatant_4Test.java",
		"test_prompt": "// SimpleCombatant_4Test.java\npackage de.outstare.fortbattleplayer.model.impl;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.CombatantState;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleCombatant}.\n* It contains ten unit test cases for the {@link SimpleCombatant#_health()} method.\n*/\nclass SimpleCombatant_4Test {"
	},
	{
		"original_code": "// SimpleCombatant.java\npackage de.outstare.fortbattleplayer.model.impl;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.CombatantState;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\n\n/**\n * A Combatant with basic attributes (position, health)\n *\n * @author daniel\n */\npublic class SimpleCombatant implements Combatant {\n\n    private static final transient Logger LOG = Logger.getLogger(SimpleCombatant.class.getName());\n\n    private final int maxHealth;\n\n    private final CombatantSide side;\n\n    private final String name;\n\n    private final String city;\n\n    private final Set<CombatantObserver> observers = new HashSet<CombatantObserver>();\n\n    private final Object stateChangeLock = new Object();\n\n    private final CharacterClass charClass;\n\n    private final Weapon weapon;\n\n    private CombatantState state;\n\n    private Combatant aimingAt = null;\n\n    /**\n     * Create a new {@link Combatant} at the given position and the given amount\n     * of health.\n     *\n     * @param side\n     *            not null\n     * @param initialState\n     *            not null\n     * @param maxHealth\n     *            > 0\n     * @param name\n     *            the name of the player of this Combatant\n     * @param characterClass\n     *            maybe null for old logs\n     * @param weapon\n     *            not null\n     * @param city\n     *            not null\n     */\n    public SimpleCombatant(final CombatantSide side, final CombatantState initialState, final int maxHealth, final String name, final CharacterClass characterClass, final Weapon weapon, final String city) {\n        assert side != null && initialState != null && weapon != null && city != null : \"parameters may not be null!\";\n        assert maxHealth > 0 : \"health must be positive!\";\n        assert maxHealth >= initialState.getHealth() && initialState.getHealth() > 0 : \"currentHealth must be inbetween 1 and max, is \" + initialState.getHealth();\n        this.side = side;\n        this.maxHealth = maxHealth;\n        this.name = name;\n        this.city = city;\n        state = initialState;\n        charClass = characterClass;\n        this.weapon = weapon;\n        // move to current location\n        state.getPosition().occupy(this, null);\n    }\n\n    /**\n     * @see java.lang.Object#toString()\n     */\n    @Override\n    public String toString() {\n        return getSide() + \" \" + name;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getName()\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getWeapon()\n     */\n    public Weapon getWeapon() {\n        return weapon;\n    }\n\n    /**\n     * internal method for graphical display\n     *\n     * @return the maximal health\n     */\n    public int _getMaxLP() {\n        return maxHealth;\n    }\n\n    /**\n     * internal method for graphical display\n     *\n     * @return the current health\n     */\n    public int _getCurrentLP() {\n        return state.getHealth();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#move(de.outstare.fortbattleplayer.model.Area)\n     */\n    public void move(final Area target) {\n        LOG.fine(name + \" moving to \" + target);\n        synchronized (stateChangeLock) {\n            final Area oldPosition = state.getPosition();\n            moveAway(oldPosition);\n            state = state.changePosition(target);\n            final Combatant swapped = target.occupy(this, oldPosition);\n            fireHasMoved();\n            if (swapped != null) {\n                fireHasSwapped(swapped);\n            }\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#shoot(de.outstare.fortbattleplayer.model.Area)\n     */\n    public void shoot(final int power) {\n        LOG.fine(name + \" shooting with \" + power);\n        aimingAt.hit(power);\n        final int sectorBonusDamage = state.getPosition().getSectorBonus(this).additionalDamage;\n        if (charClass == CharacterClass.DUELANT && power > weapon.maxDamage() + sectorBonusDamage) {\n            final double tenPercent = aimingAt._maxHealth() * 0.1;\n            if (power > weapon.minDamage() + tenPercent) {\n                fireCriticalShot(power);\n            } else {\n                LOG.fine(\"almost crit by \" + name + \": \" + power);\n            }\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#hit(int)\n     */\n    public boolean hit(final int damageAmount) {\n        LOG.fine(name + \" was hit and lost \" + damageAmount + \" health points\");\n        synchronized (stateChangeLock) {\n            final int oldHealth = state.getHealth();\n            state = state.reduceHealthBy(damageAmount);\n            fireWasHit(damageAmount, oldHealth);\n            if (state.getHealth() <= 0) {\n                moveAway(state.getPosition());\n                fireIsDead();\n            }\n            return state.getHealth() > 0;\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#aimAt(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void aimAt(final Combatant target) {\n        LOG.fine(name + \" aims at \" + target);\n        aimingAt = target;\n        fireAimingAt();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#setDestination(de.outstare.fortbattleplayer.model.Area)\n     */\n    public void setDestination(final Area destination) {\n        LOG.fine(name + \" wants to move to \" + destination);\n        synchronized (stateChangeLock) {\n            state = state.changeTarget(destination);\n            fireNewTarget();\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#addObserver(de.outstare.fortbattleplayer.model.CombatantObserver)\n     */\n    public void addObserver(final CombatantObserver observer) {\n        observers.add(observer);\n        // send current state\n        observer.hasMoved(this, state.getPosition());\n        if (aimingAt != null) {\n            observer.aimsAt(this, aimingAt);\n        }\n        if (state.getHealth() <= 0) {\n            observer.isDead(this);\n        } else {\n            observer.isAlive(this);\n        }\n        observer.isOnline(this, false);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#removeObserver(de.outstare.fortbattleplayer.model.CombatantObserver)\n     */\n    public void removeObserver(final CombatantObserver observer) {\n        observers.remove(observer);\n    }\n\n    /**\n     * notify all observers about the current position\n     */\n    protected void fireHasMoved() {\n        for (final CombatantObserver observer : observers) {\n            observer.hasMoved(this, state.getPosition());\n        }\n    }\n\n    /**\n     * notify all observers about the current position\n     *\n     * @param swappedWith\n     */\n    protected void fireHasSwapped(final Combatant swappedWith) {\n        for (final CombatantObserver observer : observers) {\n            observer.hasSwappedPosition(this, swappedWith);\n        }\n    }\n\n    /**\n     * notify all observers about the current position\n     */\n    protected void fireNewTarget() {\n        for (final CombatantObserver observer : observers) {\n            observer.newDestination(this, state.getTarget());\n        }\n    }\n\n    /**\n     * notify all observers that I shot at somebody.\n     */\n    protected void fireAimingAt() {\n        if (aimingAt != null) {\n            for (final CombatantObserver observer : observers) {\n                observer.aimsAt(this, aimingAt);\n            }\n        }\n    }\n\n    /**\n     * notify all observers about a loss of health\n     *\n     * @param damage\n     *            amount of healthpoints lost\n     * @param healthBefore\n     *            original health amount before it was decreased by\n     *            <code>damage</code>\n     */\n    protected void fireWasHit(final int damage, final int healthBefore) {\n        for (final CombatantObserver observer : observers) {\n            observer.isHit(this, damage, healthBefore);\n        }\n    }\n\n    /**\n     * notify all observers about our dead\n     */\n    protected void fireIsDead() {\n        for (final CombatantObserver observer : observers) {\n            observer.isDead(this);\n        }\n    }\n\n    /**\n     * notify all observers about our resurrection\n     */\n    protected void fireIsAlive() {\n        for (final CombatantObserver observer : observers) {\n            observer.isAlive(this);\n        }\n    }\n\n    /**\n     * notify all observers about changed online state\n     *\n     * @param changed\n     *            if the value was changed or only set\n     */\n    protected void fireOnlineChange(final boolean changed) {\n        for (final CombatantObserver observer : observers) {\n            observer.isOnline(this, changed);\n        }\n    }\n\n    /**\n     * notify all observers that i have done a critical shot\n     *\n     * @param damage\n     *            the actual caused damage\n     */\n    protected void fireCriticalShot(final int damage) {\n        for (final CombatantObserver observer : observers) {\n            observer.criticalShot(this, aimingAt, damage);\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_getLocation()\n     */\n    public Area _getLocation() {\n        return state.getPosition();\n    }\n\n    /**\n     * @return the side\n     */\n    public CombatantSide getSide() {\n        return side;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_health()\n     */\n    public int _health() {\n        return state.getHealth();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_maxHealth()\n     */\n    public int _maxHealth() {\n        return maxHealth;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_setState(de.outstare.fortbattleplayer.model.CombatantState)\n     */\n    public void _setState(final CombatantState newState) {\n        final CombatantState oldState = state;\n        // TODO maybe a PropertyChangeListener for the state\n        synchronized (stateChangeLock) {\n            state = newState;\n            // new pos has not to be null!\n            if (state.getPosition() != null) {\n                final Area oldPos = oldState.getPosition();\n                // fix for swapping:\n                // 1. go away from battlefield\n                moveAway(oldPos);\n                // 2. come from nowhere to new position (avoids swapping)\n                state.getPosition().occupy(this, null);\n                if (oldPos == null || !oldPos.equals(state.getPosition())) {\n                    fireHasMoved();\n                }\n            }\n            if (oldState.getHealth() != state.getHealth()) {\n                fireWasHit(oldState.getHealth() - state.getHealth(), oldState.getHealth());\n            }\n            if (state.getHealth() > 0 && oldState.getHealth() <= 0) {\n                fireIsAlive();\n            }\n            if (state.getHealth() <= 0 && oldState.getHealth() > 0) {\n                fireIsDead();\n            }\n            if (oldState.isGamerOnline() != state.isGamerOnline()) {\n                fireOnlineChange(true);\n            }\n            if (!oldState.getTarget().equals(state.getTarget())) {\n                fireNewTarget();\n            }\n        }\n    }\n\n    /**\n     * @param position\n     */\n    private void moveAway(final Area position) {\n        if (position != null && equals(position.getOccupier())) {\n            position.free();\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_state()\n     */\n    public CombatantState _state() {\n        return state;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#isOnline()\n     */\n    public boolean isOnline() {\n        return state.isGamerOnline();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#setOnline()\n     */\n    public void setOnline(final boolean isOnline) {\n        synchronized (stateChangeLock) {\n            final boolean changed = isOnline() != isOnline;\n            if (changed) {\n                LOG.fine(name + \" is now \" + (isOnline ? \"online\" : \"offline\"));\n                state = state.setOnline(isOnline);\n            }\n            fireOnlineChange(changed);\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getCharacterClass()\n     */\n    public CharacterClass getCharacterClass() {\n        return charClass;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getSectorBonus()\n     */\n    public SectorBonus getSectorBonus() {\n        return _getLocation().getSectorBonus(this);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getCity()\n     */\n    public String getCity() {\n        return city;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#usesBayonet()\n     */\n    public boolean usesBayonet() {\n        final WeaponData weaponData = new JSWeaponData();\n        return weaponData.hasBayonet(getWeapon());\n    }\n\n    /**\n     * @see java.lang.Object#hashCode()\n     */\n    @Override\n    public int hashCode() {\n        final int prime = 13;\n        int result = 1;\n        result = prime * result + ((name == null) ? 0 : name.hashCode());\n        result = prime * result + ((charClass == null) ? 0 : charClass.hashCode());\n        result = prime * result + ((city == null) ? 0 : city.hashCode());\n        return result;\n    }\n\n    /**\n     * @see java.lang.Object#equals(java.lang.Object)\n     */\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!(obj instanceof SimpleCombatant)) {\n            return false;\n        }\n        final SimpleCombatant other = (SimpleCombatant) obj;\n        if (name == null) {\n            if (other.name != null) {\n                return false;\n            }\n        } else if (!name.equals(other.name)) {\n            return false;\n        }\n        if (charClass != other.charClass) {\n            return false;\n        }\n        if (city == null) {\n            if (other.city != null) {\n                return false;\n            }\n        } else if (!city.equals(other.city)) {\n            return false;\n        }\n        return true;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/model/impl/SimpleCombatant_5Test.java",
		"test_prompt": "// SimpleCombatant_5Test.java\npackage de.outstare.fortbattleplayer.model.impl;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.CombatantState;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleCombatant}.\n* It contains ten unit test cases for the {@link SimpleCombatant#_maxHealth()} method.\n*/\nclass SimpleCombatant_5Test {"
	},
	{
		"original_code": "// SimpleCombatant.java\npackage de.outstare.fortbattleplayer.model.impl;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.CombatantState;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\n\n/**\n * A Combatant with basic attributes (position, health)\n *\n * @author daniel\n */\npublic class SimpleCombatant implements Combatant {\n\n    private static final transient Logger LOG = Logger.getLogger(SimpleCombatant.class.getName());\n\n    private final int maxHealth;\n\n    private final CombatantSide side;\n\n    private final String name;\n\n    private final String city;\n\n    private final Set<CombatantObserver> observers = new HashSet<CombatantObserver>();\n\n    private final Object stateChangeLock = new Object();\n\n    private final CharacterClass charClass;\n\n    private final Weapon weapon;\n\n    private CombatantState state;\n\n    private Combatant aimingAt = null;\n\n    /**\n     * Create a new {@link Combatant} at the given position and the given amount\n     * of health.\n     *\n     * @param side\n     *            not null\n     * @param initialState\n     *            not null\n     * @param maxHealth\n     *            > 0\n     * @param name\n     *            the name of the player of this Combatant\n     * @param characterClass\n     *            maybe null for old logs\n     * @param weapon\n     *            not null\n     * @param city\n     *            not null\n     */\n    public SimpleCombatant(final CombatantSide side, final CombatantState initialState, final int maxHealth, final String name, final CharacterClass characterClass, final Weapon weapon, final String city) {\n        assert side != null && initialState != null && weapon != null && city != null : \"parameters may not be null!\";\n        assert maxHealth > 0 : \"health must be positive!\";\n        assert maxHealth >= initialState.getHealth() && initialState.getHealth() > 0 : \"currentHealth must be inbetween 1 and max, is \" + initialState.getHealth();\n        this.side = side;\n        this.maxHealth = maxHealth;\n        this.name = name;\n        this.city = city;\n        state = initialState;\n        charClass = characterClass;\n        this.weapon = weapon;\n        // move to current location\n        state.getPosition().occupy(this, null);\n    }\n\n    /**\n     * @see java.lang.Object#toString()\n     */\n    @Override\n    public String toString() {\n        return getSide() + \" \" + name;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getName()\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getWeapon()\n     */\n    public Weapon getWeapon() {\n        return weapon;\n    }\n\n    /**\n     * internal method for graphical display\n     *\n     * @return the maximal health\n     */\n    public int _getMaxLP() {\n        return maxHealth;\n    }\n\n    /**\n     * internal method for graphical display\n     *\n     * @return the current health\n     */\n    public int _getCurrentLP() {\n        return state.getHealth();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#move(de.outstare.fortbattleplayer.model.Area)\n     */\n    public void move(final Area target) {\n        LOG.fine(name + \" moving to \" + target);\n        synchronized (stateChangeLock) {\n            final Area oldPosition = state.getPosition();\n            moveAway(oldPosition);\n            state = state.changePosition(target);\n            final Combatant swapped = target.occupy(this, oldPosition);\n            fireHasMoved();\n            if (swapped != null) {\n                fireHasSwapped(swapped);\n            }\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#shoot(de.outstare.fortbattleplayer.model.Area)\n     */\n    public void shoot(final int power) {\n        LOG.fine(name + \" shooting with \" + power);\n        aimingAt.hit(power);\n        final int sectorBonusDamage = state.getPosition().getSectorBonus(this).additionalDamage;\n        if (charClass == CharacterClass.DUELANT && power > weapon.maxDamage() + sectorBonusDamage) {\n            final double tenPercent = aimingAt._maxHealth() * 0.1;\n            if (power > weapon.minDamage() + tenPercent) {\n                fireCriticalShot(power);\n            } else {\n                LOG.fine(\"almost crit by \" + name + \": \" + power);\n            }\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#hit(int)\n     */\n    public boolean hit(final int damageAmount) {\n        LOG.fine(name + \" was hit and lost \" + damageAmount + \" health points\");\n        synchronized (stateChangeLock) {\n            final int oldHealth = state.getHealth();\n            state = state.reduceHealthBy(damageAmount);\n            fireWasHit(damageAmount, oldHealth);\n            if (state.getHealth() <= 0) {\n                moveAway(state.getPosition());\n                fireIsDead();\n            }\n            return state.getHealth() > 0;\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#aimAt(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void aimAt(final Combatant target) {\n        LOG.fine(name + \" aims at \" + target);\n        aimingAt = target;\n        fireAimingAt();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#setDestination(de.outstare.fortbattleplayer.model.Area)\n     */\n    public void setDestination(final Area destination) {\n        LOG.fine(name + \" wants to move to \" + destination);\n        synchronized (stateChangeLock) {\n            state = state.changeTarget(destination);\n            fireNewTarget();\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#addObserver(de.outstare.fortbattleplayer.model.CombatantObserver)\n     */\n    public void addObserver(final CombatantObserver observer) {\n        observers.add(observer);\n        // send current state\n        observer.hasMoved(this, state.getPosition());\n        if (aimingAt != null) {\n            observer.aimsAt(this, aimingAt);\n        }\n        if (state.getHealth() <= 0) {\n            observer.isDead(this);\n        } else {\n            observer.isAlive(this);\n        }\n        observer.isOnline(this, false);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#removeObserver(de.outstare.fortbattleplayer.model.CombatantObserver)\n     */\n    public void removeObserver(final CombatantObserver observer) {\n        observers.remove(observer);\n    }\n\n    /**\n     * notify all observers about the current position\n     */\n    protected void fireHasMoved() {\n        for (final CombatantObserver observer : observers) {\n            observer.hasMoved(this, state.getPosition());\n        }\n    }\n\n    /**\n     * notify all observers about the current position\n     *\n     * @param swappedWith\n     */\n    protected void fireHasSwapped(final Combatant swappedWith) {\n        for (final CombatantObserver observer : observers) {\n            observer.hasSwappedPosition(this, swappedWith);\n        }\n    }\n\n    /**\n     * notify all observers about the current position\n     */\n    protected void fireNewTarget() {\n        for (final CombatantObserver observer : observers) {\n            observer.newDestination(this, state.getTarget());\n        }\n    }\n\n    /**\n     * notify all observers that I shot at somebody.\n     */\n    protected void fireAimingAt() {\n        if (aimingAt != null) {\n            for (final CombatantObserver observer : observers) {\n                observer.aimsAt(this, aimingAt);\n            }\n        }\n    }\n\n    /**\n     * notify all observers about a loss of health\n     *\n     * @param damage\n     *            amount of healthpoints lost\n     * @param healthBefore\n     *            original health amount before it was decreased by\n     *            <code>damage</code>\n     */\n    protected void fireWasHit(final int damage, final int healthBefore) {\n        for (final CombatantObserver observer : observers) {\n            observer.isHit(this, damage, healthBefore);\n        }\n    }\n\n    /**\n     * notify all observers about our dead\n     */\n    protected void fireIsDead() {\n        for (final CombatantObserver observer : observers) {\n            observer.isDead(this);\n        }\n    }\n\n    /**\n     * notify all observers about our resurrection\n     */\n    protected void fireIsAlive() {\n        for (final CombatantObserver observer : observers) {\n            observer.isAlive(this);\n        }\n    }\n\n    /**\n     * notify all observers about changed online state\n     *\n     * @param changed\n     *            if the value was changed or only set\n     */\n    protected void fireOnlineChange(final boolean changed) {\n        for (final CombatantObserver observer : observers) {\n            observer.isOnline(this, changed);\n        }\n    }\n\n    /**\n     * notify all observers that i have done a critical shot\n     *\n     * @param damage\n     *            the actual caused damage\n     */\n    protected void fireCriticalShot(final int damage) {\n        for (final CombatantObserver observer : observers) {\n            observer.criticalShot(this, aimingAt, damage);\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_getLocation()\n     */\n    public Area _getLocation() {\n        return state.getPosition();\n    }\n\n    /**\n     * @return the side\n     */\n    public CombatantSide getSide() {\n        return side;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_health()\n     */\n    public int _health() {\n        return state.getHealth();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_maxHealth()\n     */\n    public int _maxHealth() {\n        return maxHealth;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_setState(de.outstare.fortbattleplayer.model.CombatantState)\n     */\n    public void _setState(final CombatantState newState) {\n        final CombatantState oldState = state;\n        // TODO maybe a PropertyChangeListener for the state\n        synchronized (stateChangeLock) {\n            state = newState;\n            // new pos has not to be null!\n            if (state.getPosition() != null) {\n                final Area oldPos = oldState.getPosition();\n                // fix for swapping:\n                // 1. go away from battlefield\n                moveAway(oldPos);\n                // 2. come from nowhere to new position (avoids swapping)\n                state.getPosition().occupy(this, null);\n                if (oldPos == null || !oldPos.equals(state.getPosition())) {\n                    fireHasMoved();\n                }\n            }\n            if (oldState.getHealth() != state.getHealth()) {\n                fireWasHit(oldState.getHealth() - state.getHealth(), oldState.getHealth());\n            }\n            if (state.getHealth() > 0 && oldState.getHealth() <= 0) {\n                fireIsAlive();\n            }\n            if (state.getHealth() <= 0 && oldState.getHealth() > 0) {\n                fireIsDead();\n            }\n            if (oldState.isGamerOnline() != state.isGamerOnline()) {\n                fireOnlineChange(true);\n            }\n            if (!oldState.getTarget().equals(state.getTarget())) {\n                fireNewTarget();\n            }\n        }\n    }\n\n    /**\n     * @param position\n     */\n    private void moveAway(final Area position) {\n        if (position != null && equals(position.getOccupier())) {\n            position.free();\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_state()\n     */\n    public CombatantState _state() {\n        return state;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#isOnline()\n     */\n    public boolean isOnline() {\n        return state.isGamerOnline();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#setOnline()\n     */\n    public void setOnline(final boolean isOnline) {\n        synchronized (stateChangeLock) {\n            final boolean changed = isOnline() != isOnline;\n            if (changed) {\n                LOG.fine(name + \" is now \" + (isOnline ? \"online\" : \"offline\"));\n                state = state.setOnline(isOnline);\n            }\n            fireOnlineChange(changed);\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getCharacterClass()\n     */\n    public CharacterClass getCharacterClass() {\n        return charClass;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getSectorBonus()\n     */\n    public SectorBonus getSectorBonus() {\n        return _getLocation().getSectorBonus(this);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getCity()\n     */\n    public String getCity() {\n        return city;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#usesBayonet()\n     */\n    public boolean usesBayonet() {\n        final WeaponData weaponData = new JSWeaponData();\n        return weaponData.hasBayonet(getWeapon());\n    }\n\n    /**\n     * @see java.lang.Object#hashCode()\n     */\n    @Override\n    public int hashCode() {\n        final int prime = 13;\n        int result = 1;\n        result = prime * result + ((name == null) ? 0 : name.hashCode());\n        result = prime * result + ((charClass == null) ? 0 : charClass.hashCode());\n        result = prime * result + ((city == null) ? 0 : city.hashCode());\n        return result;\n    }\n\n    /**\n     * @see java.lang.Object#equals(java.lang.Object)\n     */\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!(obj instanceof SimpleCombatant)) {\n            return false;\n        }\n        final SimpleCombatant other = (SimpleCombatant) obj;\n        if (name == null) {\n            if (other.name != null) {\n                return false;\n            }\n        } else if (!name.equals(other.name)) {\n            return false;\n        }\n        if (charClass != other.charClass) {\n            return false;\n        }\n        if (city == null) {\n            if (other.city != null) {\n                return false;\n            }\n        } else if (!city.equals(other.city)) {\n            return false;\n        }\n        return true;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/model/impl/SimpleCombatant_6Test.java",
		"test_prompt": "// SimpleCombatant_6Test.java\npackage de.outstare.fortbattleplayer.model.impl;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.CombatantState;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleCombatant}.\n* It contains ten unit test cases for the {@link SimpleCombatant#_state()} method.\n*/\nclass SimpleCombatant_6Test {"
	},
	{
		"original_code": "// SimpleCombatant.java\npackage de.outstare.fortbattleplayer.model.impl;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.CombatantState;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\n\n/**\n * A Combatant with basic attributes (position, health)\n *\n * @author daniel\n */\npublic class SimpleCombatant implements Combatant {\n\n    private static final transient Logger LOG = Logger.getLogger(SimpleCombatant.class.getName());\n\n    private final int maxHealth;\n\n    private final CombatantSide side;\n\n    private final String name;\n\n    private final String city;\n\n    private final Set<CombatantObserver> observers = new HashSet<CombatantObserver>();\n\n    private final Object stateChangeLock = new Object();\n\n    private final CharacterClass charClass;\n\n    private final Weapon weapon;\n\n    private CombatantState state;\n\n    private Combatant aimingAt = null;\n\n    /**\n     * Create a new {@link Combatant} at the given position and the given amount\n     * of health.\n     *\n     * @param side\n     *            not null\n     * @param initialState\n     *            not null\n     * @param maxHealth\n     *            > 0\n     * @param name\n     *            the name of the player of this Combatant\n     * @param characterClass\n     *            maybe null for old logs\n     * @param weapon\n     *            not null\n     * @param city\n     *            not null\n     */\n    public SimpleCombatant(final CombatantSide side, final CombatantState initialState, final int maxHealth, final String name, final CharacterClass characterClass, final Weapon weapon, final String city) {\n        assert side != null && initialState != null && weapon != null && city != null : \"parameters may not be null!\";\n        assert maxHealth > 0 : \"health must be positive!\";\n        assert maxHealth >= initialState.getHealth() && initialState.getHealth() > 0 : \"currentHealth must be inbetween 1 and max, is \" + initialState.getHealth();\n        this.side = side;\n        this.maxHealth = maxHealth;\n        this.name = name;\n        this.city = city;\n        state = initialState;\n        charClass = characterClass;\n        this.weapon = weapon;\n        // move to current location\n        state.getPosition().occupy(this, null);\n    }\n\n    /**\n     * @see java.lang.Object#toString()\n     */\n    @Override\n    public String toString() {\n        return getSide() + \" \" + name;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getName()\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getWeapon()\n     */\n    public Weapon getWeapon() {\n        return weapon;\n    }\n\n    /**\n     * internal method for graphical display\n     *\n     * @return the maximal health\n     */\n    public int _getMaxLP() {\n        return maxHealth;\n    }\n\n    /**\n     * internal method for graphical display\n     *\n     * @return the current health\n     */\n    public int _getCurrentLP() {\n        return state.getHealth();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#move(de.outstare.fortbattleplayer.model.Area)\n     */\n    public void move(final Area target) {\n        LOG.fine(name + \" moving to \" + target);\n        synchronized (stateChangeLock) {\n            final Area oldPosition = state.getPosition();\n            moveAway(oldPosition);\n            state = state.changePosition(target);\n            final Combatant swapped = target.occupy(this, oldPosition);\n            fireHasMoved();\n            if (swapped != null) {\n                fireHasSwapped(swapped);\n            }\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#shoot(de.outstare.fortbattleplayer.model.Area)\n     */\n    public void shoot(final int power) {\n        LOG.fine(name + \" shooting with \" + power);\n        aimingAt.hit(power);\n        final int sectorBonusDamage = state.getPosition().getSectorBonus(this).additionalDamage;\n        if (charClass == CharacterClass.DUELANT && power > weapon.maxDamage() + sectorBonusDamage) {\n            final double tenPercent = aimingAt._maxHealth() * 0.1;\n            if (power > weapon.minDamage() + tenPercent) {\n                fireCriticalShot(power);\n            } else {\n                LOG.fine(\"almost crit by \" + name + \": \" + power);\n            }\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#hit(int)\n     */\n    public boolean hit(final int damageAmount) {\n        LOG.fine(name + \" was hit and lost \" + damageAmount + \" health points\");\n        synchronized (stateChangeLock) {\n            final int oldHealth = state.getHealth();\n            state = state.reduceHealthBy(damageAmount);\n            fireWasHit(damageAmount, oldHealth);\n            if (state.getHealth() <= 0) {\n                moveAway(state.getPosition());\n                fireIsDead();\n            }\n            return state.getHealth() > 0;\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#aimAt(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void aimAt(final Combatant target) {\n        LOG.fine(name + \" aims at \" + target);\n        aimingAt = target;\n        fireAimingAt();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#setDestination(de.outstare.fortbattleplayer.model.Area)\n     */\n    public void setDestination(final Area destination) {\n        LOG.fine(name + \" wants to move to \" + destination);\n        synchronized (stateChangeLock) {\n            state = state.changeTarget(destination);\n            fireNewTarget();\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#addObserver(de.outstare.fortbattleplayer.model.CombatantObserver)\n     */\n    public void addObserver(final CombatantObserver observer) {\n        observers.add(observer);\n        // send current state\n        observer.hasMoved(this, state.getPosition());\n        if (aimingAt != null) {\n            observer.aimsAt(this, aimingAt);\n        }\n        if (state.getHealth() <= 0) {\n            observer.isDead(this);\n        } else {\n            observer.isAlive(this);\n        }\n        observer.isOnline(this, false);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#removeObserver(de.outstare.fortbattleplayer.model.CombatantObserver)\n     */\n    public void removeObserver(final CombatantObserver observer) {\n        observers.remove(observer);\n    }\n\n    /**\n     * notify all observers about the current position\n     */\n    protected void fireHasMoved() {\n        for (final CombatantObserver observer : observers) {\n            observer.hasMoved(this, state.getPosition());\n        }\n    }\n\n    /**\n     * notify all observers about the current position\n     *\n     * @param swappedWith\n     */\n    protected void fireHasSwapped(final Combatant swappedWith) {\n        for (final CombatantObserver observer : observers) {\n            observer.hasSwappedPosition(this, swappedWith);\n        }\n    }\n\n    /**\n     * notify all observers about the current position\n     */\n    protected void fireNewTarget() {\n        for (final CombatantObserver observer : observers) {\n            observer.newDestination(this, state.getTarget());\n        }\n    }\n\n    /**\n     * notify all observers that I shot at somebody.\n     */\n    protected void fireAimingAt() {\n        if (aimingAt != null) {\n            for (final CombatantObserver observer : observers) {\n                observer.aimsAt(this, aimingAt);\n            }\n        }\n    }\n\n    /**\n     * notify all observers about a loss of health\n     *\n     * @param damage\n     *            amount of healthpoints lost\n     * @param healthBefore\n     *            original health amount before it was decreased by\n     *            <code>damage</code>\n     */\n    protected void fireWasHit(final int damage, final int healthBefore) {\n        for (final CombatantObserver observer : observers) {\n            observer.isHit(this, damage, healthBefore);\n        }\n    }\n\n    /**\n     * notify all observers about our dead\n     */\n    protected void fireIsDead() {\n        for (final CombatantObserver observer : observers) {\n            observer.isDead(this);\n        }\n    }\n\n    /**\n     * notify all observers about our resurrection\n     */\n    protected void fireIsAlive() {\n        for (final CombatantObserver observer : observers) {\n            observer.isAlive(this);\n        }\n    }\n\n    /**\n     * notify all observers about changed online state\n     *\n     * @param changed\n     *            if the value was changed or only set\n     */\n    protected void fireOnlineChange(final boolean changed) {\n        for (final CombatantObserver observer : observers) {\n            observer.isOnline(this, changed);\n        }\n    }\n\n    /**\n     * notify all observers that i have done a critical shot\n     *\n     * @param damage\n     *            the actual caused damage\n     */\n    protected void fireCriticalShot(final int damage) {\n        for (final CombatantObserver observer : observers) {\n            observer.criticalShot(this, aimingAt, damage);\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_getLocation()\n     */\n    public Area _getLocation() {\n        return state.getPosition();\n    }\n\n    /**\n     * @return the side\n     */\n    public CombatantSide getSide() {\n        return side;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_health()\n     */\n    public int _health() {\n        return state.getHealth();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_maxHealth()\n     */\n    public int _maxHealth() {\n        return maxHealth;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_setState(de.outstare.fortbattleplayer.model.CombatantState)\n     */\n    public void _setState(final CombatantState newState) {\n        final CombatantState oldState = state;\n        // TODO maybe a PropertyChangeListener for the state\n        synchronized (stateChangeLock) {\n            state = newState;\n            // new pos has not to be null!\n            if (state.getPosition() != null) {\n                final Area oldPos = oldState.getPosition();\n                // fix for swapping:\n                // 1. go away from battlefield\n                moveAway(oldPos);\n                // 2. come from nowhere to new position (avoids swapping)\n                state.getPosition().occupy(this, null);\n                if (oldPos == null || !oldPos.equals(state.getPosition())) {\n                    fireHasMoved();\n                }\n            }\n            if (oldState.getHealth() != state.getHealth()) {\n                fireWasHit(oldState.getHealth() - state.getHealth(), oldState.getHealth());\n            }\n            if (state.getHealth() > 0 && oldState.getHealth() <= 0) {\n                fireIsAlive();\n            }\n            if (state.getHealth() <= 0 && oldState.getHealth() > 0) {\n                fireIsDead();\n            }\n            if (oldState.isGamerOnline() != state.isGamerOnline()) {\n                fireOnlineChange(true);\n            }\n            if (!oldState.getTarget().equals(state.getTarget())) {\n                fireNewTarget();\n            }\n        }\n    }\n\n    /**\n     * @param position\n     */\n    private void moveAway(final Area position) {\n        if (position != null && equals(position.getOccupier())) {\n            position.free();\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_state()\n     */\n    public CombatantState _state() {\n        return state;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#isOnline()\n     */\n    public boolean isOnline() {\n        return state.isGamerOnline();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#setOnline()\n     */\n    public void setOnline(final boolean isOnline) {\n        synchronized (stateChangeLock) {\n            final boolean changed = isOnline() != isOnline;\n            if (changed) {\n                LOG.fine(name + \" is now \" + (isOnline ? \"online\" : \"offline\"));\n                state = state.setOnline(isOnline);\n            }\n            fireOnlineChange(changed);\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getCharacterClass()\n     */\n    public CharacterClass getCharacterClass() {\n        return charClass;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getSectorBonus()\n     */\n    public SectorBonus getSectorBonus() {\n        return _getLocation().getSectorBonus(this);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getCity()\n     */\n    public String getCity() {\n        return city;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#usesBayonet()\n     */\n    public boolean usesBayonet() {\n        final WeaponData weaponData = new JSWeaponData();\n        return weaponData.hasBayonet(getWeapon());\n    }\n\n    /**\n     * @see java.lang.Object#hashCode()\n     */\n    @Override\n    public int hashCode() {\n        final int prime = 13;\n        int result = 1;\n        result = prime * result + ((name == null) ? 0 : name.hashCode());\n        result = prime * result + ((charClass == null) ? 0 : charClass.hashCode());\n        result = prime * result + ((city == null) ? 0 : city.hashCode());\n        return result;\n    }\n\n    /**\n     * @see java.lang.Object#equals(java.lang.Object)\n     */\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!(obj instanceof SimpleCombatant)) {\n            return false;\n        }\n        final SimpleCombatant other = (SimpleCombatant) obj;\n        if (name == null) {\n            if (other.name != null) {\n                return false;\n            }\n        } else if (!name.equals(other.name)) {\n            return false;\n        }\n        if (charClass != other.charClass) {\n            return false;\n        }\n        if (city == null) {\n            if (other.city != null) {\n                return false;\n            }\n        } else if (!city.equals(other.city)) {\n            return false;\n        }\n        return true;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/model/impl/SimpleCombatant_7Test.java",
		"test_prompt": "// SimpleCombatant_7Test.java\npackage de.outstare.fortbattleplayer.model.impl;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.CombatantState;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleCombatant}.\n* It contains ten unit test cases for the {@link SimpleCombatant#isOnline()} method.\n*/\nclass SimpleCombatant_7Test {"
	},
	{
		"original_code": "// SimpleCombatant.java\npackage de.outstare.fortbattleplayer.model.impl;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.CombatantState;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\n\n/**\n * A Combatant with basic attributes (position, health)\n *\n * @author daniel\n */\npublic class SimpleCombatant implements Combatant {\n\n    private static final transient Logger LOG = Logger.getLogger(SimpleCombatant.class.getName());\n\n    private final int maxHealth;\n\n    private final CombatantSide side;\n\n    private final String name;\n\n    private final String city;\n\n    private final Set<CombatantObserver> observers = new HashSet<CombatantObserver>();\n\n    private final Object stateChangeLock = new Object();\n\n    private final CharacterClass charClass;\n\n    private final Weapon weapon;\n\n    private CombatantState state;\n\n    private Combatant aimingAt = null;\n\n    /**\n     * Create a new {@link Combatant} at the given position and the given amount\n     * of health.\n     *\n     * @param side\n     *            not null\n     * @param initialState\n     *            not null\n     * @param maxHealth\n     *            > 0\n     * @param name\n     *            the name of the player of this Combatant\n     * @param characterClass\n     *            maybe null for old logs\n     * @param weapon\n     *            not null\n     * @param city\n     *            not null\n     */\n    public SimpleCombatant(final CombatantSide side, final CombatantState initialState, final int maxHealth, final String name, final CharacterClass characterClass, final Weapon weapon, final String city) {\n        assert side != null && initialState != null && weapon != null && city != null : \"parameters may not be null!\";\n        assert maxHealth > 0 : \"health must be positive!\";\n        assert maxHealth >= initialState.getHealth() && initialState.getHealth() > 0 : \"currentHealth must be inbetween 1 and max, is \" + initialState.getHealth();\n        this.side = side;\n        this.maxHealth = maxHealth;\n        this.name = name;\n        this.city = city;\n        state = initialState;\n        charClass = characterClass;\n        this.weapon = weapon;\n        // move to current location\n        state.getPosition().occupy(this, null);\n    }\n\n    /**\n     * @see java.lang.Object#toString()\n     */\n    @Override\n    public String toString() {\n        return getSide() + \" \" + name;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getName()\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getWeapon()\n     */\n    public Weapon getWeapon() {\n        return weapon;\n    }\n\n    /**\n     * internal method for graphical display\n     *\n     * @return the maximal health\n     */\n    public int _getMaxLP() {\n        return maxHealth;\n    }\n\n    /**\n     * internal method for graphical display\n     *\n     * @return the current health\n     */\n    public int _getCurrentLP() {\n        return state.getHealth();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#move(de.outstare.fortbattleplayer.model.Area)\n     */\n    public void move(final Area target) {\n        LOG.fine(name + \" moving to \" + target);\n        synchronized (stateChangeLock) {\n            final Area oldPosition = state.getPosition();\n            moveAway(oldPosition);\n            state = state.changePosition(target);\n            final Combatant swapped = target.occupy(this, oldPosition);\n            fireHasMoved();\n            if (swapped != null) {\n                fireHasSwapped(swapped);\n            }\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#shoot(de.outstare.fortbattleplayer.model.Area)\n     */\n    public void shoot(final int power) {\n        LOG.fine(name + \" shooting with \" + power);\n        aimingAt.hit(power);\n        final int sectorBonusDamage = state.getPosition().getSectorBonus(this).additionalDamage;\n        if (charClass == CharacterClass.DUELANT && power > weapon.maxDamage() + sectorBonusDamage) {\n            final double tenPercent = aimingAt._maxHealth() * 0.1;\n            if (power > weapon.minDamage() + tenPercent) {\n                fireCriticalShot(power);\n            } else {\n                LOG.fine(\"almost crit by \" + name + \": \" + power);\n            }\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#hit(int)\n     */\n    public boolean hit(final int damageAmount) {\n        LOG.fine(name + \" was hit and lost \" + damageAmount + \" health points\");\n        synchronized (stateChangeLock) {\n            final int oldHealth = state.getHealth();\n            state = state.reduceHealthBy(damageAmount);\n            fireWasHit(damageAmount, oldHealth);\n            if (state.getHealth() <= 0) {\n                moveAway(state.getPosition());\n                fireIsDead();\n            }\n            return state.getHealth() > 0;\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#aimAt(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void aimAt(final Combatant target) {\n        LOG.fine(name + \" aims at \" + target);\n        aimingAt = target;\n        fireAimingAt();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#setDestination(de.outstare.fortbattleplayer.model.Area)\n     */\n    public void setDestination(final Area destination) {\n        LOG.fine(name + \" wants to move to \" + destination);\n        synchronized (stateChangeLock) {\n            state = state.changeTarget(destination);\n            fireNewTarget();\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#addObserver(de.outstare.fortbattleplayer.model.CombatantObserver)\n     */\n    public void addObserver(final CombatantObserver observer) {\n        observers.add(observer);\n        // send current state\n        observer.hasMoved(this, state.getPosition());\n        if (aimingAt != null) {\n            observer.aimsAt(this, aimingAt);\n        }\n        if (state.getHealth() <= 0) {\n            observer.isDead(this);\n        } else {\n            observer.isAlive(this);\n        }\n        observer.isOnline(this, false);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#removeObserver(de.outstare.fortbattleplayer.model.CombatantObserver)\n     */\n    public void removeObserver(final CombatantObserver observer) {\n        observers.remove(observer);\n    }\n\n    /**\n     * notify all observers about the current position\n     */\n    protected void fireHasMoved() {\n        for (final CombatantObserver observer : observers) {\n            observer.hasMoved(this, state.getPosition());\n        }\n    }\n\n    /**\n     * notify all observers about the current position\n     *\n     * @param swappedWith\n     */\n    protected void fireHasSwapped(final Combatant swappedWith) {\n        for (final CombatantObserver observer : observers) {\n            observer.hasSwappedPosition(this, swappedWith);\n        }\n    }\n\n    /**\n     * notify all observers about the current position\n     */\n    protected void fireNewTarget() {\n        for (final CombatantObserver observer : observers) {\n            observer.newDestination(this, state.getTarget());\n        }\n    }\n\n    /**\n     * notify all observers that I shot at somebody.\n     */\n    protected void fireAimingAt() {\n        if (aimingAt != null) {\n            for (final CombatantObserver observer : observers) {\n                observer.aimsAt(this, aimingAt);\n            }\n        }\n    }\n\n    /**\n     * notify all observers about a loss of health\n     *\n     * @param damage\n     *            amount of healthpoints lost\n     * @param healthBefore\n     *            original health amount before it was decreased by\n     *            <code>damage</code>\n     */\n    protected void fireWasHit(final int damage, final int healthBefore) {\n        for (final CombatantObserver observer : observers) {\n            observer.isHit(this, damage, healthBefore);\n        }\n    }\n\n    /**\n     * notify all observers about our dead\n     */\n    protected void fireIsDead() {\n        for (final CombatantObserver observer : observers) {\n            observer.isDead(this);\n        }\n    }\n\n    /**\n     * notify all observers about our resurrection\n     */\n    protected void fireIsAlive() {\n        for (final CombatantObserver observer : observers) {\n            observer.isAlive(this);\n        }\n    }\n\n    /**\n     * notify all observers about changed online state\n     *\n     * @param changed\n     *            if the value was changed or only set\n     */\n    protected void fireOnlineChange(final boolean changed) {\n        for (final CombatantObserver observer : observers) {\n            observer.isOnline(this, changed);\n        }\n    }\n\n    /**\n     * notify all observers that i have done a critical shot\n     *\n     * @param damage\n     *            the actual caused damage\n     */\n    protected void fireCriticalShot(final int damage) {\n        for (final CombatantObserver observer : observers) {\n            observer.criticalShot(this, aimingAt, damage);\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_getLocation()\n     */\n    public Area _getLocation() {\n        return state.getPosition();\n    }\n\n    /**\n     * @return the side\n     */\n    public CombatantSide getSide() {\n        return side;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_health()\n     */\n    public int _health() {\n        return state.getHealth();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_maxHealth()\n     */\n    public int _maxHealth() {\n        return maxHealth;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_setState(de.outstare.fortbattleplayer.model.CombatantState)\n     */\n    public void _setState(final CombatantState newState) {\n        final CombatantState oldState = state;\n        // TODO maybe a PropertyChangeListener for the state\n        synchronized (stateChangeLock) {\n            state = newState;\n            // new pos has not to be null!\n            if (state.getPosition() != null) {\n                final Area oldPos = oldState.getPosition();\n                // fix for swapping:\n                // 1. go away from battlefield\n                moveAway(oldPos);\n                // 2. come from nowhere to new position (avoids swapping)\n                state.getPosition().occupy(this, null);\n                if (oldPos == null || !oldPos.equals(state.getPosition())) {\n                    fireHasMoved();\n                }\n            }\n            if (oldState.getHealth() != state.getHealth()) {\n                fireWasHit(oldState.getHealth() - state.getHealth(), oldState.getHealth());\n            }\n            if (state.getHealth() > 0 && oldState.getHealth() <= 0) {\n                fireIsAlive();\n            }\n            if (state.getHealth() <= 0 && oldState.getHealth() > 0) {\n                fireIsDead();\n            }\n            if (oldState.isGamerOnline() != state.isGamerOnline()) {\n                fireOnlineChange(true);\n            }\n            if (!oldState.getTarget().equals(state.getTarget())) {\n                fireNewTarget();\n            }\n        }\n    }\n\n    /**\n     * @param position\n     */\n    private void moveAway(final Area position) {\n        if (position != null && equals(position.getOccupier())) {\n            position.free();\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_state()\n     */\n    public CombatantState _state() {\n        return state;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#isOnline()\n     */\n    public boolean isOnline() {\n        return state.isGamerOnline();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#setOnline()\n     */\n    public void setOnline(final boolean isOnline) {\n        synchronized (stateChangeLock) {\n            final boolean changed = isOnline() != isOnline;\n            if (changed) {\n                LOG.fine(name + \" is now \" + (isOnline ? \"online\" : \"offline\"));\n                state = state.setOnline(isOnline);\n            }\n            fireOnlineChange(changed);\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getCharacterClass()\n     */\n    public CharacterClass getCharacterClass() {\n        return charClass;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getSectorBonus()\n     */\n    public SectorBonus getSectorBonus() {\n        return _getLocation().getSectorBonus(this);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getCity()\n     */\n    public String getCity() {\n        return city;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#usesBayonet()\n     */\n    public boolean usesBayonet() {\n        final WeaponData weaponData = new JSWeaponData();\n        return weaponData.hasBayonet(getWeapon());\n    }\n\n    /**\n     * @see java.lang.Object#hashCode()\n     */\n    @Override\n    public int hashCode() {\n        final int prime = 13;\n        int result = 1;\n        result = prime * result + ((name == null) ? 0 : name.hashCode());\n        result = prime * result + ((charClass == null) ? 0 : charClass.hashCode());\n        result = prime * result + ((city == null) ? 0 : city.hashCode());\n        return result;\n    }\n\n    /**\n     * @see java.lang.Object#equals(java.lang.Object)\n     */\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!(obj instanceof SimpleCombatant)) {\n            return false;\n        }\n        final SimpleCombatant other = (SimpleCombatant) obj;\n        if (name == null) {\n            if (other.name != null) {\n                return false;\n            }\n        } else if (!name.equals(other.name)) {\n            return false;\n        }\n        if (charClass != other.charClass) {\n            return false;\n        }\n        if (city == null) {\n            if (other.city != null) {\n                return false;\n            }\n        } else if (!city.equals(other.city)) {\n            return false;\n        }\n        return true;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/model/impl/SimpleCombatant_8Test.java",
		"test_prompt": "// SimpleCombatant_8Test.java\npackage de.outstare.fortbattleplayer.model.impl;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.CombatantState;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleCombatant}.\n* It contains ten unit test cases for the {@link SimpleCombatant#usesBayonet()} method.\n*/\nclass SimpleCombatant_8Test {"
	},
	{
		"original_code": "// SimpleCombatant.java\npackage de.outstare.fortbattleplayer.model.impl;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.CombatantState;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\n\n/**\n * A Combatant with basic attributes (position, health)\n *\n * @author daniel\n */\npublic class SimpleCombatant implements Combatant {\n\n    private static final transient Logger LOG = Logger.getLogger(SimpleCombatant.class.getName());\n\n    private final int maxHealth;\n\n    private final CombatantSide side;\n\n    private final String name;\n\n    private final String city;\n\n    private final Set<CombatantObserver> observers = new HashSet<CombatantObserver>();\n\n    private final Object stateChangeLock = new Object();\n\n    private final CharacterClass charClass;\n\n    private final Weapon weapon;\n\n    private CombatantState state;\n\n    private Combatant aimingAt = null;\n\n    /**\n     * Create a new {@link Combatant} at the given position and the given amount\n     * of health.\n     *\n     * @param side\n     *            not null\n     * @param initialState\n     *            not null\n     * @param maxHealth\n     *            > 0\n     * @param name\n     *            the name of the player of this Combatant\n     * @param characterClass\n     *            maybe null for old logs\n     * @param weapon\n     *            not null\n     * @param city\n     *            not null\n     */\n    public SimpleCombatant(final CombatantSide side, final CombatantState initialState, final int maxHealth, final String name, final CharacterClass characterClass, final Weapon weapon, final String city) {\n        assert side != null && initialState != null && weapon != null && city != null : \"parameters may not be null!\";\n        assert maxHealth > 0 : \"health must be positive!\";\n        assert maxHealth >= initialState.getHealth() && initialState.getHealth() > 0 : \"currentHealth must be inbetween 1 and max, is \" + initialState.getHealth();\n        this.side = side;\n        this.maxHealth = maxHealth;\n        this.name = name;\n        this.city = city;\n        state = initialState;\n        charClass = characterClass;\n        this.weapon = weapon;\n        // move to current location\n        state.getPosition().occupy(this, null);\n    }\n\n    /**\n     * @see java.lang.Object#toString()\n     */\n    @Override\n    public String toString() {\n        return getSide() + \" \" + name;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getName()\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getWeapon()\n     */\n    public Weapon getWeapon() {\n        return weapon;\n    }\n\n    /**\n     * internal method for graphical display\n     *\n     * @return the maximal health\n     */\n    public int _getMaxLP() {\n        return maxHealth;\n    }\n\n    /**\n     * internal method for graphical display\n     *\n     * @return the current health\n     */\n    public int _getCurrentLP() {\n        return state.getHealth();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#move(de.outstare.fortbattleplayer.model.Area)\n     */\n    public void move(final Area target) {\n        LOG.fine(name + \" moving to \" + target);\n        synchronized (stateChangeLock) {\n            final Area oldPosition = state.getPosition();\n            moveAway(oldPosition);\n            state = state.changePosition(target);\n            final Combatant swapped = target.occupy(this, oldPosition);\n            fireHasMoved();\n            if (swapped != null) {\n                fireHasSwapped(swapped);\n            }\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#shoot(de.outstare.fortbattleplayer.model.Area)\n     */\n    public void shoot(final int power) {\n        LOG.fine(name + \" shooting with \" + power);\n        aimingAt.hit(power);\n        final int sectorBonusDamage = state.getPosition().getSectorBonus(this).additionalDamage;\n        if (charClass == CharacterClass.DUELANT && power > weapon.maxDamage() + sectorBonusDamage) {\n            final double tenPercent = aimingAt._maxHealth() * 0.1;\n            if (power > weapon.minDamage() + tenPercent) {\n                fireCriticalShot(power);\n            } else {\n                LOG.fine(\"almost crit by \" + name + \": \" + power);\n            }\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#hit(int)\n     */\n    public boolean hit(final int damageAmount) {\n        LOG.fine(name + \" was hit and lost \" + damageAmount + \" health points\");\n        synchronized (stateChangeLock) {\n            final int oldHealth = state.getHealth();\n            state = state.reduceHealthBy(damageAmount);\n            fireWasHit(damageAmount, oldHealth);\n            if (state.getHealth() <= 0) {\n                moveAway(state.getPosition());\n                fireIsDead();\n            }\n            return state.getHealth() > 0;\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#aimAt(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void aimAt(final Combatant target) {\n        LOG.fine(name + \" aims at \" + target);\n        aimingAt = target;\n        fireAimingAt();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#setDestination(de.outstare.fortbattleplayer.model.Area)\n     */\n    public void setDestination(final Area destination) {\n        LOG.fine(name + \" wants to move to \" + destination);\n        synchronized (stateChangeLock) {\n            state = state.changeTarget(destination);\n            fireNewTarget();\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#addObserver(de.outstare.fortbattleplayer.model.CombatantObserver)\n     */\n    public void addObserver(final CombatantObserver observer) {\n        observers.add(observer);\n        // send current state\n        observer.hasMoved(this, state.getPosition());\n        if (aimingAt != null) {\n            observer.aimsAt(this, aimingAt);\n        }\n        if (state.getHealth() <= 0) {\n            observer.isDead(this);\n        } else {\n            observer.isAlive(this);\n        }\n        observer.isOnline(this, false);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#removeObserver(de.outstare.fortbattleplayer.model.CombatantObserver)\n     */\n    public void removeObserver(final CombatantObserver observer) {\n        observers.remove(observer);\n    }\n\n    /**\n     * notify all observers about the current position\n     */\n    protected void fireHasMoved() {\n        for (final CombatantObserver observer : observers) {\n            observer.hasMoved(this, state.getPosition());\n        }\n    }\n\n    /**\n     * notify all observers about the current position\n     *\n     * @param swappedWith\n     */\n    protected void fireHasSwapped(final Combatant swappedWith) {\n        for (final CombatantObserver observer : observers) {\n            observer.hasSwappedPosition(this, swappedWith);\n        }\n    }\n\n    /**\n     * notify all observers about the current position\n     */\n    protected void fireNewTarget() {\n        for (final CombatantObserver observer : observers) {\n            observer.newDestination(this, state.getTarget());\n        }\n    }\n\n    /**\n     * notify all observers that I shot at somebody.\n     */\n    protected void fireAimingAt() {\n        if (aimingAt != null) {\n            for (final CombatantObserver observer : observers) {\n                observer.aimsAt(this, aimingAt);\n            }\n        }\n    }\n\n    /**\n     * notify all observers about a loss of health\n     *\n     * @param damage\n     *            amount of healthpoints lost\n     * @param healthBefore\n     *            original health amount before it was decreased by\n     *            <code>damage</code>\n     */\n    protected void fireWasHit(final int damage, final int healthBefore) {\n        for (final CombatantObserver observer : observers) {\n            observer.isHit(this, damage, healthBefore);\n        }\n    }\n\n    /**\n     * notify all observers about our dead\n     */\n    protected void fireIsDead() {\n        for (final CombatantObserver observer : observers) {\n            observer.isDead(this);\n        }\n    }\n\n    /**\n     * notify all observers about our resurrection\n     */\n    protected void fireIsAlive() {\n        for (final CombatantObserver observer : observers) {\n            observer.isAlive(this);\n        }\n    }\n\n    /**\n     * notify all observers about changed online state\n     *\n     * @param changed\n     *            if the value was changed or only set\n     */\n    protected void fireOnlineChange(final boolean changed) {\n        for (final CombatantObserver observer : observers) {\n            observer.isOnline(this, changed);\n        }\n    }\n\n    /**\n     * notify all observers that i have done a critical shot\n     *\n     * @param damage\n     *            the actual caused damage\n     */\n    protected void fireCriticalShot(final int damage) {\n        for (final CombatantObserver observer : observers) {\n            observer.criticalShot(this, aimingAt, damage);\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_getLocation()\n     */\n    public Area _getLocation() {\n        return state.getPosition();\n    }\n\n    /**\n     * @return the side\n     */\n    public CombatantSide getSide() {\n        return side;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_health()\n     */\n    public int _health() {\n        return state.getHealth();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_maxHealth()\n     */\n    public int _maxHealth() {\n        return maxHealth;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_setState(de.outstare.fortbattleplayer.model.CombatantState)\n     */\n    public void _setState(final CombatantState newState) {\n        final CombatantState oldState = state;\n        // TODO maybe a PropertyChangeListener for the state\n        synchronized (stateChangeLock) {\n            state = newState;\n            // new pos has not to be null!\n            if (state.getPosition() != null) {\n                final Area oldPos = oldState.getPosition();\n                // fix for swapping:\n                // 1. go away from battlefield\n                moveAway(oldPos);\n                // 2. come from nowhere to new position (avoids swapping)\n                state.getPosition().occupy(this, null);\n                if (oldPos == null || !oldPos.equals(state.getPosition())) {\n                    fireHasMoved();\n                }\n            }\n            if (oldState.getHealth() != state.getHealth()) {\n                fireWasHit(oldState.getHealth() - state.getHealth(), oldState.getHealth());\n            }\n            if (state.getHealth() > 0 && oldState.getHealth() <= 0) {\n                fireIsAlive();\n            }\n            if (state.getHealth() <= 0 && oldState.getHealth() > 0) {\n                fireIsDead();\n            }\n            if (oldState.isGamerOnline() != state.isGamerOnline()) {\n                fireOnlineChange(true);\n            }\n            if (!oldState.getTarget().equals(state.getTarget())) {\n                fireNewTarget();\n            }\n        }\n    }\n\n    /**\n     * @param position\n     */\n    private void moveAway(final Area position) {\n        if (position != null && equals(position.getOccupier())) {\n            position.free();\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_state()\n     */\n    public CombatantState _state() {\n        return state;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#isOnline()\n     */\n    public boolean isOnline() {\n        return state.isGamerOnline();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#setOnline()\n     */\n    public void setOnline(final boolean isOnline) {\n        synchronized (stateChangeLock) {\n            final boolean changed = isOnline() != isOnline;\n            if (changed) {\n                LOG.fine(name + \" is now \" + (isOnline ? \"online\" : \"offline\"));\n                state = state.setOnline(isOnline);\n            }\n            fireOnlineChange(changed);\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getCharacterClass()\n     */\n    public CharacterClass getCharacterClass() {\n        return charClass;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getSectorBonus()\n     */\n    public SectorBonus getSectorBonus() {\n        return _getLocation().getSectorBonus(this);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getCity()\n     */\n    public String getCity() {\n        return city;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#usesBayonet()\n     */\n    public boolean usesBayonet() {\n        final WeaponData weaponData = new JSWeaponData();\n        return weaponData.hasBayonet(getWeapon());\n    }\n\n    /**\n     * @see java.lang.Object#hashCode()\n     */\n    @Override\n    public int hashCode() {\n        final int prime = 13;\n        int result = 1;\n        result = prime * result + ((name == null) ? 0 : name.hashCode());\n        result = prime * result + ((charClass == null) ? 0 : charClass.hashCode());\n        result = prime * result + ((city == null) ? 0 : city.hashCode());\n        return result;\n    }\n\n    /**\n     * @see java.lang.Object#equals(java.lang.Object)\n     */\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!(obj instanceof SimpleCombatant)) {\n            return false;\n        }\n        final SimpleCombatant other = (SimpleCombatant) obj;\n        if (name == null) {\n            if (other.name != null) {\n                return false;\n            }\n        } else if (!name.equals(other.name)) {\n            return false;\n        }\n        if (charClass != other.charClass) {\n            return false;\n        }\n        if (city == null) {\n            if (other.city != null) {\n                return false;\n            }\n        } else if (!city.equals(other.city)) {\n            return false;\n        }\n        return true;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/model/impl/SimpleCombatant_9Test.java",
		"test_prompt": "// SimpleCombatant_9Test.java\npackage de.outstare.fortbattleplayer.model.impl;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.CombatantState;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleCombatant}.\n* It contains ten unit test cases for the {@link SimpleCombatant#hashCode()} method.\n*/\nclass SimpleCombatant_9Test {"
	},
	{
		"original_code": "// SimpleCombatant.java\npackage de.outstare.fortbattleplayer.model.impl;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.CombatantState;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\n\n/**\n * A Combatant with basic attributes (position, health)\n *\n * @author daniel\n */\npublic class SimpleCombatant implements Combatant {\n\n    private static final transient Logger LOG = Logger.getLogger(SimpleCombatant.class.getName());\n\n    private final int maxHealth;\n\n    private final CombatantSide side;\n\n    private final String name;\n\n    private final String city;\n\n    private final Set<CombatantObserver> observers = new HashSet<CombatantObserver>();\n\n    private final Object stateChangeLock = new Object();\n\n    private final CharacterClass charClass;\n\n    private final Weapon weapon;\n\n    private CombatantState state;\n\n    private Combatant aimingAt = null;\n\n    /**\n     * Create a new {@link Combatant} at the given position and the given amount\n     * of health.\n     *\n     * @param side\n     *            not null\n     * @param initialState\n     *            not null\n     * @param maxHealth\n     *            > 0\n     * @param name\n     *            the name of the player of this Combatant\n     * @param characterClass\n     *            maybe null for old logs\n     * @param weapon\n     *            not null\n     * @param city\n     *            not null\n     */\n    public SimpleCombatant(final CombatantSide side, final CombatantState initialState, final int maxHealth, final String name, final CharacterClass characterClass, final Weapon weapon, final String city) {\n        assert side != null && initialState != null && weapon != null && city != null : \"parameters may not be null!\";\n        assert maxHealth > 0 : \"health must be positive!\";\n        assert maxHealth >= initialState.getHealth() && initialState.getHealth() > 0 : \"currentHealth must be inbetween 1 and max, is \" + initialState.getHealth();\n        this.side = side;\n        this.maxHealth = maxHealth;\n        this.name = name;\n        this.city = city;\n        state = initialState;\n        charClass = characterClass;\n        this.weapon = weapon;\n        // move to current location\n        state.getPosition().occupy(this, null);\n    }\n\n    /**\n     * @see java.lang.Object#toString()\n     */\n    @Override\n    public String toString() {\n        return getSide() + \" \" + name;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getName()\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getWeapon()\n     */\n    public Weapon getWeapon() {\n        return weapon;\n    }\n\n    /**\n     * internal method for graphical display\n     *\n     * @return the maximal health\n     */\n    public int _getMaxLP() {\n        return maxHealth;\n    }\n\n    /**\n     * internal method for graphical display\n     *\n     * @return the current health\n     */\n    public int _getCurrentLP() {\n        return state.getHealth();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#move(de.outstare.fortbattleplayer.model.Area)\n     */\n    public void move(final Area target) {\n        LOG.fine(name + \" moving to \" + target);\n        synchronized (stateChangeLock) {\n            final Area oldPosition = state.getPosition();\n            moveAway(oldPosition);\n            state = state.changePosition(target);\n            final Combatant swapped = target.occupy(this, oldPosition);\n            fireHasMoved();\n            if (swapped != null) {\n                fireHasSwapped(swapped);\n            }\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#shoot(de.outstare.fortbattleplayer.model.Area)\n     */\n    public void shoot(final int power) {\n        LOG.fine(name + \" shooting with \" + power);\n        aimingAt.hit(power);\n        final int sectorBonusDamage = state.getPosition().getSectorBonus(this).additionalDamage;\n        if (charClass == CharacterClass.DUELANT && power > weapon.maxDamage() + sectorBonusDamage) {\n            final double tenPercent = aimingAt._maxHealth() * 0.1;\n            if (power > weapon.minDamage() + tenPercent) {\n                fireCriticalShot(power);\n            } else {\n                LOG.fine(\"almost crit by \" + name + \": \" + power);\n            }\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#hit(int)\n     */\n    public boolean hit(final int damageAmount) {\n        LOG.fine(name + \" was hit and lost \" + damageAmount + \" health points\");\n        synchronized (stateChangeLock) {\n            final int oldHealth = state.getHealth();\n            state = state.reduceHealthBy(damageAmount);\n            fireWasHit(damageAmount, oldHealth);\n            if (state.getHealth() <= 0) {\n                moveAway(state.getPosition());\n                fireIsDead();\n            }\n            return state.getHealth() > 0;\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#aimAt(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void aimAt(final Combatant target) {\n        LOG.fine(name + \" aims at \" + target);\n        aimingAt = target;\n        fireAimingAt();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#setDestination(de.outstare.fortbattleplayer.model.Area)\n     */\n    public void setDestination(final Area destination) {\n        LOG.fine(name + \" wants to move to \" + destination);\n        synchronized (stateChangeLock) {\n            state = state.changeTarget(destination);\n            fireNewTarget();\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#addObserver(de.outstare.fortbattleplayer.model.CombatantObserver)\n     */\n    public void addObserver(final CombatantObserver observer) {\n        observers.add(observer);\n        // send current state\n        observer.hasMoved(this, state.getPosition());\n        if (aimingAt != null) {\n            observer.aimsAt(this, aimingAt);\n        }\n        if (state.getHealth() <= 0) {\n            observer.isDead(this);\n        } else {\n            observer.isAlive(this);\n        }\n        observer.isOnline(this, false);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#removeObserver(de.outstare.fortbattleplayer.model.CombatantObserver)\n     */\n    public void removeObserver(final CombatantObserver observer) {\n        observers.remove(observer);\n    }\n\n    /**\n     * notify all observers about the current position\n     */\n    protected void fireHasMoved() {\n        for (final CombatantObserver observer : observers) {\n            observer.hasMoved(this, state.getPosition());\n        }\n    }\n\n    /**\n     * notify all observers about the current position\n     *\n     * @param swappedWith\n     */\n    protected void fireHasSwapped(final Combatant swappedWith) {\n        for (final CombatantObserver observer : observers) {\n            observer.hasSwappedPosition(this, swappedWith);\n        }\n    }\n\n    /**\n     * notify all observers about the current position\n     */\n    protected void fireNewTarget() {\n        for (final CombatantObserver observer : observers) {\n            observer.newDestination(this, state.getTarget());\n        }\n    }\n\n    /**\n     * notify all observers that I shot at somebody.\n     */\n    protected void fireAimingAt() {\n        if (aimingAt != null) {\n            for (final CombatantObserver observer : observers) {\n                observer.aimsAt(this, aimingAt);\n            }\n        }\n    }\n\n    /**\n     * notify all observers about a loss of health\n     *\n     * @param damage\n     *            amount of healthpoints lost\n     * @param healthBefore\n     *            original health amount before it was decreased by\n     *            <code>damage</code>\n     */\n    protected void fireWasHit(final int damage, final int healthBefore) {\n        for (final CombatantObserver observer : observers) {\n            observer.isHit(this, damage, healthBefore);\n        }\n    }\n\n    /**\n     * notify all observers about our dead\n     */\n    protected void fireIsDead() {\n        for (final CombatantObserver observer : observers) {\n            observer.isDead(this);\n        }\n    }\n\n    /**\n     * notify all observers about our resurrection\n     */\n    protected void fireIsAlive() {\n        for (final CombatantObserver observer : observers) {\n            observer.isAlive(this);\n        }\n    }\n\n    /**\n     * notify all observers about changed online state\n     *\n     * @param changed\n     *            if the value was changed or only set\n     */\n    protected void fireOnlineChange(final boolean changed) {\n        for (final CombatantObserver observer : observers) {\n            observer.isOnline(this, changed);\n        }\n    }\n\n    /**\n     * notify all observers that i have done a critical shot\n     *\n     * @param damage\n     *            the actual caused damage\n     */\n    protected void fireCriticalShot(final int damage) {\n        for (final CombatantObserver observer : observers) {\n            observer.criticalShot(this, aimingAt, damage);\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_getLocation()\n     */\n    public Area _getLocation() {\n        return state.getPosition();\n    }\n\n    /**\n     * @return the side\n     */\n    public CombatantSide getSide() {\n        return side;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_health()\n     */\n    public int _health() {\n        return state.getHealth();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_maxHealth()\n     */\n    public int _maxHealth() {\n        return maxHealth;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_setState(de.outstare.fortbattleplayer.model.CombatantState)\n     */\n    public void _setState(final CombatantState newState) {\n        final CombatantState oldState = state;\n        // TODO maybe a PropertyChangeListener for the state\n        synchronized (stateChangeLock) {\n            state = newState;\n            // new pos has not to be null!\n            if (state.getPosition() != null) {\n                final Area oldPos = oldState.getPosition();\n                // fix for swapping:\n                // 1. go away from battlefield\n                moveAway(oldPos);\n                // 2. come from nowhere to new position (avoids swapping)\n                state.getPosition().occupy(this, null);\n                if (oldPos == null || !oldPos.equals(state.getPosition())) {\n                    fireHasMoved();\n                }\n            }\n            if (oldState.getHealth() != state.getHealth()) {\n                fireWasHit(oldState.getHealth() - state.getHealth(), oldState.getHealth());\n            }\n            if (state.getHealth() > 0 && oldState.getHealth() <= 0) {\n                fireIsAlive();\n            }\n            if (state.getHealth() <= 0 && oldState.getHealth() > 0) {\n                fireIsDead();\n            }\n            if (oldState.isGamerOnline() != state.isGamerOnline()) {\n                fireOnlineChange(true);\n            }\n            if (!oldState.getTarget().equals(state.getTarget())) {\n                fireNewTarget();\n            }\n        }\n    }\n\n    /**\n     * @param position\n     */\n    private void moveAway(final Area position) {\n        if (position != null && equals(position.getOccupier())) {\n            position.free();\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_state()\n     */\n    public CombatantState _state() {\n        return state;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#isOnline()\n     */\n    public boolean isOnline() {\n        return state.isGamerOnline();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#setOnline()\n     */\n    public void setOnline(final boolean isOnline) {\n        synchronized (stateChangeLock) {\n            final boolean changed = isOnline() != isOnline;\n            if (changed) {\n                LOG.fine(name + \" is now \" + (isOnline ? \"online\" : \"offline\"));\n                state = state.setOnline(isOnline);\n            }\n            fireOnlineChange(changed);\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getCharacterClass()\n     */\n    public CharacterClass getCharacterClass() {\n        return charClass;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getSectorBonus()\n     */\n    public SectorBonus getSectorBonus() {\n        return _getLocation().getSectorBonus(this);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getCity()\n     */\n    public String getCity() {\n        return city;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#usesBayonet()\n     */\n    public boolean usesBayonet() {\n        final WeaponData weaponData = new JSWeaponData();\n        return weaponData.hasBayonet(getWeapon());\n    }\n\n    /**\n     * @see java.lang.Object#hashCode()\n     */\n    @Override\n    public int hashCode() {\n        final int prime = 13;\n        int result = 1;\n        result = prime * result + ((name == null) ? 0 : name.hashCode());\n        result = prime * result + ((charClass == null) ? 0 : charClass.hashCode());\n        result = prime * result + ((city == null) ? 0 : city.hashCode());\n        return result;\n    }\n\n    /**\n     * @see java.lang.Object#equals(java.lang.Object)\n     */\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!(obj instanceof SimpleCombatant)) {\n            return false;\n        }\n        final SimpleCombatant other = (SimpleCombatant) obj;\n        if (name == null) {\n            if (other.name != null) {\n                return false;\n            }\n        } else if (!name.equals(other.name)) {\n            return false;\n        }\n        if (charClass != other.charClass) {\n            return false;\n        }\n        if (city == null) {\n            if (other.city != null) {\n                return false;\n            }\n        } else if (!city.equals(other.city)) {\n            return false;\n        }\n        return true;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/model/impl/SimpleCombatant_10Test.java",
		"test_prompt": "// SimpleCombatant_10Test.java\npackage de.outstare.fortbattleplayer.model.impl;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.CombatantState;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleCombatant}.\n* It contains ten unit test cases for the {@link SimpleCombatant#equals(Object)} method.\n*/\nclass SimpleCombatant_10Test {"
	},
	{
		"original_code": "// SectorBonus.java\npackage de.outstare.fortbattleplayer.model;\n\n/**\n * The actual bonus for a given {@link Combatant} and a given {@link Sector}\n *\n * @author daniel\n */\npublic class SectorBonus {\n\n    /**\n     * the different types a {@link SectorBonus} consists of\n     *\n     * @author daniel\n     */\n    public enum BonusType {\n\n        /**\n         * bonus when shooting\n         */\n        ATTACK,\n        /**\n         * bonus when dodging\n         */\n        DEFENSE,\n        /**\n         * bonus damage when hitting an enemy\n         */\n        DAMAGE\n    }\n\n    /**\n     * bonus when shooting\n     */\n    public final int attackBonus;\n\n    /**\n     * bonus when dodging\n     */\n    public final int defendBonus;\n\n    /**\n     * bonus damage\n     */\n    public final int additionalDamage;\n\n    /**\n     * @param attackBonus\n     * @param defendBonus\n     * @param additionalDamage\n     */\n    public SectorBonus(final int attackBonus, final int defendBonus, final int additionalDamage) {\n        this.attackBonus = attackBonus;\n        this.defendBonus = defendBonus;\n        this.additionalDamage = additionalDamage;\n    }\n\n    /**\n     * @see java.lang.Object#toString()\n     */\n    @Override\n    public String toString() {\n        return \"Sectorbonus [attack=\" + attackBonus + \", defense=\" + defendBonus + \"]\";\n    }\n\n    /**\n     * @see java.lang.Object#hashCode()\n     */\n    @Override\n    public int hashCode() {\n        return 13 * attackBonus + 17 * defendBonus;\n    }\n\n    /**\n     * @see java.lang.Object#equals(java.lang.Object)\n     */\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!(obj instanceof SectorBonus)) {\n            return false;\n        }\n        final SectorBonus other = (SectorBonus) obj;\n        if (attackBonus != other.attackBonus || defendBonus != other.defendBonus) {\n            return false;\n        }\n        return true;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/model/SectorBonus_0Test.java",
		"test_prompt": "// SectorBonus_0Test.java\npackage de.outstare.fortbattleplayer.model;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SectorBonus}.\n* It contains ten unit test cases for the {@link SectorBonus#hashCode()} method.\n*/\nclass SectorBonus_0Test {"
	},
	{
		"original_code": "// SectorBonus.java\npackage de.outstare.fortbattleplayer.model;\n\n/**\n * The actual bonus for a given {@link Combatant} and a given {@link Sector}\n *\n * @author daniel\n */\npublic class SectorBonus {\n\n    /**\n     * the different types a {@link SectorBonus} consists of\n     *\n     * @author daniel\n     */\n    public enum BonusType {\n\n        /**\n         * bonus when shooting\n         */\n        ATTACK,\n        /**\n         * bonus when dodging\n         */\n        DEFENSE,\n        /**\n         * bonus damage when hitting an enemy\n         */\n        DAMAGE\n    }\n\n    /**\n     * bonus when shooting\n     */\n    public final int attackBonus;\n\n    /**\n     * bonus when dodging\n     */\n    public final int defendBonus;\n\n    /**\n     * bonus damage\n     */\n    public final int additionalDamage;\n\n    /**\n     * @param attackBonus\n     * @param defendBonus\n     * @param additionalDamage\n     */\n    public SectorBonus(final int attackBonus, final int defendBonus, final int additionalDamage) {\n        this.attackBonus = attackBonus;\n        this.defendBonus = defendBonus;\n        this.additionalDamage = additionalDamage;\n    }\n\n    /**\n     * @see java.lang.Object#toString()\n     */\n    @Override\n    public String toString() {\n        return \"Sectorbonus [attack=\" + attackBonus + \", defense=\" + defendBonus + \"]\";\n    }\n\n    /**\n     * @see java.lang.Object#hashCode()\n     */\n    @Override\n    public int hashCode() {\n        return 13 * attackBonus + 17 * defendBonus;\n    }\n\n    /**\n     * @see java.lang.Object#equals(java.lang.Object)\n     */\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!(obj instanceof SectorBonus)) {\n            return false;\n        }\n        final SectorBonus other = (SectorBonus) obj;\n        if (attackBonus != other.attackBonus || defendBonus != other.defendBonus) {\n            return false;\n        }\n        return true;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/model/SectorBonus_1Test.java",
		"test_prompt": "// SectorBonus_1Test.java\npackage de.outstare.fortbattleplayer.model;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SectorBonus}.\n* It contains ten unit test cases for the {@link SectorBonus#equals(Object)} method.\n*/\nclass SectorBonus_1Test {"
	},
	{
		"original_code": "// CombatantState.java\npackage de.outstare.fortbattleplayer.model;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\n/**\n * The state of a {@link Combatant}. An instance is immutable, so all modifying\n * methods return a new state.\n *\n * FIXME this class should not be public\n *\n * @author daniel\n */\npublic class CombatantState {\n\n    /**\n     * the current position on the battlefield\n     */\n    private final Area position;\n\n    /**\n     * the current amount of health-points\n     */\n    private final int health;\n\n    /**\n     * the place the {@link Combatant} wants to go to\n     */\n    private final Area target;\n\n    /**\n     * <p>\n     * if the human who controls the avatar is currently connected\n     * </p>\n     * <code>null</code> = unknown (used to ignore first offline event)\n     */\n    private final boolean isGamerOnline;\n\n    /**\n     * @param position\n     * @param health\n     * @param target\n     * @param gamerIsOnline\n     */\n    public CombatantState(final Area position, final int health, final Area target, final boolean gamerIsOnline) {\n        this.position = position;\n        this.health = health;\n        this.target = target;\n        isGamerOnline = gamerIsOnline;\n    }\n\n    /**\n     * creates a new state with the given position and a copy of the oldState\n     *\n     * @param position\n     * @param oldState\n     */\n    public CombatantState(final Area position, final CombatantState oldState) {\n        this(position, oldState.getHealth(), oldState.getTarget(), oldState.isGamerOnline());\n    }\n\n    /**\n     * creates a new state with the given health and a copy of the oldState\n     *\n     * @param health\n     * @param oldState\n     */\n    public CombatantState(final int health, final CombatantState oldState) {\n        this(oldState.getPosition(), health, oldState.getTarget(), oldState.isGamerOnline());\n    }\n\n    /**\n     * creates a new state with the given target and a copy of the oldState\n     *\n     * @param oldState\n     * @param target\n     */\n    public CombatantState(final CombatantState oldState, final Area target) {\n        this(oldState.getPosition(), oldState.getHealth(), target, oldState.isGamerOnline());\n    }\n\n    /**\n     * creates a new state with the given isOnline status and a copy of the\n     * oldState\n     *\n     * @param isOnline\n     * @param oldState\n     */\n    public CombatantState(final boolean isOnline, final CombatantState oldState) {\n        this(oldState.getPosition(), oldState.getHealth(), oldState.getTarget(), isOnline);\n    }\n\n    /**\n     * @param newPosition\n     * @return a new state object with the given position and else the same\n     *         attributes as this state\n     */\n    public CombatantState changePosition(final Area newPosition) {\n        return new CombatantState(newPosition, this);\n    }\n\n    /**\n     * @param amount\n     * @return a new state object with the health decreased by the given amount\n     *         and else the same attributes as this state\n     */\n    public CombatantState reduceHealthBy(final int amount) {\n        return new CombatantState(getHealth() - amount, this);\n    }\n\n    /**\n     * @param moveTarget\n     * @return a new state object with the given target and else the same\n     *         attributes as this state\n     */\n    public CombatantState changeTarget(final Area moveTarget) {\n        return new CombatantState(this, moveTarget);\n    }\n\n    /**\n     * @param isOnline\n     *            in the new state\n     * @return a new state object with the online state inverted and else the\n     *         same attributes as this state\n     */\n    public CombatantState setOnline(final boolean isOnline) {\n        return new CombatantState(isOnline, this);\n    }\n\n    /**\n     * @return the target\n     */\n    public Area getTarget() {\n        return target;\n    }\n\n    /**\n     * @return the position\n     */\n    public Area getPosition() {\n        return position;\n    }\n\n    /**\n     * @return the health\n     */\n    public int getHealth() {\n        return health;\n    }\n\n    /**\n     * @return the gamerIsOnline\n     */\n    public boolean isGamerOnline() {\n        return isGamerOnline;\n    }\n\n    /**\n     * @see java.lang.Object#toString()\n     */\n    @Override\n    public String toString() {\n        return getClass().getName() + \" position=\" + position + \", healt=\" + health + \", target=\" + target + \", online=\" + isGamerOnline;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/model/CombatantState_0Test.java",
		"test_prompt": "// CombatantState_0Test.java\npackage de.outstare.fortbattleplayer.model;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CombatantState}.\n* It contains ten unit test cases for the {@link CombatantState#changePosition(Area)} method.\n*/\nclass CombatantState_0Test {"
	},
	{
		"original_code": "// CombatantState.java\npackage de.outstare.fortbattleplayer.model;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\n/**\n * The state of a {@link Combatant}. An instance is immutable, so all modifying\n * methods return a new state.\n *\n * FIXME this class should not be public\n *\n * @author daniel\n */\npublic class CombatantState {\n\n    /**\n     * the current position on the battlefield\n     */\n    private final Area position;\n\n    /**\n     * the current amount of health-points\n     */\n    private final int health;\n\n    /**\n     * the place the {@link Combatant} wants to go to\n     */\n    private final Area target;\n\n    /**\n     * <p>\n     * if the human who controls the avatar is currently connected\n     * </p>\n     * <code>null</code> = unknown (used to ignore first offline event)\n     */\n    private final boolean isGamerOnline;\n\n    /**\n     * @param position\n     * @param health\n     * @param target\n     * @param gamerIsOnline\n     */\n    public CombatantState(final Area position, final int health, final Area target, final boolean gamerIsOnline) {\n        this.position = position;\n        this.health = health;\n        this.target = target;\n        isGamerOnline = gamerIsOnline;\n    }\n\n    /**\n     * creates a new state with the given position and a copy of the oldState\n     *\n     * @param position\n     * @param oldState\n     */\n    public CombatantState(final Area position, final CombatantState oldState) {\n        this(position, oldState.getHealth(), oldState.getTarget(), oldState.isGamerOnline());\n    }\n\n    /**\n     * creates a new state with the given health and a copy of the oldState\n     *\n     * @param health\n     * @param oldState\n     */\n    public CombatantState(final int health, final CombatantState oldState) {\n        this(oldState.getPosition(), health, oldState.getTarget(), oldState.isGamerOnline());\n    }\n\n    /**\n     * creates a new state with the given target and a copy of the oldState\n     *\n     * @param oldState\n     * @param target\n     */\n    public CombatantState(final CombatantState oldState, final Area target) {\n        this(oldState.getPosition(), oldState.getHealth(), target, oldState.isGamerOnline());\n    }\n\n    /**\n     * creates a new state with the given isOnline status and a copy of the\n     * oldState\n     *\n     * @param isOnline\n     * @param oldState\n     */\n    public CombatantState(final boolean isOnline, final CombatantState oldState) {\n        this(oldState.getPosition(), oldState.getHealth(), oldState.getTarget(), isOnline);\n    }\n\n    /**\n     * @param newPosition\n     * @return a new state object with the given position and else the same\n     *         attributes as this state\n     */\n    public CombatantState changePosition(final Area newPosition) {\n        return new CombatantState(newPosition, this);\n    }\n\n    /**\n     * @param amount\n     * @return a new state object with the health decreased by the given amount\n     *         and else the same attributes as this state\n     */\n    public CombatantState reduceHealthBy(final int amount) {\n        return new CombatantState(getHealth() - amount, this);\n    }\n\n    /**\n     * @param moveTarget\n     * @return a new state object with the given target and else the same\n     *         attributes as this state\n     */\n    public CombatantState changeTarget(final Area moveTarget) {\n        return new CombatantState(this, moveTarget);\n    }\n\n    /**\n     * @param isOnline\n     *            in the new state\n     * @return a new state object with the online state inverted and else the\n     *         same attributes as this state\n     */\n    public CombatantState setOnline(final boolean isOnline) {\n        return new CombatantState(isOnline, this);\n    }\n\n    /**\n     * @return the target\n     */\n    public Area getTarget() {\n        return target;\n    }\n\n    /**\n     * @return the position\n     */\n    public Area getPosition() {\n        return position;\n    }\n\n    /**\n     * @return the health\n     */\n    public int getHealth() {\n        return health;\n    }\n\n    /**\n     * @return the gamerIsOnline\n     */\n    public boolean isGamerOnline() {\n        return isGamerOnline;\n    }\n\n    /**\n     * @see java.lang.Object#toString()\n     */\n    @Override\n    public String toString() {\n        return getClass().getName() + \" position=\" + position + \", healt=\" + health + \", target=\" + target + \", online=\" + isGamerOnline;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/model/CombatantState_1Test.java",
		"test_prompt": "// CombatantState_1Test.java\npackage de.outstare.fortbattleplayer.model;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CombatantState}.\n* It contains ten unit test cases for the {@link CombatantState#reduceHealthBy(int)} method.\n*/\nclass CombatantState_1Test {"
	},
	{
		"original_code": "// CombatantState.java\npackage de.outstare.fortbattleplayer.model;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\n/**\n * The state of a {@link Combatant}. An instance is immutable, so all modifying\n * methods return a new state.\n *\n * FIXME this class should not be public\n *\n * @author daniel\n */\npublic class CombatantState {\n\n    /**\n     * the current position on the battlefield\n     */\n    private final Area position;\n\n    /**\n     * the current amount of health-points\n     */\n    private final int health;\n\n    /**\n     * the place the {@link Combatant} wants to go to\n     */\n    private final Area target;\n\n    /**\n     * <p>\n     * if the human who controls the avatar is currently connected\n     * </p>\n     * <code>null</code> = unknown (used to ignore first offline event)\n     */\n    private final boolean isGamerOnline;\n\n    /**\n     * @param position\n     * @param health\n     * @param target\n     * @param gamerIsOnline\n     */\n    public CombatantState(final Area position, final int health, final Area target, final boolean gamerIsOnline) {\n        this.position = position;\n        this.health = health;\n        this.target = target;\n        isGamerOnline = gamerIsOnline;\n    }\n\n    /**\n     * creates a new state with the given position and a copy of the oldState\n     *\n     * @param position\n     * @param oldState\n     */\n    public CombatantState(final Area position, final CombatantState oldState) {\n        this(position, oldState.getHealth(), oldState.getTarget(), oldState.isGamerOnline());\n    }\n\n    /**\n     * creates a new state with the given health and a copy of the oldState\n     *\n     * @param health\n     * @param oldState\n     */\n    public CombatantState(final int health, final CombatantState oldState) {\n        this(oldState.getPosition(), health, oldState.getTarget(), oldState.isGamerOnline());\n    }\n\n    /**\n     * creates a new state with the given target and a copy of the oldState\n     *\n     * @param oldState\n     * @param target\n     */\n    public CombatantState(final CombatantState oldState, final Area target) {\n        this(oldState.getPosition(), oldState.getHealth(), target, oldState.isGamerOnline());\n    }\n\n    /**\n     * creates a new state with the given isOnline status and a copy of the\n     * oldState\n     *\n     * @param isOnline\n     * @param oldState\n     */\n    public CombatantState(final boolean isOnline, final CombatantState oldState) {\n        this(oldState.getPosition(), oldState.getHealth(), oldState.getTarget(), isOnline);\n    }\n\n    /**\n     * @param newPosition\n     * @return a new state object with the given position and else the same\n     *         attributes as this state\n     */\n    public CombatantState changePosition(final Area newPosition) {\n        return new CombatantState(newPosition, this);\n    }\n\n    /**\n     * @param amount\n     * @return a new state object with the health decreased by the given amount\n     *         and else the same attributes as this state\n     */\n    public CombatantState reduceHealthBy(final int amount) {\n        return new CombatantState(getHealth() - amount, this);\n    }\n\n    /**\n     * @param moveTarget\n     * @return a new state object with the given target and else the same\n     *         attributes as this state\n     */\n    public CombatantState changeTarget(final Area moveTarget) {\n        return new CombatantState(this, moveTarget);\n    }\n\n    /**\n     * @param isOnline\n     *            in the new state\n     * @return a new state object with the online state inverted and else the\n     *         same attributes as this state\n     */\n    public CombatantState setOnline(final boolean isOnline) {\n        return new CombatantState(isOnline, this);\n    }\n\n    /**\n     * @return the target\n     */\n    public Area getTarget() {\n        return target;\n    }\n\n    /**\n     * @return the position\n     */\n    public Area getPosition() {\n        return position;\n    }\n\n    /**\n     * @return the health\n     */\n    public int getHealth() {\n        return health;\n    }\n\n    /**\n     * @return the gamerIsOnline\n     */\n    public boolean isGamerOnline() {\n        return isGamerOnline;\n    }\n\n    /**\n     * @see java.lang.Object#toString()\n     */\n    @Override\n    public String toString() {\n        return getClass().getName() + \" position=\" + position + \", healt=\" + health + \", target=\" + target + \", online=\" + isGamerOnline;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/model/CombatantState_2Test.java",
		"test_prompt": "// CombatantState_2Test.java\npackage de.outstare.fortbattleplayer.model;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CombatantState}.\n* It contains ten unit test cases for the {@link CombatantState#changeTarget(Area)} method.\n*/\nclass CombatantState_2Test {"
	},
	{
		"original_code": "// CombatantState.java\npackage de.outstare.fortbattleplayer.model;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\n/**\n * The state of a {@link Combatant}. An instance is immutable, so all modifying\n * methods return a new state.\n *\n * FIXME this class should not be public\n *\n * @author daniel\n */\npublic class CombatantState {\n\n    /**\n     * the current position on the battlefield\n     */\n    private final Area position;\n\n    /**\n     * the current amount of health-points\n     */\n    private final int health;\n\n    /**\n     * the place the {@link Combatant} wants to go to\n     */\n    private final Area target;\n\n    /**\n     * <p>\n     * if the human who controls the avatar is currently connected\n     * </p>\n     * <code>null</code> = unknown (used to ignore first offline event)\n     */\n    private final boolean isGamerOnline;\n\n    /**\n     * @param position\n     * @param health\n     * @param target\n     * @param gamerIsOnline\n     */\n    public CombatantState(final Area position, final int health, final Area target, final boolean gamerIsOnline) {\n        this.position = position;\n        this.health = health;\n        this.target = target;\n        isGamerOnline = gamerIsOnline;\n    }\n\n    /**\n     * creates a new state with the given position and a copy of the oldState\n     *\n     * @param position\n     * @param oldState\n     */\n    public CombatantState(final Area position, final CombatantState oldState) {\n        this(position, oldState.getHealth(), oldState.getTarget(), oldState.isGamerOnline());\n    }\n\n    /**\n     * creates a new state with the given health and a copy of the oldState\n     *\n     * @param health\n     * @param oldState\n     */\n    public CombatantState(final int health, final CombatantState oldState) {\n        this(oldState.getPosition(), health, oldState.getTarget(), oldState.isGamerOnline());\n    }\n\n    /**\n     * creates a new state with the given target and a copy of the oldState\n     *\n     * @param oldState\n     * @param target\n     */\n    public CombatantState(final CombatantState oldState, final Area target) {\n        this(oldState.getPosition(), oldState.getHealth(), target, oldState.isGamerOnline());\n    }\n\n    /**\n     * creates a new state with the given isOnline status and a copy of the\n     * oldState\n     *\n     * @param isOnline\n     * @param oldState\n     */\n    public CombatantState(final boolean isOnline, final CombatantState oldState) {\n        this(oldState.getPosition(), oldState.getHealth(), oldState.getTarget(), isOnline);\n    }\n\n    /**\n     * @param newPosition\n     * @return a new state object with the given position and else the same\n     *         attributes as this state\n     */\n    public CombatantState changePosition(final Area newPosition) {\n        return new CombatantState(newPosition, this);\n    }\n\n    /**\n     * @param amount\n     * @return a new state object with the health decreased by the given amount\n     *         and else the same attributes as this state\n     */\n    public CombatantState reduceHealthBy(final int amount) {\n        return new CombatantState(getHealth() - amount, this);\n    }\n\n    /**\n     * @param moveTarget\n     * @return a new state object with the given target and else the same\n     *         attributes as this state\n     */\n    public CombatantState changeTarget(final Area moveTarget) {\n        return new CombatantState(this, moveTarget);\n    }\n\n    /**\n     * @param isOnline\n     *            in the new state\n     * @return a new state object with the online state inverted and else the\n     *         same attributes as this state\n     */\n    public CombatantState setOnline(final boolean isOnline) {\n        return new CombatantState(isOnline, this);\n    }\n\n    /**\n     * @return the target\n     */\n    public Area getTarget() {\n        return target;\n    }\n\n    /**\n     * @return the position\n     */\n    public Area getPosition() {\n        return position;\n    }\n\n    /**\n     * @return the health\n     */\n    public int getHealth() {\n        return health;\n    }\n\n    /**\n     * @return the gamerIsOnline\n     */\n    public boolean isGamerOnline() {\n        return isGamerOnline;\n    }\n\n    /**\n     * @see java.lang.Object#toString()\n     */\n    @Override\n    public String toString() {\n        return getClass().getName() + \" position=\" + position + \", healt=\" + health + \", target=\" + target + \", online=\" + isGamerOnline;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/model/CombatantState_3Test.java",
		"test_prompt": "// CombatantState_3Test.java\npackage de.outstare.fortbattleplayer.model;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CombatantState}.\n* It contains ten unit test cases for the {@link CombatantState#isGamerOnline()} method.\n*/\nclass CombatantState_3Test {"
	},
	{
		"original_code": "// PlayerConfiguration.java\npackage de.outstare.fortbattleplayer.player;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport de.outstare.fortbattleplayer.Configuration;\n\n/**\n * An instance of this will be used by the player to hold its tunable\n * parameters.\n *\n * @author daniel\n */\npublic class PlayerConfiguration implements Cloneable {\n\n    /**\n     * a configuration which skips animation (used for purposes where the user\n     * should not see whats going on)\n     */\n    public static final PlayerConfiguration NO_DELAY = new PlayerConfiguration();\n\n    static {\n        NO_DELAY.ACTION_DELAY = 0;\n        NO_DELAY.PLAYER_DELAY = 0;\n        NO_DELAY.ROUND_DELAY = 0;\n        NO_DELAY.setShowMoveTargets(false);\n        NO_DELAY.setShowShootline(false);\n    }\n\n    /**\n     * this is used to control who currently does something with the player\n     */\n    private final Lock playLock = new ReentrantLock();\n\n    private final Set<PlayerConfigurationListener> listeners = new HashSet<PlayerConfigurationListener>();\n\n    /**\n     * current state of the player\n     */\n    private PlayerState state = PlayerState.STOP;\n\n    /**\n     * pause between two rounds in milliseconds\n     */\n    public volatile int ROUND_DELAY = Configuration.ROUND_DELAY;\n\n    /**\n     * pause between two players in a round in milliseconds\n     */\n    public volatile int PLAYER_DELAY = Configuration.PLAYER_DELAY;\n\n    /**\n     * pause between two actions in milliseconds\n     */\n    public volatile int ACTION_DELAY = Configuration.ACTION_DELAY;\n\n    /**\n     * draw a line to the point, where the player wants to go\n     */\n    private volatile boolean SHOW_MOVETARGETS = Configuration.SHOW_MOVETARGETS;\n\n    /**\n     * draw a line to the enemy ath wich the player shoots\n     */\n    private volatile boolean SHOW_SHOOTLINE = Configuration.SHOW_SHOOTLINE;\n\n    /**\n     * @param other\n     */\n    public void setTo(final PlayerConfiguration other) {\n        ROUND_DELAY = other.ROUND_DELAY;\n        PLAYER_DELAY = other.PLAYER_DELAY;\n        ACTION_DELAY = other.ACTION_DELAY;\n    }\n\n    /**\n     * @return a copy of this object\n     * @throws CloneNotSupportedException\n     */\n    public PlayerConfiguration copy() throws CloneNotSupportedException {\n        return (PlayerConfiguration) clone();\n    }\n\n    /**\n     * should only be called by {@link Battleplayer}!\n     *\n     * @param newState\n     */\n    synchronized void setState(final PlayerState newState) {\n        state = newState;\n    }\n\n    /**\n     * @return true if the player should be playing\n     */\n    public synchronized boolean isPlaying() {\n        return state == PlayerState.PLAY;\n    }\n\n    /**\n     * @return true if the player is hold\n     */\n    public synchronized boolean isPaused() {\n        return state == PlayerState.PAUSE;\n    }\n\n    /**\n     * @return true if the player is stopped\n     */\n    public synchronized boolean isStopped() {\n        return state == PlayerState.STOP;\n    }\n\n    /**\n     * exclusive use of the player\n     */\n    void lock() {\n        playLock.lock();\n    }\n\n    /**\n     * release the player\n     */\n    void unlock() {\n        playLock.unlock();\n    }\n\n    /**\n     * @return <code>true</code> if lines to movement targets should be\n     *         displayed\n     */\n    public boolean showMoveTargets() {\n        return SHOW_MOVETARGETS;\n    }\n\n    /**\n     * @param showMovetargets\n     */\n    public void setShowMoveTargets(final boolean showMovetargets) {\n        SHOW_MOVETARGETS = showMovetargets;\n        for (final PlayerConfigurationListener listener : listeners) {\n            listener.changedShowMoveTarget(SHOW_MOVETARGETS);\n        }\n    }\n\n    /**\n     * @return <code>true</code> if shooting lines should be displayed\n     */\n    public boolean showShootline() {\n        return SHOW_SHOOTLINE;\n    }\n\n    /**\n     * @param showShootline\n     */\n    public void setShowShootline(final boolean showShootline) {\n        SHOW_SHOOTLINE = showShootline;\n        for (final PlayerConfigurationListener listener : listeners) {\n            listener.changedShowShootingLine(SHOW_SHOOTLINE);\n        }\n    }\n\n    /**\n     * Adds a listener which will be notified about changes.\n     *\n     * @param listener\n     */\n    public void addListener(final PlayerConfigurationListener listener) {\n        listeners.add(listener);\n    }\n\n    /**\n     * Removes the listener from the registered ones.\n     *\n     * @param listener\n     */\n    public void removeListener(final PlayerConfigurationListener listener) {\n        listeners.remove(listener);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/player/PlayerConfiguration_0Test.java",
		"test_prompt": "// PlayerConfiguration_0Test.java\npackage de.outstare.fortbattleplayer.player;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport de.outstare.fortbattleplayer.Configuration;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PlayerConfiguration}.\n* It contains ten unit test cases for the {@link PlayerConfiguration#copy()} method.\n*/\nclass PlayerConfiguration_0Test {"
	},
	{
		"original_code": "// PlayerConfiguration.java\npackage de.outstare.fortbattleplayer.player;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport de.outstare.fortbattleplayer.Configuration;\n\n/**\n * An instance of this will be used by the player to hold its tunable\n * parameters.\n *\n * @author daniel\n */\npublic class PlayerConfiguration implements Cloneable {\n\n    /**\n     * a configuration which skips animation (used for purposes where the user\n     * should not see whats going on)\n     */\n    public static final PlayerConfiguration NO_DELAY = new PlayerConfiguration();\n\n    static {\n        NO_DELAY.ACTION_DELAY = 0;\n        NO_DELAY.PLAYER_DELAY = 0;\n        NO_DELAY.ROUND_DELAY = 0;\n        NO_DELAY.setShowMoveTargets(false);\n        NO_DELAY.setShowShootline(false);\n    }\n\n    /**\n     * this is used to control who currently does something with the player\n     */\n    private final Lock playLock = new ReentrantLock();\n\n    private final Set<PlayerConfigurationListener> listeners = new HashSet<PlayerConfigurationListener>();\n\n    /**\n     * current state of the player\n     */\n    private PlayerState state = PlayerState.STOP;\n\n    /**\n     * pause between two rounds in milliseconds\n     */\n    public volatile int ROUND_DELAY = Configuration.ROUND_DELAY;\n\n    /**\n     * pause between two players in a round in milliseconds\n     */\n    public volatile int PLAYER_DELAY = Configuration.PLAYER_DELAY;\n\n    /**\n     * pause between two actions in milliseconds\n     */\n    public volatile int ACTION_DELAY = Configuration.ACTION_DELAY;\n\n    /**\n     * draw a line to the point, where the player wants to go\n     */\n    private volatile boolean SHOW_MOVETARGETS = Configuration.SHOW_MOVETARGETS;\n\n    /**\n     * draw a line to the enemy ath wich the player shoots\n     */\n    private volatile boolean SHOW_SHOOTLINE = Configuration.SHOW_SHOOTLINE;\n\n    /**\n     * @param other\n     */\n    public void setTo(final PlayerConfiguration other) {\n        ROUND_DELAY = other.ROUND_DELAY;\n        PLAYER_DELAY = other.PLAYER_DELAY;\n        ACTION_DELAY = other.ACTION_DELAY;\n    }\n\n    /**\n     * @return a copy of this object\n     * @throws CloneNotSupportedException\n     */\n    public PlayerConfiguration copy() throws CloneNotSupportedException {\n        return (PlayerConfiguration) clone();\n    }\n\n    /**\n     * should only be called by {@link Battleplayer}!\n     *\n     * @param newState\n     */\n    synchronized void setState(final PlayerState newState) {\n        state = newState;\n    }\n\n    /**\n     * @return true if the player should be playing\n     */\n    public synchronized boolean isPlaying() {\n        return state == PlayerState.PLAY;\n    }\n\n    /**\n     * @return true if the player is hold\n     */\n    public synchronized boolean isPaused() {\n        return state == PlayerState.PAUSE;\n    }\n\n    /**\n     * @return true if the player is stopped\n     */\n    public synchronized boolean isStopped() {\n        return state == PlayerState.STOP;\n    }\n\n    /**\n     * exclusive use of the player\n     */\n    void lock() {\n        playLock.lock();\n    }\n\n    /**\n     * release the player\n     */\n    void unlock() {\n        playLock.unlock();\n    }\n\n    /**\n     * @return <code>true</code> if lines to movement targets should be\n     *         displayed\n     */\n    public boolean showMoveTargets() {\n        return SHOW_MOVETARGETS;\n    }\n\n    /**\n     * @param showMovetargets\n     */\n    public void setShowMoveTargets(final boolean showMovetargets) {\n        SHOW_MOVETARGETS = showMovetargets;\n        for (final PlayerConfigurationListener listener : listeners) {\n            listener.changedShowMoveTarget(SHOW_MOVETARGETS);\n        }\n    }\n\n    /**\n     * @return <code>true</code> if shooting lines should be displayed\n     */\n    public boolean showShootline() {\n        return SHOW_SHOOTLINE;\n    }\n\n    /**\n     * @param showShootline\n     */\n    public void setShowShootline(final boolean showShootline) {\n        SHOW_SHOOTLINE = showShootline;\n        for (final PlayerConfigurationListener listener : listeners) {\n            listener.changedShowShootingLine(SHOW_SHOOTLINE);\n        }\n    }\n\n    /**\n     * Adds a listener which will be notified about changes.\n     *\n     * @param listener\n     */\n    public void addListener(final PlayerConfigurationListener listener) {\n        listeners.add(listener);\n    }\n\n    /**\n     * Removes the listener from the registered ones.\n     *\n     * @param listener\n     */\n    public void removeListener(final PlayerConfigurationListener listener) {\n        listeners.remove(listener);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/player/PlayerConfiguration_1Test.java",
		"test_prompt": "// PlayerConfiguration_1Test.java\npackage de.outstare.fortbattleplayer.player;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport de.outstare.fortbattleplayer.Configuration;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PlayerConfiguration}.\n* It contains ten unit test cases for the {@link PlayerConfiguration#isPlaying()} method.\n*/\nclass PlayerConfiguration_1Test {"
	},
	{
		"original_code": "// PlayerConfiguration.java\npackage de.outstare.fortbattleplayer.player;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport de.outstare.fortbattleplayer.Configuration;\n\n/**\n * An instance of this will be used by the player to hold its tunable\n * parameters.\n *\n * @author daniel\n */\npublic class PlayerConfiguration implements Cloneable {\n\n    /**\n     * a configuration which skips animation (used for purposes where the user\n     * should not see whats going on)\n     */\n    public static final PlayerConfiguration NO_DELAY = new PlayerConfiguration();\n\n    static {\n        NO_DELAY.ACTION_DELAY = 0;\n        NO_DELAY.PLAYER_DELAY = 0;\n        NO_DELAY.ROUND_DELAY = 0;\n        NO_DELAY.setShowMoveTargets(false);\n        NO_DELAY.setShowShootline(false);\n    }\n\n    /**\n     * this is used to control who currently does something with the player\n     */\n    private final Lock playLock = new ReentrantLock();\n\n    private final Set<PlayerConfigurationListener> listeners = new HashSet<PlayerConfigurationListener>();\n\n    /**\n     * current state of the player\n     */\n    private PlayerState state = PlayerState.STOP;\n\n    /**\n     * pause between two rounds in milliseconds\n     */\n    public volatile int ROUND_DELAY = Configuration.ROUND_DELAY;\n\n    /**\n     * pause between two players in a round in milliseconds\n     */\n    public volatile int PLAYER_DELAY = Configuration.PLAYER_DELAY;\n\n    /**\n     * pause between two actions in milliseconds\n     */\n    public volatile int ACTION_DELAY = Configuration.ACTION_DELAY;\n\n    /**\n     * draw a line to the point, where the player wants to go\n     */\n    private volatile boolean SHOW_MOVETARGETS = Configuration.SHOW_MOVETARGETS;\n\n    /**\n     * draw a line to the enemy ath wich the player shoots\n     */\n    private volatile boolean SHOW_SHOOTLINE = Configuration.SHOW_SHOOTLINE;\n\n    /**\n     * @param other\n     */\n    public void setTo(final PlayerConfiguration other) {\n        ROUND_DELAY = other.ROUND_DELAY;\n        PLAYER_DELAY = other.PLAYER_DELAY;\n        ACTION_DELAY = other.ACTION_DELAY;\n    }\n\n    /**\n     * @return a copy of this object\n     * @throws CloneNotSupportedException\n     */\n    public PlayerConfiguration copy() throws CloneNotSupportedException {\n        return (PlayerConfiguration) clone();\n    }\n\n    /**\n     * should only be called by {@link Battleplayer}!\n     *\n     * @param newState\n     */\n    synchronized void setState(final PlayerState newState) {\n        state = newState;\n    }\n\n    /**\n     * @return true if the player should be playing\n     */\n    public synchronized boolean isPlaying() {\n        return state == PlayerState.PLAY;\n    }\n\n    /**\n     * @return true if the player is hold\n     */\n    public synchronized boolean isPaused() {\n        return state == PlayerState.PAUSE;\n    }\n\n    /**\n     * @return true if the player is stopped\n     */\n    public synchronized boolean isStopped() {\n        return state == PlayerState.STOP;\n    }\n\n    /**\n     * exclusive use of the player\n     */\n    void lock() {\n        playLock.lock();\n    }\n\n    /**\n     * release the player\n     */\n    void unlock() {\n        playLock.unlock();\n    }\n\n    /**\n     * @return <code>true</code> if lines to movement targets should be\n     *         displayed\n     */\n    public boolean showMoveTargets() {\n        return SHOW_MOVETARGETS;\n    }\n\n    /**\n     * @param showMovetargets\n     */\n    public void setShowMoveTargets(final boolean showMovetargets) {\n        SHOW_MOVETARGETS = showMovetargets;\n        for (final PlayerConfigurationListener listener : listeners) {\n            listener.changedShowMoveTarget(SHOW_MOVETARGETS);\n        }\n    }\n\n    /**\n     * @return <code>true</code> if shooting lines should be displayed\n     */\n    public boolean showShootline() {\n        return SHOW_SHOOTLINE;\n    }\n\n    /**\n     * @param showShootline\n     */\n    public void setShowShootline(final boolean showShootline) {\n        SHOW_SHOOTLINE = showShootline;\n        for (final PlayerConfigurationListener listener : listeners) {\n            listener.changedShowShootingLine(SHOW_SHOOTLINE);\n        }\n    }\n\n    /**\n     * Adds a listener which will be notified about changes.\n     *\n     * @param listener\n     */\n    public void addListener(final PlayerConfigurationListener listener) {\n        listeners.add(listener);\n    }\n\n    /**\n     * Removes the listener from the registered ones.\n     *\n     * @param listener\n     */\n    public void removeListener(final PlayerConfigurationListener listener) {\n        listeners.remove(listener);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/player/PlayerConfiguration_2Test.java",
		"test_prompt": "// PlayerConfiguration_2Test.java\npackage de.outstare.fortbattleplayer.player;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport de.outstare.fortbattleplayer.Configuration;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PlayerConfiguration}.\n* It contains ten unit test cases for the {@link PlayerConfiguration#isPaused()} method.\n*/\nclass PlayerConfiguration_2Test {"
	},
	{
		"original_code": "// PlayerConfiguration.java\npackage de.outstare.fortbattleplayer.player;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport de.outstare.fortbattleplayer.Configuration;\n\n/**\n * An instance of this will be used by the player to hold its tunable\n * parameters.\n *\n * @author daniel\n */\npublic class PlayerConfiguration implements Cloneable {\n\n    /**\n     * a configuration which skips animation (used for purposes where the user\n     * should not see whats going on)\n     */\n    public static final PlayerConfiguration NO_DELAY = new PlayerConfiguration();\n\n    static {\n        NO_DELAY.ACTION_DELAY = 0;\n        NO_DELAY.PLAYER_DELAY = 0;\n        NO_DELAY.ROUND_DELAY = 0;\n        NO_DELAY.setShowMoveTargets(false);\n        NO_DELAY.setShowShootline(false);\n    }\n\n    /**\n     * this is used to control who currently does something with the player\n     */\n    private final Lock playLock = new ReentrantLock();\n\n    private final Set<PlayerConfigurationListener> listeners = new HashSet<PlayerConfigurationListener>();\n\n    /**\n     * current state of the player\n     */\n    private PlayerState state = PlayerState.STOP;\n\n    /**\n     * pause between two rounds in milliseconds\n     */\n    public volatile int ROUND_DELAY = Configuration.ROUND_DELAY;\n\n    /**\n     * pause between two players in a round in milliseconds\n     */\n    public volatile int PLAYER_DELAY = Configuration.PLAYER_DELAY;\n\n    /**\n     * pause between two actions in milliseconds\n     */\n    public volatile int ACTION_DELAY = Configuration.ACTION_DELAY;\n\n    /**\n     * draw a line to the point, where the player wants to go\n     */\n    private volatile boolean SHOW_MOVETARGETS = Configuration.SHOW_MOVETARGETS;\n\n    /**\n     * draw a line to the enemy ath wich the player shoots\n     */\n    private volatile boolean SHOW_SHOOTLINE = Configuration.SHOW_SHOOTLINE;\n\n    /**\n     * @param other\n     */\n    public void setTo(final PlayerConfiguration other) {\n        ROUND_DELAY = other.ROUND_DELAY;\n        PLAYER_DELAY = other.PLAYER_DELAY;\n        ACTION_DELAY = other.ACTION_DELAY;\n    }\n\n    /**\n     * @return a copy of this object\n     * @throws CloneNotSupportedException\n     */\n    public PlayerConfiguration copy() throws CloneNotSupportedException {\n        return (PlayerConfiguration) clone();\n    }\n\n    /**\n     * should only be called by {@link Battleplayer}!\n     *\n     * @param newState\n     */\n    synchronized void setState(final PlayerState newState) {\n        state = newState;\n    }\n\n    /**\n     * @return true if the player should be playing\n     */\n    public synchronized boolean isPlaying() {\n        return state == PlayerState.PLAY;\n    }\n\n    /**\n     * @return true if the player is hold\n     */\n    public synchronized boolean isPaused() {\n        return state == PlayerState.PAUSE;\n    }\n\n    /**\n     * @return true if the player is stopped\n     */\n    public synchronized boolean isStopped() {\n        return state == PlayerState.STOP;\n    }\n\n    /**\n     * exclusive use of the player\n     */\n    void lock() {\n        playLock.lock();\n    }\n\n    /**\n     * release the player\n     */\n    void unlock() {\n        playLock.unlock();\n    }\n\n    /**\n     * @return <code>true</code> if lines to movement targets should be\n     *         displayed\n     */\n    public boolean showMoveTargets() {\n        return SHOW_MOVETARGETS;\n    }\n\n    /**\n     * @param showMovetargets\n     */\n    public void setShowMoveTargets(final boolean showMovetargets) {\n        SHOW_MOVETARGETS = showMovetargets;\n        for (final PlayerConfigurationListener listener : listeners) {\n            listener.changedShowMoveTarget(SHOW_MOVETARGETS);\n        }\n    }\n\n    /**\n     * @return <code>true</code> if shooting lines should be displayed\n     */\n    public boolean showShootline() {\n        return SHOW_SHOOTLINE;\n    }\n\n    /**\n     * @param showShootline\n     */\n    public void setShowShootline(final boolean showShootline) {\n        SHOW_SHOOTLINE = showShootline;\n        for (final PlayerConfigurationListener listener : listeners) {\n            listener.changedShowShootingLine(SHOW_SHOOTLINE);\n        }\n    }\n\n    /**\n     * Adds a listener which will be notified about changes.\n     *\n     * @param listener\n     */\n    public void addListener(final PlayerConfigurationListener listener) {\n        listeners.add(listener);\n    }\n\n    /**\n     * Removes the listener from the registered ones.\n     *\n     * @param listener\n     */\n    public void removeListener(final PlayerConfigurationListener listener) {\n        listeners.remove(listener);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/player/PlayerConfiguration_3Test.java",
		"test_prompt": "// PlayerConfiguration_3Test.java\npackage de.outstare.fortbattleplayer.player;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport de.outstare.fortbattleplayer.Configuration;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PlayerConfiguration}.\n* It contains ten unit test cases for the {@link PlayerConfiguration#isStopped()} method.\n*/\nclass PlayerConfiguration_3Test {"
	},
	{
		"original_code": "// PlayerConfiguration.java\npackage de.outstare.fortbattleplayer.player;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport de.outstare.fortbattleplayer.Configuration;\n\n/**\n * An instance of this will be used by the player to hold its tunable\n * parameters.\n *\n * @author daniel\n */\npublic class PlayerConfiguration implements Cloneable {\n\n    /**\n     * a configuration which skips animation (used for purposes where the user\n     * should not see whats going on)\n     */\n    public static final PlayerConfiguration NO_DELAY = new PlayerConfiguration();\n\n    static {\n        NO_DELAY.ACTION_DELAY = 0;\n        NO_DELAY.PLAYER_DELAY = 0;\n        NO_DELAY.ROUND_DELAY = 0;\n        NO_DELAY.setShowMoveTargets(false);\n        NO_DELAY.setShowShootline(false);\n    }\n\n    /**\n     * this is used to control who currently does something with the player\n     */\n    private final Lock playLock = new ReentrantLock();\n\n    private final Set<PlayerConfigurationListener> listeners = new HashSet<PlayerConfigurationListener>();\n\n    /**\n     * current state of the player\n     */\n    private PlayerState state = PlayerState.STOP;\n\n    /**\n     * pause between two rounds in milliseconds\n     */\n    public volatile int ROUND_DELAY = Configuration.ROUND_DELAY;\n\n    /**\n     * pause between two players in a round in milliseconds\n     */\n    public volatile int PLAYER_DELAY = Configuration.PLAYER_DELAY;\n\n    /**\n     * pause between two actions in milliseconds\n     */\n    public volatile int ACTION_DELAY = Configuration.ACTION_DELAY;\n\n    /**\n     * draw a line to the point, where the player wants to go\n     */\n    private volatile boolean SHOW_MOVETARGETS = Configuration.SHOW_MOVETARGETS;\n\n    /**\n     * draw a line to the enemy ath wich the player shoots\n     */\n    private volatile boolean SHOW_SHOOTLINE = Configuration.SHOW_SHOOTLINE;\n\n    /**\n     * @param other\n     */\n    public void setTo(final PlayerConfiguration other) {\n        ROUND_DELAY = other.ROUND_DELAY;\n        PLAYER_DELAY = other.PLAYER_DELAY;\n        ACTION_DELAY = other.ACTION_DELAY;\n    }\n\n    /**\n     * @return a copy of this object\n     * @throws CloneNotSupportedException\n     */\n    public PlayerConfiguration copy() throws CloneNotSupportedException {\n        return (PlayerConfiguration) clone();\n    }\n\n    /**\n     * should only be called by {@link Battleplayer}!\n     *\n     * @param newState\n     */\n    synchronized void setState(final PlayerState newState) {\n        state = newState;\n    }\n\n    /**\n     * @return true if the player should be playing\n     */\n    public synchronized boolean isPlaying() {\n        return state == PlayerState.PLAY;\n    }\n\n    /**\n     * @return true if the player is hold\n     */\n    public synchronized boolean isPaused() {\n        return state == PlayerState.PAUSE;\n    }\n\n    /**\n     * @return true if the player is stopped\n     */\n    public synchronized boolean isStopped() {\n        return state == PlayerState.STOP;\n    }\n\n    /**\n     * exclusive use of the player\n     */\n    void lock() {\n        playLock.lock();\n    }\n\n    /**\n     * release the player\n     */\n    void unlock() {\n        playLock.unlock();\n    }\n\n    /**\n     * @return <code>true</code> if lines to movement targets should be\n     *         displayed\n     */\n    public boolean showMoveTargets() {\n        return SHOW_MOVETARGETS;\n    }\n\n    /**\n     * @param showMovetargets\n     */\n    public void setShowMoveTargets(final boolean showMovetargets) {\n        SHOW_MOVETARGETS = showMovetargets;\n        for (final PlayerConfigurationListener listener : listeners) {\n            listener.changedShowMoveTarget(SHOW_MOVETARGETS);\n        }\n    }\n\n    /**\n     * @return <code>true</code> if shooting lines should be displayed\n     */\n    public boolean showShootline() {\n        return SHOW_SHOOTLINE;\n    }\n\n    /**\n     * @param showShootline\n     */\n    public void setShowShootline(final boolean showShootline) {\n        SHOW_SHOOTLINE = showShootline;\n        for (final PlayerConfigurationListener listener : listeners) {\n            listener.changedShowShootingLine(SHOW_SHOOTLINE);\n        }\n    }\n\n    /**\n     * Adds a listener which will be notified about changes.\n     *\n     * @param listener\n     */\n    public void addListener(final PlayerConfigurationListener listener) {\n        listeners.add(listener);\n    }\n\n    /**\n     * Removes the listener from the registered ones.\n     *\n     * @param listener\n     */\n    public void removeListener(final PlayerConfigurationListener listener) {\n        listeners.remove(listener);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/player/PlayerConfiguration_4Test.java",
		"test_prompt": "// PlayerConfiguration_4Test.java\npackage de.outstare.fortbattleplayer.player;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport de.outstare.fortbattleplayer.Configuration;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PlayerConfiguration}.\n* It contains ten unit test cases for the {@link PlayerConfiguration#showMoveTargets()} method.\n*/\nclass PlayerConfiguration_4Test {"
	},
	{
		"original_code": "// PlayerConfiguration.java\npackage de.outstare.fortbattleplayer.player;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport de.outstare.fortbattleplayer.Configuration;\n\n/**\n * An instance of this will be used by the player to hold its tunable\n * parameters.\n *\n * @author daniel\n */\npublic class PlayerConfiguration implements Cloneable {\n\n    /**\n     * a configuration which skips animation (used for purposes where the user\n     * should not see whats going on)\n     */\n    public static final PlayerConfiguration NO_DELAY = new PlayerConfiguration();\n\n    static {\n        NO_DELAY.ACTION_DELAY = 0;\n        NO_DELAY.PLAYER_DELAY = 0;\n        NO_DELAY.ROUND_DELAY = 0;\n        NO_DELAY.setShowMoveTargets(false);\n        NO_DELAY.setShowShootline(false);\n    }\n\n    /**\n     * this is used to control who currently does something with the player\n     */\n    private final Lock playLock = new ReentrantLock();\n\n    private final Set<PlayerConfigurationListener> listeners = new HashSet<PlayerConfigurationListener>();\n\n    /**\n     * current state of the player\n     */\n    private PlayerState state = PlayerState.STOP;\n\n    /**\n     * pause between two rounds in milliseconds\n     */\n    public volatile int ROUND_DELAY = Configuration.ROUND_DELAY;\n\n    /**\n     * pause between two players in a round in milliseconds\n     */\n    public volatile int PLAYER_DELAY = Configuration.PLAYER_DELAY;\n\n    /**\n     * pause between two actions in milliseconds\n     */\n    public volatile int ACTION_DELAY = Configuration.ACTION_DELAY;\n\n    /**\n     * draw a line to the point, where the player wants to go\n     */\n    private volatile boolean SHOW_MOVETARGETS = Configuration.SHOW_MOVETARGETS;\n\n    /**\n     * draw a line to the enemy ath wich the player shoots\n     */\n    private volatile boolean SHOW_SHOOTLINE = Configuration.SHOW_SHOOTLINE;\n\n    /**\n     * @param other\n     */\n    public void setTo(final PlayerConfiguration other) {\n        ROUND_DELAY = other.ROUND_DELAY;\n        PLAYER_DELAY = other.PLAYER_DELAY;\n        ACTION_DELAY = other.ACTION_DELAY;\n    }\n\n    /**\n     * @return a copy of this object\n     * @throws CloneNotSupportedException\n     */\n    public PlayerConfiguration copy() throws CloneNotSupportedException {\n        return (PlayerConfiguration) clone();\n    }\n\n    /**\n     * should only be called by {@link Battleplayer}!\n     *\n     * @param newState\n     */\n    synchronized void setState(final PlayerState newState) {\n        state = newState;\n    }\n\n    /**\n     * @return true if the player should be playing\n     */\n    public synchronized boolean isPlaying() {\n        return state == PlayerState.PLAY;\n    }\n\n    /**\n     * @return true if the player is hold\n     */\n    public synchronized boolean isPaused() {\n        return state == PlayerState.PAUSE;\n    }\n\n    /**\n     * @return true if the player is stopped\n     */\n    public synchronized boolean isStopped() {\n        return state == PlayerState.STOP;\n    }\n\n    /**\n     * exclusive use of the player\n     */\n    void lock() {\n        playLock.lock();\n    }\n\n    /**\n     * release the player\n     */\n    void unlock() {\n        playLock.unlock();\n    }\n\n    /**\n     * @return <code>true</code> if lines to movement targets should be\n     *         displayed\n     */\n    public boolean showMoveTargets() {\n        return SHOW_MOVETARGETS;\n    }\n\n    /**\n     * @param showMovetargets\n     */\n    public void setShowMoveTargets(final boolean showMovetargets) {\n        SHOW_MOVETARGETS = showMovetargets;\n        for (final PlayerConfigurationListener listener : listeners) {\n            listener.changedShowMoveTarget(SHOW_MOVETARGETS);\n        }\n    }\n\n    /**\n     * @return <code>true</code> if shooting lines should be displayed\n     */\n    public boolean showShootline() {\n        return SHOW_SHOOTLINE;\n    }\n\n    /**\n     * @param showShootline\n     */\n    public void setShowShootline(final boolean showShootline) {\n        SHOW_SHOOTLINE = showShootline;\n        for (final PlayerConfigurationListener listener : listeners) {\n            listener.changedShowShootingLine(SHOW_SHOOTLINE);\n        }\n    }\n\n    /**\n     * Adds a listener which will be notified about changes.\n     *\n     * @param listener\n     */\n    public void addListener(final PlayerConfigurationListener listener) {\n        listeners.add(listener);\n    }\n\n    /**\n     * Removes the listener from the registered ones.\n     *\n     * @param listener\n     */\n    public void removeListener(final PlayerConfigurationListener listener) {\n        listeners.remove(listener);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/player/PlayerConfiguration_5Test.java",
		"test_prompt": "// PlayerConfiguration_5Test.java\npackage de.outstare.fortbattleplayer.player;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport de.outstare.fortbattleplayer.Configuration;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PlayerConfiguration}.\n* It contains ten unit test cases for the {@link PlayerConfiguration#showShootline()} method.\n*/\nclass PlayerConfiguration_5Test {"
	},
	{
		"original_code": "// Battleplan.java\npackage de.outstare.fortbattleplayer.player;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.Collection;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.logging.Logger;\n\n/**\n * A plan which determines each step of the battle. A battle is divided into\n * {@link Round}s.\n *\n * @author daniel\n */\npublic class Battleplan {\n\n    private static final transient Logger LOG = Logger.getLogger(Battleplan.class.getName());\n\n    private final SortedMap<Integer, Round> rounds = new TreeMap<Integer, Round>();\n\n    /**\n     * Create a new plan with the given rounds\n     *\n     * @param roundsOfPlan\n     */\n    public Battleplan(final Collection<Round> roundsOfPlan) {\n        mapRoundsToNumbers(roundsOfPlan);\n    }\n\n    /**\n     * @param roundsOfPlan\n     */\n    private void mapRoundsToNumbers(final Collection<Round> roundsOfPlan) {\n        for (final Round round : roundsOfPlan) {\n            final int no = round.getNo();\n            final Integer roundNo = Integer.valueOf(no);\n            if (rounds.containsKey(roundNo)) {\n                LOG.warning(\"multiple rounds with number \" + roundNo + \"! overwriting\");\n            }\n            rounds.put(roundNo, round);\n        }\n    }\n\n    /**\n     * @return the number of rounds this plan has\n     */\n    public int numberOfRounds() {\n        return rounds.size();\n    }\n\n    /**\n     * executes the given {@link Round} of this plan\n     *\n     * @param roundNo\n     *            0 <= roundNo <= numberOfRounds()\n     * @param config\n     */\n    public void executeRound(final int roundNo, final PlayerConfiguration config) {\n        getRound(roundNo).execute(config);\n    }\n\n    /**\n     * @param roundNo\n     * @return\n     * @throws IllegalArgumentException\n     */\n    private Round getRound(final int roundNo) throws IllegalArgumentException {\n        final Integer roundKey = Integer.valueOf(roundNo);\n        if (!rounds.containsKey(roundKey)) {\n            throw new IllegalArgumentException(\"the given round number does not exist: \" + roundNo);\n        }\n        final Round round = rounds.get(roundKey);\n        return round;\n    }\n\n    /**\n     * @param no\n     * @return <code>true</code> if this plan contains a round with the given\n     *         number\n     */\n    public boolean hasRoundNo(final int no) {\n        final Integer roundKey = Integer.valueOf(no);\n        return rounds.containsKey(roundKey);\n    }\n\n    /**\n     * @param roundNo\n     */\n    public void resetToRound(final int roundNo) {\n        if (hasRoundNo(roundNo)) {\n            getRound(roundNo).setInitialState();\n        }\n    }\n\n    /**\n     * @param roundNo\n     * @return <code>true</code> if more rounds follow after the given round\n     *         number.\n     */\n    public boolean hasMoreRounds(final int roundNo) {\n        return !getRemainingRounds(roundNo).isEmpty();\n    }\n\n    /**\n     * @require hasMoreRounds(currentRoundNo)\n     * @param currentRoundNo\n     * @return the number of the following round\n     */\n    public int getNextRound(final int currentRoundNo) {\n        final SortedMap<Integer, Round> remainingRounds = getRemainingRounds(currentRoundNo);\n        assert remainingRounds.size() > 0 : \"more rounds must exist!\";\n        return remainingRounds.firstKey().intValue();\n    }\n\n    /**\n     * @param currentRoundNo\n     * @return all rounds that follow after the given round number\n     */\n    private SortedMap<Integer, Round> getRemainingRounds(final int currentRoundNo) {\n        final Integer nextRoundNo = Integer.valueOf(currentRoundNo + 1);\n        final SortedMap<Integer, Round> remainingRounds = rounds.tailMap(nextRoundNo);\n        return remainingRounds;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/player/Battleplan_0Test.java",
		"test_prompt": "// Battleplan_0Test.java\npackage de.outstare.fortbattleplayer.player;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.Collection;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.logging.Logger;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Battleplan}.\n* It contains ten unit test cases for the {@link Battleplan#numberOfRounds()} method.\n*/\nclass Battleplan_0Test {"
	},
	{
		"original_code": "// Battleplan.java\npackage de.outstare.fortbattleplayer.player;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.Collection;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.logging.Logger;\n\n/**\n * A plan which determines each step of the battle. A battle is divided into\n * {@link Round}s.\n *\n * @author daniel\n */\npublic class Battleplan {\n\n    private static final transient Logger LOG = Logger.getLogger(Battleplan.class.getName());\n\n    private final SortedMap<Integer, Round> rounds = new TreeMap<Integer, Round>();\n\n    /**\n     * Create a new plan with the given rounds\n     *\n     * @param roundsOfPlan\n     */\n    public Battleplan(final Collection<Round> roundsOfPlan) {\n        mapRoundsToNumbers(roundsOfPlan);\n    }\n\n    /**\n     * @param roundsOfPlan\n     */\n    private void mapRoundsToNumbers(final Collection<Round> roundsOfPlan) {\n        for (final Round round : roundsOfPlan) {\n            final int no = round.getNo();\n            final Integer roundNo = Integer.valueOf(no);\n            if (rounds.containsKey(roundNo)) {\n                LOG.warning(\"multiple rounds with number \" + roundNo + \"! overwriting\");\n            }\n            rounds.put(roundNo, round);\n        }\n    }\n\n    /**\n     * @return the number of rounds this plan has\n     */\n    public int numberOfRounds() {\n        return rounds.size();\n    }\n\n    /**\n     * executes the given {@link Round} of this plan\n     *\n     * @param roundNo\n     *            0 <= roundNo <= numberOfRounds()\n     * @param config\n     */\n    public void executeRound(final int roundNo, final PlayerConfiguration config) {\n        getRound(roundNo).execute(config);\n    }\n\n    /**\n     * @param roundNo\n     * @return\n     * @throws IllegalArgumentException\n     */\n    private Round getRound(final int roundNo) throws IllegalArgumentException {\n        final Integer roundKey = Integer.valueOf(roundNo);\n        if (!rounds.containsKey(roundKey)) {\n            throw new IllegalArgumentException(\"the given round number does not exist: \" + roundNo);\n        }\n        final Round round = rounds.get(roundKey);\n        return round;\n    }\n\n    /**\n     * @param no\n     * @return <code>true</code> if this plan contains a round with the given\n     *         number\n     */\n    public boolean hasRoundNo(final int no) {\n        final Integer roundKey = Integer.valueOf(no);\n        return rounds.containsKey(roundKey);\n    }\n\n    /**\n     * @param roundNo\n     */\n    public void resetToRound(final int roundNo) {\n        if (hasRoundNo(roundNo)) {\n            getRound(roundNo).setInitialState();\n        }\n    }\n\n    /**\n     * @param roundNo\n     * @return <code>true</code> if more rounds follow after the given round\n     *         number.\n     */\n    public boolean hasMoreRounds(final int roundNo) {\n        return !getRemainingRounds(roundNo).isEmpty();\n    }\n\n    /**\n     * @require hasMoreRounds(currentRoundNo)\n     * @param currentRoundNo\n     * @return the number of the following round\n     */\n    public int getNextRound(final int currentRoundNo) {\n        final SortedMap<Integer, Round> remainingRounds = getRemainingRounds(currentRoundNo);\n        assert remainingRounds.size() > 0 : \"more rounds must exist!\";\n        return remainingRounds.firstKey().intValue();\n    }\n\n    /**\n     * @param currentRoundNo\n     * @return all rounds that follow after the given round number\n     */\n    private SortedMap<Integer, Round> getRemainingRounds(final int currentRoundNo) {\n        final Integer nextRoundNo = Integer.valueOf(currentRoundNo + 1);\n        final SortedMap<Integer, Round> remainingRounds = rounds.tailMap(nextRoundNo);\n        return remainingRounds;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/player/Battleplan_1Test.java",
		"test_prompt": "// Battleplan_1Test.java\npackage de.outstare.fortbattleplayer.player;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.Collection;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.logging.Logger;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Battleplan}.\n* It contains ten unit test cases for the {@link Battleplan#hasRoundNo(int)} method.\n*/\nclass Battleplan_1Test {"
	},
	{
		"original_code": "// Battleplan.java\npackage de.outstare.fortbattleplayer.player;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.Collection;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.logging.Logger;\n\n/**\n * A plan which determines each step of the battle. A battle is divided into\n * {@link Round}s.\n *\n * @author daniel\n */\npublic class Battleplan {\n\n    private static final transient Logger LOG = Logger.getLogger(Battleplan.class.getName());\n\n    private final SortedMap<Integer, Round> rounds = new TreeMap<Integer, Round>();\n\n    /**\n     * Create a new plan with the given rounds\n     *\n     * @param roundsOfPlan\n     */\n    public Battleplan(final Collection<Round> roundsOfPlan) {\n        mapRoundsToNumbers(roundsOfPlan);\n    }\n\n    /**\n     * @param roundsOfPlan\n     */\n    private void mapRoundsToNumbers(final Collection<Round> roundsOfPlan) {\n        for (final Round round : roundsOfPlan) {\n            final int no = round.getNo();\n            final Integer roundNo = Integer.valueOf(no);\n            if (rounds.containsKey(roundNo)) {\n                LOG.warning(\"multiple rounds with number \" + roundNo + \"! overwriting\");\n            }\n            rounds.put(roundNo, round);\n        }\n    }\n\n    /**\n     * @return the number of rounds this plan has\n     */\n    public int numberOfRounds() {\n        return rounds.size();\n    }\n\n    /**\n     * executes the given {@link Round} of this plan\n     *\n     * @param roundNo\n     *            0 <= roundNo <= numberOfRounds()\n     * @param config\n     */\n    public void executeRound(final int roundNo, final PlayerConfiguration config) {\n        getRound(roundNo).execute(config);\n    }\n\n    /**\n     * @param roundNo\n     * @return\n     * @throws IllegalArgumentException\n     */\n    private Round getRound(final int roundNo) throws IllegalArgumentException {\n        final Integer roundKey = Integer.valueOf(roundNo);\n        if (!rounds.containsKey(roundKey)) {\n            throw new IllegalArgumentException(\"the given round number does not exist: \" + roundNo);\n        }\n        final Round round = rounds.get(roundKey);\n        return round;\n    }\n\n    /**\n     * @param no\n     * @return <code>true</code> if this plan contains a round with the given\n     *         number\n     */\n    public boolean hasRoundNo(final int no) {\n        final Integer roundKey = Integer.valueOf(no);\n        return rounds.containsKey(roundKey);\n    }\n\n    /**\n     * @param roundNo\n     */\n    public void resetToRound(final int roundNo) {\n        if (hasRoundNo(roundNo)) {\n            getRound(roundNo).setInitialState();\n        }\n    }\n\n    /**\n     * @param roundNo\n     * @return <code>true</code> if more rounds follow after the given round\n     *         number.\n     */\n    public boolean hasMoreRounds(final int roundNo) {\n        return !getRemainingRounds(roundNo).isEmpty();\n    }\n\n    /**\n     * @require hasMoreRounds(currentRoundNo)\n     * @param currentRoundNo\n     * @return the number of the following round\n     */\n    public int getNextRound(final int currentRoundNo) {\n        final SortedMap<Integer, Round> remainingRounds = getRemainingRounds(currentRoundNo);\n        assert remainingRounds.size() > 0 : \"more rounds must exist!\";\n        return remainingRounds.firstKey().intValue();\n    }\n\n    /**\n     * @param currentRoundNo\n     * @return all rounds that follow after the given round number\n     */\n    private SortedMap<Integer, Round> getRemainingRounds(final int currentRoundNo) {\n        final Integer nextRoundNo = Integer.valueOf(currentRoundNo + 1);\n        final SortedMap<Integer, Round> remainingRounds = rounds.tailMap(nextRoundNo);\n        return remainingRounds;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/player/Battleplan_2Test.java",
		"test_prompt": "// Battleplan_2Test.java\npackage de.outstare.fortbattleplayer.player;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.Collection;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.logging.Logger;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Battleplan}.\n* It contains ten unit test cases for the {@link Battleplan#hasMoreRounds(int)} method.\n*/\nclass Battleplan_2Test {"
	},
	{
		"original_code": "// Battleplayer.java\npackage de.outstare.fortbattleplayer.player;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Combatant;\n\n/**\n * A {@link Battleplayer} controls the battle. It is a puppet player controlling\n * the behavior of the {@link Combatant}s.\n *\n * @author daniel\n */\npublic class Battleplayer implements Player {\n\n    private static final transient Logger LOG = Logger.getLogger(Battleplayer.class.getName());\n\n    private final Battleplan plan;\n\n    private final Set<RoundListener> listeners = new HashSet<RoundListener>();\n\n    private boolean isPaused = false;\n\n    /**\n     * round numbers may not be sequential (this variable is also used for\n     * locking during a round)\n     */\n    private int currentRoundNo;\n\n    private volatile boolean isPlaying = false;\n\n    private volatile boolean shouldStop = false;\n\n    /**\n     * controls some aspects of the behavior of the player\n     */\n    public final PlayerConfiguration config;\n\n    /**\n     * @param plan\n     * @param config\n     */\n    public Battleplayer(final Battleplan plan, final PlayerConfiguration config) {\n        this.plan = plan;\n        this.config = config;\n        if (!plan.hasMoreRounds(0)) {\n            throw new IllegalStateException(\"Cannot play a battle without rounds!\");\n        }\n        currentRoundNo = plan.getNextRound(0);\n    }\n\n    /**\n     * @param plan\n     */\n    public Battleplayer(final Battleplan plan) {\n        this(plan, new PlayerConfiguration());\n    }\n\n    /**\n     * let the battle begin! The whole battle is done by executing the\n     * {@link Battleplan}.\n     */\n    public void play() {\n        isPlaying = true;\n        LOG.info(\"now playing\");\n        while (!shouldStop) {\n            playCurrentRound(currentRoundNo);\n            if (plan.hasMoreRounds(currentRoundNo)) {\n                currentRoundNo = plan.getNextRound(currentRoundNo);\n            } else {\n                break;\n            }\n        }\n        shouldStop = false;\n        isPlaying = false;\n        LOG.info(\"stopped playing\");\n    }\n\n    /**\n     * blocks until current round has ended\n     *\n     * @see de.outstare.fortbattleplayer.player.Player#gotoRound(de.outstare.fortbattleplayer.player.Round)\n     */\n    public void gotoRound(final int i) {\n        assert plan.hasRoundNo(i) : \"round with number \" + i + \" must exist!\";\n        stop();\n        while (isPlaying) {\n            try {\n                LOG.fine(\"waiting for round \" + currentRoundNo + \" to end to go to round \" + i);\n                Thread.sleep(500);\n            } catch (final InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        synchronized (this) {\n            currentRoundNo = i;\n        }\n        plan.resetToRound(currentRoundNo);\n    }\n\n    /**\n     * executes the round of the internal state\n     */\n    private void playCurrentRound(final int roundNo) {\n        fireNewRoundEvent(roundNo);\n        plan.executeRound(roundNo, config);\n        delayNextRound();\n    }\n\n    /**\n     * wait the time given in {@link PlayerConfiguration#ROUND_DELAY}\n     */\n    private void delayNextRound() {\n        try {\n            Thread.sleep(config.ROUND_DELAY);\n        } catch (final InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * tell all listeners that a new round will start now\n     *\n     * @param roundNo\n     */\n    private void fireNewRoundEvent(final int roundNo) {\n        for (final RoundListener listener : listeners) {\n            listener.nextRound(roundNo);\n        }\n    }\n\n    /**\n     * @param listener\n     */\n    public void addRoundListener(final RoundListener listener) {\n        listeners.add(listener);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.player.Player#stop()\n     */\n    public void stop() {\n        if (isPlaying) {\n            LOG.fine(\"stopping\");\n            shouldStop = true;\n        } else {\n            LOG.fine(\"already stopped\");\n        }\n    }\n\n    /**\n     * A RoundListener waits for Round events.\n     *\n     * @author daniel\n     */\n    public static interface RoundListener {\n\n        /**\n         * a new round will begin immediatly\n         *\n         * @param roundNo\n         */\n        void nextRound(int roundNo);\n    }\n\n    /**\n     * @return the number of rounds this player shows\n     */\n    public int numberOfRounds() {\n        return plan.numberOfRounds();\n    }\n\n    /**\n     * toggles pause which holds playing rounds. if this player is currently\n     * paused can be checked with isPaused()\n     */\n    public void pause() {\n        if (isPaused) {\n            config.unlock();\n            isPaused = false;\n        } else {\n            config.lock();\n            isPaused = true;\n        }\n    }\n\n    /**\n     * @return <code>true</code> if this player is playing and is currently hold\n     */\n    public boolean isPaused() {\n        return isPaused;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.player.Player#getRoundNumbers()\n     */\n    public List<Integer> getRoundNumbers() {\n        // always generating a new list\n        final List<Integer> rounds = new ArrayList<Integer>(plan.numberOfRounds());\n        // check if first round exists\n        final int firstRound = 0;\n        if (plan.hasRoundNo(firstRound)) {\n            rounds.add(Integer.valueOf(firstRound));\n        }\n        // add all following rounds\n        int roundNo;\n        for (roundNo = plan.getNextRound(firstRound); plan.hasMoreRounds(roundNo); roundNo = plan.getNextRound(roundNo)) {\n            rounds.add(Integer.valueOf(roundNo));\n        }\n        // add last round (has no round after it)\n        rounds.add(Integer.valueOf(roundNo));\n        return rounds;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/player/Battleplayer_0Test.java",
		"test_prompt": "// Battleplayer_0Test.java\npackage de.outstare.fortbattleplayer.player;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Battleplayer}.\n* It contains ten unit test cases for the {@link Battleplayer#numberOfRounds()} method.\n*/\nclass Battleplayer_0Test {"
	},
	{
		"original_code": "// Battleplayer.java\npackage de.outstare.fortbattleplayer.player;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Combatant;\n\n/**\n * A {@link Battleplayer} controls the battle. It is a puppet player controlling\n * the behavior of the {@link Combatant}s.\n *\n * @author daniel\n */\npublic class Battleplayer implements Player {\n\n    private static final transient Logger LOG = Logger.getLogger(Battleplayer.class.getName());\n\n    private final Battleplan plan;\n\n    private final Set<RoundListener> listeners = new HashSet<RoundListener>();\n\n    private boolean isPaused = false;\n\n    /**\n     * round numbers may not be sequential (this variable is also used for\n     * locking during a round)\n     */\n    private int currentRoundNo;\n\n    private volatile boolean isPlaying = false;\n\n    private volatile boolean shouldStop = false;\n\n    /**\n     * controls some aspects of the behavior of the player\n     */\n    public final PlayerConfiguration config;\n\n    /**\n     * @param plan\n     * @param config\n     */\n    public Battleplayer(final Battleplan plan, final PlayerConfiguration config) {\n        this.plan = plan;\n        this.config = config;\n        if (!plan.hasMoreRounds(0)) {\n            throw new IllegalStateException(\"Cannot play a battle without rounds!\");\n        }\n        currentRoundNo = plan.getNextRound(0);\n    }\n\n    /**\n     * @param plan\n     */\n    public Battleplayer(final Battleplan plan) {\n        this(plan, new PlayerConfiguration());\n    }\n\n    /**\n     * let the battle begin! The whole battle is done by executing the\n     * {@link Battleplan}.\n     */\n    public void play() {\n        isPlaying = true;\n        LOG.info(\"now playing\");\n        while (!shouldStop) {\n            playCurrentRound(currentRoundNo);\n            if (plan.hasMoreRounds(currentRoundNo)) {\n                currentRoundNo = plan.getNextRound(currentRoundNo);\n            } else {\n                break;\n            }\n        }\n        shouldStop = false;\n        isPlaying = false;\n        LOG.info(\"stopped playing\");\n    }\n\n    /**\n     * blocks until current round has ended\n     *\n     * @see de.outstare.fortbattleplayer.player.Player#gotoRound(de.outstare.fortbattleplayer.player.Round)\n     */\n    public void gotoRound(final int i) {\n        assert plan.hasRoundNo(i) : \"round with number \" + i + \" must exist!\";\n        stop();\n        while (isPlaying) {\n            try {\n                LOG.fine(\"waiting for round \" + currentRoundNo + \" to end to go to round \" + i);\n                Thread.sleep(500);\n            } catch (final InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        synchronized (this) {\n            currentRoundNo = i;\n        }\n        plan.resetToRound(currentRoundNo);\n    }\n\n    /**\n     * executes the round of the internal state\n     */\n    private void playCurrentRound(final int roundNo) {\n        fireNewRoundEvent(roundNo);\n        plan.executeRound(roundNo, config);\n        delayNextRound();\n    }\n\n    /**\n     * wait the time given in {@link PlayerConfiguration#ROUND_DELAY}\n     */\n    private void delayNextRound() {\n        try {\n            Thread.sleep(config.ROUND_DELAY);\n        } catch (final InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * tell all listeners that a new round will start now\n     *\n     * @param roundNo\n     */\n    private void fireNewRoundEvent(final int roundNo) {\n        for (final RoundListener listener : listeners) {\n            listener.nextRound(roundNo);\n        }\n    }\n\n    /**\n     * @param listener\n     */\n    public void addRoundListener(final RoundListener listener) {\n        listeners.add(listener);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.player.Player#stop()\n     */\n    public void stop() {\n        if (isPlaying) {\n            LOG.fine(\"stopping\");\n            shouldStop = true;\n        } else {\n            LOG.fine(\"already stopped\");\n        }\n    }\n\n    /**\n     * A RoundListener waits for Round events.\n     *\n     * @author daniel\n     */\n    public static interface RoundListener {\n\n        /**\n         * a new round will begin immediatly\n         *\n         * @param roundNo\n         */\n        void nextRound(int roundNo);\n    }\n\n    /**\n     * @return the number of rounds this player shows\n     */\n    public int numberOfRounds() {\n        return plan.numberOfRounds();\n    }\n\n    /**\n     * toggles pause which holds playing rounds. if this player is currently\n     * paused can be checked with isPaused()\n     */\n    public void pause() {\n        if (isPaused) {\n            config.unlock();\n            isPaused = false;\n        } else {\n            config.lock();\n            isPaused = true;\n        }\n    }\n\n    /**\n     * @return <code>true</code> if this player is playing and is currently hold\n     */\n    public boolean isPaused() {\n        return isPaused;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.player.Player#getRoundNumbers()\n     */\n    public List<Integer> getRoundNumbers() {\n        // always generating a new list\n        final List<Integer> rounds = new ArrayList<Integer>(plan.numberOfRounds());\n        // check if first round exists\n        final int firstRound = 0;\n        if (plan.hasRoundNo(firstRound)) {\n            rounds.add(Integer.valueOf(firstRound));\n        }\n        // add all following rounds\n        int roundNo;\n        for (roundNo = plan.getNextRound(firstRound); plan.hasMoreRounds(roundNo); roundNo = plan.getNextRound(roundNo)) {\n            rounds.add(Integer.valueOf(roundNo));\n        }\n        // add last round (has no round after it)\n        rounds.add(Integer.valueOf(roundNo));\n        return rounds;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/player/Battleplayer_1Test.java",
		"test_prompt": "// Battleplayer_1Test.java\npackage de.outstare.fortbattleplayer.player;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Battleplayer}.\n* It contains ten unit test cases for the {@link Battleplayer#isPaused()} method.\n*/\nclass Battleplayer_1Test {"
	}
]