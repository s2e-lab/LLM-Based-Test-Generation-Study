[
	{
		"original_code": "// DynamicTemplate.java\n/*\r\n * Copyright(C) 2008-2009 Dmitriy Kumshayev. <dq@mail.com>\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\npackage org.templateit;\r\n\r\nimport java.util.List;\r\nimport org.apache.poi.hssf.usermodel.HSSFCell;\r\nimport org.apache.poi.hssf.usermodel.HSSFRow;\r\nimport org.apache.poi.hssf.usermodel.HSSFSheet;\r\n\r\npublic class DynamicTemplate extends Template {\r\n\r\n    private int height = 0;\r\n\r\n    private int width = 0;\r\n\r\n    private final List<NamedStyle> styles;\r\n\r\n    public DynamicTemplate(String name, HSSFSheet sheet, int height, List<NamedStyle> styles) {\r\n        super(name, sheet);\r\n        this.styles = styles;\r\n        this.height = height;\r\n        this.width = styles.size() / height;\r\n        for (int i = 0; i != styles.size(); i++) {\r\n            NamedStyle style = styles.get(i);\r\n            if (style.hasParam()) {\r\n                int r = i / width;\r\n                int c = i % width;\r\n                createParameter(\"\" + (i + 1), r, c);\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public int height() {\r\n        return height;\r\n    }\r\n\r\n    @Override\r\n    public int width() {\r\n        return width;\r\n    }\r\n\r\n    public Reference absoluteReference(int r, int c) {\r\n        NamedStyle style = styles.get(r * width() + c);\r\n        return new Reference(style.getRow(), style.getColumn());\r\n    }\r\n\r\n    @Override\r\n    public int getRowHeight(int r) {\r\n        int rh = 0;\r\n        for (int c = 0; c < width(); c++) {\r\n            Reference ar = absoluteReference(r, c);\r\n            HSSFRow row = sheet.getRow(ar.row());\r\n            if (row != null) {\r\n                rh = Math.max(rh, row.getHeight());\r\n            }\r\n        }\r\n        return rh;\r\n    }\r\n\r\n    @Override\r\n    public HSSFCell getCell(int r, int c) {\r\n        if (c >= 0 && c < width() && r >= 0 && r < height()) {\r\n            Reference ar = absoluteReference(r, c);\r\n            HSSFRow tRow = sheet.getRow(ar.row());\r\n            if (tRow != null) {\r\n                return tRow.getCell(ar.column());\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/5_templateit/src/main/java/org/templateit/DynamicTemplateTest0.java",
		"test_prompt": "// DynamicTemplateTest0.java\npackage org.templateit;\n\nimport java.util.List;\nimport org.apache.poi.hssf.usermodel.HSSFCell;\nimport org.apache.poi.hssf.usermodel.HSSFRow;\nimport org.apache.poi.hssf.usermodel.HSSFSheet;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DynamicTemplate}.\n* It contains ten unit test cases for the {@link DynamicTemplate#height()} method.\n*/\nclass DynamicTemplateTest0 {"
	},
	{
		"original_code": "// DynamicTemplate.java\n/*\r\n * Copyright(C) 2008-2009 Dmitriy Kumshayev. <dq@mail.com>\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\npackage org.templateit;\r\n\r\nimport java.util.List;\r\nimport org.apache.poi.hssf.usermodel.HSSFCell;\r\nimport org.apache.poi.hssf.usermodel.HSSFRow;\r\nimport org.apache.poi.hssf.usermodel.HSSFSheet;\r\n\r\npublic class DynamicTemplate extends Template {\r\n\r\n    private int height = 0;\r\n\r\n    private int width = 0;\r\n\r\n    private final List<NamedStyle> styles;\r\n\r\n    public DynamicTemplate(String name, HSSFSheet sheet, int height, List<NamedStyle> styles) {\r\n        super(name, sheet);\r\n        this.styles = styles;\r\n        this.height = height;\r\n        this.width = styles.size() / height;\r\n        for (int i = 0; i != styles.size(); i++) {\r\n            NamedStyle style = styles.get(i);\r\n            if (style.hasParam()) {\r\n                int r = i / width;\r\n                int c = i % width;\r\n                createParameter(\"\" + (i + 1), r, c);\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public int height() {\r\n        return height;\r\n    }\r\n\r\n    @Override\r\n    public int width() {\r\n        return width;\r\n    }\r\n\r\n    public Reference absoluteReference(int r, int c) {\r\n        NamedStyle style = styles.get(r * width() + c);\r\n        return new Reference(style.getRow(), style.getColumn());\r\n    }\r\n\r\n    @Override\r\n    public int getRowHeight(int r) {\r\n        int rh = 0;\r\n        for (int c = 0; c < width(); c++) {\r\n            Reference ar = absoluteReference(r, c);\r\n            HSSFRow row = sheet.getRow(ar.row());\r\n            if (row != null) {\r\n                rh = Math.max(rh, row.getHeight());\r\n            }\r\n        }\r\n        return rh;\r\n    }\r\n\r\n    @Override\r\n    public HSSFCell getCell(int r, int c) {\r\n        if (c >= 0 && c < width() && r >= 0 && r < height()) {\r\n            Reference ar = absoluteReference(r, c);\r\n            HSSFRow tRow = sheet.getRow(ar.row());\r\n            if (tRow != null) {\r\n                return tRow.getCell(ar.column());\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/5_templateit/src/main/java/org/templateit/DynamicTemplateTest1.java",
		"test_prompt": "// DynamicTemplateTest1.java\npackage org.templateit;\n\nimport java.util.List;\nimport org.apache.poi.hssf.usermodel.HSSFCell;\nimport org.apache.poi.hssf.usermodel.HSSFRow;\nimport org.apache.poi.hssf.usermodel.HSSFSheet;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DynamicTemplate}.\n* It contains ten unit test cases for the {@link DynamicTemplate#width()} method.\n*/\nclass DynamicTemplateTest1 {"
	},
	{
		"original_code": "// DynamicTemplate.java\n/*\r\n * Copyright(C) 2008-2009 Dmitriy Kumshayev. <dq@mail.com>\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\npackage org.templateit;\r\n\r\nimport java.util.List;\r\nimport org.apache.poi.hssf.usermodel.HSSFCell;\r\nimport org.apache.poi.hssf.usermodel.HSSFRow;\r\nimport org.apache.poi.hssf.usermodel.HSSFSheet;\r\n\r\npublic class DynamicTemplate extends Template {\r\n\r\n    private int height = 0;\r\n\r\n    private int width = 0;\r\n\r\n    private final List<NamedStyle> styles;\r\n\r\n    public DynamicTemplate(String name, HSSFSheet sheet, int height, List<NamedStyle> styles) {\r\n        super(name, sheet);\r\n        this.styles = styles;\r\n        this.height = height;\r\n        this.width = styles.size() / height;\r\n        for (int i = 0; i != styles.size(); i++) {\r\n            NamedStyle style = styles.get(i);\r\n            if (style.hasParam()) {\r\n                int r = i / width;\r\n                int c = i % width;\r\n                createParameter(\"\" + (i + 1), r, c);\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public int height() {\r\n        return height;\r\n    }\r\n\r\n    @Override\r\n    public int width() {\r\n        return width;\r\n    }\r\n\r\n    public Reference absoluteReference(int r, int c) {\r\n        NamedStyle style = styles.get(r * width() + c);\r\n        return new Reference(style.getRow(), style.getColumn());\r\n    }\r\n\r\n    @Override\r\n    public int getRowHeight(int r) {\r\n        int rh = 0;\r\n        for (int c = 0; c < width(); c++) {\r\n            Reference ar = absoluteReference(r, c);\r\n            HSSFRow row = sheet.getRow(ar.row());\r\n            if (row != null) {\r\n                rh = Math.max(rh, row.getHeight());\r\n            }\r\n        }\r\n        return rh;\r\n    }\r\n\r\n    @Override\r\n    public HSSFCell getCell(int r, int c) {\r\n        if (c >= 0 && c < width() && r >= 0 && r < height()) {\r\n            Reference ar = absoluteReference(r, c);\r\n            HSSFRow tRow = sheet.getRow(ar.row());\r\n            if (tRow != null) {\r\n                return tRow.getCell(ar.column());\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/5_templateit/src/main/java/org/templateit/DynamicTemplateTest2.java",
		"test_prompt": "// DynamicTemplateTest2.java\npackage org.templateit;\n\nimport java.util.List;\nimport org.apache.poi.hssf.usermodel.HSSFCell;\nimport org.apache.poi.hssf.usermodel.HSSFRow;\nimport org.apache.poi.hssf.usermodel.HSSFSheet;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DynamicTemplate}.\n* It contains ten unit test cases for the {@link DynamicTemplate#absoluteReference(int, int)} method.\n*/\nclass DynamicTemplateTest2 {"
	},
	{
		"original_code": "// TemplateWorkbook.java\n/*\r\n * Copyright(C) 2008-2009 Dmitriy Kumshayev. <dq@mail.com>\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\npackage org.templateit;\r\n\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport org.apache.poi.hssf.usermodel.HSSFSheet;\r\n\r\n/**\r\n * This class encapsulates a map of {@link TemplateSheet} gathered\r\n * by {@link WorkbookParser} from the template workbook.\r\n * @author Dmitriy Kumshayev\r\n */\r\nfinal class TemplateWorkbook {\r\n\r\n    private Map<String, TemplateSheet> sheets = new HashMap<String, TemplateSheet>();\r\n\r\n    public TemplateSheet getTemplateSheet(String sheetName) {\r\n        return sheets.get(sheetName);\r\n    }\r\n\r\n    /**\r\n     * Set {@link TemplateSheet}\r\n     * @param sheetName\r\n     * @param sheetData\r\n     * @return\r\n     */\r\n    public TemplateSheet setSheetTemplateData(String sheetName, TemplateSheet sheetData) {\r\n        return sheets.put(sheetName, sheetData);\r\n    }\r\n\r\n    public TemplateSheet createTemplateSheet(String sheetName, HSSFSheet sheet) {\r\n        TemplateSheet tSheet = getTemplateSheet(sheetName);\r\n        if (tSheet == null) {\r\n            tSheet = new TemplateSheet(sheetName, sheet);\r\n            setSheetTemplateData(sheetName, tSheet);\r\n        }\r\n        return tSheet;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/5_templateit/src/main/java/org/templateit/TemplateWorkbookTest.java",
		"test_prompt": "// TemplateWorkbookTest.java\npackage org.templateit;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.apache.poi.hssf.usermodel.HSSFSheet;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TemplateWorkbook}.\n* It contains ten unit test cases for the {@link TemplateWorkbook#createTemplateSheet(String, HSSFSheet)} method.\n*/\nclass TemplateWorkbookTest {"
	},
	{
		"original_code": "// NamedStyle.java\n/*\r\n * Copyright(C) 2008-2009 Dmitriy Kumshayev. <dq@mail.com>\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\npackage org.templateit;\r\n\r\nclass NamedStyle {\r\n\r\n    private final String name;\r\n\r\n    private final boolean hasParam;\r\n\r\n    private int row;\r\n\r\n    private int column;\r\n\r\n    public NamedStyle(String name, boolean hasParam) {\r\n        this.name = name;\r\n        this.hasParam = hasParam;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public boolean hasParam() {\r\n        return hasParam;\r\n    }\r\n\r\n    public int getRow() {\r\n        return row;\r\n    }\r\n\r\n    public int getColumn() {\r\n        return column;\r\n    }\r\n\r\n    public void setRow(int row) {\r\n        this.row = row;\r\n    }\r\n\r\n    public void setColumn(int column) {\r\n        this.column = column;\r\n    }\r\n\r\n    public String toString() {\r\n        return \"@style(\" + getName() + \",\" + hasParam() + \")\";\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/5_templateit/src/main/java/org/templateit/NamedStyleTest.java",
		"test_prompt": "// NamedStyleTest.java\npackage org.templateit;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NamedStyle}.\n* It contains ten unit test cases for the {@link NamedStyle#hasParam()} method.\n*/\nclass NamedStyleTest {"
	},
	{
		"original_code": "// WorkbookParser.java\n/*\r\n * Copyright(C) 2008-2009 Dmitriy Kumshayev. <dq@mail.com>\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\npackage org.templateit;\r\n\r\nimport java.util.Set;\r\nimport org.apache.log4j.Logger;\r\nimport org.apache.poi.hssf.usermodel.HSSFComment;\r\nimport org.apache.poi.hssf.usermodel.HSSFRichTextString;\r\nimport org.apache.poi.hssf.usermodel.HSSFRow;\r\nimport org.apache.poi.hssf.usermodel.HSSFSheet;\r\nimport org.apache.poi.hssf.usermodel.HSSFWorkbook;\r\nimport org.apache.poi.hssf.util.CellRangeAddress;\r\n\r\nclass WorkbookParser {\r\n\r\n    private static final Logger logger = Logger.getLogger(WorkbookParser.class);\r\n\r\n    private final HSSFWorkbook workbook;\r\n\r\n    private final TemplateWorkbook tWorkbook;\r\n\r\n    private TemplateSheet tSheet;\r\n\r\n    public WorkbookParser(HSSFWorkbook workbook) {\r\n        this.workbook = workbook;\r\n        this.tWorkbook = new TemplateWorkbook();\r\n    }\r\n\r\n    public TemplateWorkbook parse() {\r\n        return parse(null);\r\n    }\r\n\r\n    public TemplateWorkbook parse(Set<String> excludedSheetNames) {\r\n        int nSheets = workbook.getNumberOfSheets();\r\n        for (int i = 0; i < nSheets; i++) {\r\n            HSSFSheet sheet = workbook.getSheetAt(i);\r\n            String sheetName = workbook.getSheetName(i);\r\n            if (excludedSheetNames != null && !excludedSheetNames.contains(sheetName)) {\r\n                parseSheet(sheetName, sheet);\r\n            }\r\n        }\r\n        return tWorkbook;\r\n    }\r\n\r\n    private void parseSheet(String sheetName, HSSFSheet sheet) {\r\n        logger.debug(\"Parsing <\" + sheetName + \">\");\r\n        tSheet = tWorkbook.createTemplateSheet(sheetName, sheet);\r\n        int lastRow = sheet.getLastRowNum();\r\n        StaticTemplate template = null;\r\n        for (int r = 0; r <= lastRow; r++) {\r\n            HSSFRow row = sheet.getRow(r);\r\n            if (row != null) {\r\n                tSheet.setLastColumn(Math.max(row.getLastCellNum(), tSheet.getLastColumn()));\r\n                // POI does not provide a way to walk through\r\n                // all available cell comments, so we reserve\r\n                // first 20 columns\r\n                int lastColumn = Math.max(tSheet.getLastColumn(), 20);\r\n                for (int c = 0; c <= lastColumn; c++) {\r\n                    boolean templateEndFound = false;\r\n                    HSSFComment cellComment = sheet.getCellComment(r, c);\r\n                    if (cellComment != null) {\r\n                        HSSFRichTextString hstring = cellComment.getString();\r\n                        if (hstring != null) {\r\n                            String comm = hstring.toString();\r\n                            if (comm != null) {\r\n                                if (logger.isTraceEnabled()) {\r\n                                    String ct = comm.replace('\\n', ' ').trim();\r\n                                    logger.trace(\"comment @(\" + r + \",\" + c + \"): '\" + ct + \"'\");\r\n                                }\r\n                                String[] names = null;\r\n                                if ((names = OpMatcher.matchTemplateBegin(comm)) != null) {\r\n                                    if (logger.isTraceEnabled()) {\r\n                                        logger.trace(\"@template_begin @(\" + r + \",\" + c + \")\");\r\n                                    }\r\n                                    template = tSheet.createTemplate(r, c, names);\r\n                                }\r\n                                if (OpMatcher.matchTemplateEnd(comm)) {\r\n                                    if (logger.isTraceEnabled()) {\r\n                                        logger.trace(\"@template_end @(\" + r + \",\" + c + \")\");\r\n                                    }\r\n                                    if (template != null) {\r\n                                        template.setEndReference(new Reference(r, c));\r\n                                    } else {\r\n                                        logger.warn(\"@template_end without @template_begin\");\r\n                                    }\r\n                                    templateEndFound = true;\r\n                                }\r\n                                String paramName = OpMatcher.matchTemplateParameter(comm);\r\n                                if (paramName != null) {\r\n                                    if (template != null) {\r\n                                        int relRow = r - template.start().row();\r\n                                        int relCol = c - template.start().column();\r\n                                        template.createParameter(paramName, relRow, relCol);\r\n                                    } else {\r\n                                        logger.warn(\"Cannot create parameter '\" + paramName + \"'\");\r\n                                    }\r\n                                }\r\n                                NamedStyle style = OpMatcher.matchStyle(comm);\r\n                                if (style != null) {\r\n                                    style.setRow(r);\r\n                                    style.setColumn(c);\r\n                                    tSheet.addStyle(style);\r\n                                }\r\n                            }\r\n                            if (templateEndFound) {\r\n                                // reset template\r\n                                template = null;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        processMergeRegions(sheet);\r\n    }\r\n\r\n    private void processMergeRegions(HSSFSheet sheet) {\r\n        // identify MergeRegions and assign them to corresponding template sections\r\n        int numMergedRegions = sheet.getNumMergedRegions();\r\n        for (int i = 0; i < numMergedRegions; i++) {\r\n            CellRangeAddress mr = sheet.getMergedRegion(i);\r\n            Reference start = new Reference(mr.getFirstRow(), mr.getFirstColumn());\r\n            Reference end = new Reference(mr.getLastRow(), mr.getLastColumn());\r\n            MergeRegion mreg = new MergeRegion(start, end);\r\n            if (logger.isTraceEnabled()) {\r\n                logger.trace(\"Merge region @(\" + mreg + \")\");\r\n            }\r\n            for (StaticTemplate template : tSheet.templates()) {\r\n                if (mreg.contains(template.end())) {\r\n                    template.setEndReference(mreg.end());\r\n                    if (logger.isTraceEnabled()) {\r\n                        logger.trace(\"Template \" + template.getName() + \" extended to (\" + template + \")\");\r\n                    }\r\n                }\r\n                if (template.contains(mreg)) {\r\n                    template.addMergeRegion(mreg);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/5_templateit/src/main/java/org/templateit/WorkbookParserTest0.java",
		"test_prompt": "// WorkbookParserTest0.java\npackage org.templateit;\n\nimport java.util.Set;\nimport org.apache.log4j.Logger;\nimport org.apache.poi.hssf.usermodel.HSSFComment;\nimport org.apache.poi.hssf.usermodel.HSSFRichTextString;\nimport org.apache.poi.hssf.usermodel.HSSFRow;\nimport org.apache.poi.hssf.usermodel.HSSFSheet;\nimport org.apache.poi.hssf.usermodel.HSSFWorkbook;\nimport org.apache.poi.hssf.util.CellRangeAddress;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link WorkbookParser}.\n* It contains ten unit test cases for the {@link WorkbookParser#parse()} method.\n*/\nclass WorkbookParserTest0 {"
	},
	{
		"original_code": "// WorkbookParser.java\n/*\r\n * Copyright(C) 2008-2009 Dmitriy Kumshayev. <dq@mail.com>\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\npackage org.templateit;\r\n\r\nimport java.util.Set;\r\nimport org.apache.log4j.Logger;\r\nimport org.apache.poi.hssf.usermodel.HSSFComment;\r\nimport org.apache.poi.hssf.usermodel.HSSFRichTextString;\r\nimport org.apache.poi.hssf.usermodel.HSSFRow;\r\nimport org.apache.poi.hssf.usermodel.HSSFSheet;\r\nimport org.apache.poi.hssf.usermodel.HSSFWorkbook;\r\nimport org.apache.poi.hssf.util.CellRangeAddress;\r\n\r\nclass WorkbookParser {\r\n\r\n    private static final Logger logger = Logger.getLogger(WorkbookParser.class);\r\n\r\n    private final HSSFWorkbook workbook;\r\n\r\n    private final TemplateWorkbook tWorkbook;\r\n\r\n    private TemplateSheet tSheet;\r\n\r\n    public WorkbookParser(HSSFWorkbook workbook) {\r\n        this.workbook = workbook;\r\n        this.tWorkbook = new TemplateWorkbook();\r\n    }\r\n\r\n    public TemplateWorkbook parse() {\r\n        return parse(null);\r\n    }\r\n\r\n    public TemplateWorkbook parse(Set<String> excludedSheetNames) {\r\n        int nSheets = workbook.getNumberOfSheets();\r\n        for (int i = 0; i < nSheets; i++) {\r\n            HSSFSheet sheet = workbook.getSheetAt(i);\r\n            String sheetName = workbook.getSheetName(i);\r\n            if (excludedSheetNames != null && !excludedSheetNames.contains(sheetName)) {\r\n                parseSheet(sheetName, sheet);\r\n            }\r\n        }\r\n        return tWorkbook;\r\n    }\r\n\r\n    private void parseSheet(String sheetName, HSSFSheet sheet) {\r\n        logger.debug(\"Parsing <\" + sheetName + \">\");\r\n        tSheet = tWorkbook.createTemplateSheet(sheetName, sheet);\r\n        int lastRow = sheet.getLastRowNum();\r\n        StaticTemplate template = null;\r\n        for (int r = 0; r <= lastRow; r++) {\r\n            HSSFRow row = sheet.getRow(r);\r\n            if (row != null) {\r\n                tSheet.setLastColumn(Math.max(row.getLastCellNum(), tSheet.getLastColumn()));\r\n                // POI does not provide a way to walk through\r\n                // all available cell comments, so we reserve\r\n                // first 20 columns\r\n                int lastColumn = Math.max(tSheet.getLastColumn(), 20);\r\n                for (int c = 0; c <= lastColumn; c++) {\r\n                    boolean templateEndFound = false;\r\n                    HSSFComment cellComment = sheet.getCellComment(r, c);\r\n                    if (cellComment != null) {\r\n                        HSSFRichTextString hstring = cellComment.getString();\r\n                        if (hstring != null) {\r\n                            String comm = hstring.toString();\r\n                            if (comm != null) {\r\n                                if (logger.isTraceEnabled()) {\r\n                                    String ct = comm.replace('\\n', ' ').trim();\r\n                                    logger.trace(\"comment @(\" + r + \",\" + c + \"): '\" + ct + \"'\");\r\n                                }\r\n                                String[] names = null;\r\n                                if ((names = OpMatcher.matchTemplateBegin(comm)) != null) {\r\n                                    if (logger.isTraceEnabled()) {\r\n                                        logger.trace(\"@template_begin @(\" + r + \",\" + c + \")\");\r\n                                    }\r\n                                    template = tSheet.createTemplate(r, c, names);\r\n                                }\r\n                                if (OpMatcher.matchTemplateEnd(comm)) {\r\n                                    if (logger.isTraceEnabled()) {\r\n                                        logger.trace(\"@template_end @(\" + r + \",\" + c + \")\");\r\n                                    }\r\n                                    if (template != null) {\r\n                                        template.setEndReference(new Reference(r, c));\r\n                                    } else {\r\n                                        logger.warn(\"@template_end without @template_begin\");\r\n                                    }\r\n                                    templateEndFound = true;\r\n                                }\r\n                                String paramName = OpMatcher.matchTemplateParameter(comm);\r\n                                if (paramName != null) {\r\n                                    if (template != null) {\r\n                                        int relRow = r - template.start().row();\r\n                                        int relCol = c - template.start().column();\r\n                                        template.createParameter(paramName, relRow, relCol);\r\n                                    } else {\r\n                                        logger.warn(\"Cannot create parameter '\" + paramName + \"'\");\r\n                                    }\r\n                                }\r\n                                NamedStyle style = OpMatcher.matchStyle(comm);\r\n                                if (style != null) {\r\n                                    style.setRow(r);\r\n                                    style.setColumn(c);\r\n                                    tSheet.addStyle(style);\r\n                                }\r\n                            }\r\n                            if (templateEndFound) {\r\n                                // reset template\r\n                                template = null;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        processMergeRegions(sheet);\r\n    }\r\n\r\n    private void processMergeRegions(HSSFSheet sheet) {\r\n        // identify MergeRegions and assign them to corresponding template sections\r\n        int numMergedRegions = sheet.getNumMergedRegions();\r\n        for (int i = 0; i < numMergedRegions; i++) {\r\n            CellRangeAddress mr = sheet.getMergedRegion(i);\r\n            Reference start = new Reference(mr.getFirstRow(), mr.getFirstColumn());\r\n            Reference end = new Reference(mr.getLastRow(), mr.getLastColumn());\r\n            MergeRegion mreg = new MergeRegion(start, end);\r\n            if (logger.isTraceEnabled()) {\r\n                logger.trace(\"Merge region @(\" + mreg + \")\");\r\n            }\r\n            for (StaticTemplate template : tSheet.templates()) {\r\n                if (mreg.contains(template.end())) {\r\n                    template.setEndReference(mreg.end());\r\n                    if (logger.isTraceEnabled()) {\r\n                        logger.trace(\"Template \" + template.getName() + \" extended to (\" + template + \")\");\r\n                    }\r\n                }\r\n                if (template.contains(mreg)) {\r\n                    template.addMergeRegion(mreg);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/5_templateit/src/main/java/org/templateit/WorkbookParserTest1.java",
		"test_prompt": "// WorkbookParserTest1.java\npackage org.templateit;\n\nimport java.util.Set;\nimport org.apache.log4j.Logger;\nimport org.apache.poi.hssf.usermodel.HSSFComment;\nimport org.apache.poi.hssf.usermodel.HSSFRichTextString;\nimport org.apache.poi.hssf.usermodel.HSSFRow;\nimport org.apache.poi.hssf.usermodel.HSSFSheet;\nimport org.apache.poi.hssf.usermodel.HSSFWorkbook;\nimport org.apache.poi.hssf.util.CellRangeAddress;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link WorkbookParser}.\n* It contains ten unit test cases for the {@link WorkbookParser#parse(Set)} method.\n*/\nclass WorkbookParserTest1 {"
	},
	{
		"original_code": "// Region.java\n/*\r\n * Copyright(C) 2008-2009 Dmitriy Kumshayev. <dq@mail.com>\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\npackage org.templateit;\r\n\r\nclass Region {\r\n\r\n    private Reference start;\r\n\r\n    private Reference end;\r\n\r\n    public Region() {\r\n    }\r\n\r\n    public Region(Reference start, Reference end) {\r\n        this.start = start;\r\n        this.end = end;\r\n    }\r\n\r\n    public void setStartReference(Reference start) {\r\n        this.start = start;\r\n    }\r\n\r\n    public Reference start() {\r\n        return start;\r\n    }\r\n\r\n    public void setEndReference(Reference end) {\r\n        this.end = end;\r\n    }\r\n\r\n    public Reference end() {\r\n        return end;\r\n    }\r\n\r\n    /**\r\n     * @return true if this Region contains the Region passed as an argument\r\n     */\r\n    public boolean contains(Region region) {\r\n        return start.row() <= region.start.row() && start.column() <= region.start.column() && (end.row() == Reference.INFINITY || region.end.row() <= end.row()) && (end.column() == Reference.INFINITY || region.end.column() <= end.column());\r\n    }\r\n\r\n    /**\r\n     * @return true if this Region contains the reference\r\n     */\r\n    public boolean contains(Reference reference) {\r\n        return start.row() <= reference.row() && (end.row() == Reference.INFINITY || reference.row() <= end.row()) && start.column() <= reference.column() && (end.column() == Reference.INFINITY || reference.column() <= end.column());\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return start + \",\" + end;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/5_templateit/src/main/java/org/templateit/RegionTest0.java",
		"test_prompt": "// RegionTest0.java\npackage org.templateit;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Region}.\n* It contains ten unit test cases for the {@link Region#start()} method.\n*/\nclass RegionTest0 {"
	},
	{
		"original_code": "// Region.java\n/*\r\n * Copyright(C) 2008-2009 Dmitriy Kumshayev. <dq@mail.com>\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\npackage org.templateit;\r\n\r\nclass Region {\r\n\r\n    private Reference start;\r\n\r\n    private Reference end;\r\n\r\n    public Region() {\r\n    }\r\n\r\n    public Region(Reference start, Reference end) {\r\n        this.start = start;\r\n        this.end = end;\r\n    }\r\n\r\n    public void setStartReference(Reference start) {\r\n        this.start = start;\r\n    }\r\n\r\n    public Reference start() {\r\n        return start;\r\n    }\r\n\r\n    public void setEndReference(Reference end) {\r\n        this.end = end;\r\n    }\r\n\r\n    public Reference end() {\r\n        return end;\r\n    }\r\n\r\n    /**\r\n     * @return true if this Region contains the Region passed as an argument\r\n     */\r\n    public boolean contains(Region region) {\r\n        return start.row() <= region.start.row() && start.column() <= region.start.column() && (end.row() == Reference.INFINITY || region.end.row() <= end.row()) && (end.column() == Reference.INFINITY || region.end.column() <= end.column());\r\n    }\r\n\r\n    /**\r\n     * @return true if this Region contains the reference\r\n     */\r\n    public boolean contains(Reference reference) {\r\n        return start.row() <= reference.row() && (end.row() == Reference.INFINITY || reference.row() <= end.row()) && start.column() <= reference.column() && (end.column() == Reference.INFINITY || reference.column() <= end.column());\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return start + \",\" + end;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/5_templateit/src/main/java/org/templateit/RegionTest1.java",
		"test_prompt": "// RegionTest1.java\npackage org.templateit;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Region}.\n* It contains ten unit test cases for the {@link Region#end()} method.\n*/\nclass RegionTest1 {"
	},
	{
		"original_code": "// Region.java\n/*\r\n * Copyright(C) 2008-2009 Dmitriy Kumshayev. <dq@mail.com>\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\npackage org.templateit;\r\n\r\nclass Region {\r\n\r\n    private Reference start;\r\n\r\n    private Reference end;\r\n\r\n    public Region() {\r\n    }\r\n\r\n    public Region(Reference start, Reference end) {\r\n        this.start = start;\r\n        this.end = end;\r\n    }\r\n\r\n    public void setStartReference(Reference start) {\r\n        this.start = start;\r\n    }\r\n\r\n    public Reference start() {\r\n        return start;\r\n    }\r\n\r\n    public void setEndReference(Reference end) {\r\n        this.end = end;\r\n    }\r\n\r\n    public Reference end() {\r\n        return end;\r\n    }\r\n\r\n    /**\r\n     * @return true if this Region contains the Region passed as an argument\r\n     */\r\n    public boolean contains(Region region) {\r\n        return start.row() <= region.start.row() && start.column() <= region.start.column() && (end.row() == Reference.INFINITY || region.end.row() <= end.row()) && (end.column() == Reference.INFINITY || region.end.column() <= end.column());\r\n    }\r\n\r\n    /**\r\n     * @return true if this Region contains the reference\r\n     */\r\n    public boolean contains(Reference reference) {\r\n        return start.row() <= reference.row() && (end.row() == Reference.INFINITY || reference.row() <= end.row()) && start.column() <= reference.column() && (end.column() == Reference.INFINITY || reference.column() <= end.column());\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return start + \",\" + end;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/5_templateit/src/main/java/org/templateit/RegionTest2.java",
		"test_prompt": "// RegionTest2.java\npackage org.templateit;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Region}.\n* It contains ten unit test cases for the {@link Region#contains(Region)} method.\n*/\nclass RegionTest2 {"
	},
	{
		"original_code": "// Region.java\n/*\r\n * Copyright(C) 2008-2009 Dmitriy Kumshayev. <dq@mail.com>\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\npackage org.templateit;\r\n\r\nclass Region {\r\n\r\n    private Reference start;\r\n\r\n    private Reference end;\r\n\r\n    public Region() {\r\n    }\r\n\r\n    public Region(Reference start, Reference end) {\r\n        this.start = start;\r\n        this.end = end;\r\n    }\r\n\r\n    public void setStartReference(Reference start) {\r\n        this.start = start;\r\n    }\r\n\r\n    public Reference start() {\r\n        return start;\r\n    }\r\n\r\n    public void setEndReference(Reference end) {\r\n        this.end = end;\r\n    }\r\n\r\n    public Reference end() {\r\n        return end;\r\n    }\r\n\r\n    /**\r\n     * @return true if this Region contains the Region passed as an argument\r\n     */\r\n    public boolean contains(Region region) {\r\n        return start.row() <= region.start.row() && start.column() <= region.start.column() && (end.row() == Reference.INFINITY || region.end.row() <= end.row()) && (end.column() == Reference.INFINITY || region.end.column() <= end.column());\r\n    }\r\n\r\n    /**\r\n     * @return true if this Region contains the reference\r\n     */\r\n    public boolean contains(Reference reference) {\r\n        return start.row() <= reference.row() && (end.row() == Reference.INFINITY || reference.row() <= end.row()) && start.column() <= reference.column() && (end.column() == Reference.INFINITY || reference.column() <= end.column());\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return start + \",\" + end;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/5_templateit/src/main/java/org/templateit/RegionTest3.java",
		"test_prompt": "// RegionTest3.java\npackage org.templateit;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Region}.\n* It contains ten unit test cases for the {@link Region#contains(Reference)} method.\n*/\nclass RegionTest3 {"
	},
	{
		"original_code": "// DelimitedFileReader.java\n/*\r\n * Copyright(C) 2008-2009 Dmitriy Kumshayev. <dq@mail.com>\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\npackage org.templateit.util;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.File;\r\nimport java.io.FileNotFoundException;\r\nimport java.io.FileReader;\r\nimport java.io.IOException;\r\nimport java.util.Iterator;\r\nimport java.util.NoSuchElementException;\r\n\r\n/**\r\n * Implementation of Iterator interface. Reads an input file line by line and\r\n * parses each one as fields separated by a delimiter. For each line the fields\r\n * are stored in a String array and made accessible via Iterator interface.\r\n *\r\n * @author Dmitriy Kumshayev\r\n */\r\npublic class DelimitedFileReader implements Iterator<String[]> {\r\n\r\n    private String delimiter;\r\n\r\n    private BufferedReader reader;\r\n\r\n    private String nextLine = null;\r\n\r\n    private boolean hasNext = true;\r\n\r\n    public DelimitedFileReader(File file) throws FileNotFoundException {\r\n        this(file, \",\");\r\n    }\r\n\r\n    public DelimitedFileReader(File file, String delimiter) throws FileNotFoundException {\r\n        reader = new BufferedReader(new FileReader(file));\r\n        this.delimiter = delimiter;\r\n    }\r\n\r\n    public boolean hasNext() {\r\n        if (hasNext) {\r\n            if (nextLine == null) {\r\n                try {\r\n                    nextLine = reader.readLine();\r\n                } catch (IOException e) {\r\n                    nextLine = null;\r\n                }\r\n                if (nextLine == null) {\r\n                    hasNext = false;\r\n                }\r\n            }\r\n        }\r\n        return hasNext;\r\n    }\r\n\r\n    public String[] next() {\r\n        if (hasNext()) {\r\n            String[] next = nextLine.split(delimiter);\r\n            nextLine = null;\r\n            return next;\r\n        } else {\r\n            throw new NoSuchElementException();\r\n        }\r\n    }\r\n\r\n    public void remove() {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/5_templateit/src/main/java/org/templateit/util/DelimitedFileReaderTest0.java",
		"test_prompt": "// DelimitedFileReaderTest0.java\npackage org.templateit.util;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DelimitedFileReader}.\n* It contains ten unit test cases for the {@link DelimitedFileReader#hasNext()} method.\n*/\nclass DelimitedFileReaderTest0 {"
	},
	{
		"original_code": "// DelimitedFileReader.java\n/*\r\n * Copyright(C) 2008-2009 Dmitriy Kumshayev. <dq@mail.com>\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\npackage org.templateit.util;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.File;\r\nimport java.io.FileNotFoundException;\r\nimport java.io.FileReader;\r\nimport java.io.IOException;\r\nimport java.util.Iterator;\r\nimport java.util.NoSuchElementException;\r\n\r\n/**\r\n * Implementation of Iterator interface. Reads an input file line by line and\r\n * parses each one as fields separated by a delimiter. For each line the fields\r\n * are stored in a String array and made accessible via Iterator interface.\r\n *\r\n * @author Dmitriy Kumshayev\r\n */\r\npublic class DelimitedFileReader implements Iterator<String[]> {\r\n\r\n    private String delimiter;\r\n\r\n    private BufferedReader reader;\r\n\r\n    private String nextLine = null;\r\n\r\n    private boolean hasNext = true;\r\n\r\n    public DelimitedFileReader(File file) throws FileNotFoundException {\r\n        this(file, \",\");\r\n    }\r\n\r\n    public DelimitedFileReader(File file, String delimiter) throws FileNotFoundException {\r\n        reader = new BufferedReader(new FileReader(file));\r\n        this.delimiter = delimiter;\r\n    }\r\n\r\n    public boolean hasNext() {\r\n        if (hasNext) {\r\n            if (nextLine == null) {\r\n                try {\r\n                    nextLine = reader.readLine();\r\n                } catch (IOException e) {\r\n                    nextLine = null;\r\n                }\r\n                if (nextLine == null) {\r\n                    hasNext = false;\r\n                }\r\n            }\r\n        }\r\n        return hasNext;\r\n    }\r\n\r\n    public String[] next() {\r\n        if (hasNext()) {\r\n            String[] next = nextLine.split(delimiter);\r\n            nextLine = null;\r\n            return next;\r\n        } else {\r\n            throw new NoSuchElementException();\r\n        }\r\n    }\r\n\r\n    public void remove() {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/5_templateit/src/main/java/org/templateit/util/DelimitedFileReaderTest1.java",
		"test_prompt": "// DelimitedFileReaderTest1.java\npackage org.templateit.util;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DelimitedFileReader}.\n* It contains ten unit test cases for the {@link DelimitedFileReader#next()} method.\n*/\nclass DelimitedFileReaderTest1 {"
	},
	{
		"original_code": "// FormulaUtil.java\npackage org.templateit.util;\r\n\r\nimport org.apache.poi.hssf.model.HSSFFormulaParser;\r\nimport org.apache.poi.hssf.record.formula.AreaPtg;\r\nimport org.apache.poi.hssf.record.formula.Ptg;\r\nimport org.apache.poi.hssf.record.formula.RefPtg;\r\nimport org.apache.poi.hssf.usermodel.HSSFWorkbook;\r\n\r\npublic class FormulaUtil {\r\n\r\n    public static String offsetRelativeReferences(HSSFWorkbook wb, String formula, int roff, int coff) {\r\n        Ptg[] ptgs = HSSFFormulaParser.parse(formula, wb);\r\n        offsetRelativePtgs(ptgs, roff, coff);\r\n        String newFormula = HSSFFormulaParser.toFormulaString(wb, ptgs);\r\n        return newFormula;\r\n    }\r\n\r\n    private static void offsetRelativePtgs(Ptg[] ptgs, int roff, int coff) {\r\n        for (Ptg ptg : ptgs) {\r\n            offsetRelativePtg(ptg, roff, coff);\r\n        }\r\n    }\r\n\r\n    private static void offsetRelativePtg(Ptg ptg, int roff, int coff) {\r\n        if (ptg instanceof RefPtg) {\r\n            RefPtg ref = (RefPtg) ptg;\r\n            if (roff != 0 && ref.isRowRelative()) {\r\n                ref.setRow(ref.getRow() + roff);\r\n            }\r\n            if (coff != 0 && ref.isColRelative()) {\r\n                ref.setColumn(ref.getColumn() + coff);\r\n            }\r\n        } else if (ptg instanceof AreaPtg) {\r\n            AreaPtg aptg = (AreaPtg) ptg;\r\n            if (roff != 0) {\r\n                if (aptg.isFirstRowRelative()) {\r\n                    aptg.setFirstRow(aptg.getFirstRow() + roff);\r\n                }\r\n                if (aptg.isLastRowRelative()) {\r\n                    aptg.setLastRow(aptg.getLastRow() + roff);\r\n                }\r\n            }\r\n            if (coff != 0) {\r\n                if (aptg.isFirstColRelative()) {\r\n                    aptg.setFirstColumn(aptg.getFirstColumn() + coff);\r\n                }\r\n                if (aptg.isLastColRelative()) {\r\n                    aptg.setLastColumn(aptg.getLastColumn() + coff);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/5_templateit/src/main/java/org/templateit/util/FormulaUtilTest.java",
		"test_prompt": "// FormulaUtilTest.java\npackage org.templateit.util;\n\nimport org.apache.poi.hssf.model.HSSFFormulaParser;\nimport org.apache.poi.hssf.record.formula.AreaPtg;\nimport org.apache.poi.hssf.record.formula.Ptg;\nimport org.apache.poi.hssf.record.formula.RefPtg;\nimport org.apache.poi.hssf.usermodel.HSSFWorkbook;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FormulaUtil}.\n* It contains ten unit test cases for the {@link FormulaUtil#offsetRelativeReferences(HSSFWorkbook, String, int, int)} method.\n*/\nclass FormulaUtilTest {"
	},
	{
		"original_code": "// TemplateProcessor.java\n/*\r\n * Copyright(C) 2008-2009 Dmitriy Kumshayev. <dq@mail.com>\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\npackage org.templateit;\r\n\r\nimport java.io.BufferedInputStream;\r\nimport java.io.ByteArrayInputStream;\r\nimport java.io.ByteArrayOutputStream;\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.io.OutputStream;\r\nimport java.text.DateFormat;\r\nimport java.text.ParseException;\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.Date;\r\nimport java.util.HashSet;\r\nimport java.util.Iterator;\r\nimport java.util.LinkedList;\r\nimport java.util.List;\r\nimport java.util.Set;\r\nimport org.apache.log4j.Logger;\r\nimport org.apache.poi.hssf.usermodel.HSSFCell;\r\nimport org.apache.poi.hssf.usermodel.HSSFConditionalFormatting;\r\nimport org.apache.poi.hssf.usermodel.HSSFPrintSetup;\r\nimport org.apache.poi.hssf.usermodel.HSSFRow;\r\nimport org.apache.poi.hssf.usermodel.HSSFSheet;\r\nimport org.apache.poi.hssf.usermodel.HSSFSheetConditionalFormatting;\r\nimport org.apache.poi.hssf.usermodel.HSSFWorkbook;\r\nimport org.apache.poi.hssf.util.CellRangeAddress;\r\nimport org.apache.poi.hssf.util.PaneInformation;\r\nimport org.templateit.util.FormulaUtil;\r\n\r\n/**\r\n * Template processor - the core class of the library.\r\n * <br>\r\n * Example:\r\n * <pre>\r\n *    TemplateProcessor tp = new TemplateProcessor(new File(\"MyTemplate.xls\"));\r\n *    Iterator<String[]> data1 = new DelimitedFileReader(new File(\"MyData1.csv\"));\r\n *    Iterator<String[]> data1 = new DelimitedFileReader(new File(\"MyData2.csv\"));\r\n *    // Keep Sheet2. This way Sheet2 will remain untouched in the output document\r\n *    tp.keepSheet(\"Sheet2\");\r\n *    // You can call process multiple times on the same template\r\n *    // with different data, to generate different files\r\n *    tp.process(data1,new File(\"MyResult1.xls\"));\r\n *    tp.process(data2,new File(\"MyResult2.xls\"));\r\n * </pre>\r\n *\r\n * @author Dmitriy Kumshayev\r\n */\r\npublic class TemplateProcessor {\r\n\r\n    private static final Logger logger = Logger.getLogger(TemplateProcessor.class);\r\n\r\n    private final ByteArrayOutputStream bos;\r\n\r\n    private final Set<String> protectedSheetNames;\r\n\r\n    private HSSFWorkbook workbook;\r\n\r\n    private List<String> sheetNames;\r\n\r\n    protected TemplateWorkbook tWorkbook;\r\n\r\n    public TemplateProcessor(File templateWorkbook) throws IOException {\r\n        this(new BufferedInputStream(new FileInputStream(templateWorkbook)), true);\r\n    }\r\n\r\n    public TemplateProcessor(InputStream templateWorkbookStream) throws IOException {\r\n        this(templateWorkbookStream, false);\r\n    }\r\n\r\n    public TemplateProcessor(InputStream templateWorkbookStream, boolean close) throws IOException {\r\n        try {\r\n            bos = toByteArrayOutputStream(templateWorkbookStream);\r\n            protectedSheetNames = new HashSet<String>();\r\n        } finally {\r\n            if (close) {\r\n                try {\r\n                    templateWorkbookStream.close();\r\n                } catch (Exception ignore) {\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void process(Iterator<String[]> di, File outputWorkbook) throws IOException {\r\n        FileOutputStream out = new FileOutputStream(outputWorkbook);\r\n        try {\r\n            process(di, out);\r\n        } finally {\r\n            try {\r\n                out.close();\r\n            } catch (Exception ignore) {\r\n            }\r\n        }\r\n    }\r\n\r\n    public void process(Iterator<String[]> di, OutputStream out) throws IOException {\r\n        // Parse workbook\r\n        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());\r\n        workbook = new HSSFWorkbook(bis);\r\n        // prepare processing\r\n        sheetNames = renameTemplateSheets();\r\n        tWorkbook = new WorkbookParser(workbook).parse(protectedSheetNames);\r\n        processData(di);\r\n        // finalize processing\r\n        removeTemplateSheets();\r\n        workbook.write(out);\r\n    }\r\n\r\n    /**\r\n     * Excludes the specified sheet from being considered as a template sheet.\r\n     * Keeps the sheet in the generated workbook after the processing.\r\n     *\r\n     * @param sheetName\r\n     */\r\n    public void keepSheet(String sheetName) {\r\n        protectedSheetNames.add(sheetName);\r\n    }\r\n\r\n    private enum Operation {\r\n\r\n        invalid,\r\n        empty,\r\n        sheet,\r\n        select,\r\n        data,\r\n        end,\r\n        template\r\n    }\r\n\r\n    private void processData(Iterator<String[]> di) {\r\n        while (di.hasNext()) {\r\n            String[] data = di.next();\r\n            while (data != null) {\r\n                Operation op = parseOperation(data);\r\n                switch(op) {\r\n                    case sheet:\r\n                        {\r\n                            String templateSheetName = data[1] + SUFFIX;\r\n                            String newSheetName = data[1];\r\n                            if (data.length > 2 && data[2] != null && data[2].length() > 0) {\r\n                                newSheetName = data[2];\r\n                            }\r\n                            data = generateNewSheet(templateSheetName, newSheetName, di);\r\n                        }\r\n                        break;\r\n                    case empty:\r\n                        {\r\n                        }\r\n                    default:\r\n                        {\r\n                            throw new RuntimeException(\"unexpected operation (only #sheet is allowed here)\");\r\n                        }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public String[] generateNewSheet(String templateSheetName, String newSheetName, Iterator<String[]> di) {\r\n        TemplateSheet tSheet = tWorkbook.getTemplateSheet(templateSheetName);\r\n        if (tSheet != null) {\r\n            return new SheetGenerator(tSheet, newSheetName).generateNewSheet(di);\r\n        } else {\r\n            logger.warn(\"Sheet \" + templateSheetName + \" not found.\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    private static String extractTemplateName(String[] data) {\r\n        String op = data[0];\r\n        if (data != null && data.length > 0 && OpMatcher.matchTemplateName(op)) {\r\n            return op;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private static Operation parseOperation(String[] data) {\r\n        String op = data[0];\r\n        if (data == null || data.length == 0) {\r\n            return Operation.empty;\r\n        }\r\n        if (op != null && op.equals(\"#sheet\") && data[1] != null && data[1].length() > 0) {\r\n            return Operation.sheet;\r\n        }\r\n        if (OpMatcher.matchTemplateName(op)) {\r\n            return Operation.data;\r\n        }\r\n        if (op != null && op.equals(\"#end\")) {\r\n            return Operation.end;\r\n        }\r\n        if (op != null && op.equals(\"#select\")) {\r\n            return Operation.select;\r\n        }\r\n        if (op != null && op.equals(\"#template\")) {\r\n            return Operation.template;\r\n        }\r\n        return Operation.invalid;\r\n    }\r\n\r\n    private final String SUFFIX = \"Template\";\r\n\r\n    /**\r\n     * Rename all sheets in the template workbook. Add a SUFFIX to each name.\r\n     *\r\n     * @return list of renamed sheet names\r\n     */\r\n    private List<String> renameTemplateSheets() {\r\n        List<String> names = new LinkedList<String>();\r\n        for (int i = 0; i != workbook.getNumberOfSheets(); i++) {\r\n            String name = workbook.getSheetName(i);\r\n            // exclude protected sheets from processing\r\n            if (!protectedSheetNames.contains(name)) {\r\n                name += SUFFIX;\r\n                workbook.setSheetName(i, name);\r\n                names.add(name);\r\n            }\r\n        }\r\n        return names;\r\n    }\r\n\r\n    private void removeTemplateSheets() {\r\n        for (String sheetName : sheetNames) {\r\n            workbook.removeSheetAt(workbook.getSheetIndex(sheetName));\r\n        }\r\n        sheetNames.clear();\r\n    }\r\n\r\n    private class SheetGenerator {\r\n\r\n        private final TemplateSheet tSheet;\r\n\r\n        private final HSSFSheet newSheet;\r\n\r\n        private int outRow = 0;\r\n\r\n        private SheetGenerator(TemplateSheet tSheet, String newSheetName) {\r\n            this.tSheet = tSheet;\r\n            this.newSheet = workbook.createSheet(newSheetName);\r\n        }\r\n\r\n        private String[] generateNewSheet(Iterator<String[]> di) {\r\n            copySheetSettings();\r\n            copyPaneInformation();\r\n            copyConditionalFormatting();\r\n            copyPrintSetup();\r\n            String[] ret = null;\r\n            for (boolean end = false; !end && di.hasNext(); ) {\r\n                String[] data = di.next();\r\n                Operation op = parseOperation(data);\r\n                switch(op) {\r\n                    case select:\r\n                        {\r\n                            selectList(data);\r\n                        }\r\n                        break;\r\n                    case data:\r\n                        {\r\n                            processTemplate(data);\r\n                        }\r\n                        break;\r\n                    case empty:\r\n                        {\r\n                            ;\r\n                            /* Skip */\r\n                        }\r\n                        break;\r\n                    case sheet:\r\n                        {\r\n                            ret = data;\r\n                            end = true;\r\n                        }\r\n                        break;\r\n                    case end:\r\n                        {\r\n                            end = true;\r\n                        }\r\n                        break;\r\n                    case template:\r\n                        {\r\n                            createDynamicTemplate(data);\r\n                        }\r\n                        break;\r\n                    case invalid:\r\n                        {\r\n                            logger.warn(\"invalid operation\");\r\n                        }\r\n                }\r\n            }\r\n            return ret;\r\n        }\r\n\r\n        private void createDynamicTemplate(String[] data) {\r\n            String name = data[1];\r\n            int nr = Integer.parseInt(data[2]);\r\n            int nc = (data.length - 3) / nr;\r\n            List<NamedStyle> styles = new ArrayList<NamedStyle>(nc);\r\n            for (int i = 3; i < data.length; i++) {\r\n                String styleName = data[i];\r\n                NamedStyle style = tSheet.getStyle(styleName);\r\n                if (style == null) {\r\n                    throw new RuntimeException(\"Style '\" + styleName + \"' not found\");\r\n                }\r\n                styles.add(style);\r\n            }\r\n            tSheet.addDynamicTemplate(new DynamicTemplate(name, tSheet.sheet(), nr, styles));\r\n        }\r\n\r\n        private void processTemplate(String[] data) {\r\n            String templateName = extractTemplateName(data);\r\n            Template t = tSheet.getTemplate(templateName);\r\n            if (t != null) {\r\n                int startRow = outRow;\r\n                int height = t.height();\r\n                for (int r = 0; r < height; r++, outRow++) {\r\n                    HSSFRow newRow = createNewRow(t, r, outRow);\r\n                    if (newRow != null) {\r\n                        copyTemplateRow(t, r, newRow, outRow, data);\r\n                    }\r\n                }\r\n                if (t instanceof StaticTemplate) {\r\n                    copyMergeRegions((StaticTemplate) t, startRow);\r\n                }\r\n            }\r\n        }\r\n\r\n        private void selectList(String[] data) {\r\n            if (data.length > 1 && data[1] != null && data[1].trim().length() > 0) {\r\n                String templateName = data[1];\r\n                StaticTemplate t = tSheet.getStaticTemplate(templateName);\r\n                if (t != null) {\r\n                    List<Integer> selectList = new ArrayList<Integer>(data.length - 2);\r\n                    try {\r\n                        for (int i = 2; i < data.length; i++) {\r\n                            selectList.add(Integer.valueOf(data[i]) - 1);\r\n                        }\r\n                    } catch (NumberFormatException e) {\r\n                        logger.warn(\"Invalid #select list: \" + Arrays.asList(data));\r\n                        selectList.clear();\r\n                    }\r\n                    if (selectList.size() > 0) {\r\n                        t.setSelectList(selectList);\r\n                    } else {\r\n                        t.setSelectList(null);\r\n                    }\r\n                }\r\n            } else {\r\n                logger.warn(\"No template name in #select\");\r\n            }\r\n        }\r\n\r\n        public HSSFRow createNewRow(Template t, int r, int rOut) {\r\n            HSSFRow newRow = newSheet.createRow(rOut);\r\n            newRow.setHeight((short) t.getRowHeight(r));\r\n            if (t.isRowBroken(r)) {\r\n                newSheet.setRowBreak(rOut);\r\n            }\r\n            return newRow;\r\n        }\r\n\r\n        private void copyTemplateRow(Template t, int r, HSSFRow newRow, int currentRow, String[] data) {\r\n            int currentCol = 0;\r\n            int width = t.width();\r\n            for (int c = 0; c < width; c++, currentCol++) {\r\n                copyTemplateCell(t, r, c, newRow, currentRow, currentCol, data);\r\n            }\r\n        }\r\n\r\n        private void copyTemplateCell(Template t, int r, int c, HSSFRow newRow, int currentRow, int currentCol, String[] data) {\r\n            HSSFCell tCell = t.getCell(r, c);\r\n            if (tCell != null) {\r\n                HSSFCell newCell = newRow.createCell(currentCol);\r\n                int cellType = tCell.getCellType();\r\n                newCell.setCellType(cellType);\r\n                newCell.setCellStyle(tCell.getCellStyle());\r\n                switch(cellType) {\r\n                    case HSSFCell.CELL_TYPE_BOOLEAN:\r\n                        {\r\n                            newCell.setCellValue(tCell.getBooleanCellValue());\r\n                        }\r\n                        break;\r\n                    case HSSFCell.CELL_TYPE_FORMULA:\r\n                        {\r\n                            String newFormula = recalculateRelativeRefs(t, r, c, currentRow, currentCol);\r\n                            newCell.setCellFormula(newFormula);\r\n                        }\r\n                        break;\r\n                    case HSSFCell.CELL_TYPE_NUMERIC:\r\n                        {\r\n                            newCell.setCellValue(tCell.getNumericCellValue());\r\n                        }\r\n                        break;\r\n                    case HSSFCell.CELL_TYPE_STRING:\r\n                        {\r\n                            newCell.setCellValue(tCell.getRichStringCellValue());\r\n                        }\r\n                        break;\r\n                }\r\n                substituteParameters(t, r, c, currentRow, currentCol, newCell, data);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Offset all relative references to correspond the new location of the cell.\r\n         *\r\n         * @param tCell\r\n         * @param originalRow - relative row number within given template\r\n         * @param originalCol - relative column number within given template\r\n         * @param newRow - new/target absolute row number of the cell\r\n         * @param newCol - new/target absolute row number of the cell\r\n         *\r\n         * @return recalculated formula\r\n         */\r\n        private String recalculateRelativeRefs(Template t, int originalRow, int originalCol, int newRow, int newCol) {\r\n            HSSFCell tCell = t.getCell(originalRow, originalCol);\r\n            String formula = tCell.getCellFormula();\r\n            Reference absRef = t.absoluteReference(originalRow, originalCol);\r\n            int roff = newRow - absRef.row();\r\n            int coff = newCol - absRef.column();\r\n            String newFormula = FormulaUtil.offsetRelativeReferences(workbook, formula, roff, coff);\r\n            if (logger.isTraceEnabled()) {\r\n                logger.trace(\"Formula @(\" + originalRow + \",\" + originalCol + \") recalculated:: \" + formula + \" ===(\" + roff + \",\" + coff + \")===> \" + newFormula + \" @(\" + newRow + \",\" + newCol + \")\");\r\n            }\r\n            return newFormula;\r\n        }\r\n\r\n        private void substituteParameters(Template t, int r, int c, int outRow, int outCol, HSSFCell newCell, String[] data) {\r\n            int idx = t.getParameterIndex(r, c);\r\n            if (idx > 0) {\r\n                String value = idx < data.length && data[idx] != null ? data[idx] : \"\";\r\n                try {\r\n                    setCellValue(newCell, value);\r\n                } catch (Exception e) {\r\n                    logger.warn(\"Failed to set value '\" + value + \"' to cell(\" + outRow + \",\" + outRow + \")\", e);\r\n                }\r\n            }\r\n        }\r\n\r\n        @SuppressWarnings(\"deprecation\")\r\n        private void setCellValue(HSSFCell newCell, String value) {\r\n            Double dval = tryToParseAsDouble(value);\r\n            if (dval != null) {\r\n                newCell.setCellValue(dval);\r\n            } else {\r\n                Date date = tryToParseAsDate(value);\r\n                if (date != null) {\r\n                    newCell.setCellValue(date);\r\n                } else {\r\n                    newCell.setCellValue(value);\r\n                }\r\n            }\r\n        }\r\n\r\n        private void copyMergeRegions(StaticTemplate t, int absTemplateOutputStartRow) {\r\n            for (MergeRegion m : t.getMergeRegions()) {\r\n                if (t.contains(m.start()) && (m.end().row() != Reference.INFINITY) && (m.end().column() != Reference.INFINITY)) {\r\n                    int vTopOffset = m.start().row() - t.start().row();\r\n                    int mh = m.end().row() - m.start().row();\r\n                    int firstRow = absTemplateOutputStartRow + vTopOffset;\r\n                    int lastRow = firstRow + mh;\r\n                    int w = t.width();\r\n                    int firstCol = w;\r\n                    int lastCol = 0;\r\n                    for (int c = 0; c < w; c++) {\r\n                        if (t.absoluteColumn(c) >= m.start().column() && t.absoluteColumn(c) <= m.end().column()) {\r\n                            firstCol = Math.min(firstCol, c);\r\n                            lastCol = Math.max(lastCol, c);\r\n                        }\r\n                    }\r\n                    newSheet.addMergedRegion(new CellRangeAddress(firstRow, lastRow, firstCol, lastCol));\r\n                }\r\n            }\r\n        }\r\n\r\n        private void copyConditionalFormatting() {\r\n            HSSFSheet sheet = tSheet.sheet();\r\n            HSSFSheetConditionalFormatting sheetCf = sheet.getSheetConditionalFormatting();\r\n            HSSFSheetConditionalFormatting newSheetcf = newSheet.getSheetConditionalFormatting();\r\n            int n = sheetCf.getNumConditionalFormattings();\r\n            for (int i = 0; i != n; i++) {\r\n                HSSFConditionalFormatting cf = sheetCf.getConditionalFormattingAt(i);\r\n                if (cf != null) {\r\n                    newSheetcf.addConditionalFormatting(cf);\r\n                }\r\n            }\r\n        }\r\n\r\n        private void copySheetSettings() {\r\n            HSSFSheet sheet = tSheet.sheet();\r\n            newSheet.setDisplayFormulas(sheet.isDisplayFormulas());\r\n            newSheet.setDisplayGridlines(sheet.isDisplayGridlines());\r\n            newSheet.setDisplayRowColHeadings(sheet.isDisplayRowColHeadings());\r\n            newSheet.setGridsPrinted(sheet.isGridsPrinted());\r\n            newSheet.setPrintGridlines(sheet.isPrintGridlines());\r\n            int fc = tSheet.getFirstColumn();\r\n            int lc = tSheet.getLastColumn();\r\n            for (int c = fc; c <= lc; c++) {\r\n                int nc = c - fc;\r\n                newSheet.setColumnWidth(nc, sheet.getColumnWidth(c));\r\n                if (sheet.isColumnBroken((short) c)) {\r\n                    newSheet.setColumnBreak((short) nc);\r\n                }\r\n                if (sheet.isColumnHidden(c)) {\r\n                    newSheet.setColumnHidden(nc, true);\r\n                }\r\n            }\r\n        }\r\n\r\n        private void copyPaneInformation() {\r\n            PaneInformation paneInfo = tSheet.sheet().getPaneInformation();\r\n            if (paneInfo != null) {\r\n                short vSplitPos = paneInfo.getVerticalSplitPosition();\r\n                short hSplitPos = paneInfo.getHorizontalSplitPosition();\r\n                short vSplitLeftColumn = paneInfo.getVerticalSplitLeftColumn();\r\n                short hSplitTopRow = paneInfo.getHorizontalSplitTopRow();\r\n                byte activePane = paneInfo.getActivePane();\r\n                if (paneInfo.isFreezePane()) {\r\n                    newSheet.createFreezePane(vSplitPos, hSplitPos, vSplitLeftColumn, hSplitTopRow);\r\n                } else {\r\n                    newSheet.createSplitPane(vSplitPos, hSplitPos, vSplitLeftColumn, hSplitTopRow, activePane);\r\n                }\r\n            }\r\n        }\r\n\r\n        private void copyPrintSetup() {\r\n            HSSFPrintSetup ps = tSheet.sheet().getPrintSetup();\r\n            if (ps != null) {\r\n                // Have to surround the code below with try/catch block\r\n                // since POI throws NPE in cases when the sheet\r\n                // does not contain Print Setup Record.\r\n                // POI also does not provide any means to determine if\r\n                // PrintSetupRecord is present except throwing NPE.\r\n                // TODO: patch POI to fix NPE at HSSFPrintSetup.getXXX methods\r\n                try {\r\n                    short nCopies = ps.getCopies();\r\n                    boolean draft = ps.getDraft();\r\n                    short fitHeight = ps.getFitHeight();\r\n                    short fitWidth = ps.getFitWidth();\r\n                    double footerMargin = ps.getFooterMargin();\r\n                    double headerMargin = ps.getHeaderMargin();\r\n                    short hResolution = ps.getHResolution();\r\n                    boolean landscape = ps.getLandscape();\r\n                    boolean leftToRight = ps.getLeftToRight();\r\n                    boolean noColor = ps.getNoColor();\r\n                    boolean noOrientation = ps.getNoOrientation();\r\n                    boolean notes = ps.getNotes();\r\n                    short options = ps.getOptions();\r\n                    short pageStart = ps.getPageStart();\r\n                    short paperSize = ps.getPaperSize();\r\n                    short scale = ps.getScale();\r\n                    boolean usePage = ps.getUsePage();\r\n                    boolean validSettings = ps.getValidSettings();\r\n                    short vResolution = ps.getVResolution();\r\n                    HSSFPrintSetup newPs = newSheet.getPrintSetup();\r\n                    newPs.setCopies(nCopies);\r\n                    newPs.setDraft(draft);\r\n                    newPs.setFitHeight(fitHeight);\r\n                    newPs.setFitWidth(fitWidth);\r\n                    newPs.setFooterMargin(footerMargin);\r\n                    newPs.setHeaderMargin(headerMargin);\r\n                    newPs.setHResolution(hResolution);\r\n                    newPs.setLandscape(landscape);\r\n                    newPs.setLeftToRight(leftToRight);\r\n                    newPs.setNoColor(noColor);\r\n                    newPs.setNoOrientation(noOrientation);\r\n                    newPs.setNotes(notes);\r\n                    newPs.setOptions(options);\r\n                    newPs.setPageStart(pageStart);\r\n                    newPs.setPaperSize(paperSize);\r\n                    newPs.setScale(scale);\r\n                    newPs.setUsePage(usePage);\r\n                    newPs.setValidSettings(validSettings);\r\n                    newPs.setVResolution(vResolution);\r\n                } catch (NullPointerException e) {\r\n                    if (logger.isTraceEnabled()) {\r\n                        logger.warn(\"Print Setup information is missing\");\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private static Double tryToParseAsDouble(String value) {\r\n        try {\r\n            return Double.parseDouble(value);\r\n        } catch (NumberFormatException e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    private static Date tryToParseAsDate(String value) {\r\n        for (DateFormat df : new DateFormat[] { new SimpleDateFormat(\"MM/dd/yyyy HH:mm:ss\"), new SimpleDateFormat(\"MM/dd/yyyy HH:mm\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"dd-MMM-yyyy HH:mm:ss\"), new SimpleDateFormat(\"dd-MMM-yyyy HH:mm\"), new SimpleDateFormat(\"dd-MMM-yyyy\") }) {\r\n            try {\r\n                return df.parse(value);\r\n            } catch (ParseException pe) {\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private static ByteArrayOutputStream toByteArrayOutputStream(InputStream is) throws IOException {\r\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n        byte[] b = new byte[4096];\r\n        int off = 0;\r\n        int len = 0;\r\n        while ((len = is.read(b, off, b.length)) != -1) {\r\n            bos.write(b, off, len);\r\n        }\r\n        bos.flush();\r\n        return bos;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/5_templateit/src/main/java/org/templateit/TemplateProcessorTest.java",
		"test_prompt": "// TemplateProcessorTest.java\npackage org.templateit;\n\nimport java.io.BufferedInputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.text.DateFormat;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Set;\nimport org.apache.log4j.Logger;\nimport org.apache.poi.hssf.usermodel.HSSFCell;\nimport org.apache.poi.hssf.usermodel.HSSFConditionalFormatting;\nimport org.apache.poi.hssf.usermodel.HSSFPrintSetup;\nimport org.apache.poi.hssf.usermodel.HSSFRow;\nimport org.apache.poi.hssf.usermodel.HSSFSheet;\nimport org.apache.poi.hssf.usermodel.HSSFSheetConditionalFormatting;\nimport org.apache.poi.hssf.usermodel.HSSFWorkbook;\nimport org.apache.poi.hssf.util.CellRangeAddress;\nimport org.apache.poi.hssf.util.PaneInformation;\nimport org.templateit.util.FormulaUtil;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TemplateProcessor}.\n* It contains ten unit test cases for the {@link TemplateProcessor#generateNewSheet(String, String, Iterator)} method.\n*/\nclass TemplateProcessorTest {"
	},
	{
		"original_code": "// StaticTemplate.java\n/*\r\n * Copyright(C) 2008-2009 Dmitriy Kumshayev. <dq@mail.com>\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\npackage org.templateit;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.LinkedList;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport org.apache.poi.hssf.usermodel.HSSFCell;\r\nimport org.apache.poi.hssf.usermodel.HSSFRow;\r\nimport org.apache.poi.hssf.usermodel.HSSFSheet;\r\n\r\n/**\r\n * Represents a rectangular template area in the template workbook.\r\n * Encapsulated accompanying data such as template parameters,\r\n * columns permutation information and the original template sheet object.\r\n *\r\n * @author Dmitriy Kumshayev\r\n */\r\nclass StaticTemplate extends Template {\r\n\r\n    private final List<MergeRegion> mergeRegions = new LinkedList<MergeRegion>();\r\n\r\n    List<Integer> selectList = null;\r\n\r\n    private List<Integer> absSelectList = null;\r\n\r\n    private final Region region = new Region();\r\n\r\n    private Map<Integer, Map<Integer, Integer>> parameterIndexMap = null;\r\n\r\n    public StaticTemplate(String name, HSSFSheet sheet) {\r\n        super(name, sheet);\r\n    }\r\n\r\n    public List<MergeRegion> getMergeRegions() {\r\n        return mergeRegions;\r\n    }\r\n\r\n    public void addMergeRegion(MergeRegion mreg) {\r\n        mergeRegions.add(mreg);\r\n    }\r\n\r\n    public void setSelectList(List<Integer> selectList) {\r\n        this.selectList = selectList;\r\n        // calculate parameterIndexMap\r\n        if (selectList != null) {\r\n            // Initialize absolute numbers of the selected columns\r\n            this.absSelectList = new ArrayList<Integer>(selectList.size());\r\n            for (int c = 0; c < width(); c++) {\r\n                absSelectList.add(absoluteColumn(c));\r\n            }\r\n            parameterIndexMap = new HashMap<Integer, Map<Integer, Integer>>();\r\n            int idx = 1;\r\n            int h = height();\r\n            int w = width();\r\n            for (int r = 0; r < h; r++) {\r\n                for (int c = 0; c < w; c++) {\r\n                    int col = selectList.get(c);\r\n                    Parameter p = getParameter(r, col);\r\n                    if (p != null) {\r\n                        Map<Integer, Integer> rowIndexMap = parameterIndexMap.get(r);\r\n                        if (rowIndexMap == null) {\r\n                            rowIndexMap = new HashMap<Integer, Integer>();\r\n                            parameterIndexMap.put(r, rowIndexMap);\r\n                        }\r\n                        rowIndexMap.put(c, idx++);\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            parameterIndexMap = null;\r\n            absSelectList = null;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public int getRowHeight(int row) {\r\n        HSSFRow trow = sheet.getRow(absoluteRow(row));\r\n        if (trow != null) {\r\n            return trow.getHeight();\r\n        }\r\n        return sheet.getDefaultRowHeight();\r\n    }\r\n\r\n    /**\r\n     * @param r - 0-based relative row number within the template\r\n     * @return\r\n     */\r\n    private int absoluteRow(int r) {\r\n        return start().row() + r;\r\n    }\r\n\r\n    @Override\r\n    public boolean isRowBroken(int r) {\r\n        return sheet.isRowBroken(absoluteRow(r));\r\n    }\r\n\r\n    /**\r\n     * @param r - 0-based relative column number within the template\r\n     * @return\r\n     */\r\n    public int absoluteColumn(int c) {\r\n        if (selectList != null) {\r\n            return start().column() + selectList.get(c);\r\n        } else {\r\n            return start().column() + c;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public int getParameterIndex(int r, int c) {\r\n        Integer idx = -1;\r\n        if (selectList == null) {\r\n            Parameter p = super.getParameter(r, c);\r\n            if (p != null) {\r\n                idx = p.getIndex();\r\n            }\r\n        } else {\r\n            idx = parameterIndexMap.get(r).get(c);\r\n            if (idx == null) {\r\n                idx = -1;\r\n            }\r\n        }\r\n        return idx;\r\n    }\r\n\r\n    public HSSFCell getCell(int r, int c) {\r\n        HSSFRow tRow = sheet.getRow(absoluteRow(r));\r\n        if (tRow != null) {\r\n            return tRow.getCell(absoluteColumn(c));\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private int absoluteFirstRow() {\r\n        return absoluteRow(0);\r\n    }\r\n\r\n    private int absoluteFirstColumn() {\r\n        return absoluteColumn(0);\r\n    }\r\n\r\n    private int absoluteLastRow() {\r\n        return absoluteRow(height() - 1);\r\n    }\r\n\r\n    private int absoluteLastColumn() {\r\n        return absoluteColumn(width() - 1);\r\n    }\r\n\r\n    @Override\r\n    public Reference absoluteReference(int r, int c) {\r\n        Reference ref = new Reference(absoluteRow(r), absoluteColumn(c));\r\n        return ref;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return name + \",\" + super.toString();\r\n    }\r\n\r\n    @Override\r\n    public int height() {\r\n        return end().row() - start().row() + 1;\r\n    }\r\n\r\n    @Override\r\n    public int width() {\r\n        if (selectList != null) {\r\n            return selectList.size();\r\n        } else {\r\n            return end().column() - start().column() + 1;\r\n        }\r\n    }\r\n\r\n    /* Wrapping methods to access region */\r\n    public void setStartReference(Reference start) {\r\n        region.setStartReference(start);\r\n    }\r\n\r\n    public Reference start() {\r\n        return region.start();\r\n    }\r\n\r\n    public void setEndReference(Reference end) {\r\n        region.setEndReference(end);\r\n    }\r\n\r\n    public Reference end() {\r\n        return region.end();\r\n    }\r\n\r\n    /**\r\n     * @return true if this Template contains the reference\r\n     */\r\n    public boolean contains(Reference reference) {\r\n        if (selectList == null) {\r\n            return region.contains(reference);\r\n        } else {\r\n            return absoluteFirstRow() <= reference.row() && reference.row() <= absoluteLastRow() && absoluteFirstColumn() <= reference.column() && reference.column() <= absoluteLastColumn() && (absSelectList != null ? absSelectList.contains(reference.column()) : true);\r\n        }\r\n    }\r\n\r\n    public boolean contains(Region region) {\r\n        return region.contains(region);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/5_templateit/src/main/java/org/templateit/StaticTemplateTest0.java",
		"test_prompt": "// StaticTemplateTest0.java\npackage org.templateit;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.poi.hssf.usermodel.HSSFCell;\nimport org.apache.poi.hssf.usermodel.HSSFRow;\nimport org.apache.poi.hssf.usermodel.HSSFSheet;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StaticTemplate}.\n* It contains ten unit test cases for the {@link StaticTemplate#isRowBroken(int)} method.\n*/\nclass StaticTemplateTest0 {"
	},
	{
		"original_code": "// StaticTemplate.java\n/*\r\n * Copyright(C) 2008-2009 Dmitriy Kumshayev. <dq@mail.com>\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\npackage org.templateit;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.LinkedList;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport org.apache.poi.hssf.usermodel.HSSFCell;\r\nimport org.apache.poi.hssf.usermodel.HSSFRow;\r\nimport org.apache.poi.hssf.usermodel.HSSFSheet;\r\n\r\n/**\r\n * Represents a rectangular template area in the template workbook.\r\n * Encapsulated accompanying data such as template parameters,\r\n * columns permutation information and the original template sheet object.\r\n *\r\n * @author Dmitriy Kumshayev\r\n */\r\nclass StaticTemplate extends Template {\r\n\r\n    private final List<MergeRegion> mergeRegions = new LinkedList<MergeRegion>();\r\n\r\n    List<Integer> selectList = null;\r\n\r\n    private List<Integer> absSelectList = null;\r\n\r\n    private final Region region = new Region();\r\n\r\n    private Map<Integer, Map<Integer, Integer>> parameterIndexMap = null;\r\n\r\n    public StaticTemplate(String name, HSSFSheet sheet) {\r\n        super(name, sheet);\r\n    }\r\n\r\n    public List<MergeRegion> getMergeRegions() {\r\n        return mergeRegions;\r\n    }\r\n\r\n    public void addMergeRegion(MergeRegion mreg) {\r\n        mergeRegions.add(mreg);\r\n    }\r\n\r\n    public void setSelectList(List<Integer> selectList) {\r\n        this.selectList = selectList;\r\n        // calculate parameterIndexMap\r\n        if (selectList != null) {\r\n            // Initialize absolute numbers of the selected columns\r\n            this.absSelectList = new ArrayList<Integer>(selectList.size());\r\n            for (int c = 0; c < width(); c++) {\r\n                absSelectList.add(absoluteColumn(c));\r\n            }\r\n            parameterIndexMap = new HashMap<Integer, Map<Integer, Integer>>();\r\n            int idx = 1;\r\n            int h = height();\r\n            int w = width();\r\n            for (int r = 0; r < h; r++) {\r\n                for (int c = 0; c < w; c++) {\r\n                    int col = selectList.get(c);\r\n                    Parameter p = getParameter(r, col);\r\n                    if (p != null) {\r\n                        Map<Integer, Integer> rowIndexMap = parameterIndexMap.get(r);\r\n                        if (rowIndexMap == null) {\r\n                            rowIndexMap = new HashMap<Integer, Integer>();\r\n                            parameterIndexMap.put(r, rowIndexMap);\r\n                        }\r\n                        rowIndexMap.put(c, idx++);\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            parameterIndexMap = null;\r\n            absSelectList = null;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public int getRowHeight(int row) {\r\n        HSSFRow trow = sheet.getRow(absoluteRow(row));\r\n        if (trow != null) {\r\n            return trow.getHeight();\r\n        }\r\n        return sheet.getDefaultRowHeight();\r\n    }\r\n\r\n    /**\r\n     * @param r - 0-based relative row number within the template\r\n     * @return\r\n     */\r\n    private int absoluteRow(int r) {\r\n        return start().row() + r;\r\n    }\r\n\r\n    @Override\r\n    public boolean isRowBroken(int r) {\r\n        return sheet.isRowBroken(absoluteRow(r));\r\n    }\r\n\r\n    /**\r\n     * @param r - 0-based relative column number within the template\r\n     * @return\r\n     */\r\n    public int absoluteColumn(int c) {\r\n        if (selectList != null) {\r\n            return start().column() + selectList.get(c);\r\n        } else {\r\n            return start().column() + c;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public int getParameterIndex(int r, int c) {\r\n        Integer idx = -1;\r\n        if (selectList == null) {\r\n            Parameter p = super.getParameter(r, c);\r\n            if (p != null) {\r\n                idx = p.getIndex();\r\n            }\r\n        } else {\r\n            idx = parameterIndexMap.get(r).get(c);\r\n            if (idx == null) {\r\n                idx = -1;\r\n            }\r\n        }\r\n        return idx;\r\n    }\r\n\r\n    public HSSFCell getCell(int r, int c) {\r\n        HSSFRow tRow = sheet.getRow(absoluteRow(r));\r\n        if (tRow != null) {\r\n            return tRow.getCell(absoluteColumn(c));\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private int absoluteFirstRow() {\r\n        return absoluteRow(0);\r\n    }\r\n\r\n    private int absoluteFirstColumn() {\r\n        return absoluteColumn(0);\r\n    }\r\n\r\n    private int absoluteLastRow() {\r\n        return absoluteRow(height() - 1);\r\n    }\r\n\r\n    private int absoluteLastColumn() {\r\n        return absoluteColumn(width() - 1);\r\n    }\r\n\r\n    @Override\r\n    public Reference absoluteReference(int r, int c) {\r\n        Reference ref = new Reference(absoluteRow(r), absoluteColumn(c));\r\n        return ref;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return name + \",\" + super.toString();\r\n    }\r\n\r\n    @Override\r\n    public int height() {\r\n        return end().row() - start().row() + 1;\r\n    }\r\n\r\n    @Override\r\n    public int width() {\r\n        if (selectList != null) {\r\n            return selectList.size();\r\n        } else {\r\n            return end().column() - start().column() + 1;\r\n        }\r\n    }\r\n\r\n    /* Wrapping methods to access region */\r\n    public void setStartReference(Reference start) {\r\n        region.setStartReference(start);\r\n    }\r\n\r\n    public Reference start() {\r\n        return region.start();\r\n    }\r\n\r\n    public void setEndReference(Reference end) {\r\n        region.setEndReference(end);\r\n    }\r\n\r\n    public Reference end() {\r\n        return region.end();\r\n    }\r\n\r\n    /**\r\n     * @return true if this Template contains the reference\r\n     */\r\n    public boolean contains(Reference reference) {\r\n        if (selectList == null) {\r\n            return region.contains(reference);\r\n        } else {\r\n            return absoluteFirstRow() <= reference.row() && reference.row() <= absoluteLastRow() && absoluteFirstColumn() <= reference.column() && reference.column() <= absoluteLastColumn() && (absSelectList != null ? absSelectList.contains(reference.column()) : true);\r\n        }\r\n    }\r\n\r\n    public boolean contains(Region region) {\r\n        return region.contains(region);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/5_templateit/src/main/java/org/templateit/StaticTemplateTest1.java",
		"test_prompt": "// StaticTemplateTest1.java\npackage org.templateit;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.poi.hssf.usermodel.HSSFCell;\nimport org.apache.poi.hssf.usermodel.HSSFRow;\nimport org.apache.poi.hssf.usermodel.HSSFSheet;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StaticTemplate}.\n* It contains ten unit test cases for the {@link StaticTemplate#absoluteColumn(int)} method.\n*/\nclass StaticTemplateTest1 {"
	},
	{
		"original_code": "// StaticTemplate.java\n/*\r\n * Copyright(C) 2008-2009 Dmitriy Kumshayev. <dq@mail.com>\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\npackage org.templateit;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.LinkedList;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport org.apache.poi.hssf.usermodel.HSSFCell;\r\nimport org.apache.poi.hssf.usermodel.HSSFRow;\r\nimport org.apache.poi.hssf.usermodel.HSSFSheet;\r\n\r\n/**\r\n * Represents a rectangular template area in the template workbook.\r\n * Encapsulated accompanying data such as template parameters,\r\n * columns permutation information and the original template sheet object.\r\n *\r\n * @author Dmitriy Kumshayev\r\n */\r\nclass StaticTemplate extends Template {\r\n\r\n    private final List<MergeRegion> mergeRegions = new LinkedList<MergeRegion>();\r\n\r\n    List<Integer> selectList = null;\r\n\r\n    private List<Integer> absSelectList = null;\r\n\r\n    private final Region region = new Region();\r\n\r\n    private Map<Integer, Map<Integer, Integer>> parameterIndexMap = null;\r\n\r\n    public StaticTemplate(String name, HSSFSheet sheet) {\r\n        super(name, sheet);\r\n    }\r\n\r\n    public List<MergeRegion> getMergeRegions() {\r\n        return mergeRegions;\r\n    }\r\n\r\n    public void addMergeRegion(MergeRegion mreg) {\r\n        mergeRegions.add(mreg);\r\n    }\r\n\r\n    public void setSelectList(List<Integer> selectList) {\r\n        this.selectList = selectList;\r\n        // calculate parameterIndexMap\r\n        if (selectList != null) {\r\n            // Initialize absolute numbers of the selected columns\r\n            this.absSelectList = new ArrayList<Integer>(selectList.size());\r\n            for (int c = 0; c < width(); c++) {\r\n                absSelectList.add(absoluteColumn(c));\r\n            }\r\n            parameterIndexMap = new HashMap<Integer, Map<Integer, Integer>>();\r\n            int idx = 1;\r\n            int h = height();\r\n            int w = width();\r\n            for (int r = 0; r < h; r++) {\r\n                for (int c = 0; c < w; c++) {\r\n                    int col = selectList.get(c);\r\n                    Parameter p = getParameter(r, col);\r\n                    if (p != null) {\r\n                        Map<Integer, Integer> rowIndexMap = parameterIndexMap.get(r);\r\n                        if (rowIndexMap == null) {\r\n                            rowIndexMap = new HashMap<Integer, Integer>();\r\n                            parameterIndexMap.put(r, rowIndexMap);\r\n                        }\r\n                        rowIndexMap.put(c, idx++);\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            parameterIndexMap = null;\r\n            absSelectList = null;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public int getRowHeight(int row) {\r\n        HSSFRow trow = sheet.getRow(absoluteRow(row));\r\n        if (trow != null) {\r\n            return trow.getHeight();\r\n        }\r\n        return sheet.getDefaultRowHeight();\r\n    }\r\n\r\n    /**\r\n     * @param r - 0-based relative row number within the template\r\n     * @return\r\n     */\r\n    private int absoluteRow(int r) {\r\n        return start().row() + r;\r\n    }\r\n\r\n    @Override\r\n    public boolean isRowBroken(int r) {\r\n        return sheet.isRowBroken(absoluteRow(r));\r\n    }\r\n\r\n    /**\r\n     * @param r - 0-based relative column number within the template\r\n     * @return\r\n     */\r\n    public int absoluteColumn(int c) {\r\n        if (selectList != null) {\r\n            return start().column() + selectList.get(c);\r\n        } else {\r\n            return start().column() + c;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public int getParameterIndex(int r, int c) {\r\n        Integer idx = -1;\r\n        if (selectList == null) {\r\n            Parameter p = super.getParameter(r, c);\r\n            if (p != null) {\r\n                idx = p.getIndex();\r\n            }\r\n        } else {\r\n            idx = parameterIndexMap.get(r).get(c);\r\n            if (idx == null) {\r\n                idx = -1;\r\n            }\r\n        }\r\n        return idx;\r\n    }\r\n\r\n    public HSSFCell getCell(int r, int c) {\r\n        HSSFRow tRow = sheet.getRow(absoluteRow(r));\r\n        if (tRow != null) {\r\n            return tRow.getCell(absoluteColumn(c));\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private int absoluteFirstRow() {\r\n        return absoluteRow(0);\r\n    }\r\n\r\n    private int absoluteFirstColumn() {\r\n        return absoluteColumn(0);\r\n    }\r\n\r\n    private int absoluteLastRow() {\r\n        return absoluteRow(height() - 1);\r\n    }\r\n\r\n    private int absoluteLastColumn() {\r\n        return absoluteColumn(width() - 1);\r\n    }\r\n\r\n    @Override\r\n    public Reference absoluteReference(int r, int c) {\r\n        Reference ref = new Reference(absoluteRow(r), absoluteColumn(c));\r\n        return ref;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return name + \",\" + super.toString();\r\n    }\r\n\r\n    @Override\r\n    public int height() {\r\n        return end().row() - start().row() + 1;\r\n    }\r\n\r\n    @Override\r\n    public int width() {\r\n        if (selectList != null) {\r\n            return selectList.size();\r\n        } else {\r\n            return end().column() - start().column() + 1;\r\n        }\r\n    }\r\n\r\n    /* Wrapping methods to access region */\r\n    public void setStartReference(Reference start) {\r\n        region.setStartReference(start);\r\n    }\r\n\r\n    public Reference start() {\r\n        return region.start();\r\n    }\r\n\r\n    public void setEndReference(Reference end) {\r\n        region.setEndReference(end);\r\n    }\r\n\r\n    public Reference end() {\r\n        return region.end();\r\n    }\r\n\r\n    /**\r\n     * @return true if this Template contains the reference\r\n     */\r\n    public boolean contains(Reference reference) {\r\n        if (selectList == null) {\r\n            return region.contains(reference);\r\n        } else {\r\n            return absoluteFirstRow() <= reference.row() && reference.row() <= absoluteLastRow() && absoluteFirstColumn() <= reference.column() && reference.column() <= absoluteLastColumn() && (absSelectList != null ? absSelectList.contains(reference.column()) : true);\r\n        }\r\n    }\r\n\r\n    public boolean contains(Region region) {\r\n        return region.contains(region);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/5_templateit/src/main/java/org/templateit/StaticTemplateTest2.java",
		"test_prompt": "// StaticTemplateTest2.java\npackage org.templateit;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.poi.hssf.usermodel.HSSFCell;\nimport org.apache.poi.hssf.usermodel.HSSFRow;\nimport org.apache.poi.hssf.usermodel.HSSFSheet;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StaticTemplate}.\n* It contains ten unit test cases for the {@link StaticTemplate#absoluteReference(int, int)} method.\n*/\nclass StaticTemplateTest2 {"
	},
	{
		"original_code": "// StaticTemplate.java\n/*\r\n * Copyright(C) 2008-2009 Dmitriy Kumshayev. <dq@mail.com>\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\npackage org.templateit;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.LinkedList;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport org.apache.poi.hssf.usermodel.HSSFCell;\r\nimport org.apache.poi.hssf.usermodel.HSSFRow;\r\nimport org.apache.poi.hssf.usermodel.HSSFSheet;\r\n\r\n/**\r\n * Represents a rectangular template area in the template workbook.\r\n * Encapsulated accompanying data such as template parameters,\r\n * columns permutation information and the original template sheet object.\r\n *\r\n * @author Dmitriy Kumshayev\r\n */\r\nclass StaticTemplate extends Template {\r\n\r\n    private final List<MergeRegion> mergeRegions = new LinkedList<MergeRegion>();\r\n\r\n    List<Integer> selectList = null;\r\n\r\n    private List<Integer> absSelectList = null;\r\n\r\n    private final Region region = new Region();\r\n\r\n    private Map<Integer, Map<Integer, Integer>> parameterIndexMap = null;\r\n\r\n    public StaticTemplate(String name, HSSFSheet sheet) {\r\n        super(name, sheet);\r\n    }\r\n\r\n    public List<MergeRegion> getMergeRegions() {\r\n        return mergeRegions;\r\n    }\r\n\r\n    public void addMergeRegion(MergeRegion mreg) {\r\n        mergeRegions.add(mreg);\r\n    }\r\n\r\n    public void setSelectList(List<Integer> selectList) {\r\n        this.selectList = selectList;\r\n        // calculate parameterIndexMap\r\n        if (selectList != null) {\r\n            // Initialize absolute numbers of the selected columns\r\n            this.absSelectList = new ArrayList<Integer>(selectList.size());\r\n            for (int c = 0; c < width(); c++) {\r\n                absSelectList.add(absoluteColumn(c));\r\n            }\r\n            parameterIndexMap = new HashMap<Integer, Map<Integer, Integer>>();\r\n            int idx = 1;\r\n            int h = height();\r\n            int w = width();\r\n            for (int r = 0; r < h; r++) {\r\n                for (int c = 0; c < w; c++) {\r\n                    int col = selectList.get(c);\r\n                    Parameter p = getParameter(r, col);\r\n                    if (p != null) {\r\n                        Map<Integer, Integer> rowIndexMap = parameterIndexMap.get(r);\r\n                        if (rowIndexMap == null) {\r\n                            rowIndexMap = new HashMap<Integer, Integer>();\r\n                            parameterIndexMap.put(r, rowIndexMap);\r\n                        }\r\n                        rowIndexMap.put(c, idx++);\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            parameterIndexMap = null;\r\n            absSelectList = null;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public int getRowHeight(int row) {\r\n        HSSFRow trow = sheet.getRow(absoluteRow(row));\r\n        if (trow != null) {\r\n            return trow.getHeight();\r\n        }\r\n        return sheet.getDefaultRowHeight();\r\n    }\r\n\r\n    /**\r\n     * @param r - 0-based relative row number within the template\r\n     * @return\r\n     */\r\n    private int absoluteRow(int r) {\r\n        return start().row() + r;\r\n    }\r\n\r\n    @Override\r\n    public boolean isRowBroken(int r) {\r\n        return sheet.isRowBroken(absoluteRow(r));\r\n    }\r\n\r\n    /**\r\n     * @param r - 0-based relative column number within the template\r\n     * @return\r\n     */\r\n    public int absoluteColumn(int c) {\r\n        if (selectList != null) {\r\n            return start().column() + selectList.get(c);\r\n        } else {\r\n            return start().column() + c;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public int getParameterIndex(int r, int c) {\r\n        Integer idx = -1;\r\n        if (selectList == null) {\r\n            Parameter p = super.getParameter(r, c);\r\n            if (p != null) {\r\n                idx = p.getIndex();\r\n            }\r\n        } else {\r\n            idx = parameterIndexMap.get(r).get(c);\r\n            if (idx == null) {\r\n                idx = -1;\r\n            }\r\n        }\r\n        return idx;\r\n    }\r\n\r\n    public HSSFCell getCell(int r, int c) {\r\n        HSSFRow tRow = sheet.getRow(absoluteRow(r));\r\n        if (tRow != null) {\r\n            return tRow.getCell(absoluteColumn(c));\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private int absoluteFirstRow() {\r\n        return absoluteRow(0);\r\n    }\r\n\r\n    private int absoluteFirstColumn() {\r\n        return absoluteColumn(0);\r\n    }\r\n\r\n    private int absoluteLastRow() {\r\n        return absoluteRow(height() - 1);\r\n    }\r\n\r\n    private int absoluteLastColumn() {\r\n        return absoluteColumn(width() - 1);\r\n    }\r\n\r\n    @Override\r\n    public Reference absoluteReference(int r, int c) {\r\n        Reference ref = new Reference(absoluteRow(r), absoluteColumn(c));\r\n        return ref;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return name + \",\" + super.toString();\r\n    }\r\n\r\n    @Override\r\n    public int height() {\r\n        return end().row() - start().row() + 1;\r\n    }\r\n\r\n    @Override\r\n    public int width() {\r\n        if (selectList != null) {\r\n            return selectList.size();\r\n        } else {\r\n            return end().column() - start().column() + 1;\r\n        }\r\n    }\r\n\r\n    /* Wrapping methods to access region */\r\n    public void setStartReference(Reference start) {\r\n        region.setStartReference(start);\r\n    }\r\n\r\n    public Reference start() {\r\n        return region.start();\r\n    }\r\n\r\n    public void setEndReference(Reference end) {\r\n        region.setEndReference(end);\r\n    }\r\n\r\n    public Reference end() {\r\n        return region.end();\r\n    }\r\n\r\n    /**\r\n     * @return true if this Template contains the reference\r\n     */\r\n    public boolean contains(Reference reference) {\r\n        if (selectList == null) {\r\n            return region.contains(reference);\r\n        } else {\r\n            return absoluteFirstRow() <= reference.row() && reference.row() <= absoluteLastRow() && absoluteFirstColumn() <= reference.column() && reference.column() <= absoluteLastColumn() && (absSelectList != null ? absSelectList.contains(reference.column()) : true);\r\n        }\r\n    }\r\n\r\n    public boolean contains(Region region) {\r\n        return region.contains(region);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/5_templateit/src/main/java/org/templateit/StaticTemplateTest3.java",
		"test_prompt": "// StaticTemplateTest3.java\npackage org.templateit;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.poi.hssf.usermodel.HSSFCell;\nimport org.apache.poi.hssf.usermodel.HSSFRow;\nimport org.apache.poi.hssf.usermodel.HSSFSheet;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StaticTemplate}.\n* It contains ten unit test cases for the {@link StaticTemplate#height()} method.\n*/\nclass StaticTemplateTest3 {"
	},
	{
		"original_code": "// StaticTemplate.java\n/*\r\n * Copyright(C) 2008-2009 Dmitriy Kumshayev. <dq@mail.com>\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\npackage org.templateit;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.LinkedList;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport org.apache.poi.hssf.usermodel.HSSFCell;\r\nimport org.apache.poi.hssf.usermodel.HSSFRow;\r\nimport org.apache.poi.hssf.usermodel.HSSFSheet;\r\n\r\n/**\r\n * Represents a rectangular template area in the template workbook.\r\n * Encapsulated accompanying data such as template parameters,\r\n * columns permutation information and the original template sheet object.\r\n *\r\n * @author Dmitriy Kumshayev\r\n */\r\nclass StaticTemplate extends Template {\r\n\r\n    private final List<MergeRegion> mergeRegions = new LinkedList<MergeRegion>();\r\n\r\n    List<Integer> selectList = null;\r\n\r\n    private List<Integer> absSelectList = null;\r\n\r\n    private final Region region = new Region();\r\n\r\n    private Map<Integer, Map<Integer, Integer>> parameterIndexMap = null;\r\n\r\n    public StaticTemplate(String name, HSSFSheet sheet) {\r\n        super(name, sheet);\r\n    }\r\n\r\n    public List<MergeRegion> getMergeRegions() {\r\n        return mergeRegions;\r\n    }\r\n\r\n    public void addMergeRegion(MergeRegion mreg) {\r\n        mergeRegions.add(mreg);\r\n    }\r\n\r\n    public void setSelectList(List<Integer> selectList) {\r\n        this.selectList = selectList;\r\n        // calculate parameterIndexMap\r\n        if (selectList != null) {\r\n            // Initialize absolute numbers of the selected columns\r\n            this.absSelectList = new ArrayList<Integer>(selectList.size());\r\n            for (int c = 0; c < width(); c++) {\r\n                absSelectList.add(absoluteColumn(c));\r\n            }\r\n            parameterIndexMap = new HashMap<Integer, Map<Integer, Integer>>();\r\n            int idx = 1;\r\n            int h = height();\r\n            int w = width();\r\n            for (int r = 0; r < h; r++) {\r\n                for (int c = 0; c < w; c++) {\r\n                    int col = selectList.get(c);\r\n                    Parameter p = getParameter(r, col);\r\n                    if (p != null) {\r\n                        Map<Integer, Integer> rowIndexMap = parameterIndexMap.get(r);\r\n                        if (rowIndexMap == null) {\r\n                            rowIndexMap = new HashMap<Integer, Integer>();\r\n                            parameterIndexMap.put(r, rowIndexMap);\r\n                        }\r\n                        rowIndexMap.put(c, idx++);\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            parameterIndexMap = null;\r\n            absSelectList = null;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public int getRowHeight(int row) {\r\n        HSSFRow trow = sheet.getRow(absoluteRow(row));\r\n        if (trow != null) {\r\n            return trow.getHeight();\r\n        }\r\n        return sheet.getDefaultRowHeight();\r\n    }\r\n\r\n    /**\r\n     * @param r - 0-based relative row number within the template\r\n     * @return\r\n     */\r\n    private int absoluteRow(int r) {\r\n        return start().row() + r;\r\n    }\r\n\r\n    @Override\r\n    public boolean isRowBroken(int r) {\r\n        return sheet.isRowBroken(absoluteRow(r));\r\n    }\r\n\r\n    /**\r\n     * @param r - 0-based relative column number within the template\r\n     * @return\r\n     */\r\n    public int absoluteColumn(int c) {\r\n        if (selectList != null) {\r\n            return start().column() + selectList.get(c);\r\n        } else {\r\n            return start().column() + c;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public int getParameterIndex(int r, int c) {\r\n        Integer idx = -1;\r\n        if (selectList == null) {\r\n            Parameter p = super.getParameter(r, c);\r\n            if (p != null) {\r\n                idx = p.getIndex();\r\n            }\r\n        } else {\r\n            idx = parameterIndexMap.get(r).get(c);\r\n            if (idx == null) {\r\n                idx = -1;\r\n            }\r\n        }\r\n        return idx;\r\n    }\r\n\r\n    public HSSFCell getCell(int r, int c) {\r\n        HSSFRow tRow = sheet.getRow(absoluteRow(r));\r\n        if (tRow != null) {\r\n            return tRow.getCell(absoluteColumn(c));\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private int absoluteFirstRow() {\r\n        return absoluteRow(0);\r\n    }\r\n\r\n    private int absoluteFirstColumn() {\r\n        return absoluteColumn(0);\r\n    }\r\n\r\n    private int absoluteLastRow() {\r\n        return absoluteRow(height() - 1);\r\n    }\r\n\r\n    private int absoluteLastColumn() {\r\n        return absoluteColumn(width() - 1);\r\n    }\r\n\r\n    @Override\r\n    public Reference absoluteReference(int r, int c) {\r\n        Reference ref = new Reference(absoluteRow(r), absoluteColumn(c));\r\n        return ref;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return name + \",\" + super.toString();\r\n    }\r\n\r\n    @Override\r\n    public int height() {\r\n        return end().row() - start().row() + 1;\r\n    }\r\n\r\n    @Override\r\n    public int width() {\r\n        if (selectList != null) {\r\n            return selectList.size();\r\n        } else {\r\n            return end().column() - start().column() + 1;\r\n        }\r\n    }\r\n\r\n    /* Wrapping methods to access region */\r\n    public void setStartReference(Reference start) {\r\n        region.setStartReference(start);\r\n    }\r\n\r\n    public Reference start() {\r\n        return region.start();\r\n    }\r\n\r\n    public void setEndReference(Reference end) {\r\n        region.setEndReference(end);\r\n    }\r\n\r\n    public Reference end() {\r\n        return region.end();\r\n    }\r\n\r\n    /**\r\n     * @return true if this Template contains the reference\r\n     */\r\n    public boolean contains(Reference reference) {\r\n        if (selectList == null) {\r\n            return region.contains(reference);\r\n        } else {\r\n            return absoluteFirstRow() <= reference.row() && reference.row() <= absoluteLastRow() && absoluteFirstColumn() <= reference.column() && reference.column() <= absoluteLastColumn() && (absSelectList != null ? absSelectList.contains(reference.column()) : true);\r\n        }\r\n    }\r\n\r\n    public boolean contains(Region region) {\r\n        return region.contains(region);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/5_templateit/src/main/java/org/templateit/StaticTemplateTest4.java",
		"test_prompt": "// StaticTemplateTest4.java\npackage org.templateit;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.poi.hssf.usermodel.HSSFCell;\nimport org.apache.poi.hssf.usermodel.HSSFRow;\nimport org.apache.poi.hssf.usermodel.HSSFSheet;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StaticTemplate}.\n* It contains ten unit test cases for the {@link StaticTemplate#width()} method.\n*/\nclass StaticTemplateTest4 {"
	},
	{
		"original_code": "// StaticTemplate.java\n/*\r\n * Copyright(C) 2008-2009 Dmitriy Kumshayev. <dq@mail.com>\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\npackage org.templateit;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.LinkedList;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport org.apache.poi.hssf.usermodel.HSSFCell;\r\nimport org.apache.poi.hssf.usermodel.HSSFRow;\r\nimport org.apache.poi.hssf.usermodel.HSSFSheet;\r\n\r\n/**\r\n * Represents a rectangular template area in the template workbook.\r\n * Encapsulated accompanying data such as template parameters,\r\n * columns permutation information and the original template sheet object.\r\n *\r\n * @author Dmitriy Kumshayev\r\n */\r\nclass StaticTemplate extends Template {\r\n\r\n    private final List<MergeRegion> mergeRegions = new LinkedList<MergeRegion>();\r\n\r\n    List<Integer> selectList = null;\r\n\r\n    private List<Integer> absSelectList = null;\r\n\r\n    private final Region region = new Region();\r\n\r\n    private Map<Integer, Map<Integer, Integer>> parameterIndexMap = null;\r\n\r\n    public StaticTemplate(String name, HSSFSheet sheet) {\r\n        super(name, sheet);\r\n    }\r\n\r\n    public List<MergeRegion> getMergeRegions() {\r\n        return mergeRegions;\r\n    }\r\n\r\n    public void addMergeRegion(MergeRegion mreg) {\r\n        mergeRegions.add(mreg);\r\n    }\r\n\r\n    public void setSelectList(List<Integer> selectList) {\r\n        this.selectList = selectList;\r\n        // calculate parameterIndexMap\r\n        if (selectList != null) {\r\n            // Initialize absolute numbers of the selected columns\r\n            this.absSelectList = new ArrayList<Integer>(selectList.size());\r\n            for (int c = 0; c < width(); c++) {\r\n                absSelectList.add(absoluteColumn(c));\r\n            }\r\n            parameterIndexMap = new HashMap<Integer, Map<Integer, Integer>>();\r\n            int idx = 1;\r\n            int h = height();\r\n            int w = width();\r\n            for (int r = 0; r < h; r++) {\r\n                for (int c = 0; c < w; c++) {\r\n                    int col = selectList.get(c);\r\n                    Parameter p = getParameter(r, col);\r\n                    if (p != null) {\r\n                        Map<Integer, Integer> rowIndexMap = parameterIndexMap.get(r);\r\n                        if (rowIndexMap == null) {\r\n                            rowIndexMap = new HashMap<Integer, Integer>();\r\n                            parameterIndexMap.put(r, rowIndexMap);\r\n                        }\r\n                        rowIndexMap.put(c, idx++);\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            parameterIndexMap = null;\r\n            absSelectList = null;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public int getRowHeight(int row) {\r\n        HSSFRow trow = sheet.getRow(absoluteRow(row));\r\n        if (trow != null) {\r\n            return trow.getHeight();\r\n        }\r\n        return sheet.getDefaultRowHeight();\r\n    }\r\n\r\n    /**\r\n     * @param r - 0-based relative row number within the template\r\n     * @return\r\n     */\r\n    private int absoluteRow(int r) {\r\n        return start().row() + r;\r\n    }\r\n\r\n    @Override\r\n    public boolean isRowBroken(int r) {\r\n        return sheet.isRowBroken(absoluteRow(r));\r\n    }\r\n\r\n    /**\r\n     * @param r - 0-based relative column number within the template\r\n     * @return\r\n     */\r\n    public int absoluteColumn(int c) {\r\n        if (selectList != null) {\r\n            return start().column() + selectList.get(c);\r\n        } else {\r\n            return start().column() + c;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public int getParameterIndex(int r, int c) {\r\n        Integer idx = -1;\r\n        if (selectList == null) {\r\n            Parameter p = super.getParameter(r, c);\r\n            if (p != null) {\r\n                idx = p.getIndex();\r\n            }\r\n        } else {\r\n            idx = parameterIndexMap.get(r).get(c);\r\n            if (idx == null) {\r\n                idx = -1;\r\n            }\r\n        }\r\n        return idx;\r\n    }\r\n\r\n    public HSSFCell getCell(int r, int c) {\r\n        HSSFRow tRow = sheet.getRow(absoluteRow(r));\r\n        if (tRow != null) {\r\n            return tRow.getCell(absoluteColumn(c));\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private int absoluteFirstRow() {\r\n        return absoluteRow(0);\r\n    }\r\n\r\n    private int absoluteFirstColumn() {\r\n        return absoluteColumn(0);\r\n    }\r\n\r\n    private int absoluteLastRow() {\r\n        return absoluteRow(height() - 1);\r\n    }\r\n\r\n    private int absoluteLastColumn() {\r\n        return absoluteColumn(width() - 1);\r\n    }\r\n\r\n    @Override\r\n    public Reference absoluteReference(int r, int c) {\r\n        Reference ref = new Reference(absoluteRow(r), absoluteColumn(c));\r\n        return ref;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return name + \",\" + super.toString();\r\n    }\r\n\r\n    @Override\r\n    public int height() {\r\n        return end().row() - start().row() + 1;\r\n    }\r\n\r\n    @Override\r\n    public int width() {\r\n        if (selectList != null) {\r\n            return selectList.size();\r\n        } else {\r\n            return end().column() - start().column() + 1;\r\n        }\r\n    }\r\n\r\n    /* Wrapping methods to access region */\r\n    public void setStartReference(Reference start) {\r\n        region.setStartReference(start);\r\n    }\r\n\r\n    public Reference start() {\r\n        return region.start();\r\n    }\r\n\r\n    public void setEndReference(Reference end) {\r\n        region.setEndReference(end);\r\n    }\r\n\r\n    public Reference end() {\r\n        return region.end();\r\n    }\r\n\r\n    /**\r\n     * @return true if this Template contains the reference\r\n     */\r\n    public boolean contains(Reference reference) {\r\n        if (selectList == null) {\r\n            return region.contains(reference);\r\n        } else {\r\n            return absoluteFirstRow() <= reference.row() && reference.row() <= absoluteLastRow() && absoluteFirstColumn() <= reference.column() && reference.column() <= absoluteLastColumn() && (absSelectList != null ? absSelectList.contains(reference.column()) : true);\r\n        }\r\n    }\r\n\r\n    public boolean contains(Region region) {\r\n        return region.contains(region);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/5_templateit/src/main/java/org/templateit/StaticTemplateTest5.java",
		"test_prompt": "// StaticTemplateTest5.java\npackage org.templateit;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.poi.hssf.usermodel.HSSFCell;\nimport org.apache.poi.hssf.usermodel.HSSFRow;\nimport org.apache.poi.hssf.usermodel.HSSFSheet;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StaticTemplate}.\n* It contains ten unit test cases for the {@link StaticTemplate#start()} method.\n*/\nclass StaticTemplateTest5 {"
	},
	{
		"original_code": "// StaticTemplate.java\n/*\r\n * Copyright(C) 2008-2009 Dmitriy Kumshayev. <dq@mail.com>\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\npackage org.templateit;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.LinkedList;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport org.apache.poi.hssf.usermodel.HSSFCell;\r\nimport org.apache.poi.hssf.usermodel.HSSFRow;\r\nimport org.apache.poi.hssf.usermodel.HSSFSheet;\r\n\r\n/**\r\n * Represents a rectangular template area in the template workbook.\r\n * Encapsulated accompanying data such as template parameters,\r\n * columns permutation information and the original template sheet object.\r\n *\r\n * @author Dmitriy Kumshayev\r\n */\r\nclass StaticTemplate extends Template {\r\n\r\n    private final List<MergeRegion> mergeRegions = new LinkedList<MergeRegion>();\r\n\r\n    List<Integer> selectList = null;\r\n\r\n    private List<Integer> absSelectList = null;\r\n\r\n    private final Region region = new Region();\r\n\r\n    private Map<Integer, Map<Integer, Integer>> parameterIndexMap = null;\r\n\r\n    public StaticTemplate(String name, HSSFSheet sheet) {\r\n        super(name, sheet);\r\n    }\r\n\r\n    public List<MergeRegion> getMergeRegions() {\r\n        return mergeRegions;\r\n    }\r\n\r\n    public void addMergeRegion(MergeRegion mreg) {\r\n        mergeRegions.add(mreg);\r\n    }\r\n\r\n    public void setSelectList(List<Integer> selectList) {\r\n        this.selectList = selectList;\r\n        // calculate parameterIndexMap\r\n        if (selectList != null) {\r\n            // Initialize absolute numbers of the selected columns\r\n            this.absSelectList = new ArrayList<Integer>(selectList.size());\r\n            for (int c = 0; c < width(); c++) {\r\n                absSelectList.add(absoluteColumn(c));\r\n            }\r\n            parameterIndexMap = new HashMap<Integer, Map<Integer, Integer>>();\r\n            int idx = 1;\r\n            int h = height();\r\n            int w = width();\r\n            for (int r = 0; r < h; r++) {\r\n                for (int c = 0; c < w; c++) {\r\n                    int col = selectList.get(c);\r\n                    Parameter p = getParameter(r, col);\r\n                    if (p != null) {\r\n                        Map<Integer, Integer> rowIndexMap = parameterIndexMap.get(r);\r\n                        if (rowIndexMap == null) {\r\n                            rowIndexMap = new HashMap<Integer, Integer>();\r\n                            parameterIndexMap.put(r, rowIndexMap);\r\n                        }\r\n                        rowIndexMap.put(c, idx++);\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            parameterIndexMap = null;\r\n            absSelectList = null;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public int getRowHeight(int row) {\r\n        HSSFRow trow = sheet.getRow(absoluteRow(row));\r\n        if (trow != null) {\r\n            return trow.getHeight();\r\n        }\r\n        return sheet.getDefaultRowHeight();\r\n    }\r\n\r\n    /**\r\n     * @param r - 0-based relative row number within the template\r\n     * @return\r\n     */\r\n    private int absoluteRow(int r) {\r\n        return start().row() + r;\r\n    }\r\n\r\n    @Override\r\n    public boolean isRowBroken(int r) {\r\n        return sheet.isRowBroken(absoluteRow(r));\r\n    }\r\n\r\n    /**\r\n     * @param r - 0-based relative column number within the template\r\n     * @return\r\n     */\r\n    public int absoluteColumn(int c) {\r\n        if (selectList != null) {\r\n            return start().column() + selectList.get(c);\r\n        } else {\r\n            return start().column() + c;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public int getParameterIndex(int r, int c) {\r\n        Integer idx = -1;\r\n        if (selectList == null) {\r\n            Parameter p = super.getParameter(r, c);\r\n            if (p != null) {\r\n                idx = p.getIndex();\r\n            }\r\n        } else {\r\n            idx = parameterIndexMap.get(r).get(c);\r\n            if (idx == null) {\r\n                idx = -1;\r\n            }\r\n        }\r\n        return idx;\r\n    }\r\n\r\n    public HSSFCell getCell(int r, int c) {\r\n        HSSFRow tRow = sheet.getRow(absoluteRow(r));\r\n        if (tRow != null) {\r\n            return tRow.getCell(absoluteColumn(c));\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private int absoluteFirstRow() {\r\n        return absoluteRow(0);\r\n    }\r\n\r\n    private int absoluteFirstColumn() {\r\n        return absoluteColumn(0);\r\n    }\r\n\r\n    private int absoluteLastRow() {\r\n        return absoluteRow(height() - 1);\r\n    }\r\n\r\n    private int absoluteLastColumn() {\r\n        return absoluteColumn(width() - 1);\r\n    }\r\n\r\n    @Override\r\n    public Reference absoluteReference(int r, int c) {\r\n        Reference ref = new Reference(absoluteRow(r), absoluteColumn(c));\r\n        return ref;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return name + \",\" + super.toString();\r\n    }\r\n\r\n    @Override\r\n    public int height() {\r\n        return end().row() - start().row() + 1;\r\n    }\r\n\r\n    @Override\r\n    public int width() {\r\n        if (selectList != null) {\r\n            return selectList.size();\r\n        } else {\r\n            return end().column() - start().column() + 1;\r\n        }\r\n    }\r\n\r\n    /* Wrapping methods to access region */\r\n    public void setStartReference(Reference start) {\r\n        region.setStartReference(start);\r\n    }\r\n\r\n    public Reference start() {\r\n        return region.start();\r\n    }\r\n\r\n    public void setEndReference(Reference end) {\r\n        region.setEndReference(end);\r\n    }\r\n\r\n    public Reference end() {\r\n        return region.end();\r\n    }\r\n\r\n    /**\r\n     * @return true if this Template contains the reference\r\n     */\r\n    public boolean contains(Reference reference) {\r\n        if (selectList == null) {\r\n            return region.contains(reference);\r\n        } else {\r\n            return absoluteFirstRow() <= reference.row() && reference.row() <= absoluteLastRow() && absoluteFirstColumn() <= reference.column() && reference.column() <= absoluteLastColumn() && (absSelectList != null ? absSelectList.contains(reference.column()) : true);\r\n        }\r\n    }\r\n\r\n    public boolean contains(Region region) {\r\n        return region.contains(region);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/5_templateit/src/main/java/org/templateit/StaticTemplateTest6.java",
		"test_prompt": "// StaticTemplateTest6.java\npackage org.templateit;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.poi.hssf.usermodel.HSSFCell;\nimport org.apache.poi.hssf.usermodel.HSSFRow;\nimport org.apache.poi.hssf.usermodel.HSSFSheet;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StaticTemplate}.\n* It contains ten unit test cases for the {@link StaticTemplate#end()} method.\n*/\nclass StaticTemplateTest6 {"
	},
	{
		"original_code": "// StaticTemplate.java\n/*\r\n * Copyright(C) 2008-2009 Dmitriy Kumshayev. <dq@mail.com>\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\npackage org.templateit;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.LinkedList;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport org.apache.poi.hssf.usermodel.HSSFCell;\r\nimport org.apache.poi.hssf.usermodel.HSSFRow;\r\nimport org.apache.poi.hssf.usermodel.HSSFSheet;\r\n\r\n/**\r\n * Represents a rectangular template area in the template workbook.\r\n * Encapsulated accompanying data such as template parameters,\r\n * columns permutation information and the original template sheet object.\r\n *\r\n * @author Dmitriy Kumshayev\r\n */\r\nclass StaticTemplate extends Template {\r\n\r\n    private final List<MergeRegion> mergeRegions = new LinkedList<MergeRegion>();\r\n\r\n    List<Integer> selectList = null;\r\n\r\n    private List<Integer> absSelectList = null;\r\n\r\n    private final Region region = new Region();\r\n\r\n    private Map<Integer, Map<Integer, Integer>> parameterIndexMap = null;\r\n\r\n    public StaticTemplate(String name, HSSFSheet sheet) {\r\n        super(name, sheet);\r\n    }\r\n\r\n    public List<MergeRegion> getMergeRegions() {\r\n        return mergeRegions;\r\n    }\r\n\r\n    public void addMergeRegion(MergeRegion mreg) {\r\n        mergeRegions.add(mreg);\r\n    }\r\n\r\n    public void setSelectList(List<Integer> selectList) {\r\n        this.selectList = selectList;\r\n        // calculate parameterIndexMap\r\n        if (selectList != null) {\r\n            // Initialize absolute numbers of the selected columns\r\n            this.absSelectList = new ArrayList<Integer>(selectList.size());\r\n            for (int c = 0; c < width(); c++) {\r\n                absSelectList.add(absoluteColumn(c));\r\n            }\r\n            parameterIndexMap = new HashMap<Integer, Map<Integer, Integer>>();\r\n            int idx = 1;\r\n            int h = height();\r\n            int w = width();\r\n            for (int r = 0; r < h; r++) {\r\n                for (int c = 0; c < w; c++) {\r\n                    int col = selectList.get(c);\r\n                    Parameter p = getParameter(r, col);\r\n                    if (p != null) {\r\n                        Map<Integer, Integer> rowIndexMap = parameterIndexMap.get(r);\r\n                        if (rowIndexMap == null) {\r\n                            rowIndexMap = new HashMap<Integer, Integer>();\r\n                            parameterIndexMap.put(r, rowIndexMap);\r\n                        }\r\n                        rowIndexMap.put(c, idx++);\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            parameterIndexMap = null;\r\n            absSelectList = null;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public int getRowHeight(int row) {\r\n        HSSFRow trow = sheet.getRow(absoluteRow(row));\r\n        if (trow != null) {\r\n            return trow.getHeight();\r\n        }\r\n        return sheet.getDefaultRowHeight();\r\n    }\r\n\r\n    /**\r\n     * @param r - 0-based relative row number within the template\r\n     * @return\r\n     */\r\n    private int absoluteRow(int r) {\r\n        return start().row() + r;\r\n    }\r\n\r\n    @Override\r\n    public boolean isRowBroken(int r) {\r\n        return sheet.isRowBroken(absoluteRow(r));\r\n    }\r\n\r\n    /**\r\n     * @param r - 0-based relative column number within the template\r\n     * @return\r\n     */\r\n    public int absoluteColumn(int c) {\r\n        if (selectList != null) {\r\n            return start().column() + selectList.get(c);\r\n        } else {\r\n            return start().column() + c;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public int getParameterIndex(int r, int c) {\r\n        Integer idx = -1;\r\n        if (selectList == null) {\r\n            Parameter p = super.getParameter(r, c);\r\n            if (p != null) {\r\n                idx = p.getIndex();\r\n            }\r\n        } else {\r\n            idx = parameterIndexMap.get(r).get(c);\r\n            if (idx == null) {\r\n                idx = -1;\r\n            }\r\n        }\r\n        return idx;\r\n    }\r\n\r\n    public HSSFCell getCell(int r, int c) {\r\n        HSSFRow tRow = sheet.getRow(absoluteRow(r));\r\n        if (tRow != null) {\r\n            return tRow.getCell(absoluteColumn(c));\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private int absoluteFirstRow() {\r\n        return absoluteRow(0);\r\n    }\r\n\r\n    private int absoluteFirstColumn() {\r\n        return absoluteColumn(0);\r\n    }\r\n\r\n    private int absoluteLastRow() {\r\n        return absoluteRow(height() - 1);\r\n    }\r\n\r\n    private int absoluteLastColumn() {\r\n        return absoluteColumn(width() - 1);\r\n    }\r\n\r\n    @Override\r\n    public Reference absoluteReference(int r, int c) {\r\n        Reference ref = new Reference(absoluteRow(r), absoluteColumn(c));\r\n        return ref;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return name + \",\" + super.toString();\r\n    }\r\n\r\n    @Override\r\n    public int height() {\r\n        return end().row() - start().row() + 1;\r\n    }\r\n\r\n    @Override\r\n    public int width() {\r\n        if (selectList != null) {\r\n            return selectList.size();\r\n        } else {\r\n            return end().column() - start().column() + 1;\r\n        }\r\n    }\r\n\r\n    /* Wrapping methods to access region */\r\n    public void setStartReference(Reference start) {\r\n        region.setStartReference(start);\r\n    }\r\n\r\n    public Reference start() {\r\n        return region.start();\r\n    }\r\n\r\n    public void setEndReference(Reference end) {\r\n        region.setEndReference(end);\r\n    }\r\n\r\n    public Reference end() {\r\n        return region.end();\r\n    }\r\n\r\n    /**\r\n     * @return true if this Template contains the reference\r\n     */\r\n    public boolean contains(Reference reference) {\r\n        if (selectList == null) {\r\n            return region.contains(reference);\r\n        } else {\r\n            return absoluteFirstRow() <= reference.row() && reference.row() <= absoluteLastRow() && absoluteFirstColumn() <= reference.column() && reference.column() <= absoluteLastColumn() && (absSelectList != null ? absSelectList.contains(reference.column()) : true);\r\n        }\r\n    }\r\n\r\n    public boolean contains(Region region) {\r\n        return region.contains(region);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/5_templateit/src/main/java/org/templateit/StaticTemplateTest7.java",
		"test_prompt": "// StaticTemplateTest7.java\npackage org.templateit;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.poi.hssf.usermodel.HSSFCell;\nimport org.apache.poi.hssf.usermodel.HSSFRow;\nimport org.apache.poi.hssf.usermodel.HSSFSheet;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StaticTemplate}.\n* It contains ten unit test cases for the {@link StaticTemplate#contains(Reference)} method.\n*/\nclass StaticTemplateTest7 {"
	},
	{
		"original_code": "// StaticTemplate.java\n/*\r\n * Copyright(C) 2008-2009 Dmitriy Kumshayev. <dq@mail.com>\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\npackage org.templateit;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.LinkedList;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport org.apache.poi.hssf.usermodel.HSSFCell;\r\nimport org.apache.poi.hssf.usermodel.HSSFRow;\r\nimport org.apache.poi.hssf.usermodel.HSSFSheet;\r\n\r\n/**\r\n * Represents a rectangular template area in the template workbook.\r\n * Encapsulated accompanying data such as template parameters,\r\n * columns permutation information and the original template sheet object.\r\n *\r\n * @author Dmitriy Kumshayev\r\n */\r\nclass StaticTemplate extends Template {\r\n\r\n    private final List<MergeRegion> mergeRegions = new LinkedList<MergeRegion>();\r\n\r\n    List<Integer> selectList = null;\r\n\r\n    private List<Integer> absSelectList = null;\r\n\r\n    private final Region region = new Region();\r\n\r\n    private Map<Integer, Map<Integer, Integer>> parameterIndexMap = null;\r\n\r\n    public StaticTemplate(String name, HSSFSheet sheet) {\r\n        super(name, sheet);\r\n    }\r\n\r\n    public List<MergeRegion> getMergeRegions() {\r\n        return mergeRegions;\r\n    }\r\n\r\n    public void addMergeRegion(MergeRegion mreg) {\r\n        mergeRegions.add(mreg);\r\n    }\r\n\r\n    public void setSelectList(List<Integer> selectList) {\r\n        this.selectList = selectList;\r\n        // calculate parameterIndexMap\r\n        if (selectList != null) {\r\n            // Initialize absolute numbers of the selected columns\r\n            this.absSelectList = new ArrayList<Integer>(selectList.size());\r\n            for (int c = 0; c < width(); c++) {\r\n                absSelectList.add(absoluteColumn(c));\r\n            }\r\n            parameterIndexMap = new HashMap<Integer, Map<Integer, Integer>>();\r\n            int idx = 1;\r\n            int h = height();\r\n            int w = width();\r\n            for (int r = 0; r < h; r++) {\r\n                for (int c = 0; c < w; c++) {\r\n                    int col = selectList.get(c);\r\n                    Parameter p = getParameter(r, col);\r\n                    if (p != null) {\r\n                        Map<Integer, Integer> rowIndexMap = parameterIndexMap.get(r);\r\n                        if (rowIndexMap == null) {\r\n                            rowIndexMap = new HashMap<Integer, Integer>();\r\n                            parameterIndexMap.put(r, rowIndexMap);\r\n                        }\r\n                        rowIndexMap.put(c, idx++);\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            parameterIndexMap = null;\r\n            absSelectList = null;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public int getRowHeight(int row) {\r\n        HSSFRow trow = sheet.getRow(absoluteRow(row));\r\n        if (trow != null) {\r\n            return trow.getHeight();\r\n        }\r\n        return sheet.getDefaultRowHeight();\r\n    }\r\n\r\n    /**\r\n     * @param r - 0-based relative row number within the template\r\n     * @return\r\n     */\r\n    private int absoluteRow(int r) {\r\n        return start().row() + r;\r\n    }\r\n\r\n    @Override\r\n    public boolean isRowBroken(int r) {\r\n        return sheet.isRowBroken(absoluteRow(r));\r\n    }\r\n\r\n    /**\r\n     * @param r - 0-based relative column number within the template\r\n     * @return\r\n     */\r\n    public int absoluteColumn(int c) {\r\n        if (selectList != null) {\r\n            return start().column() + selectList.get(c);\r\n        } else {\r\n            return start().column() + c;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public int getParameterIndex(int r, int c) {\r\n        Integer idx = -1;\r\n        if (selectList == null) {\r\n            Parameter p = super.getParameter(r, c);\r\n            if (p != null) {\r\n                idx = p.getIndex();\r\n            }\r\n        } else {\r\n            idx = parameterIndexMap.get(r).get(c);\r\n            if (idx == null) {\r\n                idx = -1;\r\n            }\r\n        }\r\n        return idx;\r\n    }\r\n\r\n    public HSSFCell getCell(int r, int c) {\r\n        HSSFRow tRow = sheet.getRow(absoluteRow(r));\r\n        if (tRow != null) {\r\n            return tRow.getCell(absoluteColumn(c));\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private int absoluteFirstRow() {\r\n        return absoluteRow(0);\r\n    }\r\n\r\n    private int absoluteFirstColumn() {\r\n        return absoluteColumn(0);\r\n    }\r\n\r\n    private int absoluteLastRow() {\r\n        return absoluteRow(height() - 1);\r\n    }\r\n\r\n    private int absoluteLastColumn() {\r\n        return absoluteColumn(width() - 1);\r\n    }\r\n\r\n    @Override\r\n    public Reference absoluteReference(int r, int c) {\r\n        Reference ref = new Reference(absoluteRow(r), absoluteColumn(c));\r\n        return ref;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return name + \",\" + super.toString();\r\n    }\r\n\r\n    @Override\r\n    public int height() {\r\n        return end().row() - start().row() + 1;\r\n    }\r\n\r\n    @Override\r\n    public int width() {\r\n        if (selectList != null) {\r\n            return selectList.size();\r\n        } else {\r\n            return end().column() - start().column() + 1;\r\n        }\r\n    }\r\n\r\n    /* Wrapping methods to access region */\r\n    public void setStartReference(Reference start) {\r\n        region.setStartReference(start);\r\n    }\r\n\r\n    public Reference start() {\r\n        return region.start();\r\n    }\r\n\r\n    public void setEndReference(Reference end) {\r\n        region.setEndReference(end);\r\n    }\r\n\r\n    public Reference end() {\r\n        return region.end();\r\n    }\r\n\r\n    /**\r\n     * @return true if this Template contains the reference\r\n     */\r\n    public boolean contains(Reference reference) {\r\n        if (selectList == null) {\r\n            return region.contains(reference);\r\n        } else {\r\n            return absoluteFirstRow() <= reference.row() && reference.row() <= absoluteLastRow() && absoluteFirstColumn() <= reference.column() && reference.column() <= absoluteLastColumn() && (absSelectList != null ? absSelectList.contains(reference.column()) : true);\r\n        }\r\n    }\r\n\r\n    public boolean contains(Region region) {\r\n        return region.contains(region);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/5_templateit/src/main/java/org/templateit/StaticTemplateTest8.java",
		"test_prompt": "// StaticTemplateTest8.java\npackage org.templateit;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.poi.hssf.usermodel.HSSFCell;\nimport org.apache.poi.hssf.usermodel.HSSFRow;\nimport org.apache.poi.hssf.usermodel.HSSFSheet;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StaticTemplate}.\n* It contains ten unit test cases for the {@link StaticTemplate#contains(Region)} method.\n*/\nclass StaticTemplateTest8 {"
	},
	{
		"original_code": "// Reference.java\n/*\r\n * Copyright(C) 2008-2009 Dmitriy Kumshayev. <dq@mail.com>\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\npackage org.templateit;\r\n\r\n/**\r\n * Immutable object representing a cell address (row,column).\r\n * {@link Object#equals(Object)} and {@link Object#hashCode()} methods\r\n * are overridden so that two <code>Reference</code> are equal\r\n * if and only if they refer the same row and column.\r\n *\r\n * @author Dmitriy Kumshayev\r\n */\r\nclass Reference {\r\n\r\n    public final static int INFINITY = -1;\r\n\r\n    private final int row;\r\n\r\n    private final int column;\r\n\r\n    public Reference(int row, int column) {\r\n        this.row = row;\r\n        this.column = column;\r\n    }\r\n\r\n    public int row() {\r\n        return row;\r\n    }\r\n\r\n    public int column() {\r\n        return column;\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        final int prime = 31;\r\n        int result = 1;\r\n        result = prime * result + column;\r\n        result = prime * result + row;\r\n        return result;\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(Object obj) {\r\n        if (this == obj)\r\n            return true;\r\n        if (obj == null)\r\n            return false;\r\n        if (getClass() != obj.getClass())\r\n            return false;\r\n        Reference other = (Reference) obj;\r\n        if (column != other.column)\r\n            return false;\r\n        if (row != other.row)\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return row + \",\" + column;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/5_templateit/src/main/java/org/templateit/ReferenceTest0.java",
		"test_prompt": "// ReferenceTest0.java\npackage org.templateit;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Reference}.\n* It contains ten unit test cases for the {@link Reference#row()} method.\n*/\nclass ReferenceTest0 {"
	},
	{
		"original_code": "// Reference.java\n/*\r\n * Copyright(C) 2008-2009 Dmitriy Kumshayev. <dq@mail.com>\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\npackage org.templateit;\r\n\r\n/**\r\n * Immutable object representing a cell address (row,column).\r\n * {@link Object#equals(Object)} and {@link Object#hashCode()} methods\r\n * are overridden so that two <code>Reference</code> are equal\r\n * if and only if they refer the same row and column.\r\n *\r\n * @author Dmitriy Kumshayev\r\n */\r\nclass Reference {\r\n\r\n    public final static int INFINITY = -1;\r\n\r\n    private final int row;\r\n\r\n    private final int column;\r\n\r\n    public Reference(int row, int column) {\r\n        this.row = row;\r\n        this.column = column;\r\n    }\r\n\r\n    public int row() {\r\n        return row;\r\n    }\r\n\r\n    public int column() {\r\n        return column;\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        final int prime = 31;\r\n        int result = 1;\r\n        result = prime * result + column;\r\n        result = prime * result + row;\r\n        return result;\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(Object obj) {\r\n        if (this == obj)\r\n            return true;\r\n        if (obj == null)\r\n            return false;\r\n        if (getClass() != obj.getClass())\r\n            return false;\r\n        Reference other = (Reference) obj;\r\n        if (column != other.column)\r\n            return false;\r\n        if (row != other.row)\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return row + \",\" + column;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/5_templateit/src/main/java/org/templateit/ReferenceTest1.java",
		"test_prompt": "// ReferenceTest1.java\npackage org.templateit;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Reference}.\n* It contains ten unit test cases for the {@link Reference#column()} method.\n*/\nclass ReferenceTest1 {"
	},
	{
		"original_code": "// Reference.java\n/*\r\n * Copyright(C) 2008-2009 Dmitriy Kumshayev. <dq@mail.com>\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\npackage org.templateit;\r\n\r\n/**\r\n * Immutable object representing a cell address (row,column).\r\n * {@link Object#equals(Object)} and {@link Object#hashCode()} methods\r\n * are overridden so that two <code>Reference</code> are equal\r\n * if and only if they refer the same row and column.\r\n *\r\n * @author Dmitriy Kumshayev\r\n */\r\nclass Reference {\r\n\r\n    public final static int INFINITY = -1;\r\n\r\n    private final int row;\r\n\r\n    private final int column;\r\n\r\n    public Reference(int row, int column) {\r\n        this.row = row;\r\n        this.column = column;\r\n    }\r\n\r\n    public int row() {\r\n        return row;\r\n    }\r\n\r\n    public int column() {\r\n        return column;\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        final int prime = 31;\r\n        int result = 1;\r\n        result = prime * result + column;\r\n        result = prime * result + row;\r\n        return result;\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(Object obj) {\r\n        if (this == obj)\r\n            return true;\r\n        if (obj == null)\r\n            return false;\r\n        if (getClass() != obj.getClass())\r\n            return false;\r\n        Reference other = (Reference) obj;\r\n        if (column != other.column)\r\n            return false;\r\n        if (row != other.row)\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return row + \",\" + column;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/5_templateit/src/main/java/org/templateit/ReferenceTest2.java",
		"test_prompt": "// ReferenceTest2.java\npackage org.templateit;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Reference}.\n* It contains ten unit test cases for the {@link Reference#hashCode()} method.\n*/\nclass ReferenceTest2 {"
	},
	{
		"original_code": "// Reference.java\n/*\r\n * Copyright(C) 2008-2009 Dmitriy Kumshayev. <dq@mail.com>\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\npackage org.templateit;\r\n\r\n/**\r\n * Immutable object representing a cell address (row,column).\r\n * {@link Object#equals(Object)} and {@link Object#hashCode()} methods\r\n * are overridden so that two <code>Reference</code> are equal\r\n * if and only if they refer the same row and column.\r\n *\r\n * @author Dmitriy Kumshayev\r\n */\r\nclass Reference {\r\n\r\n    public final static int INFINITY = -1;\r\n\r\n    private final int row;\r\n\r\n    private final int column;\r\n\r\n    public Reference(int row, int column) {\r\n        this.row = row;\r\n        this.column = column;\r\n    }\r\n\r\n    public int row() {\r\n        return row;\r\n    }\r\n\r\n    public int column() {\r\n        return column;\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        final int prime = 31;\r\n        int result = 1;\r\n        result = prime * result + column;\r\n        result = prime * result + row;\r\n        return result;\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(Object obj) {\r\n        if (this == obj)\r\n            return true;\r\n        if (obj == null)\r\n            return false;\r\n        if (getClass() != obj.getClass())\r\n            return false;\r\n        Reference other = (Reference) obj;\r\n        if (column != other.column)\r\n            return false;\r\n        if (row != other.row)\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return row + \",\" + column;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/5_templateit/src/main/java/org/templateit/ReferenceTest3.java",
		"test_prompt": "// ReferenceTest3.java\npackage org.templateit;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Reference}.\n* It contains ten unit test cases for the {@link Reference#equals(Object)} method.\n*/\nclass ReferenceTest3 {"
	},
	{
		"original_code": "// Poi2ItextUtil.java\npackage org.templateit;\r\n\r\nimport java.awt.Color;\r\nimport java.awt.font.FontRenderContext;\r\nimport java.awt.font.TextAttribute;\r\nimport java.awt.font.TextLayout;\r\nimport java.text.AttributedString;\r\nimport org.apache.log4j.Logger;\r\nimport org.apache.poi.hssf.usermodel.HSSFCell;\r\nimport org.apache.poi.hssf.usermodel.HSSFCellStyle;\r\nimport org.apache.poi.hssf.usermodel.HSSFFont;\r\nimport org.apache.poi.hssf.usermodel.HSSFFormulaEvaluator;\r\nimport org.apache.poi.hssf.usermodel.HSSFPalette;\r\nimport org.apache.poi.hssf.usermodel.HSSFWorkbook;\r\nimport org.apache.poi.hssf.util.HSSFColor;\r\nimport com.lowagie.text.Element;\r\nimport com.lowagie.text.Font;\r\nimport com.lowagie.text.Rectangle;\r\nimport com.lowagie.text.pdf.PdfPCell;\r\n\r\npublic class Poi2ItextUtil {\r\n\r\n    private static final Logger logger = Logger.getLogger(Poi2ItextUtil.class);\r\n\r\n    private final HSSFWorkbook workbook;\r\n\r\n    public Poi2ItextUtil(HSSFWorkbook workbook) {\r\n        this.workbook = workbook;\r\n    }\r\n\r\n    public static Color colorPOI2Itext(HSSFColor poiColor) {\r\n        short[] poiRGB = poiColor.getTriplet();\r\n        return new Color(poiRGB[0], poiRGB[1], poiRGB[2]);\r\n    }\r\n\r\n    public void copyBackgroundColor(HSSFCell xcell, PdfPCell cell) {\r\n        HSSFCellStyle xstyle = xcell.getCellStyle();\r\n        short cx = xstyle.getFillForegroundColor();\r\n        HSSFPalette palette = workbook.getCustomPalette();\r\n        HSSFColor poiColor = palette.getColor(cx);\r\n        if (poiColor != null && poiColor.getIndex() != HSSFColor.AUTOMATIC.index) {\r\n            Color color = colorPOI2Itext(poiColor);\r\n            cell.setBackgroundColor(color);\r\n        }\r\n    }\r\n\r\n    public void copyCellHorisontalAlignment(HSSFCell xcell, PdfPCell cell) {\r\n        HSSFCellStyle xstyle = xcell.getCellStyle();\r\n        int type = xcell.getCellType();\r\n        short alignment = xstyle.getAlignment();\r\n        switch(alignment) {\r\n            case HSSFCellStyle.ALIGN_GENERAL:\r\n                switch(type) {\r\n                    case HSSFCell.CELL_TYPE_NUMERIC:\r\n                        cell.setHorizontalAlignment(Element.ALIGN_RIGHT);\r\n                        break;\r\n                    case HSSFCell.CELL_TYPE_BLANK:\r\n                    case HSSFCell.CELL_TYPE_BOOLEAN:\r\n                    case HSSFCell.CELL_TYPE_ERROR:\r\n                    case HSSFCell.CELL_TYPE_STRING:\r\n                        cell.setHorizontalAlignment(Element.ALIGN_UNDEFINED);\r\n                        break;\r\n                    case HSSFCell.CELL_TYPE_FORMULA:\r\n                        HSSFFormulaEvaluator eval = new HSSFFormulaEvaluator(workbook);\r\n                        int valType = eval.evaluateFormulaCell(xcell);\r\n                        switch(valType) {\r\n                            case HSSFCell.CELL_TYPE_NUMERIC:\r\n                                cell.setHorizontalAlignment(Element.ALIGN_RIGHT);\r\n                                break;\r\n                            default:\r\n                                cell.setHorizontalAlignment(Element.ALIGN_UNDEFINED);\r\n                        }\r\n                        break;\r\n                }\r\n                break;\r\n            case HSSFCellStyle.ALIGN_LEFT:\r\n                cell.setHorizontalAlignment(Element.ALIGN_LEFT);\r\n                break;\r\n            case HSSFCellStyle.ALIGN_CENTER:\r\n                cell.setHorizontalAlignment(Element.ALIGN_CENTER);\r\n                break;\r\n            case HSSFCellStyle.ALIGN_RIGHT:\r\n                cell.setHorizontalAlignment(Element.ALIGN_RIGHT);\r\n                break;\r\n            case HSSFCellStyle.ALIGN_FILL:\r\n                cell.setHorizontalAlignment(Element.ALIGN_CENTER);\r\n                break;\r\n            case HSSFCellStyle.ALIGN_JUSTIFY:\r\n                cell.setHorizontalAlignment(Element.ALIGN_JUSTIFIED);\r\n                break;\r\n            case HSSFCellStyle.ALIGN_CENTER_SELECTION:\r\n                cell.setHorizontalAlignment(Element.ALIGN_CENTER);\r\n                break;\r\n        }\r\n    }\r\n\r\n    public void copyCellBorders(HSSFCell xcell, PdfPCell cell) {\r\n        HSSFCellStyle xstyle = xcell.getCellStyle();\r\n        int top = xstyle.getBorderTop() != HSSFCellStyle.BORDER_NONE ? Rectangle.TOP : Rectangle.NO_BORDER;\r\n        int bottom = xstyle.getBorderBottom() != HSSFCellStyle.BORDER_NONE ? Rectangle.BOTTOM : Rectangle.NO_BORDER;\r\n        int left = xstyle.getBorderLeft() != HSSFCellStyle.BORDER_NONE ? Rectangle.LEFT : Rectangle.NO_BORDER;\r\n        int right = xstyle.getBorderRight() != HSSFCellStyle.BORDER_NONE ? Rectangle.RIGHT : Rectangle.NO_BORDER;\r\n        cell.setBorder(top | bottom | left | right);\r\n    }\r\n\r\n    public void resetRightBorder(HSSFCell xcell, PdfPCell cell) {\r\n        HSSFCellStyle xstyle = xcell.getCellStyle();\r\n        int right = xstyle.getBorderRight() != HSSFCellStyle.BORDER_NONE ? Rectangle.RIGHT : Rectangle.NO_BORDER;\r\n        cell.setBorder(cell.getBorder() | right);\r\n    }\r\n\r\n    public Font chooseFont(HSSFFont xfont) {\r\n        int fontFamily = chooseFontFamily(xfont, Font.HELVETICA);\r\n        Font font = new Font(fontFamily);\r\n        font.setSize(xfont.getFontHeightInPoints());\r\n        int style = xfont.getBoldweight() == HSSFFont.BOLDWEIGHT_BOLD ? Font.BOLD : Font.NORMAL;\r\n        style |= xfont.getItalic() ? Font.ITALIC : Font.NORMAL;\r\n        style |= xfont.getStrikeout() ? Font.STRIKETHRU : Font.NORMAL;\r\n        style |= xfont.getUnderline() == HSSFFont.U_NONE ? Font.NORMAL : Font.UNDERLINE;\r\n        font.setStyle(style);\r\n        HSSFPalette palette = workbook.getCustomPalette();\r\n        HSSFColor poiColor = palette.getColor(xfont.getColor());\r\n        if (poiColor != null && poiColor.getIndex() != HSSFColor.AUTOMATIC.index) {\r\n            font.setColor(colorPOI2Itext(poiColor));\r\n        }\r\n        return font;\r\n    }\r\n\r\n    public int chooseFontFamily(HSSFFont font, int defaultFontFamily) {\r\n        String fontName = font.getFontName();\r\n        int fontFamily = defaultFontFamily;\r\n        if (\"Arial\".equals(fontName)) {\r\n            fontFamily = Font.HELVETICA;\r\n        } else if (\"Courier\".equals(fontName)) {\r\n            fontFamily = Font.COURIER;\r\n        } else if (\"Courier New\".equals(fontName)) {\r\n            fontFamily = Font.COURIER;\r\n        } else if (\"Times New Roman\".equals(fontName)) {\r\n            fontFamily = Font.TIMES_ROMAN;\r\n        }\r\n        return fontFamily;\r\n    }\r\n\r\n    public Font chooseFont(short fontIdx) {\r\n        return chooseFont(workbook.getFontAt(fontIdx));\r\n    }\r\n\r\n    public int getDefaultCharWidth() {\r\n        char defaultChar = '0';\r\n        HSSFFont defaultFont = workbook.getFontAt((short) 0);\r\n        AttributedString str = new AttributedString(\"\" + defaultChar);\r\n        copyAttributes(defaultFont, str, 0, 1);\r\n        FontRenderContext frc = new FontRenderContext(null, true, true);\r\n        TextLayout layout = new TextLayout(str.getIterator(), frc);\r\n        int defaultCharWidth = (int) layout.getAdvance();\r\n        return defaultCharWidth;\r\n    }\r\n\r\n    private void copyAttributes(HSSFFont font, AttributedString str, int startIdx, int endIdx) {\r\n        str.addAttribute(TextAttribute.FAMILY, font.getFontName(), startIdx, endIdx);\r\n        str.addAttribute(TextAttribute.SIZE, new Float(font.getFontHeightInPoints()));\r\n        if (font.getBoldweight() == HSSFFont.BOLDWEIGHT_BOLD)\r\n            str.addAttribute(TextAttribute.WEIGHT, TextAttribute.WEIGHT_BOLD, startIdx, endIdx);\r\n        if (font.getItalic())\r\n            str.addAttribute(TextAttribute.POSTURE, TextAttribute.POSTURE_OBLIQUE, startIdx, endIdx);\r\n        if (font.getUnderline() == HSSFFont.U_SINGLE)\r\n            str.addAttribute(TextAttribute.UNDERLINE, TextAttribute.UNDERLINE_ON, startIdx, endIdx);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/5_templateit/src/main/java/org/templateit/Poi2ItextUtilTest0.java",
		"test_prompt": "// Poi2ItextUtilTest0.java\npackage org.templateit;\n\nimport java.awt.Color;\nimport java.awt.font.FontRenderContext;\nimport java.awt.font.TextAttribute;\nimport java.awt.font.TextLayout;\nimport java.text.AttributedString;\nimport org.apache.log4j.Logger;\nimport org.apache.poi.hssf.usermodel.HSSFCell;\nimport org.apache.poi.hssf.usermodel.HSSFCellStyle;\nimport org.apache.poi.hssf.usermodel.HSSFFont;\nimport org.apache.poi.hssf.usermodel.HSSFFormulaEvaluator;\nimport org.apache.poi.hssf.usermodel.HSSFPalette;\nimport org.apache.poi.hssf.usermodel.HSSFWorkbook;\nimport org.apache.poi.hssf.util.HSSFColor;\nimport com.lowagie.text.Element;\nimport com.lowagie.text.Font;\nimport com.lowagie.text.Rectangle;\nimport com.lowagie.text.pdf.PdfPCell;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Poi2ItextUtil}.\n* It contains ten unit test cases for the {@link Poi2ItextUtil#colorPOI2Itext(HSSFColor)} method.\n*/\nclass Poi2ItextUtilTest0 {"
	},
	{
		"original_code": "// Poi2ItextUtil.java\npackage org.templateit;\r\n\r\nimport java.awt.Color;\r\nimport java.awt.font.FontRenderContext;\r\nimport java.awt.font.TextAttribute;\r\nimport java.awt.font.TextLayout;\r\nimport java.text.AttributedString;\r\nimport org.apache.log4j.Logger;\r\nimport org.apache.poi.hssf.usermodel.HSSFCell;\r\nimport org.apache.poi.hssf.usermodel.HSSFCellStyle;\r\nimport org.apache.poi.hssf.usermodel.HSSFFont;\r\nimport org.apache.poi.hssf.usermodel.HSSFFormulaEvaluator;\r\nimport org.apache.poi.hssf.usermodel.HSSFPalette;\r\nimport org.apache.poi.hssf.usermodel.HSSFWorkbook;\r\nimport org.apache.poi.hssf.util.HSSFColor;\r\nimport com.lowagie.text.Element;\r\nimport com.lowagie.text.Font;\r\nimport com.lowagie.text.Rectangle;\r\nimport com.lowagie.text.pdf.PdfPCell;\r\n\r\npublic class Poi2ItextUtil {\r\n\r\n    private static final Logger logger = Logger.getLogger(Poi2ItextUtil.class);\r\n\r\n    private final HSSFWorkbook workbook;\r\n\r\n    public Poi2ItextUtil(HSSFWorkbook workbook) {\r\n        this.workbook = workbook;\r\n    }\r\n\r\n    public static Color colorPOI2Itext(HSSFColor poiColor) {\r\n        short[] poiRGB = poiColor.getTriplet();\r\n        return new Color(poiRGB[0], poiRGB[1], poiRGB[2]);\r\n    }\r\n\r\n    public void copyBackgroundColor(HSSFCell xcell, PdfPCell cell) {\r\n        HSSFCellStyle xstyle = xcell.getCellStyle();\r\n        short cx = xstyle.getFillForegroundColor();\r\n        HSSFPalette palette = workbook.getCustomPalette();\r\n        HSSFColor poiColor = palette.getColor(cx);\r\n        if (poiColor != null && poiColor.getIndex() != HSSFColor.AUTOMATIC.index) {\r\n            Color color = colorPOI2Itext(poiColor);\r\n            cell.setBackgroundColor(color);\r\n        }\r\n    }\r\n\r\n    public void copyCellHorisontalAlignment(HSSFCell xcell, PdfPCell cell) {\r\n        HSSFCellStyle xstyle = xcell.getCellStyle();\r\n        int type = xcell.getCellType();\r\n        short alignment = xstyle.getAlignment();\r\n        switch(alignment) {\r\n            case HSSFCellStyle.ALIGN_GENERAL:\r\n                switch(type) {\r\n                    case HSSFCell.CELL_TYPE_NUMERIC:\r\n                        cell.setHorizontalAlignment(Element.ALIGN_RIGHT);\r\n                        break;\r\n                    case HSSFCell.CELL_TYPE_BLANK:\r\n                    case HSSFCell.CELL_TYPE_BOOLEAN:\r\n                    case HSSFCell.CELL_TYPE_ERROR:\r\n                    case HSSFCell.CELL_TYPE_STRING:\r\n                        cell.setHorizontalAlignment(Element.ALIGN_UNDEFINED);\r\n                        break;\r\n                    case HSSFCell.CELL_TYPE_FORMULA:\r\n                        HSSFFormulaEvaluator eval = new HSSFFormulaEvaluator(workbook);\r\n                        int valType = eval.evaluateFormulaCell(xcell);\r\n                        switch(valType) {\r\n                            case HSSFCell.CELL_TYPE_NUMERIC:\r\n                                cell.setHorizontalAlignment(Element.ALIGN_RIGHT);\r\n                                break;\r\n                            default:\r\n                                cell.setHorizontalAlignment(Element.ALIGN_UNDEFINED);\r\n                        }\r\n                        break;\r\n                }\r\n                break;\r\n            case HSSFCellStyle.ALIGN_LEFT:\r\n                cell.setHorizontalAlignment(Element.ALIGN_LEFT);\r\n                break;\r\n            case HSSFCellStyle.ALIGN_CENTER:\r\n                cell.setHorizontalAlignment(Element.ALIGN_CENTER);\r\n                break;\r\n            case HSSFCellStyle.ALIGN_RIGHT:\r\n                cell.setHorizontalAlignment(Element.ALIGN_RIGHT);\r\n                break;\r\n            case HSSFCellStyle.ALIGN_FILL:\r\n                cell.setHorizontalAlignment(Element.ALIGN_CENTER);\r\n                break;\r\n            case HSSFCellStyle.ALIGN_JUSTIFY:\r\n                cell.setHorizontalAlignment(Element.ALIGN_JUSTIFIED);\r\n                break;\r\n            case HSSFCellStyle.ALIGN_CENTER_SELECTION:\r\n                cell.setHorizontalAlignment(Element.ALIGN_CENTER);\r\n                break;\r\n        }\r\n    }\r\n\r\n    public void copyCellBorders(HSSFCell xcell, PdfPCell cell) {\r\n        HSSFCellStyle xstyle = xcell.getCellStyle();\r\n        int top = xstyle.getBorderTop() != HSSFCellStyle.BORDER_NONE ? Rectangle.TOP : Rectangle.NO_BORDER;\r\n        int bottom = xstyle.getBorderBottom() != HSSFCellStyle.BORDER_NONE ? Rectangle.BOTTOM : Rectangle.NO_BORDER;\r\n        int left = xstyle.getBorderLeft() != HSSFCellStyle.BORDER_NONE ? Rectangle.LEFT : Rectangle.NO_BORDER;\r\n        int right = xstyle.getBorderRight() != HSSFCellStyle.BORDER_NONE ? Rectangle.RIGHT : Rectangle.NO_BORDER;\r\n        cell.setBorder(top | bottom | left | right);\r\n    }\r\n\r\n    public void resetRightBorder(HSSFCell xcell, PdfPCell cell) {\r\n        HSSFCellStyle xstyle = xcell.getCellStyle();\r\n        int right = xstyle.getBorderRight() != HSSFCellStyle.BORDER_NONE ? Rectangle.RIGHT : Rectangle.NO_BORDER;\r\n        cell.setBorder(cell.getBorder() | right);\r\n    }\r\n\r\n    public Font chooseFont(HSSFFont xfont) {\r\n        int fontFamily = chooseFontFamily(xfont, Font.HELVETICA);\r\n        Font font = new Font(fontFamily);\r\n        font.setSize(xfont.getFontHeightInPoints());\r\n        int style = xfont.getBoldweight() == HSSFFont.BOLDWEIGHT_BOLD ? Font.BOLD : Font.NORMAL;\r\n        style |= xfont.getItalic() ? Font.ITALIC : Font.NORMAL;\r\n        style |= xfont.getStrikeout() ? Font.STRIKETHRU : Font.NORMAL;\r\n        style |= xfont.getUnderline() == HSSFFont.U_NONE ? Font.NORMAL : Font.UNDERLINE;\r\n        font.setStyle(style);\r\n        HSSFPalette palette = workbook.getCustomPalette();\r\n        HSSFColor poiColor = palette.getColor(xfont.getColor());\r\n        if (poiColor != null && poiColor.getIndex() != HSSFColor.AUTOMATIC.index) {\r\n            font.setColor(colorPOI2Itext(poiColor));\r\n        }\r\n        return font;\r\n    }\r\n\r\n    public int chooseFontFamily(HSSFFont font, int defaultFontFamily) {\r\n        String fontName = font.getFontName();\r\n        int fontFamily = defaultFontFamily;\r\n        if (\"Arial\".equals(fontName)) {\r\n            fontFamily = Font.HELVETICA;\r\n        } else if (\"Courier\".equals(fontName)) {\r\n            fontFamily = Font.COURIER;\r\n        } else if (\"Courier New\".equals(fontName)) {\r\n            fontFamily = Font.COURIER;\r\n        } else if (\"Times New Roman\".equals(fontName)) {\r\n            fontFamily = Font.TIMES_ROMAN;\r\n        }\r\n        return fontFamily;\r\n    }\r\n\r\n    public Font chooseFont(short fontIdx) {\r\n        return chooseFont(workbook.getFontAt(fontIdx));\r\n    }\r\n\r\n    public int getDefaultCharWidth() {\r\n        char defaultChar = '0';\r\n        HSSFFont defaultFont = workbook.getFontAt((short) 0);\r\n        AttributedString str = new AttributedString(\"\" + defaultChar);\r\n        copyAttributes(defaultFont, str, 0, 1);\r\n        FontRenderContext frc = new FontRenderContext(null, true, true);\r\n        TextLayout layout = new TextLayout(str.getIterator(), frc);\r\n        int defaultCharWidth = (int) layout.getAdvance();\r\n        return defaultCharWidth;\r\n    }\r\n\r\n    private void copyAttributes(HSSFFont font, AttributedString str, int startIdx, int endIdx) {\r\n        str.addAttribute(TextAttribute.FAMILY, font.getFontName(), startIdx, endIdx);\r\n        str.addAttribute(TextAttribute.SIZE, new Float(font.getFontHeightInPoints()));\r\n        if (font.getBoldweight() == HSSFFont.BOLDWEIGHT_BOLD)\r\n            str.addAttribute(TextAttribute.WEIGHT, TextAttribute.WEIGHT_BOLD, startIdx, endIdx);\r\n        if (font.getItalic())\r\n            str.addAttribute(TextAttribute.POSTURE, TextAttribute.POSTURE_OBLIQUE, startIdx, endIdx);\r\n        if (font.getUnderline() == HSSFFont.U_SINGLE)\r\n            str.addAttribute(TextAttribute.UNDERLINE, TextAttribute.UNDERLINE_ON, startIdx, endIdx);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/5_templateit/src/main/java/org/templateit/Poi2ItextUtilTest1.java",
		"test_prompt": "// Poi2ItextUtilTest1.java\npackage org.templateit;\n\nimport java.awt.Color;\nimport java.awt.font.FontRenderContext;\nimport java.awt.font.TextAttribute;\nimport java.awt.font.TextLayout;\nimport java.text.AttributedString;\nimport org.apache.log4j.Logger;\nimport org.apache.poi.hssf.usermodel.HSSFCell;\nimport org.apache.poi.hssf.usermodel.HSSFCellStyle;\nimport org.apache.poi.hssf.usermodel.HSSFFont;\nimport org.apache.poi.hssf.usermodel.HSSFFormulaEvaluator;\nimport org.apache.poi.hssf.usermodel.HSSFPalette;\nimport org.apache.poi.hssf.usermodel.HSSFWorkbook;\nimport org.apache.poi.hssf.util.HSSFColor;\nimport com.lowagie.text.Element;\nimport com.lowagie.text.Font;\nimport com.lowagie.text.Rectangle;\nimport com.lowagie.text.pdf.PdfPCell;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Poi2ItextUtil}.\n* It contains ten unit test cases for the {@link Poi2ItextUtil#chooseFont(HSSFFont)} method.\n*/\nclass Poi2ItextUtilTest1 {"
	},
	{
		"original_code": "// Poi2ItextUtil.java\npackage org.templateit;\r\n\r\nimport java.awt.Color;\r\nimport java.awt.font.FontRenderContext;\r\nimport java.awt.font.TextAttribute;\r\nimport java.awt.font.TextLayout;\r\nimport java.text.AttributedString;\r\nimport org.apache.log4j.Logger;\r\nimport org.apache.poi.hssf.usermodel.HSSFCell;\r\nimport org.apache.poi.hssf.usermodel.HSSFCellStyle;\r\nimport org.apache.poi.hssf.usermodel.HSSFFont;\r\nimport org.apache.poi.hssf.usermodel.HSSFFormulaEvaluator;\r\nimport org.apache.poi.hssf.usermodel.HSSFPalette;\r\nimport org.apache.poi.hssf.usermodel.HSSFWorkbook;\r\nimport org.apache.poi.hssf.util.HSSFColor;\r\nimport com.lowagie.text.Element;\r\nimport com.lowagie.text.Font;\r\nimport com.lowagie.text.Rectangle;\r\nimport com.lowagie.text.pdf.PdfPCell;\r\n\r\npublic class Poi2ItextUtil {\r\n\r\n    private static final Logger logger = Logger.getLogger(Poi2ItextUtil.class);\r\n\r\n    private final HSSFWorkbook workbook;\r\n\r\n    public Poi2ItextUtil(HSSFWorkbook workbook) {\r\n        this.workbook = workbook;\r\n    }\r\n\r\n    public static Color colorPOI2Itext(HSSFColor poiColor) {\r\n        short[] poiRGB = poiColor.getTriplet();\r\n        return new Color(poiRGB[0], poiRGB[1], poiRGB[2]);\r\n    }\r\n\r\n    public void copyBackgroundColor(HSSFCell xcell, PdfPCell cell) {\r\n        HSSFCellStyle xstyle = xcell.getCellStyle();\r\n        short cx = xstyle.getFillForegroundColor();\r\n        HSSFPalette palette = workbook.getCustomPalette();\r\n        HSSFColor poiColor = palette.getColor(cx);\r\n        if (poiColor != null && poiColor.getIndex() != HSSFColor.AUTOMATIC.index) {\r\n            Color color = colorPOI2Itext(poiColor);\r\n            cell.setBackgroundColor(color);\r\n        }\r\n    }\r\n\r\n    public void copyCellHorisontalAlignment(HSSFCell xcell, PdfPCell cell) {\r\n        HSSFCellStyle xstyle = xcell.getCellStyle();\r\n        int type = xcell.getCellType();\r\n        short alignment = xstyle.getAlignment();\r\n        switch(alignment) {\r\n            case HSSFCellStyle.ALIGN_GENERAL:\r\n                switch(type) {\r\n                    case HSSFCell.CELL_TYPE_NUMERIC:\r\n                        cell.setHorizontalAlignment(Element.ALIGN_RIGHT);\r\n                        break;\r\n                    case HSSFCell.CELL_TYPE_BLANK:\r\n                    case HSSFCell.CELL_TYPE_BOOLEAN:\r\n                    case HSSFCell.CELL_TYPE_ERROR:\r\n                    case HSSFCell.CELL_TYPE_STRING:\r\n                        cell.setHorizontalAlignment(Element.ALIGN_UNDEFINED);\r\n                        break;\r\n                    case HSSFCell.CELL_TYPE_FORMULA:\r\n                        HSSFFormulaEvaluator eval = new HSSFFormulaEvaluator(workbook);\r\n                        int valType = eval.evaluateFormulaCell(xcell);\r\n                        switch(valType) {\r\n                            case HSSFCell.CELL_TYPE_NUMERIC:\r\n                                cell.setHorizontalAlignment(Element.ALIGN_RIGHT);\r\n                                break;\r\n                            default:\r\n                                cell.setHorizontalAlignment(Element.ALIGN_UNDEFINED);\r\n                        }\r\n                        break;\r\n                }\r\n                break;\r\n            case HSSFCellStyle.ALIGN_LEFT:\r\n                cell.setHorizontalAlignment(Element.ALIGN_LEFT);\r\n                break;\r\n            case HSSFCellStyle.ALIGN_CENTER:\r\n                cell.setHorizontalAlignment(Element.ALIGN_CENTER);\r\n                break;\r\n            case HSSFCellStyle.ALIGN_RIGHT:\r\n                cell.setHorizontalAlignment(Element.ALIGN_RIGHT);\r\n                break;\r\n            case HSSFCellStyle.ALIGN_FILL:\r\n                cell.setHorizontalAlignment(Element.ALIGN_CENTER);\r\n                break;\r\n            case HSSFCellStyle.ALIGN_JUSTIFY:\r\n                cell.setHorizontalAlignment(Element.ALIGN_JUSTIFIED);\r\n                break;\r\n            case HSSFCellStyle.ALIGN_CENTER_SELECTION:\r\n                cell.setHorizontalAlignment(Element.ALIGN_CENTER);\r\n                break;\r\n        }\r\n    }\r\n\r\n    public void copyCellBorders(HSSFCell xcell, PdfPCell cell) {\r\n        HSSFCellStyle xstyle = xcell.getCellStyle();\r\n        int top = xstyle.getBorderTop() != HSSFCellStyle.BORDER_NONE ? Rectangle.TOP : Rectangle.NO_BORDER;\r\n        int bottom = xstyle.getBorderBottom() != HSSFCellStyle.BORDER_NONE ? Rectangle.BOTTOM : Rectangle.NO_BORDER;\r\n        int left = xstyle.getBorderLeft() != HSSFCellStyle.BORDER_NONE ? Rectangle.LEFT : Rectangle.NO_BORDER;\r\n        int right = xstyle.getBorderRight() != HSSFCellStyle.BORDER_NONE ? Rectangle.RIGHT : Rectangle.NO_BORDER;\r\n        cell.setBorder(top | bottom | left | right);\r\n    }\r\n\r\n    public void resetRightBorder(HSSFCell xcell, PdfPCell cell) {\r\n        HSSFCellStyle xstyle = xcell.getCellStyle();\r\n        int right = xstyle.getBorderRight() != HSSFCellStyle.BORDER_NONE ? Rectangle.RIGHT : Rectangle.NO_BORDER;\r\n        cell.setBorder(cell.getBorder() | right);\r\n    }\r\n\r\n    public Font chooseFont(HSSFFont xfont) {\r\n        int fontFamily = chooseFontFamily(xfont, Font.HELVETICA);\r\n        Font font = new Font(fontFamily);\r\n        font.setSize(xfont.getFontHeightInPoints());\r\n        int style = xfont.getBoldweight() == HSSFFont.BOLDWEIGHT_BOLD ? Font.BOLD : Font.NORMAL;\r\n        style |= xfont.getItalic() ? Font.ITALIC : Font.NORMAL;\r\n        style |= xfont.getStrikeout() ? Font.STRIKETHRU : Font.NORMAL;\r\n        style |= xfont.getUnderline() == HSSFFont.U_NONE ? Font.NORMAL : Font.UNDERLINE;\r\n        font.setStyle(style);\r\n        HSSFPalette palette = workbook.getCustomPalette();\r\n        HSSFColor poiColor = palette.getColor(xfont.getColor());\r\n        if (poiColor != null && poiColor.getIndex() != HSSFColor.AUTOMATIC.index) {\r\n            font.setColor(colorPOI2Itext(poiColor));\r\n        }\r\n        return font;\r\n    }\r\n\r\n    public int chooseFontFamily(HSSFFont font, int defaultFontFamily) {\r\n        String fontName = font.getFontName();\r\n        int fontFamily = defaultFontFamily;\r\n        if (\"Arial\".equals(fontName)) {\r\n            fontFamily = Font.HELVETICA;\r\n        } else if (\"Courier\".equals(fontName)) {\r\n            fontFamily = Font.COURIER;\r\n        } else if (\"Courier New\".equals(fontName)) {\r\n            fontFamily = Font.COURIER;\r\n        } else if (\"Times New Roman\".equals(fontName)) {\r\n            fontFamily = Font.TIMES_ROMAN;\r\n        }\r\n        return fontFamily;\r\n    }\r\n\r\n    public Font chooseFont(short fontIdx) {\r\n        return chooseFont(workbook.getFontAt(fontIdx));\r\n    }\r\n\r\n    public int getDefaultCharWidth() {\r\n        char defaultChar = '0';\r\n        HSSFFont defaultFont = workbook.getFontAt((short) 0);\r\n        AttributedString str = new AttributedString(\"\" + defaultChar);\r\n        copyAttributes(defaultFont, str, 0, 1);\r\n        FontRenderContext frc = new FontRenderContext(null, true, true);\r\n        TextLayout layout = new TextLayout(str.getIterator(), frc);\r\n        int defaultCharWidth = (int) layout.getAdvance();\r\n        return defaultCharWidth;\r\n    }\r\n\r\n    private void copyAttributes(HSSFFont font, AttributedString str, int startIdx, int endIdx) {\r\n        str.addAttribute(TextAttribute.FAMILY, font.getFontName(), startIdx, endIdx);\r\n        str.addAttribute(TextAttribute.SIZE, new Float(font.getFontHeightInPoints()));\r\n        if (font.getBoldweight() == HSSFFont.BOLDWEIGHT_BOLD)\r\n            str.addAttribute(TextAttribute.WEIGHT, TextAttribute.WEIGHT_BOLD, startIdx, endIdx);\r\n        if (font.getItalic())\r\n            str.addAttribute(TextAttribute.POSTURE, TextAttribute.POSTURE_OBLIQUE, startIdx, endIdx);\r\n        if (font.getUnderline() == HSSFFont.U_SINGLE)\r\n            str.addAttribute(TextAttribute.UNDERLINE, TextAttribute.UNDERLINE_ON, startIdx, endIdx);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/5_templateit/src/main/java/org/templateit/Poi2ItextUtilTest2.java",
		"test_prompt": "// Poi2ItextUtilTest2.java\npackage org.templateit;\n\nimport java.awt.Color;\nimport java.awt.font.FontRenderContext;\nimport java.awt.font.TextAttribute;\nimport java.awt.font.TextLayout;\nimport java.text.AttributedString;\nimport org.apache.log4j.Logger;\nimport org.apache.poi.hssf.usermodel.HSSFCell;\nimport org.apache.poi.hssf.usermodel.HSSFCellStyle;\nimport org.apache.poi.hssf.usermodel.HSSFFont;\nimport org.apache.poi.hssf.usermodel.HSSFFormulaEvaluator;\nimport org.apache.poi.hssf.usermodel.HSSFPalette;\nimport org.apache.poi.hssf.usermodel.HSSFWorkbook;\nimport org.apache.poi.hssf.util.HSSFColor;\nimport com.lowagie.text.Element;\nimport com.lowagie.text.Font;\nimport com.lowagie.text.Rectangle;\nimport com.lowagie.text.pdf.PdfPCell;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Poi2ItextUtil}.\n* It contains ten unit test cases for the {@link Poi2ItextUtil#chooseFontFamily(HSSFFont, int)} method.\n*/\nclass Poi2ItextUtilTest2 {"
	},
	{
		"original_code": "// Poi2ItextUtil.java\npackage org.templateit;\r\n\r\nimport java.awt.Color;\r\nimport java.awt.font.FontRenderContext;\r\nimport java.awt.font.TextAttribute;\r\nimport java.awt.font.TextLayout;\r\nimport java.text.AttributedString;\r\nimport org.apache.log4j.Logger;\r\nimport org.apache.poi.hssf.usermodel.HSSFCell;\r\nimport org.apache.poi.hssf.usermodel.HSSFCellStyle;\r\nimport org.apache.poi.hssf.usermodel.HSSFFont;\r\nimport org.apache.poi.hssf.usermodel.HSSFFormulaEvaluator;\r\nimport org.apache.poi.hssf.usermodel.HSSFPalette;\r\nimport org.apache.poi.hssf.usermodel.HSSFWorkbook;\r\nimport org.apache.poi.hssf.util.HSSFColor;\r\nimport com.lowagie.text.Element;\r\nimport com.lowagie.text.Font;\r\nimport com.lowagie.text.Rectangle;\r\nimport com.lowagie.text.pdf.PdfPCell;\r\n\r\npublic class Poi2ItextUtil {\r\n\r\n    private static final Logger logger = Logger.getLogger(Poi2ItextUtil.class);\r\n\r\n    private final HSSFWorkbook workbook;\r\n\r\n    public Poi2ItextUtil(HSSFWorkbook workbook) {\r\n        this.workbook = workbook;\r\n    }\r\n\r\n    public static Color colorPOI2Itext(HSSFColor poiColor) {\r\n        short[] poiRGB = poiColor.getTriplet();\r\n        return new Color(poiRGB[0], poiRGB[1], poiRGB[2]);\r\n    }\r\n\r\n    public void copyBackgroundColor(HSSFCell xcell, PdfPCell cell) {\r\n        HSSFCellStyle xstyle = xcell.getCellStyle();\r\n        short cx = xstyle.getFillForegroundColor();\r\n        HSSFPalette palette = workbook.getCustomPalette();\r\n        HSSFColor poiColor = palette.getColor(cx);\r\n        if (poiColor != null && poiColor.getIndex() != HSSFColor.AUTOMATIC.index) {\r\n            Color color = colorPOI2Itext(poiColor);\r\n            cell.setBackgroundColor(color);\r\n        }\r\n    }\r\n\r\n    public void copyCellHorisontalAlignment(HSSFCell xcell, PdfPCell cell) {\r\n        HSSFCellStyle xstyle = xcell.getCellStyle();\r\n        int type = xcell.getCellType();\r\n        short alignment = xstyle.getAlignment();\r\n        switch(alignment) {\r\n            case HSSFCellStyle.ALIGN_GENERAL:\r\n                switch(type) {\r\n                    case HSSFCell.CELL_TYPE_NUMERIC:\r\n                        cell.setHorizontalAlignment(Element.ALIGN_RIGHT);\r\n                        break;\r\n                    case HSSFCell.CELL_TYPE_BLANK:\r\n                    case HSSFCell.CELL_TYPE_BOOLEAN:\r\n                    case HSSFCell.CELL_TYPE_ERROR:\r\n                    case HSSFCell.CELL_TYPE_STRING:\r\n                        cell.setHorizontalAlignment(Element.ALIGN_UNDEFINED);\r\n                        break;\r\n                    case HSSFCell.CELL_TYPE_FORMULA:\r\n                        HSSFFormulaEvaluator eval = new HSSFFormulaEvaluator(workbook);\r\n                        int valType = eval.evaluateFormulaCell(xcell);\r\n                        switch(valType) {\r\n                            case HSSFCell.CELL_TYPE_NUMERIC:\r\n                                cell.setHorizontalAlignment(Element.ALIGN_RIGHT);\r\n                                break;\r\n                            default:\r\n                                cell.setHorizontalAlignment(Element.ALIGN_UNDEFINED);\r\n                        }\r\n                        break;\r\n                }\r\n                break;\r\n            case HSSFCellStyle.ALIGN_LEFT:\r\n                cell.setHorizontalAlignment(Element.ALIGN_LEFT);\r\n                break;\r\n            case HSSFCellStyle.ALIGN_CENTER:\r\n                cell.setHorizontalAlignment(Element.ALIGN_CENTER);\r\n                break;\r\n            case HSSFCellStyle.ALIGN_RIGHT:\r\n                cell.setHorizontalAlignment(Element.ALIGN_RIGHT);\r\n                break;\r\n            case HSSFCellStyle.ALIGN_FILL:\r\n                cell.setHorizontalAlignment(Element.ALIGN_CENTER);\r\n                break;\r\n            case HSSFCellStyle.ALIGN_JUSTIFY:\r\n                cell.setHorizontalAlignment(Element.ALIGN_JUSTIFIED);\r\n                break;\r\n            case HSSFCellStyle.ALIGN_CENTER_SELECTION:\r\n                cell.setHorizontalAlignment(Element.ALIGN_CENTER);\r\n                break;\r\n        }\r\n    }\r\n\r\n    public void copyCellBorders(HSSFCell xcell, PdfPCell cell) {\r\n        HSSFCellStyle xstyle = xcell.getCellStyle();\r\n        int top = xstyle.getBorderTop() != HSSFCellStyle.BORDER_NONE ? Rectangle.TOP : Rectangle.NO_BORDER;\r\n        int bottom = xstyle.getBorderBottom() != HSSFCellStyle.BORDER_NONE ? Rectangle.BOTTOM : Rectangle.NO_BORDER;\r\n        int left = xstyle.getBorderLeft() != HSSFCellStyle.BORDER_NONE ? Rectangle.LEFT : Rectangle.NO_BORDER;\r\n        int right = xstyle.getBorderRight() != HSSFCellStyle.BORDER_NONE ? Rectangle.RIGHT : Rectangle.NO_BORDER;\r\n        cell.setBorder(top | bottom | left | right);\r\n    }\r\n\r\n    public void resetRightBorder(HSSFCell xcell, PdfPCell cell) {\r\n        HSSFCellStyle xstyle = xcell.getCellStyle();\r\n        int right = xstyle.getBorderRight() != HSSFCellStyle.BORDER_NONE ? Rectangle.RIGHT : Rectangle.NO_BORDER;\r\n        cell.setBorder(cell.getBorder() | right);\r\n    }\r\n\r\n    public Font chooseFont(HSSFFont xfont) {\r\n        int fontFamily = chooseFontFamily(xfont, Font.HELVETICA);\r\n        Font font = new Font(fontFamily);\r\n        font.setSize(xfont.getFontHeightInPoints());\r\n        int style = xfont.getBoldweight() == HSSFFont.BOLDWEIGHT_BOLD ? Font.BOLD : Font.NORMAL;\r\n        style |= xfont.getItalic() ? Font.ITALIC : Font.NORMAL;\r\n        style |= xfont.getStrikeout() ? Font.STRIKETHRU : Font.NORMAL;\r\n        style |= xfont.getUnderline() == HSSFFont.U_NONE ? Font.NORMAL : Font.UNDERLINE;\r\n        font.setStyle(style);\r\n        HSSFPalette palette = workbook.getCustomPalette();\r\n        HSSFColor poiColor = palette.getColor(xfont.getColor());\r\n        if (poiColor != null && poiColor.getIndex() != HSSFColor.AUTOMATIC.index) {\r\n            font.setColor(colorPOI2Itext(poiColor));\r\n        }\r\n        return font;\r\n    }\r\n\r\n    public int chooseFontFamily(HSSFFont font, int defaultFontFamily) {\r\n        String fontName = font.getFontName();\r\n        int fontFamily = defaultFontFamily;\r\n        if (\"Arial\".equals(fontName)) {\r\n            fontFamily = Font.HELVETICA;\r\n        } else if (\"Courier\".equals(fontName)) {\r\n            fontFamily = Font.COURIER;\r\n        } else if (\"Courier New\".equals(fontName)) {\r\n            fontFamily = Font.COURIER;\r\n        } else if (\"Times New Roman\".equals(fontName)) {\r\n            fontFamily = Font.TIMES_ROMAN;\r\n        }\r\n        return fontFamily;\r\n    }\r\n\r\n    public Font chooseFont(short fontIdx) {\r\n        return chooseFont(workbook.getFontAt(fontIdx));\r\n    }\r\n\r\n    public int getDefaultCharWidth() {\r\n        char defaultChar = '0';\r\n        HSSFFont defaultFont = workbook.getFontAt((short) 0);\r\n        AttributedString str = new AttributedString(\"\" + defaultChar);\r\n        copyAttributes(defaultFont, str, 0, 1);\r\n        FontRenderContext frc = new FontRenderContext(null, true, true);\r\n        TextLayout layout = new TextLayout(str.getIterator(), frc);\r\n        int defaultCharWidth = (int) layout.getAdvance();\r\n        return defaultCharWidth;\r\n    }\r\n\r\n    private void copyAttributes(HSSFFont font, AttributedString str, int startIdx, int endIdx) {\r\n        str.addAttribute(TextAttribute.FAMILY, font.getFontName(), startIdx, endIdx);\r\n        str.addAttribute(TextAttribute.SIZE, new Float(font.getFontHeightInPoints()));\r\n        if (font.getBoldweight() == HSSFFont.BOLDWEIGHT_BOLD)\r\n            str.addAttribute(TextAttribute.WEIGHT, TextAttribute.WEIGHT_BOLD, startIdx, endIdx);\r\n        if (font.getItalic())\r\n            str.addAttribute(TextAttribute.POSTURE, TextAttribute.POSTURE_OBLIQUE, startIdx, endIdx);\r\n        if (font.getUnderline() == HSSFFont.U_SINGLE)\r\n            str.addAttribute(TextAttribute.UNDERLINE, TextAttribute.UNDERLINE_ON, startIdx, endIdx);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/5_templateit/src/main/java/org/templateit/Poi2ItextUtilTest3.java",
		"test_prompt": "// Poi2ItextUtilTest3.java\npackage org.templateit;\n\nimport java.awt.Color;\nimport java.awt.font.FontRenderContext;\nimport java.awt.font.TextAttribute;\nimport java.awt.font.TextLayout;\nimport java.text.AttributedString;\nimport org.apache.log4j.Logger;\nimport org.apache.poi.hssf.usermodel.HSSFCell;\nimport org.apache.poi.hssf.usermodel.HSSFCellStyle;\nimport org.apache.poi.hssf.usermodel.HSSFFont;\nimport org.apache.poi.hssf.usermodel.HSSFFormulaEvaluator;\nimport org.apache.poi.hssf.usermodel.HSSFPalette;\nimport org.apache.poi.hssf.usermodel.HSSFWorkbook;\nimport org.apache.poi.hssf.util.HSSFColor;\nimport com.lowagie.text.Element;\nimport com.lowagie.text.Font;\nimport com.lowagie.text.Rectangle;\nimport com.lowagie.text.pdf.PdfPCell;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Poi2ItextUtil}.\n* It contains ten unit test cases for the {@link Poi2ItextUtil#chooseFont(short)} method.\n*/\nclass Poi2ItextUtilTest3 {"
	},
	{
		"original_code": "// Template.java\n/*\r\n * Copyright(C) 2008-2009 Dmitriy Kumshayev. <dq@mail.com>\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\npackage org.templateit;\r\n\r\nimport java.util.HashMap;\r\nimport java.util.LinkedList;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport org.apache.log4j.Logger;\r\nimport org.apache.poi.hssf.usermodel.HSSFCell;\r\nimport org.apache.poi.hssf.usermodel.HSSFSheet;\r\n\r\npublic abstract class Template {\r\n\r\n    private static final Logger logger = Logger.getLogger(Template.class);\r\n\r\n    protected final String name;\r\n\r\n    protected final HSSFSheet sheet;\r\n\r\n    protected final List<Parameter> parameters = new LinkedList<Parameter>();\r\n\r\n    private final Map<String, Parameter> parametersByName = new HashMap<String, Parameter>();\r\n\r\n    private final Map<Integer, Map<Integer, Parameter>> paramsByRowCol = new HashMap<Integer, Map<Integer, Parameter>>();\r\n\r\n    public Template(String name, HSSFSheet sheet) {\r\n        this.name = name;\r\n        this.sheet = sheet;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public Parameter getParameter(String name) {\r\n        return parametersByName.get(name);\r\n    }\r\n\r\n    public void setParameters(Parameter[] parameters) {\r\n        for (Parameter p : parameters) {\r\n            addParameter(p);\r\n        }\r\n    }\r\n\r\n    public int getParametersNumber() {\r\n        return parameters.size();\r\n    }\r\n\r\n    protected void createParameter(String paramName, int r, int c) {\r\n        boolean isNumber = Character.isDigit(paramName.charAt(0));\r\n        Parameter param = (isNumber ? this.getParameter(Integer.parseInt(paramName)) : this.getParameter(paramName));\r\n        if (param != null) {\r\n            param.setColumn(c);\r\n            param.setRow(r);\r\n        } else if (isNumber) {\r\n            param = new Parameter();\r\n            param.setColumn(c);\r\n            param.setRow(r);\r\n            param.setIndex(Integer.parseInt(paramName));\r\n            param.setName(\"#\" + paramName);\r\n            this.addParameter(param);\r\n        } else {\r\n            logger.warn(\"Missing parameter: \" + paramName + \"@(\" + r + \",\" + c + \")\");\r\n        }\r\n        if (param != null) {\r\n            int relRow = param.getRow();\r\n            int relCol = param.getColumn();\r\n            Map<Integer, Parameter> paramsByCol = paramsByRowCol.get(relRow);\r\n            if (paramsByCol == null) {\r\n                paramsByCol = new HashMap<Integer, Parameter>();\r\n                paramsByRowCol.put(relRow, paramsByCol);\r\n            }\r\n            paramsByCol.put(relCol, param);\r\n        }\r\n    }\r\n\r\n    public Parameter getParameter(int r, int c) {\r\n        Map<Integer, Parameter> paramsByCol = paramsByRowCol.get(r);\r\n        if (paramsByCol != null) {\r\n            return paramsByCol.get(c);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public void addParameter(Parameter parameter) {\r\n        parameters.add(parameter);\r\n        String name = parameter.getName();\r\n        // Parameter name is optional\r\n        if (name != null) {\r\n            if (!parametersByName.containsKey(name)) {\r\n                parametersByName.put(name, parameter);\r\n            } else {\r\n                logger.warn(\"Duplicate parameter: \" + name);\r\n            }\r\n        }\r\n    }\r\n\r\n    public Parameter getParameter(int idx) {\r\n        return idx >= 1 && idx <= parameters.size() ? parameters.get(idx - 1) : null;\r\n    }\r\n\r\n    public abstract int height();\r\n\r\n    public abstract int width();\r\n\r\n    public abstract Reference absoluteReference(int r, int c);\r\n\r\n    public abstract int getRowHeight(int r);\r\n\r\n    public abstract HSSFCell getCell(int r, int c);\r\n\r\n    public boolean isRowBroken(int r) {\r\n        return false;\r\n    }\r\n\r\n    public int getParameterIndex(int r, int c) {\r\n        int idx = -1;\r\n        Parameter p = getParameter(r, c);\r\n        if (p != null) {\r\n            idx = p.getIndex();\r\n        }\r\n        return idx;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/5_templateit/src/main/java/org/templateit/TemplateTest.java",
		"test_prompt": "// TemplateTest.java\npackage org.templateit;\n\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.log4j.Logger;\nimport org.apache.poi.hssf.usermodel.HSSFCell;\nimport org.apache.poi.hssf.usermodel.HSSFSheet;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Template}.\n* It contains ten unit test cases for the {@link Template#isRowBroken(int)} method.\n*/\nclass TemplateTest {"
	},
	{
		"original_code": "// TemplateSheet.java\n/*\r\n * Copyright(C) 2008-2009 Dmitriy Kumshayev. <dq@mail.com>\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\npackage org.templateit;\r\n\r\nimport java.util.Collection;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport org.apache.poi.hssf.usermodel.HSSFSheet;\r\n\r\nclass TemplateSheet {\r\n\r\n    private final String sheetName;\r\n\r\n    private final HSSFSheet sheet;\r\n\r\n    private final Map<String, StaticTemplate> templateMap = new HashMap<String, StaticTemplate>();\r\n\r\n    private final Map<String, DynamicTemplate> dynamicTemplateMap = new HashMap<String, DynamicTemplate>();\r\n\r\n    private int lastColumn = 0;\r\n\r\n    private int firstColumn = 0;\r\n\r\n    private final Map<String, NamedStyle> stylesMap = new HashMap<String, NamedStyle>();\r\n\r\n    public TemplateSheet(String sheetName, HSSFSheet sheet) {\r\n        this.sheetName = sheetName;\r\n        this.sheet = sheet;\r\n    }\r\n\r\n    public Template getTemplate(String tName) {\r\n        Template template = dynamicTemplateMap.get(tName);\r\n        if (template == null) {\r\n            template = templateMap.get(tName);\r\n        }\r\n        return template;\r\n    }\r\n\r\n    public StaticTemplate getStaticTemplate(String tName) {\r\n        return templateMap.get(tName);\r\n    }\r\n\r\n    public Collection<StaticTemplate> templates() {\r\n        return templateMap.values();\r\n    }\r\n\r\n    public StaticTemplate createTemplate(int r, int c, String[] names) {\r\n        String tName = names[0];\r\n        StaticTemplate t = this.getStaticTemplate(tName);\r\n        if (t == null) {\r\n            t = new StaticTemplate(tName, sheet);\r\n            if (names.length > 1) {\r\n                Parameter[] parameters = new Parameter[names.length - 1];\r\n                for (int i = 1; i < names.length; i++) {\r\n                    Parameter parameter = new Parameter();\r\n                    parameter.setName(names[i]);\r\n                    parameter.setIndex(i);\r\n                    parameters[i - 1] = parameter;\r\n                }\r\n                t.setParameters(parameters);\r\n            }\r\n            Reference start = new Reference(r, c);\r\n            t.setStartReference(start);\r\n            this.addTemplate(t);\r\n        }\r\n        return t;\r\n    }\r\n\r\n    public String getSheetName() {\r\n        return sheetName;\r\n    }\r\n\r\n    public int getFirstColumn() {\r\n        return firstColumn;\r\n    }\r\n\r\n    public int getLastColumn() {\r\n        return lastColumn;\r\n    }\r\n\r\n    public void setLastColumn(int lastColumn) {\r\n        this.lastColumn = lastColumn;\r\n    }\r\n\r\n    public HSSFSheet sheet() {\r\n        return sheet;\r\n    }\r\n\r\n    private StaticTemplate addTemplate(StaticTemplate t) {\r\n        if (templateMap.size() == 0) {\r\n            firstColumn = t.start().column();\r\n        } else {\r\n            firstColumn = Math.min(firstColumn, t.start().column());\r\n        }\r\n        return templateMap.put(t.getName(), t);\r\n    }\r\n\r\n    public NamedStyle addStyle(NamedStyle style) {\r\n        if (style != null) {\r\n            return stylesMap.put(style.getName(), style);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public NamedStyle getStyle(String styleName) {\r\n        return stylesMap.get(styleName);\r\n    }\r\n\r\n    public void addDynamicTemplate(DynamicTemplate dynamicTemplate) {\r\n        dynamicTemplateMap.put(dynamicTemplate.getName(), dynamicTemplate);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/5_templateit/src/main/java/org/templateit/TemplateSheetTest0.java",
		"test_prompt": "// TemplateSheetTest0.java\npackage org.templateit;\n\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.apache.poi.hssf.usermodel.HSSFSheet;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TemplateSheet}.\n* It contains ten unit test cases for the {@link TemplateSheet#templates()} method.\n*/\nclass TemplateSheetTest0 {"
	},
	{
		"original_code": "// TemplateSheet.java\n/*\r\n * Copyright(C) 2008-2009 Dmitriy Kumshayev. <dq@mail.com>\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\npackage org.templateit;\r\n\r\nimport java.util.Collection;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport org.apache.poi.hssf.usermodel.HSSFSheet;\r\n\r\nclass TemplateSheet {\r\n\r\n    private final String sheetName;\r\n\r\n    private final HSSFSheet sheet;\r\n\r\n    private final Map<String, StaticTemplate> templateMap = new HashMap<String, StaticTemplate>();\r\n\r\n    private final Map<String, DynamicTemplate> dynamicTemplateMap = new HashMap<String, DynamicTemplate>();\r\n\r\n    private int lastColumn = 0;\r\n\r\n    private int firstColumn = 0;\r\n\r\n    private final Map<String, NamedStyle> stylesMap = new HashMap<String, NamedStyle>();\r\n\r\n    public TemplateSheet(String sheetName, HSSFSheet sheet) {\r\n        this.sheetName = sheetName;\r\n        this.sheet = sheet;\r\n    }\r\n\r\n    public Template getTemplate(String tName) {\r\n        Template template = dynamicTemplateMap.get(tName);\r\n        if (template == null) {\r\n            template = templateMap.get(tName);\r\n        }\r\n        return template;\r\n    }\r\n\r\n    public StaticTemplate getStaticTemplate(String tName) {\r\n        return templateMap.get(tName);\r\n    }\r\n\r\n    public Collection<StaticTemplate> templates() {\r\n        return templateMap.values();\r\n    }\r\n\r\n    public StaticTemplate createTemplate(int r, int c, String[] names) {\r\n        String tName = names[0];\r\n        StaticTemplate t = this.getStaticTemplate(tName);\r\n        if (t == null) {\r\n            t = new StaticTemplate(tName, sheet);\r\n            if (names.length > 1) {\r\n                Parameter[] parameters = new Parameter[names.length - 1];\r\n                for (int i = 1; i < names.length; i++) {\r\n                    Parameter parameter = new Parameter();\r\n                    parameter.setName(names[i]);\r\n                    parameter.setIndex(i);\r\n                    parameters[i - 1] = parameter;\r\n                }\r\n                t.setParameters(parameters);\r\n            }\r\n            Reference start = new Reference(r, c);\r\n            t.setStartReference(start);\r\n            this.addTemplate(t);\r\n        }\r\n        return t;\r\n    }\r\n\r\n    public String getSheetName() {\r\n        return sheetName;\r\n    }\r\n\r\n    public int getFirstColumn() {\r\n        return firstColumn;\r\n    }\r\n\r\n    public int getLastColumn() {\r\n        return lastColumn;\r\n    }\r\n\r\n    public void setLastColumn(int lastColumn) {\r\n        this.lastColumn = lastColumn;\r\n    }\r\n\r\n    public HSSFSheet sheet() {\r\n        return sheet;\r\n    }\r\n\r\n    private StaticTemplate addTemplate(StaticTemplate t) {\r\n        if (templateMap.size() == 0) {\r\n            firstColumn = t.start().column();\r\n        } else {\r\n            firstColumn = Math.min(firstColumn, t.start().column());\r\n        }\r\n        return templateMap.put(t.getName(), t);\r\n    }\r\n\r\n    public NamedStyle addStyle(NamedStyle style) {\r\n        if (style != null) {\r\n            return stylesMap.put(style.getName(), style);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public NamedStyle getStyle(String styleName) {\r\n        return stylesMap.get(styleName);\r\n    }\r\n\r\n    public void addDynamicTemplate(DynamicTemplate dynamicTemplate) {\r\n        dynamicTemplateMap.put(dynamicTemplate.getName(), dynamicTemplate);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/5_templateit/src/main/java/org/templateit/TemplateSheetTest1.java",
		"test_prompt": "// TemplateSheetTest1.java\npackage org.templateit;\n\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.apache.poi.hssf.usermodel.HSSFSheet;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TemplateSheet}.\n* It contains ten unit test cases for the {@link TemplateSheet#createTemplate(int, int, String[])} method.\n*/\nclass TemplateSheetTest1 {"
	},
	{
		"original_code": "// TemplateSheet.java\n/*\r\n * Copyright(C) 2008-2009 Dmitriy Kumshayev. <dq@mail.com>\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\npackage org.templateit;\r\n\r\nimport java.util.Collection;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport org.apache.poi.hssf.usermodel.HSSFSheet;\r\n\r\nclass TemplateSheet {\r\n\r\n    private final String sheetName;\r\n\r\n    private final HSSFSheet sheet;\r\n\r\n    private final Map<String, StaticTemplate> templateMap = new HashMap<String, StaticTemplate>();\r\n\r\n    private final Map<String, DynamicTemplate> dynamicTemplateMap = new HashMap<String, DynamicTemplate>();\r\n\r\n    private int lastColumn = 0;\r\n\r\n    private int firstColumn = 0;\r\n\r\n    private final Map<String, NamedStyle> stylesMap = new HashMap<String, NamedStyle>();\r\n\r\n    public TemplateSheet(String sheetName, HSSFSheet sheet) {\r\n        this.sheetName = sheetName;\r\n        this.sheet = sheet;\r\n    }\r\n\r\n    public Template getTemplate(String tName) {\r\n        Template template = dynamicTemplateMap.get(tName);\r\n        if (template == null) {\r\n            template = templateMap.get(tName);\r\n        }\r\n        return template;\r\n    }\r\n\r\n    public StaticTemplate getStaticTemplate(String tName) {\r\n        return templateMap.get(tName);\r\n    }\r\n\r\n    public Collection<StaticTemplate> templates() {\r\n        return templateMap.values();\r\n    }\r\n\r\n    public StaticTemplate createTemplate(int r, int c, String[] names) {\r\n        String tName = names[0];\r\n        StaticTemplate t = this.getStaticTemplate(tName);\r\n        if (t == null) {\r\n            t = new StaticTemplate(tName, sheet);\r\n            if (names.length > 1) {\r\n                Parameter[] parameters = new Parameter[names.length - 1];\r\n                for (int i = 1; i < names.length; i++) {\r\n                    Parameter parameter = new Parameter();\r\n                    parameter.setName(names[i]);\r\n                    parameter.setIndex(i);\r\n                    parameters[i - 1] = parameter;\r\n                }\r\n                t.setParameters(parameters);\r\n            }\r\n            Reference start = new Reference(r, c);\r\n            t.setStartReference(start);\r\n            this.addTemplate(t);\r\n        }\r\n        return t;\r\n    }\r\n\r\n    public String getSheetName() {\r\n        return sheetName;\r\n    }\r\n\r\n    public int getFirstColumn() {\r\n        return firstColumn;\r\n    }\r\n\r\n    public int getLastColumn() {\r\n        return lastColumn;\r\n    }\r\n\r\n    public void setLastColumn(int lastColumn) {\r\n        this.lastColumn = lastColumn;\r\n    }\r\n\r\n    public HSSFSheet sheet() {\r\n        return sheet;\r\n    }\r\n\r\n    private StaticTemplate addTemplate(StaticTemplate t) {\r\n        if (templateMap.size() == 0) {\r\n            firstColumn = t.start().column();\r\n        } else {\r\n            firstColumn = Math.min(firstColumn, t.start().column());\r\n        }\r\n        return templateMap.put(t.getName(), t);\r\n    }\r\n\r\n    public NamedStyle addStyle(NamedStyle style) {\r\n        if (style != null) {\r\n            return stylesMap.put(style.getName(), style);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public NamedStyle getStyle(String styleName) {\r\n        return stylesMap.get(styleName);\r\n    }\r\n\r\n    public void addDynamicTemplate(DynamicTemplate dynamicTemplate) {\r\n        dynamicTemplateMap.put(dynamicTemplate.getName(), dynamicTemplate);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/5_templateit/src/main/java/org/templateit/TemplateSheetTest2.java",
		"test_prompt": "// TemplateSheetTest2.java\npackage org.templateit;\n\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.apache.poi.hssf.usermodel.HSSFSheet;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TemplateSheet}.\n* It contains ten unit test cases for the {@link TemplateSheet#sheet()} method.\n*/\nclass TemplateSheetTest2 {"
	},
	{
		"original_code": "// TemplateSheet.java\n/*\r\n * Copyright(C) 2008-2009 Dmitriy Kumshayev. <dq@mail.com>\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\npackage org.templateit;\r\n\r\nimport java.util.Collection;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport org.apache.poi.hssf.usermodel.HSSFSheet;\r\n\r\nclass TemplateSheet {\r\n\r\n    private final String sheetName;\r\n\r\n    private final HSSFSheet sheet;\r\n\r\n    private final Map<String, StaticTemplate> templateMap = new HashMap<String, StaticTemplate>();\r\n\r\n    private final Map<String, DynamicTemplate> dynamicTemplateMap = new HashMap<String, DynamicTemplate>();\r\n\r\n    private int lastColumn = 0;\r\n\r\n    private int firstColumn = 0;\r\n\r\n    private final Map<String, NamedStyle> stylesMap = new HashMap<String, NamedStyle>();\r\n\r\n    public TemplateSheet(String sheetName, HSSFSheet sheet) {\r\n        this.sheetName = sheetName;\r\n        this.sheet = sheet;\r\n    }\r\n\r\n    public Template getTemplate(String tName) {\r\n        Template template = dynamicTemplateMap.get(tName);\r\n        if (template == null) {\r\n            template = templateMap.get(tName);\r\n        }\r\n        return template;\r\n    }\r\n\r\n    public StaticTemplate getStaticTemplate(String tName) {\r\n        return templateMap.get(tName);\r\n    }\r\n\r\n    public Collection<StaticTemplate> templates() {\r\n        return templateMap.values();\r\n    }\r\n\r\n    public StaticTemplate createTemplate(int r, int c, String[] names) {\r\n        String tName = names[0];\r\n        StaticTemplate t = this.getStaticTemplate(tName);\r\n        if (t == null) {\r\n            t = new StaticTemplate(tName, sheet);\r\n            if (names.length > 1) {\r\n                Parameter[] parameters = new Parameter[names.length - 1];\r\n                for (int i = 1; i < names.length; i++) {\r\n                    Parameter parameter = new Parameter();\r\n                    parameter.setName(names[i]);\r\n                    parameter.setIndex(i);\r\n                    parameters[i - 1] = parameter;\r\n                }\r\n                t.setParameters(parameters);\r\n            }\r\n            Reference start = new Reference(r, c);\r\n            t.setStartReference(start);\r\n            this.addTemplate(t);\r\n        }\r\n        return t;\r\n    }\r\n\r\n    public String getSheetName() {\r\n        return sheetName;\r\n    }\r\n\r\n    public int getFirstColumn() {\r\n        return firstColumn;\r\n    }\r\n\r\n    public int getLastColumn() {\r\n        return lastColumn;\r\n    }\r\n\r\n    public void setLastColumn(int lastColumn) {\r\n        this.lastColumn = lastColumn;\r\n    }\r\n\r\n    public HSSFSheet sheet() {\r\n        return sheet;\r\n    }\r\n\r\n    private StaticTemplate addTemplate(StaticTemplate t) {\r\n        if (templateMap.size() == 0) {\r\n            firstColumn = t.start().column();\r\n        } else {\r\n            firstColumn = Math.min(firstColumn, t.start().column());\r\n        }\r\n        return templateMap.put(t.getName(), t);\r\n    }\r\n\r\n    public NamedStyle addStyle(NamedStyle style) {\r\n        if (style != null) {\r\n            return stylesMap.put(style.getName(), style);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public NamedStyle getStyle(String styleName) {\r\n        return stylesMap.get(styleName);\r\n    }\r\n\r\n    public void addDynamicTemplate(DynamicTemplate dynamicTemplate) {\r\n        dynamicTemplateMap.put(dynamicTemplate.getName(), dynamicTemplate);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/5_templateit/src/main/java/org/templateit/TemplateSheetTest3.java",
		"test_prompt": "// TemplateSheetTest3.java\npackage org.templateit;\n\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.apache.poi.hssf.usermodel.HSSFSheet;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TemplateSheet}.\n* It contains ten unit test cases for the {@link TemplateSheet#addStyle(NamedStyle)} method.\n*/\nclass TemplateSheetTest3 {"
	},
	{
		"original_code": "// OpMatcher.java\n/*\r\n * Copyright(C) 2008-2009 Dmitriy Kumshayev. <dq@mail.com>\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\npackage org.templateit;\r\n\r\nimport java.util.regex.Matcher;\r\nimport java.util.regex.Pattern;\r\n\r\nfinal class OpMatcher {\r\n\r\n    private static final String TBEGIN1 = \"@template_begin\";\r\n\r\n    private static final String TBEGIN2 = \"@tbegin\";\r\n\r\n    private static final String beginParams = \"\\\\s*\\\\(\\\\s*((\\\\p{Alpha}\\\\w*)(\\\\s*,\\\\s*\\\\p{Alpha}\\\\w*)*)\\\\s*\\\\)\";\r\n\r\n    private static final Pattern templateBeginPattern1 = Pattern.compile(TBEGIN1 + beginParams);\r\n\r\n    private static final Pattern templateBeginPattern2 = Pattern.compile(TBEGIN2 + beginParams);\r\n\r\n    /**\r\n     * Match a string with\r\n     * <em>#template_begin(name, param1, param2, ..., paramN)</em> instruction.\r\n     *\r\n     * @param text\r\n     *          being matched\r\n     *\r\n     * @return if matched, return a String array, where the first element is\r\n     */\r\n    public static String[] matchTemplateBegin(String text) {\r\n        String[] names = null;\r\n        if (text != null) {\r\n            Matcher m = null;\r\n            if (text.indexOf(TBEGIN1) != -1) {\r\n                m = templateBeginPattern1.matcher(text);\r\n            } else if (text.indexOf(TBEGIN2) != -1) {\r\n                m = templateBeginPattern2.matcher(text);\r\n            }\r\n            if (m != null) {\r\n                if (m.groupCount() == 3) {\r\n                    boolean matches = m.find();\r\n                    if (matches) {\r\n                        String group = m.group(1);\r\n                        if (group != null) {\r\n                            names = group.split(\"\\\\s*,\\\\s*\");\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return names;\r\n    }\r\n\r\n    public static boolean matchTemplateEnd(String text) {\r\n        return text != null && (text.indexOf(\"@template_end\") != -1) || (text.indexOf(\"@tend\") != -1);\r\n    }\r\n\r\n    private static final Pattern parameterNumberPattern = Pattern.compile(\"#([1-9]\\\\p{Digit}*)\");\r\n\r\n    private static final Pattern parameterNamePattern = Pattern.compile(\"#(\\\\p{Alpha}\\\\w*)\");\r\n\r\n    public static String matchTemplateParameter(String text) {\r\n        String parameterName = null;\r\n        if (text != null) {\r\n            if (text.indexOf(\"#\") != -1) {\r\n                Matcher fieldNameMatcher = parameterNamePattern.matcher(text);\r\n                boolean found = fieldNameMatcher.find();\r\n                if (found && fieldNameMatcher.groupCount() == 1) {\r\n                    parameterName = fieldNameMatcher.group(1);\r\n                } else {\r\n                    Matcher fieldNumberMatcher = parameterNumberPattern.matcher(text);\r\n                    found = fieldNumberMatcher.find();\r\n                    if (found && fieldNumberMatcher.groupCount() == 1) {\r\n                        parameterName = fieldNumberMatcher.group(1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return parameterName;\r\n    }\r\n\r\n    private static final Pattern templateNamePattern = Pattern.compile(\"\\\\p{Alpha}\\\\w*\");\r\n\r\n    public static boolean matchTemplateName(String text) {\r\n        if (text != null) {\r\n            return templateNamePattern.matcher(text).matches();\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    private static final Pattern stylePattern = Pattern.compile(\"@style\\\\s*\\\\(\\\\s*(\\\\p{Alpha}\\\\w*)\\\\s*\\\\)\");\r\n\r\n    private static final Pattern styleWithParamPattern = Pattern.compile(\"@style\\\\s*\\\\(\\\\s*(\\\\p{Alpha}\\\\w*)\\\\s*,\\\\s*((true)|(false))\\\\s*\\\\)\");\r\n\r\n    public static NamedStyle matchStyle(String text) {\r\n        NamedStyle style = null;\r\n        String styleName = null;\r\n        if (text != null) {\r\n            Matcher matcher = stylePattern.matcher(text);\r\n            boolean found = matcher.find();\r\n            if (found && matcher.groupCount() == 1) {\r\n                styleName = matcher.group(1);\r\n                style = new NamedStyle(styleName, false);\r\n            } else {\r\n                matcher = styleWithParamPattern.matcher(text);\r\n                found = matcher.find();\r\n                if (found && matcher.groupCount() == 4) {\r\n                    styleName = matcher.group(1);\r\n                    String paramFlag = matcher.group(2);\r\n                    boolean flag = Boolean.parseBoolean(paramFlag);\r\n                    style = new NamedStyle(styleName, flag);\r\n                }\r\n            }\r\n        }\r\n        return style;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/5_templateit/src/main/java/org/templateit/OpMatcherTest0.java",
		"test_prompt": "// OpMatcherTest0.java\npackage org.templateit;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link OpMatcher}.\n* It contains ten unit test cases for the {@link OpMatcher#matchTemplateBegin(String)} method.\n*/\nclass OpMatcherTest0 {"
	},
	{
		"original_code": "// OpMatcher.java\n/*\r\n * Copyright(C) 2008-2009 Dmitriy Kumshayev. <dq@mail.com>\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\npackage org.templateit;\r\n\r\nimport java.util.regex.Matcher;\r\nimport java.util.regex.Pattern;\r\n\r\nfinal class OpMatcher {\r\n\r\n    private static final String TBEGIN1 = \"@template_begin\";\r\n\r\n    private static final String TBEGIN2 = \"@tbegin\";\r\n\r\n    private static final String beginParams = \"\\\\s*\\\\(\\\\s*((\\\\p{Alpha}\\\\w*)(\\\\s*,\\\\s*\\\\p{Alpha}\\\\w*)*)\\\\s*\\\\)\";\r\n\r\n    private static final Pattern templateBeginPattern1 = Pattern.compile(TBEGIN1 + beginParams);\r\n\r\n    private static final Pattern templateBeginPattern2 = Pattern.compile(TBEGIN2 + beginParams);\r\n\r\n    /**\r\n     * Match a string with\r\n     * <em>#template_begin(name, param1, param2, ..., paramN)</em> instruction.\r\n     *\r\n     * @param text\r\n     *          being matched\r\n     *\r\n     * @return if matched, return a String array, where the first element is\r\n     */\r\n    public static String[] matchTemplateBegin(String text) {\r\n        String[] names = null;\r\n        if (text != null) {\r\n            Matcher m = null;\r\n            if (text.indexOf(TBEGIN1) != -1) {\r\n                m = templateBeginPattern1.matcher(text);\r\n            } else if (text.indexOf(TBEGIN2) != -1) {\r\n                m = templateBeginPattern2.matcher(text);\r\n            }\r\n            if (m != null) {\r\n                if (m.groupCount() == 3) {\r\n                    boolean matches = m.find();\r\n                    if (matches) {\r\n                        String group = m.group(1);\r\n                        if (group != null) {\r\n                            names = group.split(\"\\\\s*,\\\\s*\");\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return names;\r\n    }\r\n\r\n    public static boolean matchTemplateEnd(String text) {\r\n        return text != null && (text.indexOf(\"@template_end\") != -1) || (text.indexOf(\"@tend\") != -1);\r\n    }\r\n\r\n    private static final Pattern parameterNumberPattern = Pattern.compile(\"#([1-9]\\\\p{Digit}*)\");\r\n\r\n    private static final Pattern parameterNamePattern = Pattern.compile(\"#(\\\\p{Alpha}\\\\w*)\");\r\n\r\n    public static String matchTemplateParameter(String text) {\r\n        String parameterName = null;\r\n        if (text != null) {\r\n            if (text.indexOf(\"#\") != -1) {\r\n                Matcher fieldNameMatcher = parameterNamePattern.matcher(text);\r\n                boolean found = fieldNameMatcher.find();\r\n                if (found && fieldNameMatcher.groupCount() == 1) {\r\n                    parameterName = fieldNameMatcher.group(1);\r\n                } else {\r\n                    Matcher fieldNumberMatcher = parameterNumberPattern.matcher(text);\r\n                    found = fieldNumberMatcher.find();\r\n                    if (found && fieldNumberMatcher.groupCount() == 1) {\r\n                        parameterName = fieldNumberMatcher.group(1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return parameterName;\r\n    }\r\n\r\n    private static final Pattern templateNamePattern = Pattern.compile(\"\\\\p{Alpha}\\\\w*\");\r\n\r\n    public static boolean matchTemplateName(String text) {\r\n        if (text != null) {\r\n            return templateNamePattern.matcher(text).matches();\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    private static final Pattern stylePattern = Pattern.compile(\"@style\\\\s*\\\\(\\\\s*(\\\\p{Alpha}\\\\w*)\\\\s*\\\\)\");\r\n\r\n    private static final Pattern styleWithParamPattern = Pattern.compile(\"@style\\\\s*\\\\(\\\\s*(\\\\p{Alpha}\\\\w*)\\\\s*,\\\\s*((true)|(false))\\\\s*\\\\)\");\r\n\r\n    public static NamedStyle matchStyle(String text) {\r\n        NamedStyle style = null;\r\n        String styleName = null;\r\n        if (text != null) {\r\n            Matcher matcher = stylePattern.matcher(text);\r\n            boolean found = matcher.find();\r\n            if (found && matcher.groupCount() == 1) {\r\n                styleName = matcher.group(1);\r\n                style = new NamedStyle(styleName, false);\r\n            } else {\r\n                matcher = styleWithParamPattern.matcher(text);\r\n                found = matcher.find();\r\n                if (found && matcher.groupCount() == 4) {\r\n                    styleName = matcher.group(1);\r\n                    String paramFlag = matcher.group(2);\r\n                    boolean flag = Boolean.parseBoolean(paramFlag);\r\n                    style = new NamedStyle(styleName, flag);\r\n                }\r\n            }\r\n        }\r\n        return style;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/5_templateit/src/main/java/org/templateit/OpMatcherTest1.java",
		"test_prompt": "// OpMatcherTest1.java\npackage org.templateit;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link OpMatcher}.\n* It contains ten unit test cases for the {@link OpMatcher#matchTemplateEnd(String)} method.\n*/\nclass OpMatcherTest1 {"
	},
	{
		"original_code": "// OpMatcher.java\n/*\r\n * Copyright(C) 2008-2009 Dmitriy Kumshayev. <dq@mail.com>\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\npackage org.templateit;\r\n\r\nimport java.util.regex.Matcher;\r\nimport java.util.regex.Pattern;\r\n\r\nfinal class OpMatcher {\r\n\r\n    private static final String TBEGIN1 = \"@template_begin\";\r\n\r\n    private static final String TBEGIN2 = \"@tbegin\";\r\n\r\n    private static final String beginParams = \"\\\\s*\\\\(\\\\s*((\\\\p{Alpha}\\\\w*)(\\\\s*,\\\\s*\\\\p{Alpha}\\\\w*)*)\\\\s*\\\\)\";\r\n\r\n    private static final Pattern templateBeginPattern1 = Pattern.compile(TBEGIN1 + beginParams);\r\n\r\n    private static final Pattern templateBeginPattern2 = Pattern.compile(TBEGIN2 + beginParams);\r\n\r\n    /**\r\n     * Match a string with\r\n     * <em>#template_begin(name, param1, param2, ..., paramN)</em> instruction.\r\n     *\r\n     * @param text\r\n     *          being matched\r\n     *\r\n     * @return if matched, return a String array, where the first element is\r\n     */\r\n    public static String[] matchTemplateBegin(String text) {\r\n        String[] names = null;\r\n        if (text != null) {\r\n            Matcher m = null;\r\n            if (text.indexOf(TBEGIN1) != -1) {\r\n                m = templateBeginPattern1.matcher(text);\r\n            } else if (text.indexOf(TBEGIN2) != -1) {\r\n                m = templateBeginPattern2.matcher(text);\r\n            }\r\n            if (m != null) {\r\n                if (m.groupCount() == 3) {\r\n                    boolean matches = m.find();\r\n                    if (matches) {\r\n                        String group = m.group(1);\r\n                        if (group != null) {\r\n                            names = group.split(\"\\\\s*,\\\\s*\");\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return names;\r\n    }\r\n\r\n    public static boolean matchTemplateEnd(String text) {\r\n        return text != null && (text.indexOf(\"@template_end\") != -1) || (text.indexOf(\"@tend\") != -1);\r\n    }\r\n\r\n    private static final Pattern parameterNumberPattern = Pattern.compile(\"#([1-9]\\\\p{Digit}*)\");\r\n\r\n    private static final Pattern parameterNamePattern = Pattern.compile(\"#(\\\\p{Alpha}\\\\w*)\");\r\n\r\n    public static String matchTemplateParameter(String text) {\r\n        String parameterName = null;\r\n        if (text != null) {\r\n            if (text.indexOf(\"#\") != -1) {\r\n                Matcher fieldNameMatcher = parameterNamePattern.matcher(text);\r\n                boolean found = fieldNameMatcher.find();\r\n                if (found && fieldNameMatcher.groupCount() == 1) {\r\n                    parameterName = fieldNameMatcher.group(1);\r\n                } else {\r\n                    Matcher fieldNumberMatcher = parameterNumberPattern.matcher(text);\r\n                    found = fieldNumberMatcher.find();\r\n                    if (found && fieldNumberMatcher.groupCount() == 1) {\r\n                        parameterName = fieldNumberMatcher.group(1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return parameterName;\r\n    }\r\n\r\n    private static final Pattern templateNamePattern = Pattern.compile(\"\\\\p{Alpha}\\\\w*\");\r\n\r\n    public static boolean matchTemplateName(String text) {\r\n        if (text != null) {\r\n            return templateNamePattern.matcher(text).matches();\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    private static final Pattern stylePattern = Pattern.compile(\"@style\\\\s*\\\\(\\\\s*(\\\\p{Alpha}\\\\w*)\\\\s*\\\\)\");\r\n\r\n    private static final Pattern styleWithParamPattern = Pattern.compile(\"@style\\\\s*\\\\(\\\\s*(\\\\p{Alpha}\\\\w*)\\\\s*,\\\\s*((true)|(false))\\\\s*\\\\)\");\r\n\r\n    public static NamedStyle matchStyle(String text) {\r\n        NamedStyle style = null;\r\n        String styleName = null;\r\n        if (text != null) {\r\n            Matcher matcher = stylePattern.matcher(text);\r\n            boolean found = matcher.find();\r\n            if (found && matcher.groupCount() == 1) {\r\n                styleName = matcher.group(1);\r\n                style = new NamedStyle(styleName, false);\r\n            } else {\r\n                matcher = styleWithParamPattern.matcher(text);\r\n                found = matcher.find();\r\n                if (found && matcher.groupCount() == 4) {\r\n                    styleName = matcher.group(1);\r\n                    String paramFlag = matcher.group(2);\r\n                    boolean flag = Boolean.parseBoolean(paramFlag);\r\n                    style = new NamedStyle(styleName, flag);\r\n                }\r\n            }\r\n        }\r\n        return style;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/5_templateit/src/main/java/org/templateit/OpMatcherTest2.java",
		"test_prompt": "// OpMatcherTest2.java\npackage org.templateit;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link OpMatcher}.\n* It contains ten unit test cases for the {@link OpMatcher#matchTemplateParameter(String)} method.\n*/\nclass OpMatcherTest2 {"
	},
	{
		"original_code": "// OpMatcher.java\n/*\r\n * Copyright(C) 2008-2009 Dmitriy Kumshayev. <dq@mail.com>\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\npackage org.templateit;\r\n\r\nimport java.util.regex.Matcher;\r\nimport java.util.regex.Pattern;\r\n\r\nfinal class OpMatcher {\r\n\r\n    private static final String TBEGIN1 = \"@template_begin\";\r\n\r\n    private static final String TBEGIN2 = \"@tbegin\";\r\n\r\n    private static final String beginParams = \"\\\\s*\\\\(\\\\s*((\\\\p{Alpha}\\\\w*)(\\\\s*,\\\\s*\\\\p{Alpha}\\\\w*)*)\\\\s*\\\\)\";\r\n\r\n    private static final Pattern templateBeginPattern1 = Pattern.compile(TBEGIN1 + beginParams);\r\n\r\n    private static final Pattern templateBeginPattern2 = Pattern.compile(TBEGIN2 + beginParams);\r\n\r\n    /**\r\n     * Match a string with\r\n     * <em>#template_begin(name, param1, param2, ..., paramN)</em> instruction.\r\n     *\r\n     * @param text\r\n     *          being matched\r\n     *\r\n     * @return if matched, return a String array, where the first element is\r\n     */\r\n    public static String[] matchTemplateBegin(String text) {\r\n        String[] names = null;\r\n        if (text != null) {\r\n            Matcher m = null;\r\n            if (text.indexOf(TBEGIN1) != -1) {\r\n                m = templateBeginPattern1.matcher(text);\r\n            } else if (text.indexOf(TBEGIN2) != -1) {\r\n                m = templateBeginPattern2.matcher(text);\r\n            }\r\n            if (m != null) {\r\n                if (m.groupCount() == 3) {\r\n                    boolean matches = m.find();\r\n                    if (matches) {\r\n                        String group = m.group(1);\r\n                        if (group != null) {\r\n                            names = group.split(\"\\\\s*,\\\\s*\");\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return names;\r\n    }\r\n\r\n    public static boolean matchTemplateEnd(String text) {\r\n        return text != null && (text.indexOf(\"@template_end\") != -1) || (text.indexOf(\"@tend\") != -1);\r\n    }\r\n\r\n    private static final Pattern parameterNumberPattern = Pattern.compile(\"#([1-9]\\\\p{Digit}*)\");\r\n\r\n    private static final Pattern parameterNamePattern = Pattern.compile(\"#(\\\\p{Alpha}\\\\w*)\");\r\n\r\n    public static String matchTemplateParameter(String text) {\r\n        String parameterName = null;\r\n        if (text != null) {\r\n            if (text.indexOf(\"#\") != -1) {\r\n                Matcher fieldNameMatcher = parameterNamePattern.matcher(text);\r\n                boolean found = fieldNameMatcher.find();\r\n                if (found && fieldNameMatcher.groupCount() == 1) {\r\n                    parameterName = fieldNameMatcher.group(1);\r\n                } else {\r\n                    Matcher fieldNumberMatcher = parameterNumberPattern.matcher(text);\r\n                    found = fieldNumberMatcher.find();\r\n                    if (found && fieldNumberMatcher.groupCount() == 1) {\r\n                        parameterName = fieldNumberMatcher.group(1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return parameterName;\r\n    }\r\n\r\n    private static final Pattern templateNamePattern = Pattern.compile(\"\\\\p{Alpha}\\\\w*\");\r\n\r\n    public static boolean matchTemplateName(String text) {\r\n        if (text != null) {\r\n            return templateNamePattern.matcher(text).matches();\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    private static final Pattern stylePattern = Pattern.compile(\"@style\\\\s*\\\\(\\\\s*(\\\\p{Alpha}\\\\w*)\\\\s*\\\\)\");\r\n\r\n    private static final Pattern styleWithParamPattern = Pattern.compile(\"@style\\\\s*\\\\(\\\\s*(\\\\p{Alpha}\\\\w*)\\\\s*,\\\\s*((true)|(false))\\\\s*\\\\)\");\r\n\r\n    public static NamedStyle matchStyle(String text) {\r\n        NamedStyle style = null;\r\n        String styleName = null;\r\n        if (text != null) {\r\n            Matcher matcher = stylePattern.matcher(text);\r\n            boolean found = matcher.find();\r\n            if (found && matcher.groupCount() == 1) {\r\n                styleName = matcher.group(1);\r\n                style = new NamedStyle(styleName, false);\r\n            } else {\r\n                matcher = styleWithParamPattern.matcher(text);\r\n                found = matcher.find();\r\n                if (found && matcher.groupCount() == 4) {\r\n                    styleName = matcher.group(1);\r\n                    String paramFlag = matcher.group(2);\r\n                    boolean flag = Boolean.parseBoolean(paramFlag);\r\n                    style = new NamedStyle(styleName, flag);\r\n                }\r\n            }\r\n        }\r\n        return style;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/5_templateit/src/main/java/org/templateit/OpMatcherTest3.java",
		"test_prompt": "// OpMatcherTest3.java\npackage org.templateit;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link OpMatcher}.\n* It contains ten unit test cases for the {@link OpMatcher#matchTemplateName(String)} method.\n*/\nclass OpMatcherTest3 {"
	},
	{
		"original_code": "// OpMatcher.java\n/*\r\n * Copyright(C) 2008-2009 Dmitriy Kumshayev. <dq@mail.com>\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\npackage org.templateit;\r\n\r\nimport java.util.regex.Matcher;\r\nimport java.util.regex.Pattern;\r\n\r\nfinal class OpMatcher {\r\n\r\n    private static final String TBEGIN1 = \"@template_begin\";\r\n\r\n    private static final String TBEGIN2 = \"@tbegin\";\r\n\r\n    private static final String beginParams = \"\\\\s*\\\\(\\\\s*((\\\\p{Alpha}\\\\w*)(\\\\s*,\\\\s*\\\\p{Alpha}\\\\w*)*)\\\\s*\\\\)\";\r\n\r\n    private static final Pattern templateBeginPattern1 = Pattern.compile(TBEGIN1 + beginParams);\r\n\r\n    private static final Pattern templateBeginPattern2 = Pattern.compile(TBEGIN2 + beginParams);\r\n\r\n    /**\r\n     * Match a string with\r\n     * <em>#template_begin(name, param1, param2, ..., paramN)</em> instruction.\r\n     *\r\n     * @param text\r\n     *          being matched\r\n     *\r\n     * @return if matched, return a String array, where the first element is\r\n     */\r\n    public static String[] matchTemplateBegin(String text) {\r\n        String[] names = null;\r\n        if (text != null) {\r\n            Matcher m = null;\r\n            if (text.indexOf(TBEGIN1) != -1) {\r\n                m = templateBeginPattern1.matcher(text);\r\n            } else if (text.indexOf(TBEGIN2) != -1) {\r\n                m = templateBeginPattern2.matcher(text);\r\n            }\r\n            if (m != null) {\r\n                if (m.groupCount() == 3) {\r\n                    boolean matches = m.find();\r\n                    if (matches) {\r\n                        String group = m.group(1);\r\n                        if (group != null) {\r\n                            names = group.split(\"\\\\s*,\\\\s*\");\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return names;\r\n    }\r\n\r\n    public static boolean matchTemplateEnd(String text) {\r\n        return text != null && (text.indexOf(\"@template_end\") != -1) || (text.indexOf(\"@tend\") != -1);\r\n    }\r\n\r\n    private static final Pattern parameterNumberPattern = Pattern.compile(\"#([1-9]\\\\p{Digit}*)\");\r\n\r\n    private static final Pattern parameterNamePattern = Pattern.compile(\"#(\\\\p{Alpha}\\\\w*)\");\r\n\r\n    public static String matchTemplateParameter(String text) {\r\n        String parameterName = null;\r\n        if (text != null) {\r\n            if (text.indexOf(\"#\") != -1) {\r\n                Matcher fieldNameMatcher = parameterNamePattern.matcher(text);\r\n                boolean found = fieldNameMatcher.find();\r\n                if (found && fieldNameMatcher.groupCount() == 1) {\r\n                    parameterName = fieldNameMatcher.group(1);\r\n                } else {\r\n                    Matcher fieldNumberMatcher = parameterNumberPattern.matcher(text);\r\n                    found = fieldNumberMatcher.find();\r\n                    if (found && fieldNumberMatcher.groupCount() == 1) {\r\n                        parameterName = fieldNumberMatcher.group(1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return parameterName;\r\n    }\r\n\r\n    private static final Pattern templateNamePattern = Pattern.compile(\"\\\\p{Alpha}\\\\w*\");\r\n\r\n    public static boolean matchTemplateName(String text) {\r\n        if (text != null) {\r\n            return templateNamePattern.matcher(text).matches();\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    private static final Pattern stylePattern = Pattern.compile(\"@style\\\\s*\\\\(\\\\s*(\\\\p{Alpha}\\\\w*)\\\\s*\\\\)\");\r\n\r\n    private static final Pattern styleWithParamPattern = Pattern.compile(\"@style\\\\s*\\\\(\\\\s*(\\\\p{Alpha}\\\\w*)\\\\s*,\\\\s*((true)|(false))\\\\s*\\\\)\");\r\n\r\n    public static NamedStyle matchStyle(String text) {\r\n        NamedStyle style = null;\r\n        String styleName = null;\r\n        if (text != null) {\r\n            Matcher matcher = stylePattern.matcher(text);\r\n            boolean found = matcher.find();\r\n            if (found && matcher.groupCount() == 1) {\r\n                styleName = matcher.group(1);\r\n                style = new NamedStyle(styleName, false);\r\n            } else {\r\n                matcher = styleWithParamPattern.matcher(text);\r\n                found = matcher.find();\r\n                if (found && matcher.groupCount() == 4) {\r\n                    styleName = matcher.group(1);\r\n                    String paramFlag = matcher.group(2);\r\n                    boolean flag = Boolean.parseBoolean(paramFlag);\r\n                    style = new NamedStyle(styleName, flag);\r\n                }\r\n            }\r\n        }\r\n        return style;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/5_templateit/src/main/java/org/templateit/OpMatcherTest4.java",
		"test_prompt": "// OpMatcherTest4.java\npackage org.templateit;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link OpMatcher}.\n* It contains ten unit test cases for the {@link OpMatcher#matchStyle(String)} method.\n*/\nclass OpMatcherTest4 {"
	},
	{
		"original_code": "// HSSFDataFormat.java\n/* ====================================================================\n   Licensed to the Apache Software Foundation (ASF) under one or more\n   contributor license agreements.  See the NOTICE file distributed with\n   this work for additional information regarding copyright ownership.\n   The ASF licenses this file to You under the Apache License, Version 2.0\n   (the \"License\"); you may not use this file except in compliance with\n   the License.  You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n==================================================================== */\n/*\n * HSSFDataFormat.java\n *\n * Created on December 18, 2001, 12:42 PM\n */\npackage org.apache.poi.hssf.usermodel;\n\nimport org.apache.poi.hssf.model.Workbook;\nimport org.apache.poi.hssf.record.FormatRecord;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Vector;\n\n/**\n *  Utility to identify builtin formats.  Now can handle user defined data formats also.  The following is a list of the formats as\n *  returned by this class.<P>\n * <P>\n *        0, \"General\"<br>\n *        1, \"0\"<br>\n *        2, \"0.00\"<br>\n *        3, \"#,##0\"<br>\n *        4, \"#,##0.00\"<br>\n *        5, \"($#,##0_);($#,##0)\"<br>\n *        6, \"($#,##0_);[Red]($#,##0)\"<br>\n *        7, \"($#,##0.00);($#,##0.00)\"<br>\n *        8, \"($#,##0.00_);[Red]($#,##0.00)\"<br>\n *        9, \"0%\"<br>\n *        0xa, \"0.00%\"<br>\n *        0xb, \"0.00E+00\"<br>\n *        0xc, \"# ?/?\"<br>\n *        0xd, \"# ??/??\"<br>\n *        0xe, \"m/d/yy\"<br>\n *        0xf, \"d-mmm-yy\"<br>\n *        0x10, \"d-mmm\"<br>\n *        0x11, \"mmm-yy\"<br>\n *        0x12, \"h:mm AM/PM\"<br>\n *        0x13, \"h:mm:ss AM/PM\"<br>\n *        0x14, \"h:mm\"<br>\n *        0x15, \"h:mm:ss\"<br>\n *        0x16, \"m/d/yy h:mm\"<br>\n * <P>\n *        // 0x17 - 0x24 reserved for international and undocumented\n *        0x25, \"(#,##0_);(#,##0)\"<P>\n *        0x26, \"(#,##0_);[Red](#,##0)\"<P>\n *        0x27, \"(#,##0.00_);(#,##0.00)\"<P>\n *        0x28, \"(#,##0.00_);[Red](#,##0.00)\"<P>\n *        0x29, \"_(*#,##0_);_(*(#,##0);_(* \\\"-\\\"_);_(@_)\"<P>\n *        0x2a, \"_($*#,##0_);_($*(#,##0);_($* \\\"-\\\"_);_(@_)\"<P>\n *        0x2b, \"_(*#,##0.00_);_(*(#,##0.00);_(*\\\"-\\\"??_);_(@_)\"<P>\n *        0x2c, \"_($*#,##0.00_);_($*(#,##0.00);_($*\\\"-\\\"??_);_(@_)\"<P>\n *        0x2d, \"mm:ss\"<P>\n *        0x2e, \"[h]:mm:ss\"<P>\n *        0x2f, \"mm:ss.0\"<P>\n *        0x30, \"##0.0E+0\"<P>\n *        0x31, \"@\" - This is text format.<P>\n *        0x31  \"text\" - Alias for \"@\"<P>\n *\n *  @author  Andrew C. Oliver (acoliver at apache dot org)\n *  @author  Shawn M. Laubach (slaubach at apache dot org)\n */\npublic class HSSFDataFormat {\n\n    private static List builtinFormats = createBuiltinFormats();\n\n    private Vector formats = new Vector();\n\n    private Workbook workbook;\n\n    // Flag to see if need to\n    private boolean movedBuiltins = false;\n\n    // check the built in list\n    // or if the regular list\n    // has all entries.\n    /**\n     * Construncts a new data formatter.  It takes a workbook to have\n     * access to the workbooks format records.\n     * @param workbook the workbook the formats are tied to.\n     */\n    public HSSFDataFormat(Workbook workbook) {\n        this.workbook = workbook;\n        Iterator i = workbook.getFormats().iterator();\n        while (i.hasNext()) {\n            FormatRecord r = (FormatRecord) i.next();\n            if (formats.size() < r.getIndexCode() + 1) {\n                formats.setSize(r.getIndexCode() + 1);\n            }\n            formats.set(r.getIndexCode(), r.getFormatString());\n        }\n    }\n\n    private static synchronized List createBuiltinFormats() {\n        List builtinFormats = new Vector();\n        builtinFormats.add(0, \"General\");\n        builtinFormats.add(1, \"0\");\n        builtinFormats.add(2, \"0.00\");\n        builtinFormats.add(3, \"#,##0\");\n        builtinFormats.add(4, \"#,##0.00\");\n        builtinFormats.add(5, \"$#,##0_);($#,##0)\");\n        builtinFormats.add(6, \"$#,##0_);[Red]($#,##0)\");\n        builtinFormats.add(7, \"$#,##0.00_);($#,##0.00)\");\n        builtinFormats.add(8, \"$#,##0.00_);[Red]($#,##0.00)\");\n        builtinFormats.add(9, \"0%\");\n        builtinFormats.add(0xa, \"0.00%\");\n        builtinFormats.add(0xb, \"0.00E+00\");\n        builtinFormats.add(0xc, \"# ?/?\");\n        builtinFormats.add(0xd, \"# ??/??\");\n        builtinFormats.add(0xe, \"m/d/yy\");\n        builtinFormats.add(0xf, \"d-mmm-yy\");\n        builtinFormats.add(0x10, \"d-mmm\");\n        builtinFormats.add(0x11, \"mmm-yy\");\n        builtinFormats.add(0x12, \"h:mm AM/PM\");\n        builtinFormats.add(0x13, \"h:mm:ss AM/PM\");\n        builtinFormats.add(0x14, \"h:mm\");\n        builtinFormats.add(0x15, \"h:mm:ss\");\n        builtinFormats.add(0x16, \"m/d/yy h:mm\");\n        // 0x17 - 0x24 reserved for international and undocumented\n        builtinFormats.add(0x17, \"0x17\");\n        builtinFormats.add(0x18, \"0x18\");\n        builtinFormats.add(0x19, \"0x19\");\n        builtinFormats.add(0x1a, \"0x1a\");\n        builtinFormats.add(0x1b, \"0x1b\");\n        builtinFormats.add(0x1c, \"0x1c\");\n        builtinFormats.add(0x1d, \"0x1d\");\n        builtinFormats.add(0x1e, \"0x1e\");\n        builtinFormats.add(0x1f, \"0x1f\");\n        builtinFormats.add(0x20, \"0x20\");\n        builtinFormats.add(0x21, \"0x21\");\n        builtinFormats.add(0x22, \"0x22\");\n        builtinFormats.add(0x23, \"0x23\");\n        builtinFormats.add(0x24, \"0x24\");\n        // 0x17 - 0x24 reserved for international and undocumented\n        builtinFormats.add(0x25, \"#,##0_);(#,##0)\");\n        builtinFormats.add(0x26, \"#,##0_);[Red](#,##0)\");\n        builtinFormats.add(0x27, \"#,##0.00_);(#,##0.00)\");\n        builtinFormats.add(0x28, \"#,##0.00_);[Red](#,##0.00)\");\n        builtinFormats.add(0x29, \"*#,##0_);_(*(#,##0);_(* \\\"-\\\"_);_(@_)\");\n        builtinFormats.add(0x2a, \"$*#,##0_);_($*(#,##0);_($* \\\"-\\\"_);_(@_)\");\n        builtinFormats.add(0x2b, \"*#,##0.00_);_(*(#,##0.00);_(*\\\"-\\\"??_);_(@_)\");\n        builtinFormats.add(0x2c, \"_($*#,##0.00_);_($*(#,##0.00);_($*\\\"-\\\"??_);_(@_)\");\n        builtinFormats.add(0x2d, \"mm:ss\");\n        builtinFormats.add(0x2e, \"[h]:mm:ss\");\n        builtinFormats.add(0x2f, \"mm:ss.0\");\n        builtinFormats.add(0x30, \"##0.0E+0\");\n        builtinFormats.add(0x31, \"@\");\n        return builtinFormats;\n    }\n\n    public static List getBuiltinFormats() {\n        return builtinFormats;\n    }\n\n    /**\n     * get the format index that matches the given format string<p>\n     * Automatically converts \"text\" to excel's format string to represent text.\n     * @param format string matching a built in format\n     * @return index of format or -1 if undefined.\n     */\n    public static short getBuiltinFormat(String format) {\n        if (format.toUpperCase().equals(\"TEXT\"))\n            format = \"@\";\n        short retval = -1;\n        for (short k = 0; k <= 0x31; k++) {\n            String nformat = (String) builtinFormats.get(k);\n            if ((nformat != null) && nformat.equals(format)) {\n                retval = k;\n                break;\n            }\n        }\n        return retval;\n    }\n\n    /**\n     * Get the format index that matches the given format\n     *  string, creating a new format entry if required.\n     * Aliases text to the proper format as required.\n     * @param format string matching a built in format\n     * @return index of format.\n     */\n    public short getFormat(String format) {\n        ListIterator i;\n        int ind;\n        if (format.toUpperCase().equals(\"TEXT\"))\n            format = \"@\";\n        if (!movedBuiltins) {\n            i = builtinFormats.listIterator();\n            while (i.hasNext()) {\n                ind = i.nextIndex();\n                if (formats.size() < ind + 1) {\n                    formats.setSize(ind + 1);\n                }\n                formats.set(ind, i.next());\n            }\n            movedBuiltins = true;\n        }\n        i = formats.listIterator();\n        while (i.hasNext()) {\n            ind = i.nextIndex();\n            if (format.equals(i.next()))\n                return (short) ind;\n        }\n        ind = workbook.getFormat(format, true);\n        if (formats.size() <= ind)\n            formats.setSize(ind + 1);\n        formats.set(ind, format);\n        return (short) ind;\n    }\n\n    /**\n     * get the format string that matches the given format index\n     * @param index of a format\n     * @return string represented at index of format or null if there is not a  format at that index\n     */\n    public String getFormat(short index) {\n        if (movedBuiltins)\n            return (String) formats.get(index);\n        else\n            return (String) (builtinFormats.size() > index && builtinFormats.get(index) != null ? builtinFormats.get(index) : formats.get(index));\n    }\n\n    /**\n     * get the format string that matches the given format index\n     * @param index of a built in format\n     * @return string represented at index of format or null if there is not a builtin format at that index\n     * @throws ArrayOutOfBoundsException when the index exceeds the number of builtin formats.\n     */\n    public static String getBuiltinFormat(short index) {\n        return (String) builtinFormats.get(index);\n    }\n\n    /**\n     * get the number of builtin and reserved builtinFormats\n     * @return number of builtin and reserved builtinFormats\n     */\n    public static int getNumberOfBuiltinBuiltinFormats() {\n        return builtinFormats.size();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/5_templateit/src/main/java/org/apache/poi/hssf/usermodel/HSSFDataFormatTest0.java",
		"test_prompt": "// HSSFDataFormatTest0.java\n/*\n * HSSFDataFormat.java\n *\n * Created on December 18, 2001, 12:42 PM\n */\npackage org.apache.poi.hssf.usermodel;\n\nimport org.apache.poi.hssf.model.Workbook;\nimport org.apache.poi.hssf.record.FormatRecord;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HSSFDataFormat}.\n* It contains ten unit test cases for the {@link HSSFDataFormat#getBuiltinFormats()} method.\n*/\nclass HSSFDataFormatTest0 {"
	},
	{
		"original_code": "// HSSFDataFormat.java\n/* ====================================================================\n   Licensed to the Apache Software Foundation (ASF) under one or more\n   contributor license agreements.  See the NOTICE file distributed with\n   this work for additional information regarding copyright ownership.\n   The ASF licenses this file to You under the Apache License, Version 2.0\n   (the \"License\"); you may not use this file except in compliance with\n   the License.  You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n==================================================================== */\n/*\n * HSSFDataFormat.java\n *\n * Created on December 18, 2001, 12:42 PM\n */\npackage org.apache.poi.hssf.usermodel;\n\nimport org.apache.poi.hssf.model.Workbook;\nimport org.apache.poi.hssf.record.FormatRecord;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Vector;\n\n/**\n *  Utility to identify builtin formats.  Now can handle user defined data formats also.  The following is a list of the formats as\n *  returned by this class.<P>\n * <P>\n *        0, \"General\"<br>\n *        1, \"0\"<br>\n *        2, \"0.00\"<br>\n *        3, \"#,##0\"<br>\n *        4, \"#,##0.00\"<br>\n *        5, \"($#,##0_);($#,##0)\"<br>\n *        6, \"($#,##0_);[Red]($#,##0)\"<br>\n *        7, \"($#,##0.00);($#,##0.00)\"<br>\n *        8, \"($#,##0.00_);[Red]($#,##0.00)\"<br>\n *        9, \"0%\"<br>\n *        0xa, \"0.00%\"<br>\n *        0xb, \"0.00E+00\"<br>\n *        0xc, \"# ?/?\"<br>\n *        0xd, \"# ??/??\"<br>\n *        0xe, \"m/d/yy\"<br>\n *        0xf, \"d-mmm-yy\"<br>\n *        0x10, \"d-mmm\"<br>\n *        0x11, \"mmm-yy\"<br>\n *        0x12, \"h:mm AM/PM\"<br>\n *        0x13, \"h:mm:ss AM/PM\"<br>\n *        0x14, \"h:mm\"<br>\n *        0x15, \"h:mm:ss\"<br>\n *        0x16, \"m/d/yy h:mm\"<br>\n * <P>\n *        // 0x17 - 0x24 reserved for international and undocumented\n *        0x25, \"(#,##0_);(#,##0)\"<P>\n *        0x26, \"(#,##0_);[Red](#,##0)\"<P>\n *        0x27, \"(#,##0.00_);(#,##0.00)\"<P>\n *        0x28, \"(#,##0.00_);[Red](#,##0.00)\"<P>\n *        0x29, \"_(*#,##0_);_(*(#,##0);_(* \\\"-\\\"_);_(@_)\"<P>\n *        0x2a, \"_($*#,##0_);_($*(#,##0);_($* \\\"-\\\"_);_(@_)\"<P>\n *        0x2b, \"_(*#,##0.00_);_(*(#,##0.00);_(*\\\"-\\\"??_);_(@_)\"<P>\n *        0x2c, \"_($*#,##0.00_);_($*(#,##0.00);_($*\\\"-\\\"??_);_(@_)\"<P>\n *        0x2d, \"mm:ss\"<P>\n *        0x2e, \"[h]:mm:ss\"<P>\n *        0x2f, \"mm:ss.0\"<P>\n *        0x30, \"##0.0E+0\"<P>\n *        0x31, \"@\" - This is text format.<P>\n *        0x31  \"text\" - Alias for \"@\"<P>\n *\n *  @author  Andrew C. Oliver (acoliver at apache dot org)\n *  @author  Shawn M. Laubach (slaubach at apache dot org)\n */\npublic class HSSFDataFormat {\n\n    private static List builtinFormats = createBuiltinFormats();\n\n    private Vector formats = new Vector();\n\n    private Workbook workbook;\n\n    // Flag to see if need to\n    private boolean movedBuiltins = false;\n\n    // check the built in list\n    // or if the regular list\n    // has all entries.\n    /**\n     * Construncts a new data formatter.  It takes a workbook to have\n     * access to the workbooks format records.\n     * @param workbook the workbook the formats are tied to.\n     */\n    public HSSFDataFormat(Workbook workbook) {\n        this.workbook = workbook;\n        Iterator i = workbook.getFormats().iterator();\n        while (i.hasNext()) {\n            FormatRecord r = (FormatRecord) i.next();\n            if (formats.size() < r.getIndexCode() + 1) {\n                formats.setSize(r.getIndexCode() + 1);\n            }\n            formats.set(r.getIndexCode(), r.getFormatString());\n        }\n    }\n\n    private static synchronized List createBuiltinFormats() {\n        List builtinFormats = new Vector();\n        builtinFormats.add(0, \"General\");\n        builtinFormats.add(1, \"0\");\n        builtinFormats.add(2, \"0.00\");\n        builtinFormats.add(3, \"#,##0\");\n        builtinFormats.add(4, \"#,##0.00\");\n        builtinFormats.add(5, \"$#,##0_);($#,##0)\");\n        builtinFormats.add(6, \"$#,##0_);[Red]($#,##0)\");\n        builtinFormats.add(7, \"$#,##0.00_);($#,##0.00)\");\n        builtinFormats.add(8, \"$#,##0.00_);[Red]($#,##0.00)\");\n        builtinFormats.add(9, \"0%\");\n        builtinFormats.add(0xa, \"0.00%\");\n        builtinFormats.add(0xb, \"0.00E+00\");\n        builtinFormats.add(0xc, \"# ?/?\");\n        builtinFormats.add(0xd, \"# ??/??\");\n        builtinFormats.add(0xe, \"m/d/yy\");\n        builtinFormats.add(0xf, \"d-mmm-yy\");\n        builtinFormats.add(0x10, \"d-mmm\");\n        builtinFormats.add(0x11, \"mmm-yy\");\n        builtinFormats.add(0x12, \"h:mm AM/PM\");\n        builtinFormats.add(0x13, \"h:mm:ss AM/PM\");\n        builtinFormats.add(0x14, \"h:mm\");\n        builtinFormats.add(0x15, \"h:mm:ss\");\n        builtinFormats.add(0x16, \"m/d/yy h:mm\");\n        // 0x17 - 0x24 reserved for international and undocumented\n        builtinFormats.add(0x17, \"0x17\");\n        builtinFormats.add(0x18, \"0x18\");\n        builtinFormats.add(0x19, \"0x19\");\n        builtinFormats.add(0x1a, \"0x1a\");\n        builtinFormats.add(0x1b, \"0x1b\");\n        builtinFormats.add(0x1c, \"0x1c\");\n        builtinFormats.add(0x1d, \"0x1d\");\n        builtinFormats.add(0x1e, \"0x1e\");\n        builtinFormats.add(0x1f, \"0x1f\");\n        builtinFormats.add(0x20, \"0x20\");\n        builtinFormats.add(0x21, \"0x21\");\n        builtinFormats.add(0x22, \"0x22\");\n        builtinFormats.add(0x23, \"0x23\");\n        builtinFormats.add(0x24, \"0x24\");\n        // 0x17 - 0x24 reserved for international and undocumented\n        builtinFormats.add(0x25, \"#,##0_);(#,##0)\");\n        builtinFormats.add(0x26, \"#,##0_);[Red](#,##0)\");\n        builtinFormats.add(0x27, \"#,##0.00_);(#,##0.00)\");\n        builtinFormats.add(0x28, \"#,##0.00_);[Red](#,##0.00)\");\n        builtinFormats.add(0x29, \"*#,##0_);_(*(#,##0);_(* \\\"-\\\"_);_(@_)\");\n        builtinFormats.add(0x2a, \"$*#,##0_);_($*(#,##0);_($* \\\"-\\\"_);_(@_)\");\n        builtinFormats.add(0x2b, \"*#,##0.00_);_(*(#,##0.00);_(*\\\"-\\\"??_);_(@_)\");\n        builtinFormats.add(0x2c, \"_($*#,##0.00_);_($*(#,##0.00);_($*\\\"-\\\"??_);_(@_)\");\n        builtinFormats.add(0x2d, \"mm:ss\");\n        builtinFormats.add(0x2e, \"[h]:mm:ss\");\n        builtinFormats.add(0x2f, \"mm:ss.0\");\n        builtinFormats.add(0x30, \"##0.0E+0\");\n        builtinFormats.add(0x31, \"@\");\n        return builtinFormats;\n    }\n\n    public static List getBuiltinFormats() {\n        return builtinFormats;\n    }\n\n    /**\n     * get the format index that matches the given format string<p>\n     * Automatically converts \"text\" to excel's format string to represent text.\n     * @param format string matching a built in format\n     * @return index of format or -1 if undefined.\n     */\n    public static short getBuiltinFormat(String format) {\n        if (format.toUpperCase().equals(\"TEXT\"))\n            format = \"@\";\n        short retval = -1;\n        for (short k = 0; k <= 0x31; k++) {\n            String nformat = (String) builtinFormats.get(k);\n            if ((nformat != null) && nformat.equals(format)) {\n                retval = k;\n                break;\n            }\n        }\n        return retval;\n    }\n\n    /**\n     * Get the format index that matches the given format\n     *  string, creating a new format entry if required.\n     * Aliases text to the proper format as required.\n     * @param format string matching a built in format\n     * @return index of format.\n     */\n    public short getFormat(String format) {\n        ListIterator i;\n        int ind;\n        if (format.toUpperCase().equals(\"TEXT\"))\n            format = \"@\";\n        if (!movedBuiltins) {\n            i = builtinFormats.listIterator();\n            while (i.hasNext()) {\n                ind = i.nextIndex();\n                if (formats.size() < ind + 1) {\n                    formats.setSize(ind + 1);\n                }\n                formats.set(ind, i.next());\n            }\n            movedBuiltins = true;\n        }\n        i = formats.listIterator();\n        while (i.hasNext()) {\n            ind = i.nextIndex();\n            if (format.equals(i.next()))\n                return (short) ind;\n        }\n        ind = workbook.getFormat(format, true);\n        if (formats.size() <= ind)\n            formats.setSize(ind + 1);\n        formats.set(ind, format);\n        return (short) ind;\n    }\n\n    /**\n     * get the format string that matches the given format index\n     * @param index of a format\n     * @return string represented at index of format or null if there is not a  format at that index\n     */\n    public String getFormat(short index) {\n        if (movedBuiltins)\n            return (String) formats.get(index);\n        else\n            return (String) (builtinFormats.size() > index && builtinFormats.get(index) != null ? builtinFormats.get(index) : formats.get(index));\n    }\n\n    /**\n     * get the format string that matches the given format index\n     * @param index of a built in format\n     * @return string represented at index of format or null if there is not a builtin format at that index\n     * @throws ArrayOutOfBoundsException when the index exceeds the number of builtin formats.\n     */\n    public static String getBuiltinFormat(short index) {\n        return (String) builtinFormats.get(index);\n    }\n\n    /**\n     * get the number of builtin and reserved builtinFormats\n     * @return number of builtin and reserved builtinFormats\n     */\n    public static int getNumberOfBuiltinBuiltinFormats() {\n        return builtinFormats.size();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/5_templateit/src/main/java/org/apache/poi/hssf/usermodel/HSSFDataFormatTest1.java",
		"test_prompt": "// HSSFDataFormatTest1.java\n/*\n * HSSFDataFormat.java\n *\n * Created on December 18, 2001, 12:42 PM\n */\npackage org.apache.poi.hssf.usermodel;\n\nimport org.apache.poi.hssf.model.Workbook;\nimport org.apache.poi.hssf.record.FormatRecord;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HSSFDataFormat}.\n* It contains ten unit test cases for the {@link HSSFDataFormat#getBuiltinFormat(String)} method.\n*/\nclass HSSFDataFormatTest1 {"
	},
	{
		"original_code": "// HSSFDataFormat.java\n/* ====================================================================\n   Licensed to the Apache Software Foundation (ASF) under one or more\n   contributor license agreements.  See the NOTICE file distributed with\n   this work for additional information regarding copyright ownership.\n   The ASF licenses this file to You under the Apache License, Version 2.0\n   (the \"License\"); you may not use this file except in compliance with\n   the License.  You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n==================================================================== */\n/*\n * HSSFDataFormat.java\n *\n * Created on December 18, 2001, 12:42 PM\n */\npackage org.apache.poi.hssf.usermodel;\n\nimport org.apache.poi.hssf.model.Workbook;\nimport org.apache.poi.hssf.record.FormatRecord;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Vector;\n\n/**\n *  Utility to identify builtin formats.  Now can handle user defined data formats also.  The following is a list of the formats as\n *  returned by this class.<P>\n * <P>\n *        0, \"General\"<br>\n *        1, \"0\"<br>\n *        2, \"0.00\"<br>\n *        3, \"#,##0\"<br>\n *        4, \"#,##0.00\"<br>\n *        5, \"($#,##0_);($#,##0)\"<br>\n *        6, \"($#,##0_);[Red]($#,##0)\"<br>\n *        7, \"($#,##0.00);($#,##0.00)\"<br>\n *        8, \"($#,##0.00_);[Red]($#,##0.00)\"<br>\n *        9, \"0%\"<br>\n *        0xa, \"0.00%\"<br>\n *        0xb, \"0.00E+00\"<br>\n *        0xc, \"# ?/?\"<br>\n *        0xd, \"# ??/??\"<br>\n *        0xe, \"m/d/yy\"<br>\n *        0xf, \"d-mmm-yy\"<br>\n *        0x10, \"d-mmm\"<br>\n *        0x11, \"mmm-yy\"<br>\n *        0x12, \"h:mm AM/PM\"<br>\n *        0x13, \"h:mm:ss AM/PM\"<br>\n *        0x14, \"h:mm\"<br>\n *        0x15, \"h:mm:ss\"<br>\n *        0x16, \"m/d/yy h:mm\"<br>\n * <P>\n *        // 0x17 - 0x24 reserved for international and undocumented\n *        0x25, \"(#,##0_);(#,##0)\"<P>\n *        0x26, \"(#,##0_);[Red](#,##0)\"<P>\n *        0x27, \"(#,##0.00_);(#,##0.00)\"<P>\n *        0x28, \"(#,##0.00_);[Red](#,##0.00)\"<P>\n *        0x29, \"_(*#,##0_);_(*(#,##0);_(* \\\"-\\\"_);_(@_)\"<P>\n *        0x2a, \"_($*#,##0_);_($*(#,##0);_($* \\\"-\\\"_);_(@_)\"<P>\n *        0x2b, \"_(*#,##0.00_);_(*(#,##0.00);_(*\\\"-\\\"??_);_(@_)\"<P>\n *        0x2c, \"_($*#,##0.00_);_($*(#,##0.00);_($*\\\"-\\\"??_);_(@_)\"<P>\n *        0x2d, \"mm:ss\"<P>\n *        0x2e, \"[h]:mm:ss\"<P>\n *        0x2f, \"mm:ss.0\"<P>\n *        0x30, \"##0.0E+0\"<P>\n *        0x31, \"@\" - This is text format.<P>\n *        0x31  \"text\" - Alias for \"@\"<P>\n *\n *  @author  Andrew C. Oliver (acoliver at apache dot org)\n *  @author  Shawn M. Laubach (slaubach at apache dot org)\n */\npublic class HSSFDataFormat {\n\n    private static List builtinFormats = createBuiltinFormats();\n\n    private Vector formats = new Vector();\n\n    private Workbook workbook;\n\n    // Flag to see if need to\n    private boolean movedBuiltins = false;\n\n    // check the built in list\n    // or if the regular list\n    // has all entries.\n    /**\n     * Construncts a new data formatter.  It takes a workbook to have\n     * access to the workbooks format records.\n     * @param workbook the workbook the formats are tied to.\n     */\n    public HSSFDataFormat(Workbook workbook) {\n        this.workbook = workbook;\n        Iterator i = workbook.getFormats().iterator();\n        while (i.hasNext()) {\n            FormatRecord r = (FormatRecord) i.next();\n            if (formats.size() < r.getIndexCode() + 1) {\n                formats.setSize(r.getIndexCode() + 1);\n            }\n            formats.set(r.getIndexCode(), r.getFormatString());\n        }\n    }\n\n    private static synchronized List createBuiltinFormats() {\n        List builtinFormats = new Vector();\n        builtinFormats.add(0, \"General\");\n        builtinFormats.add(1, \"0\");\n        builtinFormats.add(2, \"0.00\");\n        builtinFormats.add(3, \"#,##0\");\n        builtinFormats.add(4, \"#,##0.00\");\n        builtinFormats.add(5, \"$#,##0_);($#,##0)\");\n        builtinFormats.add(6, \"$#,##0_);[Red]($#,##0)\");\n        builtinFormats.add(7, \"$#,##0.00_);($#,##0.00)\");\n        builtinFormats.add(8, \"$#,##0.00_);[Red]($#,##0.00)\");\n        builtinFormats.add(9, \"0%\");\n        builtinFormats.add(0xa, \"0.00%\");\n        builtinFormats.add(0xb, \"0.00E+00\");\n        builtinFormats.add(0xc, \"# ?/?\");\n        builtinFormats.add(0xd, \"# ??/??\");\n        builtinFormats.add(0xe, \"m/d/yy\");\n        builtinFormats.add(0xf, \"d-mmm-yy\");\n        builtinFormats.add(0x10, \"d-mmm\");\n        builtinFormats.add(0x11, \"mmm-yy\");\n        builtinFormats.add(0x12, \"h:mm AM/PM\");\n        builtinFormats.add(0x13, \"h:mm:ss AM/PM\");\n        builtinFormats.add(0x14, \"h:mm\");\n        builtinFormats.add(0x15, \"h:mm:ss\");\n        builtinFormats.add(0x16, \"m/d/yy h:mm\");\n        // 0x17 - 0x24 reserved for international and undocumented\n        builtinFormats.add(0x17, \"0x17\");\n        builtinFormats.add(0x18, \"0x18\");\n        builtinFormats.add(0x19, \"0x19\");\n        builtinFormats.add(0x1a, \"0x1a\");\n        builtinFormats.add(0x1b, \"0x1b\");\n        builtinFormats.add(0x1c, \"0x1c\");\n        builtinFormats.add(0x1d, \"0x1d\");\n        builtinFormats.add(0x1e, \"0x1e\");\n        builtinFormats.add(0x1f, \"0x1f\");\n        builtinFormats.add(0x20, \"0x20\");\n        builtinFormats.add(0x21, \"0x21\");\n        builtinFormats.add(0x22, \"0x22\");\n        builtinFormats.add(0x23, \"0x23\");\n        builtinFormats.add(0x24, \"0x24\");\n        // 0x17 - 0x24 reserved for international and undocumented\n        builtinFormats.add(0x25, \"#,##0_);(#,##0)\");\n        builtinFormats.add(0x26, \"#,##0_);[Red](#,##0)\");\n        builtinFormats.add(0x27, \"#,##0.00_);(#,##0.00)\");\n        builtinFormats.add(0x28, \"#,##0.00_);[Red](#,##0.00)\");\n        builtinFormats.add(0x29, \"*#,##0_);_(*(#,##0);_(* \\\"-\\\"_);_(@_)\");\n        builtinFormats.add(0x2a, \"$*#,##0_);_($*(#,##0);_($* \\\"-\\\"_);_(@_)\");\n        builtinFormats.add(0x2b, \"*#,##0.00_);_(*(#,##0.00);_(*\\\"-\\\"??_);_(@_)\");\n        builtinFormats.add(0x2c, \"_($*#,##0.00_);_($*(#,##0.00);_($*\\\"-\\\"??_);_(@_)\");\n        builtinFormats.add(0x2d, \"mm:ss\");\n        builtinFormats.add(0x2e, \"[h]:mm:ss\");\n        builtinFormats.add(0x2f, \"mm:ss.0\");\n        builtinFormats.add(0x30, \"##0.0E+0\");\n        builtinFormats.add(0x31, \"@\");\n        return builtinFormats;\n    }\n\n    public static List getBuiltinFormats() {\n        return builtinFormats;\n    }\n\n    /**\n     * get the format index that matches the given format string<p>\n     * Automatically converts \"text\" to excel's format string to represent text.\n     * @param format string matching a built in format\n     * @return index of format or -1 if undefined.\n     */\n    public static short getBuiltinFormat(String format) {\n        if (format.toUpperCase().equals(\"TEXT\"))\n            format = \"@\";\n        short retval = -1;\n        for (short k = 0; k <= 0x31; k++) {\n            String nformat = (String) builtinFormats.get(k);\n            if ((nformat != null) && nformat.equals(format)) {\n                retval = k;\n                break;\n            }\n        }\n        return retval;\n    }\n\n    /**\n     * Get the format index that matches the given format\n     *  string, creating a new format entry if required.\n     * Aliases text to the proper format as required.\n     * @param format string matching a built in format\n     * @return index of format.\n     */\n    public short getFormat(String format) {\n        ListIterator i;\n        int ind;\n        if (format.toUpperCase().equals(\"TEXT\"))\n            format = \"@\";\n        if (!movedBuiltins) {\n            i = builtinFormats.listIterator();\n            while (i.hasNext()) {\n                ind = i.nextIndex();\n                if (formats.size() < ind + 1) {\n                    formats.setSize(ind + 1);\n                }\n                formats.set(ind, i.next());\n            }\n            movedBuiltins = true;\n        }\n        i = formats.listIterator();\n        while (i.hasNext()) {\n            ind = i.nextIndex();\n            if (format.equals(i.next()))\n                return (short) ind;\n        }\n        ind = workbook.getFormat(format, true);\n        if (formats.size() <= ind)\n            formats.setSize(ind + 1);\n        formats.set(ind, format);\n        return (short) ind;\n    }\n\n    /**\n     * get the format string that matches the given format index\n     * @param index of a format\n     * @return string represented at index of format or null if there is not a  format at that index\n     */\n    public String getFormat(short index) {\n        if (movedBuiltins)\n            return (String) formats.get(index);\n        else\n            return (String) (builtinFormats.size() > index && builtinFormats.get(index) != null ? builtinFormats.get(index) : formats.get(index));\n    }\n\n    /**\n     * get the format string that matches the given format index\n     * @param index of a built in format\n     * @return string represented at index of format or null if there is not a builtin format at that index\n     * @throws ArrayOutOfBoundsException when the index exceeds the number of builtin formats.\n     */\n    public static String getBuiltinFormat(short index) {\n        return (String) builtinFormats.get(index);\n    }\n\n    /**\n     * get the number of builtin and reserved builtinFormats\n     * @return number of builtin and reserved builtinFormats\n     */\n    public static int getNumberOfBuiltinBuiltinFormats() {\n        return builtinFormats.size();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/5_templateit/src/main/java/org/apache/poi/hssf/usermodel/HSSFDataFormatTest2.java",
		"test_prompt": "// HSSFDataFormatTest2.java\n/*\n * HSSFDataFormat.java\n *\n * Created on December 18, 2001, 12:42 PM\n */\npackage org.apache.poi.hssf.usermodel;\n\nimport org.apache.poi.hssf.model.Workbook;\nimport org.apache.poi.hssf.record.FormatRecord;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HSSFDataFormat}.\n* It contains ten unit test cases for the {@link HSSFDataFormat#getBuiltinFormat(short)} method.\n*/\nclass HSSFDataFormatTest2 {"
	},
	{
		"original_code": "// HSSFDataFormat.java\n/* ====================================================================\n   Licensed to the Apache Software Foundation (ASF) under one or more\n   contributor license agreements.  See the NOTICE file distributed with\n   this work for additional information regarding copyright ownership.\n   The ASF licenses this file to You under the Apache License, Version 2.0\n   (the \"License\"); you may not use this file except in compliance with\n   the License.  You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n==================================================================== */\n/*\n * HSSFDataFormat.java\n *\n * Created on December 18, 2001, 12:42 PM\n */\npackage org.apache.poi.hssf.usermodel;\n\nimport org.apache.poi.hssf.model.Workbook;\nimport org.apache.poi.hssf.record.FormatRecord;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Vector;\n\n/**\n *  Utility to identify builtin formats.  Now can handle user defined data formats also.  The following is a list of the formats as\n *  returned by this class.<P>\n * <P>\n *        0, \"General\"<br>\n *        1, \"0\"<br>\n *        2, \"0.00\"<br>\n *        3, \"#,##0\"<br>\n *        4, \"#,##0.00\"<br>\n *        5, \"($#,##0_);($#,##0)\"<br>\n *        6, \"($#,##0_);[Red]($#,##0)\"<br>\n *        7, \"($#,##0.00);($#,##0.00)\"<br>\n *        8, \"($#,##0.00_);[Red]($#,##0.00)\"<br>\n *        9, \"0%\"<br>\n *        0xa, \"0.00%\"<br>\n *        0xb, \"0.00E+00\"<br>\n *        0xc, \"# ?/?\"<br>\n *        0xd, \"# ??/??\"<br>\n *        0xe, \"m/d/yy\"<br>\n *        0xf, \"d-mmm-yy\"<br>\n *        0x10, \"d-mmm\"<br>\n *        0x11, \"mmm-yy\"<br>\n *        0x12, \"h:mm AM/PM\"<br>\n *        0x13, \"h:mm:ss AM/PM\"<br>\n *        0x14, \"h:mm\"<br>\n *        0x15, \"h:mm:ss\"<br>\n *        0x16, \"m/d/yy h:mm\"<br>\n * <P>\n *        // 0x17 - 0x24 reserved for international and undocumented\n *        0x25, \"(#,##0_);(#,##0)\"<P>\n *        0x26, \"(#,##0_);[Red](#,##0)\"<P>\n *        0x27, \"(#,##0.00_);(#,##0.00)\"<P>\n *        0x28, \"(#,##0.00_);[Red](#,##0.00)\"<P>\n *        0x29, \"_(*#,##0_);_(*(#,##0);_(* \\\"-\\\"_);_(@_)\"<P>\n *        0x2a, \"_($*#,##0_);_($*(#,##0);_($* \\\"-\\\"_);_(@_)\"<P>\n *        0x2b, \"_(*#,##0.00_);_(*(#,##0.00);_(*\\\"-\\\"??_);_(@_)\"<P>\n *        0x2c, \"_($*#,##0.00_);_($*(#,##0.00);_($*\\\"-\\\"??_);_(@_)\"<P>\n *        0x2d, \"mm:ss\"<P>\n *        0x2e, \"[h]:mm:ss\"<P>\n *        0x2f, \"mm:ss.0\"<P>\n *        0x30, \"##0.0E+0\"<P>\n *        0x31, \"@\" - This is text format.<P>\n *        0x31  \"text\" - Alias for \"@\"<P>\n *\n *  @author  Andrew C. Oliver (acoliver at apache dot org)\n *  @author  Shawn M. Laubach (slaubach at apache dot org)\n */\npublic class HSSFDataFormat {\n\n    private static List builtinFormats = createBuiltinFormats();\n\n    private Vector formats = new Vector();\n\n    private Workbook workbook;\n\n    // Flag to see if need to\n    private boolean movedBuiltins = false;\n\n    // check the built in list\n    // or if the regular list\n    // has all entries.\n    /**\n     * Construncts a new data formatter.  It takes a workbook to have\n     * access to the workbooks format records.\n     * @param workbook the workbook the formats are tied to.\n     */\n    public HSSFDataFormat(Workbook workbook) {\n        this.workbook = workbook;\n        Iterator i = workbook.getFormats().iterator();\n        while (i.hasNext()) {\n            FormatRecord r = (FormatRecord) i.next();\n            if (formats.size() < r.getIndexCode() + 1) {\n                formats.setSize(r.getIndexCode() + 1);\n            }\n            formats.set(r.getIndexCode(), r.getFormatString());\n        }\n    }\n\n    private static synchronized List createBuiltinFormats() {\n        List builtinFormats = new Vector();\n        builtinFormats.add(0, \"General\");\n        builtinFormats.add(1, \"0\");\n        builtinFormats.add(2, \"0.00\");\n        builtinFormats.add(3, \"#,##0\");\n        builtinFormats.add(4, \"#,##0.00\");\n        builtinFormats.add(5, \"$#,##0_);($#,##0)\");\n        builtinFormats.add(6, \"$#,##0_);[Red]($#,##0)\");\n        builtinFormats.add(7, \"$#,##0.00_);($#,##0.00)\");\n        builtinFormats.add(8, \"$#,##0.00_);[Red]($#,##0.00)\");\n        builtinFormats.add(9, \"0%\");\n        builtinFormats.add(0xa, \"0.00%\");\n        builtinFormats.add(0xb, \"0.00E+00\");\n        builtinFormats.add(0xc, \"# ?/?\");\n        builtinFormats.add(0xd, \"# ??/??\");\n        builtinFormats.add(0xe, \"m/d/yy\");\n        builtinFormats.add(0xf, \"d-mmm-yy\");\n        builtinFormats.add(0x10, \"d-mmm\");\n        builtinFormats.add(0x11, \"mmm-yy\");\n        builtinFormats.add(0x12, \"h:mm AM/PM\");\n        builtinFormats.add(0x13, \"h:mm:ss AM/PM\");\n        builtinFormats.add(0x14, \"h:mm\");\n        builtinFormats.add(0x15, \"h:mm:ss\");\n        builtinFormats.add(0x16, \"m/d/yy h:mm\");\n        // 0x17 - 0x24 reserved for international and undocumented\n        builtinFormats.add(0x17, \"0x17\");\n        builtinFormats.add(0x18, \"0x18\");\n        builtinFormats.add(0x19, \"0x19\");\n        builtinFormats.add(0x1a, \"0x1a\");\n        builtinFormats.add(0x1b, \"0x1b\");\n        builtinFormats.add(0x1c, \"0x1c\");\n        builtinFormats.add(0x1d, \"0x1d\");\n        builtinFormats.add(0x1e, \"0x1e\");\n        builtinFormats.add(0x1f, \"0x1f\");\n        builtinFormats.add(0x20, \"0x20\");\n        builtinFormats.add(0x21, \"0x21\");\n        builtinFormats.add(0x22, \"0x22\");\n        builtinFormats.add(0x23, \"0x23\");\n        builtinFormats.add(0x24, \"0x24\");\n        // 0x17 - 0x24 reserved for international and undocumented\n        builtinFormats.add(0x25, \"#,##0_);(#,##0)\");\n        builtinFormats.add(0x26, \"#,##0_);[Red](#,##0)\");\n        builtinFormats.add(0x27, \"#,##0.00_);(#,##0.00)\");\n        builtinFormats.add(0x28, \"#,##0.00_);[Red](#,##0.00)\");\n        builtinFormats.add(0x29, \"*#,##0_);_(*(#,##0);_(* \\\"-\\\"_);_(@_)\");\n        builtinFormats.add(0x2a, \"$*#,##0_);_($*(#,##0);_($* \\\"-\\\"_);_(@_)\");\n        builtinFormats.add(0x2b, \"*#,##0.00_);_(*(#,##0.00);_(*\\\"-\\\"??_);_(@_)\");\n        builtinFormats.add(0x2c, \"_($*#,##0.00_);_($*(#,##0.00);_($*\\\"-\\\"??_);_(@_)\");\n        builtinFormats.add(0x2d, \"mm:ss\");\n        builtinFormats.add(0x2e, \"[h]:mm:ss\");\n        builtinFormats.add(0x2f, \"mm:ss.0\");\n        builtinFormats.add(0x30, \"##0.0E+0\");\n        builtinFormats.add(0x31, \"@\");\n        return builtinFormats;\n    }\n\n    public static List getBuiltinFormats() {\n        return builtinFormats;\n    }\n\n    /**\n     * get the format index that matches the given format string<p>\n     * Automatically converts \"text\" to excel's format string to represent text.\n     * @param format string matching a built in format\n     * @return index of format or -1 if undefined.\n     */\n    public static short getBuiltinFormat(String format) {\n        if (format.toUpperCase().equals(\"TEXT\"))\n            format = \"@\";\n        short retval = -1;\n        for (short k = 0; k <= 0x31; k++) {\n            String nformat = (String) builtinFormats.get(k);\n            if ((nformat != null) && nformat.equals(format)) {\n                retval = k;\n                break;\n            }\n        }\n        return retval;\n    }\n\n    /**\n     * Get the format index that matches the given format\n     *  string, creating a new format entry if required.\n     * Aliases text to the proper format as required.\n     * @param format string matching a built in format\n     * @return index of format.\n     */\n    public short getFormat(String format) {\n        ListIterator i;\n        int ind;\n        if (format.toUpperCase().equals(\"TEXT\"))\n            format = \"@\";\n        if (!movedBuiltins) {\n            i = builtinFormats.listIterator();\n            while (i.hasNext()) {\n                ind = i.nextIndex();\n                if (formats.size() < ind + 1) {\n                    formats.setSize(ind + 1);\n                }\n                formats.set(ind, i.next());\n            }\n            movedBuiltins = true;\n        }\n        i = formats.listIterator();\n        while (i.hasNext()) {\n            ind = i.nextIndex();\n            if (format.equals(i.next()))\n                return (short) ind;\n        }\n        ind = workbook.getFormat(format, true);\n        if (formats.size() <= ind)\n            formats.setSize(ind + 1);\n        formats.set(ind, format);\n        return (short) ind;\n    }\n\n    /**\n     * get the format string that matches the given format index\n     * @param index of a format\n     * @return string represented at index of format or null if there is not a  format at that index\n     */\n    public String getFormat(short index) {\n        if (movedBuiltins)\n            return (String) formats.get(index);\n        else\n            return (String) (builtinFormats.size() > index && builtinFormats.get(index) != null ? builtinFormats.get(index) : formats.get(index));\n    }\n\n    /**\n     * get the format string that matches the given format index\n     * @param index of a built in format\n     * @return string represented at index of format or null if there is not a builtin format at that index\n     * @throws ArrayOutOfBoundsException when the index exceeds the number of builtin formats.\n     */\n    public static String getBuiltinFormat(short index) {\n        return (String) builtinFormats.get(index);\n    }\n\n    /**\n     * get the number of builtin and reserved builtinFormats\n     * @return number of builtin and reserved builtinFormats\n     */\n    public static int getNumberOfBuiltinBuiltinFormats() {\n        return builtinFormats.size();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/5_templateit/src/main/java/org/apache/poi/hssf/usermodel/HSSFDataFormatTest3.java",
		"test_prompt": "// HSSFDataFormatTest3.java\n/*\n * HSSFDataFormat.java\n *\n * Created on December 18, 2001, 12:42 PM\n */\npackage org.apache.poi.hssf.usermodel;\n\nimport org.apache.poi.hssf.model.Workbook;\nimport org.apache.poi.hssf.record.FormatRecord;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HSSFDataFormat}.\n* It contains ten unit test cases for the {@link HSSFDataFormat#getNumberOfBuiltinBuiltinFormats()} method.\n*/\nclass HSSFDataFormatTest3 {"
	}
]