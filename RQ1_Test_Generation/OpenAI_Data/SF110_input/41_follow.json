[
	{
		"original_code": "// FollowAppAttributes.java\n/*\n * Copyright (C) 2000-2003 Greg Merrill (greghmerrill@yahoo.com)\n * \n * This file is part of Follow (http://follow.sf.net).\n * \n * Follow is free software; you can redistribute it and/or modify it under the\n * terms of version 2 of the GNU General Public License as published by the Free\n * Software Foundation.\n * \n * Follow is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License along with\n * Follow; if not, write to the Free Software Foundation, Inc., 59 Temple Place,\n * Suite 330, Boston, MA 02111-1307 USA\n */\npackage ghm.follow.config;\n\nimport ghm.follow.FollowApp;\nimport java.awt.Font;\nimport java.awt.GraphicsEnvironment;\nimport java.beans.PropertyChangeListener;\nimport java.beans.PropertyChangeSupport;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.List;\nimport javax.swing.JOptionPane;\nimport java.util.logging.Logger;\n\n/**\n * @author <a href=\"mailto:greghmerrill@yahoo.com\">Greg Merrill</a>\n */\npublic class FollowAppAttributes {\n\n    private static Logger log = Logger.getLogger(FollowAppAttributes.class.getName());\n\n    EnumeratedProperties properties;\n\n    private EnumeratedProperties defaultProperties;\n\n    private FollowAppAttributes defaultAttributes;\n\n    static final String userHome = System.getProperty(\"user.home\");\n\n    public static final String PROPERTY_FILE_NAME = \".followApp.properties\";\n\n    static final String defaultPropertyFileName = userHome + FollowApp.FILE_SEPARATOR + PROPERTY_FILE_NAME;\n\n    private File propertyFile;\n\n    public static final String PROPERTY_PROTOTYPE_FILE_NAME = \"followApp.properties.prototype\";\n\n    public static final int BUFFER_SIZE = 32768;\n\n    public static final String HEIGHT_KEY = \"height\";\n\n    public static final String WIDTH_KEY = \"width\";\n\n    public static final String X_KEY = \"x\";\n\n    public static final String Y_KEY = \"y\";\n\n    public static final String FOLLOWED_FILES_KEY = \"followedFiles\";\n\n    public static final String TAB_PLACEMENT_KEY = \"tabs.placement\";\n\n    public static final String SELECTED_TAB_INDEX_KEY = \"tabs.selectedIndex\";\n\n    public static final String LAST_FILE_CHOOSER_DIR_KEY = \"fileChooser.lastDir\";\n\n    public static final String BUFFER_SIZE_KEY = \"bufferSize\";\n\n    public static final String LATENCY_KEY = \"latency\";\n\n    public static final String ATTRIBUTES_VERSION_KEY = \"attributesVersion\";\n\n    public static final String FONT_FAMILY_KEY = \"fontFamily\";\n\n    public static final String FONT_STYLE_KEY = \"fontStyle\";\n\n    public static final String FONT_SIZE_KEY = \"fontSize\";\n\n    public static final String CONFIRM_DELETE_KEY = \"confirmDelete\";\n\n    public static final String CONFIRM_DELETE_ALL_KEY = \"confirmDeleteAll\";\n\n    public static final String AUTO_SCROLL_KEY = \"autoScroll\";\n\n    public static final String EDITOR_KEY = \"editor\";\n\n    public static final String TAB_SIZE_KEY = \"tabSize\";\n\n    public static final String RECENT_FILES_MAX_KEY = \"recentFilesMax\";\n\n    public static final String RECENT_FILES_KEY = \"recentFiles\";\n\n    // Versions\n    public static final int UNVERSIONED = 0;\n\n    public static final int v1_1 = 1;\n\n    public static final int v1_2 = 2;\n\n    public static final int v1_3 = 3;\n\n    public static final int v1_3_2 = 4;\n\n    public static final int v1_4 = 5;\n\n    public static final int v1_5_0 = 6;\n\n    public static final int v1_6_0 = 7;\n\n    private PropertyChangeSupport pcs = new PropertyChangeSupport(this);\n\n    public FollowAppAttributes() throws IOException {\n        // have to cast null so that the constructor call isn't ambiguous\n        this((File) null);\n    }\n\n    public FollowAppAttributes(File exitingPropertyFile) throws IOException {\n        if (exitingPropertyFile != null) {\n            propertyFile = exitingPropertyFile;\n        } else {\n            propertyFile = new File(defaultPropertyFileName);\n        }\n        if (!(propertyFile.exists())) {\n            // If the property file doesn't exist, we create a default property\n            // file using a prototype property file stored somewhere on the\n            // classpath\n            log.info(\"No property file for the Follow application is present; creating \" + propertyFile.getAbsolutePath() + \" (with default values) ...\");\n            properties = (EnumeratedProperties) getDefaultProperties().clone();\n            log.info(\"... property file created successfully.\");\n        } else {\n            properties = new EnumeratedProperties();\n            FileInputStream fis = new FileInputStream(propertyFile);\n            properties.load(fis);\n            switch(getAttributesVersion()) {\n                case UNVERSIONED:\n                    // Migrate unversioned attributes to 1.1 attributes\n                    log.info(\"Migrating pre-v1.1 properties to v1.1.\");\n                    setAttributesVersion(v1_1);\n                    setTabPlacement(getDefaultAttributes().getTabPlacement());\n                case v1_1:\n                    // Migrate 1.1 attributes to 1.2 attributes\n                    log.info(\"Migrating v1.1 properties to v1.2.\");\n                    setAttributesVersion(v1_2);\n                    setFont(getDefaultAttributes().getFont());\n                case v1_2:\n                    // Migrate 1.2 attributes to 1.3 attributes\n                    log.info(\"Migrating v1.2 properties to v1.3.\");\n                    setAttributesVersion(v1_3);\n                    setConfirmDelete(true);\n                    setConfirmDeleteAll(true);\n                    // Additionally, it is necessary to warn the user about the\n                    // changes to\n                    // Clear and ClearAll and the introduction of Delete and\n                    // DeleteAll\n                    JOptionPane.showMessageDialog(null, FollowApp.getResourceString(\"v1.3.warning.text\"), FollowApp.getResourceString(\"v1.3.warning.title\"), JOptionPane.WARNING_MESSAGE);\n                case v1_3:\n                case v1_3_2:\n                    // Migrate 1.3 attributes to 1.4 attributes\n                    log.info(\"Migrating v1.3 properties to v1.4.\");\n                    setAttributesVersion(v1_4);\n                    setAutoScroll(true);\n                    // Inform the user of the new AutoScroll feature\n                    JOptionPane.showMessageDialog(null, FollowApp.getResourceString(\"v1.4.info.text\"), FollowApp.getResourceString(\"v1.4.info.title\"), JOptionPane.INFORMATION_MESSAGE);\n                case v1_4:\n                    // Migrate 1.4 attributes to 1.5 attributes\n                    log.info(\"Migrating v1.4 properties to v.1.5.\");\n                    setAttributesVersion(v1_5_0);\n                    setTabSize(4);\n                case v1_5_0:\n                    // Migrate 1.5.0 attributes to 1.6.0 attributes\n                    log.info(\"Migrating v1.5 properties to 1.6.0.\");\n                    setAttributesVersion(v1_6_0);\n                    setRecentFilesMax(5);\n            }\n            fis.close();\n        }\n    }\n\n    private FollowAppAttributes(EnumeratedProperties props) throws IOException {\n        properties = props;\n    }\n\n    public int getHeight() {\n        return getInt(HEIGHT_KEY);\n    }\n\n    public void setHeight(int height) {\n        setInt(HEIGHT_KEY, height);\n    }\n\n    public int getWidth() {\n        return getInt(WIDTH_KEY);\n    }\n\n    public void setWidth(int width) {\n        setInt(WIDTH_KEY, width);\n    }\n\n    public int getX() {\n        return getInt(X_KEY);\n    }\n\n    public void setX(int x) {\n        setInt(X_KEY, x);\n    }\n\n    public int getY() {\n        return getInt(Y_KEY);\n    }\n\n    public void setY(int y) {\n        setInt(Y_KEY, y);\n    }\n\n    /**\n     * Get an array files being followed\n     *\n     * @return File[] File array of followed files\n     */\n    public List<File> getFollowedFiles() {\n        return getFiles(getFollowedFilesList());\n    }\n\n    /**\n     * Get a list of files being followed\n     *\n     * @return List file names as Strings\n     */\n    private List<String> getFollowedFilesList() {\n        return getEnumeratedProperty(FOLLOWED_FILES_KEY);\n    }\n\n    protected List<File> getFiles(List<String> fileList) {\n        ArrayList<File> files = new ArrayList<File>(fileList.size());\n        for (String s : fileList) {\n            files.add(new File(s));\n        }\n        return files;\n    }\n\n    /**\n     * Checks the existence of a file in the list of followed files\n     *\n     * @return true iff any File in the List of followed Files (getFollowedFiles()) has the same\n     *         Canonical Path as the supplied File\n     */\n    public boolean followedFileListContains(File file) {\n        return fileListContains(getFollowedFilesList(), file);\n    }\n\n    /**\n     * Checks the existence of a file in the list of recent files\n     *\n     * @return true iff any File in the List of recent Files (getFollowedFiles()) has the same\n     *         Canonical Path as the supplied File\n     */\n    public boolean recentFileListContains(File file) {\n        return fileListContains(getRecentFilesList(), file);\n    }\n\n    /**\n     * @return true iff any File in the List of Files (getFollowedFiles()) has the same Canonical\n     *         Path as the supplied File\n     */\n    protected boolean fileListContains(List<String> fileList, File file) {\n        boolean retval = false;\n        if (fileList != null && file != null) {\n            for (int i = 0; i < fileList.size(); i++) {\n                String nextFile = (String) fileList.get(i);\n                // be sure to check the same thing that is added in\n                // addFollowedFile(File)\n                if (nextFile.equals(file.getAbsolutePath())) {\n                    retval = true;\n                    break;\n                }\n            }\n        }\n        return retval;\n    }\n\n    /**\n     * Adds a file to the list of followed files\n     *\n     * @param file\n     */\n    public void addFollowedFile(File file) {\n        List<String> fileNames = getEnumeratedProperty(FOLLOWED_FILES_KEY);\n        if (!fileListContains(fileNames, file)) {\n            fileNames.add(file.getAbsolutePath());\n            setEnumeratedProperty(FOLLOWED_FILES_KEY, fileNames);\n        }\n    }\n\n    /**\n     * Removes a file from the list of followed files\n     *\n     * @param file\n     */\n    public void removeFollowedFile(File file) {\n        List<String> fileNames = getEnumeratedProperty(FOLLOWED_FILES_KEY);\n        fileNames.remove(file.getAbsolutePath());\n        setEnumeratedProperty(FOLLOWED_FILES_KEY, fileNames);\n    }\n\n    public int getTabPlacement() {\n        return getInt(TAB_PLACEMENT_KEY);\n    }\n\n    public void setTabPlacement(int tabPlacement) {\n        setInt(TAB_PLACEMENT_KEY, tabPlacement);\n    }\n\n    public int getTabSize() {\n        return getInt(TAB_SIZE_KEY);\n    }\n\n    public void setTabSize(int tabSize) {\n        setInt(TAB_SIZE_KEY, tabSize);\n    }\n\n    public void setTabSize(String tabSize) {\n        setTabSize(Integer.parseInt(tabSize));\n    }\n\n    public int getSelectedTabIndex() {\n        try {\n            return getInt(SELECTED_TAB_INDEX_KEY);\n        } catch (NumberFormatException e) {\n            setSelectedTabIndex(0);\n            return 0;\n        }\n    }\n\n    public void setSelectedTabIndex(int selectedTabIndex) {\n        setInt(SELECTED_TAB_INDEX_KEY, selectedTabIndex);\n    }\n\n    public File getLastFileChooserDirectory() {\n        return new File(properties.getProperty(LAST_FILE_CHOOSER_DIR_KEY, userHome));\n    }\n\n    public void setLastFileChooserDirectory(File file) {\n        setString(LAST_FILE_CHOOSER_DIR_KEY, file.getAbsolutePath());\n    }\n\n    public int getBufferSize() {\n        return getInt(BUFFER_SIZE_KEY);\n    }\n\n    public void setBufferSize(int bufferSize) {\n        setInt(BUFFER_SIZE_KEY, bufferSize);\n    }\n\n    public void setBufferSize(String bufferSize) {\n        setBufferSize(Integer.parseInt(bufferSize));\n    }\n\n    public int getLatency() {\n        return getInt(LATENCY_KEY);\n    }\n\n    public void setLatency(int latency) {\n        setInt(LATENCY_KEY, latency);\n    }\n\n    public void setLatency(String latency) {\n        setLatency(Integer.parseInt(latency));\n    }\n\n    public int getAttributesVersion() {\n        if (properties.get(ATTRIBUTES_VERSION_KEY) == null) {\n            // Supporting v1.0 & v1.0.1, which had no notion of attributes\n            // version\n            return UNVERSIONED;\n        } else {\n            return getInt(ATTRIBUTES_VERSION_KEY);\n        }\n    }\n\n    public void setAttributesVersion(int attributesVersion) {\n        setInt(ATTRIBUTES_VERSION_KEY, attributesVersion);\n    }\n\n    public Font getFont() {\n        Font font = new Font(getString(FONT_FAMILY_KEY), getInt(FONT_STYLE_KEY), getInt(FONT_SIZE_KEY));\n        return font;\n    }\n\n    public void setFont(Font font) {\n        setString(FONT_FAMILY_KEY, font.getFontName());\n        setInt(FONT_STYLE_KEY, font.getStyle());\n        setInt(FONT_SIZE_KEY, font.getSize());\n    }\n\n    public boolean confirmDelete() {\n        return getBoolean(CONFIRM_DELETE_KEY);\n    }\n\n    public void setConfirmDelete(boolean value) {\n        setBoolean(CONFIRM_DELETE_KEY, value);\n    }\n\n    public boolean confirmDeleteAll() {\n        return getBoolean(CONFIRM_DELETE_ALL_KEY);\n    }\n\n    public void setConfirmDeleteAll(boolean value) {\n        setBoolean(CONFIRM_DELETE_ALL_KEY, value);\n    }\n\n    public boolean autoScroll() {\n        return getBoolean(AUTO_SCROLL_KEY);\n    }\n\n    public void setAutoScroll(boolean value) {\n        setBoolean(AUTO_SCROLL_KEY, value);\n    }\n\n    public String getEditor() {\n        String result = getString(EDITOR_KEY);\n        if (result == null) {\n            result = \"\";\n        }\n        return (result);\n    }\n\n    public void setEditor(String value) {\n        setString(EDITOR_KEY, value);\n    }\n\n    /**\n     * Adds a file to the list of recent files\n     *\n     * @param file\n     */\n    public void addRecentFile(File file) {\n        if (!recentFileListContains(file)) {\n            List<String> fileList = getRecentFilesList();\n            // check size constraint and add accordingly\n            if (fileList.size() == getRecentFilesMax()) {\n                for (int i = 0; i < fileList.size() - 1; i++) {\n                    fileList.set(i, fileList.get(i + 1));\n                }\n                fileList.set(fileList.size() - 1, file.getAbsolutePath());\n            } else {\n                fileList.add(file.getAbsolutePath());\n            }\n            setEnumeratedProperty(RECENT_FILES_KEY, fileList);\n        }\n    }\n\n    /**\n     * Get an array of recently opened files\n     *\n     * @return File[] File array of followed files\n     */\n    public List<File> getRecentFiles() {\n        return getFiles(getRecentFilesList());\n    }\n\n    public int getRecentFilesMax() {\n        return getInt(RECENT_FILES_MAX_KEY);\n    }\n\n    public void setRecentFilesMax(String max) {\n        setRecentFilesMax(Integer.parseInt(max));\n    }\n\n    public void setRecentFilesMax(int max) {\n        List<String> files = getRecentFilesList();\n        if (files.size() > max) {\n            for (int i = files.size() - max; i > 0; i--) {\n                files.remove(0);\n            }\n            setEnumeratedProperty(RECENT_FILES_KEY, files);\n        }\n        setInt(RECENT_FILES_MAX_KEY, max);\n    }\n\n    public File getPropertyFile() {\n        return propertyFile;\n    }\n\n    public void store() throws IOException {\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(defaultPropertyFileName));\n        properties.store(bos, null);\n        // close this stream.  no need to flush it since Properties.store(..) does that\n        bos.close();\n    }\n\n    // The listener list wrapper methods.\n    public synchronized void addPropertyChangeListener(PropertyChangeListener listener) {\n        pcs.addPropertyChangeListener(listener);\n    }\n\n    public synchronized void addPropertyChangeListener(String prop, PropertyChangeListener listener) {\n        pcs.addPropertyChangeListener(prop, listener);\n    }\n\n    public synchronized void removePropertyChangeListener(PropertyChangeListener listener) {\n        pcs.removePropertyChangeListener(listener);\n    }\n\n    public synchronized void removePropertyChangeListener(String prop, PropertyChangeListener listener) {\n        pcs.removePropertyChangeListener(prop, listener);\n    }\n\n    public FollowAppAttributes getDefaultAttributes() throws IOException {\n        if (defaultAttributes == null) {\n            defaultAttributes = new FollowAppAttributes(getDefaultProperties());\n            // Check for the unlikely possibility that the default font is\n            // unavailable\n            Font defaultFont = defaultAttributes.getFont();\n            String[] availableFontFamilyNames = GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames();\n            boolean defaultFontIsAvailable = false;\n            for (int i = 0; i < availableFontFamilyNames.length; i++) {\n                if (defaultFont.getFamily().equals(availableFontFamilyNames[i])) {\n                    defaultFontIsAvailable = true;\n                    break;\n                }\n            }\n            if (!defaultFontIsAvailable) {\n                log.info(\"Font family \" + defaultFont.getFamily() + \" is unavailable; using \" + availableFontFamilyNames[0] + \" instead.\");\n                defaultAttributes.setFont(new Font(availableFontFamilyNames[0], defaultFont.getStyle(), defaultFont.getSize()));\n            }\n        }\n        return defaultAttributes;\n    }\n\n    /**\n     * Get a list of recently opened files\n     *\n     * @return List recently opened files as Strings\n     */\n    private List<String> getRecentFilesList() {\n        return getEnumeratedProperty(RECENT_FILES_KEY);\n    }\n\n    private int getInt(String key) {\n        int retval = 0;\n        String s = getString(key);\n        if (s != null)\n            retval = Integer.parseInt(getString(key));\n        return retval;\n    }\n\n    private void setInt(String key, int value) {\n        int oldValue = getInt(key);\n        properties.setProperty(key, String.valueOf(value));\n        pcs.firePropertyChange(key, oldValue, value);\n    }\n\n    private boolean getBoolean(String key) {\n        return \"true\".equals(getString(key));\n    }\n\n    private void setBoolean(String key, boolean value) {\n        boolean oldValue = getBoolean(key);\n        properties.setProperty(key, String.valueOf(value));\n        pcs.firePropertyChange(key, oldValue, value);\n    }\n\n    private String getString(String key) {\n        return properties.getProperty(key);\n    }\n\n    private void setString(String key, String value) {\n        String oldValue = getString(key);\n        properties.setProperty(key, value);\n        pcs.firePropertyChange(key, oldValue, value);\n    }\n\n    private List<String> getEnumeratedProperty(String key) {\n        return properties.getEnumeratedProperty(key);\n    }\n\n    private void setEnumeratedProperty(String key, List<String> values) {\n        List<String> oldValue = getEnumeratedProperty(key);\n        properties.setEnumeratedProperty(key, values);\n        pcs.firePropertyChange(key, oldValue, values);\n    }\n\n    private EnumeratedProperties getDefaultProperties() throws IOException {\n        if (defaultProperties == null) {\n            InputStream in = this.getClass().getResourceAsStream(PROPERTY_PROTOTYPE_FILE_NAME);\n            BufferedInputStream bis = new BufferedInputStream(in);\n            FileOutputStream fos = new FileOutputStream(propertyFile);\n            BufferedOutputStream bos = new BufferedOutputStream(fos);\n            byte[] byteArray = new byte[BUFFER_SIZE];\n            int len;\n            while ((len = bis.read(byteArray, 0, BUFFER_SIZE)) > 0) {\n                bos.write(byteArray, 0, len);\n            }\n            bos.flush();\n            bos.close();\n            bis.close();\n            defaultProperties = new EnumeratedProperties();\n            defaultProperties.load(new BufferedInputStream(new FileInputStream(propertyFile)));\n        }\n        return defaultProperties;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/config/FollowAppAttributesTest0.java",
		"test_prompt": "// FollowAppAttributesTest0.java\npackage ghm.follow.config;\n\nimport ghm.follow.FollowApp;\nimport java.awt.Font;\nimport java.awt.GraphicsEnvironment;\nimport java.beans.PropertyChangeListener;\nimport java.beans.PropertyChangeSupport;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.List;\nimport javax.swing.JOptionPane;\nimport java.util.logging.Logger;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FollowAppAttributes}.\n* It contains ten unit test cases for the {@link FollowAppAttributes#followedFileListContains(File)} method.\n*/\nclass FollowAppAttributesTest0 {"
	},
	{
		"original_code": "// FollowAppAttributes.java\n/*\n * Copyright (C) 2000-2003 Greg Merrill (greghmerrill@yahoo.com)\n * \n * This file is part of Follow (http://follow.sf.net).\n * \n * Follow is free software; you can redistribute it and/or modify it under the\n * terms of version 2 of the GNU General Public License as published by the Free\n * Software Foundation.\n * \n * Follow is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License along with\n * Follow; if not, write to the Free Software Foundation, Inc., 59 Temple Place,\n * Suite 330, Boston, MA 02111-1307 USA\n */\npackage ghm.follow.config;\n\nimport ghm.follow.FollowApp;\nimport java.awt.Font;\nimport java.awt.GraphicsEnvironment;\nimport java.beans.PropertyChangeListener;\nimport java.beans.PropertyChangeSupport;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.List;\nimport javax.swing.JOptionPane;\nimport java.util.logging.Logger;\n\n/**\n * @author <a href=\"mailto:greghmerrill@yahoo.com\">Greg Merrill</a>\n */\npublic class FollowAppAttributes {\n\n    private static Logger log = Logger.getLogger(FollowAppAttributes.class.getName());\n\n    EnumeratedProperties properties;\n\n    private EnumeratedProperties defaultProperties;\n\n    private FollowAppAttributes defaultAttributes;\n\n    static final String userHome = System.getProperty(\"user.home\");\n\n    public static final String PROPERTY_FILE_NAME = \".followApp.properties\";\n\n    static final String defaultPropertyFileName = userHome + FollowApp.FILE_SEPARATOR + PROPERTY_FILE_NAME;\n\n    private File propertyFile;\n\n    public static final String PROPERTY_PROTOTYPE_FILE_NAME = \"followApp.properties.prototype\";\n\n    public static final int BUFFER_SIZE = 32768;\n\n    public static final String HEIGHT_KEY = \"height\";\n\n    public static final String WIDTH_KEY = \"width\";\n\n    public static final String X_KEY = \"x\";\n\n    public static final String Y_KEY = \"y\";\n\n    public static final String FOLLOWED_FILES_KEY = \"followedFiles\";\n\n    public static final String TAB_PLACEMENT_KEY = \"tabs.placement\";\n\n    public static final String SELECTED_TAB_INDEX_KEY = \"tabs.selectedIndex\";\n\n    public static final String LAST_FILE_CHOOSER_DIR_KEY = \"fileChooser.lastDir\";\n\n    public static final String BUFFER_SIZE_KEY = \"bufferSize\";\n\n    public static final String LATENCY_KEY = \"latency\";\n\n    public static final String ATTRIBUTES_VERSION_KEY = \"attributesVersion\";\n\n    public static final String FONT_FAMILY_KEY = \"fontFamily\";\n\n    public static final String FONT_STYLE_KEY = \"fontStyle\";\n\n    public static final String FONT_SIZE_KEY = \"fontSize\";\n\n    public static final String CONFIRM_DELETE_KEY = \"confirmDelete\";\n\n    public static final String CONFIRM_DELETE_ALL_KEY = \"confirmDeleteAll\";\n\n    public static final String AUTO_SCROLL_KEY = \"autoScroll\";\n\n    public static final String EDITOR_KEY = \"editor\";\n\n    public static final String TAB_SIZE_KEY = \"tabSize\";\n\n    public static final String RECENT_FILES_MAX_KEY = \"recentFilesMax\";\n\n    public static final String RECENT_FILES_KEY = \"recentFiles\";\n\n    // Versions\n    public static final int UNVERSIONED = 0;\n\n    public static final int v1_1 = 1;\n\n    public static final int v1_2 = 2;\n\n    public static final int v1_3 = 3;\n\n    public static final int v1_3_2 = 4;\n\n    public static final int v1_4 = 5;\n\n    public static final int v1_5_0 = 6;\n\n    public static final int v1_6_0 = 7;\n\n    private PropertyChangeSupport pcs = new PropertyChangeSupport(this);\n\n    public FollowAppAttributes() throws IOException {\n        // have to cast null so that the constructor call isn't ambiguous\n        this((File) null);\n    }\n\n    public FollowAppAttributes(File exitingPropertyFile) throws IOException {\n        if (exitingPropertyFile != null) {\n            propertyFile = exitingPropertyFile;\n        } else {\n            propertyFile = new File(defaultPropertyFileName);\n        }\n        if (!(propertyFile.exists())) {\n            // If the property file doesn't exist, we create a default property\n            // file using a prototype property file stored somewhere on the\n            // classpath\n            log.info(\"No property file for the Follow application is present; creating \" + propertyFile.getAbsolutePath() + \" (with default values) ...\");\n            properties = (EnumeratedProperties) getDefaultProperties().clone();\n            log.info(\"... property file created successfully.\");\n        } else {\n            properties = new EnumeratedProperties();\n            FileInputStream fis = new FileInputStream(propertyFile);\n            properties.load(fis);\n            switch(getAttributesVersion()) {\n                case UNVERSIONED:\n                    // Migrate unversioned attributes to 1.1 attributes\n                    log.info(\"Migrating pre-v1.1 properties to v1.1.\");\n                    setAttributesVersion(v1_1);\n                    setTabPlacement(getDefaultAttributes().getTabPlacement());\n                case v1_1:\n                    // Migrate 1.1 attributes to 1.2 attributes\n                    log.info(\"Migrating v1.1 properties to v1.2.\");\n                    setAttributesVersion(v1_2);\n                    setFont(getDefaultAttributes().getFont());\n                case v1_2:\n                    // Migrate 1.2 attributes to 1.3 attributes\n                    log.info(\"Migrating v1.2 properties to v1.3.\");\n                    setAttributesVersion(v1_3);\n                    setConfirmDelete(true);\n                    setConfirmDeleteAll(true);\n                    // Additionally, it is necessary to warn the user about the\n                    // changes to\n                    // Clear and ClearAll and the introduction of Delete and\n                    // DeleteAll\n                    JOptionPane.showMessageDialog(null, FollowApp.getResourceString(\"v1.3.warning.text\"), FollowApp.getResourceString(\"v1.3.warning.title\"), JOptionPane.WARNING_MESSAGE);\n                case v1_3:\n                case v1_3_2:\n                    // Migrate 1.3 attributes to 1.4 attributes\n                    log.info(\"Migrating v1.3 properties to v1.4.\");\n                    setAttributesVersion(v1_4);\n                    setAutoScroll(true);\n                    // Inform the user of the new AutoScroll feature\n                    JOptionPane.showMessageDialog(null, FollowApp.getResourceString(\"v1.4.info.text\"), FollowApp.getResourceString(\"v1.4.info.title\"), JOptionPane.INFORMATION_MESSAGE);\n                case v1_4:\n                    // Migrate 1.4 attributes to 1.5 attributes\n                    log.info(\"Migrating v1.4 properties to v.1.5.\");\n                    setAttributesVersion(v1_5_0);\n                    setTabSize(4);\n                case v1_5_0:\n                    // Migrate 1.5.0 attributes to 1.6.0 attributes\n                    log.info(\"Migrating v1.5 properties to 1.6.0.\");\n                    setAttributesVersion(v1_6_0);\n                    setRecentFilesMax(5);\n            }\n            fis.close();\n        }\n    }\n\n    private FollowAppAttributes(EnumeratedProperties props) throws IOException {\n        properties = props;\n    }\n\n    public int getHeight() {\n        return getInt(HEIGHT_KEY);\n    }\n\n    public void setHeight(int height) {\n        setInt(HEIGHT_KEY, height);\n    }\n\n    public int getWidth() {\n        return getInt(WIDTH_KEY);\n    }\n\n    public void setWidth(int width) {\n        setInt(WIDTH_KEY, width);\n    }\n\n    public int getX() {\n        return getInt(X_KEY);\n    }\n\n    public void setX(int x) {\n        setInt(X_KEY, x);\n    }\n\n    public int getY() {\n        return getInt(Y_KEY);\n    }\n\n    public void setY(int y) {\n        setInt(Y_KEY, y);\n    }\n\n    /**\n     * Get an array files being followed\n     *\n     * @return File[] File array of followed files\n     */\n    public List<File> getFollowedFiles() {\n        return getFiles(getFollowedFilesList());\n    }\n\n    /**\n     * Get a list of files being followed\n     *\n     * @return List file names as Strings\n     */\n    private List<String> getFollowedFilesList() {\n        return getEnumeratedProperty(FOLLOWED_FILES_KEY);\n    }\n\n    protected List<File> getFiles(List<String> fileList) {\n        ArrayList<File> files = new ArrayList<File>(fileList.size());\n        for (String s : fileList) {\n            files.add(new File(s));\n        }\n        return files;\n    }\n\n    /**\n     * Checks the existence of a file in the list of followed files\n     *\n     * @return true iff any File in the List of followed Files (getFollowedFiles()) has the same\n     *         Canonical Path as the supplied File\n     */\n    public boolean followedFileListContains(File file) {\n        return fileListContains(getFollowedFilesList(), file);\n    }\n\n    /**\n     * Checks the existence of a file in the list of recent files\n     *\n     * @return true iff any File in the List of recent Files (getFollowedFiles()) has the same\n     *         Canonical Path as the supplied File\n     */\n    public boolean recentFileListContains(File file) {\n        return fileListContains(getRecentFilesList(), file);\n    }\n\n    /**\n     * @return true iff any File in the List of Files (getFollowedFiles()) has the same Canonical\n     *         Path as the supplied File\n     */\n    protected boolean fileListContains(List<String> fileList, File file) {\n        boolean retval = false;\n        if (fileList != null && file != null) {\n            for (int i = 0; i < fileList.size(); i++) {\n                String nextFile = (String) fileList.get(i);\n                // be sure to check the same thing that is added in\n                // addFollowedFile(File)\n                if (nextFile.equals(file.getAbsolutePath())) {\n                    retval = true;\n                    break;\n                }\n            }\n        }\n        return retval;\n    }\n\n    /**\n     * Adds a file to the list of followed files\n     *\n     * @param file\n     */\n    public void addFollowedFile(File file) {\n        List<String> fileNames = getEnumeratedProperty(FOLLOWED_FILES_KEY);\n        if (!fileListContains(fileNames, file)) {\n            fileNames.add(file.getAbsolutePath());\n            setEnumeratedProperty(FOLLOWED_FILES_KEY, fileNames);\n        }\n    }\n\n    /**\n     * Removes a file from the list of followed files\n     *\n     * @param file\n     */\n    public void removeFollowedFile(File file) {\n        List<String> fileNames = getEnumeratedProperty(FOLLOWED_FILES_KEY);\n        fileNames.remove(file.getAbsolutePath());\n        setEnumeratedProperty(FOLLOWED_FILES_KEY, fileNames);\n    }\n\n    public int getTabPlacement() {\n        return getInt(TAB_PLACEMENT_KEY);\n    }\n\n    public void setTabPlacement(int tabPlacement) {\n        setInt(TAB_PLACEMENT_KEY, tabPlacement);\n    }\n\n    public int getTabSize() {\n        return getInt(TAB_SIZE_KEY);\n    }\n\n    public void setTabSize(int tabSize) {\n        setInt(TAB_SIZE_KEY, tabSize);\n    }\n\n    public void setTabSize(String tabSize) {\n        setTabSize(Integer.parseInt(tabSize));\n    }\n\n    public int getSelectedTabIndex() {\n        try {\n            return getInt(SELECTED_TAB_INDEX_KEY);\n        } catch (NumberFormatException e) {\n            setSelectedTabIndex(0);\n            return 0;\n        }\n    }\n\n    public void setSelectedTabIndex(int selectedTabIndex) {\n        setInt(SELECTED_TAB_INDEX_KEY, selectedTabIndex);\n    }\n\n    public File getLastFileChooserDirectory() {\n        return new File(properties.getProperty(LAST_FILE_CHOOSER_DIR_KEY, userHome));\n    }\n\n    public void setLastFileChooserDirectory(File file) {\n        setString(LAST_FILE_CHOOSER_DIR_KEY, file.getAbsolutePath());\n    }\n\n    public int getBufferSize() {\n        return getInt(BUFFER_SIZE_KEY);\n    }\n\n    public void setBufferSize(int bufferSize) {\n        setInt(BUFFER_SIZE_KEY, bufferSize);\n    }\n\n    public void setBufferSize(String bufferSize) {\n        setBufferSize(Integer.parseInt(bufferSize));\n    }\n\n    public int getLatency() {\n        return getInt(LATENCY_KEY);\n    }\n\n    public void setLatency(int latency) {\n        setInt(LATENCY_KEY, latency);\n    }\n\n    public void setLatency(String latency) {\n        setLatency(Integer.parseInt(latency));\n    }\n\n    public int getAttributesVersion() {\n        if (properties.get(ATTRIBUTES_VERSION_KEY) == null) {\n            // Supporting v1.0 & v1.0.1, which had no notion of attributes\n            // version\n            return UNVERSIONED;\n        } else {\n            return getInt(ATTRIBUTES_VERSION_KEY);\n        }\n    }\n\n    public void setAttributesVersion(int attributesVersion) {\n        setInt(ATTRIBUTES_VERSION_KEY, attributesVersion);\n    }\n\n    public Font getFont() {\n        Font font = new Font(getString(FONT_FAMILY_KEY), getInt(FONT_STYLE_KEY), getInt(FONT_SIZE_KEY));\n        return font;\n    }\n\n    public void setFont(Font font) {\n        setString(FONT_FAMILY_KEY, font.getFontName());\n        setInt(FONT_STYLE_KEY, font.getStyle());\n        setInt(FONT_SIZE_KEY, font.getSize());\n    }\n\n    public boolean confirmDelete() {\n        return getBoolean(CONFIRM_DELETE_KEY);\n    }\n\n    public void setConfirmDelete(boolean value) {\n        setBoolean(CONFIRM_DELETE_KEY, value);\n    }\n\n    public boolean confirmDeleteAll() {\n        return getBoolean(CONFIRM_DELETE_ALL_KEY);\n    }\n\n    public void setConfirmDeleteAll(boolean value) {\n        setBoolean(CONFIRM_DELETE_ALL_KEY, value);\n    }\n\n    public boolean autoScroll() {\n        return getBoolean(AUTO_SCROLL_KEY);\n    }\n\n    public void setAutoScroll(boolean value) {\n        setBoolean(AUTO_SCROLL_KEY, value);\n    }\n\n    public String getEditor() {\n        String result = getString(EDITOR_KEY);\n        if (result == null) {\n            result = \"\";\n        }\n        return (result);\n    }\n\n    public void setEditor(String value) {\n        setString(EDITOR_KEY, value);\n    }\n\n    /**\n     * Adds a file to the list of recent files\n     *\n     * @param file\n     */\n    public void addRecentFile(File file) {\n        if (!recentFileListContains(file)) {\n            List<String> fileList = getRecentFilesList();\n            // check size constraint and add accordingly\n            if (fileList.size() == getRecentFilesMax()) {\n                for (int i = 0; i < fileList.size() - 1; i++) {\n                    fileList.set(i, fileList.get(i + 1));\n                }\n                fileList.set(fileList.size() - 1, file.getAbsolutePath());\n            } else {\n                fileList.add(file.getAbsolutePath());\n            }\n            setEnumeratedProperty(RECENT_FILES_KEY, fileList);\n        }\n    }\n\n    /**\n     * Get an array of recently opened files\n     *\n     * @return File[] File array of followed files\n     */\n    public List<File> getRecentFiles() {\n        return getFiles(getRecentFilesList());\n    }\n\n    public int getRecentFilesMax() {\n        return getInt(RECENT_FILES_MAX_KEY);\n    }\n\n    public void setRecentFilesMax(String max) {\n        setRecentFilesMax(Integer.parseInt(max));\n    }\n\n    public void setRecentFilesMax(int max) {\n        List<String> files = getRecentFilesList();\n        if (files.size() > max) {\n            for (int i = files.size() - max; i > 0; i--) {\n                files.remove(0);\n            }\n            setEnumeratedProperty(RECENT_FILES_KEY, files);\n        }\n        setInt(RECENT_FILES_MAX_KEY, max);\n    }\n\n    public File getPropertyFile() {\n        return propertyFile;\n    }\n\n    public void store() throws IOException {\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(defaultPropertyFileName));\n        properties.store(bos, null);\n        // close this stream.  no need to flush it since Properties.store(..) does that\n        bos.close();\n    }\n\n    // The listener list wrapper methods.\n    public synchronized void addPropertyChangeListener(PropertyChangeListener listener) {\n        pcs.addPropertyChangeListener(listener);\n    }\n\n    public synchronized void addPropertyChangeListener(String prop, PropertyChangeListener listener) {\n        pcs.addPropertyChangeListener(prop, listener);\n    }\n\n    public synchronized void removePropertyChangeListener(PropertyChangeListener listener) {\n        pcs.removePropertyChangeListener(listener);\n    }\n\n    public synchronized void removePropertyChangeListener(String prop, PropertyChangeListener listener) {\n        pcs.removePropertyChangeListener(prop, listener);\n    }\n\n    public FollowAppAttributes getDefaultAttributes() throws IOException {\n        if (defaultAttributes == null) {\n            defaultAttributes = new FollowAppAttributes(getDefaultProperties());\n            // Check for the unlikely possibility that the default font is\n            // unavailable\n            Font defaultFont = defaultAttributes.getFont();\n            String[] availableFontFamilyNames = GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames();\n            boolean defaultFontIsAvailable = false;\n            for (int i = 0; i < availableFontFamilyNames.length; i++) {\n                if (defaultFont.getFamily().equals(availableFontFamilyNames[i])) {\n                    defaultFontIsAvailable = true;\n                    break;\n                }\n            }\n            if (!defaultFontIsAvailable) {\n                log.info(\"Font family \" + defaultFont.getFamily() + \" is unavailable; using \" + availableFontFamilyNames[0] + \" instead.\");\n                defaultAttributes.setFont(new Font(availableFontFamilyNames[0], defaultFont.getStyle(), defaultFont.getSize()));\n            }\n        }\n        return defaultAttributes;\n    }\n\n    /**\n     * Get a list of recently opened files\n     *\n     * @return List recently opened files as Strings\n     */\n    private List<String> getRecentFilesList() {\n        return getEnumeratedProperty(RECENT_FILES_KEY);\n    }\n\n    private int getInt(String key) {\n        int retval = 0;\n        String s = getString(key);\n        if (s != null)\n            retval = Integer.parseInt(getString(key));\n        return retval;\n    }\n\n    private void setInt(String key, int value) {\n        int oldValue = getInt(key);\n        properties.setProperty(key, String.valueOf(value));\n        pcs.firePropertyChange(key, oldValue, value);\n    }\n\n    private boolean getBoolean(String key) {\n        return \"true\".equals(getString(key));\n    }\n\n    private void setBoolean(String key, boolean value) {\n        boolean oldValue = getBoolean(key);\n        properties.setProperty(key, String.valueOf(value));\n        pcs.firePropertyChange(key, oldValue, value);\n    }\n\n    private String getString(String key) {\n        return properties.getProperty(key);\n    }\n\n    private void setString(String key, String value) {\n        String oldValue = getString(key);\n        properties.setProperty(key, value);\n        pcs.firePropertyChange(key, oldValue, value);\n    }\n\n    private List<String> getEnumeratedProperty(String key) {\n        return properties.getEnumeratedProperty(key);\n    }\n\n    private void setEnumeratedProperty(String key, List<String> values) {\n        List<String> oldValue = getEnumeratedProperty(key);\n        properties.setEnumeratedProperty(key, values);\n        pcs.firePropertyChange(key, oldValue, values);\n    }\n\n    private EnumeratedProperties getDefaultProperties() throws IOException {\n        if (defaultProperties == null) {\n            InputStream in = this.getClass().getResourceAsStream(PROPERTY_PROTOTYPE_FILE_NAME);\n            BufferedInputStream bis = new BufferedInputStream(in);\n            FileOutputStream fos = new FileOutputStream(propertyFile);\n            BufferedOutputStream bos = new BufferedOutputStream(fos);\n            byte[] byteArray = new byte[BUFFER_SIZE];\n            int len;\n            while ((len = bis.read(byteArray, 0, BUFFER_SIZE)) > 0) {\n                bos.write(byteArray, 0, len);\n            }\n            bos.flush();\n            bos.close();\n            bis.close();\n            defaultProperties = new EnumeratedProperties();\n            defaultProperties.load(new BufferedInputStream(new FileInputStream(propertyFile)));\n        }\n        return defaultProperties;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/config/FollowAppAttributesTest1.java",
		"test_prompt": "// FollowAppAttributesTest1.java\npackage ghm.follow.config;\n\nimport ghm.follow.FollowApp;\nimport java.awt.Font;\nimport java.awt.GraphicsEnvironment;\nimport java.beans.PropertyChangeListener;\nimport java.beans.PropertyChangeSupport;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.List;\nimport javax.swing.JOptionPane;\nimport java.util.logging.Logger;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FollowAppAttributes}.\n* It contains ten unit test cases for the {@link FollowAppAttributes#recentFileListContains(File)} method.\n*/\nclass FollowAppAttributesTest1 {"
	},
	{
		"original_code": "// FollowAppAttributes.java\n/*\n * Copyright (C) 2000-2003 Greg Merrill (greghmerrill@yahoo.com)\n * \n * This file is part of Follow (http://follow.sf.net).\n * \n * Follow is free software; you can redistribute it and/or modify it under the\n * terms of version 2 of the GNU General Public License as published by the Free\n * Software Foundation.\n * \n * Follow is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License along with\n * Follow; if not, write to the Free Software Foundation, Inc., 59 Temple Place,\n * Suite 330, Boston, MA 02111-1307 USA\n */\npackage ghm.follow.config;\n\nimport ghm.follow.FollowApp;\nimport java.awt.Font;\nimport java.awt.GraphicsEnvironment;\nimport java.beans.PropertyChangeListener;\nimport java.beans.PropertyChangeSupport;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.List;\nimport javax.swing.JOptionPane;\nimport java.util.logging.Logger;\n\n/**\n * @author <a href=\"mailto:greghmerrill@yahoo.com\">Greg Merrill</a>\n */\npublic class FollowAppAttributes {\n\n    private static Logger log = Logger.getLogger(FollowAppAttributes.class.getName());\n\n    EnumeratedProperties properties;\n\n    private EnumeratedProperties defaultProperties;\n\n    private FollowAppAttributes defaultAttributes;\n\n    static final String userHome = System.getProperty(\"user.home\");\n\n    public static final String PROPERTY_FILE_NAME = \".followApp.properties\";\n\n    static final String defaultPropertyFileName = userHome + FollowApp.FILE_SEPARATOR + PROPERTY_FILE_NAME;\n\n    private File propertyFile;\n\n    public static final String PROPERTY_PROTOTYPE_FILE_NAME = \"followApp.properties.prototype\";\n\n    public static final int BUFFER_SIZE = 32768;\n\n    public static final String HEIGHT_KEY = \"height\";\n\n    public static final String WIDTH_KEY = \"width\";\n\n    public static final String X_KEY = \"x\";\n\n    public static final String Y_KEY = \"y\";\n\n    public static final String FOLLOWED_FILES_KEY = \"followedFiles\";\n\n    public static final String TAB_PLACEMENT_KEY = \"tabs.placement\";\n\n    public static final String SELECTED_TAB_INDEX_KEY = \"tabs.selectedIndex\";\n\n    public static final String LAST_FILE_CHOOSER_DIR_KEY = \"fileChooser.lastDir\";\n\n    public static final String BUFFER_SIZE_KEY = \"bufferSize\";\n\n    public static final String LATENCY_KEY = \"latency\";\n\n    public static final String ATTRIBUTES_VERSION_KEY = \"attributesVersion\";\n\n    public static final String FONT_FAMILY_KEY = \"fontFamily\";\n\n    public static final String FONT_STYLE_KEY = \"fontStyle\";\n\n    public static final String FONT_SIZE_KEY = \"fontSize\";\n\n    public static final String CONFIRM_DELETE_KEY = \"confirmDelete\";\n\n    public static final String CONFIRM_DELETE_ALL_KEY = \"confirmDeleteAll\";\n\n    public static final String AUTO_SCROLL_KEY = \"autoScroll\";\n\n    public static final String EDITOR_KEY = \"editor\";\n\n    public static final String TAB_SIZE_KEY = \"tabSize\";\n\n    public static final String RECENT_FILES_MAX_KEY = \"recentFilesMax\";\n\n    public static final String RECENT_FILES_KEY = \"recentFiles\";\n\n    // Versions\n    public static final int UNVERSIONED = 0;\n\n    public static final int v1_1 = 1;\n\n    public static final int v1_2 = 2;\n\n    public static final int v1_3 = 3;\n\n    public static final int v1_3_2 = 4;\n\n    public static final int v1_4 = 5;\n\n    public static final int v1_5_0 = 6;\n\n    public static final int v1_6_0 = 7;\n\n    private PropertyChangeSupport pcs = new PropertyChangeSupport(this);\n\n    public FollowAppAttributes() throws IOException {\n        // have to cast null so that the constructor call isn't ambiguous\n        this((File) null);\n    }\n\n    public FollowAppAttributes(File exitingPropertyFile) throws IOException {\n        if (exitingPropertyFile != null) {\n            propertyFile = exitingPropertyFile;\n        } else {\n            propertyFile = new File(defaultPropertyFileName);\n        }\n        if (!(propertyFile.exists())) {\n            // If the property file doesn't exist, we create a default property\n            // file using a prototype property file stored somewhere on the\n            // classpath\n            log.info(\"No property file for the Follow application is present; creating \" + propertyFile.getAbsolutePath() + \" (with default values) ...\");\n            properties = (EnumeratedProperties) getDefaultProperties().clone();\n            log.info(\"... property file created successfully.\");\n        } else {\n            properties = new EnumeratedProperties();\n            FileInputStream fis = new FileInputStream(propertyFile);\n            properties.load(fis);\n            switch(getAttributesVersion()) {\n                case UNVERSIONED:\n                    // Migrate unversioned attributes to 1.1 attributes\n                    log.info(\"Migrating pre-v1.1 properties to v1.1.\");\n                    setAttributesVersion(v1_1);\n                    setTabPlacement(getDefaultAttributes().getTabPlacement());\n                case v1_1:\n                    // Migrate 1.1 attributes to 1.2 attributes\n                    log.info(\"Migrating v1.1 properties to v1.2.\");\n                    setAttributesVersion(v1_2);\n                    setFont(getDefaultAttributes().getFont());\n                case v1_2:\n                    // Migrate 1.2 attributes to 1.3 attributes\n                    log.info(\"Migrating v1.2 properties to v1.3.\");\n                    setAttributesVersion(v1_3);\n                    setConfirmDelete(true);\n                    setConfirmDeleteAll(true);\n                    // Additionally, it is necessary to warn the user about the\n                    // changes to\n                    // Clear and ClearAll and the introduction of Delete and\n                    // DeleteAll\n                    JOptionPane.showMessageDialog(null, FollowApp.getResourceString(\"v1.3.warning.text\"), FollowApp.getResourceString(\"v1.3.warning.title\"), JOptionPane.WARNING_MESSAGE);\n                case v1_3:\n                case v1_3_2:\n                    // Migrate 1.3 attributes to 1.4 attributes\n                    log.info(\"Migrating v1.3 properties to v1.4.\");\n                    setAttributesVersion(v1_4);\n                    setAutoScroll(true);\n                    // Inform the user of the new AutoScroll feature\n                    JOptionPane.showMessageDialog(null, FollowApp.getResourceString(\"v1.4.info.text\"), FollowApp.getResourceString(\"v1.4.info.title\"), JOptionPane.INFORMATION_MESSAGE);\n                case v1_4:\n                    // Migrate 1.4 attributes to 1.5 attributes\n                    log.info(\"Migrating v1.4 properties to v.1.5.\");\n                    setAttributesVersion(v1_5_0);\n                    setTabSize(4);\n                case v1_5_0:\n                    // Migrate 1.5.0 attributes to 1.6.0 attributes\n                    log.info(\"Migrating v1.5 properties to 1.6.0.\");\n                    setAttributesVersion(v1_6_0);\n                    setRecentFilesMax(5);\n            }\n            fis.close();\n        }\n    }\n\n    private FollowAppAttributes(EnumeratedProperties props) throws IOException {\n        properties = props;\n    }\n\n    public int getHeight() {\n        return getInt(HEIGHT_KEY);\n    }\n\n    public void setHeight(int height) {\n        setInt(HEIGHT_KEY, height);\n    }\n\n    public int getWidth() {\n        return getInt(WIDTH_KEY);\n    }\n\n    public void setWidth(int width) {\n        setInt(WIDTH_KEY, width);\n    }\n\n    public int getX() {\n        return getInt(X_KEY);\n    }\n\n    public void setX(int x) {\n        setInt(X_KEY, x);\n    }\n\n    public int getY() {\n        return getInt(Y_KEY);\n    }\n\n    public void setY(int y) {\n        setInt(Y_KEY, y);\n    }\n\n    /**\n     * Get an array files being followed\n     *\n     * @return File[] File array of followed files\n     */\n    public List<File> getFollowedFiles() {\n        return getFiles(getFollowedFilesList());\n    }\n\n    /**\n     * Get a list of files being followed\n     *\n     * @return List file names as Strings\n     */\n    private List<String> getFollowedFilesList() {\n        return getEnumeratedProperty(FOLLOWED_FILES_KEY);\n    }\n\n    protected List<File> getFiles(List<String> fileList) {\n        ArrayList<File> files = new ArrayList<File>(fileList.size());\n        for (String s : fileList) {\n            files.add(new File(s));\n        }\n        return files;\n    }\n\n    /**\n     * Checks the existence of a file in the list of followed files\n     *\n     * @return true iff any File in the List of followed Files (getFollowedFiles()) has the same\n     *         Canonical Path as the supplied File\n     */\n    public boolean followedFileListContains(File file) {\n        return fileListContains(getFollowedFilesList(), file);\n    }\n\n    /**\n     * Checks the existence of a file in the list of recent files\n     *\n     * @return true iff any File in the List of recent Files (getFollowedFiles()) has the same\n     *         Canonical Path as the supplied File\n     */\n    public boolean recentFileListContains(File file) {\n        return fileListContains(getRecentFilesList(), file);\n    }\n\n    /**\n     * @return true iff any File in the List of Files (getFollowedFiles()) has the same Canonical\n     *         Path as the supplied File\n     */\n    protected boolean fileListContains(List<String> fileList, File file) {\n        boolean retval = false;\n        if (fileList != null && file != null) {\n            for (int i = 0; i < fileList.size(); i++) {\n                String nextFile = (String) fileList.get(i);\n                // be sure to check the same thing that is added in\n                // addFollowedFile(File)\n                if (nextFile.equals(file.getAbsolutePath())) {\n                    retval = true;\n                    break;\n                }\n            }\n        }\n        return retval;\n    }\n\n    /**\n     * Adds a file to the list of followed files\n     *\n     * @param file\n     */\n    public void addFollowedFile(File file) {\n        List<String> fileNames = getEnumeratedProperty(FOLLOWED_FILES_KEY);\n        if (!fileListContains(fileNames, file)) {\n            fileNames.add(file.getAbsolutePath());\n            setEnumeratedProperty(FOLLOWED_FILES_KEY, fileNames);\n        }\n    }\n\n    /**\n     * Removes a file from the list of followed files\n     *\n     * @param file\n     */\n    public void removeFollowedFile(File file) {\n        List<String> fileNames = getEnumeratedProperty(FOLLOWED_FILES_KEY);\n        fileNames.remove(file.getAbsolutePath());\n        setEnumeratedProperty(FOLLOWED_FILES_KEY, fileNames);\n    }\n\n    public int getTabPlacement() {\n        return getInt(TAB_PLACEMENT_KEY);\n    }\n\n    public void setTabPlacement(int tabPlacement) {\n        setInt(TAB_PLACEMENT_KEY, tabPlacement);\n    }\n\n    public int getTabSize() {\n        return getInt(TAB_SIZE_KEY);\n    }\n\n    public void setTabSize(int tabSize) {\n        setInt(TAB_SIZE_KEY, tabSize);\n    }\n\n    public void setTabSize(String tabSize) {\n        setTabSize(Integer.parseInt(tabSize));\n    }\n\n    public int getSelectedTabIndex() {\n        try {\n            return getInt(SELECTED_TAB_INDEX_KEY);\n        } catch (NumberFormatException e) {\n            setSelectedTabIndex(0);\n            return 0;\n        }\n    }\n\n    public void setSelectedTabIndex(int selectedTabIndex) {\n        setInt(SELECTED_TAB_INDEX_KEY, selectedTabIndex);\n    }\n\n    public File getLastFileChooserDirectory() {\n        return new File(properties.getProperty(LAST_FILE_CHOOSER_DIR_KEY, userHome));\n    }\n\n    public void setLastFileChooserDirectory(File file) {\n        setString(LAST_FILE_CHOOSER_DIR_KEY, file.getAbsolutePath());\n    }\n\n    public int getBufferSize() {\n        return getInt(BUFFER_SIZE_KEY);\n    }\n\n    public void setBufferSize(int bufferSize) {\n        setInt(BUFFER_SIZE_KEY, bufferSize);\n    }\n\n    public void setBufferSize(String bufferSize) {\n        setBufferSize(Integer.parseInt(bufferSize));\n    }\n\n    public int getLatency() {\n        return getInt(LATENCY_KEY);\n    }\n\n    public void setLatency(int latency) {\n        setInt(LATENCY_KEY, latency);\n    }\n\n    public void setLatency(String latency) {\n        setLatency(Integer.parseInt(latency));\n    }\n\n    public int getAttributesVersion() {\n        if (properties.get(ATTRIBUTES_VERSION_KEY) == null) {\n            // Supporting v1.0 & v1.0.1, which had no notion of attributes\n            // version\n            return UNVERSIONED;\n        } else {\n            return getInt(ATTRIBUTES_VERSION_KEY);\n        }\n    }\n\n    public void setAttributesVersion(int attributesVersion) {\n        setInt(ATTRIBUTES_VERSION_KEY, attributesVersion);\n    }\n\n    public Font getFont() {\n        Font font = new Font(getString(FONT_FAMILY_KEY), getInt(FONT_STYLE_KEY), getInt(FONT_SIZE_KEY));\n        return font;\n    }\n\n    public void setFont(Font font) {\n        setString(FONT_FAMILY_KEY, font.getFontName());\n        setInt(FONT_STYLE_KEY, font.getStyle());\n        setInt(FONT_SIZE_KEY, font.getSize());\n    }\n\n    public boolean confirmDelete() {\n        return getBoolean(CONFIRM_DELETE_KEY);\n    }\n\n    public void setConfirmDelete(boolean value) {\n        setBoolean(CONFIRM_DELETE_KEY, value);\n    }\n\n    public boolean confirmDeleteAll() {\n        return getBoolean(CONFIRM_DELETE_ALL_KEY);\n    }\n\n    public void setConfirmDeleteAll(boolean value) {\n        setBoolean(CONFIRM_DELETE_ALL_KEY, value);\n    }\n\n    public boolean autoScroll() {\n        return getBoolean(AUTO_SCROLL_KEY);\n    }\n\n    public void setAutoScroll(boolean value) {\n        setBoolean(AUTO_SCROLL_KEY, value);\n    }\n\n    public String getEditor() {\n        String result = getString(EDITOR_KEY);\n        if (result == null) {\n            result = \"\";\n        }\n        return (result);\n    }\n\n    public void setEditor(String value) {\n        setString(EDITOR_KEY, value);\n    }\n\n    /**\n     * Adds a file to the list of recent files\n     *\n     * @param file\n     */\n    public void addRecentFile(File file) {\n        if (!recentFileListContains(file)) {\n            List<String> fileList = getRecentFilesList();\n            // check size constraint and add accordingly\n            if (fileList.size() == getRecentFilesMax()) {\n                for (int i = 0; i < fileList.size() - 1; i++) {\n                    fileList.set(i, fileList.get(i + 1));\n                }\n                fileList.set(fileList.size() - 1, file.getAbsolutePath());\n            } else {\n                fileList.add(file.getAbsolutePath());\n            }\n            setEnumeratedProperty(RECENT_FILES_KEY, fileList);\n        }\n    }\n\n    /**\n     * Get an array of recently opened files\n     *\n     * @return File[] File array of followed files\n     */\n    public List<File> getRecentFiles() {\n        return getFiles(getRecentFilesList());\n    }\n\n    public int getRecentFilesMax() {\n        return getInt(RECENT_FILES_MAX_KEY);\n    }\n\n    public void setRecentFilesMax(String max) {\n        setRecentFilesMax(Integer.parseInt(max));\n    }\n\n    public void setRecentFilesMax(int max) {\n        List<String> files = getRecentFilesList();\n        if (files.size() > max) {\n            for (int i = files.size() - max; i > 0; i--) {\n                files.remove(0);\n            }\n            setEnumeratedProperty(RECENT_FILES_KEY, files);\n        }\n        setInt(RECENT_FILES_MAX_KEY, max);\n    }\n\n    public File getPropertyFile() {\n        return propertyFile;\n    }\n\n    public void store() throws IOException {\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(defaultPropertyFileName));\n        properties.store(bos, null);\n        // close this stream.  no need to flush it since Properties.store(..) does that\n        bos.close();\n    }\n\n    // The listener list wrapper methods.\n    public synchronized void addPropertyChangeListener(PropertyChangeListener listener) {\n        pcs.addPropertyChangeListener(listener);\n    }\n\n    public synchronized void addPropertyChangeListener(String prop, PropertyChangeListener listener) {\n        pcs.addPropertyChangeListener(prop, listener);\n    }\n\n    public synchronized void removePropertyChangeListener(PropertyChangeListener listener) {\n        pcs.removePropertyChangeListener(listener);\n    }\n\n    public synchronized void removePropertyChangeListener(String prop, PropertyChangeListener listener) {\n        pcs.removePropertyChangeListener(prop, listener);\n    }\n\n    public FollowAppAttributes getDefaultAttributes() throws IOException {\n        if (defaultAttributes == null) {\n            defaultAttributes = new FollowAppAttributes(getDefaultProperties());\n            // Check for the unlikely possibility that the default font is\n            // unavailable\n            Font defaultFont = defaultAttributes.getFont();\n            String[] availableFontFamilyNames = GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames();\n            boolean defaultFontIsAvailable = false;\n            for (int i = 0; i < availableFontFamilyNames.length; i++) {\n                if (defaultFont.getFamily().equals(availableFontFamilyNames[i])) {\n                    defaultFontIsAvailable = true;\n                    break;\n                }\n            }\n            if (!defaultFontIsAvailable) {\n                log.info(\"Font family \" + defaultFont.getFamily() + \" is unavailable; using \" + availableFontFamilyNames[0] + \" instead.\");\n                defaultAttributes.setFont(new Font(availableFontFamilyNames[0], defaultFont.getStyle(), defaultFont.getSize()));\n            }\n        }\n        return defaultAttributes;\n    }\n\n    /**\n     * Get a list of recently opened files\n     *\n     * @return List recently opened files as Strings\n     */\n    private List<String> getRecentFilesList() {\n        return getEnumeratedProperty(RECENT_FILES_KEY);\n    }\n\n    private int getInt(String key) {\n        int retval = 0;\n        String s = getString(key);\n        if (s != null)\n            retval = Integer.parseInt(getString(key));\n        return retval;\n    }\n\n    private void setInt(String key, int value) {\n        int oldValue = getInt(key);\n        properties.setProperty(key, String.valueOf(value));\n        pcs.firePropertyChange(key, oldValue, value);\n    }\n\n    private boolean getBoolean(String key) {\n        return \"true\".equals(getString(key));\n    }\n\n    private void setBoolean(String key, boolean value) {\n        boolean oldValue = getBoolean(key);\n        properties.setProperty(key, String.valueOf(value));\n        pcs.firePropertyChange(key, oldValue, value);\n    }\n\n    private String getString(String key) {\n        return properties.getProperty(key);\n    }\n\n    private void setString(String key, String value) {\n        String oldValue = getString(key);\n        properties.setProperty(key, value);\n        pcs.firePropertyChange(key, oldValue, value);\n    }\n\n    private List<String> getEnumeratedProperty(String key) {\n        return properties.getEnumeratedProperty(key);\n    }\n\n    private void setEnumeratedProperty(String key, List<String> values) {\n        List<String> oldValue = getEnumeratedProperty(key);\n        properties.setEnumeratedProperty(key, values);\n        pcs.firePropertyChange(key, oldValue, values);\n    }\n\n    private EnumeratedProperties getDefaultProperties() throws IOException {\n        if (defaultProperties == null) {\n            InputStream in = this.getClass().getResourceAsStream(PROPERTY_PROTOTYPE_FILE_NAME);\n            BufferedInputStream bis = new BufferedInputStream(in);\n            FileOutputStream fos = new FileOutputStream(propertyFile);\n            BufferedOutputStream bos = new BufferedOutputStream(fos);\n            byte[] byteArray = new byte[BUFFER_SIZE];\n            int len;\n            while ((len = bis.read(byteArray, 0, BUFFER_SIZE)) > 0) {\n                bos.write(byteArray, 0, len);\n            }\n            bos.flush();\n            bos.close();\n            bis.close();\n            defaultProperties = new EnumeratedProperties();\n            defaultProperties.load(new BufferedInputStream(new FileInputStream(propertyFile)));\n        }\n        return defaultProperties;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/config/FollowAppAttributesTest2.java",
		"test_prompt": "// FollowAppAttributesTest2.java\npackage ghm.follow.config;\n\nimport ghm.follow.FollowApp;\nimport java.awt.Font;\nimport java.awt.GraphicsEnvironment;\nimport java.beans.PropertyChangeListener;\nimport java.beans.PropertyChangeSupport;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.List;\nimport javax.swing.JOptionPane;\nimport java.util.logging.Logger;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FollowAppAttributes}.\n* It contains ten unit test cases for the {@link FollowAppAttributes#confirmDelete()} method.\n*/\nclass FollowAppAttributesTest2 {"
	},
	{
		"original_code": "// FollowAppAttributes.java\n/*\n * Copyright (C) 2000-2003 Greg Merrill (greghmerrill@yahoo.com)\n * \n * This file is part of Follow (http://follow.sf.net).\n * \n * Follow is free software; you can redistribute it and/or modify it under the\n * terms of version 2 of the GNU General Public License as published by the Free\n * Software Foundation.\n * \n * Follow is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License along with\n * Follow; if not, write to the Free Software Foundation, Inc., 59 Temple Place,\n * Suite 330, Boston, MA 02111-1307 USA\n */\npackage ghm.follow.config;\n\nimport ghm.follow.FollowApp;\nimport java.awt.Font;\nimport java.awt.GraphicsEnvironment;\nimport java.beans.PropertyChangeListener;\nimport java.beans.PropertyChangeSupport;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.List;\nimport javax.swing.JOptionPane;\nimport java.util.logging.Logger;\n\n/**\n * @author <a href=\"mailto:greghmerrill@yahoo.com\">Greg Merrill</a>\n */\npublic class FollowAppAttributes {\n\n    private static Logger log = Logger.getLogger(FollowAppAttributes.class.getName());\n\n    EnumeratedProperties properties;\n\n    private EnumeratedProperties defaultProperties;\n\n    private FollowAppAttributes defaultAttributes;\n\n    static final String userHome = System.getProperty(\"user.home\");\n\n    public static final String PROPERTY_FILE_NAME = \".followApp.properties\";\n\n    static final String defaultPropertyFileName = userHome + FollowApp.FILE_SEPARATOR + PROPERTY_FILE_NAME;\n\n    private File propertyFile;\n\n    public static final String PROPERTY_PROTOTYPE_FILE_NAME = \"followApp.properties.prototype\";\n\n    public static final int BUFFER_SIZE = 32768;\n\n    public static final String HEIGHT_KEY = \"height\";\n\n    public static final String WIDTH_KEY = \"width\";\n\n    public static final String X_KEY = \"x\";\n\n    public static final String Y_KEY = \"y\";\n\n    public static final String FOLLOWED_FILES_KEY = \"followedFiles\";\n\n    public static final String TAB_PLACEMENT_KEY = \"tabs.placement\";\n\n    public static final String SELECTED_TAB_INDEX_KEY = \"tabs.selectedIndex\";\n\n    public static final String LAST_FILE_CHOOSER_DIR_KEY = \"fileChooser.lastDir\";\n\n    public static final String BUFFER_SIZE_KEY = \"bufferSize\";\n\n    public static final String LATENCY_KEY = \"latency\";\n\n    public static final String ATTRIBUTES_VERSION_KEY = \"attributesVersion\";\n\n    public static final String FONT_FAMILY_KEY = \"fontFamily\";\n\n    public static final String FONT_STYLE_KEY = \"fontStyle\";\n\n    public static final String FONT_SIZE_KEY = \"fontSize\";\n\n    public static final String CONFIRM_DELETE_KEY = \"confirmDelete\";\n\n    public static final String CONFIRM_DELETE_ALL_KEY = \"confirmDeleteAll\";\n\n    public static final String AUTO_SCROLL_KEY = \"autoScroll\";\n\n    public static final String EDITOR_KEY = \"editor\";\n\n    public static final String TAB_SIZE_KEY = \"tabSize\";\n\n    public static final String RECENT_FILES_MAX_KEY = \"recentFilesMax\";\n\n    public static final String RECENT_FILES_KEY = \"recentFiles\";\n\n    // Versions\n    public static final int UNVERSIONED = 0;\n\n    public static final int v1_1 = 1;\n\n    public static final int v1_2 = 2;\n\n    public static final int v1_3 = 3;\n\n    public static final int v1_3_2 = 4;\n\n    public static final int v1_4 = 5;\n\n    public static final int v1_5_0 = 6;\n\n    public static final int v1_6_0 = 7;\n\n    private PropertyChangeSupport pcs = new PropertyChangeSupport(this);\n\n    public FollowAppAttributes() throws IOException {\n        // have to cast null so that the constructor call isn't ambiguous\n        this((File) null);\n    }\n\n    public FollowAppAttributes(File exitingPropertyFile) throws IOException {\n        if (exitingPropertyFile != null) {\n            propertyFile = exitingPropertyFile;\n        } else {\n            propertyFile = new File(defaultPropertyFileName);\n        }\n        if (!(propertyFile.exists())) {\n            // If the property file doesn't exist, we create a default property\n            // file using a prototype property file stored somewhere on the\n            // classpath\n            log.info(\"No property file for the Follow application is present; creating \" + propertyFile.getAbsolutePath() + \" (with default values) ...\");\n            properties = (EnumeratedProperties) getDefaultProperties().clone();\n            log.info(\"... property file created successfully.\");\n        } else {\n            properties = new EnumeratedProperties();\n            FileInputStream fis = new FileInputStream(propertyFile);\n            properties.load(fis);\n            switch(getAttributesVersion()) {\n                case UNVERSIONED:\n                    // Migrate unversioned attributes to 1.1 attributes\n                    log.info(\"Migrating pre-v1.1 properties to v1.1.\");\n                    setAttributesVersion(v1_1);\n                    setTabPlacement(getDefaultAttributes().getTabPlacement());\n                case v1_1:\n                    // Migrate 1.1 attributes to 1.2 attributes\n                    log.info(\"Migrating v1.1 properties to v1.2.\");\n                    setAttributesVersion(v1_2);\n                    setFont(getDefaultAttributes().getFont());\n                case v1_2:\n                    // Migrate 1.2 attributes to 1.3 attributes\n                    log.info(\"Migrating v1.2 properties to v1.3.\");\n                    setAttributesVersion(v1_3);\n                    setConfirmDelete(true);\n                    setConfirmDeleteAll(true);\n                    // Additionally, it is necessary to warn the user about the\n                    // changes to\n                    // Clear and ClearAll and the introduction of Delete and\n                    // DeleteAll\n                    JOptionPane.showMessageDialog(null, FollowApp.getResourceString(\"v1.3.warning.text\"), FollowApp.getResourceString(\"v1.3.warning.title\"), JOptionPane.WARNING_MESSAGE);\n                case v1_3:\n                case v1_3_2:\n                    // Migrate 1.3 attributes to 1.4 attributes\n                    log.info(\"Migrating v1.3 properties to v1.4.\");\n                    setAttributesVersion(v1_4);\n                    setAutoScroll(true);\n                    // Inform the user of the new AutoScroll feature\n                    JOptionPane.showMessageDialog(null, FollowApp.getResourceString(\"v1.4.info.text\"), FollowApp.getResourceString(\"v1.4.info.title\"), JOptionPane.INFORMATION_MESSAGE);\n                case v1_4:\n                    // Migrate 1.4 attributes to 1.5 attributes\n                    log.info(\"Migrating v1.4 properties to v.1.5.\");\n                    setAttributesVersion(v1_5_0);\n                    setTabSize(4);\n                case v1_5_0:\n                    // Migrate 1.5.0 attributes to 1.6.0 attributes\n                    log.info(\"Migrating v1.5 properties to 1.6.0.\");\n                    setAttributesVersion(v1_6_0);\n                    setRecentFilesMax(5);\n            }\n            fis.close();\n        }\n    }\n\n    private FollowAppAttributes(EnumeratedProperties props) throws IOException {\n        properties = props;\n    }\n\n    public int getHeight() {\n        return getInt(HEIGHT_KEY);\n    }\n\n    public void setHeight(int height) {\n        setInt(HEIGHT_KEY, height);\n    }\n\n    public int getWidth() {\n        return getInt(WIDTH_KEY);\n    }\n\n    public void setWidth(int width) {\n        setInt(WIDTH_KEY, width);\n    }\n\n    public int getX() {\n        return getInt(X_KEY);\n    }\n\n    public void setX(int x) {\n        setInt(X_KEY, x);\n    }\n\n    public int getY() {\n        return getInt(Y_KEY);\n    }\n\n    public void setY(int y) {\n        setInt(Y_KEY, y);\n    }\n\n    /**\n     * Get an array files being followed\n     *\n     * @return File[] File array of followed files\n     */\n    public List<File> getFollowedFiles() {\n        return getFiles(getFollowedFilesList());\n    }\n\n    /**\n     * Get a list of files being followed\n     *\n     * @return List file names as Strings\n     */\n    private List<String> getFollowedFilesList() {\n        return getEnumeratedProperty(FOLLOWED_FILES_KEY);\n    }\n\n    protected List<File> getFiles(List<String> fileList) {\n        ArrayList<File> files = new ArrayList<File>(fileList.size());\n        for (String s : fileList) {\n            files.add(new File(s));\n        }\n        return files;\n    }\n\n    /**\n     * Checks the existence of a file in the list of followed files\n     *\n     * @return true iff any File in the List of followed Files (getFollowedFiles()) has the same\n     *         Canonical Path as the supplied File\n     */\n    public boolean followedFileListContains(File file) {\n        return fileListContains(getFollowedFilesList(), file);\n    }\n\n    /**\n     * Checks the existence of a file in the list of recent files\n     *\n     * @return true iff any File in the List of recent Files (getFollowedFiles()) has the same\n     *         Canonical Path as the supplied File\n     */\n    public boolean recentFileListContains(File file) {\n        return fileListContains(getRecentFilesList(), file);\n    }\n\n    /**\n     * @return true iff any File in the List of Files (getFollowedFiles()) has the same Canonical\n     *         Path as the supplied File\n     */\n    protected boolean fileListContains(List<String> fileList, File file) {\n        boolean retval = false;\n        if (fileList != null && file != null) {\n            for (int i = 0; i < fileList.size(); i++) {\n                String nextFile = (String) fileList.get(i);\n                // be sure to check the same thing that is added in\n                // addFollowedFile(File)\n                if (nextFile.equals(file.getAbsolutePath())) {\n                    retval = true;\n                    break;\n                }\n            }\n        }\n        return retval;\n    }\n\n    /**\n     * Adds a file to the list of followed files\n     *\n     * @param file\n     */\n    public void addFollowedFile(File file) {\n        List<String> fileNames = getEnumeratedProperty(FOLLOWED_FILES_KEY);\n        if (!fileListContains(fileNames, file)) {\n            fileNames.add(file.getAbsolutePath());\n            setEnumeratedProperty(FOLLOWED_FILES_KEY, fileNames);\n        }\n    }\n\n    /**\n     * Removes a file from the list of followed files\n     *\n     * @param file\n     */\n    public void removeFollowedFile(File file) {\n        List<String> fileNames = getEnumeratedProperty(FOLLOWED_FILES_KEY);\n        fileNames.remove(file.getAbsolutePath());\n        setEnumeratedProperty(FOLLOWED_FILES_KEY, fileNames);\n    }\n\n    public int getTabPlacement() {\n        return getInt(TAB_PLACEMENT_KEY);\n    }\n\n    public void setTabPlacement(int tabPlacement) {\n        setInt(TAB_PLACEMENT_KEY, tabPlacement);\n    }\n\n    public int getTabSize() {\n        return getInt(TAB_SIZE_KEY);\n    }\n\n    public void setTabSize(int tabSize) {\n        setInt(TAB_SIZE_KEY, tabSize);\n    }\n\n    public void setTabSize(String tabSize) {\n        setTabSize(Integer.parseInt(tabSize));\n    }\n\n    public int getSelectedTabIndex() {\n        try {\n            return getInt(SELECTED_TAB_INDEX_KEY);\n        } catch (NumberFormatException e) {\n            setSelectedTabIndex(0);\n            return 0;\n        }\n    }\n\n    public void setSelectedTabIndex(int selectedTabIndex) {\n        setInt(SELECTED_TAB_INDEX_KEY, selectedTabIndex);\n    }\n\n    public File getLastFileChooserDirectory() {\n        return new File(properties.getProperty(LAST_FILE_CHOOSER_DIR_KEY, userHome));\n    }\n\n    public void setLastFileChooserDirectory(File file) {\n        setString(LAST_FILE_CHOOSER_DIR_KEY, file.getAbsolutePath());\n    }\n\n    public int getBufferSize() {\n        return getInt(BUFFER_SIZE_KEY);\n    }\n\n    public void setBufferSize(int bufferSize) {\n        setInt(BUFFER_SIZE_KEY, bufferSize);\n    }\n\n    public void setBufferSize(String bufferSize) {\n        setBufferSize(Integer.parseInt(bufferSize));\n    }\n\n    public int getLatency() {\n        return getInt(LATENCY_KEY);\n    }\n\n    public void setLatency(int latency) {\n        setInt(LATENCY_KEY, latency);\n    }\n\n    public void setLatency(String latency) {\n        setLatency(Integer.parseInt(latency));\n    }\n\n    public int getAttributesVersion() {\n        if (properties.get(ATTRIBUTES_VERSION_KEY) == null) {\n            // Supporting v1.0 & v1.0.1, which had no notion of attributes\n            // version\n            return UNVERSIONED;\n        } else {\n            return getInt(ATTRIBUTES_VERSION_KEY);\n        }\n    }\n\n    public void setAttributesVersion(int attributesVersion) {\n        setInt(ATTRIBUTES_VERSION_KEY, attributesVersion);\n    }\n\n    public Font getFont() {\n        Font font = new Font(getString(FONT_FAMILY_KEY), getInt(FONT_STYLE_KEY), getInt(FONT_SIZE_KEY));\n        return font;\n    }\n\n    public void setFont(Font font) {\n        setString(FONT_FAMILY_KEY, font.getFontName());\n        setInt(FONT_STYLE_KEY, font.getStyle());\n        setInt(FONT_SIZE_KEY, font.getSize());\n    }\n\n    public boolean confirmDelete() {\n        return getBoolean(CONFIRM_DELETE_KEY);\n    }\n\n    public void setConfirmDelete(boolean value) {\n        setBoolean(CONFIRM_DELETE_KEY, value);\n    }\n\n    public boolean confirmDeleteAll() {\n        return getBoolean(CONFIRM_DELETE_ALL_KEY);\n    }\n\n    public void setConfirmDeleteAll(boolean value) {\n        setBoolean(CONFIRM_DELETE_ALL_KEY, value);\n    }\n\n    public boolean autoScroll() {\n        return getBoolean(AUTO_SCROLL_KEY);\n    }\n\n    public void setAutoScroll(boolean value) {\n        setBoolean(AUTO_SCROLL_KEY, value);\n    }\n\n    public String getEditor() {\n        String result = getString(EDITOR_KEY);\n        if (result == null) {\n            result = \"\";\n        }\n        return (result);\n    }\n\n    public void setEditor(String value) {\n        setString(EDITOR_KEY, value);\n    }\n\n    /**\n     * Adds a file to the list of recent files\n     *\n     * @param file\n     */\n    public void addRecentFile(File file) {\n        if (!recentFileListContains(file)) {\n            List<String> fileList = getRecentFilesList();\n            // check size constraint and add accordingly\n            if (fileList.size() == getRecentFilesMax()) {\n                for (int i = 0; i < fileList.size() - 1; i++) {\n                    fileList.set(i, fileList.get(i + 1));\n                }\n                fileList.set(fileList.size() - 1, file.getAbsolutePath());\n            } else {\n                fileList.add(file.getAbsolutePath());\n            }\n            setEnumeratedProperty(RECENT_FILES_KEY, fileList);\n        }\n    }\n\n    /**\n     * Get an array of recently opened files\n     *\n     * @return File[] File array of followed files\n     */\n    public List<File> getRecentFiles() {\n        return getFiles(getRecentFilesList());\n    }\n\n    public int getRecentFilesMax() {\n        return getInt(RECENT_FILES_MAX_KEY);\n    }\n\n    public void setRecentFilesMax(String max) {\n        setRecentFilesMax(Integer.parseInt(max));\n    }\n\n    public void setRecentFilesMax(int max) {\n        List<String> files = getRecentFilesList();\n        if (files.size() > max) {\n            for (int i = files.size() - max; i > 0; i--) {\n                files.remove(0);\n            }\n            setEnumeratedProperty(RECENT_FILES_KEY, files);\n        }\n        setInt(RECENT_FILES_MAX_KEY, max);\n    }\n\n    public File getPropertyFile() {\n        return propertyFile;\n    }\n\n    public void store() throws IOException {\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(defaultPropertyFileName));\n        properties.store(bos, null);\n        // close this stream.  no need to flush it since Properties.store(..) does that\n        bos.close();\n    }\n\n    // The listener list wrapper methods.\n    public synchronized void addPropertyChangeListener(PropertyChangeListener listener) {\n        pcs.addPropertyChangeListener(listener);\n    }\n\n    public synchronized void addPropertyChangeListener(String prop, PropertyChangeListener listener) {\n        pcs.addPropertyChangeListener(prop, listener);\n    }\n\n    public synchronized void removePropertyChangeListener(PropertyChangeListener listener) {\n        pcs.removePropertyChangeListener(listener);\n    }\n\n    public synchronized void removePropertyChangeListener(String prop, PropertyChangeListener listener) {\n        pcs.removePropertyChangeListener(prop, listener);\n    }\n\n    public FollowAppAttributes getDefaultAttributes() throws IOException {\n        if (defaultAttributes == null) {\n            defaultAttributes = new FollowAppAttributes(getDefaultProperties());\n            // Check for the unlikely possibility that the default font is\n            // unavailable\n            Font defaultFont = defaultAttributes.getFont();\n            String[] availableFontFamilyNames = GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames();\n            boolean defaultFontIsAvailable = false;\n            for (int i = 0; i < availableFontFamilyNames.length; i++) {\n                if (defaultFont.getFamily().equals(availableFontFamilyNames[i])) {\n                    defaultFontIsAvailable = true;\n                    break;\n                }\n            }\n            if (!defaultFontIsAvailable) {\n                log.info(\"Font family \" + defaultFont.getFamily() + \" is unavailable; using \" + availableFontFamilyNames[0] + \" instead.\");\n                defaultAttributes.setFont(new Font(availableFontFamilyNames[0], defaultFont.getStyle(), defaultFont.getSize()));\n            }\n        }\n        return defaultAttributes;\n    }\n\n    /**\n     * Get a list of recently opened files\n     *\n     * @return List recently opened files as Strings\n     */\n    private List<String> getRecentFilesList() {\n        return getEnumeratedProperty(RECENT_FILES_KEY);\n    }\n\n    private int getInt(String key) {\n        int retval = 0;\n        String s = getString(key);\n        if (s != null)\n            retval = Integer.parseInt(getString(key));\n        return retval;\n    }\n\n    private void setInt(String key, int value) {\n        int oldValue = getInt(key);\n        properties.setProperty(key, String.valueOf(value));\n        pcs.firePropertyChange(key, oldValue, value);\n    }\n\n    private boolean getBoolean(String key) {\n        return \"true\".equals(getString(key));\n    }\n\n    private void setBoolean(String key, boolean value) {\n        boolean oldValue = getBoolean(key);\n        properties.setProperty(key, String.valueOf(value));\n        pcs.firePropertyChange(key, oldValue, value);\n    }\n\n    private String getString(String key) {\n        return properties.getProperty(key);\n    }\n\n    private void setString(String key, String value) {\n        String oldValue = getString(key);\n        properties.setProperty(key, value);\n        pcs.firePropertyChange(key, oldValue, value);\n    }\n\n    private List<String> getEnumeratedProperty(String key) {\n        return properties.getEnumeratedProperty(key);\n    }\n\n    private void setEnumeratedProperty(String key, List<String> values) {\n        List<String> oldValue = getEnumeratedProperty(key);\n        properties.setEnumeratedProperty(key, values);\n        pcs.firePropertyChange(key, oldValue, values);\n    }\n\n    private EnumeratedProperties getDefaultProperties() throws IOException {\n        if (defaultProperties == null) {\n            InputStream in = this.getClass().getResourceAsStream(PROPERTY_PROTOTYPE_FILE_NAME);\n            BufferedInputStream bis = new BufferedInputStream(in);\n            FileOutputStream fos = new FileOutputStream(propertyFile);\n            BufferedOutputStream bos = new BufferedOutputStream(fos);\n            byte[] byteArray = new byte[BUFFER_SIZE];\n            int len;\n            while ((len = bis.read(byteArray, 0, BUFFER_SIZE)) > 0) {\n                bos.write(byteArray, 0, len);\n            }\n            bos.flush();\n            bos.close();\n            bis.close();\n            defaultProperties = new EnumeratedProperties();\n            defaultProperties.load(new BufferedInputStream(new FileInputStream(propertyFile)));\n        }\n        return defaultProperties;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/config/FollowAppAttributesTest3.java",
		"test_prompt": "// FollowAppAttributesTest3.java\npackage ghm.follow.config;\n\nimport ghm.follow.FollowApp;\nimport java.awt.Font;\nimport java.awt.GraphicsEnvironment;\nimport java.beans.PropertyChangeListener;\nimport java.beans.PropertyChangeSupport;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.List;\nimport javax.swing.JOptionPane;\nimport java.util.logging.Logger;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FollowAppAttributes}.\n* It contains ten unit test cases for the {@link FollowAppAttributes#confirmDeleteAll()} method.\n*/\nclass FollowAppAttributesTest3 {"
	},
	{
		"original_code": "// FollowAppAttributes.java\n/*\n * Copyright (C) 2000-2003 Greg Merrill (greghmerrill@yahoo.com)\n * \n * This file is part of Follow (http://follow.sf.net).\n * \n * Follow is free software; you can redistribute it and/or modify it under the\n * terms of version 2 of the GNU General Public License as published by the Free\n * Software Foundation.\n * \n * Follow is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License along with\n * Follow; if not, write to the Free Software Foundation, Inc., 59 Temple Place,\n * Suite 330, Boston, MA 02111-1307 USA\n */\npackage ghm.follow.config;\n\nimport ghm.follow.FollowApp;\nimport java.awt.Font;\nimport java.awt.GraphicsEnvironment;\nimport java.beans.PropertyChangeListener;\nimport java.beans.PropertyChangeSupport;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.List;\nimport javax.swing.JOptionPane;\nimport java.util.logging.Logger;\n\n/**\n * @author <a href=\"mailto:greghmerrill@yahoo.com\">Greg Merrill</a>\n */\npublic class FollowAppAttributes {\n\n    private static Logger log = Logger.getLogger(FollowAppAttributes.class.getName());\n\n    EnumeratedProperties properties;\n\n    private EnumeratedProperties defaultProperties;\n\n    private FollowAppAttributes defaultAttributes;\n\n    static final String userHome = System.getProperty(\"user.home\");\n\n    public static final String PROPERTY_FILE_NAME = \".followApp.properties\";\n\n    static final String defaultPropertyFileName = userHome + FollowApp.FILE_SEPARATOR + PROPERTY_FILE_NAME;\n\n    private File propertyFile;\n\n    public static final String PROPERTY_PROTOTYPE_FILE_NAME = \"followApp.properties.prototype\";\n\n    public static final int BUFFER_SIZE = 32768;\n\n    public static final String HEIGHT_KEY = \"height\";\n\n    public static final String WIDTH_KEY = \"width\";\n\n    public static final String X_KEY = \"x\";\n\n    public static final String Y_KEY = \"y\";\n\n    public static final String FOLLOWED_FILES_KEY = \"followedFiles\";\n\n    public static final String TAB_PLACEMENT_KEY = \"tabs.placement\";\n\n    public static final String SELECTED_TAB_INDEX_KEY = \"tabs.selectedIndex\";\n\n    public static final String LAST_FILE_CHOOSER_DIR_KEY = \"fileChooser.lastDir\";\n\n    public static final String BUFFER_SIZE_KEY = \"bufferSize\";\n\n    public static final String LATENCY_KEY = \"latency\";\n\n    public static final String ATTRIBUTES_VERSION_KEY = \"attributesVersion\";\n\n    public static final String FONT_FAMILY_KEY = \"fontFamily\";\n\n    public static final String FONT_STYLE_KEY = \"fontStyle\";\n\n    public static final String FONT_SIZE_KEY = \"fontSize\";\n\n    public static final String CONFIRM_DELETE_KEY = \"confirmDelete\";\n\n    public static final String CONFIRM_DELETE_ALL_KEY = \"confirmDeleteAll\";\n\n    public static final String AUTO_SCROLL_KEY = \"autoScroll\";\n\n    public static final String EDITOR_KEY = \"editor\";\n\n    public static final String TAB_SIZE_KEY = \"tabSize\";\n\n    public static final String RECENT_FILES_MAX_KEY = \"recentFilesMax\";\n\n    public static final String RECENT_FILES_KEY = \"recentFiles\";\n\n    // Versions\n    public static final int UNVERSIONED = 0;\n\n    public static final int v1_1 = 1;\n\n    public static final int v1_2 = 2;\n\n    public static final int v1_3 = 3;\n\n    public static final int v1_3_2 = 4;\n\n    public static final int v1_4 = 5;\n\n    public static final int v1_5_0 = 6;\n\n    public static final int v1_6_0 = 7;\n\n    private PropertyChangeSupport pcs = new PropertyChangeSupport(this);\n\n    public FollowAppAttributes() throws IOException {\n        // have to cast null so that the constructor call isn't ambiguous\n        this((File) null);\n    }\n\n    public FollowAppAttributes(File exitingPropertyFile) throws IOException {\n        if (exitingPropertyFile != null) {\n            propertyFile = exitingPropertyFile;\n        } else {\n            propertyFile = new File(defaultPropertyFileName);\n        }\n        if (!(propertyFile.exists())) {\n            // If the property file doesn't exist, we create a default property\n            // file using a prototype property file stored somewhere on the\n            // classpath\n            log.info(\"No property file for the Follow application is present; creating \" + propertyFile.getAbsolutePath() + \" (with default values) ...\");\n            properties = (EnumeratedProperties) getDefaultProperties().clone();\n            log.info(\"... property file created successfully.\");\n        } else {\n            properties = new EnumeratedProperties();\n            FileInputStream fis = new FileInputStream(propertyFile);\n            properties.load(fis);\n            switch(getAttributesVersion()) {\n                case UNVERSIONED:\n                    // Migrate unversioned attributes to 1.1 attributes\n                    log.info(\"Migrating pre-v1.1 properties to v1.1.\");\n                    setAttributesVersion(v1_1);\n                    setTabPlacement(getDefaultAttributes().getTabPlacement());\n                case v1_1:\n                    // Migrate 1.1 attributes to 1.2 attributes\n                    log.info(\"Migrating v1.1 properties to v1.2.\");\n                    setAttributesVersion(v1_2);\n                    setFont(getDefaultAttributes().getFont());\n                case v1_2:\n                    // Migrate 1.2 attributes to 1.3 attributes\n                    log.info(\"Migrating v1.2 properties to v1.3.\");\n                    setAttributesVersion(v1_3);\n                    setConfirmDelete(true);\n                    setConfirmDeleteAll(true);\n                    // Additionally, it is necessary to warn the user about the\n                    // changes to\n                    // Clear and ClearAll and the introduction of Delete and\n                    // DeleteAll\n                    JOptionPane.showMessageDialog(null, FollowApp.getResourceString(\"v1.3.warning.text\"), FollowApp.getResourceString(\"v1.3.warning.title\"), JOptionPane.WARNING_MESSAGE);\n                case v1_3:\n                case v1_3_2:\n                    // Migrate 1.3 attributes to 1.4 attributes\n                    log.info(\"Migrating v1.3 properties to v1.4.\");\n                    setAttributesVersion(v1_4);\n                    setAutoScroll(true);\n                    // Inform the user of the new AutoScroll feature\n                    JOptionPane.showMessageDialog(null, FollowApp.getResourceString(\"v1.4.info.text\"), FollowApp.getResourceString(\"v1.4.info.title\"), JOptionPane.INFORMATION_MESSAGE);\n                case v1_4:\n                    // Migrate 1.4 attributes to 1.5 attributes\n                    log.info(\"Migrating v1.4 properties to v.1.5.\");\n                    setAttributesVersion(v1_5_0);\n                    setTabSize(4);\n                case v1_5_0:\n                    // Migrate 1.5.0 attributes to 1.6.0 attributes\n                    log.info(\"Migrating v1.5 properties to 1.6.0.\");\n                    setAttributesVersion(v1_6_0);\n                    setRecentFilesMax(5);\n            }\n            fis.close();\n        }\n    }\n\n    private FollowAppAttributes(EnumeratedProperties props) throws IOException {\n        properties = props;\n    }\n\n    public int getHeight() {\n        return getInt(HEIGHT_KEY);\n    }\n\n    public void setHeight(int height) {\n        setInt(HEIGHT_KEY, height);\n    }\n\n    public int getWidth() {\n        return getInt(WIDTH_KEY);\n    }\n\n    public void setWidth(int width) {\n        setInt(WIDTH_KEY, width);\n    }\n\n    public int getX() {\n        return getInt(X_KEY);\n    }\n\n    public void setX(int x) {\n        setInt(X_KEY, x);\n    }\n\n    public int getY() {\n        return getInt(Y_KEY);\n    }\n\n    public void setY(int y) {\n        setInt(Y_KEY, y);\n    }\n\n    /**\n     * Get an array files being followed\n     *\n     * @return File[] File array of followed files\n     */\n    public List<File> getFollowedFiles() {\n        return getFiles(getFollowedFilesList());\n    }\n\n    /**\n     * Get a list of files being followed\n     *\n     * @return List file names as Strings\n     */\n    private List<String> getFollowedFilesList() {\n        return getEnumeratedProperty(FOLLOWED_FILES_KEY);\n    }\n\n    protected List<File> getFiles(List<String> fileList) {\n        ArrayList<File> files = new ArrayList<File>(fileList.size());\n        for (String s : fileList) {\n            files.add(new File(s));\n        }\n        return files;\n    }\n\n    /**\n     * Checks the existence of a file in the list of followed files\n     *\n     * @return true iff any File in the List of followed Files (getFollowedFiles()) has the same\n     *         Canonical Path as the supplied File\n     */\n    public boolean followedFileListContains(File file) {\n        return fileListContains(getFollowedFilesList(), file);\n    }\n\n    /**\n     * Checks the existence of a file in the list of recent files\n     *\n     * @return true iff any File in the List of recent Files (getFollowedFiles()) has the same\n     *         Canonical Path as the supplied File\n     */\n    public boolean recentFileListContains(File file) {\n        return fileListContains(getRecentFilesList(), file);\n    }\n\n    /**\n     * @return true iff any File in the List of Files (getFollowedFiles()) has the same Canonical\n     *         Path as the supplied File\n     */\n    protected boolean fileListContains(List<String> fileList, File file) {\n        boolean retval = false;\n        if (fileList != null && file != null) {\n            for (int i = 0; i < fileList.size(); i++) {\n                String nextFile = (String) fileList.get(i);\n                // be sure to check the same thing that is added in\n                // addFollowedFile(File)\n                if (nextFile.equals(file.getAbsolutePath())) {\n                    retval = true;\n                    break;\n                }\n            }\n        }\n        return retval;\n    }\n\n    /**\n     * Adds a file to the list of followed files\n     *\n     * @param file\n     */\n    public void addFollowedFile(File file) {\n        List<String> fileNames = getEnumeratedProperty(FOLLOWED_FILES_KEY);\n        if (!fileListContains(fileNames, file)) {\n            fileNames.add(file.getAbsolutePath());\n            setEnumeratedProperty(FOLLOWED_FILES_KEY, fileNames);\n        }\n    }\n\n    /**\n     * Removes a file from the list of followed files\n     *\n     * @param file\n     */\n    public void removeFollowedFile(File file) {\n        List<String> fileNames = getEnumeratedProperty(FOLLOWED_FILES_KEY);\n        fileNames.remove(file.getAbsolutePath());\n        setEnumeratedProperty(FOLLOWED_FILES_KEY, fileNames);\n    }\n\n    public int getTabPlacement() {\n        return getInt(TAB_PLACEMENT_KEY);\n    }\n\n    public void setTabPlacement(int tabPlacement) {\n        setInt(TAB_PLACEMENT_KEY, tabPlacement);\n    }\n\n    public int getTabSize() {\n        return getInt(TAB_SIZE_KEY);\n    }\n\n    public void setTabSize(int tabSize) {\n        setInt(TAB_SIZE_KEY, tabSize);\n    }\n\n    public void setTabSize(String tabSize) {\n        setTabSize(Integer.parseInt(tabSize));\n    }\n\n    public int getSelectedTabIndex() {\n        try {\n            return getInt(SELECTED_TAB_INDEX_KEY);\n        } catch (NumberFormatException e) {\n            setSelectedTabIndex(0);\n            return 0;\n        }\n    }\n\n    public void setSelectedTabIndex(int selectedTabIndex) {\n        setInt(SELECTED_TAB_INDEX_KEY, selectedTabIndex);\n    }\n\n    public File getLastFileChooserDirectory() {\n        return new File(properties.getProperty(LAST_FILE_CHOOSER_DIR_KEY, userHome));\n    }\n\n    public void setLastFileChooserDirectory(File file) {\n        setString(LAST_FILE_CHOOSER_DIR_KEY, file.getAbsolutePath());\n    }\n\n    public int getBufferSize() {\n        return getInt(BUFFER_SIZE_KEY);\n    }\n\n    public void setBufferSize(int bufferSize) {\n        setInt(BUFFER_SIZE_KEY, bufferSize);\n    }\n\n    public void setBufferSize(String bufferSize) {\n        setBufferSize(Integer.parseInt(bufferSize));\n    }\n\n    public int getLatency() {\n        return getInt(LATENCY_KEY);\n    }\n\n    public void setLatency(int latency) {\n        setInt(LATENCY_KEY, latency);\n    }\n\n    public void setLatency(String latency) {\n        setLatency(Integer.parseInt(latency));\n    }\n\n    public int getAttributesVersion() {\n        if (properties.get(ATTRIBUTES_VERSION_KEY) == null) {\n            // Supporting v1.0 & v1.0.1, which had no notion of attributes\n            // version\n            return UNVERSIONED;\n        } else {\n            return getInt(ATTRIBUTES_VERSION_KEY);\n        }\n    }\n\n    public void setAttributesVersion(int attributesVersion) {\n        setInt(ATTRIBUTES_VERSION_KEY, attributesVersion);\n    }\n\n    public Font getFont() {\n        Font font = new Font(getString(FONT_FAMILY_KEY), getInt(FONT_STYLE_KEY), getInt(FONT_SIZE_KEY));\n        return font;\n    }\n\n    public void setFont(Font font) {\n        setString(FONT_FAMILY_KEY, font.getFontName());\n        setInt(FONT_STYLE_KEY, font.getStyle());\n        setInt(FONT_SIZE_KEY, font.getSize());\n    }\n\n    public boolean confirmDelete() {\n        return getBoolean(CONFIRM_DELETE_KEY);\n    }\n\n    public void setConfirmDelete(boolean value) {\n        setBoolean(CONFIRM_DELETE_KEY, value);\n    }\n\n    public boolean confirmDeleteAll() {\n        return getBoolean(CONFIRM_DELETE_ALL_KEY);\n    }\n\n    public void setConfirmDeleteAll(boolean value) {\n        setBoolean(CONFIRM_DELETE_ALL_KEY, value);\n    }\n\n    public boolean autoScroll() {\n        return getBoolean(AUTO_SCROLL_KEY);\n    }\n\n    public void setAutoScroll(boolean value) {\n        setBoolean(AUTO_SCROLL_KEY, value);\n    }\n\n    public String getEditor() {\n        String result = getString(EDITOR_KEY);\n        if (result == null) {\n            result = \"\";\n        }\n        return (result);\n    }\n\n    public void setEditor(String value) {\n        setString(EDITOR_KEY, value);\n    }\n\n    /**\n     * Adds a file to the list of recent files\n     *\n     * @param file\n     */\n    public void addRecentFile(File file) {\n        if (!recentFileListContains(file)) {\n            List<String> fileList = getRecentFilesList();\n            // check size constraint and add accordingly\n            if (fileList.size() == getRecentFilesMax()) {\n                for (int i = 0; i < fileList.size() - 1; i++) {\n                    fileList.set(i, fileList.get(i + 1));\n                }\n                fileList.set(fileList.size() - 1, file.getAbsolutePath());\n            } else {\n                fileList.add(file.getAbsolutePath());\n            }\n            setEnumeratedProperty(RECENT_FILES_KEY, fileList);\n        }\n    }\n\n    /**\n     * Get an array of recently opened files\n     *\n     * @return File[] File array of followed files\n     */\n    public List<File> getRecentFiles() {\n        return getFiles(getRecentFilesList());\n    }\n\n    public int getRecentFilesMax() {\n        return getInt(RECENT_FILES_MAX_KEY);\n    }\n\n    public void setRecentFilesMax(String max) {\n        setRecentFilesMax(Integer.parseInt(max));\n    }\n\n    public void setRecentFilesMax(int max) {\n        List<String> files = getRecentFilesList();\n        if (files.size() > max) {\n            for (int i = files.size() - max; i > 0; i--) {\n                files.remove(0);\n            }\n            setEnumeratedProperty(RECENT_FILES_KEY, files);\n        }\n        setInt(RECENT_FILES_MAX_KEY, max);\n    }\n\n    public File getPropertyFile() {\n        return propertyFile;\n    }\n\n    public void store() throws IOException {\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(defaultPropertyFileName));\n        properties.store(bos, null);\n        // close this stream.  no need to flush it since Properties.store(..) does that\n        bos.close();\n    }\n\n    // The listener list wrapper methods.\n    public synchronized void addPropertyChangeListener(PropertyChangeListener listener) {\n        pcs.addPropertyChangeListener(listener);\n    }\n\n    public synchronized void addPropertyChangeListener(String prop, PropertyChangeListener listener) {\n        pcs.addPropertyChangeListener(prop, listener);\n    }\n\n    public synchronized void removePropertyChangeListener(PropertyChangeListener listener) {\n        pcs.removePropertyChangeListener(listener);\n    }\n\n    public synchronized void removePropertyChangeListener(String prop, PropertyChangeListener listener) {\n        pcs.removePropertyChangeListener(prop, listener);\n    }\n\n    public FollowAppAttributes getDefaultAttributes() throws IOException {\n        if (defaultAttributes == null) {\n            defaultAttributes = new FollowAppAttributes(getDefaultProperties());\n            // Check for the unlikely possibility that the default font is\n            // unavailable\n            Font defaultFont = defaultAttributes.getFont();\n            String[] availableFontFamilyNames = GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames();\n            boolean defaultFontIsAvailable = false;\n            for (int i = 0; i < availableFontFamilyNames.length; i++) {\n                if (defaultFont.getFamily().equals(availableFontFamilyNames[i])) {\n                    defaultFontIsAvailable = true;\n                    break;\n                }\n            }\n            if (!defaultFontIsAvailable) {\n                log.info(\"Font family \" + defaultFont.getFamily() + \" is unavailable; using \" + availableFontFamilyNames[0] + \" instead.\");\n                defaultAttributes.setFont(new Font(availableFontFamilyNames[0], defaultFont.getStyle(), defaultFont.getSize()));\n            }\n        }\n        return defaultAttributes;\n    }\n\n    /**\n     * Get a list of recently opened files\n     *\n     * @return List recently opened files as Strings\n     */\n    private List<String> getRecentFilesList() {\n        return getEnumeratedProperty(RECENT_FILES_KEY);\n    }\n\n    private int getInt(String key) {\n        int retval = 0;\n        String s = getString(key);\n        if (s != null)\n            retval = Integer.parseInt(getString(key));\n        return retval;\n    }\n\n    private void setInt(String key, int value) {\n        int oldValue = getInt(key);\n        properties.setProperty(key, String.valueOf(value));\n        pcs.firePropertyChange(key, oldValue, value);\n    }\n\n    private boolean getBoolean(String key) {\n        return \"true\".equals(getString(key));\n    }\n\n    private void setBoolean(String key, boolean value) {\n        boolean oldValue = getBoolean(key);\n        properties.setProperty(key, String.valueOf(value));\n        pcs.firePropertyChange(key, oldValue, value);\n    }\n\n    private String getString(String key) {\n        return properties.getProperty(key);\n    }\n\n    private void setString(String key, String value) {\n        String oldValue = getString(key);\n        properties.setProperty(key, value);\n        pcs.firePropertyChange(key, oldValue, value);\n    }\n\n    private List<String> getEnumeratedProperty(String key) {\n        return properties.getEnumeratedProperty(key);\n    }\n\n    private void setEnumeratedProperty(String key, List<String> values) {\n        List<String> oldValue = getEnumeratedProperty(key);\n        properties.setEnumeratedProperty(key, values);\n        pcs.firePropertyChange(key, oldValue, values);\n    }\n\n    private EnumeratedProperties getDefaultProperties() throws IOException {\n        if (defaultProperties == null) {\n            InputStream in = this.getClass().getResourceAsStream(PROPERTY_PROTOTYPE_FILE_NAME);\n            BufferedInputStream bis = new BufferedInputStream(in);\n            FileOutputStream fos = new FileOutputStream(propertyFile);\n            BufferedOutputStream bos = new BufferedOutputStream(fos);\n            byte[] byteArray = new byte[BUFFER_SIZE];\n            int len;\n            while ((len = bis.read(byteArray, 0, BUFFER_SIZE)) > 0) {\n                bos.write(byteArray, 0, len);\n            }\n            bos.flush();\n            bos.close();\n            bis.close();\n            defaultProperties = new EnumeratedProperties();\n            defaultProperties.load(new BufferedInputStream(new FileInputStream(propertyFile)));\n        }\n        return defaultProperties;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/config/FollowAppAttributesTest4.java",
		"test_prompt": "// FollowAppAttributesTest4.java\npackage ghm.follow.config;\n\nimport ghm.follow.FollowApp;\nimport java.awt.Font;\nimport java.awt.GraphicsEnvironment;\nimport java.beans.PropertyChangeListener;\nimport java.beans.PropertyChangeSupport;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.List;\nimport javax.swing.JOptionPane;\nimport java.util.logging.Logger;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FollowAppAttributes}.\n* It contains ten unit test cases for the {@link FollowAppAttributes#autoScroll()} method.\n*/\nclass FollowAppAttributesTest4 {"
	},
	{
		"original_code": "// JTextPaneDestination.java\n/* \n Copyright (C) 2000-2003 Greg Merrill (greghmerrill@yahoo.com)\n\n This file is part of Follow (http://follow.sf.net).\n\n Follow is free software; you can redistribute it and/or modify\n it under the terms of version 2 of the GNU General Public\n License as published by the Free Software Foundation.\n\n Follow is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n\n You should have received a copy of the GNU General Public License\n along with Follow; if not, write to the Free Software\n Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\npackage ghm.follow.io;\n\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.swing.JTextPane;\nimport javax.swing.text.BadLocationException;\n\n/**\n * Implementation of {@link OutputDestination} which appends Strings to a {@link JTextPane}.\n *\n * @see OutputDestination\n * @see JTextPane\n * @author <a href=\"mailto:carl.hall@gmail.com\">Carl Hall</a>\n */\npublic class JTextPaneDestination implements OutputDestination {\n\n    private Logger log = Logger.getLogger(JTextPaneDestination.class.getName());\n\n    protected JTextPane jTextPane;\n\n    protected boolean autoPositionCaret;\n\n    /**\n     * Construct a new JTextPaneDestination.\n     *\n     * @param jTextPane\n     *            text will be appended to this text area\n     * @param autoPositionCaret\n     *            if true, caret will be automatically moved to the bottom of the text area when\n     *            text is appended\n     */\n    public JTextPaneDestination(JTextPane jTextPane, boolean autoPositionCaret) {\n        this.jTextPane = jTextPane;\n        this.autoPositionCaret = autoPositionCaret;\n    }\n\n    public JTextPane getJTextPane() {\n        return jTextPane;\n    }\n\n    public void setJTextArea(JTextPane jTextPane) {\n        this.jTextPane = jTextPane;\n    }\n\n    /**\n     * Add a filtered view to this destination. Filtered views show only a subset of the total\n     * output based on filter conditions.\n     *\n     * @since 1.8.0\n     */\n    public void addFilteredView() {\n    }\n\n    /**\n     * Remove a filtered view\n     *\n     * @since 1.8.0\n     */\n    public void removeFilteredView() {\n    }\n\n    /**\n     * @return whether caret will be automatically moved to the bottom of the text area when text is\n     *         appended\n     */\n    public boolean autoPositionCaret() {\n        return autoPositionCaret;\n    }\n\n    /**\n     * @param autoPositionCaret\n     *            if true, caret will be automatically moved to the bottom of the text area when\n     *            text is appended\n     */\n    public void setAutoPositionCaret(boolean autoPositionCaret) {\n        this.autoPositionCaret = autoPositionCaret;\n    }\n\n    public void print(String s) {\n        try {\n            jTextPane.getDocument().insertString(jTextPane.getDocument().getLength(), s, null);\n            if (autoPositionCaret) {\n                jTextPane.setCaretPosition(jTextPane.getDocument().getLength());\n            }\n        } catch (BadLocationException e) {\n            // just ignore, nothing we can do\n            log.log(Level.SEVERE, \"BadLocationException in JTextPaneDestination\", e);\n        }\n    }\n\n    public void clear() {\n        jTextPane.setText(\"\");\n        if (autoPositionCaret) {\n            jTextPane.setCaretPosition(0);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/io/JTextPaneDestinationTest.java",
		"test_prompt": "// JTextPaneDestinationTest.java\npackage ghm.follow.io;\n\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.swing.JTextPane;\nimport javax.swing.text.BadLocationException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JTextPaneDestination}.\n* It contains ten unit test cases for the {@link JTextPaneDestination#autoPositionCaret()} method.\n*/\nclass JTextPaneDestinationTest {"
	},
	{
		"original_code": "// JTextComponentDestination.java\n/* \n Copyright (C) 2000-2003 Greg Merrill (greghmerrill@yahoo.com)\n\n This file is part of Follow (http://follow.sf.net).\n\n Follow is free software; you can redistribute it and/or modify\n it under the terms of version 2 of the GNU General Public\n License as published by the Free Software Foundation.\n\n Follow is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n\n You should have received a copy of the GNU General Public License\n along with Follow; if not, write to the Free Software\n Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\npackage ghm.follow.io;\n\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.swing.text.BadLocationException;\nimport javax.swing.text.JTextComponent;\n\n/**\n * Implementation of {@link OutputDestination} which appends Strings to a {@link JTextComponent}.\n *\n * @see OutputDestination\n * @see JTextCompnent\n * @author <a href=\"mailto:carl.hall@gmail.com\">Carl Hall</a>\n */\npublic class JTextComponentDestination extends FilterableOutputDestination {\n\n    private static final Logger LOG = Logger.getLogger(JTextComponentDestination.class.getName());\n\n    protected JTextComponent comp;\n\n    protected boolean autoPositionCaret;\n\n    /**\n     * Construct a new JTextCompnentDestination.\n     *\n     * @param jTextPane\n     *            text will be appended to this text area\n     * @param autoPositionCaret\n     *            if true, caret will be automatically moved to the bottom of the text area when\n     *            text is appended\n     */\n    public JTextComponentDestination(JTextComponent comp, boolean autoPositionCaret) {\n        this.comp = comp;\n        this.autoPositionCaret = autoPositionCaret;\n    }\n\n    public JTextComponent getJTextComponent() {\n        return comp;\n    }\n\n    public void setJTextComponent(JTextComponent comp) {\n        this.comp = comp;\n    }\n\n    /**\n     * Add a filtered view to this destination. Filtered views show only a subset of the total\n     * output based on filter conditions.\n     *\n     * @since 1.8.0\n     */\n    public void addFilteredView() {\n    }\n\n    /**\n     * Remove a filtered view\n     *\n     * @since 1.8.0\n     */\n    public void removeFilteredView() {\n    }\n\n    /**\n     * @return whether caret will be automatically moved to the bottom of the text area when text is\n     *         appended\n     */\n    public boolean autoPositionCaret() {\n        return autoPositionCaret;\n    }\n\n    /**\n     * @param autoPositionCaret\n     *            if true, caret will be automatically moved to the bottom of the text area when\n     *            text is appended\n     */\n    public void setAutoPositionCaret(boolean autoPositionCaret) {\n        this.autoPositionCaret = autoPositionCaret;\n    }\n\n    public void handlePrint(String s) {\n        try {\n            comp.getDocument().insertString(comp.getDocument().getLength(), s, null);\n            if (autoPositionCaret) {\n                comp.setCaretPosition(comp.getDocument().getLength());\n            }\n        } catch (BadLocationException e) {\n            // just ignore, nothing we can do\n            LOG.log(Level.SEVERE, \"BadLocationException in JTextComponentDestination\", e);\n        }\n    }\n\n    public void clear() {\n        comp.setText(\"\");\n        if (autoPositionCaret) {\n            comp.setCaretPosition(0);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/io/JTextComponentDestinationTest.java",
		"test_prompt": "// JTextComponentDestinationTest.java\npackage ghm.follow.io;\n\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.swing.text.BadLocationException;\nimport javax.swing.text.JTextComponent;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JTextComponentDestination}.\n* It contains ten unit test cases for the {@link JTextComponentDestination#autoPositionCaret()} method.\n*/\nclass JTextComponentDestinationTest {"
	},
	{
		"original_code": "// SearchEngine.java\npackage ghm.follow.search;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.regex.Matcher;\r\nimport java.util.regex.Pattern;\r\n\r\n/**\r\n * Searches through text based on flags passed at time of search.\r\n *\r\n * @author Carl Hall (carl.hall@gmail.com)\r\n */\r\npublic class SearchEngine {\r\n\r\n    public static final int CASE_SENSITIVE = 1;\r\n\r\n    public static final int REGEX = 2;\r\n\r\n    private int flags;\r\n\r\n    /**\r\n     * Constructor for search text and tracking display elements for results list\r\n     *\r\n     * @author Carl Hall (carl.hall@gmail.com)\r\n     * @param textPane\r\n     */\r\n    public SearchEngine(int flags) {\r\n        this.flags = flags;\r\n    }\r\n\r\n    /**\r\n     * Search for <code>term</code>. Use the constants of this class for flags.\r\n     *\r\n     * @author Carl Hall (carl.hall@gmail.com)\r\n     * @param term\r\n     * @return An array of found positions of term\r\n     */\r\n    public List<WordResult> search(String term, String text) {\r\n        List<WordResult> retval = null;\r\n        // search using a case sensitive regular expression\r\n        if (((flags & CASE_SENSITIVE) != 0) && ((flags & REGEX) != 0)) {\r\n            Pattern p = Pattern.compile(term, Pattern.MULTILINE);\r\n            retval = regexSearch(p, text);\r\n        } else // search using a case insensitive regular expression\r\n        if ((flags & REGEX) != 0) {\r\n            Pattern p = Pattern.compile(term, Pattern.CASE_INSENSITIVE | Pattern.MULTILINE);\r\n            retval = regexSearch(p, text);\r\n        } else // search by case sensitive text\r\n        if ((flags & CASE_SENSITIVE) != 0) {\r\n            retval = textSearch(term, text);\r\n        } else // search by case insensitive text\r\n        if (flags == 0) {\r\n            retval = textSearch(term.toLowerCase(), text.toLowerCase());\r\n        } else // fail due to unknown flags\r\n        {\r\n            throw new IllegalArgumentException(\"Unknown search strategy requested [flags=\" + flags);\r\n        }\r\n        return retval;\r\n    }\r\n\r\n    /**\r\n     * Searches <code>text</code> for <code>term</code> by performing a simple text search.\r\n     *\r\n     * @author Carl Hall (carl.hall@gmail.com)\r\n     * @param term\r\n     * @param text\r\n     * @return\r\n     */\r\n    protected List<WordResult> textSearch(String term, String text) {\r\n        ArrayList<WordResult> results = new ArrayList<WordResult>();\r\n        if (term != null && term.length() > 0 && text != null && text.length() > 0) {\r\n            int pos = 0;\r\n            while ((pos = text.indexOf(term, pos)) > -1) {\r\n                results.add(new WordResult(pos, pos + term.length(), term));\r\n                pos += term.length();\r\n                // allow other things to happen in case the search takes a while\r\n                Thread.yield();\r\n            }\r\n        }\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * Searches <code>text</code> using the provided <code>Pattern</code><br>\r\n     * <br>\r\n     * Thanks to prec in #regex for correcting the use of Matcher.\r\n     *\r\n     * @author Carl Hall (carl.hall@gmail.com)\r\n     * @param p\r\n     * @param text\r\n     * @return\r\n     */\r\n    protected List<WordResult> regexSearch(Pattern p, String text) {\r\n        Matcher m = p.matcher(text);\r\n        ArrayList<WordResult> results = new ArrayList<WordResult>();\r\n        while (m.find()) {\r\n            results.add(new WordResult(m.start(), m.end(), m.group()));\r\n            Thread.yield();\r\n        }\r\n        return results;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/search/SearchEngineTest.java",
		"test_prompt": "// SearchEngineTest.java\npackage ghm.follow.search;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SearchEngine}.\n* It contains ten unit test cases for the {@link SearchEngine#search(String, String)} method.\n*/\nclass SearchEngineTest {"
	},
	{
		"original_code": "// SearchableTextPane.java\npackage ghm.follow.search;\n\nimport java.awt.Color;\nimport java.awt.Component;\nimport java.awt.Font;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.swing.JTextArea;\nimport javax.swing.plaf.ComponentUI;\nimport javax.swing.text.BadLocationException;\nimport javax.swing.text.Document;\nimport javax.swing.text.Element;\nimport javax.swing.text.Utilities;\nimport javax.swing.text.DefaultHighlighter.DefaultHighlightPainter;\n\npublic class SearchableTextPane extends JTextArea {\n\n    private Logger log = Logger.getLogger(SearchableTextPane.class.getName());\n\n    private int lastSearchPos = -1;\n\n    private String lastSearchTerm;\n\n    private final DefaultHighlightPainter wordPainter = new DefaultHighlightPainter(Color.YELLOW);\n\n    public SearchableTextPane(Font font, int tabSize) {\n        // set the display font\n        setFont(font);\n        setTabSize(tabSize);\n    }\n\n    /**\n     * Override this to keep the text from wrapping and to make the viewable area as wide as the\n     * tabbed pane\n     */\n    public boolean getScrollableTracksViewportWidth() {\n        Component parent = getParent();\n        ComponentUI ui = getUI();\n        return parent != null ? (ui.getPreferredSize(this).width <= parent.getSize().width) : true;\n    }\n\n    /**\n     * Highlight <code>term</code> wherever it is found in the view. Also highlights the entire\n     * line on which the term is found.\n     *\n     * @param term\n     * @param caseSensitive\n     * @param useRegularExpression\n     * @return\n     */\n    public List<LineResult> highlight(String term, int flags) {\n        List<LineResult> lineResults = new ArrayList<LineResult>();\n        // Remove all old highlights\n        removeHighlights();\n        // Search for pattern\n        if ((term != null) && (term.length() > 0)) {\n            // look for instances of the term in the text\n            try {\n                Document doc = getDocument();\n                String text = doc.getText(0, doc.getLength());\n                List<WordResult> searchResults = new SearchEngine(flags).search(term, text);\n                lineResults = convertWords2Lines(searchResults);\n                for (LineResult lineResult : lineResults) {\n                    List<WordResult> wordResults = lineResult.getWordResults();\n                    for (WordResult wordResult : wordResults) {\n                        // highlight the searched term\n                        int wordStart = wordResult.start;\n                        int wordEnd = wordResult.end;\n                        addHighlight(wordStart, wordEnd - wordStart);\n                        Thread.yield();\n                    }\n                }\n            } catch (BadLocationException e) {\n                log.log(Level.SEVERE, \"BadLocationException in SearchableTextPane\", e);\n                lineResults = new ArrayList<LineResult>();\n            }\n        }\n        return lineResults;\n    }\n\n    /**\n     * Highlight a piece of text in the document\n     *\n     * @param start\n     * @param wordEnd\n     * @param highlighter\n     */\n    private void addHighlight(int start, int length) throws BadLocationException {\n        getHighlighter().addHighlight(start, start + length, wordPainter);\n    }\n\n    /**\n     * Removes highlights from text area\n     */\n    public void removeHighlights() {\n        getHighlighter().removeAllHighlights();\n    }\n\n    /**\n     * Searches for a term. If the term provided matches the last searched term, the last found\n     * position is used as a starting point.<br>\n     * <br>\n     * Developer note: this method isn't currently used.\n     *\n     * @param term\n     *            The string for which to search.\n     * @return The position where the term was found.<br>\n     *         If the term is null, empty or not found, -1 is returned.\n     */\n    public int search(String term) {\n        if (term != null && term.length() > 0) {\n            if (term.equals(lastSearchTerm)) {\n                // assume to start at the beginning\n                int pos = 0;\n                // if there is a previous search position, start there plus the\n                // length\n                // of the last term so that last term again isn't found again\n                if (lastSearchPos != -1) {\n                    pos = lastSearchPos + lastSearchTerm.length();\n                }\n                lastSearchPos = search(lastSearchTerm, pos);\n            } else {\n                lastSearchPos = search(term, 0);\n            }\n        }\n        // remember the term if it was found\n        if (lastSearchPos == -1) {\n            lastSearchTerm = null;\n        } else {\n            lastSearchTerm = term;\n        }\n        return lastSearchPos;\n    }\n\n    /**\n     * Searches for a term at the given starting position.<br>\n     * <br>\n     * Developer note: this method isn't currently used.\n     *\n     * @param term\n     *            The string for which to search.\n     * @param startPos\n     *            Where to start.\n     * @return The position where the term was found.<br>\n     *         If the term is null, empty or not found, -1 is returned.\n     */\n    public int search(String term, int startPos) {\n        int pos = 0;\n        try {\n            Document doc = getDocument();\n            String text = doc.getText(0, doc.getLength());\n            // Search for pattern\n            pos = text.indexOf(term, startPos);\n        } catch (BadLocationException e) {\n            // just return -1;\n            log.log(Level.WARNING, \"BadLocationException in SearchableTextPane\", e);\n            pos = -1;\n        }\n        return pos;\n    }\n\n    /**\n     * Converts word results from search into line results\n     *\n     * @param words\n     * @return\n     */\n    private List<LineResult> convertWords2Lines(List<WordResult> words) throws BadLocationException {\n        ArrayList<LineResult> lines = new ArrayList<LineResult>();\n        LineResult tempLine = null;\n        int lastLine = -1;\n        for (WordResult word : words) {\n            int line = getLineOfOffset(word.start);\n            if (line != lastLine) {\n                if (tempLine != null) {\n                    lines.add(tempLine);\n                }\n                Element elem = Utilities.getParagraphElement(this, word.start);\n                int lineStart = elem.getStartOffset();\n                int lineEnd = elem.getEndOffset();\n                tempLine = new LineResult(line, lineStart, lineEnd);\n            }\n            updateWordResult(word, tempLine);\n            lastLine = line;\n            // allow other things to happen in case the search takes a while\n            Thread.yield();\n        }\n        if (tempLine != null) {\n            lines.add(tempLine);\n        }\n        return lines;\n    }\n\n    /**\n     * Adds word result to line result and updates line information\n     *\n     * @param wordResult\n     * @param lineResult\n     */\n    private void updateWordResult(WordResult wordResult, LineResult lineResult) throws BadLocationException {\n        lineResult.addWord(wordResult);\n        // increase by 1 because offset starts at 0.\n        // 1 is clearer to the user since most people don't start counting\n        // at 0\n        int line = getLineOfOffset(wordResult.start);\n        wordResult.parent.lineNumber = line + 1;\n        int lineOffset = getLineStartOffset(line);\n        wordResult.setLineOffset(lineOffset);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/search/SearchableTextPaneTest0.java",
		"test_prompt": "// SearchableTextPaneTest0.java\npackage ghm.follow.search;\n\nimport java.awt.Color;\nimport java.awt.Component;\nimport java.awt.Font;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.swing.JTextArea;\nimport javax.swing.plaf.ComponentUI;\nimport javax.swing.text.BadLocationException;\nimport javax.swing.text.Document;\nimport javax.swing.text.Element;\nimport javax.swing.text.Utilities;\nimport javax.swing.text.DefaultHighlighter.DefaultHighlightPainter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SearchableTextPane}.\n* It contains ten unit test cases for the {@link SearchableTextPane#highlight(String, int)} method.\n*/\nclass SearchableTextPaneTest0 {"
	},
	{
		"original_code": "// SearchableTextPane.java\npackage ghm.follow.search;\n\nimport java.awt.Color;\nimport java.awt.Component;\nimport java.awt.Font;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.swing.JTextArea;\nimport javax.swing.plaf.ComponentUI;\nimport javax.swing.text.BadLocationException;\nimport javax.swing.text.Document;\nimport javax.swing.text.Element;\nimport javax.swing.text.Utilities;\nimport javax.swing.text.DefaultHighlighter.DefaultHighlightPainter;\n\npublic class SearchableTextPane extends JTextArea {\n\n    private Logger log = Logger.getLogger(SearchableTextPane.class.getName());\n\n    private int lastSearchPos = -1;\n\n    private String lastSearchTerm;\n\n    private final DefaultHighlightPainter wordPainter = new DefaultHighlightPainter(Color.YELLOW);\n\n    public SearchableTextPane(Font font, int tabSize) {\n        // set the display font\n        setFont(font);\n        setTabSize(tabSize);\n    }\n\n    /**\n     * Override this to keep the text from wrapping and to make the viewable area as wide as the\n     * tabbed pane\n     */\n    public boolean getScrollableTracksViewportWidth() {\n        Component parent = getParent();\n        ComponentUI ui = getUI();\n        return parent != null ? (ui.getPreferredSize(this).width <= parent.getSize().width) : true;\n    }\n\n    /**\n     * Highlight <code>term</code> wherever it is found in the view. Also highlights the entire\n     * line on which the term is found.\n     *\n     * @param term\n     * @param caseSensitive\n     * @param useRegularExpression\n     * @return\n     */\n    public List<LineResult> highlight(String term, int flags) {\n        List<LineResult> lineResults = new ArrayList<LineResult>();\n        // Remove all old highlights\n        removeHighlights();\n        // Search for pattern\n        if ((term != null) && (term.length() > 0)) {\n            // look for instances of the term in the text\n            try {\n                Document doc = getDocument();\n                String text = doc.getText(0, doc.getLength());\n                List<WordResult> searchResults = new SearchEngine(flags).search(term, text);\n                lineResults = convertWords2Lines(searchResults);\n                for (LineResult lineResult : lineResults) {\n                    List<WordResult> wordResults = lineResult.getWordResults();\n                    for (WordResult wordResult : wordResults) {\n                        // highlight the searched term\n                        int wordStart = wordResult.start;\n                        int wordEnd = wordResult.end;\n                        addHighlight(wordStart, wordEnd - wordStart);\n                        Thread.yield();\n                    }\n                }\n            } catch (BadLocationException e) {\n                log.log(Level.SEVERE, \"BadLocationException in SearchableTextPane\", e);\n                lineResults = new ArrayList<LineResult>();\n            }\n        }\n        return lineResults;\n    }\n\n    /**\n     * Highlight a piece of text in the document\n     *\n     * @param start\n     * @param wordEnd\n     * @param highlighter\n     */\n    private void addHighlight(int start, int length) throws BadLocationException {\n        getHighlighter().addHighlight(start, start + length, wordPainter);\n    }\n\n    /**\n     * Removes highlights from text area\n     */\n    public void removeHighlights() {\n        getHighlighter().removeAllHighlights();\n    }\n\n    /**\n     * Searches for a term. If the term provided matches the last searched term, the last found\n     * position is used as a starting point.<br>\n     * <br>\n     * Developer note: this method isn't currently used.\n     *\n     * @param term\n     *            The string for which to search.\n     * @return The position where the term was found.<br>\n     *         If the term is null, empty or not found, -1 is returned.\n     */\n    public int search(String term) {\n        if (term != null && term.length() > 0) {\n            if (term.equals(lastSearchTerm)) {\n                // assume to start at the beginning\n                int pos = 0;\n                // if there is a previous search position, start there plus the\n                // length\n                // of the last term so that last term again isn't found again\n                if (lastSearchPos != -1) {\n                    pos = lastSearchPos + lastSearchTerm.length();\n                }\n                lastSearchPos = search(lastSearchTerm, pos);\n            } else {\n                lastSearchPos = search(term, 0);\n            }\n        }\n        // remember the term if it was found\n        if (lastSearchPos == -1) {\n            lastSearchTerm = null;\n        } else {\n            lastSearchTerm = term;\n        }\n        return lastSearchPos;\n    }\n\n    /**\n     * Searches for a term at the given starting position.<br>\n     * <br>\n     * Developer note: this method isn't currently used.\n     *\n     * @param term\n     *            The string for which to search.\n     * @param startPos\n     *            Where to start.\n     * @return The position where the term was found.<br>\n     *         If the term is null, empty or not found, -1 is returned.\n     */\n    public int search(String term, int startPos) {\n        int pos = 0;\n        try {\n            Document doc = getDocument();\n            String text = doc.getText(0, doc.getLength());\n            // Search for pattern\n            pos = text.indexOf(term, startPos);\n        } catch (BadLocationException e) {\n            // just return -1;\n            log.log(Level.WARNING, \"BadLocationException in SearchableTextPane\", e);\n            pos = -1;\n        }\n        return pos;\n    }\n\n    /**\n     * Converts word results from search into line results\n     *\n     * @param words\n     * @return\n     */\n    private List<LineResult> convertWords2Lines(List<WordResult> words) throws BadLocationException {\n        ArrayList<LineResult> lines = new ArrayList<LineResult>();\n        LineResult tempLine = null;\n        int lastLine = -1;\n        for (WordResult word : words) {\n            int line = getLineOfOffset(word.start);\n            if (line != lastLine) {\n                if (tempLine != null) {\n                    lines.add(tempLine);\n                }\n                Element elem = Utilities.getParagraphElement(this, word.start);\n                int lineStart = elem.getStartOffset();\n                int lineEnd = elem.getEndOffset();\n                tempLine = new LineResult(line, lineStart, lineEnd);\n            }\n            updateWordResult(word, tempLine);\n            lastLine = line;\n            // allow other things to happen in case the search takes a while\n            Thread.yield();\n        }\n        if (tempLine != null) {\n            lines.add(tempLine);\n        }\n        return lines;\n    }\n\n    /**\n     * Adds word result to line result and updates line information\n     *\n     * @param wordResult\n     * @param lineResult\n     */\n    private void updateWordResult(WordResult wordResult, LineResult lineResult) throws BadLocationException {\n        lineResult.addWord(wordResult);\n        // increase by 1 because offset starts at 0.\n        // 1 is clearer to the user since most people don't start counting\n        // at 0\n        int line = getLineOfOffset(wordResult.start);\n        wordResult.parent.lineNumber = line + 1;\n        int lineOffset = getLineStartOffset(line);\n        wordResult.setLineOffset(lineOffset);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/search/SearchableTextPaneTest1.java",
		"test_prompt": "// SearchableTextPaneTest1.java\npackage ghm.follow.search;\n\nimport java.awt.Color;\nimport java.awt.Component;\nimport java.awt.Font;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.swing.JTextArea;\nimport javax.swing.plaf.ComponentUI;\nimport javax.swing.text.BadLocationException;\nimport javax.swing.text.Document;\nimport javax.swing.text.Element;\nimport javax.swing.text.Utilities;\nimport javax.swing.text.DefaultHighlighter.DefaultHighlightPainter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SearchableTextPane}.\n* It contains ten unit test cases for the {@link SearchableTextPane#search(String)} method.\n*/\nclass SearchableTextPaneTest1 {"
	},
	{
		"original_code": "// SearchableTextPane.java\npackage ghm.follow.search;\n\nimport java.awt.Color;\nimport java.awt.Component;\nimport java.awt.Font;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.swing.JTextArea;\nimport javax.swing.plaf.ComponentUI;\nimport javax.swing.text.BadLocationException;\nimport javax.swing.text.Document;\nimport javax.swing.text.Element;\nimport javax.swing.text.Utilities;\nimport javax.swing.text.DefaultHighlighter.DefaultHighlightPainter;\n\npublic class SearchableTextPane extends JTextArea {\n\n    private Logger log = Logger.getLogger(SearchableTextPane.class.getName());\n\n    private int lastSearchPos = -1;\n\n    private String lastSearchTerm;\n\n    private final DefaultHighlightPainter wordPainter = new DefaultHighlightPainter(Color.YELLOW);\n\n    public SearchableTextPane(Font font, int tabSize) {\n        // set the display font\n        setFont(font);\n        setTabSize(tabSize);\n    }\n\n    /**\n     * Override this to keep the text from wrapping and to make the viewable area as wide as the\n     * tabbed pane\n     */\n    public boolean getScrollableTracksViewportWidth() {\n        Component parent = getParent();\n        ComponentUI ui = getUI();\n        return parent != null ? (ui.getPreferredSize(this).width <= parent.getSize().width) : true;\n    }\n\n    /**\n     * Highlight <code>term</code> wherever it is found in the view. Also highlights the entire\n     * line on which the term is found.\n     *\n     * @param term\n     * @param caseSensitive\n     * @param useRegularExpression\n     * @return\n     */\n    public List<LineResult> highlight(String term, int flags) {\n        List<LineResult> lineResults = new ArrayList<LineResult>();\n        // Remove all old highlights\n        removeHighlights();\n        // Search for pattern\n        if ((term != null) && (term.length() > 0)) {\n            // look for instances of the term in the text\n            try {\n                Document doc = getDocument();\n                String text = doc.getText(0, doc.getLength());\n                List<WordResult> searchResults = new SearchEngine(flags).search(term, text);\n                lineResults = convertWords2Lines(searchResults);\n                for (LineResult lineResult : lineResults) {\n                    List<WordResult> wordResults = lineResult.getWordResults();\n                    for (WordResult wordResult : wordResults) {\n                        // highlight the searched term\n                        int wordStart = wordResult.start;\n                        int wordEnd = wordResult.end;\n                        addHighlight(wordStart, wordEnd - wordStart);\n                        Thread.yield();\n                    }\n                }\n            } catch (BadLocationException e) {\n                log.log(Level.SEVERE, \"BadLocationException in SearchableTextPane\", e);\n                lineResults = new ArrayList<LineResult>();\n            }\n        }\n        return lineResults;\n    }\n\n    /**\n     * Highlight a piece of text in the document\n     *\n     * @param start\n     * @param wordEnd\n     * @param highlighter\n     */\n    private void addHighlight(int start, int length) throws BadLocationException {\n        getHighlighter().addHighlight(start, start + length, wordPainter);\n    }\n\n    /**\n     * Removes highlights from text area\n     */\n    public void removeHighlights() {\n        getHighlighter().removeAllHighlights();\n    }\n\n    /**\n     * Searches for a term. If the term provided matches the last searched term, the last found\n     * position is used as a starting point.<br>\n     * <br>\n     * Developer note: this method isn't currently used.\n     *\n     * @param term\n     *            The string for which to search.\n     * @return The position where the term was found.<br>\n     *         If the term is null, empty or not found, -1 is returned.\n     */\n    public int search(String term) {\n        if (term != null && term.length() > 0) {\n            if (term.equals(lastSearchTerm)) {\n                // assume to start at the beginning\n                int pos = 0;\n                // if there is a previous search position, start there plus the\n                // length\n                // of the last term so that last term again isn't found again\n                if (lastSearchPos != -1) {\n                    pos = lastSearchPos + lastSearchTerm.length();\n                }\n                lastSearchPos = search(lastSearchTerm, pos);\n            } else {\n                lastSearchPos = search(term, 0);\n            }\n        }\n        // remember the term if it was found\n        if (lastSearchPos == -1) {\n            lastSearchTerm = null;\n        } else {\n            lastSearchTerm = term;\n        }\n        return lastSearchPos;\n    }\n\n    /**\n     * Searches for a term at the given starting position.<br>\n     * <br>\n     * Developer note: this method isn't currently used.\n     *\n     * @param term\n     *            The string for which to search.\n     * @param startPos\n     *            Where to start.\n     * @return The position where the term was found.<br>\n     *         If the term is null, empty or not found, -1 is returned.\n     */\n    public int search(String term, int startPos) {\n        int pos = 0;\n        try {\n            Document doc = getDocument();\n            String text = doc.getText(0, doc.getLength());\n            // Search for pattern\n            pos = text.indexOf(term, startPos);\n        } catch (BadLocationException e) {\n            // just return -1;\n            log.log(Level.WARNING, \"BadLocationException in SearchableTextPane\", e);\n            pos = -1;\n        }\n        return pos;\n    }\n\n    /**\n     * Converts word results from search into line results\n     *\n     * @param words\n     * @return\n     */\n    private List<LineResult> convertWords2Lines(List<WordResult> words) throws BadLocationException {\n        ArrayList<LineResult> lines = new ArrayList<LineResult>();\n        LineResult tempLine = null;\n        int lastLine = -1;\n        for (WordResult word : words) {\n            int line = getLineOfOffset(word.start);\n            if (line != lastLine) {\n                if (tempLine != null) {\n                    lines.add(tempLine);\n                }\n                Element elem = Utilities.getParagraphElement(this, word.start);\n                int lineStart = elem.getStartOffset();\n                int lineEnd = elem.getEndOffset();\n                tempLine = new LineResult(line, lineStart, lineEnd);\n            }\n            updateWordResult(word, tempLine);\n            lastLine = line;\n            // allow other things to happen in case the search takes a while\n            Thread.yield();\n        }\n        if (tempLine != null) {\n            lines.add(tempLine);\n        }\n        return lines;\n    }\n\n    /**\n     * Adds word result to line result and updates line information\n     *\n     * @param wordResult\n     * @param lineResult\n     */\n    private void updateWordResult(WordResult wordResult, LineResult lineResult) throws BadLocationException {\n        lineResult.addWord(wordResult);\n        // increase by 1 because offset starts at 0.\n        // 1 is clearer to the user since most people don't start counting\n        // at 0\n        int line = getLineOfOffset(wordResult.start);\n        wordResult.parent.lineNumber = line + 1;\n        int lineOffset = getLineStartOffset(line);\n        wordResult.setLineOffset(lineOffset);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/search/SearchableTextPaneTest2.java",
		"test_prompt": "// SearchableTextPaneTest2.java\npackage ghm.follow.search;\n\nimport java.awt.Color;\nimport java.awt.Component;\nimport java.awt.Font;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.swing.JTextArea;\nimport javax.swing.plaf.ComponentUI;\nimport javax.swing.text.BadLocationException;\nimport javax.swing.text.Document;\nimport javax.swing.text.Element;\nimport javax.swing.text.Utilities;\nimport javax.swing.text.DefaultHighlighter.DefaultHighlightPainter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SearchableTextPane}.\n* It contains ten unit test cases for the {@link SearchableTextPane#search(String, int)} method.\n*/\nclass SearchableTextPaneTest2 {"
	},
	{
		"original_code": "// LineTextUI.java\npackage ghm.follow.gui;\r\n\r\nimport java.awt.Rectangle;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport javax.swing.JComponent;\r\nimport javax.swing.event.CaretEvent;\r\nimport javax.swing.event.CaretListener;\r\nimport javax.swing.plaf.basic.BasicTextAreaUI;\r\nimport javax.swing.text.BadLocationException;\r\nimport javax.swing.text.Document;\r\nimport javax.swing.text.Element;\r\nimport javax.swing.text.JTextComponent;\r\nimport javax.swing.text.View;\r\n\r\n/**\r\n * UI implementation that highlights the line where the caret is found.\r\n *\r\n * @author Carl Hall\r\n */\r\npublic class LineTextUI extends BasicTextAreaUI {\r\n\r\n    private transient Logger log = Logger.getLogger(LineTextUI.class.getName());\r\n\r\n    int selectedIndex = -1;\r\n\r\n    private JTextComponent comp;\r\n\r\n    public View create(Element elem) {\r\n        return new LineView(elem);\r\n    }\r\n\r\n    public void installUI(JComponent c) {\r\n        comp = (JTextComponent) c;\r\n        // install listener if we should highlight the current line\r\n        // if (SyntaxSupport.getInstance().getShouldHighlightCurrentLine()) {\r\n        comp.addCaretListener(new CaretListener() {\r\n\r\n            public void caretUpdate(CaretEvent e) {\r\n                Document doc = comp.getDocument();\r\n                Element map = doc.getDefaultRootElement();\r\n                int index = map.getElementIndex(e.getDot());\r\n                if (selectedIndex > -1) {\r\n                    try {\r\n                        // unhighlight previous Selected line\r\n                        Element previous = map.getElement(selectedIndex);\r\n                        if (previous != null) {\r\n                            Rectangle rec = comp.modelToView(previous.getStartOffset());\r\n                            if (rec != null) {\r\n                                rec.width = comp.getWidth();\r\n                                comp.repaint(rec);\r\n                            }\r\n                        }\r\n                    } catch (BadLocationException e1) {\r\n                        log.log(Level.SEVERE, \"BadLocationException in LineTextUI\", e1);\r\n                    }\r\n                }\r\n                if (comp.getSelectionStart() == comp.getSelectionEnd()) {\r\n                    selectedIndex = index;\r\n                } else {\r\n                    selectedIndex = -1;\r\n                }\r\n                // highlight current\r\n                Element selected = map.getElement(index);\r\n                damageRange(comp, selected.getStartOffset(), selected.getEndOffset() - 1);\r\n            }\r\n        });\r\n        super.installUI(c);\r\n    }\r\n\r\n    public int getSelectedIndex() {\r\n        return selectedIndex;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/gui/LineTextUITest.java",
		"test_prompt": "// LineTextUITest.java\npackage ghm.follow.gui;\n\nimport java.awt.Rectangle;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.swing.JComponent;\nimport javax.swing.event.CaretEvent;\nimport javax.swing.event.CaretListener;\nimport javax.swing.plaf.basic.BasicTextAreaUI;\nimport javax.swing.text.BadLocationException;\nimport javax.swing.text.Document;\nimport javax.swing.text.Element;\nimport javax.swing.text.JTextComponent;\nimport javax.swing.text.View;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link LineTextUI}.\n* It contains ten unit test cases for the {@link LineTextUI#create(Element)} method.\n*/\nclass LineTextUITest {"
	},
	{
		"original_code": "// ExternalEditor.java\n/*\n * Copyright (C) 2000-2003 Greg Merrill (greghmerrill@yahoo.com)\n * \n * This file is part of Follow (http://follow.sf.net).\n * \n * Follow is free software; you can redistribute it and/or modify it under the\n * terms of version 2 of the GNU General Public License as published by the Free\n * Software Foundation.\n * \n * Follow is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License along with\n * Follow; if not, write to the Free Software Foundation, Inc., 59 Temple Place,\n * Suite 330, Boston, MA 02111-1307 USA\n */\npackage ghm.follow.gui;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * Action which closes the currently followed file.\n *\n * @author <a href=\"mailto:greghmerrill@yahoo.com\">Greg Merrill</a>\n * @author <a href=\"mailto:murali_ca_us@hotmail.com\">Murali Krishnan</a>\n */\npublic class ExternalEditor extends Object {\n\n    private Logger log = Logger.getLogger(ExternalEditor.class.getName());\n\n    // ------------------------------------------------------------\n    // - Constructor\n    public ExternalEditor(String string) {\n        cmdString = string;\n    }\n\n    // ------------------------------------------------------------\n    // - Member Variables\n    private String cmdString = \"\";\n\n    // ------------------------------------------------------------\n    // - Accessors\n    protected String getCmdString() {\n        return (cmdString);\n    }\n\n    // ------------------------------------------------------------\n    // - Internal Utilities.\n    public String[] toCmdArray(String file) {\n        String string = (getCmdString() == null) ? \"\" : getCmdString().trim();\n        // Pessimistic.\n        String[] result = new String[0];\n        if (!string.equals(\"\")) {\n            // space terminate the last part.\n            string = string + \" \";\n            List<String> list = new ArrayList<String>();\n            boolean inQuoteSingle = false;\n            boolean inQuoteDouble = false;\n            boolean inWhitespace = false;\n            StringBuffer buffer = new StringBuffer();\n            char[] chArray = string.toCharArray();\n            for (int i = 0; i < chArray.length; i++) {\n                char ch = chArray[i];\n                if (inQuoteSingle) {\n                    if (ch == '\\'') {\n                        inQuoteSingle = false;\n                    } else {\n                        buffer.append(ch);\n                    }\n                } else if (inQuoteDouble) {\n                    if (ch == '\"') {\n                        inQuoteDouble = false;\n                    } else {\n                        buffer.append(ch);\n                    }\n                } else if (inWhitespace) {\n                    if (!Character.isWhitespace(ch)) {\n                        inWhitespace = false;\n                        // Re-process this character.\n                        --i;\n                    }\n                } else {\n                    if (ch == '\\'') {\n                        inQuoteSingle = true;\n                    } else if (ch == '\"') {\n                        inQuoteDouble = true;\n                    } else if (Character.isWhitespace(ch)) {\n                        inWhitespace = true;\n                        list.add(buffer.toString());\n                        buffer = new StringBuffer();\n                    } else {\n                        buffer.append(ch);\n                    }\n                }\n            }\n            list.add(file);\n            result = (String[]) list.toArray(result);\n        }\n        return (result);\n    }\n\n    // ------------------------------------------------------------\n    // - Public API\n    public void exec(File file) {\n        String fullPath = file.getAbsolutePath();\n        String[] cmd = toCmdArray(fullPath);\n        log.info(\"Exec'ing \" + Arrays.asList(cmd) + \".\");\n        try {\n            Runtime.getRuntime().exec(cmd);\n        } catch (IOException ioe) {\n            String errmsg = \"Could not exec [\" + getCmdString() + \"] with [\" + fullPath + \"].\";\n            log.log(Level.SEVERE, errmsg, ioe);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/gui/ExternalEditorTest.java",
		"test_prompt": "// ExternalEditorTest.java\npackage ghm.follow.gui;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ExternalEditor}.\n* It contains ten unit test cases for the {@link ExternalEditor#toCmdArray(String)} method.\n*/\nclass ExternalEditorTest {"
	},
	{
		"original_code": "// ComponentBuilder.java\npackage ghm.follow.gui;\n\nimport ghm.follow.FollowApp;\nimport ghm.follow.config.Configure;\nimport ghm.follow.nav.Bottom;\nimport ghm.follow.nav.NextTab;\nimport ghm.follow.nav.PreviousTab;\nimport ghm.follow.nav.Top;\nimport ghm.follow.search.ClearAllHighlights;\nimport ghm.follow.search.ClearHighlights;\nimport ghm.follow.search.Find;\nimport java.util.HashMap;\nimport java.util.ResourceBundle;\nimport javax.swing.JMenuBar;\n\npublic class ComponentBuilder {\n\n    public static Menu fileMenu;\n\n    public static Menu editMenu;\n\n    public static Menu toolsMenu;\n\n    public static Menu windowMenu;\n\n    public static Menu helpMenu;\n\n    // file menu items\n    public static Menu recentFilesMenu;\n\n    private ComponentBuilder() {\n    }\n\n    /**\n     * Builds the menu bar for the application\n     *\n     * @return reference the constructed menu bar\n     */\n    public static JMenuBar buildMenuBar(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {\n        // create menu bar and add menus\n        JMenuBar jMenuBar = new JMenuBar();\n        // file menu\n        fileMenu = ComponentBuilder.buildFileMenu(resources, actions);\n        jMenuBar.add(fileMenu);\n        // edit menu\n        editMenu = ComponentBuilder.buildEditMenu(resources, actions);\n        jMenuBar.add(editMenu);\n        // tool menu\n        toolsMenu = ComponentBuilder.buildToolsMenu(resources, actions);\n        jMenuBar.add(toolsMenu);\n        // window menu\n        windowMenu = ComponentBuilder.buildWindowMenu(resources, actions);\n        jMenuBar.add(windowMenu);\n        // help menu\n        helpMenu = ComponentBuilder.buildHelpMenu(resources, actions);\n        jMenuBar.add(helpMenu);\n        return jMenuBar;\n    }\n\n    public static Menu buildFileMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {\n        Menu fileMenu = new Menu(resources.getString(\"menu.File.name\"), resources.getString(\"menu.File.mnemonic\"));\n        fileMenu.addFollowAppAction(actions.get(Open.NAME));\n        fileMenu.addFollowAppAction(actions.get(Close.NAME));\n        fileMenu.addSeparator();\n        fileMenu.addFollowAppAction(actions.get(Reset.NAME));\n        fileMenu.addFollowAppAction(actions.get(Pause.NAME));\n        fileMenu.addSeparator();\n        recentFilesMenu = new Menu(resources.getString(\"menu.RecentFiles.name\"), resources.getString(\"menu.RecentFiles.mnemonic\"), FollowApp.getIcon(ComponentBuilder.class, \"menu.RecentFiles.icon\"));\n        fileMenu.add(recentFilesMenu);\n        fileMenu.addSeparator();\n        fileMenu.addFollowAppAction(actions.get(Exit.NAME));\n        return fileMenu;\n    }\n\n    public static Menu buildEditMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {\n        Menu editMenu = new Menu(resources.getString(\"menu.Edit.name\"), resources.getString(\"menu.Edit.mnemonic\"));\n        editMenu.addFollowAppAction(actions.get(Find.NAME));\n        editMenu.addFollowAppAction(actions.get(ClearHighlights.NAME));\n        editMenu.addFollowAppAction(actions.get(ClearAllHighlights.NAME));\n        editMenu.addSeparator();\n        editMenu.addFollowAppAction(actions.get(Configure.NAME));\n        return editMenu;\n    }\n\n    public static Menu buildToolsMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {\n        Menu toolsMenu = new Menu(resources.getString(\"menu.Tools.name\"), resources.getString(\"menu.Tools.mnemonic\"));\n        toolsMenu.addFollowAppAction(actions.get(Top.NAME));\n        toolsMenu.addFollowAppAction(actions.get(Bottom.NAME));\n        toolsMenu.addSeparator();\n        toolsMenu.addFollowAppAction(actions.get(Clear.NAME));\n        toolsMenu.addFollowAppAction(actions.get(ClearAll.NAME));\n        toolsMenu.addFollowAppAction(actions.get(Delete.NAME));\n        toolsMenu.addFollowAppAction(actions.get(DeleteAll.NAME));\n        toolsMenu.addSeparator();\n        toolsMenu.addFollowAppAction(actions.get(Edit.NAME));\n        return toolsMenu;\n    }\n\n    public static Menu buildWindowMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {\n        Menu windowMenu = new Menu(resources.getString(\"menu.Window.name\"), resources.getString(\"menu.Window.mnemonic\"));\n        windowMenu.addFollowAppAction(actions.get(NextTab.NAME));\n        windowMenu.addFollowAppAction(actions.get(PreviousTab.NAME));\n        return windowMenu;\n    }\n\n    public static Menu buildHelpMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {\n        Menu helpMenu = new Menu(resources.getString(\"menu.Help.name\"), resources.getString(\"menu.Help.mnemonic\"));\n        helpMenu.addFollowAppAction(actions.get(About.NAME));\n        return helpMenu;\n    }\n\n    /**\n     * Builds the popup menu shown when right clicking in a text area.\n     *\n     * @return\n     */\n    public static PopupMenu buildPopupMenu(HashMap<String, FollowAppAction> actions) {\n        PopupMenu popupMenu = new PopupMenu();\n        popupMenu.addFollowAppAction(actions.get(Open.NAME));\n        popupMenu.addFollowAppAction(actions.get(Close.NAME));\n        popupMenu.addSeparator();\n        popupMenu.addFollowAppAction(actions.get(Reset.NAME));\n        popupMenu.addFollowAppAction(actions.get(Pause.NAME));\n        popupMenu.addSeparator();\n        popupMenu.addFollowAppAction(actions.get(Top.NAME));\n        popupMenu.addFollowAppAction(actions.get(Bottom.NAME));\n        popupMenu.addSeparator();\n        popupMenu.addFollowAppAction(actions.get(Clear.NAME));\n        popupMenu.addFollowAppAction(actions.get(Delete.NAME));\n        popupMenu.addSeparator();\n        popupMenu.addFollowAppAction(actions.get(Configure.NAME));\n        popupMenu.addFollowAppAction(actions.get(Edit.NAME));\n        return popupMenu;\n    }\n\n    /**\n     * Builds the toolbar shown at the top of the application\n     *\n     * @return\n     */\n    public static ToolBar buildToolBar(HashMap<String, FollowAppAction> actions) {\n        ToolBar toolBar = new ToolBar();\n        toolBar.addFollowAppAction(actions.get(Open.NAME));\n        toolBar.addSeparator();\n        toolBar.addFollowAppAction(actions.get(Top.NAME));\n        toolBar.addFollowAppAction(actions.get(Bottom.NAME));\n        toolBar.addSeparator();\n        toolBar.addFollowAppAction(actions.get(Clear.NAME));\n        toolBar.addFollowAppAction(actions.get(ClearAll.NAME));\n        toolBar.addFollowAppAction(actions.get(Delete.NAME));\n        toolBar.addFollowAppAction(actions.get(DeleteAll.NAME));\n        toolBar.addSeparator();\n        toolBar.addFollowAppAction(actions.get(Reset.NAME));\n        toolBar.addFollowAppAction(actions.get(Pause.NAME));\n        toolBar.addSeparator();\n        toolBar.addFollowAppAction(actions.get(Configure.NAME));\n        return toolBar;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/gui/ComponentBuilderTest0.java",
		"test_prompt": "// ComponentBuilderTest0.java\npackage ghm.follow.gui;\n\nimport ghm.follow.FollowApp;\nimport ghm.follow.config.Configure;\nimport ghm.follow.nav.Bottom;\nimport ghm.follow.nav.NextTab;\nimport ghm.follow.nav.PreviousTab;\nimport ghm.follow.nav.Top;\nimport ghm.follow.search.ClearAllHighlights;\nimport ghm.follow.search.ClearHighlights;\nimport ghm.follow.search.Find;\nimport java.util.HashMap;\nimport java.util.ResourceBundle;\nimport javax.swing.JMenuBar;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ComponentBuilder}.\n* It contains ten unit test cases for the {@link ComponentBuilder#buildMenuBar(ResourceBundle, HashMap)} method.\n*/\nclass ComponentBuilderTest0 {"
	},
	{
		"original_code": "// ComponentBuilder.java\npackage ghm.follow.gui;\n\nimport ghm.follow.FollowApp;\nimport ghm.follow.config.Configure;\nimport ghm.follow.nav.Bottom;\nimport ghm.follow.nav.NextTab;\nimport ghm.follow.nav.PreviousTab;\nimport ghm.follow.nav.Top;\nimport ghm.follow.search.ClearAllHighlights;\nimport ghm.follow.search.ClearHighlights;\nimport ghm.follow.search.Find;\nimport java.util.HashMap;\nimport java.util.ResourceBundle;\nimport javax.swing.JMenuBar;\n\npublic class ComponentBuilder {\n\n    public static Menu fileMenu;\n\n    public static Menu editMenu;\n\n    public static Menu toolsMenu;\n\n    public static Menu windowMenu;\n\n    public static Menu helpMenu;\n\n    // file menu items\n    public static Menu recentFilesMenu;\n\n    private ComponentBuilder() {\n    }\n\n    /**\n     * Builds the menu bar for the application\n     *\n     * @return reference the constructed menu bar\n     */\n    public static JMenuBar buildMenuBar(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {\n        // create menu bar and add menus\n        JMenuBar jMenuBar = new JMenuBar();\n        // file menu\n        fileMenu = ComponentBuilder.buildFileMenu(resources, actions);\n        jMenuBar.add(fileMenu);\n        // edit menu\n        editMenu = ComponentBuilder.buildEditMenu(resources, actions);\n        jMenuBar.add(editMenu);\n        // tool menu\n        toolsMenu = ComponentBuilder.buildToolsMenu(resources, actions);\n        jMenuBar.add(toolsMenu);\n        // window menu\n        windowMenu = ComponentBuilder.buildWindowMenu(resources, actions);\n        jMenuBar.add(windowMenu);\n        // help menu\n        helpMenu = ComponentBuilder.buildHelpMenu(resources, actions);\n        jMenuBar.add(helpMenu);\n        return jMenuBar;\n    }\n\n    public static Menu buildFileMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {\n        Menu fileMenu = new Menu(resources.getString(\"menu.File.name\"), resources.getString(\"menu.File.mnemonic\"));\n        fileMenu.addFollowAppAction(actions.get(Open.NAME));\n        fileMenu.addFollowAppAction(actions.get(Close.NAME));\n        fileMenu.addSeparator();\n        fileMenu.addFollowAppAction(actions.get(Reset.NAME));\n        fileMenu.addFollowAppAction(actions.get(Pause.NAME));\n        fileMenu.addSeparator();\n        recentFilesMenu = new Menu(resources.getString(\"menu.RecentFiles.name\"), resources.getString(\"menu.RecentFiles.mnemonic\"), FollowApp.getIcon(ComponentBuilder.class, \"menu.RecentFiles.icon\"));\n        fileMenu.add(recentFilesMenu);\n        fileMenu.addSeparator();\n        fileMenu.addFollowAppAction(actions.get(Exit.NAME));\n        return fileMenu;\n    }\n\n    public static Menu buildEditMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {\n        Menu editMenu = new Menu(resources.getString(\"menu.Edit.name\"), resources.getString(\"menu.Edit.mnemonic\"));\n        editMenu.addFollowAppAction(actions.get(Find.NAME));\n        editMenu.addFollowAppAction(actions.get(ClearHighlights.NAME));\n        editMenu.addFollowAppAction(actions.get(ClearAllHighlights.NAME));\n        editMenu.addSeparator();\n        editMenu.addFollowAppAction(actions.get(Configure.NAME));\n        return editMenu;\n    }\n\n    public static Menu buildToolsMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {\n        Menu toolsMenu = new Menu(resources.getString(\"menu.Tools.name\"), resources.getString(\"menu.Tools.mnemonic\"));\n        toolsMenu.addFollowAppAction(actions.get(Top.NAME));\n        toolsMenu.addFollowAppAction(actions.get(Bottom.NAME));\n        toolsMenu.addSeparator();\n        toolsMenu.addFollowAppAction(actions.get(Clear.NAME));\n        toolsMenu.addFollowAppAction(actions.get(ClearAll.NAME));\n        toolsMenu.addFollowAppAction(actions.get(Delete.NAME));\n        toolsMenu.addFollowAppAction(actions.get(DeleteAll.NAME));\n        toolsMenu.addSeparator();\n        toolsMenu.addFollowAppAction(actions.get(Edit.NAME));\n        return toolsMenu;\n    }\n\n    public static Menu buildWindowMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {\n        Menu windowMenu = new Menu(resources.getString(\"menu.Window.name\"), resources.getString(\"menu.Window.mnemonic\"));\n        windowMenu.addFollowAppAction(actions.get(NextTab.NAME));\n        windowMenu.addFollowAppAction(actions.get(PreviousTab.NAME));\n        return windowMenu;\n    }\n\n    public static Menu buildHelpMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {\n        Menu helpMenu = new Menu(resources.getString(\"menu.Help.name\"), resources.getString(\"menu.Help.mnemonic\"));\n        helpMenu.addFollowAppAction(actions.get(About.NAME));\n        return helpMenu;\n    }\n\n    /**\n     * Builds the popup menu shown when right clicking in a text area.\n     *\n     * @return\n     */\n    public static PopupMenu buildPopupMenu(HashMap<String, FollowAppAction> actions) {\n        PopupMenu popupMenu = new PopupMenu();\n        popupMenu.addFollowAppAction(actions.get(Open.NAME));\n        popupMenu.addFollowAppAction(actions.get(Close.NAME));\n        popupMenu.addSeparator();\n        popupMenu.addFollowAppAction(actions.get(Reset.NAME));\n        popupMenu.addFollowAppAction(actions.get(Pause.NAME));\n        popupMenu.addSeparator();\n        popupMenu.addFollowAppAction(actions.get(Top.NAME));\n        popupMenu.addFollowAppAction(actions.get(Bottom.NAME));\n        popupMenu.addSeparator();\n        popupMenu.addFollowAppAction(actions.get(Clear.NAME));\n        popupMenu.addFollowAppAction(actions.get(Delete.NAME));\n        popupMenu.addSeparator();\n        popupMenu.addFollowAppAction(actions.get(Configure.NAME));\n        popupMenu.addFollowAppAction(actions.get(Edit.NAME));\n        return popupMenu;\n    }\n\n    /**\n     * Builds the toolbar shown at the top of the application\n     *\n     * @return\n     */\n    public static ToolBar buildToolBar(HashMap<String, FollowAppAction> actions) {\n        ToolBar toolBar = new ToolBar();\n        toolBar.addFollowAppAction(actions.get(Open.NAME));\n        toolBar.addSeparator();\n        toolBar.addFollowAppAction(actions.get(Top.NAME));\n        toolBar.addFollowAppAction(actions.get(Bottom.NAME));\n        toolBar.addSeparator();\n        toolBar.addFollowAppAction(actions.get(Clear.NAME));\n        toolBar.addFollowAppAction(actions.get(ClearAll.NAME));\n        toolBar.addFollowAppAction(actions.get(Delete.NAME));\n        toolBar.addFollowAppAction(actions.get(DeleteAll.NAME));\n        toolBar.addSeparator();\n        toolBar.addFollowAppAction(actions.get(Reset.NAME));\n        toolBar.addFollowAppAction(actions.get(Pause.NAME));\n        toolBar.addSeparator();\n        toolBar.addFollowAppAction(actions.get(Configure.NAME));\n        return toolBar;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/gui/ComponentBuilderTest1.java",
		"test_prompt": "// ComponentBuilderTest1.java\npackage ghm.follow.gui;\n\nimport ghm.follow.FollowApp;\nimport ghm.follow.config.Configure;\nimport ghm.follow.nav.Bottom;\nimport ghm.follow.nav.NextTab;\nimport ghm.follow.nav.PreviousTab;\nimport ghm.follow.nav.Top;\nimport ghm.follow.search.ClearAllHighlights;\nimport ghm.follow.search.ClearHighlights;\nimport ghm.follow.search.Find;\nimport java.util.HashMap;\nimport java.util.ResourceBundle;\nimport javax.swing.JMenuBar;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ComponentBuilder}.\n* It contains ten unit test cases for the {@link ComponentBuilder#buildFileMenu(ResourceBundle, HashMap)} method.\n*/\nclass ComponentBuilderTest1 {"
	},
	{
		"original_code": "// ComponentBuilder.java\npackage ghm.follow.gui;\n\nimport ghm.follow.FollowApp;\nimport ghm.follow.config.Configure;\nimport ghm.follow.nav.Bottom;\nimport ghm.follow.nav.NextTab;\nimport ghm.follow.nav.PreviousTab;\nimport ghm.follow.nav.Top;\nimport ghm.follow.search.ClearAllHighlights;\nimport ghm.follow.search.ClearHighlights;\nimport ghm.follow.search.Find;\nimport java.util.HashMap;\nimport java.util.ResourceBundle;\nimport javax.swing.JMenuBar;\n\npublic class ComponentBuilder {\n\n    public static Menu fileMenu;\n\n    public static Menu editMenu;\n\n    public static Menu toolsMenu;\n\n    public static Menu windowMenu;\n\n    public static Menu helpMenu;\n\n    // file menu items\n    public static Menu recentFilesMenu;\n\n    private ComponentBuilder() {\n    }\n\n    /**\n     * Builds the menu bar for the application\n     *\n     * @return reference the constructed menu bar\n     */\n    public static JMenuBar buildMenuBar(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {\n        // create menu bar and add menus\n        JMenuBar jMenuBar = new JMenuBar();\n        // file menu\n        fileMenu = ComponentBuilder.buildFileMenu(resources, actions);\n        jMenuBar.add(fileMenu);\n        // edit menu\n        editMenu = ComponentBuilder.buildEditMenu(resources, actions);\n        jMenuBar.add(editMenu);\n        // tool menu\n        toolsMenu = ComponentBuilder.buildToolsMenu(resources, actions);\n        jMenuBar.add(toolsMenu);\n        // window menu\n        windowMenu = ComponentBuilder.buildWindowMenu(resources, actions);\n        jMenuBar.add(windowMenu);\n        // help menu\n        helpMenu = ComponentBuilder.buildHelpMenu(resources, actions);\n        jMenuBar.add(helpMenu);\n        return jMenuBar;\n    }\n\n    public static Menu buildFileMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {\n        Menu fileMenu = new Menu(resources.getString(\"menu.File.name\"), resources.getString(\"menu.File.mnemonic\"));\n        fileMenu.addFollowAppAction(actions.get(Open.NAME));\n        fileMenu.addFollowAppAction(actions.get(Close.NAME));\n        fileMenu.addSeparator();\n        fileMenu.addFollowAppAction(actions.get(Reset.NAME));\n        fileMenu.addFollowAppAction(actions.get(Pause.NAME));\n        fileMenu.addSeparator();\n        recentFilesMenu = new Menu(resources.getString(\"menu.RecentFiles.name\"), resources.getString(\"menu.RecentFiles.mnemonic\"), FollowApp.getIcon(ComponentBuilder.class, \"menu.RecentFiles.icon\"));\n        fileMenu.add(recentFilesMenu);\n        fileMenu.addSeparator();\n        fileMenu.addFollowAppAction(actions.get(Exit.NAME));\n        return fileMenu;\n    }\n\n    public static Menu buildEditMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {\n        Menu editMenu = new Menu(resources.getString(\"menu.Edit.name\"), resources.getString(\"menu.Edit.mnemonic\"));\n        editMenu.addFollowAppAction(actions.get(Find.NAME));\n        editMenu.addFollowAppAction(actions.get(ClearHighlights.NAME));\n        editMenu.addFollowAppAction(actions.get(ClearAllHighlights.NAME));\n        editMenu.addSeparator();\n        editMenu.addFollowAppAction(actions.get(Configure.NAME));\n        return editMenu;\n    }\n\n    public static Menu buildToolsMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {\n        Menu toolsMenu = new Menu(resources.getString(\"menu.Tools.name\"), resources.getString(\"menu.Tools.mnemonic\"));\n        toolsMenu.addFollowAppAction(actions.get(Top.NAME));\n        toolsMenu.addFollowAppAction(actions.get(Bottom.NAME));\n        toolsMenu.addSeparator();\n        toolsMenu.addFollowAppAction(actions.get(Clear.NAME));\n        toolsMenu.addFollowAppAction(actions.get(ClearAll.NAME));\n        toolsMenu.addFollowAppAction(actions.get(Delete.NAME));\n        toolsMenu.addFollowAppAction(actions.get(DeleteAll.NAME));\n        toolsMenu.addSeparator();\n        toolsMenu.addFollowAppAction(actions.get(Edit.NAME));\n        return toolsMenu;\n    }\n\n    public static Menu buildWindowMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {\n        Menu windowMenu = new Menu(resources.getString(\"menu.Window.name\"), resources.getString(\"menu.Window.mnemonic\"));\n        windowMenu.addFollowAppAction(actions.get(NextTab.NAME));\n        windowMenu.addFollowAppAction(actions.get(PreviousTab.NAME));\n        return windowMenu;\n    }\n\n    public static Menu buildHelpMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {\n        Menu helpMenu = new Menu(resources.getString(\"menu.Help.name\"), resources.getString(\"menu.Help.mnemonic\"));\n        helpMenu.addFollowAppAction(actions.get(About.NAME));\n        return helpMenu;\n    }\n\n    /**\n     * Builds the popup menu shown when right clicking in a text area.\n     *\n     * @return\n     */\n    public static PopupMenu buildPopupMenu(HashMap<String, FollowAppAction> actions) {\n        PopupMenu popupMenu = new PopupMenu();\n        popupMenu.addFollowAppAction(actions.get(Open.NAME));\n        popupMenu.addFollowAppAction(actions.get(Close.NAME));\n        popupMenu.addSeparator();\n        popupMenu.addFollowAppAction(actions.get(Reset.NAME));\n        popupMenu.addFollowAppAction(actions.get(Pause.NAME));\n        popupMenu.addSeparator();\n        popupMenu.addFollowAppAction(actions.get(Top.NAME));\n        popupMenu.addFollowAppAction(actions.get(Bottom.NAME));\n        popupMenu.addSeparator();\n        popupMenu.addFollowAppAction(actions.get(Clear.NAME));\n        popupMenu.addFollowAppAction(actions.get(Delete.NAME));\n        popupMenu.addSeparator();\n        popupMenu.addFollowAppAction(actions.get(Configure.NAME));\n        popupMenu.addFollowAppAction(actions.get(Edit.NAME));\n        return popupMenu;\n    }\n\n    /**\n     * Builds the toolbar shown at the top of the application\n     *\n     * @return\n     */\n    public static ToolBar buildToolBar(HashMap<String, FollowAppAction> actions) {\n        ToolBar toolBar = new ToolBar();\n        toolBar.addFollowAppAction(actions.get(Open.NAME));\n        toolBar.addSeparator();\n        toolBar.addFollowAppAction(actions.get(Top.NAME));\n        toolBar.addFollowAppAction(actions.get(Bottom.NAME));\n        toolBar.addSeparator();\n        toolBar.addFollowAppAction(actions.get(Clear.NAME));\n        toolBar.addFollowAppAction(actions.get(ClearAll.NAME));\n        toolBar.addFollowAppAction(actions.get(Delete.NAME));\n        toolBar.addFollowAppAction(actions.get(DeleteAll.NAME));\n        toolBar.addSeparator();\n        toolBar.addFollowAppAction(actions.get(Reset.NAME));\n        toolBar.addFollowAppAction(actions.get(Pause.NAME));\n        toolBar.addSeparator();\n        toolBar.addFollowAppAction(actions.get(Configure.NAME));\n        return toolBar;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/gui/ComponentBuilderTest2.java",
		"test_prompt": "// ComponentBuilderTest2.java\npackage ghm.follow.gui;\n\nimport ghm.follow.FollowApp;\nimport ghm.follow.config.Configure;\nimport ghm.follow.nav.Bottom;\nimport ghm.follow.nav.NextTab;\nimport ghm.follow.nav.PreviousTab;\nimport ghm.follow.nav.Top;\nimport ghm.follow.search.ClearAllHighlights;\nimport ghm.follow.search.ClearHighlights;\nimport ghm.follow.search.Find;\nimport java.util.HashMap;\nimport java.util.ResourceBundle;\nimport javax.swing.JMenuBar;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ComponentBuilder}.\n* It contains ten unit test cases for the {@link ComponentBuilder#buildEditMenu(ResourceBundle, HashMap)} method.\n*/\nclass ComponentBuilderTest2 {"
	},
	{
		"original_code": "// ComponentBuilder.java\npackage ghm.follow.gui;\n\nimport ghm.follow.FollowApp;\nimport ghm.follow.config.Configure;\nimport ghm.follow.nav.Bottom;\nimport ghm.follow.nav.NextTab;\nimport ghm.follow.nav.PreviousTab;\nimport ghm.follow.nav.Top;\nimport ghm.follow.search.ClearAllHighlights;\nimport ghm.follow.search.ClearHighlights;\nimport ghm.follow.search.Find;\nimport java.util.HashMap;\nimport java.util.ResourceBundle;\nimport javax.swing.JMenuBar;\n\npublic class ComponentBuilder {\n\n    public static Menu fileMenu;\n\n    public static Menu editMenu;\n\n    public static Menu toolsMenu;\n\n    public static Menu windowMenu;\n\n    public static Menu helpMenu;\n\n    // file menu items\n    public static Menu recentFilesMenu;\n\n    private ComponentBuilder() {\n    }\n\n    /**\n     * Builds the menu bar for the application\n     *\n     * @return reference the constructed menu bar\n     */\n    public static JMenuBar buildMenuBar(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {\n        // create menu bar and add menus\n        JMenuBar jMenuBar = new JMenuBar();\n        // file menu\n        fileMenu = ComponentBuilder.buildFileMenu(resources, actions);\n        jMenuBar.add(fileMenu);\n        // edit menu\n        editMenu = ComponentBuilder.buildEditMenu(resources, actions);\n        jMenuBar.add(editMenu);\n        // tool menu\n        toolsMenu = ComponentBuilder.buildToolsMenu(resources, actions);\n        jMenuBar.add(toolsMenu);\n        // window menu\n        windowMenu = ComponentBuilder.buildWindowMenu(resources, actions);\n        jMenuBar.add(windowMenu);\n        // help menu\n        helpMenu = ComponentBuilder.buildHelpMenu(resources, actions);\n        jMenuBar.add(helpMenu);\n        return jMenuBar;\n    }\n\n    public static Menu buildFileMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {\n        Menu fileMenu = new Menu(resources.getString(\"menu.File.name\"), resources.getString(\"menu.File.mnemonic\"));\n        fileMenu.addFollowAppAction(actions.get(Open.NAME));\n        fileMenu.addFollowAppAction(actions.get(Close.NAME));\n        fileMenu.addSeparator();\n        fileMenu.addFollowAppAction(actions.get(Reset.NAME));\n        fileMenu.addFollowAppAction(actions.get(Pause.NAME));\n        fileMenu.addSeparator();\n        recentFilesMenu = new Menu(resources.getString(\"menu.RecentFiles.name\"), resources.getString(\"menu.RecentFiles.mnemonic\"), FollowApp.getIcon(ComponentBuilder.class, \"menu.RecentFiles.icon\"));\n        fileMenu.add(recentFilesMenu);\n        fileMenu.addSeparator();\n        fileMenu.addFollowAppAction(actions.get(Exit.NAME));\n        return fileMenu;\n    }\n\n    public static Menu buildEditMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {\n        Menu editMenu = new Menu(resources.getString(\"menu.Edit.name\"), resources.getString(\"menu.Edit.mnemonic\"));\n        editMenu.addFollowAppAction(actions.get(Find.NAME));\n        editMenu.addFollowAppAction(actions.get(ClearHighlights.NAME));\n        editMenu.addFollowAppAction(actions.get(ClearAllHighlights.NAME));\n        editMenu.addSeparator();\n        editMenu.addFollowAppAction(actions.get(Configure.NAME));\n        return editMenu;\n    }\n\n    public static Menu buildToolsMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {\n        Menu toolsMenu = new Menu(resources.getString(\"menu.Tools.name\"), resources.getString(\"menu.Tools.mnemonic\"));\n        toolsMenu.addFollowAppAction(actions.get(Top.NAME));\n        toolsMenu.addFollowAppAction(actions.get(Bottom.NAME));\n        toolsMenu.addSeparator();\n        toolsMenu.addFollowAppAction(actions.get(Clear.NAME));\n        toolsMenu.addFollowAppAction(actions.get(ClearAll.NAME));\n        toolsMenu.addFollowAppAction(actions.get(Delete.NAME));\n        toolsMenu.addFollowAppAction(actions.get(DeleteAll.NAME));\n        toolsMenu.addSeparator();\n        toolsMenu.addFollowAppAction(actions.get(Edit.NAME));\n        return toolsMenu;\n    }\n\n    public static Menu buildWindowMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {\n        Menu windowMenu = new Menu(resources.getString(\"menu.Window.name\"), resources.getString(\"menu.Window.mnemonic\"));\n        windowMenu.addFollowAppAction(actions.get(NextTab.NAME));\n        windowMenu.addFollowAppAction(actions.get(PreviousTab.NAME));\n        return windowMenu;\n    }\n\n    public static Menu buildHelpMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {\n        Menu helpMenu = new Menu(resources.getString(\"menu.Help.name\"), resources.getString(\"menu.Help.mnemonic\"));\n        helpMenu.addFollowAppAction(actions.get(About.NAME));\n        return helpMenu;\n    }\n\n    /**\n     * Builds the popup menu shown when right clicking in a text area.\n     *\n     * @return\n     */\n    public static PopupMenu buildPopupMenu(HashMap<String, FollowAppAction> actions) {\n        PopupMenu popupMenu = new PopupMenu();\n        popupMenu.addFollowAppAction(actions.get(Open.NAME));\n        popupMenu.addFollowAppAction(actions.get(Close.NAME));\n        popupMenu.addSeparator();\n        popupMenu.addFollowAppAction(actions.get(Reset.NAME));\n        popupMenu.addFollowAppAction(actions.get(Pause.NAME));\n        popupMenu.addSeparator();\n        popupMenu.addFollowAppAction(actions.get(Top.NAME));\n        popupMenu.addFollowAppAction(actions.get(Bottom.NAME));\n        popupMenu.addSeparator();\n        popupMenu.addFollowAppAction(actions.get(Clear.NAME));\n        popupMenu.addFollowAppAction(actions.get(Delete.NAME));\n        popupMenu.addSeparator();\n        popupMenu.addFollowAppAction(actions.get(Configure.NAME));\n        popupMenu.addFollowAppAction(actions.get(Edit.NAME));\n        return popupMenu;\n    }\n\n    /**\n     * Builds the toolbar shown at the top of the application\n     *\n     * @return\n     */\n    public static ToolBar buildToolBar(HashMap<String, FollowAppAction> actions) {\n        ToolBar toolBar = new ToolBar();\n        toolBar.addFollowAppAction(actions.get(Open.NAME));\n        toolBar.addSeparator();\n        toolBar.addFollowAppAction(actions.get(Top.NAME));\n        toolBar.addFollowAppAction(actions.get(Bottom.NAME));\n        toolBar.addSeparator();\n        toolBar.addFollowAppAction(actions.get(Clear.NAME));\n        toolBar.addFollowAppAction(actions.get(ClearAll.NAME));\n        toolBar.addFollowAppAction(actions.get(Delete.NAME));\n        toolBar.addFollowAppAction(actions.get(DeleteAll.NAME));\n        toolBar.addSeparator();\n        toolBar.addFollowAppAction(actions.get(Reset.NAME));\n        toolBar.addFollowAppAction(actions.get(Pause.NAME));\n        toolBar.addSeparator();\n        toolBar.addFollowAppAction(actions.get(Configure.NAME));\n        return toolBar;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/gui/ComponentBuilderTest3.java",
		"test_prompt": "// ComponentBuilderTest3.java\npackage ghm.follow.gui;\n\nimport ghm.follow.FollowApp;\nimport ghm.follow.config.Configure;\nimport ghm.follow.nav.Bottom;\nimport ghm.follow.nav.NextTab;\nimport ghm.follow.nav.PreviousTab;\nimport ghm.follow.nav.Top;\nimport ghm.follow.search.ClearAllHighlights;\nimport ghm.follow.search.ClearHighlights;\nimport ghm.follow.search.Find;\nimport java.util.HashMap;\nimport java.util.ResourceBundle;\nimport javax.swing.JMenuBar;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ComponentBuilder}.\n* It contains ten unit test cases for the {@link ComponentBuilder#buildToolsMenu(ResourceBundle, HashMap)} method.\n*/\nclass ComponentBuilderTest3 {"
	},
	{
		"original_code": "// ComponentBuilder.java\npackage ghm.follow.gui;\n\nimport ghm.follow.FollowApp;\nimport ghm.follow.config.Configure;\nimport ghm.follow.nav.Bottom;\nimport ghm.follow.nav.NextTab;\nimport ghm.follow.nav.PreviousTab;\nimport ghm.follow.nav.Top;\nimport ghm.follow.search.ClearAllHighlights;\nimport ghm.follow.search.ClearHighlights;\nimport ghm.follow.search.Find;\nimport java.util.HashMap;\nimport java.util.ResourceBundle;\nimport javax.swing.JMenuBar;\n\npublic class ComponentBuilder {\n\n    public static Menu fileMenu;\n\n    public static Menu editMenu;\n\n    public static Menu toolsMenu;\n\n    public static Menu windowMenu;\n\n    public static Menu helpMenu;\n\n    // file menu items\n    public static Menu recentFilesMenu;\n\n    private ComponentBuilder() {\n    }\n\n    /**\n     * Builds the menu bar for the application\n     *\n     * @return reference the constructed menu bar\n     */\n    public static JMenuBar buildMenuBar(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {\n        // create menu bar and add menus\n        JMenuBar jMenuBar = new JMenuBar();\n        // file menu\n        fileMenu = ComponentBuilder.buildFileMenu(resources, actions);\n        jMenuBar.add(fileMenu);\n        // edit menu\n        editMenu = ComponentBuilder.buildEditMenu(resources, actions);\n        jMenuBar.add(editMenu);\n        // tool menu\n        toolsMenu = ComponentBuilder.buildToolsMenu(resources, actions);\n        jMenuBar.add(toolsMenu);\n        // window menu\n        windowMenu = ComponentBuilder.buildWindowMenu(resources, actions);\n        jMenuBar.add(windowMenu);\n        // help menu\n        helpMenu = ComponentBuilder.buildHelpMenu(resources, actions);\n        jMenuBar.add(helpMenu);\n        return jMenuBar;\n    }\n\n    public static Menu buildFileMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {\n        Menu fileMenu = new Menu(resources.getString(\"menu.File.name\"), resources.getString(\"menu.File.mnemonic\"));\n        fileMenu.addFollowAppAction(actions.get(Open.NAME));\n        fileMenu.addFollowAppAction(actions.get(Close.NAME));\n        fileMenu.addSeparator();\n        fileMenu.addFollowAppAction(actions.get(Reset.NAME));\n        fileMenu.addFollowAppAction(actions.get(Pause.NAME));\n        fileMenu.addSeparator();\n        recentFilesMenu = new Menu(resources.getString(\"menu.RecentFiles.name\"), resources.getString(\"menu.RecentFiles.mnemonic\"), FollowApp.getIcon(ComponentBuilder.class, \"menu.RecentFiles.icon\"));\n        fileMenu.add(recentFilesMenu);\n        fileMenu.addSeparator();\n        fileMenu.addFollowAppAction(actions.get(Exit.NAME));\n        return fileMenu;\n    }\n\n    public static Menu buildEditMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {\n        Menu editMenu = new Menu(resources.getString(\"menu.Edit.name\"), resources.getString(\"menu.Edit.mnemonic\"));\n        editMenu.addFollowAppAction(actions.get(Find.NAME));\n        editMenu.addFollowAppAction(actions.get(ClearHighlights.NAME));\n        editMenu.addFollowAppAction(actions.get(ClearAllHighlights.NAME));\n        editMenu.addSeparator();\n        editMenu.addFollowAppAction(actions.get(Configure.NAME));\n        return editMenu;\n    }\n\n    public static Menu buildToolsMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {\n        Menu toolsMenu = new Menu(resources.getString(\"menu.Tools.name\"), resources.getString(\"menu.Tools.mnemonic\"));\n        toolsMenu.addFollowAppAction(actions.get(Top.NAME));\n        toolsMenu.addFollowAppAction(actions.get(Bottom.NAME));\n        toolsMenu.addSeparator();\n        toolsMenu.addFollowAppAction(actions.get(Clear.NAME));\n        toolsMenu.addFollowAppAction(actions.get(ClearAll.NAME));\n        toolsMenu.addFollowAppAction(actions.get(Delete.NAME));\n        toolsMenu.addFollowAppAction(actions.get(DeleteAll.NAME));\n        toolsMenu.addSeparator();\n        toolsMenu.addFollowAppAction(actions.get(Edit.NAME));\n        return toolsMenu;\n    }\n\n    public static Menu buildWindowMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {\n        Menu windowMenu = new Menu(resources.getString(\"menu.Window.name\"), resources.getString(\"menu.Window.mnemonic\"));\n        windowMenu.addFollowAppAction(actions.get(NextTab.NAME));\n        windowMenu.addFollowAppAction(actions.get(PreviousTab.NAME));\n        return windowMenu;\n    }\n\n    public static Menu buildHelpMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {\n        Menu helpMenu = new Menu(resources.getString(\"menu.Help.name\"), resources.getString(\"menu.Help.mnemonic\"));\n        helpMenu.addFollowAppAction(actions.get(About.NAME));\n        return helpMenu;\n    }\n\n    /**\n     * Builds the popup menu shown when right clicking in a text area.\n     *\n     * @return\n     */\n    public static PopupMenu buildPopupMenu(HashMap<String, FollowAppAction> actions) {\n        PopupMenu popupMenu = new PopupMenu();\n        popupMenu.addFollowAppAction(actions.get(Open.NAME));\n        popupMenu.addFollowAppAction(actions.get(Close.NAME));\n        popupMenu.addSeparator();\n        popupMenu.addFollowAppAction(actions.get(Reset.NAME));\n        popupMenu.addFollowAppAction(actions.get(Pause.NAME));\n        popupMenu.addSeparator();\n        popupMenu.addFollowAppAction(actions.get(Top.NAME));\n        popupMenu.addFollowAppAction(actions.get(Bottom.NAME));\n        popupMenu.addSeparator();\n        popupMenu.addFollowAppAction(actions.get(Clear.NAME));\n        popupMenu.addFollowAppAction(actions.get(Delete.NAME));\n        popupMenu.addSeparator();\n        popupMenu.addFollowAppAction(actions.get(Configure.NAME));\n        popupMenu.addFollowAppAction(actions.get(Edit.NAME));\n        return popupMenu;\n    }\n\n    /**\n     * Builds the toolbar shown at the top of the application\n     *\n     * @return\n     */\n    public static ToolBar buildToolBar(HashMap<String, FollowAppAction> actions) {\n        ToolBar toolBar = new ToolBar();\n        toolBar.addFollowAppAction(actions.get(Open.NAME));\n        toolBar.addSeparator();\n        toolBar.addFollowAppAction(actions.get(Top.NAME));\n        toolBar.addFollowAppAction(actions.get(Bottom.NAME));\n        toolBar.addSeparator();\n        toolBar.addFollowAppAction(actions.get(Clear.NAME));\n        toolBar.addFollowAppAction(actions.get(ClearAll.NAME));\n        toolBar.addFollowAppAction(actions.get(Delete.NAME));\n        toolBar.addFollowAppAction(actions.get(DeleteAll.NAME));\n        toolBar.addSeparator();\n        toolBar.addFollowAppAction(actions.get(Reset.NAME));\n        toolBar.addFollowAppAction(actions.get(Pause.NAME));\n        toolBar.addSeparator();\n        toolBar.addFollowAppAction(actions.get(Configure.NAME));\n        return toolBar;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/gui/ComponentBuilderTest4.java",
		"test_prompt": "// ComponentBuilderTest4.java\npackage ghm.follow.gui;\n\nimport ghm.follow.FollowApp;\nimport ghm.follow.config.Configure;\nimport ghm.follow.nav.Bottom;\nimport ghm.follow.nav.NextTab;\nimport ghm.follow.nav.PreviousTab;\nimport ghm.follow.nav.Top;\nimport ghm.follow.search.ClearAllHighlights;\nimport ghm.follow.search.ClearHighlights;\nimport ghm.follow.search.Find;\nimport java.util.HashMap;\nimport java.util.ResourceBundle;\nimport javax.swing.JMenuBar;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ComponentBuilder}.\n* It contains ten unit test cases for the {@link ComponentBuilder#buildWindowMenu(ResourceBundle, HashMap)} method.\n*/\nclass ComponentBuilderTest4 {"
	},
	{
		"original_code": "// ComponentBuilder.java\npackage ghm.follow.gui;\n\nimport ghm.follow.FollowApp;\nimport ghm.follow.config.Configure;\nimport ghm.follow.nav.Bottom;\nimport ghm.follow.nav.NextTab;\nimport ghm.follow.nav.PreviousTab;\nimport ghm.follow.nav.Top;\nimport ghm.follow.search.ClearAllHighlights;\nimport ghm.follow.search.ClearHighlights;\nimport ghm.follow.search.Find;\nimport java.util.HashMap;\nimport java.util.ResourceBundle;\nimport javax.swing.JMenuBar;\n\npublic class ComponentBuilder {\n\n    public static Menu fileMenu;\n\n    public static Menu editMenu;\n\n    public static Menu toolsMenu;\n\n    public static Menu windowMenu;\n\n    public static Menu helpMenu;\n\n    // file menu items\n    public static Menu recentFilesMenu;\n\n    private ComponentBuilder() {\n    }\n\n    /**\n     * Builds the menu bar for the application\n     *\n     * @return reference the constructed menu bar\n     */\n    public static JMenuBar buildMenuBar(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {\n        // create menu bar and add menus\n        JMenuBar jMenuBar = new JMenuBar();\n        // file menu\n        fileMenu = ComponentBuilder.buildFileMenu(resources, actions);\n        jMenuBar.add(fileMenu);\n        // edit menu\n        editMenu = ComponentBuilder.buildEditMenu(resources, actions);\n        jMenuBar.add(editMenu);\n        // tool menu\n        toolsMenu = ComponentBuilder.buildToolsMenu(resources, actions);\n        jMenuBar.add(toolsMenu);\n        // window menu\n        windowMenu = ComponentBuilder.buildWindowMenu(resources, actions);\n        jMenuBar.add(windowMenu);\n        // help menu\n        helpMenu = ComponentBuilder.buildHelpMenu(resources, actions);\n        jMenuBar.add(helpMenu);\n        return jMenuBar;\n    }\n\n    public static Menu buildFileMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {\n        Menu fileMenu = new Menu(resources.getString(\"menu.File.name\"), resources.getString(\"menu.File.mnemonic\"));\n        fileMenu.addFollowAppAction(actions.get(Open.NAME));\n        fileMenu.addFollowAppAction(actions.get(Close.NAME));\n        fileMenu.addSeparator();\n        fileMenu.addFollowAppAction(actions.get(Reset.NAME));\n        fileMenu.addFollowAppAction(actions.get(Pause.NAME));\n        fileMenu.addSeparator();\n        recentFilesMenu = new Menu(resources.getString(\"menu.RecentFiles.name\"), resources.getString(\"menu.RecentFiles.mnemonic\"), FollowApp.getIcon(ComponentBuilder.class, \"menu.RecentFiles.icon\"));\n        fileMenu.add(recentFilesMenu);\n        fileMenu.addSeparator();\n        fileMenu.addFollowAppAction(actions.get(Exit.NAME));\n        return fileMenu;\n    }\n\n    public static Menu buildEditMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {\n        Menu editMenu = new Menu(resources.getString(\"menu.Edit.name\"), resources.getString(\"menu.Edit.mnemonic\"));\n        editMenu.addFollowAppAction(actions.get(Find.NAME));\n        editMenu.addFollowAppAction(actions.get(ClearHighlights.NAME));\n        editMenu.addFollowAppAction(actions.get(ClearAllHighlights.NAME));\n        editMenu.addSeparator();\n        editMenu.addFollowAppAction(actions.get(Configure.NAME));\n        return editMenu;\n    }\n\n    public static Menu buildToolsMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {\n        Menu toolsMenu = new Menu(resources.getString(\"menu.Tools.name\"), resources.getString(\"menu.Tools.mnemonic\"));\n        toolsMenu.addFollowAppAction(actions.get(Top.NAME));\n        toolsMenu.addFollowAppAction(actions.get(Bottom.NAME));\n        toolsMenu.addSeparator();\n        toolsMenu.addFollowAppAction(actions.get(Clear.NAME));\n        toolsMenu.addFollowAppAction(actions.get(ClearAll.NAME));\n        toolsMenu.addFollowAppAction(actions.get(Delete.NAME));\n        toolsMenu.addFollowAppAction(actions.get(DeleteAll.NAME));\n        toolsMenu.addSeparator();\n        toolsMenu.addFollowAppAction(actions.get(Edit.NAME));\n        return toolsMenu;\n    }\n\n    public static Menu buildWindowMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {\n        Menu windowMenu = new Menu(resources.getString(\"menu.Window.name\"), resources.getString(\"menu.Window.mnemonic\"));\n        windowMenu.addFollowAppAction(actions.get(NextTab.NAME));\n        windowMenu.addFollowAppAction(actions.get(PreviousTab.NAME));\n        return windowMenu;\n    }\n\n    public static Menu buildHelpMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {\n        Menu helpMenu = new Menu(resources.getString(\"menu.Help.name\"), resources.getString(\"menu.Help.mnemonic\"));\n        helpMenu.addFollowAppAction(actions.get(About.NAME));\n        return helpMenu;\n    }\n\n    /**\n     * Builds the popup menu shown when right clicking in a text area.\n     *\n     * @return\n     */\n    public static PopupMenu buildPopupMenu(HashMap<String, FollowAppAction> actions) {\n        PopupMenu popupMenu = new PopupMenu();\n        popupMenu.addFollowAppAction(actions.get(Open.NAME));\n        popupMenu.addFollowAppAction(actions.get(Close.NAME));\n        popupMenu.addSeparator();\n        popupMenu.addFollowAppAction(actions.get(Reset.NAME));\n        popupMenu.addFollowAppAction(actions.get(Pause.NAME));\n        popupMenu.addSeparator();\n        popupMenu.addFollowAppAction(actions.get(Top.NAME));\n        popupMenu.addFollowAppAction(actions.get(Bottom.NAME));\n        popupMenu.addSeparator();\n        popupMenu.addFollowAppAction(actions.get(Clear.NAME));\n        popupMenu.addFollowAppAction(actions.get(Delete.NAME));\n        popupMenu.addSeparator();\n        popupMenu.addFollowAppAction(actions.get(Configure.NAME));\n        popupMenu.addFollowAppAction(actions.get(Edit.NAME));\n        return popupMenu;\n    }\n\n    /**\n     * Builds the toolbar shown at the top of the application\n     *\n     * @return\n     */\n    public static ToolBar buildToolBar(HashMap<String, FollowAppAction> actions) {\n        ToolBar toolBar = new ToolBar();\n        toolBar.addFollowAppAction(actions.get(Open.NAME));\n        toolBar.addSeparator();\n        toolBar.addFollowAppAction(actions.get(Top.NAME));\n        toolBar.addFollowAppAction(actions.get(Bottom.NAME));\n        toolBar.addSeparator();\n        toolBar.addFollowAppAction(actions.get(Clear.NAME));\n        toolBar.addFollowAppAction(actions.get(ClearAll.NAME));\n        toolBar.addFollowAppAction(actions.get(Delete.NAME));\n        toolBar.addFollowAppAction(actions.get(DeleteAll.NAME));\n        toolBar.addSeparator();\n        toolBar.addFollowAppAction(actions.get(Reset.NAME));\n        toolBar.addFollowAppAction(actions.get(Pause.NAME));\n        toolBar.addSeparator();\n        toolBar.addFollowAppAction(actions.get(Configure.NAME));\n        return toolBar;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/gui/ComponentBuilderTest5.java",
		"test_prompt": "// ComponentBuilderTest5.java\npackage ghm.follow.gui;\n\nimport ghm.follow.FollowApp;\nimport ghm.follow.config.Configure;\nimport ghm.follow.nav.Bottom;\nimport ghm.follow.nav.NextTab;\nimport ghm.follow.nav.PreviousTab;\nimport ghm.follow.nav.Top;\nimport ghm.follow.search.ClearAllHighlights;\nimport ghm.follow.search.ClearHighlights;\nimport ghm.follow.search.Find;\nimport java.util.HashMap;\nimport java.util.ResourceBundle;\nimport javax.swing.JMenuBar;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ComponentBuilder}.\n* It contains ten unit test cases for the {@link ComponentBuilder#buildHelpMenu(ResourceBundle, HashMap)} method.\n*/\nclass ComponentBuilderTest5 {"
	},
	{
		"original_code": "// ComponentBuilder.java\npackage ghm.follow.gui;\n\nimport ghm.follow.FollowApp;\nimport ghm.follow.config.Configure;\nimport ghm.follow.nav.Bottom;\nimport ghm.follow.nav.NextTab;\nimport ghm.follow.nav.PreviousTab;\nimport ghm.follow.nav.Top;\nimport ghm.follow.search.ClearAllHighlights;\nimport ghm.follow.search.ClearHighlights;\nimport ghm.follow.search.Find;\nimport java.util.HashMap;\nimport java.util.ResourceBundle;\nimport javax.swing.JMenuBar;\n\npublic class ComponentBuilder {\n\n    public static Menu fileMenu;\n\n    public static Menu editMenu;\n\n    public static Menu toolsMenu;\n\n    public static Menu windowMenu;\n\n    public static Menu helpMenu;\n\n    // file menu items\n    public static Menu recentFilesMenu;\n\n    private ComponentBuilder() {\n    }\n\n    /**\n     * Builds the menu bar for the application\n     *\n     * @return reference the constructed menu bar\n     */\n    public static JMenuBar buildMenuBar(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {\n        // create menu bar and add menus\n        JMenuBar jMenuBar = new JMenuBar();\n        // file menu\n        fileMenu = ComponentBuilder.buildFileMenu(resources, actions);\n        jMenuBar.add(fileMenu);\n        // edit menu\n        editMenu = ComponentBuilder.buildEditMenu(resources, actions);\n        jMenuBar.add(editMenu);\n        // tool menu\n        toolsMenu = ComponentBuilder.buildToolsMenu(resources, actions);\n        jMenuBar.add(toolsMenu);\n        // window menu\n        windowMenu = ComponentBuilder.buildWindowMenu(resources, actions);\n        jMenuBar.add(windowMenu);\n        // help menu\n        helpMenu = ComponentBuilder.buildHelpMenu(resources, actions);\n        jMenuBar.add(helpMenu);\n        return jMenuBar;\n    }\n\n    public static Menu buildFileMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {\n        Menu fileMenu = new Menu(resources.getString(\"menu.File.name\"), resources.getString(\"menu.File.mnemonic\"));\n        fileMenu.addFollowAppAction(actions.get(Open.NAME));\n        fileMenu.addFollowAppAction(actions.get(Close.NAME));\n        fileMenu.addSeparator();\n        fileMenu.addFollowAppAction(actions.get(Reset.NAME));\n        fileMenu.addFollowAppAction(actions.get(Pause.NAME));\n        fileMenu.addSeparator();\n        recentFilesMenu = new Menu(resources.getString(\"menu.RecentFiles.name\"), resources.getString(\"menu.RecentFiles.mnemonic\"), FollowApp.getIcon(ComponentBuilder.class, \"menu.RecentFiles.icon\"));\n        fileMenu.add(recentFilesMenu);\n        fileMenu.addSeparator();\n        fileMenu.addFollowAppAction(actions.get(Exit.NAME));\n        return fileMenu;\n    }\n\n    public static Menu buildEditMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {\n        Menu editMenu = new Menu(resources.getString(\"menu.Edit.name\"), resources.getString(\"menu.Edit.mnemonic\"));\n        editMenu.addFollowAppAction(actions.get(Find.NAME));\n        editMenu.addFollowAppAction(actions.get(ClearHighlights.NAME));\n        editMenu.addFollowAppAction(actions.get(ClearAllHighlights.NAME));\n        editMenu.addSeparator();\n        editMenu.addFollowAppAction(actions.get(Configure.NAME));\n        return editMenu;\n    }\n\n    public static Menu buildToolsMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {\n        Menu toolsMenu = new Menu(resources.getString(\"menu.Tools.name\"), resources.getString(\"menu.Tools.mnemonic\"));\n        toolsMenu.addFollowAppAction(actions.get(Top.NAME));\n        toolsMenu.addFollowAppAction(actions.get(Bottom.NAME));\n        toolsMenu.addSeparator();\n        toolsMenu.addFollowAppAction(actions.get(Clear.NAME));\n        toolsMenu.addFollowAppAction(actions.get(ClearAll.NAME));\n        toolsMenu.addFollowAppAction(actions.get(Delete.NAME));\n        toolsMenu.addFollowAppAction(actions.get(DeleteAll.NAME));\n        toolsMenu.addSeparator();\n        toolsMenu.addFollowAppAction(actions.get(Edit.NAME));\n        return toolsMenu;\n    }\n\n    public static Menu buildWindowMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {\n        Menu windowMenu = new Menu(resources.getString(\"menu.Window.name\"), resources.getString(\"menu.Window.mnemonic\"));\n        windowMenu.addFollowAppAction(actions.get(NextTab.NAME));\n        windowMenu.addFollowAppAction(actions.get(PreviousTab.NAME));\n        return windowMenu;\n    }\n\n    public static Menu buildHelpMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {\n        Menu helpMenu = new Menu(resources.getString(\"menu.Help.name\"), resources.getString(\"menu.Help.mnemonic\"));\n        helpMenu.addFollowAppAction(actions.get(About.NAME));\n        return helpMenu;\n    }\n\n    /**\n     * Builds the popup menu shown when right clicking in a text area.\n     *\n     * @return\n     */\n    public static PopupMenu buildPopupMenu(HashMap<String, FollowAppAction> actions) {\n        PopupMenu popupMenu = new PopupMenu();\n        popupMenu.addFollowAppAction(actions.get(Open.NAME));\n        popupMenu.addFollowAppAction(actions.get(Close.NAME));\n        popupMenu.addSeparator();\n        popupMenu.addFollowAppAction(actions.get(Reset.NAME));\n        popupMenu.addFollowAppAction(actions.get(Pause.NAME));\n        popupMenu.addSeparator();\n        popupMenu.addFollowAppAction(actions.get(Top.NAME));\n        popupMenu.addFollowAppAction(actions.get(Bottom.NAME));\n        popupMenu.addSeparator();\n        popupMenu.addFollowAppAction(actions.get(Clear.NAME));\n        popupMenu.addFollowAppAction(actions.get(Delete.NAME));\n        popupMenu.addSeparator();\n        popupMenu.addFollowAppAction(actions.get(Configure.NAME));\n        popupMenu.addFollowAppAction(actions.get(Edit.NAME));\n        return popupMenu;\n    }\n\n    /**\n     * Builds the toolbar shown at the top of the application\n     *\n     * @return\n     */\n    public static ToolBar buildToolBar(HashMap<String, FollowAppAction> actions) {\n        ToolBar toolBar = new ToolBar();\n        toolBar.addFollowAppAction(actions.get(Open.NAME));\n        toolBar.addSeparator();\n        toolBar.addFollowAppAction(actions.get(Top.NAME));\n        toolBar.addFollowAppAction(actions.get(Bottom.NAME));\n        toolBar.addSeparator();\n        toolBar.addFollowAppAction(actions.get(Clear.NAME));\n        toolBar.addFollowAppAction(actions.get(ClearAll.NAME));\n        toolBar.addFollowAppAction(actions.get(Delete.NAME));\n        toolBar.addFollowAppAction(actions.get(DeleteAll.NAME));\n        toolBar.addSeparator();\n        toolBar.addFollowAppAction(actions.get(Reset.NAME));\n        toolBar.addFollowAppAction(actions.get(Pause.NAME));\n        toolBar.addSeparator();\n        toolBar.addFollowAppAction(actions.get(Configure.NAME));\n        return toolBar;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/gui/ComponentBuilderTest6.java",
		"test_prompt": "// ComponentBuilderTest6.java\npackage ghm.follow.gui;\n\nimport ghm.follow.FollowApp;\nimport ghm.follow.config.Configure;\nimport ghm.follow.nav.Bottom;\nimport ghm.follow.nav.NextTab;\nimport ghm.follow.nav.PreviousTab;\nimport ghm.follow.nav.Top;\nimport ghm.follow.search.ClearAllHighlights;\nimport ghm.follow.search.ClearHighlights;\nimport ghm.follow.search.Find;\nimport java.util.HashMap;\nimport java.util.ResourceBundle;\nimport javax.swing.JMenuBar;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ComponentBuilder}.\n* It contains ten unit test cases for the {@link ComponentBuilder#buildPopupMenu(HashMap)} method.\n*/\nclass ComponentBuilderTest6 {"
	},
	{
		"original_code": "// ComponentBuilder.java\npackage ghm.follow.gui;\n\nimport ghm.follow.FollowApp;\nimport ghm.follow.config.Configure;\nimport ghm.follow.nav.Bottom;\nimport ghm.follow.nav.NextTab;\nimport ghm.follow.nav.PreviousTab;\nimport ghm.follow.nav.Top;\nimport ghm.follow.search.ClearAllHighlights;\nimport ghm.follow.search.ClearHighlights;\nimport ghm.follow.search.Find;\nimport java.util.HashMap;\nimport java.util.ResourceBundle;\nimport javax.swing.JMenuBar;\n\npublic class ComponentBuilder {\n\n    public static Menu fileMenu;\n\n    public static Menu editMenu;\n\n    public static Menu toolsMenu;\n\n    public static Menu windowMenu;\n\n    public static Menu helpMenu;\n\n    // file menu items\n    public static Menu recentFilesMenu;\n\n    private ComponentBuilder() {\n    }\n\n    /**\n     * Builds the menu bar for the application\n     *\n     * @return reference the constructed menu bar\n     */\n    public static JMenuBar buildMenuBar(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {\n        // create menu bar and add menus\n        JMenuBar jMenuBar = new JMenuBar();\n        // file menu\n        fileMenu = ComponentBuilder.buildFileMenu(resources, actions);\n        jMenuBar.add(fileMenu);\n        // edit menu\n        editMenu = ComponentBuilder.buildEditMenu(resources, actions);\n        jMenuBar.add(editMenu);\n        // tool menu\n        toolsMenu = ComponentBuilder.buildToolsMenu(resources, actions);\n        jMenuBar.add(toolsMenu);\n        // window menu\n        windowMenu = ComponentBuilder.buildWindowMenu(resources, actions);\n        jMenuBar.add(windowMenu);\n        // help menu\n        helpMenu = ComponentBuilder.buildHelpMenu(resources, actions);\n        jMenuBar.add(helpMenu);\n        return jMenuBar;\n    }\n\n    public static Menu buildFileMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {\n        Menu fileMenu = new Menu(resources.getString(\"menu.File.name\"), resources.getString(\"menu.File.mnemonic\"));\n        fileMenu.addFollowAppAction(actions.get(Open.NAME));\n        fileMenu.addFollowAppAction(actions.get(Close.NAME));\n        fileMenu.addSeparator();\n        fileMenu.addFollowAppAction(actions.get(Reset.NAME));\n        fileMenu.addFollowAppAction(actions.get(Pause.NAME));\n        fileMenu.addSeparator();\n        recentFilesMenu = new Menu(resources.getString(\"menu.RecentFiles.name\"), resources.getString(\"menu.RecentFiles.mnemonic\"), FollowApp.getIcon(ComponentBuilder.class, \"menu.RecentFiles.icon\"));\n        fileMenu.add(recentFilesMenu);\n        fileMenu.addSeparator();\n        fileMenu.addFollowAppAction(actions.get(Exit.NAME));\n        return fileMenu;\n    }\n\n    public static Menu buildEditMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {\n        Menu editMenu = new Menu(resources.getString(\"menu.Edit.name\"), resources.getString(\"menu.Edit.mnemonic\"));\n        editMenu.addFollowAppAction(actions.get(Find.NAME));\n        editMenu.addFollowAppAction(actions.get(ClearHighlights.NAME));\n        editMenu.addFollowAppAction(actions.get(ClearAllHighlights.NAME));\n        editMenu.addSeparator();\n        editMenu.addFollowAppAction(actions.get(Configure.NAME));\n        return editMenu;\n    }\n\n    public static Menu buildToolsMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {\n        Menu toolsMenu = new Menu(resources.getString(\"menu.Tools.name\"), resources.getString(\"menu.Tools.mnemonic\"));\n        toolsMenu.addFollowAppAction(actions.get(Top.NAME));\n        toolsMenu.addFollowAppAction(actions.get(Bottom.NAME));\n        toolsMenu.addSeparator();\n        toolsMenu.addFollowAppAction(actions.get(Clear.NAME));\n        toolsMenu.addFollowAppAction(actions.get(ClearAll.NAME));\n        toolsMenu.addFollowAppAction(actions.get(Delete.NAME));\n        toolsMenu.addFollowAppAction(actions.get(DeleteAll.NAME));\n        toolsMenu.addSeparator();\n        toolsMenu.addFollowAppAction(actions.get(Edit.NAME));\n        return toolsMenu;\n    }\n\n    public static Menu buildWindowMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {\n        Menu windowMenu = new Menu(resources.getString(\"menu.Window.name\"), resources.getString(\"menu.Window.mnemonic\"));\n        windowMenu.addFollowAppAction(actions.get(NextTab.NAME));\n        windowMenu.addFollowAppAction(actions.get(PreviousTab.NAME));\n        return windowMenu;\n    }\n\n    public static Menu buildHelpMenu(ResourceBundle resources, HashMap<String, FollowAppAction> actions) {\n        Menu helpMenu = new Menu(resources.getString(\"menu.Help.name\"), resources.getString(\"menu.Help.mnemonic\"));\n        helpMenu.addFollowAppAction(actions.get(About.NAME));\n        return helpMenu;\n    }\n\n    /**\n     * Builds the popup menu shown when right clicking in a text area.\n     *\n     * @return\n     */\n    public static PopupMenu buildPopupMenu(HashMap<String, FollowAppAction> actions) {\n        PopupMenu popupMenu = new PopupMenu();\n        popupMenu.addFollowAppAction(actions.get(Open.NAME));\n        popupMenu.addFollowAppAction(actions.get(Close.NAME));\n        popupMenu.addSeparator();\n        popupMenu.addFollowAppAction(actions.get(Reset.NAME));\n        popupMenu.addFollowAppAction(actions.get(Pause.NAME));\n        popupMenu.addSeparator();\n        popupMenu.addFollowAppAction(actions.get(Top.NAME));\n        popupMenu.addFollowAppAction(actions.get(Bottom.NAME));\n        popupMenu.addSeparator();\n        popupMenu.addFollowAppAction(actions.get(Clear.NAME));\n        popupMenu.addFollowAppAction(actions.get(Delete.NAME));\n        popupMenu.addSeparator();\n        popupMenu.addFollowAppAction(actions.get(Configure.NAME));\n        popupMenu.addFollowAppAction(actions.get(Edit.NAME));\n        return popupMenu;\n    }\n\n    /**\n     * Builds the toolbar shown at the top of the application\n     *\n     * @return\n     */\n    public static ToolBar buildToolBar(HashMap<String, FollowAppAction> actions) {\n        ToolBar toolBar = new ToolBar();\n        toolBar.addFollowAppAction(actions.get(Open.NAME));\n        toolBar.addSeparator();\n        toolBar.addFollowAppAction(actions.get(Top.NAME));\n        toolBar.addFollowAppAction(actions.get(Bottom.NAME));\n        toolBar.addSeparator();\n        toolBar.addFollowAppAction(actions.get(Clear.NAME));\n        toolBar.addFollowAppAction(actions.get(ClearAll.NAME));\n        toolBar.addFollowAppAction(actions.get(Delete.NAME));\n        toolBar.addFollowAppAction(actions.get(DeleteAll.NAME));\n        toolBar.addSeparator();\n        toolBar.addFollowAppAction(actions.get(Reset.NAME));\n        toolBar.addFollowAppAction(actions.get(Pause.NAME));\n        toolBar.addSeparator();\n        toolBar.addFollowAppAction(actions.get(Configure.NAME));\n        return toolBar;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/gui/ComponentBuilderTest7.java",
		"test_prompt": "// ComponentBuilderTest7.java\npackage ghm.follow.gui;\n\nimport ghm.follow.FollowApp;\nimport ghm.follow.config.Configure;\nimport ghm.follow.nav.Bottom;\nimport ghm.follow.nav.NextTab;\nimport ghm.follow.nav.PreviousTab;\nimport ghm.follow.nav.Top;\nimport ghm.follow.search.ClearAllHighlights;\nimport ghm.follow.search.ClearHighlights;\nimport ghm.follow.search.Find;\nimport java.util.HashMap;\nimport java.util.ResourceBundle;\nimport javax.swing.JMenuBar;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ComponentBuilder}.\n* It contains ten unit test cases for the {@link ComponentBuilder#buildToolBar(HashMap)} method.\n*/\nclass ComponentBuilderTest7 {"
	},
	{
		"original_code": "// TabbedPane.java\n/* \n Copyright (C) 2000-2003 Greg Merrill (greghmerrill@yahoo.com)\n\n This file is part of Follow (http://follow.sf.net).\n\n Follow is free software; you can redistribute it and/or modify\n it under the terms of version 2 of the GNU General Public\n License as published by the Free Software Foundation.\n\n Follow is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n\n You should have received a copy of the GNU General Public License\n along with Follow; if not, write to the Free Software\n Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\npackage ghm.follow.gui;\n\nimport ghm.follow.config.FollowAppAttributes;\nimport java.awt.Component;\nimport java.awt.Container;\nimport java.io.File;\nimport javax.swing.JTabbedPane;\n\n/**\n * Derived from a workaround proposed by sqrrrl for bug <a\n * href=\"http://developer.java.sun.com/developer/bugParade/bugs/4193463.html\" >4193463</a>. This\n * bug was causing drag-and-drop to behave incorrectly for all but the first tab.\n */\npublic class TabbedPane extends JTabbedPane {\n\n    private FollowAppAttributes attributes = null;\n\n    public TabbedPane(FollowAppAttributes attributes) {\n        super(attributes.getTabPlacement());\n        this.attributes = attributes;\n    }\n\n    /**\n     * sqrrrl's fix\n     */\n    public Component findComponentAt(int x, int y) {\n        if (!contains(x, y)) {\n            return null;\n        }\n        int ncomponents = getComponentCount();\n        for (int i = 0; i < ncomponents; i++) {\n            Component comp = getComponentAt(i);\n            if (comp != null) {\n                if (comp instanceof Container) {\n                    if (comp.isVisible()) {\n                        comp = ((Container) comp).findComponentAt(x - comp.getX(), y - comp.getY());\n                    }\n                } else {\n                    comp = comp.getComponentAt(x - comp.getX(), y - comp.getY());\n                }\n                if (comp != null && comp.isVisible()) {\n                    return comp;\n                }\n            }\n        }\n        return this;\n    }\n\n    public void setSelectedIndex(int index) {\n        super.setSelectedIndex(index);\n        handleSelectedFile();\n    }\n\n    public void setSelectedComponent(FileFollowingPane pane) {\n        super.setSelectedComponent(pane);\n        handleSelectedFile();\n    }\n\n    public void removeTabAt(int index) {\n        super.removeTabAt(index);\n        handleSelectedFile();\n    }\n\n    private void handleSelectedFile() {\n        FileFollowingPane pane = (FileFollowingPane) getSelectedComponent();\n        if (pane != null) {\n            File parent = pane.getFollowedFile().getParentFile();\n            attributes.setLastFileChooserDirectory(parent);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/gui/TabbedPaneTest.java",
		"test_prompt": "// TabbedPaneTest.java\npackage ghm.follow.gui;\n\nimport ghm.follow.config.FollowAppAttributes;\nimport java.awt.Component;\nimport java.awt.Container;\nimport java.io.File;\nimport javax.swing.JTabbedPane;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TabbedPane}.\n* It contains ten unit test cases for the {@link TabbedPane#findComponentAt(int, int)} method.\n*/\nclass TabbedPaneTest {"
	},
	{
		"original_code": "// FileFollowingPane.java\n/* \n Copyright (C) 2000-2003 Greg Merrill (greghmerrill@yahoo.com)\n\n This file is part of Follow (http://follow.sf.net).\n\n Follow is free software; you can redistribute it and/or modify\n it under the terms of version 2 of the GNU General Public\n License as published by the Free Software Foundation.\n\n Follow is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n\n You should have received a copy of the GNU General Public License\n along with Follow; if not, write to the Free Software\n Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\npackage ghm.follow.gui;\n\nimport ghm.follow.FileFollower;\nimport ghm.follow.io.JTextComponentDestination;\nimport ghm.follow.io.OutputDestination;\nimport ghm.follow.search.SearchableTextPane;\nimport java.awt.Font;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.swing.JScrollPane;\nimport javax.swing.text.BadLocationException;\nimport javax.swing.text.Document;\n\n/**\n * A component which allows one to view a text file to which information is being asynchronously\n * appended.\n *\n * @author <a href=\"mailto:greghmerrill@yahoo.com\">Greg Merrill</a>\n */\npublic class FileFollowingPane extends JScrollPane {\n\n    private Logger log = Logger.getLogger(FileFollowingPane.class.getName());\n\n    /**\n     * FileFollower used to print to this component\n     */\n    protected FileFollower fileFollower;\n\n    /**\n     * Text area into which followed file's contents are printed\n     */\n    protected SearchableTextPane textArea;\n\n    /**\n     * OutputDestination used w/FileFollower\n     */\n    protected JTextComponentDestination destination;\n\n    /**\n     * @param file\n     *            text file to be followed\n     * @param bufferSize\n     *            size of the character buffer inside the FileFollower used to follow the supplied\n     *            file\n     * @param latency\n     *            latency of the FileFollower used to follow the supplied file\n     */\n    public FileFollowingPane(File file, int bufferSize, int latency, boolean autoPositionCaret, Font font, int tabSize) {\n        textArea = new SearchableTextPane(font, tabSize);\n        textArea.setEditable(false);\n        textArea.setUI(new LineTextUI());\n        destination = new JTextComponentDestination(textArea, autoPositionCaret);\n        fileFollower = new FileFollower(file, bufferSize, latency, new OutputDestination[] { destination });\n        add(textArea);\n        setViewportView(textArea);\n    }\n\n    /**\n     * Returns the text area to which the followed file's contents are being printed.\n     *\n     * @return text area containing followed file's contents\n     */\n    public SearchableTextPane getTextPane() {\n        return textArea;\n    }\n\n    /**\n     * Returns whether caret is automatically repositioned to the end of the text area when text is\n     * appended to the followed file\n     *\n     * @return whether caret is automatically repositioned on append\n     */\n    public boolean autoPositionCaret() {\n        return destination.autoPositionCaret();\n    }\n\n    /**\n     * Sets whether caret is automatically repositioned to the end of the text area when text is\n     * appended to the followed file\n     *\n     * @param value\n     *            whether caret is automatically repositioned on append\n     */\n    public void setAutoPositionCaret(boolean value) {\n        destination.setAutoPositionCaret(value);\n    }\n\n    /**\n     * Returns the FileFollower which is being used to print information in this component.\n     *\n     * @return FileFollower used by this component\n     */\n    public FileFollower getFileFollower() {\n        return fileFollower;\n    }\n\n    /**\n     * Convenience method; equivalent to calling getFileFollower().getFollowedFile()\n     */\n    public File getFollowedFile() {\n        return fileFollower.getFollowedFile();\n    }\n\n    /**\n     * Convenience method; equivalent to calling getFileFollower().start()\n     */\n    public void startFollowing() {\n        fileFollower.start();\n    }\n\n    /**\n     * Convenience method; equivalent to calling getFileFollower().stop()\n     */\n    public void stopFollowing() {\n        fileFollower.stop();\n    }\n\n    /**\n     * Convenience method; equivalent to calling getFileFollower().restart()\n     */\n    public void restartFollowing() {\n        fileFollower.restart();\n    }\n\n    /**\n     * Convenience method; equivalent to calling getFileFollower().pause()\n     */\n    public void pauseFollowing() {\n        fileFollower.pause();\n    }\n\n    /**\n     * Convenience method; equivalent to calling getFileFollower().unpause()\n     */\n    public void unpauseFollowing() {\n        fileFollower.unpause();\n    }\n\n    /**\n     * Convenience method; equivalent to calling getFileFollower().isPaused()\n     *\n     * @return\n     */\n    public boolean isFollowingPaused() {\n        return fileFollower.isPaused();\n    }\n\n    /**\n     * Convenience method; equivalent to calling getFileFollower().stopAndWait()\n     */\n    public void stopFollowingAndWait() throws InterruptedException {\n        fileFollower.stopAndWait();\n    }\n\n    /**\n     * Convenience method; equivalent to called getFileFollower().isBeingFollowed()\n     *\n     * @return\n     */\n    public boolean isFollowing() {\n        return fileFollower.isBeingFollowed();\n    }\n\n    /**\n     * Clears the contents of this FileFollowingPane synchronously.\n     */\n    public void clear() throws IOException {\n        if (fileFollower.getFollowedFile().length() == 0L) {\n            return;\n        }\n        synchronized (fileFollower) {\n            try {\n                fileFollower.stopAndWait();\n            } catch (InterruptedException interruptedException) {\n                // Handle this better later\n                log.log(Level.SEVERE, \"InterrupedException in FileFollowingPane\", interruptedException);\n            }\n            // This has the effect of clearing the contents of the followed file\n            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(fileFollower.getFollowedFile()));\n            bos.close();\n            // Update textarea contents to reflect freshly cleared file\n            Document doc = textArea.getDocument();\n            try {\n                doc.remove(0, doc.getLength());\n            } catch (BadLocationException e) {\n                // Handle this better later\n                log.log(Level.WARNING, \"BadLocationException in FileFolloingPane\", e);\n            }\n            fileFollower.start();\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/gui/FileFollowingPaneTest0.java",
		"test_prompt": "// FileFollowingPaneTest0.java\npackage ghm.follow.gui;\n\nimport ghm.follow.FileFollower;\nimport ghm.follow.io.JTextComponentDestination;\nimport ghm.follow.io.OutputDestination;\nimport ghm.follow.search.SearchableTextPane;\nimport java.awt.Font;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.swing.JScrollPane;\nimport javax.swing.text.BadLocationException;\nimport javax.swing.text.Document;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileFollowingPane}.\n* It contains ten unit test cases for the {@link FileFollowingPane#autoPositionCaret()} method.\n*/\nclass FileFollowingPaneTest0 {"
	},
	{
		"original_code": "// FileFollowingPane.java\n/* \n Copyright (C) 2000-2003 Greg Merrill (greghmerrill@yahoo.com)\n\n This file is part of Follow (http://follow.sf.net).\n\n Follow is free software; you can redistribute it and/or modify\n it under the terms of version 2 of the GNU General Public\n License as published by the Free Software Foundation.\n\n Follow is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n\n You should have received a copy of the GNU General Public License\n along with Follow; if not, write to the Free Software\n Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\npackage ghm.follow.gui;\n\nimport ghm.follow.FileFollower;\nimport ghm.follow.io.JTextComponentDestination;\nimport ghm.follow.io.OutputDestination;\nimport ghm.follow.search.SearchableTextPane;\nimport java.awt.Font;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.swing.JScrollPane;\nimport javax.swing.text.BadLocationException;\nimport javax.swing.text.Document;\n\n/**\n * A component which allows one to view a text file to which information is being asynchronously\n * appended.\n *\n * @author <a href=\"mailto:greghmerrill@yahoo.com\">Greg Merrill</a>\n */\npublic class FileFollowingPane extends JScrollPane {\n\n    private Logger log = Logger.getLogger(FileFollowingPane.class.getName());\n\n    /**\n     * FileFollower used to print to this component\n     */\n    protected FileFollower fileFollower;\n\n    /**\n     * Text area into which followed file's contents are printed\n     */\n    protected SearchableTextPane textArea;\n\n    /**\n     * OutputDestination used w/FileFollower\n     */\n    protected JTextComponentDestination destination;\n\n    /**\n     * @param file\n     *            text file to be followed\n     * @param bufferSize\n     *            size of the character buffer inside the FileFollower used to follow the supplied\n     *            file\n     * @param latency\n     *            latency of the FileFollower used to follow the supplied file\n     */\n    public FileFollowingPane(File file, int bufferSize, int latency, boolean autoPositionCaret, Font font, int tabSize) {\n        textArea = new SearchableTextPane(font, tabSize);\n        textArea.setEditable(false);\n        textArea.setUI(new LineTextUI());\n        destination = new JTextComponentDestination(textArea, autoPositionCaret);\n        fileFollower = new FileFollower(file, bufferSize, latency, new OutputDestination[] { destination });\n        add(textArea);\n        setViewportView(textArea);\n    }\n\n    /**\n     * Returns the text area to which the followed file's contents are being printed.\n     *\n     * @return text area containing followed file's contents\n     */\n    public SearchableTextPane getTextPane() {\n        return textArea;\n    }\n\n    /**\n     * Returns whether caret is automatically repositioned to the end of the text area when text is\n     * appended to the followed file\n     *\n     * @return whether caret is automatically repositioned on append\n     */\n    public boolean autoPositionCaret() {\n        return destination.autoPositionCaret();\n    }\n\n    /**\n     * Sets whether caret is automatically repositioned to the end of the text area when text is\n     * appended to the followed file\n     *\n     * @param value\n     *            whether caret is automatically repositioned on append\n     */\n    public void setAutoPositionCaret(boolean value) {\n        destination.setAutoPositionCaret(value);\n    }\n\n    /**\n     * Returns the FileFollower which is being used to print information in this component.\n     *\n     * @return FileFollower used by this component\n     */\n    public FileFollower getFileFollower() {\n        return fileFollower;\n    }\n\n    /**\n     * Convenience method; equivalent to calling getFileFollower().getFollowedFile()\n     */\n    public File getFollowedFile() {\n        return fileFollower.getFollowedFile();\n    }\n\n    /**\n     * Convenience method; equivalent to calling getFileFollower().start()\n     */\n    public void startFollowing() {\n        fileFollower.start();\n    }\n\n    /**\n     * Convenience method; equivalent to calling getFileFollower().stop()\n     */\n    public void stopFollowing() {\n        fileFollower.stop();\n    }\n\n    /**\n     * Convenience method; equivalent to calling getFileFollower().restart()\n     */\n    public void restartFollowing() {\n        fileFollower.restart();\n    }\n\n    /**\n     * Convenience method; equivalent to calling getFileFollower().pause()\n     */\n    public void pauseFollowing() {\n        fileFollower.pause();\n    }\n\n    /**\n     * Convenience method; equivalent to calling getFileFollower().unpause()\n     */\n    public void unpauseFollowing() {\n        fileFollower.unpause();\n    }\n\n    /**\n     * Convenience method; equivalent to calling getFileFollower().isPaused()\n     *\n     * @return\n     */\n    public boolean isFollowingPaused() {\n        return fileFollower.isPaused();\n    }\n\n    /**\n     * Convenience method; equivalent to calling getFileFollower().stopAndWait()\n     */\n    public void stopFollowingAndWait() throws InterruptedException {\n        fileFollower.stopAndWait();\n    }\n\n    /**\n     * Convenience method; equivalent to called getFileFollower().isBeingFollowed()\n     *\n     * @return\n     */\n    public boolean isFollowing() {\n        return fileFollower.isBeingFollowed();\n    }\n\n    /**\n     * Clears the contents of this FileFollowingPane synchronously.\n     */\n    public void clear() throws IOException {\n        if (fileFollower.getFollowedFile().length() == 0L) {\n            return;\n        }\n        synchronized (fileFollower) {\n            try {\n                fileFollower.stopAndWait();\n            } catch (InterruptedException interruptedException) {\n                // Handle this better later\n                log.log(Level.SEVERE, \"InterrupedException in FileFollowingPane\", interruptedException);\n            }\n            // This has the effect of clearing the contents of the followed file\n            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(fileFollower.getFollowedFile()));\n            bos.close();\n            // Update textarea contents to reflect freshly cleared file\n            Document doc = textArea.getDocument();\n            try {\n                doc.remove(0, doc.getLength());\n            } catch (BadLocationException e) {\n                // Handle this better later\n                log.log(Level.WARNING, \"BadLocationException in FileFolloingPane\", e);\n            }\n            fileFollower.start();\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/gui/FileFollowingPaneTest1.java",
		"test_prompt": "// FileFollowingPaneTest1.java\npackage ghm.follow.gui;\n\nimport ghm.follow.FileFollower;\nimport ghm.follow.io.JTextComponentDestination;\nimport ghm.follow.io.OutputDestination;\nimport ghm.follow.search.SearchableTextPane;\nimport java.awt.Font;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.swing.JScrollPane;\nimport javax.swing.text.BadLocationException;\nimport javax.swing.text.Document;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileFollowingPane}.\n* It contains ten unit test cases for the {@link FileFollowingPane#isFollowingPaused()} method.\n*/\nclass FileFollowingPaneTest1 {"
	},
	{
		"original_code": "// FileFollowingPane.java\n/* \n Copyright (C) 2000-2003 Greg Merrill (greghmerrill@yahoo.com)\n\n This file is part of Follow (http://follow.sf.net).\n\n Follow is free software; you can redistribute it and/or modify\n it under the terms of version 2 of the GNU General Public\n License as published by the Free Software Foundation.\n\n Follow is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n\n You should have received a copy of the GNU General Public License\n along with Follow; if not, write to the Free Software\n Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\npackage ghm.follow.gui;\n\nimport ghm.follow.FileFollower;\nimport ghm.follow.io.JTextComponentDestination;\nimport ghm.follow.io.OutputDestination;\nimport ghm.follow.search.SearchableTextPane;\nimport java.awt.Font;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.swing.JScrollPane;\nimport javax.swing.text.BadLocationException;\nimport javax.swing.text.Document;\n\n/**\n * A component which allows one to view a text file to which information is being asynchronously\n * appended.\n *\n * @author <a href=\"mailto:greghmerrill@yahoo.com\">Greg Merrill</a>\n */\npublic class FileFollowingPane extends JScrollPane {\n\n    private Logger log = Logger.getLogger(FileFollowingPane.class.getName());\n\n    /**\n     * FileFollower used to print to this component\n     */\n    protected FileFollower fileFollower;\n\n    /**\n     * Text area into which followed file's contents are printed\n     */\n    protected SearchableTextPane textArea;\n\n    /**\n     * OutputDestination used w/FileFollower\n     */\n    protected JTextComponentDestination destination;\n\n    /**\n     * @param file\n     *            text file to be followed\n     * @param bufferSize\n     *            size of the character buffer inside the FileFollower used to follow the supplied\n     *            file\n     * @param latency\n     *            latency of the FileFollower used to follow the supplied file\n     */\n    public FileFollowingPane(File file, int bufferSize, int latency, boolean autoPositionCaret, Font font, int tabSize) {\n        textArea = new SearchableTextPane(font, tabSize);\n        textArea.setEditable(false);\n        textArea.setUI(new LineTextUI());\n        destination = new JTextComponentDestination(textArea, autoPositionCaret);\n        fileFollower = new FileFollower(file, bufferSize, latency, new OutputDestination[] { destination });\n        add(textArea);\n        setViewportView(textArea);\n    }\n\n    /**\n     * Returns the text area to which the followed file's contents are being printed.\n     *\n     * @return text area containing followed file's contents\n     */\n    public SearchableTextPane getTextPane() {\n        return textArea;\n    }\n\n    /**\n     * Returns whether caret is automatically repositioned to the end of the text area when text is\n     * appended to the followed file\n     *\n     * @return whether caret is automatically repositioned on append\n     */\n    public boolean autoPositionCaret() {\n        return destination.autoPositionCaret();\n    }\n\n    /**\n     * Sets whether caret is automatically repositioned to the end of the text area when text is\n     * appended to the followed file\n     *\n     * @param value\n     *            whether caret is automatically repositioned on append\n     */\n    public void setAutoPositionCaret(boolean value) {\n        destination.setAutoPositionCaret(value);\n    }\n\n    /**\n     * Returns the FileFollower which is being used to print information in this component.\n     *\n     * @return FileFollower used by this component\n     */\n    public FileFollower getFileFollower() {\n        return fileFollower;\n    }\n\n    /**\n     * Convenience method; equivalent to calling getFileFollower().getFollowedFile()\n     */\n    public File getFollowedFile() {\n        return fileFollower.getFollowedFile();\n    }\n\n    /**\n     * Convenience method; equivalent to calling getFileFollower().start()\n     */\n    public void startFollowing() {\n        fileFollower.start();\n    }\n\n    /**\n     * Convenience method; equivalent to calling getFileFollower().stop()\n     */\n    public void stopFollowing() {\n        fileFollower.stop();\n    }\n\n    /**\n     * Convenience method; equivalent to calling getFileFollower().restart()\n     */\n    public void restartFollowing() {\n        fileFollower.restart();\n    }\n\n    /**\n     * Convenience method; equivalent to calling getFileFollower().pause()\n     */\n    public void pauseFollowing() {\n        fileFollower.pause();\n    }\n\n    /**\n     * Convenience method; equivalent to calling getFileFollower().unpause()\n     */\n    public void unpauseFollowing() {\n        fileFollower.unpause();\n    }\n\n    /**\n     * Convenience method; equivalent to calling getFileFollower().isPaused()\n     *\n     * @return\n     */\n    public boolean isFollowingPaused() {\n        return fileFollower.isPaused();\n    }\n\n    /**\n     * Convenience method; equivalent to calling getFileFollower().stopAndWait()\n     */\n    public void stopFollowingAndWait() throws InterruptedException {\n        fileFollower.stopAndWait();\n    }\n\n    /**\n     * Convenience method; equivalent to called getFileFollower().isBeingFollowed()\n     *\n     * @return\n     */\n    public boolean isFollowing() {\n        return fileFollower.isBeingFollowed();\n    }\n\n    /**\n     * Clears the contents of this FileFollowingPane synchronously.\n     */\n    public void clear() throws IOException {\n        if (fileFollower.getFollowedFile().length() == 0L) {\n            return;\n        }\n        synchronized (fileFollower) {\n            try {\n                fileFollower.stopAndWait();\n            } catch (InterruptedException interruptedException) {\n                // Handle this better later\n                log.log(Level.SEVERE, \"InterrupedException in FileFollowingPane\", interruptedException);\n            }\n            // This has the effect of clearing the contents of the followed file\n            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(fileFollower.getFollowedFile()));\n            bos.close();\n            // Update textarea contents to reflect freshly cleared file\n            Document doc = textArea.getDocument();\n            try {\n                doc.remove(0, doc.getLength());\n            } catch (BadLocationException e) {\n                // Handle this better later\n                log.log(Level.WARNING, \"BadLocationException in FileFolloingPane\", e);\n            }\n            fileFollower.start();\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/gui/FileFollowingPaneTest2.java",
		"test_prompt": "// FileFollowingPaneTest2.java\npackage ghm.follow.gui;\n\nimport ghm.follow.FileFollower;\nimport ghm.follow.io.JTextComponentDestination;\nimport ghm.follow.io.OutputDestination;\nimport ghm.follow.search.SearchableTextPane;\nimport java.awt.Font;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.swing.JScrollPane;\nimport javax.swing.text.BadLocationException;\nimport javax.swing.text.Document;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileFollowingPane}.\n* It contains ten unit test cases for the {@link FileFollowingPane#isFollowing()} method.\n*/\nclass FileFollowingPaneTest2 {"
	},
	{
		"original_code": "// LineEditorKit.java\npackage ghm.follow.gui;\n\nimport javax.swing.text.Element;\nimport javax.swing.text.StyledEditorKit;\nimport javax.swing.text.View;\nimport javax.swing.text.ViewFactory;\n\npublic class LineEditorKit extends StyledEditorKit implements ViewFactory {\n\n    /**\n     * @see javax.swing.text.ViewFactory#create(javax.swing.text.Element)\n     */\n    public View create(Element elem) {\n        return new LineView(elem);\n    }\n\n    /**\n     * @see javax.swing.text.DefaultEditorKit#getViewFactory()\n     */\n    public ViewFactory getViewFactory() {\n        return this;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/gui/LineEditorKitTest.java",
		"test_prompt": "// LineEditorKitTest.java\npackage ghm.follow.gui;\n\nimport javax.swing.text.Element;\nimport javax.swing.text.StyledEditorKit;\nimport javax.swing.text.View;\nimport javax.swing.text.ViewFactory;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link LineEditorKit}.\n* It contains ten unit test cases for the {@link LineEditorKit#create(Element)} method.\n*/\nclass LineEditorKitTest {"
	},
	{
		"original_code": "// FileFollower.java\n/*\n * Copyright (C) 2000-2003 Greg Merrill (greghmerrill@yahoo.com)\n * \n * This file is part of Follow (http://follow.sf.net).\n * \n * Follow is free software; you can redistribute it and/or modify it under the\n * terms of version 2 of the GNU General Public License as published by the Free\n * Software Foundation.\n * \n * Follow is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License along with\n * Follow; if not, write to the Free Software Foundation, Inc., 59 Temple Place,\n * Suite 330, Boston, MA 02111-1307 USA\n */\npackage ghm.follow;\n\nimport ghm.follow.io.OutputDestination;\nimport java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * Instances of this class 'follow' a particular text file, assmebling that\n * file's characters into Strings and sending them to instances of\n * {@link OutputDestination}. The name and behavior of this class are inspired\n * by the '-f' (follow) flag of the UNIX command 'tail'.\n *\n * @see OutputDestination\n * @author <a href=\"mailto:greghmerrill@yahoo.com\">Greg Merrill</a>\n */\npublic class FileFollower {\n\n    /**\n     * Constructs a new FileFollower; invoking this constructor does\n     * <em>not</em> cause the new object to begin following the supplied file.\n     * In order to begin following, one must call {@link #start()}.\n     *\n     * @param file\n     *            file to be followed\n     * @param bufferSize\n     *            number of chars to be read each time the file is accessed\n     * @param latency\n     *            each time a FileFollower's running thread encounters the end\n     *            of the file in its stream, it will rest for this many\n     *            milliseconds before checking to see if there are any more\n     *            bytes in the file\n     * @param initialOutputDestinations\n     *            an initial array of OutputDestinations which will be used when\n     *            printing the contents of the file (this array may be\n     *            <tt>null</tt>)\n     */\n    public FileFollower(File file, int bufferSize, int latency, OutputDestination[] initialOutputDestinations) {\n        this.file = file;\n        this.bufferSize = bufferSize;\n        this.latency = latency;\n        int initOutputDestsSize = (initialOutputDestinations != null) ? initialOutputDestinations.length : 0;\n        outputDestinations = new ArrayList<OutputDestination>(initOutputDestsSize);\n        for (int i = 0; i < initOutputDestsSize; i++) {\n            outputDestinations.add(initialOutputDestinations[i]);\n        }\n    }\n\n    /**\n     * Identical to {@link #FileFollower(File, int, int, OutputDestination[])},\n     * except that a default buffer size (32,768 characters) and latency (1000\n     * milliseconds) are used.\n     *\n     * @see #FileFollower(File, int, int, OutputDestination[])\n     */\n    public FileFollower(File file, OutputDestination[] initialOutputDestinations) {\n        // Initial buffer size pilfered from org.gjt.sp.jedit.Buffer. I'm not\n        // sure whether this is a truly optimal buffer size.\n        this(// Don't change without updating docs!\n        file, // Don't change without updating docs!\n        32768, // Don't change without updating docs!\n        1000, initialOutputDestinations);\n    }\n\n    /**\n     * Cause this FileFollower to spawn a thread which will follow the file\n     * supplied in the constructor and send its contents to all of the\n     * FileFollower's OutputDestinations.<br>\n     * <br>\n     * If this FileFollower is running but paused, this method equates to\n     * calling unpause().\n     */\n    public synchronized void start() {\n        if (continueRunning && paused) {\n            unpause();\n        } else {\n            continueRunning = true;\n            paused = false;\n            runnerThread = new Thread(new Runner(), getFollowedFile().getName());\n            runnerThread.start();\n        }\n    }\n\n    public synchronized void pause() {\n        paused = true;\n    }\n\n    public synchronized void unpause() {\n        paused = false;\n    }\n\n    public synchronized void restart() {\n        needsRestart = true;\n        runnerThread.interrupt();\n    }\n\n    /**\n     * Cause this FileFollower to stop following the file supplied in the\n     * constructor after it flushes the characters it's currently reading to all\n     * its OutputDestinations.\n     */\n    public synchronized void stop() {\n        continueRunning = false;\n        runnerThread.interrupt();\n    }\n\n    /**\n     * Like {@link #stop()}, but this method will not exit until the thread\n     * which is following the file has finished executing (i.e., stop\n     * synchronously).\n     */\n    public synchronized void stopAndWait() throws InterruptedException {\n        stop();\n        while (runnerThread.isAlive()) {\n            Thread.yield();\n        }\n    }\n\n    /**\n     * Send the supplied string to all OutputDestinations\n     *\n     * @param s\n     */\n    private synchronized void print(String s) {\n        for (OutputDestination out : outputDestinations) {\n            out.print(s);\n        }\n    }\n\n    /**\n     * Clear all OutputDestinations\n     */\n    private synchronized void clear() {\n        for (OutputDestination out : outputDestinations) {\n            out.clear();\n        }\n    }\n\n    /**\n     * Add another OutputDestination to which the followed file's contents\n     * should be printed.\n     *\n     * @param outputDestination\n     *            OutputDestination to be added\n     */\n    public boolean addOutputDestination(OutputDestination outputDestination) {\n        return outputDestinations.add(outputDestination);\n    }\n\n    /**\n     * Remove the supplied OutputDestination from the list of OutputDestinations\n     * to which the followed file's contents should be printed.\n     *\n     * @param outputDestination\n     *            OutputDestination to be removed\n     */\n    public boolean removeOutputDestination(OutputDestination outputDestination) {\n        return outputDestinations.remove(outputDestination);\n    }\n\n    /**\n     * Returns the List which maintains all OutputDestinations for this\n     * FileFollower.\n     *\n     * @return contains all OutputDestinations for this FileFollower\n     */\n    public List<OutputDestination> getOutputDestinations() {\n        return outputDestinations;\n    }\n\n    /**\n     * Returns the file which is being followed by this FileFollower\n     *\n     * @return file being followed\n     */\n    public File getFollowedFile() {\n        return file;\n    }\n\n    /**\n     * Returns the following state of a file\n     *\n     * @return true if being followed, false if not being followed\n     */\n    public boolean isBeingFollowed() {\n        return continueRunning;\n    }\n\n    /**\n     * Returns the pause state of the follower.\n     *\n     * @return true if paused, false otherwise\n     */\n    public boolean isPaused() {\n        return paused;\n    }\n\n    /**\n     * Returns the size of the character buffer used to read characters from the\n     * followed file. Each time the file is accessed, this buffer is filled.\n     *\n     * @return size of the character buffer\n     */\n    public int getBufferSize() {\n        return bufferSize;\n    }\n\n    /**\n     * Sets the size of the character buffer used to read characters from the\n     * followed file. Increasing buffer size will improve efficiency but\n     * increase the amount of memory used by the FileFollower.<br>\n     * <em>NOTE:</em> Setting this value will <em>not</em> cause a running\n     * FileFollower to immediately begin reading characters into a buffer of the\n     * newly specified size. You must stop & restart the FileFollower in order\n     * for changes to take effect.\n     *\n     * @param bufferSize\n     *            size of the character buffer\n     */\n    public void setBufferSize(int bufferSize) {\n        this.bufferSize = bufferSize;\n    }\n\n    /**\n     * Returns the time (in milliseconds) which a FileFollower spends sleeping\n     * each time it encounters the end of the followed file.\n     *\n     * @return latency, in milliseconds\n     */\n    public int getLatency() {\n        return latency;\n    }\n\n    /**\n     * Sets the time (in milliseconds) which a FileFollower spends sleeping each\n     * time it encounters the end of the followed file. Note that extremely low\n     * latency values may cause thrashing between the FileFollower's running\n     * thread and other threads in an application. A change in this value will\n     * be reflected the next time the FileFollower's running thread sleeps.\n     *\n     * @param latency\n     *            latency, in milliseconds\n     */\n    public void setLatency(int latency) {\n        this.latency = latency;\n    }\n\n    protected int bufferSize;\n\n    protected int latency;\n\n    protected File file;\n\n    protected List<OutputDestination> outputDestinations;\n\n    protected boolean continueRunning;\n\n    protected boolean needsRestart;\n\n    protected Thread runnerThread;\n\n    protected boolean paused;\n\n    /**\n     * Instances of this class are used to run a thread which follows a\n     * FileFollower's file and sends prints its contents to OutputDestinations.\n     * This class should only handle the gathering of data from the followed\n     * file. Actually writing to the output destinations is handled by the outer\n     * class (FileFollower).\n     */\n    class Runner implements Runnable {\n\n        private Logger log = Logger.getLogger(Runner.class.getName());\n\n        public void run() {\n            log.finer(\"entering FileFollower.run()\");\n            while (continueRunning) {\n                runAction();\n            }\n            log.finer(\"exiting FileFollower.run()\");\n        }\n\n        protected void runAction() {\n            try {\n                clear();\n                long fileSize = file.length();\n                byte[] byteArray = new byte[bufferSize];\n                int numBytesRead;\n                long lastActivityTime = file.lastModified();\n                // create some stream readers to handle the file\n                FileInputStream fis = new FileInputStream(file);\n                BufferedInputStream bis = new BufferedInputStream(fis);\n                // start at the beginning of the file\n                long startingPoint = 0;\n                // if the file size is bigger than the buffer size, skip to the\n                // end of the file if not performing a restart\n                if (fileSize > bufferSize) {\n                    startingPoint = fileSize - bufferSize;\n                }\n                // reset the restart flag\n                needsRestart = false;\n                log.finer(\"Starting point: \" + startingPoint + \"; Last activity: \" + lastActivityTime);\n                bis.skip(startingPoint);\n                while (continueRunning && !needsRestart) {\n                    if (!paused) {\n                        lastActivityTime = System.currentTimeMillis();\n                        numBytesRead = bis.read(byteArray, 0, byteArray.length);\n                        boolean dataWasFound = (numBytesRead > 0);\n                        log.finer(\"Bytes read: \" + numBytesRead + \"; dataWasFound: \" + dataWasFound);\n                        // if data was found, print it and log activity time\n                        if (dataWasFound) {\n                            String output = new String(byteArray, 0, numBytesRead);\n                            // print the output to the listeners\n                            print(output);\n                        } else // no data found so check the file and restart if needed\n                        {\n                            // check if the file handle has become stale (file\n                            // was modified, but no data was read).\n                            boolean fileExists = file.exists();\n                            // removed check for 0 length because a file could\n                            // change by being cleared out\n                            // && (file_.length() > 0);\n                            boolean fileHasChanged = file.lastModified() > lastActivityTime;\n                            if (fileExists && fileHasChanged) {\n                                log.finer(\"Needs restart [fileExists=\" + fileExists + \"; fileHasChanged=\" + fileHasChanged + \"]\");\n                                needsRestart = true;\n                            }\n                        }\n                        boolean allDataRead = (numBytesRead < byteArray.length);\n                        if (allDataRead && !needsRestart) {\n                            log.finer(\"Sleeping for \" + latency + \"ms [allDataRead:\" + allDataRead + \"; needsRestart:\" + needsRestart + \"]\");\n                            sleep();\n                        }\n                    } else {\n                        log.finer(\"Runner paused.\");\n                        sleep();\n                    }\n                }\n                log.finer(\"exiting Runner.runAction [continueRunning=\" + continueRunning + \"; needsRestart=\" + needsRestart + \"]\");\n                bis.close();\n                fis.close();\n            } catch (IOException e) {\n                log.log(Level.SEVERE, \"IOException while following file\", e);\n            }\n        }\n\n        private void sleep() {\n            try {\n                Thread.sleep(latency);\n            } catch (InterruptedException e) {\n                // Interrupt may be thrown manually by stop()\n                log.finer(\"DIED IN MY SLEEP\");\n            }\n        }\n    }\n\n    /**\n     * Line separator, retrieved from System properties & stored statically.\n     */\n    protected static final String lineSeparator = System.getProperty(\"line.separator\");\n}\n",
		"id": "EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/FileFollowerTest0.java",
		"test_prompt": "// FileFollowerTest0.java\npackage ghm.follow;\n\nimport ghm.follow.io.OutputDestination;\nimport java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileFollower}.\n* It contains ten unit test cases for the {@link FileFollower#addOutputDestination(OutputDestination)} method.\n*/\nclass FileFollowerTest0 {"
	},
	{
		"original_code": "// FileFollower.java\n/*\n * Copyright (C) 2000-2003 Greg Merrill (greghmerrill@yahoo.com)\n * \n * This file is part of Follow (http://follow.sf.net).\n * \n * Follow is free software; you can redistribute it and/or modify it under the\n * terms of version 2 of the GNU General Public License as published by the Free\n * Software Foundation.\n * \n * Follow is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License along with\n * Follow; if not, write to the Free Software Foundation, Inc., 59 Temple Place,\n * Suite 330, Boston, MA 02111-1307 USA\n */\npackage ghm.follow;\n\nimport ghm.follow.io.OutputDestination;\nimport java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * Instances of this class 'follow' a particular text file, assmebling that\n * file's characters into Strings and sending them to instances of\n * {@link OutputDestination}. The name and behavior of this class are inspired\n * by the '-f' (follow) flag of the UNIX command 'tail'.\n *\n * @see OutputDestination\n * @author <a href=\"mailto:greghmerrill@yahoo.com\">Greg Merrill</a>\n */\npublic class FileFollower {\n\n    /**\n     * Constructs a new FileFollower; invoking this constructor does\n     * <em>not</em> cause the new object to begin following the supplied file.\n     * In order to begin following, one must call {@link #start()}.\n     *\n     * @param file\n     *            file to be followed\n     * @param bufferSize\n     *            number of chars to be read each time the file is accessed\n     * @param latency\n     *            each time a FileFollower's running thread encounters the end\n     *            of the file in its stream, it will rest for this many\n     *            milliseconds before checking to see if there are any more\n     *            bytes in the file\n     * @param initialOutputDestinations\n     *            an initial array of OutputDestinations which will be used when\n     *            printing the contents of the file (this array may be\n     *            <tt>null</tt>)\n     */\n    public FileFollower(File file, int bufferSize, int latency, OutputDestination[] initialOutputDestinations) {\n        this.file = file;\n        this.bufferSize = bufferSize;\n        this.latency = latency;\n        int initOutputDestsSize = (initialOutputDestinations != null) ? initialOutputDestinations.length : 0;\n        outputDestinations = new ArrayList<OutputDestination>(initOutputDestsSize);\n        for (int i = 0; i < initOutputDestsSize; i++) {\n            outputDestinations.add(initialOutputDestinations[i]);\n        }\n    }\n\n    /**\n     * Identical to {@link #FileFollower(File, int, int, OutputDestination[])},\n     * except that a default buffer size (32,768 characters) and latency (1000\n     * milliseconds) are used.\n     *\n     * @see #FileFollower(File, int, int, OutputDestination[])\n     */\n    public FileFollower(File file, OutputDestination[] initialOutputDestinations) {\n        // Initial buffer size pilfered from org.gjt.sp.jedit.Buffer. I'm not\n        // sure whether this is a truly optimal buffer size.\n        this(// Don't change without updating docs!\n        file, // Don't change without updating docs!\n        32768, // Don't change without updating docs!\n        1000, initialOutputDestinations);\n    }\n\n    /**\n     * Cause this FileFollower to spawn a thread which will follow the file\n     * supplied in the constructor and send its contents to all of the\n     * FileFollower's OutputDestinations.<br>\n     * <br>\n     * If this FileFollower is running but paused, this method equates to\n     * calling unpause().\n     */\n    public synchronized void start() {\n        if (continueRunning && paused) {\n            unpause();\n        } else {\n            continueRunning = true;\n            paused = false;\n            runnerThread = new Thread(new Runner(), getFollowedFile().getName());\n            runnerThread.start();\n        }\n    }\n\n    public synchronized void pause() {\n        paused = true;\n    }\n\n    public synchronized void unpause() {\n        paused = false;\n    }\n\n    public synchronized void restart() {\n        needsRestart = true;\n        runnerThread.interrupt();\n    }\n\n    /**\n     * Cause this FileFollower to stop following the file supplied in the\n     * constructor after it flushes the characters it's currently reading to all\n     * its OutputDestinations.\n     */\n    public synchronized void stop() {\n        continueRunning = false;\n        runnerThread.interrupt();\n    }\n\n    /**\n     * Like {@link #stop()}, but this method will not exit until the thread\n     * which is following the file has finished executing (i.e., stop\n     * synchronously).\n     */\n    public synchronized void stopAndWait() throws InterruptedException {\n        stop();\n        while (runnerThread.isAlive()) {\n            Thread.yield();\n        }\n    }\n\n    /**\n     * Send the supplied string to all OutputDestinations\n     *\n     * @param s\n     */\n    private synchronized void print(String s) {\n        for (OutputDestination out : outputDestinations) {\n            out.print(s);\n        }\n    }\n\n    /**\n     * Clear all OutputDestinations\n     */\n    private synchronized void clear() {\n        for (OutputDestination out : outputDestinations) {\n            out.clear();\n        }\n    }\n\n    /**\n     * Add another OutputDestination to which the followed file's contents\n     * should be printed.\n     *\n     * @param outputDestination\n     *            OutputDestination to be added\n     */\n    public boolean addOutputDestination(OutputDestination outputDestination) {\n        return outputDestinations.add(outputDestination);\n    }\n\n    /**\n     * Remove the supplied OutputDestination from the list of OutputDestinations\n     * to which the followed file's contents should be printed.\n     *\n     * @param outputDestination\n     *            OutputDestination to be removed\n     */\n    public boolean removeOutputDestination(OutputDestination outputDestination) {\n        return outputDestinations.remove(outputDestination);\n    }\n\n    /**\n     * Returns the List which maintains all OutputDestinations for this\n     * FileFollower.\n     *\n     * @return contains all OutputDestinations for this FileFollower\n     */\n    public List<OutputDestination> getOutputDestinations() {\n        return outputDestinations;\n    }\n\n    /**\n     * Returns the file which is being followed by this FileFollower\n     *\n     * @return file being followed\n     */\n    public File getFollowedFile() {\n        return file;\n    }\n\n    /**\n     * Returns the following state of a file\n     *\n     * @return true if being followed, false if not being followed\n     */\n    public boolean isBeingFollowed() {\n        return continueRunning;\n    }\n\n    /**\n     * Returns the pause state of the follower.\n     *\n     * @return true if paused, false otherwise\n     */\n    public boolean isPaused() {\n        return paused;\n    }\n\n    /**\n     * Returns the size of the character buffer used to read characters from the\n     * followed file. Each time the file is accessed, this buffer is filled.\n     *\n     * @return size of the character buffer\n     */\n    public int getBufferSize() {\n        return bufferSize;\n    }\n\n    /**\n     * Sets the size of the character buffer used to read characters from the\n     * followed file. Increasing buffer size will improve efficiency but\n     * increase the amount of memory used by the FileFollower.<br>\n     * <em>NOTE:</em> Setting this value will <em>not</em> cause a running\n     * FileFollower to immediately begin reading characters into a buffer of the\n     * newly specified size. You must stop & restart the FileFollower in order\n     * for changes to take effect.\n     *\n     * @param bufferSize\n     *            size of the character buffer\n     */\n    public void setBufferSize(int bufferSize) {\n        this.bufferSize = bufferSize;\n    }\n\n    /**\n     * Returns the time (in milliseconds) which a FileFollower spends sleeping\n     * each time it encounters the end of the followed file.\n     *\n     * @return latency, in milliseconds\n     */\n    public int getLatency() {\n        return latency;\n    }\n\n    /**\n     * Sets the time (in milliseconds) which a FileFollower spends sleeping each\n     * time it encounters the end of the followed file. Note that extremely low\n     * latency values may cause thrashing between the FileFollower's running\n     * thread and other threads in an application. A change in this value will\n     * be reflected the next time the FileFollower's running thread sleeps.\n     *\n     * @param latency\n     *            latency, in milliseconds\n     */\n    public void setLatency(int latency) {\n        this.latency = latency;\n    }\n\n    protected int bufferSize;\n\n    protected int latency;\n\n    protected File file;\n\n    protected List<OutputDestination> outputDestinations;\n\n    protected boolean continueRunning;\n\n    protected boolean needsRestart;\n\n    protected Thread runnerThread;\n\n    protected boolean paused;\n\n    /**\n     * Instances of this class are used to run a thread which follows a\n     * FileFollower's file and sends prints its contents to OutputDestinations.\n     * This class should only handle the gathering of data from the followed\n     * file. Actually writing to the output destinations is handled by the outer\n     * class (FileFollower).\n     */\n    class Runner implements Runnable {\n\n        private Logger log = Logger.getLogger(Runner.class.getName());\n\n        public void run() {\n            log.finer(\"entering FileFollower.run()\");\n            while (continueRunning) {\n                runAction();\n            }\n            log.finer(\"exiting FileFollower.run()\");\n        }\n\n        protected void runAction() {\n            try {\n                clear();\n                long fileSize = file.length();\n                byte[] byteArray = new byte[bufferSize];\n                int numBytesRead;\n                long lastActivityTime = file.lastModified();\n                // create some stream readers to handle the file\n                FileInputStream fis = new FileInputStream(file);\n                BufferedInputStream bis = new BufferedInputStream(fis);\n                // start at the beginning of the file\n                long startingPoint = 0;\n                // if the file size is bigger than the buffer size, skip to the\n                // end of the file if not performing a restart\n                if (fileSize > bufferSize) {\n                    startingPoint = fileSize - bufferSize;\n                }\n                // reset the restart flag\n                needsRestart = false;\n                log.finer(\"Starting point: \" + startingPoint + \"; Last activity: \" + lastActivityTime);\n                bis.skip(startingPoint);\n                while (continueRunning && !needsRestart) {\n                    if (!paused) {\n                        lastActivityTime = System.currentTimeMillis();\n                        numBytesRead = bis.read(byteArray, 0, byteArray.length);\n                        boolean dataWasFound = (numBytesRead > 0);\n                        log.finer(\"Bytes read: \" + numBytesRead + \"; dataWasFound: \" + dataWasFound);\n                        // if data was found, print it and log activity time\n                        if (dataWasFound) {\n                            String output = new String(byteArray, 0, numBytesRead);\n                            // print the output to the listeners\n                            print(output);\n                        } else // no data found so check the file and restart if needed\n                        {\n                            // check if the file handle has become stale (file\n                            // was modified, but no data was read).\n                            boolean fileExists = file.exists();\n                            // removed check for 0 length because a file could\n                            // change by being cleared out\n                            // && (file_.length() > 0);\n                            boolean fileHasChanged = file.lastModified() > lastActivityTime;\n                            if (fileExists && fileHasChanged) {\n                                log.finer(\"Needs restart [fileExists=\" + fileExists + \"; fileHasChanged=\" + fileHasChanged + \"]\");\n                                needsRestart = true;\n                            }\n                        }\n                        boolean allDataRead = (numBytesRead < byteArray.length);\n                        if (allDataRead && !needsRestart) {\n                            log.finer(\"Sleeping for \" + latency + \"ms [allDataRead:\" + allDataRead + \"; needsRestart:\" + needsRestart + \"]\");\n                            sleep();\n                        }\n                    } else {\n                        log.finer(\"Runner paused.\");\n                        sleep();\n                    }\n                }\n                log.finer(\"exiting Runner.runAction [continueRunning=\" + continueRunning + \"; needsRestart=\" + needsRestart + \"]\");\n                bis.close();\n                fis.close();\n            } catch (IOException e) {\n                log.log(Level.SEVERE, \"IOException while following file\", e);\n            }\n        }\n\n        private void sleep() {\n            try {\n                Thread.sleep(latency);\n            } catch (InterruptedException e) {\n                // Interrupt may be thrown manually by stop()\n                log.finer(\"DIED IN MY SLEEP\");\n            }\n        }\n    }\n\n    /**\n     * Line separator, retrieved from System properties & stored statically.\n     */\n    protected static final String lineSeparator = System.getProperty(\"line.separator\");\n}\n",
		"id": "EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/FileFollowerTest1.java",
		"test_prompt": "// FileFollowerTest1.java\npackage ghm.follow;\n\nimport ghm.follow.io.OutputDestination;\nimport java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileFollower}.\n* It contains ten unit test cases for the {@link FileFollower#removeOutputDestination(OutputDestination)} method.\n*/\nclass FileFollowerTest1 {"
	},
	{
		"original_code": "// FileFollower.java\n/*\n * Copyright (C) 2000-2003 Greg Merrill (greghmerrill@yahoo.com)\n * \n * This file is part of Follow (http://follow.sf.net).\n * \n * Follow is free software; you can redistribute it and/or modify it under the\n * terms of version 2 of the GNU General Public License as published by the Free\n * Software Foundation.\n * \n * Follow is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License along with\n * Follow; if not, write to the Free Software Foundation, Inc., 59 Temple Place,\n * Suite 330, Boston, MA 02111-1307 USA\n */\npackage ghm.follow;\n\nimport ghm.follow.io.OutputDestination;\nimport java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * Instances of this class 'follow' a particular text file, assmebling that\n * file's characters into Strings and sending them to instances of\n * {@link OutputDestination}. The name and behavior of this class are inspired\n * by the '-f' (follow) flag of the UNIX command 'tail'.\n *\n * @see OutputDestination\n * @author <a href=\"mailto:greghmerrill@yahoo.com\">Greg Merrill</a>\n */\npublic class FileFollower {\n\n    /**\n     * Constructs a new FileFollower; invoking this constructor does\n     * <em>not</em> cause the new object to begin following the supplied file.\n     * In order to begin following, one must call {@link #start()}.\n     *\n     * @param file\n     *            file to be followed\n     * @param bufferSize\n     *            number of chars to be read each time the file is accessed\n     * @param latency\n     *            each time a FileFollower's running thread encounters the end\n     *            of the file in its stream, it will rest for this many\n     *            milliseconds before checking to see if there are any more\n     *            bytes in the file\n     * @param initialOutputDestinations\n     *            an initial array of OutputDestinations which will be used when\n     *            printing the contents of the file (this array may be\n     *            <tt>null</tt>)\n     */\n    public FileFollower(File file, int bufferSize, int latency, OutputDestination[] initialOutputDestinations) {\n        this.file = file;\n        this.bufferSize = bufferSize;\n        this.latency = latency;\n        int initOutputDestsSize = (initialOutputDestinations != null) ? initialOutputDestinations.length : 0;\n        outputDestinations = new ArrayList<OutputDestination>(initOutputDestsSize);\n        for (int i = 0; i < initOutputDestsSize; i++) {\n            outputDestinations.add(initialOutputDestinations[i]);\n        }\n    }\n\n    /**\n     * Identical to {@link #FileFollower(File, int, int, OutputDestination[])},\n     * except that a default buffer size (32,768 characters) and latency (1000\n     * milliseconds) are used.\n     *\n     * @see #FileFollower(File, int, int, OutputDestination[])\n     */\n    public FileFollower(File file, OutputDestination[] initialOutputDestinations) {\n        // Initial buffer size pilfered from org.gjt.sp.jedit.Buffer. I'm not\n        // sure whether this is a truly optimal buffer size.\n        this(// Don't change without updating docs!\n        file, // Don't change without updating docs!\n        32768, // Don't change without updating docs!\n        1000, initialOutputDestinations);\n    }\n\n    /**\n     * Cause this FileFollower to spawn a thread which will follow the file\n     * supplied in the constructor and send its contents to all of the\n     * FileFollower's OutputDestinations.<br>\n     * <br>\n     * If this FileFollower is running but paused, this method equates to\n     * calling unpause().\n     */\n    public synchronized void start() {\n        if (continueRunning && paused) {\n            unpause();\n        } else {\n            continueRunning = true;\n            paused = false;\n            runnerThread = new Thread(new Runner(), getFollowedFile().getName());\n            runnerThread.start();\n        }\n    }\n\n    public synchronized void pause() {\n        paused = true;\n    }\n\n    public synchronized void unpause() {\n        paused = false;\n    }\n\n    public synchronized void restart() {\n        needsRestart = true;\n        runnerThread.interrupt();\n    }\n\n    /**\n     * Cause this FileFollower to stop following the file supplied in the\n     * constructor after it flushes the characters it's currently reading to all\n     * its OutputDestinations.\n     */\n    public synchronized void stop() {\n        continueRunning = false;\n        runnerThread.interrupt();\n    }\n\n    /**\n     * Like {@link #stop()}, but this method will not exit until the thread\n     * which is following the file has finished executing (i.e., stop\n     * synchronously).\n     */\n    public synchronized void stopAndWait() throws InterruptedException {\n        stop();\n        while (runnerThread.isAlive()) {\n            Thread.yield();\n        }\n    }\n\n    /**\n     * Send the supplied string to all OutputDestinations\n     *\n     * @param s\n     */\n    private synchronized void print(String s) {\n        for (OutputDestination out : outputDestinations) {\n            out.print(s);\n        }\n    }\n\n    /**\n     * Clear all OutputDestinations\n     */\n    private synchronized void clear() {\n        for (OutputDestination out : outputDestinations) {\n            out.clear();\n        }\n    }\n\n    /**\n     * Add another OutputDestination to which the followed file's contents\n     * should be printed.\n     *\n     * @param outputDestination\n     *            OutputDestination to be added\n     */\n    public boolean addOutputDestination(OutputDestination outputDestination) {\n        return outputDestinations.add(outputDestination);\n    }\n\n    /**\n     * Remove the supplied OutputDestination from the list of OutputDestinations\n     * to which the followed file's contents should be printed.\n     *\n     * @param outputDestination\n     *            OutputDestination to be removed\n     */\n    public boolean removeOutputDestination(OutputDestination outputDestination) {\n        return outputDestinations.remove(outputDestination);\n    }\n\n    /**\n     * Returns the List which maintains all OutputDestinations for this\n     * FileFollower.\n     *\n     * @return contains all OutputDestinations for this FileFollower\n     */\n    public List<OutputDestination> getOutputDestinations() {\n        return outputDestinations;\n    }\n\n    /**\n     * Returns the file which is being followed by this FileFollower\n     *\n     * @return file being followed\n     */\n    public File getFollowedFile() {\n        return file;\n    }\n\n    /**\n     * Returns the following state of a file\n     *\n     * @return true if being followed, false if not being followed\n     */\n    public boolean isBeingFollowed() {\n        return continueRunning;\n    }\n\n    /**\n     * Returns the pause state of the follower.\n     *\n     * @return true if paused, false otherwise\n     */\n    public boolean isPaused() {\n        return paused;\n    }\n\n    /**\n     * Returns the size of the character buffer used to read characters from the\n     * followed file. Each time the file is accessed, this buffer is filled.\n     *\n     * @return size of the character buffer\n     */\n    public int getBufferSize() {\n        return bufferSize;\n    }\n\n    /**\n     * Sets the size of the character buffer used to read characters from the\n     * followed file. Increasing buffer size will improve efficiency but\n     * increase the amount of memory used by the FileFollower.<br>\n     * <em>NOTE:</em> Setting this value will <em>not</em> cause a running\n     * FileFollower to immediately begin reading characters into a buffer of the\n     * newly specified size. You must stop & restart the FileFollower in order\n     * for changes to take effect.\n     *\n     * @param bufferSize\n     *            size of the character buffer\n     */\n    public void setBufferSize(int bufferSize) {\n        this.bufferSize = bufferSize;\n    }\n\n    /**\n     * Returns the time (in milliseconds) which a FileFollower spends sleeping\n     * each time it encounters the end of the followed file.\n     *\n     * @return latency, in milliseconds\n     */\n    public int getLatency() {\n        return latency;\n    }\n\n    /**\n     * Sets the time (in milliseconds) which a FileFollower spends sleeping each\n     * time it encounters the end of the followed file. Note that extremely low\n     * latency values may cause thrashing between the FileFollower's running\n     * thread and other threads in an application. A change in this value will\n     * be reflected the next time the FileFollower's running thread sleeps.\n     *\n     * @param latency\n     *            latency, in milliseconds\n     */\n    public void setLatency(int latency) {\n        this.latency = latency;\n    }\n\n    protected int bufferSize;\n\n    protected int latency;\n\n    protected File file;\n\n    protected List<OutputDestination> outputDestinations;\n\n    protected boolean continueRunning;\n\n    protected boolean needsRestart;\n\n    protected Thread runnerThread;\n\n    protected boolean paused;\n\n    /**\n     * Instances of this class are used to run a thread which follows a\n     * FileFollower's file and sends prints its contents to OutputDestinations.\n     * This class should only handle the gathering of data from the followed\n     * file. Actually writing to the output destinations is handled by the outer\n     * class (FileFollower).\n     */\n    class Runner implements Runnable {\n\n        private Logger log = Logger.getLogger(Runner.class.getName());\n\n        public void run() {\n            log.finer(\"entering FileFollower.run()\");\n            while (continueRunning) {\n                runAction();\n            }\n            log.finer(\"exiting FileFollower.run()\");\n        }\n\n        protected void runAction() {\n            try {\n                clear();\n                long fileSize = file.length();\n                byte[] byteArray = new byte[bufferSize];\n                int numBytesRead;\n                long lastActivityTime = file.lastModified();\n                // create some stream readers to handle the file\n                FileInputStream fis = new FileInputStream(file);\n                BufferedInputStream bis = new BufferedInputStream(fis);\n                // start at the beginning of the file\n                long startingPoint = 0;\n                // if the file size is bigger than the buffer size, skip to the\n                // end of the file if not performing a restart\n                if (fileSize > bufferSize) {\n                    startingPoint = fileSize - bufferSize;\n                }\n                // reset the restart flag\n                needsRestart = false;\n                log.finer(\"Starting point: \" + startingPoint + \"; Last activity: \" + lastActivityTime);\n                bis.skip(startingPoint);\n                while (continueRunning && !needsRestart) {\n                    if (!paused) {\n                        lastActivityTime = System.currentTimeMillis();\n                        numBytesRead = bis.read(byteArray, 0, byteArray.length);\n                        boolean dataWasFound = (numBytesRead > 0);\n                        log.finer(\"Bytes read: \" + numBytesRead + \"; dataWasFound: \" + dataWasFound);\n                        // if data was found, print it and log activity time\n                        if (dataWasFound) {\n                            String output = new String(byteArray, 0, numBytesRead);\n                            // print the output to the listeners\n                            print(output);\n                        } else // no data found so check the file and restart if needed\n                        {\n                            // check if the file handle has become stale (file\n                            // was modified, but no data was read).\n                            boolean fileExists = file.exists();\n                            // removed check for 0 length because a file could\n                            // change by being cleared out\n                            // && (file_.length() > 0);\n                            boolean fileHasChanged = file.lastModified() > lastActivityTime;\n                            if (fileExists && fileHasChanged) {\n                                log.finer(\"Needs restart [fileExists=\" + fileExists + \"; fileHasChanged=\" + fileHasChanged + \"]\");\n                                needsRestart = true;\n                            }\n                        }\n                        boolean allDataRead = (numBytesRead < byteArray.length);\n                        if (allDataRead && !needsRestart) {\n                            log.finer(\"Sleeping for \" + latency + \"ms [allDataRead:\" + allDataRead + \"; needsRestart:\" + needsRestart + \"]\");\n                            sleep();\n                        }\n                    } else {\n                        log.finer(\"Runner paused.\");\n                        sleep();\n                    }\n                }\n                log.finer(\"exiting Runner.runAction [continueRunning=\" + continueRunning + \"; needsRestart=\" + needsRestart + \"]\");\n                bis.close();\n                fis.close();\n            } catch (IOException e) {\n                log.log(Level.SEVERE, \"IOException while following file\", e);\n            }\n        }\n\n        private void sleep() {\n            try {\n                Thread.sleep(latency);\n            } catch (InterruptedException e) {\n                // Interrupt may be thrown manually by stop()\n                log.finer(\"DIED IN MY SLEEP\");\n            }\n        }\n    }\n\n    /**\n     * Line separator, retrieved from System properties & stored statically.\n     */\n    protected static final String lineSeparator = System.getProperty(\"line.separator\");\n}\n",
		"id": "EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/FileFollowerTest2.java",
		"test_prompt": "// FileFollowerTest2.java\npackage ghm.follow;\n\nimport ghm.follow.io.OutputDestination;\nimport java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileFollower}.\n* It contains ten unit test cases for the {@link FileFollower#isBeingFollowed()} method.\n*/\nclass FileFollowerTest2 {"
	},
	{
		"original_code": "// FileFollower.java\n/*\n * Copyright (C) 2000-2003 Greg Merrill (greghmerrill@yahoo.com)\n * \n * This file is part of Follow (http://follow.sf.net).\n * \n * Follow is free software; you can redistribute it and/or modify it under the\n * terms of version 2 of the GNU General Public License as published by the Free\n * Software Foundation.\n * \n * Follow is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License along with\n * Follow; if not, write to the Free Software Foundation, Inc., 59 Temple Place,\n * Suite 330, Boston, MA 02111-1307 USA\n */\npackage ghm.follow;\n\nimport ghm.follow.io.OutputDestination;\nimport java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * Instances of this class 'follow' a particular text file, assmebling that\n * file's characters into Strings and sending them to instances of\n * {@link OutputDestination}. The name and behavior of this class are inspired\n * by the '-f' (follow) flag of the UNIX command 'tail'.\n *\n * @see OutputDestination\n * @author <a href=\"mailto:greghmerrill@yahoo.com\">Greg Merrill</a>\n */\npublic class FileFollower {\n\n    /**\n     * Constructs a new FileFollower; invoking this constructor does\n     * <em>not</em> cause the new object to begin following the supplied file.\n     * In order to begin following, one must call {@link #start()}.\n     *\n     * @param file\n     *            file to be followed\n     * @param bufferSize\n     *            number of chars to be read each time the file is accessed\n     * @param latency\n     *            each time a FileFollower's running thread encounters the end\n     *            of the file in its stream, it will rest for this many\n     *            milliseconds before checking to see if there are any more\n     *            bytes in the file\n     * @param initialOutputDestinations\n     *            an initial array of OutputDestinations which will be used when\n     *            printing the contents of the file (this array may be\n     *            <tt>null</tt>)\n     */\n    public FileFollower(File file, int bufferSize, int latency, OutputDestination[] initialOutputDestinations) {\n        this.file = file;\n        this.bufferSize = bufferSize;\n        this.latency = latency;\n        int initOutputDestsSize = (initialOutputDestinations != null) ? initialOutputDestinations.length : 0;\n        outputDestinations = new ArrayList<OutputDestination>(initOutputDestsSize);\n        for (int i = 0; i < initOutputDestsSize; i++) {\n            outputDestinations.add(initialOutputDestinations[i]);\n        }\n    }\n\n    /**\n     * Identical to {@link #FileFollower(File, int, int, OutputDestination[])},\n     * except that a default buffer size (32,768 characters) and latency (1000\n     * milliseconds) are used.\n     *\n     * @see #FileFollower(File, int, int, OutputDestination[])\n     */\n    public FileFollower(File file, OutputDestination[] initialOutputDestinations) {\n        // Initial buffer size pilfered from org.gjt.sp.jedit.Buffer. I'm not\n        // sure whether this is a truly optimal buffer size.\n        this(// Don't change without updating docs!\n        file, // Don't change without updating docs!\n        32768, // Don't change without updating docs!\n        1000, initialOutputDestinations);\n    }\n\n    /**\n     * Cause this FileFollower to spawn a thread which will follow the file\n     * supplied in the constructor and send its contents to all of the\n     * FileFollower's OutputDestinations.<br>\n     * <br>\n     * If this FileFollower is running but paused, this method equates to\n     * calling unpause().\n     */\n    public synchronized void start() {\n        if (continueRunning && paused) {\n            unpause();\n        } else {\n            continueRunning = true;\n            paused = false;\n            runnerThread = new Thread(new Runner(), getFollowedFile().getName());\n            runnerThread.start();\n        }\n    }\n\n    public synchronized void pause() {\n        paused = true;\n    }\n\n    public synchronized void unpause() {\n        paused = false;\n    }\n\n    public synchronized void restart() {\n        needsRestart = true;\n        runnerThread.interrupt();\n    }\n\n    /**\n     * Cause this FileFollower to stop following the file supplied in the\n     * constructor after it flushes the characters it's currently reading to all\n     * its OutputDestinations.\n     */\n    public synchronized void stop() {\n        continueRunning = false;\n        runnerThread.interrupt();\n    }\n\n    /**\n     * Like {@link #stop()}, but this method will not exit until the thread\n     * which is following the file has finished executing (i.e., stop\n     * synchronously).\n     */\n    public synchronized void stopAndWait() throws InterruptedException {\n        stop();\n        while (runnerThread.isAlive()) {\n            Thread.yield();\n        }\n    }\n\n    /**\n     * Send the supplied string to all OutputDestinations\n     *\n     * @param s\n     */\n    private synchronized void print(String s) {\n        for (OutputDestination out : outputDestinations) {\n            out.print(s);\n        }\n    }\n\n    /**\n     * Clear all OutputDestinations\n     */\n    private synchronized void clear() {\n        for (OutputDestination out : outputDestinations) {\n            out.clear();\n        }\n    }\n\n    /**\n     * Add another OutputDestination to which the followed file's contents\n     * should be printed.\n     *\n     * @param outputDestination\n     *            OutputDestination to be added\n     */\n    public boolean addOutputDestination(OutputDestination outputDestination) {\n        return outputDestinations.add(outputDestination);\n    }\n\n    /**\n     * Remove the supplied OutputDestination from the list of OutputDestinations\n     * to which the followed file's contents should be printed.\n     *\n     * @param outputDestination\n     *            OutputDestination to be removed\n     */\n    public boolean removeOutputDestination(OutputDestination outputDestination) {\n        return outputDestinations.remove(outputDestination);\n    }\n\n    /**\n     * Returns the List which maintains all OutputDestinations for this\n     * FileFollower.\n     *\n     * @return contains all OutputDestinations for this FileFollower\n     */\n    public List<OutputDestination> getOutputDestinations() {\n        return outputDestinations;\n    }\n\n    /**\n     * Returns the file which is being followed by this FileFollower\n     *\n     * @return file being followed\n     */\n    public File getFollowedFile() {\n        return file;\n    }\n\n    /**\n     * Returns the following state of a file\n     *\n     * @return true if being followed, false if not being followed\n     */\n    public boolean isBeingFollowed() {\n        return continueRunning;\n    }\n\n    /**\n     * Returns the pause state of the follower.\n     *\n     * @return true if paused, false otherwise\n     */\n    public boolean isPaused() {\n        return paused;\n    }\n\n    /**\n     * Returns the size of the character buffer used to read characters from the\n     * followed file. Each time the file is accessed, this buffer is filled.\n     *\n     * @return size of the character buffer\n     */\n    public int getBufferSize() {\n        return bufferSize;\n    }\n\n    /**\n     * Sets the size of the character buffer used to read characters from the\n     * followed file. Increasing buffer size will improve efficiency but\n     * increase the amount of memory used by the FileFollower.<br>\n     * <em>NOTE:</em> Setting this value will <em>not</em> cause a running\n     * FileFollower to immediately begin reading characters into a buffer of the\n     * newly specified size. You must stop & restart the FileFollower in order\n     * for changes to take effect.\n     *\n     * @param bufferSize\n     *            size of the character buffer\n     */\n    public void setBufferSize(int bufferSize) {\n        this.bufferSize = bufferSize;\n    }\n\n    /**\n     * Returns the time (in milliseconds) which a FileFollower spends sleeping\n     * each time it encounters the end of the followed file.\n     *\n     * @return latency, in milliseconds\n     */\n    public int getLatency() {\n        return latency;\n    }\n\n    /**\n     * Sets the time (in milliseconds) which a FileFollower spends sleeping each\n     * time it encounters the end of the followed file. Note that extremely low\n     * latency values may cause thrashing between the FileFollower's running\n     * thread and other threads in an application. A change in this value will\n     * be reflected the next time the FileFollower's running thread sleeps.\n     *\n     * @param latency\n     *            latency, in milliseconds\n     */\n    public void setLatency(int latency) {\n        this.latency = latency;\n    }\n\n    protected int bufferSize;\n\n    protected int latency;\n\n    protected File file;\n\n    protected List<OutputDestination> outputDestinations;\n\n    protected boolean continueRunning;\n\n    protected boolean needsRestart;\n\n    protected Thread runnerThread;\n\n    protected boolean paused;\n\n    /**\n     * Instances of this class are used to run a thread which follows a\n     * FileFollower's file and sends prints its contents to OutputDestinations.\n     * This class should only handle the gathering of data from the followed\n     * file. Actually writing to the output destinations is handled by the outer\n     * class (FileFollower).\n     */\n    class Runner implements Runnable {\n\n        private Logger log = Logger.getLogger(Runner.class.getName());\n\n        public void run() {\n            log.finer(\"entering FileFollower.run()\");\n            while (continueRunning) {\n                runAction();\n            }\n            log.finer(\"exiting FileFollower.run()\");\n        }\n\n        protected void runAction() {\n            try {\n                clear();\n                long fileSize = file.length();\n                byte[] byteArray = new byte[bufferSize];\n                int numBytesRead;\n                long lastActivityTime = file.lastModified();\n                // create some stream readers to handle the file\n                FileInputStream fis = new FileInputStream(file);\n                BufferedInputStream bis = new BufferedInputStream(fis);\n                // start at the beginning of the file\n                long startingPoint = 0;\n                // if the file size is bigger than the buffer size, skip to the\n                // end of the file if not performing a restart\n                if (fileSize > bufferSize) {\n                    startingPoint = fileSize - bufferSize;\n                }\n                // reset the restart flag\n                needsRestart = false;\n                log.finer(\"Starting point: \" + startingPoint + \"; Last activity: \" + lastActivityTime);\n                bis.skip(startingPoint);\n                while (continueRunning && !needsRestart) {\n                    if (!paused) {\n                        lastActivityTime = System.currentTimeMillis();\n                        numBytesRead = bis.read(byteArray, 0, byteArray.length);\n                        boolean dataWasFound = (numBytesRead > 0);\n                        log.finer(\"Bytes read: \" + numBytesRead + \"; dataWasFound: \" + dataWasFound);\n                        // if data was found, print it and log activity time\n                        if (dataWasFound) {\n                            String output = new String(byteArray, 0, numBytesRead);\n                            // print the output to the listeners\n                            print(output);\n                        } else // no data found so check the file and restart if needed\n                        {\n                            // check if the file handle has become stale (file\n                            // was modified, but no data was read).\n                            boolean fileExists = file.exists();\n                            // removed check for 0 length because a file could\n                            // change by being cleared out\n                            // && (file_.length() > 0);\n                            boolean fileHasChanged = file.lastModified() > lastActivityTime;\n                            if (fileExists && fileHasChanged) {\n                                log.finer(\"Needs restart [fileExists=\" + fileExists + \"; fileHasChanged=\" + fileHasChanged + \"]\");\n                                needsRestart = true;\n                            }\n                        }\n                        boolean allDataRead = (numBytesRead < byteArray.length);\n                        if (allDataRead && !needsRestart) {\n                            log.finer(\"Sleeping for \" + latency + \"ms [allDataRead:\" + allDataRead + \"; needsRestart:\" + needsRestart + \"]\");\n                            sleep();\n                        }\n                    } else {\n                        log.finer(\"Runner paused.\");\n                        sleep();\n                    }\n                }\n                log.finer(\"exiting Runner.runAction [continueRunning=\" + continueRunning + \"; needsRestart=\" + needsRestart + \"]\");\n                bis.close();\n                fis.close();\n            } catch (IOException e) {\n                log.log(Level.SEVERE, \"IOException while following file\", e);\n            }\n        }\n\n        private void sleep() {\n            try {\n                Thread.sleep(latency);\n            } catch (InterruptedException e) {\n                // Interrupt may be thrown manually by stop()\n                log.finer(\"DIED IN MY SLEEP\");\n            }\n        }\n    }\n\n    /**\n     * Line separator, retrieved from System properties & stored statically.\n     */\n    protected static final String lineSeparator = System.getProperty(\"line.separator\");\n}\n",
		"id": "EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/FileFollowerTest3.java",
		"test_prompt": "// FileFollowerTest3.java\npackage ghm.follow;\n\nimport ghm.follow.io.OutputDestination;\nimport java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileFollower}.\n* It contains ten unit test cases for the {@link FileFollower#isPaused()} method.\n*/\nclass FileFollowerTest3 {"
	},
	{
		"original_code": "// FollowApp.java\n/*\n * Copyright (C) 2000-2003 Greg Merrill (greghmerrill@yahoo.com)\n * \n * This file is part of Follow (http://follow.sf.net).\n * \n * Follow is free software; you can redistribute it and/or modify it under the\n * terms of version 2 of the GNU General Public License as published by the Free\n * Software Foundation.\n * \n * Follow is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License along with\n * Follow; if not, write to the Free Software Foundation, Inc., 59 Temple Place,\n * Suite 330, Boston, MA 02111-1307 USA\n */\npackage ghm.follow;\n\nimport ghm.follow.config.Configure;\nimport ghm.follow.config.FollowAppAttributes;\nimport ghm.follow.event.WindowTracker;\nimport ghm.follow.gui.About;\nimport ghm.follow.gui.Clear;\nimport ghm.follow.gui.ClearAll;\nimport ghm.follow.gui.Close;\nimport ghm.follow.gui.Debug;\nimport ghm.follow.gui.Delete;\nimport ghm.follow.gui.DeleteAll;\nimport ghm.follow.gui.DndFileOpener;\nimport ghm.follow.gui.Edit;\nimport ghm.follow.gui.Exit;\nimport ghm.follow.gui.FileFollowingPane;\nimport ghm.follow.gui.FollowAppAction;\nimport ghm.follow.gui.Menu;\nimport ghm.follow.gui.ComponentBuilder;\nimport ghm.follow.gui.Open;\nimport ghm.follow.gui.Pause;\nimport ghm.follow.gui.PopupMenu;\nimport ghm.follow.gui.Reset;\nimport ghm.follow.gui.StartupStatus;\nimport ghm.follow.gui.TabbedPane;\nimport ghm.follow.gui.ToolBar;\nimport ghm.follow.gui.FollowAppAction.ActionContext;\nimport ghm.follow.nav.Bottom;\nimport ghm.follow.nav.NextTab;\nimport ghm.follow.nav.PreviousTab;\nimport ghm.follow.nav.Top;\nimport ghm.follow.search.ClearAllHighlights;\nimport ghm.follow.search.ClearHighlights;\nimport ghm.follow.search.Find;\nimport ghm.follow.search.SearchableTextPane;\nimport ghm.follow.systemInterface.DefaultSystemInterface;\nimport ghm.follow.systemInterface.SystemInterface;\nimport java.awt.BorderLayout;\nimport java.awt.Component;\nimport java.awt.Cursor;\nimport java.awt.Dimension;\nimport java.awt.GraphicsEnvironment;\nimport java.awt.Window;\nimport java.awt.dnd.DropTarget;\nimport java.awt.event.ComponentAdapter;\nimport java.awt.event.ComponentEvent;\nimport java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseListener;\nimport java.beans.PropertyChangeEvent;\nimport java.beans.PropertyChangeListener;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.net.URL;\nimport java.text.MessageFormat;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.MissingResourceException;\nimport java.util.ResourceBundle;\nimport javax.swing.ImageIcon;\nimport javax.swing.JFrame;\nimport javax.swing.JMenuBar;\nimport javax.swing.JTabbedPane;\nimport javax.swing.SwingUtilities;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * This class' main() method is the entry point into the Follow application.\n *\n * @see #main(String[])\n * @author <a href=\"mailto:greghmerrill@yahoo.com\">Greg Merrill</a>\n */\npublic class FollowApp {\n\n    public static final String FILE_SEPARATOR = System.getProperty(\"file.separator\");\n\n    public static final String MESSAGE_LINE_SEPARATOR = \"\\n\";\n\n    public static final boolean DEBUG = Boolean.getBoolean(\"follow.debug\");\n\n    public static boolean HAS_SOLARIS_BUG = false;\n\n    private static Logger LOG = Logger.getLogger(FollowApp.class.getName());\n\n    private int currentCursor = Cursor.DEFAULT_CURSOR;\n\n    private Cursor defaultCursor;\n\n    private Cursor waitCursor;\n\n    private Map<File, FileFollowingPane> fileToFollowingPaneMap = new HashMap<File, FileFollowingPane>();\n\n    private JTabbedPane tabbedPane;\n\n    private ToolBar toolBar;\n\n    private PopupMenu popupMenu;\n\n    private Menu recentFilesMenu;\n\n    private MouseListener rightClickListener;\n\n    private HashMap<String, FollowAppAction> actions = new HashMap<String, FollowAppAction>();\n\n    private SystemInterface systemInterface;\n\n    private StartupStatus startupStatus;\n\n    private FollowAppAttributes attributes;\n\n    private static FollowApp instance;\n\n    private static ResourceBundle resources = ResourceBundle.getBundle(\"ghm.follow.FollowAppResourceBundle\");\n\n    private JFrame frame;\n\n    // We should remove this hack once JDK 1.4 gets wide adoption on Solaris.\n    static {\n        boolean isSolaris = \"SunOS\".equals(System.getProperty(\"os.name\"));\n        if (isSolaris) {\n            String version = System.getProperty(\"java.version\");\n            if ((version != null) && version.startsWith(\"1.\")) {\n                String substring = version.substring(2, 3);\n                try {\n                    int minor = Integer.parseInt(substring);\n                    if (minor < 4) {\n                        HAS_SOLARIS_BUG = true;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // Nothing else to do.\n                }\n            }\n        }\n    }\n\n    /**\n     * @param fileNames\n     *            names of files to be opened\n     */\n    FollowApp(List<String> fileNames) throws IOException, InterruptedException, InvocationTargetException {\n        this(fileNames, null);\n    }\n\n    FollowApp(List<String> filenames, File propertyFile) throws IOException, InterruptedException, InvocationTargetException {\n        // Create & show startup status window\n        startupStatus = new StartupStatus(resources);\n        centerWindowInScreen(startupStatus);\n        startupStatus.pack();\n        SwingUtilities.invokeAndWait(new Runnable() {\n\n            public void run() {\n                startupStatus.setVisible(true);\n            }\n        });\n        // Ghastly workaround for bug in Font construction, in review by\n        // Sun with review id 108683.\n        GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames();\n        SwingUtilities.invokeAndWait(new Runnable() {\n\n            public void run() {\n                startupStatus.markDone(startupStatus.LOAD_SYSTEM_FONTS);\n            }\n        });\n        // create frame first. the close operation is handled in WindowTracker\n        frame = new JFrame(getResourceString(\"frame.title\"));\n        // load the attributes\n        attributes = new FollowAppAttributes(propertyFile);\n        // add listeners to update the recent files list\n        RecentFileListener rfl = new RecentFileListener();\n        attributes.addPropertyChangeListener(FollowAppAttributes.RECENT_FILES_KEY, rfl);\n        attributes.addPropertyChangeListener(FollowAppAttributes.RECENT_FILES_MAX_KEY, rfl);\n        // load the actions referenced in the application\n        loadActions();\n        // initialize SystemInterface\n        systemInterface = new DefaultSystemInterface(this);\n        // initialize menubar\n        JMenuBar jMenuBar = ComponentBuilder.buildMenuBar(resources, getActions());\n        // set the recent files menu to local variable so it can be updated\n        // easily\n        recentFilesMenu = ComponentBuilder.recentFilesMenu;\n        // fake an event to get the menu setup initially\n        rfl.propertyChange(null);\n        // initialize popupMenu\n        popupMenu = ComponentBuilder.buildPopupMenu(getActions());\n        // initialize toolbar\n        toolBar = ComponentBuilder.buildToolBar(getActions());\n        // initialize tabbedPane, but wait to open files until after frame\n        // initialization\n        tabbedPane = new TabbedPane(attributes);\n        enableDragAndDrop(tabbedPane);\n        // initialize frame\n        initFrame(jMenuBar);\n        // This is an ugly hack. It seems like JFrame.setLocation() is buggy\n        // on Solaris jdk versions before 1.4\n        if (HAS_SOLARIS_BUG) {\n            frame.setLocation(50, 50);\n        } else {\n            frame.setLocation(attributes.getX(), attributes.getY());\n        }\n        // track window close events. WindowTracker handles the close operation\n        frame.addWindowListener(new WindowTracker(attributes, tabbedPane, systemInterface));\n        enableDragAndDrop(frame);\n        // Open files from attributes; this is done after the frame is complete\n        // and all components have been added to it to make sure that the frame\n        // can be shown absolutely as soon as possible. If we put this code\n        // before frame creation (as in v1.0), frame creation may take longer\n        // because there are more threads (spawned in the course of open())\n        // contending for processor time.\n        List<File> files = attributes.getFollowedFiles();\n        StringBuffer nonexistentFilesBuffer = null;\n        int nonexistentFileCount = 0;\n        for (File file : files) {\n            try {\n                openFile(file);\n            } catch (FileNotFoundException e) {\n                // This file has been deleted since the previous execution.\n                // Remove it from the list of followed files\n                attributes.removeFollowedFile(file);\n                nonexistentFileCount++;\n                if (nonexistentFilesBuffer == null) {\n                    nonexistentFilesBuffer = new StringBuffer(file.getAbsolutePath());\n                } else {\n                    nonexistentFilesBuffer.append(file.getAbsolutePath());\n                }\n                nonexistentFilesBuffer.append(MESSAGE_LINE_SEPARATOR);\n            }\n        }\n        // open files from the command line\n        for (String filename : filenames) {\n            try {\n                openFile(new File(filename));\n            } catch (FileNotFoundException e) {\n                String msg = MessageFormat.format(getResourceString(\"message.cmdLineFileNotFound.text\"), new Object[] { filename });\n                LOG.info(msg);\n            }\n        }\n        if (nonexistentFileCount > 0) {\n            // Alert the user of the fact that one or more files have been\n            // deleted since the previous execution\n            String text = getResourceString(\"message.filesDeletedSinceLastExecution.text\");\n            String message = MessageFormat.format(text, new Object[] { nonexistentFileCount, nonexistentFilesBuffer.toString() });\n            // String title =\n            // getResourceString(\"message.filesDeletedSinceLastExecution.title\");\n            // JOptionPane.showMessageDialog(frame_, message, title,\n            // JOptionPane.WARNING_MESSAGE);\n            LOG.info(message);\n        }\n        int tabCount = tabbedPane.getTabCount();\n        if (tabCount > 0) {\n            if (tabCount > attributes.getSelectedTabIndex()) {\n                tabbedPane.setSelectedIndex(attributes.getSelectedTabIndex());\n            } else {\n                tabbedPane.setSelectedIndex(0);\n            }\n        }\n    }\n\n    /**\n     * Close the current tab\n     */\n    public void closeFile() {\n        FileFollowingPane fileFollowingPane = getSelectedFileFollowingPane();\n        int tab = tabbedPane.getSelectedIndex();\n        if (tab >= 0) {\n            tabbedPane.removeTabAt(tab);\n            disableDragAndDrop(fileFollowingPane.getTextPane());\n            attributes.removeFollowedFile(fileFollowingPane.getFollowedFile());\n            fileFollowingPane.stopFollowing();\n            fileToFollowingPaneMap.remove(fileFollowingPane.getFollowedFile());\n        }\n        updateActions();\n    }\n\n    /**\n     * Get a string from the resource bundle. Convenience method to shorten and\n     * centralize this common call\n     *\n     * @param key\n     * @return The value of key in the resource bundle. null if the key is not\n     *         found.\n     */\n    public static String getResourceString(String key) {\n        String value = null;\n        try {\n            value = resources.getString(key);\n        } catch (MissingResourceException mre) {\n            LOG.warning(mre.getMessage());\n        }\n        return value;\n    }\n\n    /**\n     * Gets an image icon from the resource path.\n     *\n     * @param clazz\n     *            The class to use as an entry point to the resource path. Image\n     *            path should be relative to this class.\n     * @param iconNameKey\n     *            The resource key name where the image is defined.\n     * @return An image icon based on the URL generated from the value of\n     *         iconNameKey. null if no URL can be found.\n     */\n    public static ImageIcon getIcon(Class<?> clazz, String iconNameKey) {\n        String filename = getResourceString(iconNameKey);\n        URL url = clazz.getResource(filename);\n        LOG.finer(\"Class: \" + clazz + \", iconNameKey: \" + iconNameKey);\n        LOG.finer(\"filename: \" + filename);\n        LOG.finer(\"url: \" + url);\n        ImageIcon icon = null;\n        if (url != null) {\n            icon = new ImageIcon(url);\n            LOG.finer(\"errored: \" + (java.awt.MediaTracker.ERRORED == icon.getImageLoadStatus()));\n        }\n        return icon;\n    }\n\n    /**\n     * Loads the actions used in the application\n     *\n     * @throws IOException\n     */\n    private void loadActions() throws IOException {\n        // initialize actions\n        putAction(Open.NAME, new Open(this));\n        putAction(Close.NAME, new Close(this));\n        putAction(Edit.NAME, new Edit(this));\n        putAction(Exit.NAME, new Exit(this));\n        putAction(Top.NAME, new Top(this));\n        putAction(Bottom.NAME, new Bottom(this));\n        putAction(Clear.NAME, new Clear(this));\n        putAction(ClearAll.NAME, new ClearAll(this));\n        putAction(Delete.NAME, new Delete(this));\n        putAction(DeleteAll.NAME, new DeleteAll(this));\n        putAction(Configure.NAME, new Configure(this));\n        putAction(About.NAME, new About(this));\n        if (DEBUG) {\n            putAction(Debug.NAME, new Debug(this));\n        }\n        putAction(Pause.NAME, new Pause(this));\n        putAction(NextTab.NAME, new NextTab(this));\n        putAction(PreviousTab.NAME, new PreviousTab(this));\n        putAction(Find.NAME, new Find(this));\n        putAction(ClearHighlights.NAME, new ClearHighlights(this));\n        putAction(ClearAllHighlights.NAME, new ClearAllHighlights(this));\n        putAction(Reset.NAME, new Reset(this));\n    }\n\n    /**\n     * @param jMenuBar\n     */\n    private void initFrame(JMenuBar jMenuBar) {\n        frame.setJMenuBar(jMenuBar);\n        frame.getContentPane().add(toolBar, BorderLayout.NORTH);\n        frame.getContentPane().add(tabbedPane, BorderLayout.CENTER);\n        frame.setSize(attributes.getWidth(), attributes.getHeight());\n    }\n\n    public void show() {\n        frame.setVisible(true);\n    }\n\n    public FollowAppAction getAction(String name) {\n        return actions.get(name);\n    }\n\n    /**\n     * Get all actions associated to the application\n     *\n     * @return\n     */\n    public HashMap<String, FollowAppAction> getActions() {\n        return actions;\n    }\n\n    /**\n     * Set an action to the action map of the application.\n     *\n     * @param name\n     *            The key to set the action to.\n     * @param action\n     *            The action to create an association for.\n     */\n    public void putAction(String name, FollowAppAction action) {\n        if (FollowAppAction.ActionContext.APP == action.getContext())\n            action.setEnabled(true);\n        else\n            action.setEnabled(false);\n        actions.put(name, action);\n    }\n\n    public void openFile(File file) throws FileNotFoundException {\n        openFile(file, attributes.autoScroll());\n    }\n\n    /**\n     * Warning: This method should be called only from (1) the FollowApp\n     * initializer (before any components are realized) or (2) from the event\n     * dispatching thread.\n     */\n    void openFile(File file, boolean startFollowing) throws FileNotFoundException {\n        if (file == null) {\n            throw new FileNotFoundException(\"file is null.\");\n        }\n        if (!file.exists()) {\n            throw new FileNotFoundException(file.getName() + \" not found.\");\n        }\n        FileFollowingPane fileFollowingPane = (FileFollowingPane) fileToFollowingPaneMap.get(file);\n        if (fileFollowingPane != null) {\n            // File is already open; merely select its tab\n            tabbedPane.setSelectedComponent(fileFollowingPane);\n        } else {\n            fileFollowingPane = new FileFollowingPane(file, attributes.getBufferSize(), attributes.getLatency(), attributes.autoScroll(), attributes.getFont(), attributes.getTabSize());\n            SearchableTextPane ffpTextPane = fileFollowingPane.getTextPane();\n            enableDragAndDrop(ffpTextPane);\n            fileFollowingPane.setSize(frame.getSize());\n            ffpTextPane.setFont(attributes.getFont());\n            ffpTextPane.addMouseListener(getRightClickListener());\n            fileToFollowingPaneMap.put(file, fileFollowingPane);\n            if (startFollowing) {\n                fileFollowingPane.startFollowing();\n            }\n            tabbedPane.addTab(file.getName(), null, fileFollowingPane, file.getAbsolutePath());\n            int tabCount = tabbedPane.getTabCount();\n            if (tabCount < 10) {\n                // KeyEvent.VK_1 through KeyEvent.VK_9 is represented by the\n                // ascii characters 1-9 (49-57)\n                int index = tabCount - 1;\n                tabbedPane.setMnemonicAt(index, index + ((int) '1'));\n            }\n            tabbedPane.setSelectedIndex(tabCount - 1);\n            // add a listener to set the pause icon correctly\n            fileFollowingPane.addComponentListener(new ComponentAdapter() {\n\n                public void componentShown(ComponentEvent e) {\n                    FileFollowingPane ffp = (FileFollowingPane) e.getSource();\n                    Pause pause = (Pause) getAction(Pause.NAME);\n                    pause.setIconByState(ffp.isFollowingPaused());\n                }\n            });\n            // add the file to history\n            attributes.addFollowedFile(file);\n            attributes.addRecentFile(file);\n            updateActions();\n        }\n    }\n\n    private void updateActions() {\n        int tabCount = tabbedPane.getTabCount();\n        for (FollowAppAction a : actions.values()) {\n            if (tabCount <= 1 && a.getContext() == ActionContext.MULTI_FILE)\n                a.setEnabled(false);\n            else if (tabCount == 0 && a.getContext() == ActionContext.SINGLE_FILE)\n                a.setEnabled(false);\n            else\n                a.setEnabled(true);\n        }\n    }\n\n    /**\n     * Warning: This method should be called only from the event dispatching\n     * thread.\n     *\n     * @param cursorType\n     *            may be Cursor.DEFAULT_CURSOR or Cursor.WAIT_CURSOR\n     */\n    public void setCursor(int cursorType) {\n        if (cursorType == currentCursor) {\n            return;\n        }\n        switch(cursorType) {\n            case Cursor.DEFAULT_CURSOR:\n                if (defaultCursor == null) {\n                    defaultCursor = Cursor.getDefaultCursor();\n                }\n                frame.setCursor(defaultCursor);\n                break;\n            case Cursor.WAIT_CURSOR:\n                if (waitCursor == null) {\n                    waitCursor = Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR);\n                }\n                frame.setCursor(waitCursor);\n                break;\n            default:\n                throw new IllegalArgumentException(\"Supported cursors are Cursor.DEFAULT_CURSOR and Cursor.WAIT_CURSOR\");\n        }\n        currentCursor = cursorType;\n    }\n\n    // Lazy initializer for the right-click listener which invokes a popup menu\n    private MouseListener getRightClickListener() {\n        if (rightClickListener == null) {\n            rightClickListener = new MouseAdapter() {\n\n                public void mouseReleased(MouseEvent e) {\n                    if (SwingUtilities.isRightMouseButton(e)) {\n                        Component source = e.getComponent();\n                        popupMenu.show(source, e.getX(), e.getY());\n                    }\n                }\n            };\n        }\n        return rightClickListener;\n    }\n\n    public void enableDragAndDrop(Component c) {\n        // Invoking this constructor automatically sets the component's drop\n        // target\n        new DropTarget(c, new DndFileOpener(this));\n    }\n\n    public void disableDragAndDrop(Component c) {\n        c.setDropTarget(null);\n    }\n\n    public FileFollowingPane getSelectedFileFollowingPane() {\n        return (FileFollowingPane) tabbedPane.getSelectedComponent();\n    }\n\n    public List<FileFollowingPane> getAllFileFollowingPanes() {\n        int tabCount = tabbedPane.getTabCount();\n        List<FileFollowingPane> allFileFollowingPanes = new ArrayList<FileFollowingPane>();\n        for (int i = 0; i < tabCount; i++) {\n            allFileFollowingPanes.add((FileFollowingPane) tabbedPane.getComponentAt(i));\n        }\n        return allFileFollowingPanes;\n    }\n\n    public FollowAppAttributes getAttributes() {\n        return attributes;\n    }\n\n    public Map<File, FileFollowingPane> getFileToFollowingPaneMap() {\n        return fileToFollowingPaneMap;\n    }\n\n    public JFrame getFrame() {\n        return frame;\n    }\n\n    public static FollowApp getInstance() {\n        return instance;\n    }\n\n    public SystemInterface getSystemInterface() {\n        return systemInterface;\n    }\n\n    public void setSystemInterface(SystemInterface systemInterface) {\n        this.systemInterface = systemInterface;\n    }\n\n    public JTabbedPane getTabbedPane() {\n        return tabbedPane;\n    }\n\n    public static void centerWindowInScreen(Window window) {\n        Dimension screenSize = window.getToolkit().getScreenSize();\n        Dimension windowSize = window.getPreferredSize();\n        window.setLocation((int) (screenSize.getWidth() / 2 - windowSize.getWidth() / 2), (int) (screenSize.getHeight() / 2 - windowSize.getHeight() / 2));\n    }\n\n    /**\n     * Invoke this method to start the Follow application. If any command-line\n     * arguments are passed in, they are assume to be filenames and are opened\n     * in the Follow application\n     *\n     * @param args\n     *            files to be opened\n     */\n    public static void main(String[] args) {\n        try {\n            ArrayList<String> fileNames = new ArrayList<String>();\n            File propFile = null;\n            for (int i = 0; i < args.length; i++) {\n                if (args[i].startsWith(\"-\")) {\n                    if (\"-propFile\".equalsIgnoreCase(args[i])) {\n                        propFile = new File(args[++i]);\n                    }\n                } else {\n                    fileNames.add(args[i]);\n                }\n            }\n            instance = new FollowApp(fileNames, propFile);\n            SwingUtilities.invokeAndWait(new Runnable() {\n\n                public void run() {\n                    // ensure all widgets inited before opening files\n                    instance.show();\n                    instance.startupStatus.markDone(instance.startupStatus.CREATE_WIDGETS);\n                }\n            });\n            instance.startupStatus.dispose();\n            // commented code below so that windows follow based on setting in\n            // preferences which is set on the pane when the file is opened\n            // for (int i=0; i < instance_.tabbedPane_.getTabCount(); i++) {\n            // ((FileFollowingPane)instance_.tabbedPane_.getComponentAt(i)).startFollowing();\n            // }\n        } catch (Throwable t) {\n            LOG.log(Level.SEVERE, \"Unhandled exception\", t);\n            System.exit(-1);\n        }\n    }\n\n    private class RecentFileListener implements PropertyChangeListener {\n\n        public void propertyChange(PropertyChangeEvent evt) {\n            if (recentFilesMenu != null) {\n                recentFilesMenu.removeAll();\n                List<File> recentFiles = attributes.getRecentFiles();\n                // descend down the list to order files by last opened\n                for (int i = recentFiles.size() - 1; i >= 0; i--) {\n                    // have to use FollowApp.this because 'this' is now the\n                    // context of\n                    // the inner class\n                    recentFilesMenu.add(new Open(FollowApp.this, recentFiles.get(i)));\n                }\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/FollowAppTest0.java",
		"test_prompt": "// FollowAppTest0.java\npackage ghm.follow;\n\nimport ghm.follow.config.Configure;\nimport ghm.follow.config.FollowAppAttributes;\nimport ghm.follow.event.WindowTracker;\nimport ghm.follow.gui.About;\nimport ghm.follow.gui.Clear;\nimport ghm.follow.gui.ClearAll;\nimport ghm.follow.gui.Close;\nimport ghm.follow.gui.Debug;\nimport ghm.follow.gui.Delete;\nimport ghm.follow.gui.DeleteAll;\nimport ghm.follow.gui.DndFileOpener;\nimport ghm.follow.gui.Edit;\nimport ghm.follow.gui.Exit;\nimport ghm.follow.gui.FileFollowingPane;\nimport ghm.follow.gui.FollowAppAction;\nimport ghm.follow.gui.Menu;\nimport ghm.follow.gui.ComponentBuilder;\nimport ghm.follow.gui.Open;\nimport ghm.follow.gui.Pause;\nimport ghm.follow.gui.PopupMenu;\nimport ghm.follow.gui.Reset;\nimport ghm.follow.gui.StartupStatus;\nimport ghm.follow.gui.TabbedPane;\nimport ghm.follow.gui.ToolBar;\nimport ghm.follow.gui.FollowAppAction.ActionContext;\nimport ghm.follow.nav.Bottom;\nimport ghm.follow.nav.NextTab;\nimport ghm.follow.nav.PreviousTab;\nimport ghm.follow.nav.Top;\nimport ghm.follow.search.ClearAllHighlights;\nimport ghm.follow.search.ClearHighlights;\nimport ghm.follow.search.Find;\nimport ghm.follow.search.SearchableTextPane;\nimport ghm.follow.systemInterface.DefaultSystemInterface;\nimport ghm.follow.systemInterface.SystemInterface;\nimport java.awt.BorderLayout;\nimport java.awt.Component;\nimport java.awt.Cursor;\nimport java.awt.Dimension;\nimport java.awt.GraphicsEnvironment;\nimport java.awt.Window;\nimport java.awt.dnd.DropTarget;\nimport java.awt.event.ComponentAdapter;\nimport java.awt.event.ComponentEvent;\nimport java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseListener;\nimport java.beans.PropertyChangeEvent;\nimport java.beans.PropertyChangeListener;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.net.URL;\nimport java.text.MessageFormat;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.MissingResourceException;\nimport java.util.ResourceBundle;\nimport javax.swing.ImageIcon;\nimport javax.swing.JFrame;\nimport javax.swing.JMenuBar;\nimport javax.swing.JTabbedPane;\nimport javax.swing.SwingUtilities;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FollowApp}.\n* It contains ten unit test cases for the {@link FollowApp#getResourceString(String)} method.\n*/\nclass FollowAppTest0 {"
	},
	{
		"original_code": "// FollowApp.java\n/*\n * Copyright (C) 2000-2003 Greg Merrill (greghmerrill@yahoo.com)\n * \n * This file is part of Follow (http://follow.sf.net).\n * \n * Follow is free software; you can redistribute it and/or modify it under the\n * terms of version 2 of the GNU General Public License as published by the Free\n * Software Foundation.\n * \n * Follow is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License along with\n * Follow; if not, write to the Free Software Foundation, Inc., 59 Temple Place,\n * Suite 330, Boston, MA 02111-1307 USA\n */\npackage ghm.follow;\n\nimport ghm.follow.config.Configure;\nimport ghm.follow.config.FollowAppAttributes;\nimport ghm.follow.event.WindowTracker;\nimport ghm.follow.gui.About;\nimport ghm.follow.gui.Clear;\nimport ghm.follow.gui.ClearAll;\nimport ghm.follow.gui.Close;\nimport ghm.follow.gui.Debug;\nimport ghm.follow.gui.Delete;\nimport ghm.follow.gui.DeleteAll;\nimport ghm.follow.gui.DndFileOpener;\nimport ghm.follow.gui.Edit;\nimport ghm.follow.gui.Exit;\nimport ghm.follow.gui.FileFollowingPane;\nimport ghm.follow.gui.FollowAppAction;\nimport ghm.follow.gui.Menu;\nimport ghm.follow.gui.ComponentBuilder;\nimport ghm.follow.gui.Open;\nimport ghm.follow.gui.Pause;\nimport ghm.follow.gui.PopupMenu;\nimport ghm.follow.gui.Reset;\nimport ghm.follow.gui.StartupStatus;\nimport ghm.follow.gui.TabbedPane;\nimport ghm.follow.gui.ToolBar;\nimport ghm.follow.gui.FollowAppAction.ActionContext;\nimport ghm.follow.nav.Bottom;\nimport ghm.follow.nav.NextTab;\nimport ghm.follow.nav.PreviousTab;\nimport ghm.follow.nav.Top;\nimport ghm.follow.search.ClearAllHighlights;\nimport ghm.follow.search.ClearHighlights;\nimport ghm.follow.search.Find;\nimport ghm.follow.search.SearchableTextPane;\nimport ghm.follow.systemInterface.DefaultSystemInterface;\nimport ghm.follow.systemInterface.SystemInterface;\nimport java.awt.BorderLayout;\nimport java.awt.Component;\nimport java.awt.Cursor;\nimport java.awt.Dimension;\nimport java.awt.GraphicsEnvironment;\nimport java.awt.Window;\nimport java.awt.dnd.DropTarget;\nimport java.awt.event.ComponentAdapter;\nimport java.awt.event.ComponentEvent;\nimport java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseListener;\nimport java.beans.PropertyChangeEvent;\nimport java.beans.PropertyChangeListener;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.net.URL;\nimport java.text.MessageFormat;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.MissingResourceException;\nimport java.util.ResourceBundle;\nimport javax.swing.ImageIcon;\nimport javax.swing.JFrame;\nimport javax.swing.JMenuBar;\nimport javax.swing.JTabbedPane;\nimport javax.swing.SwingUtilities;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * This class' main() method is the entry point into the Follow application.\n *\n * @see #main(String[])\n * @author <a href=\"mailto:greghmerrill@yahoo.com\">Greg Merrill</a>\n */\npublic class FollowApp {\n\n    public static final String FILE_SEPARATOR = System.getProperty(\"file.separator\");\n\n    public static final String MESSAGE_LINE_SEPARATOR = \"\\n\";\n\n    public static final boolean DEBUG = Boolean.getBoolean(\"follow.debug\");\n\n    public static boolean HAS_SOLARIS_BUG = false;\n\n    private static Logger LOG = Logger.getLogger(FollowApp.class.getName());\n\n    private int currentCursor = Cursor.DEFAULT_CURSOR;\n\n    private Cursor defaultCursor;\n\n    private Cursor waitCursor;\n\n    private Map<File, FileFollowingPane> fileToFollowingPaneMap = new HashMap<File, FileFollowingPane>();\n\n    private JTabbedPane tabbedPane;\n\n    private ToolBar toolBar;\n\n    private PopupMenu popupMenu;\n\n    private Menu recentFilesMenu;\n\n    private MouseListener rightClickListener;\n\n    private HashMap<String, FollowAppAction> actions = new HashMap<String, FollowAppAction>();\n\n    private SystemInterface systemInterface;\n\n    private StartupStatus startupStatus;\n\n    private FollowAppAttributes attributes;\n\n    private static FollowApp instance;\n\n    private static ResourceBundle resources = ResourceBundle.getBundle(\"ghm.follow.FollowAppResourceBundle\");\n\n    private JFrame frame;\n\n    // We should remove this hack once JDK 1.4 gets wide adoption on Solaris.\n    static {\n        boolean isSolaris = \"SunOS\".equals(System.getProperty(\"os.name\"));\n        if (isSolaris) {\n            String version = System.getProperty(\"java.version\");\n            if ((version != null) && version.startsWith(\"1.\")) {\n                String substring = version.substring(2, 3);\n                try {\n                    int minor = Integer.parseInt(substring);\n                    if (minor < 4) {\n                        HAS_SOLARIS_BUG = true;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // Nothing else to do.\n                }\n            }\n        }\n    }\n\n    /**\n     * @param fileNames\n     *            names of files to be opened\n     */\n    FollowApp(List<String> fileNames) throws IOException, InterruptedException, InvocationTargetException {\n        this(fileNames, null);\n    }\n\n    FollowApp(List<String> filenames, File propertyFile) throws IOException, InterruptedException, InvocationTargetException {\n        // Create & show startup status window\n        startupStatus = new StartupStatus(resources);\n        centerWindowInScreen(startupStatus);\n        startupStatus.pack();\n        SwingUtilities.invokeAndWait(new Runnable() {\n\n            public void run() {\n                startupStatus.setVisible(true);\n            }\n        });\n        // Ghastly workaround for bug in Font construction, in review by\n        // Sun with review id 108683.\n        GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames();\n        SwingUtilities.invokeAndWait(new Runnable() {\n\n            public void run() {\n                startupStatus.markDone(startupStatus.LOAD_SYSTEM_FONTS);\n            }\n        });\n        // create frame first. the close operation is handled in WindowTracker\n        frame = new JFrame(getResourceString(\"frame.title\"));\n        // load the attributes\n        attributes = new FollowAppAttributes(propertyFile);\n        // add listeners to update the recent files list\n        RecentFileListener rfl = new RecentFileListener();\n        attributes.addPropertyChangeListener(FollowAppAttributes.RECENT_FILES_KEY, rfl);\n        attributes.addPropertyChangeListener(FollowAppAttributes.RECENT_FILES_MAX_KEY, rfl);\n        // load the actions referenced in the application\n        loadActions();\n        // initialize SystemInterface\n        systemInterface = new DefaultSystemInterface(this);\n        // initialize menubar\n        JMenuBar jMenuBar = ComponentBuilder.buildMenuBar(resources, getActions());\n        // set the recent files menu to local variable so it can be updated\n        // easily\n        recentFilesMenu = ComponentBuilder.recentFilesMenu;\n        // fake an event to get the menu setup initially\n        rfl.propertyChange(null);\n        // initialize popupMenu\n        popupMenu = ComponentBuilder.buildPopupMenu(getActions());\n        // initialize toolbar\n        toolBar = ComponentBuilder.buildToolBar(getActions());\n        // initialize tabbedPane, but wait to open files until after frame\n        // initialization\n        tabbedPane = new TabbedPane(attributes);\n        enableDragAndDrop(tabbedPane);\n        // initialize frame\n        initFrame(jMenuBar);\n        // This is an ugly hack. It seems like JFrame.setLocation() is buggy\n        // on Solaris jdk versions before 1.4\n        if (HAS_SOLARIS_BUG) {\n            frame.setLocation(50, 50);\n        } else {\n            frame.setLocation(attributes.getX(), attributes.getY());\n        }\n        // track window close events. WindowTracker handles the close operation\n        frame.addWindowListener(new WindowTracker(attributes, tabbedPane, systemInterface));\n        enableDragAndDrop(frame);\n        // Open files from attributes; this is done after the frame is complete\n        // and all components have been added to it to make sure that the frame\n        // can be shown absolutely as soon as possible. If we put this code\n        // before frame creation (as in v1.0), frame creation may take longer\n        // because there are more threads (spawned in the course of open())\n        // contending for processor time.\n        List<File> files = attributes.getFollowedFiles();\n        StringBuffer nonexistentFilesBuffer = null;\n        int nonexistentFileCount = 0;\n        for (File file : files) {\n            try {\n                openFile(file);\n            } catch (FileNotFoundException e) {\n                // This file has been deleted since the previous execution.\n                // Remove it from the list of followed files\n                attributes.removeFollowedFile(file);\n                nonexistentFileCount++;\n                if (nonexistentFilesBuffer == null) {\n                    nonexistentFilesBuffer = new StringBuffer(file.getAbsolutePath());\n                } else {\n                    nonexistentFilesBuffer.append(file.getAbsolutePath());\n                }\n                nonexistentFilesBuffer.append(MESSAGE_LINE_SEPARATOR);\n            }\n        }\n        // open files from the command line\n        for (String filename : filenames) {\n            try {\n                openFile(new File(filename));\n            } catch (FileNotFoundException e) {\n                String msg = MessageFormat.format(getResourceString(\"message.cmdLineFileNotFound.text\"), new Object[] { filename });\n                LOG.info(msg);\n            }\n        }\n        if (nonexistentFileCount > 0) {\n            // Alert the user of the fact that one or more files have been\n            // deleted since the previous execution\n            String text = getResourceString(\"message.filesDeletedSinceLastExecution.text\");\n            String message = MessageFormat.format(text, new Object[] { nonexistentFileCount, nonexistentFilesBuffer.toString() });\n            // String title =\n            // getResourceString(\"message.filesDeletedSinceLastExecution.title\");\n            // JOptionPane.showMessageDialog(frame_, message, title,\n            // JOptionPane.WARNING_MESSAGE);\n            LOG.info(message);\n        }\n        int tabCount = tabbedPane.getTabCount();\n        if (tabCount > 0) {\n            if (tabCount > attributes.getSelectedTabIndex()) {\n                tabbedPane.setSelectedIndex(attributes.getSelectedTabIndex());\n            } else {\n                tabbedPane.setSelectedIndex(0);\n            }\n        }\n    }\n\n    /**\n     * Close the current tab\n     */\n    public void closeFile() {\n        FileFollowingPane fileFollowingPane = getSelectedFileFollowingPane();\n        int tab = tabbedPane.getSelectedIndex();\n        if (tab >= 0) {\n            tabbedPane.removeTabAt(tab);\n            disableDragAndDrop(fileFollowingPane.getTextPane());\n            attributes.removeFollowedFile(fileFollowingPane.getFollowedFile());\n            fileFollowingPane.stopFollowing();\n            fileToFollowingPaneMap.remove(fileFollowingPane.getFollowedFile());\n        }\n        updateActions();\n    }\n\n    /**\n     * Get a string from the resource bundle. Convenience method to shorten and\n     * centralize this common call\n     *\n     * @param key\n     * @return The value of key in the resource bundle. null if the key is not\n     *         found.\n     */\n    public static String getResourceString(String key) {\n        String value = null;\n        try {\n            value = resources.getString(key);\n        } catch (MissingResourceException mre) {\n            LOG.warning(mre.getMessage());\n        }\n        return value;\n    }\n\n    /**\n     * Gets an image icon from the resource path.\n     *\n     * @param clazz\n     *            The class to use as an entry point to the resource path. Image\n     *            path should be relative to this class.\n     * @param iconNameKey\n     *            The resource key name where the image is defined.\n     * @return An image icon based on the URL generated from the value of\n     *         iconNameKey. null if no URL can be found.\n     */\n    public static ImageIcon getIcon(Class<?> clazz, String iconNameKey) {\n        String filename = getResourceString(iconNameKey);\n        URL url = clazz.getResource(filename);\n        LOG.finer(\"Class: \" + clazz + \", iconNameKey: \" + iconNameKey);\n        LOG.finer(\"filename: \" + filename);\n        LOG.finer(\"url: \" + url);\n        ImageIcon icon = null;\n        if (url != null) {\n            icon = new ImageIcon(url);\n            LOG.finer(\"errored: \" + (java.awt.MediaTracker.ERRORED == icon.getImageLoadStatus()));\n        }\n        return icon;\n    }\n\n    /**\n     * Loads the actions used in the application\n     *\n     * @throws IOException\n     */\n    private void loadActions() throws IOException {\n        // initialize actions\n        putAction(Open.NAME, new Open(this));\n        putAction(Close.NAME, new Close(this));\n        putAction(Edit.NAME, new Edit(this));\n        putAction(Exit.NAME, new Exit(this));\n        putAction(Top.NAME, new Top(this));\n        putAction(Bottom.NAME, new Bottom(this));\n        putAction(Clear.NAME, new Clear(this));\n        putAction(ClearAll.NAME, new ClearAll(this));\n        putAction(Delete.NAME, new Delete(this));\n        putAction(DeleteAll.NAME, new DeleteAll(this));\n        putAction(Configure.NAME, new Configure(this));\n        putAction(About.NAME, new About(this));\n        if (DEBUG) {\n            putAction(Debug.NAME, new Debug(this));\n        }\n        putAction(Pause.NAME, new Pause(this));\n        putAction(NextTab.NAME, new NextTab(this));\n        putAction(PreviousTab.NAME, new PreviousTab(this));\n        putAction(Find.NAME, new Find(this));\n        putAction(ClearHighlights.NAME, new ClearHighlights(this));\n        putAction(ClearAllHighlights.NAME, new ClearAllHighlights(this));\n        putAction(Reset.NAME, new Reset(this));\n    }\n\n    /**\n     * @param jMenuBar\n     */\n    private void initFrame(JMenuBar jMenuBar) {\n        frame.setJMenuBar(jMenuBar);\n        frame.getContentPane().add(toolBar, BorderLayout.NORTH);\n        frame.getContentPane().add(tabbedPane, BorderLayout.CENTER);\n        frame.setSize(attributes.getWidth(), attributes.getHeight());\n    }\n\n    public void show() {\n        frame.setVisible(true);\n    }\n\n    public FollowAppAction getAction(String name) {\n        return actions.get(name);\n    }\n\n    /**\n     * Get all actions associated to the application\n     *\n     * @return\n     */\n    public HashMap<String, FollowAppAction> getActions() {\n        return actions;\n    }\n\n    /**\n     * Set an action to the action map of the application.\n     *\n     * @param name\n     *            The key to set the action to.\n     * @param action\n     *            The action to create an association for.\n     */\n    public void putAction(String name, FollowAppAction action) {\n        if (FollowAppAction.ActionContext.APP == action.getContext())\n            action.setEnabled(true);\n        else\n            action.setEnabled(false);\n        actions.put(name, action);\n    }\n\n    public void openFile(File file) throws FileNotFoundException {\n        openFile(file, attributes.autoScroll());\n    }\n\n    /**\n     * Warning: This method should be called only from (1) the FollowApp\n     * initializer (before any components are realized) or (2) from the event\n     * dispatching thread.\n     */\n    void openFile(File file, boolean startFollowing) throws FileNotFoundException {\n        if (file == null) {\n            throw new FileNotFoundException(\"file is null.\");\n        }\n        if (!file.exists()) {\n            throw new FileNotFoundException(file.getName() + \" not found.\");\n        }\n        FileFollowingPane fileFollowingPane = (FileFollowingPane) fileToFollowingPaneMap.get(file);\n        if (fileFollowingPane != null) {\n            // File is already open; merely select its tab\n            tabbedPane.setSelectedComponent(fileFollowingPane);\n        } else {\n            fileFollowingPane = new FileFollowingPane(file, attributes.getBufferSize(), attributes.getLatency(), attributes.autoScroll(), attributes.getFont(), attributes.getTabSize());\n            SearchableTextPane ffpTextPane = fileFollowingPane.getTextPane();\n            enableDragAndDrop(ffpTextPane);\n            fileFollowingPane.setSize(frame.getSize());\n            ffpTextPane.setFont(attributes.getFont());\n            ffpTextPane.addMouseListener(getRightClickListener());\n            fileToFollowingPaneMap.put(file, fileFollowingPane);\n            if (startFollowing) {\n                fileFollowingPane.startFollowing();\n            }\n            tabbedPane.addTab(file.getName(), null, fileFollowingPane, file.getAbsolutePath());\n            int tabCount = tabbedPane.getTabCount();\n            if (tabCount < 10) {\n                // KeyEvent.VK_1 through KeyEvent.VK_9 is represented by the\n                // ascii characters 1-9 (49-57)\n                int index = tabCount - 1;\n                tabbedPane.setMnemonicAt(index, index + ((int) '1'));\n            }\n            tabbedPane.setSelectedIndex(tabCount - 1);\n            // add a listener to set the pause icon correctly\n            fileFollowingPane.addComponentListener(new ComponentAdapter() {\n\n                public void componentShown(ComponentEvent e) {\n                    FileFollowingPane ffp = (FileFollowingPane) e.getSource();\n                    Pause pause = (Pause) getAction(Pause.NAME);\n                    pause.setIconByState(ffp.isFollowingPaused());\n                }\n            });\n            // add the file to history\n            attributes.addFollowedFile(file);\n            attributes.addRecentFile(file);\n            updateActions();\n        }\n    }\n\n    private void updateActions() {\n        int tabCount = tabbedPane.getTabCount();\n        for (FollowAppAction a : actions.values()) {\n            if (tabCount <= 1 && a.getContext() == ActionContext.MULTI_FILE)\n                a.setEnabled(false);\n            else if (tabCount == 0 && a.getContext() == ActionContext.SINGLE_FILE)\n                a.setEnabled(false);\n            else\n                a.setEnabled(true);\n        }\n    }\n\n    /**\n     * Warning: This method should be called only from the event dispatching\n     * thread.\n     *\n     * @param cursorType\n     *            may be Cursor.DEFAULT_CURSOR or Cursor.WAIT_CURSOR\n     */\n    public void setCursor(int cursorType) {\n        if (cursorType == currentCursor) {\n            return;\n        }\n        switch(cursorType) {\n            case Cursor.DEFAULT_CURSOR:\n                if (defaultCursor == null) {\n                    defaultCursor = Cursor.getDefaultCursor();\n                }\n                frame.setCursor(defaultCursor);\n                break;\n            case Cursor.WAIT_CURSOR:\n                if (waitCursor == null) {\n                    waitCursor = Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR);\n                }\n                frame.setCursor(waitCursor);\n                break;\n            default:\n                throw new IllegalArgumentException(\"Supported cursors are Cursor.DEFAULT_CURSOR and Cursor.WAIT_CURSOR\");\n        }\n        currentCursor = cursorType;\n    }\n\n    // Lazy initializer for the right-click listener which invokes a popup menu\n    private MouseListener getRightClickListener() {\n        if (rightClickListener == null) {\n            rightClickListener = new MouseAdapter() {\n\n                public void mouseReleased(MouseEvent e) {\n                    if (SwingUtilities.isRightMouseButton(e)) {\n                        Component source = e.getComponent();\n                        popupMenu.show(source, e.getX(), e.getY());\n                    }\n                }\n            };\n        }\n        return rightClickListener;\n    }\n\n    public void enableDragAndDrop(Component c) {\n        // Invoking this constructor automatically sets the component's drop\n        // target\n        new DropTarget(c, new DndFileOpener(this));\n    }\n\n    public void disableDragAndDrop(Component c) {\n        c.setDropTarget(null);\n    }\n\n    public FileFollowingPane getSelectedFileFollowingPane() {\n        return (FileFollowingPane) tabbedPane.getSelectedComponent();\n    }\n\n    public List<FileFollowingPane> getAllFileFollowingPanes() {\n        int tabCount = tabbedPane.getTabCount();\n        List<FileFollowingPane> allFileFollowingPanes = new ArrayList<FileFollowingPane>();\n        for (int i = 0; i < tabCount; i++) {\n            allFileFollowingPanes.add((FileFollowingPane) tabbedPane.getComponentAt(i));\n        }\n        return allFileFollowingPanes;\n    }\n\n    public FollowAppAttributes getAttributes() {\n        return attributes;\n    }\n\n    public Map<File, FileFollowingPane> getFileToFollowingPaneMap() {\n        return fileToFollowingPaneMap;\n    }\n\n    public JFrame getFrame() {\n        return frame;\n    }\n\n    public static FollowApp getInstance() {\n        return instance;\n    }\n\n    public SystemInterface getSystemInterface() {\n        return systemInterface;\n    }\n\n    public void setSystemInterface(SystemInterface systemInterface) {\n        this.systemInterface = systemInterface;\n    }\n\n    public JTabbedPane getTabbedPane() {\n        return tabbedPane;\n    }\n\n    public static void centerWindowInScreen(Window window) {\n        Dimension screenSize = window.getToolkit().getScreenSize();\n        Dimension windowSize = window.getPreferredSize();\n        window.setLocation((int) (screenSize.getWidth() / 2 - windowSize.getWidth() / 2), (int) (screenSize.getHeight() / 2 - windowSize.getHeight() / 2));\n    }\n\n    /**\n     * Invoke this method to start the Follow application. If any command-line\n     * arguments are passed in, they are assume to be filenames and are opened\n     * in the Follow application\n     *\n     * @param args\n     *            files to be opened\n     */\n    public static void main(String[] args) {\n        try {\n            ArrayList<String> fileNames = new ArrayList<String>();\n            File propFile = null;\n            for (int i = 0; i < args.length; i++) {\n                if (args[i].startsWith(\"-\")) {\n                    if (\"-propFile\".equalsIgnoreCase(args[i])) {\n                        propFile = new File(args[++i]);\n                    }\n                } else {\n                    fileNames.add(args[i]);\n                }\n            }\n            instance = new FollowApp(fileNames, propFile);\n            SwingUtilities.invokeAndWait(new Runnable() {\n\n                public void run() {\n                    // ensure all widgets inited before opening files\n                    instance.show();\n                    instance.startupStatus.markDone(instance.startupStatus.CREATE_WIDGETS);\n                }\n            });\n            instance.startupStatus.dispose();\n            // commented code below so that windows follow based on setting in\n            // preferences which is set on the pane when the file is opened\n            // for (int i=0; i < instance_.tabbedPane_.getTabCount(); i++) {\n            // ((FileFollowingPane)instance_.tabbedPane_.getComponentAt(i)).startFollowing();\n            // }\n        } catch (Throwable t) {\n            LOG.log(Level.SEVERE, \"Unhandled exception\", t);\n            System.exit(-1);\n        }\n    }\n\n    private class RecentFileListener implements PropertyChangeListener {\n\n        public void propertyChange(PropertyChangeEvent evt) {\n            if (recentFilesMenu != null) {\n                recentFilesMenu.removeAll();\n                List<File> recentFiles = attributes.getRecentFiles();\n                // descend down the list to order files by last opened\n                for (int i = recentFiles.size() - 1; i >= 0; i--) {\n                    // have to use FollowApp.this because 'this' is now the\n                    // context of\n                    // the inner class\n                    recentFilesMenu.add(new Open(FollowApp.this, recentFiles.get(i)));\n                }\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/FollowAppTest1.java",
		"test_prompt": "// FollowAppTest1.java\npackage ghm.follow;\n\nimport ghm.follow.config.Configure;\nimport ghm.follow.config.FollowAppAttributes;\nimport ghm.follow.event.WindowTracker;\nimport ghm.follow.gui.About;\nimport ghm.follow.gui.Clear;\nimport ghm.follow.gui.ClearAll;\nimport ghm.follow.gui.Close;\nimport ghm.follow.gui.Debug;\nimport ghm.follow.gui.Delete;\nimport ghm.follow.gui.DeleteAll;\nimport ghm.follow.gui.DndFileOpener;\nimport ghm.follow.gui.Edit;\nimport ghm.follow.gui.Exit;\nimport ghm.follow.gui.FileFollowingPane;\nimport ghm.follow.gui.FollowAppAction;\nimport ghm.follow.gui.Menu;\nimport ghm.follow.gui.ComponentBuilder;\nimport ghm.follow.gui.Open;\nimport ghm.follow.gui.Pause;\nimport ghm.follow.gui.PopupMenu;\nimport ghm.follow.gui.Reset;\nimport ghm.follow.gui.StartupStatus;\nimport ghm.follow.gui.TabbedPane;\nimport ghm.follow.gui.ToolBar;\nimport ghm.follow.gui.FollowAppAction.ActionContext;\nimport ghm.follow.nav.Bottom;\nimport ghm.follow.nav.NextTab;\nimport ghm.follow.nav.PreviousTab;\nimport ghm.follow.nav.Top;\nimport ghm.follow.search.ClearAllHighlights;\nimport ghm.follow.search.ClearHighlights;\nimport ghm.follow.search.Find;\nimport ghm.follow.search.SearchableTextPane;\nimport ghm.follow.systemInterface.DefaultSystemInterface;\nimport ghm.follow.systemInterface.SystemInterface;\nimport java.awt.BorderLayout;\nimport java.awt.Component;\nimport java.awt.Cursor;\nimport java.awt.Dimension;\nimport java.awt.GraphicsEnvironment;\nimport java.awt.Window;\nimport java.awt.dnd.DropTarget;\nimport java.awt.event.ComponentAdapter;\nimport java.awt.event.ComponentEvent;\nimport java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseListener;\nimport java.beans.PropertyChangeEvent;\nimport java.beans.PropertyChangeListener;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.net.URL;\nimport java.text.MessageFormat;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.MissingResourceException;\nimport java.util.ResourceBundle;\nimport javax.swing.ImageIcon;\nimport javax.swing.JFrame;\nimport javax.swing.JMenuBar;\nimport javax.swing.JTabbedPane;\nimport javax.swing.SwingUtilities;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FollowApp}.\n* It contains ten unit test cases for the {@link FollowApp#getIcon(Class, String)} method.\n*/\nclass FollowAppTest1 {"
	},
	{
		"original_code": "// FollowApp.java\n/*\n * Copyright (C) 2000-2003 Greg Merrill (greghmerrill@yahoo.com)\n * \n * This file is part of Follow (http://follow.sf.net).\n * \n * Follow is free software; you can redistribute it and/or modify it under the\n * terms of version 2 of the GNU General Public License as published by the Free\n * Software Foundation.\n * \n * Follow is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License along with\n * Follow; if not, write to the Free Software Foundation, Inc., 59 Temple Place,\n * Suite 330, Boston, MA 02111-1307 USA\n */\npackage ghm.follow;\n\nimport ghm.follow.config.Configure;\nimport ghm.follow.config.FollowAppAttributes;\nimport ghm.follow.event.WindowTracker;\nimport ghm.follow.gui.About;\nimport ghm.follow.gui.Clear;\nimport ghm.follow.gui.ClearAll;\nimport ghm.follow.gui.Close;\nimport ghm.follow.gui.Debug;\nimport ghm.follow.gui.Delete;\nimport ghm.follow.gui.DeleteAll;\nimport ghm.follow.gui.DndFileOpener;\nimport ghm.follow.gui.Edit;\nimport ghm.follow.gui.Exit;\nimport ghm.follow.gui.FileFollowingPane;\nimport ghm.follow.gui.FollowAppAction;\nimport ghm.follow.gui.Menu;\nimport ghm.follow.gui.ComponentBuilder;\nimport ghm.follow.gui.Open;\nimport ghm.follow.gui.Pause;\nimport ghm.follow.gui.PopupMenu;\nimport ghm.follow.gui.Reset;\nimport ghm.follow.gui.StartupStatus;\nimport ghm.follow.gui.TabbedPane;\nimport ghm.follow.gui.ToolBar;\nimport ghm.follow.gui.FollowAppAction.ActionContext;\nimport ghm.follow.nav.Bottom;\nimport ghm.follow.nav.NextTab;\nimport ghm.follow.nav.PreviousTab;\nimport ghm.follow.nav.Top;\nimport ghm.follow.search.ClearAllHighlights;\nimport ghm.follow.search.ClearHighlights;\nimport ghm.follow.search.Find;\nimport ghm.follow.search.SearchableTextPane;\nimport ghm.follow.systemInterface.DefaultSystemInterface;\nimport ghm.follow.systemInterface.SystemInterface;\nimport java.awt.BorderLayout;\nimport java.awt.Component;\nimport java.awt.Cursor;\nimport java.awt.Dimension;\nimport java.awt.GraphicsEnvironment;\nimport java.awt.Window;\nimport java.awt.dnd.DropTarget;\nimport java.awt.event.ComponentAdapter;\nimport java.awt.event.ComponentEvent;\nimport java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseListener;\nimport java.beans.PropertyChangeEvent;\nimport java.beans.PropertyChangeListener;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.net.URL;\nimport java.text.MessageFormat;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.MissingResourceException;\nimport java.util.ResourceBundle;\nimport javax.swing.ImageIcon;\nimport javax.swing.JFrame;\nimport javax.swing.JMenuBar;\nimport javax.swing.JTabbedPane;\nimport javax.swing.SwingUtilities;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * This class' main() method is the entry point into the Follow application.\n *\n * @see #main(String[])\n * @author <a href=\"mailto:greghmerrill@yahoo.com\">Greg Merrill</a>\n */\npublic class FollowApp {\n\n    public static final String FILE_SEPARATOR = System.getProperty(\"file.separator\");\n\n    public static final String MESSAGE_LINE_SEPARATOR = \"\\n\";\n\n    public static final boolean DEBUG = Boolean.getBoolean(\"follow.debug\");\n\n    public static boolean HAS_SOLARIS_BUG = false;\n\n    private static Logger LOG = Logger.getLogger(FollowApp.class.getName());\n\n    private int currentCursor = Cursor.DEFAULT_CURSOR;\n\n    private Cursor defaultCursor;\n\n    private Cursor waitCursor;\n\n    private Map<File, FileFollowingPane> fileToFollowingPaneMap = new HashMap<File, FileFollowingPane>();\n\n    private JTabbedPane tabbedPane;\n\n    private ToolBar toolBar;\n\n    private PopupMenu popupMenu;\n\n    private Menu recentFilesMenu;\n\n    private MouseListener rightClickListener;\n\n    private HashMap<String, FollowAppAction> actions = new HashMap<String, FollowAppAction>();\n\n    private SystemInterface systemInterface;\n\n    private StartupStatus startupStatus;\n\n    private FollowAppAttributes attributes;\n\n    private static FollowApp instance;\n\n    private static ResourceBundle resources = ResourceBundle.getBundle(\"ghm.follow.FollowAppResourceBundle\");\n\n    private JFrame frame;\n\n    // We should remove this hack once JDK 1.4 gets wide adoption on Solaris.\n    static {\n        boolean isSolaris = \"SunOS\".equals(System.getProperty(\"os.name\"));\n        if (isSolaris) {\n            String version = System.getProperty(\"java.version\");\n            if ((version != null) && version.startsWith(\"1.\")) {\n                String substring = version.substring(2, 3);\n                try {\n                    int minor = Integer.parseInt(substring);\n                    if (minor < 4) {\n                        HAS_SOLARIS_BUG = true;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // Nothing else to do.\n                }\n            }\n        }\n    }\n\n    /**\n     * @param fileNames\n     *            names of files to be opened\n     */\n    FollowApp(List<String> fileNames) throws IOException, InterruptedException, InvocationTargetException {\n        this(fileNames, null);\n    }\n\n    FollowApp(List<String> filenames, File propertyFile) throws IOException, InterruptedException, InvocationTargetException {\n        // Create & show startup status window\n        startupStatus = new StartupStatus(resources);\n        centerWindowInScreen(startupStatus);\n        startupStatus.pack();\n        SwingUtilities.invokeAndWait(new Runnable() {\n\n            public void run() {\n                startupStatus.setVisible(true);\n            }\n        });\n        // Ghastly workaround for bug in Font construction, in review by\n        // Sun with review id 108683.\n        GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames();\n        SwingUtilities.invokeAndWait(new Runnable() {\n\n            public void run() {\n                startupStatus.markDone(startupStatus.LOAD_SYSTEM_FONTS);\n            }\n        });\n        // create frame first. the close operation is handled in WindowTracker\n        frame = new JFrame(getResourceString(\"frame.title\"));\n        // load the attributes\n        attributes = new FollowAppAttributes(propertyFile);\n        // add listeners to update the recent files list\n        RecentFileListener rfl = new RecentFileListener();\n        attributes.addPropertyChangeListener(FollowAppAttributes.RECENT_FILES_KEY, rfl);\n        attributes.addPropertyChangeListener(FollowAppAttributes.RECENT_FILES_MAX_KEY, rfl);\n        // load the actions referenced in the application\n        loadActions();\n        // initialize SystemInterface\n        systemInterface = new DefaultSystemInterface(this);\n        // initialize menubar\n        JMenuBar jMenuBar = ComponentBuilder.buildMenuBar(resources, getActions());\n        // set the recent files menu to local variable so it can be updated\n        // easily\n        recentFilesMenu = ComponentBuilder.recentFilesMenu;\n        // fake an event to get the menu setup initially\n        rfl.propertyChange(null);\n        // initialize popupMenu\n        popupMenu = ComponentBuilder.buildPopupMenu(getActions());\n        // initialize toolbar\n        toolBar = ComponentBuilder.buildToolBar(getActions());\n        // initialize tabbedPane, but wait to open files until after frame\n        // initialization\n        tabbedPane = new TabbedPane(attributes);\n        enableDragAndDrop(tabbedPane);\n        // initialize frame\n        initFrame(jMenuBar);\n        // This is an ugly hack. It seems like JFrame.setLocation() is buggy\n        // on Solaris jdk versions before 1.4\n        if (HAS_SOLARIS_BUG) {\n            frame.setLocation(50, 50);\n        } else {\n            frame.setLocation(attributes.getX(), attributes.getY());\n        }\n        // track window close events. WindowTracker handles the close operation\n        frame.addWindowListener(new WindowTracker(attributes, tabbedPane, systemInterface));\n        enableDragAndDrop(frame);\n        // Open files from attributes; this is done after the frame is complete\n        // and all components have been added to it to make sure that the frame\n        // can be shown absolutely as soon as possible. If we put this code\n        // before frame creation (as in v1.0), frame creation may take longer\n        // because there are more threads (spawned in the course of open())\n        // contending for processor time.\n        List<File> files = attributes.getFollowedFiles();\n        StringBuffer nonexistentFilesBuffer = null;\n        int nonexistentFileCount = 0;\n        for (File file : files) {\n            try {\n                openFile(file);\n            } catch (FileNotFoundException e) {\n                // This file has been deleted since the previous execution.\n                // Remove it from the list of followed files\n                attributes.removeFollowedFile(file);\n                nonexistentFileCount++;\n                if (nonexistentFilesBuffer == null) {\n                    nonexistentFilesBuffer = new StringBuffer(file.getAbsolutePath());\n                } else {\n                    nonexistentFilesBuffer.append(file.getAbsolutePath());\n                }\n                nonexistentFilesBuffer.append(MESSAGE_LINE_SEPARATOR);\n            }\n        }\n        // open files from the command line\n        for (String filename : filenames) {\n            try {\n                openFile(new File(filename));\n            } catch (FileNotFoundException e) {\n                String msg = MessageFormat.format(getResourceString(\"message.cmdLineFileNotFound.text\"), new Object[] { filename });\n                LOG.info(msg);\n            }\n        }\n        if (nonexistentFileCount > 0) {\n            // Alert the user of the fact that one or more files have been\n            // deleted since the previous execution\n            String text = getResourceString(\"message.filesDeletedSinceLastExecution.text\");\n            String message = MessageFormat.format(text, new Object[] { nonexistentFileCount, nonexistentFilesBuffer.toString() });\n            // String title =\n            // getResourceString(\"message.filesDeletedSinceLastExecution.title\");\n            // JOptionPane.showMessageDialog(frame_, message, title,\n            // JOptionPane.WARNING_MESSAGE);\n            LOG.info(message);\n        }\n        int tabCount = tabbedPane.getTabCount();\n        if (tabCount > 0) {\n            if (tabCount > attributes.getSelectedTabIndex()) {\n                tabbedPane.setSelectedIndex(attributes.getSelectedTabIndex());\n            } else {\n                tabbedPane.setSelectedIndex(0);\n            }\n        }\n    }\n\n    /**\n     * Close the current tab\n     */\n    public void closeFile() {\n        FileFollowingPane fileFollowingPane = getSelectedFileFollowingPane();\n        int tab = tabbedPane.getSelectedIndex();\n        if (tab >= 0) {\n            tabbedPane.removeTabAt(tab);\n            disableDragAndDrop(fileFollowingPane.getTextPane());\n            attributes.removeFollowedFile(fileFollowingPane.getFollowedFile());\n            fileFollowingPane.stopFollowing();\n            fileToFollowingPaneMap.remove(fileFollowingPane.getFollowedFile());\n        }\n        updateActions();\n    }\n\n    /**\n     * Get a string from the resource bundle. Convenience method to shorten and\n     * centralize this common call\n     *\n     * @param key\n     * @return The value of key in the resource bundle. null if the key is not\n     *         found.\n     */\n    public static String getResourceString(String key) {\n        String value = null;\n        try {\n            value = resources.getString(key);\n        } catch (MissingResourceException mre) {\n            LOG.warning(mre.getMessage());\n        }\n        return value;\n    }\n\n    /**\n     * Gets an image icon from the resource path.\n     *\n     * @param clazz\n     *            The class to use as an entry point to the resource path. Image\n     *            path should be relative to this class.\n     * @param iconNameKey\n     *            The resource key name where the image is defined.\n     * @return An image icon based on the URL generated from the value of\n     *         iconNameKey. null if no URL can be found.\n     */\n    public static ImageIcon getIcon(Class<?> clazz, String iconNameKey) {\n        String filename = getResourceString(iconNameKey);\n        URL url = clazz.getResource(filename);\n        LOG.finer(\"Class: \" + clazz + \", iconNameKey: \" + iconNameKey);\n        LOG.finer(\"filename: \" + filename);\n        LOG.finer(\"url: \" + url);\n        ImageIcon icon = null;\n        if (url != null) {\n            icon = new ImageIcon(url);\n            LOG.finer(\"errored: \" + (java.awt.MediaTracker.ERRORED == icon.getImageLoadStatus()));\n        }\n        return icon;\n    }\n\n    /**\n     * Loads the actions used in the application\n     *\n     * @throws IOException\n     */\n    private void loadActions() throws IOException {\n        // initialize actions\n        putAction(Open.NAME, new Open(this));\n        putAction(Close.NAME, new Close(this));\n        putAction(Edit.NAME, new Edit(this));\n        putAction(Exit.NAME, new Exit(this));\n        putAction(Top.NAME, new Top(this));\n        putAction(Bottom.NAME, new Bottom(this));\n        putAction(Clear.NAME, new Clear(this));\n        putAction(ClearAll.NAME, new ClearAll(this));\n        putAction(Delete.NAME, new Delete(this));\n        putAction(DeleteAll.NAME, new DeleteAll(this));\n        putAction(Configure.NAME, new Configure(this));\n        putAction(About.NAME, new About(this));\n        if (DEBUG) {\n            putAction(Debug.NAME, new Debug(this));\n        }\n        putAction(Pause.NAME, new Pause(this));\n        putAction(NextTab.NAME, new NextTab(this));\n        putAction(PreviousTab.NAME, new PreviousTab(this));\n        putAction(Find.NAME, new Find(this));\n        putAction(ClearHighlights.NAME, new ClearHighlights(this));\n        putAction(ClearAllHighlights.NAME, new ClearAllHighlights(this));\n        putAction(Reset.NAME, new Reset(this));\n    }\n\n    /**\n     * @param jMenuBar\n     */\n    private void initFrame(JMenuBar jMenuBar) {\n        frame.setJMenuBar(jMenuBar);\n        frame.getContentPane().add(toolBar, BorderLayout.NORTH);\n        frame.getContentPane().add(tabbedPane, BorderLayout.CENTER);\n        frame.setSize(attributes.getWidth(), attributes.getHeight());\n    }\n\n    public void show() {\n        frame.setVisible(true);\n    }\n\n    public FollowAppAction getAction(String name) {\n        return actions.get(name);\n    }\n\n    /**\n     * Get all actions associated to the application\n     *\n     * @return\n     */\n    public HashMap<String, FollowAppAction> getActions() {\n        return actions;\n    }\n\n    /**\n     * Set an action to the action map of the application.\n     *\n     * @param name\n     *            The key to set the action to.\n     * @param action\n     *            The action to create an association for.\n     */\n    public void putAction(String name, FollowAppAction action) {\n        if (FollowAppAction.ActionContext.APP == action.getContext())\n            action.setEnabled(true);\n        else\n            action.setEnabled(false);\n        actions.put(name, action);\n    }\n\n    public void openFile(File file) throws FileNotFoundException {\n        openFile(file, attributes.autoScroll());\n    }\n\n    /**\n     * Warning: This method should be called only from (1) the FollowApp\n     * initializer (before any components are realized) or (2) from the event\n     * dispatching thread.\n     */\n    void openFile(File file, boolean startFollowing) throws FileNotFoundException {\n        if (file == null) {\n            throw new FileNotFoundException(\"file is null.\");\n        }\n        if (!file.exists()) {\n            throw new FileNotFoundException(file.getName() + \" not found.\");\n        }\n        FileFollowingPane fileFollowingPane = (FileFollowingPane) fileToFollowingPaneMap.get(file);\n        if (fileFollowingPane != null) {\n            // File is already open; merely select its tab\n            tabbedPane.setSelectedComponent(fileFollowingPane);\n        } else {\n            fileFollowingPane = new FileFollowingPane(file, attributes.getBufferSize(), attributes.getLatency(), attributes.autoScroll(), attributes.getFont(), attributes.getTabSize());\n            SearchableTextPane ffpTextPane = fileFollowingPane.getTextPane();\n            enableDragAndDrop(ffpTextPane);\n            fileFollowingPane.setSize(frame.getSize());\n            ffpTextPane.setFont(attributes.getFont());\n            ffpTextPane.addMouseListener(getRightClickListener());\n            fileToFollowingPaneMap.put(file, fileFollowingPane);\n            if (startFollowing) {\n                fileFollowingPane.startFollowing();\n            }\n            tabbedPane.addTab(file.getName(), null, fileFollowingPane, file.getAbsolutePath());\n            int tabCount = tabbedPane.getTabCount();\n            if (tabCount < 10) {\n                // KeyEvent.VK_1 through KeyEvent.VK_9 is represented by the\n                // ascii characters 1-9 (49-57)\n                int index = tabCount - 1;\n                tabbedPane.setMnemonicAt(index, index + ((int) '1'));\n            }\n            tabbedPane.setSelectedIndex(tabCount - 1);\n            // add a listener to set the pause icon correctly\n            fileFollowingPane.addComponentListener(new ComponentAdapter() {\n\n                public void componentShown(ComponentEvent e) {\n                    FileFollowingPane ffp = (FileFollowingPane) e.getSource();\n                    Pause pause = (Pause) getAction(Pause.NAME);\n                    pause.setIconByState(ffp.isFollowingPaused());\n                }\n            });\n            // add the file to history\n            attributes.addFollowedFile(file);\n            attributes.addRecentFile(file);\n            updateActions();\n        }\n    }\n\n    private void updateActions() {\n        int tabCount = tabbedPane.getTabCount();\n        for (FollowAppAction a : actions.values()) {\n            if (tabCount <= 1 && a.getContext() == ActionContext.MULTI_FILE)\n                a.setEnabled(false);\n            else if (tabCount == 0 && a.getContext() == ActionContext.SINGLE_FILE)\n                a.setEnabled(false);\n            else\n                a.setEnabled(true);\n        }\n    }\n\n    /**\n     * Warning: This method should be called only from the event dispatching\n     * thread.\n     *\n     * @param cursorType\n     *            may be Cursor.DEFAULT_CURSOR or Cursor.WAIT_CURSOR\n     */\n    public void setCursor(int cursorType) {\n        if (cursorType == currentCursor) {\n            return;\n        }\n        switch(cursorType) {\n            case Cursor.DEFAULT_CURSOR:\n                if (defaultCursor == null) {\n                    defaultCursor = Cursor.getDefaultCursor();\n                }\n                frame.setCursor(defaultCursor);\n                break;\n            case Cursor.WAIT_CURSOR:\n                if (waitCursor == null) {\n                    waitCursor = Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR);\n                }\n                frame.setCursor(waitCursor);\n                break;\n            default:\n                throw new IllegalArgumentException(\"Supported cursors are Cursor.DEFAULT_CURSOR and Cursor.WAIT_CURSOR\");\n        }\n        currentCursor = cursorType;\n    }\n\n    // Lazy initializer for the right-click listener which invokes a popup menu\n    private MouseListener getRightClickListener() {\n        if (rightClickListener == null) {\n            rightClickListener = new MouseAdapter() {\n\n                public void mouseReleased(MouseEvent e) {\n                    if (SwingUtilities.isRightMouseButton(e)) {\n                        Component source = e.getComponent();\n                        popupMenu.show(source, e.getX(), e.getY());\n                    }\n                }\n            };\n        }\n        return rightClickListener;\n    }\n\n    public void enableDragAndDrop(Component c) {\n        // Invoking this constructor automatically sets the component's drop\n        // target\n        new DropTarget(c, new DndFileOpener(this));\n    }\n\n    public void disableDragAndDrop(Component c) {\n        c.setDropTarget(null);\n    }\n\n    public FileFollowingPane getSelectedFileFollowingPane() {\n        return (FileFollowingPane) tabbedPane.getSelectedComponent();\n    }\n\n    public List<FileFollowingPane> getAllFileFollowingPanes() {\n        int tabCount = tabbedPane.getTabCount();\n        List<FileFollowingPane> allFileFollowingPanes = new ArrayList<FileFollowingPane>();\n        for (int i = 0; i < tabCount; i++) {\n            allFileFollowingPanes.add((FileFollowingPane) tabbedPane.getComponentAt(i));\n        }\n        return allFileFollowingPanes;\n    }\n\n    public FollowAppAttributes getAttributes() {\n        return attributes;\n    }\n\n    public Map<File, FileFollowingPane> getFileToFollowingPaneMap() {\n        return fileToFollowingPaneMap;\n    }\n\n    public JFrame getFrame() {\n        return frame;\n    }\n\n    public static FollowApp getInstance() {\n        return instance;\n    }\n\n    public SystemInterface getSystemInterface() {\n        return systemInterface;\n    }\n\n    public void setSystemInterface(SystemInterface systemInterface) {\n        this.systemInterface = systemInterface;\n    }\n\n    public JTabbedPane getTabbedPane() {\n        return tabbedPane;\n    }\n\n    public static void centerWindowInScreen(Window window) {\n        Dimension screenSize = window.getToolkit().getScreenSize();\n        Dimension windowSize = window.getPreferredSize();\n        window.setLocation((int) (screenSize.getWidth() / 2 - windowSize.getWidth() / 2), (int) (screenSize.getHeight() / 2 - windowSize.getHeight() / 2));\n    }\n\n    /**\n     * Invoke this method to start the Follow application. If any command-line\n     * arguments are passed in, they are assume to be filenames and are opened\n     * in the Follow application\n     *\n     * @param args\n     *            files to be opened\n     */\n    public static void main(String[] args) {\n        try {\n            ArrayList<String> fileNames = new ArrayList<String>();\n            File propFile = null;\n            for (int i = 0; i < args.length; i++) {\n                if (args[i].startsWith(\"-\")) {\n                    if (\"-propFile\".equalsIgnoreCase(args[i])) {\n                        propFile = new File(args[++i]);\n                    }\n                } else {\n                    fileNames.add(args[i]);\n                }\n            }\n            instance = new FollowApp(fileNames, propFile);\n            SwingUtilities.invokeAndWait(new Runnable() {\n\n                public void run() {\n                    // ensure all widgets inited before opening files\n                    instance.show();\n                    instance.startupStatus.markDone(instance.startupStatus.CREATE_WIDGETS);\n                }\n            });\n            instance.startupStatus.dispose();\n            // commented code below so that windows follow based on setting in\n            // preferences which is set on the pane when the file is opened\n            // for (int i=0; i < instance_.tabbedPane_.getTabCount(); i++) {\n            // ((FileFollowingPane)instance_.tabbedPane_.getComponentAt(i)).startFollowing();\n            // }\n        } catch (Throwable t) {\n            LOG.log(Level.SEVERE, \"Unhandled exception\", t);\n            System.exit(-1);\n        }\n    }\n\n    private class RecentFileListener implements PropertyChangeListener {\n\n        public void propertyChange(PropertyChangeEvent evt) {\n            if (recentFilesMenu != null) {\n                recentFilesMenu.removeAll();\n                List<File> recentFiles = attributes.getRecentFiles();\n                // descend down the list to order files by last opened\n                for (int i = recentFiles.size() - 1; i >= 0; i--) {\n                    // have to use FollowApp.this because 'this' is now the\n                    // context of\n                    // the inner class\n                    recentFilesMenu.add(new Open(FollowApp.this, recentFiles.get(i)));\n                }\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/41_follow/src/main/java/ghm/follow/FollowAppTest2.java",
		"test_prompt": "// FollowAppTest2.java\npackage ghm.follow;\n\nimport ghm.follow.config.Configure;\nimport ghm.follow.config.FollowAppAttributes;\nimport ghm.follow.event.WindowTracker;\nimport ghm.follow.gui.About;\nimport ghm.follow.gui.Clear;\nimport ghm.follow.gui.ClearAll;\nimport ghm.follow.gui.Close;\nimport ghm.follow.gui.Debug;\nimport ghm.follow.gui.Delete;\nimport ghm.follow.gui.DeleteAll;\nimport ghm.follow.gui.DndFileOpener;\nimport ghm.follow.gui.Edit;\nimport ghm.follow.gui.Exit;\nimport ghm.follow.gui.FileFollowingPane;\nimport ghm.follow.gui.FollowAppAction;\nimport ghm.follow.gui.Menu;\nimport ghm.follow.gui.ComponentBuilder;\nimport ghm.follow.gui.Open;\nimport ghm.follow.gui.Pause;\nimport ghm.follow.gui.PopupMenu;\nimport ghm.follow.gui.Reset;\nimport ghm.follow.gui.StartupStatus;\nimport ghm.follow.gui.TabbedPane;\nimport ghm.follow.gui.ToolBar;\nimport ghm.follow.gui.FollowAppAction.ActionContext;\nimport ghm.follow.nav.Bottom;\nimport ghm.follow.nav.NextTab;\nimport ghm.follow.nav.PreviousTab;\nimport ghm.follow.nav.Top;\nimport ghm.follow.search.ClearAllHighlights;\nimport ghm.follow.search.ClearHighlights;\nimport ghm.follow.search.Find;\nimport ghm.follow.search.SearchableTextPane;\nimport ghm.follow.systemInterface.DefaultSystemInterface;\nimport ghm.follow.systemInterface.SystemInterface;\nimport java.awt.BorderLayout;\nimport java.awt.Component;\nimport java.awt.Cursor;\nimport java.awt.Dimension;\nimport java.awt.GraphicsEnvironment;\nimport java.awt.Window;\nimport java.awt.dnd.DropTarget;\nimport java.awt.event.ComponentAdapter;\nimport java.awt.event.ComponentEvent;\nimport java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseListener;\nimport java.beans.PropertyChangeEvent;\nimport java.beans.PropertyChangeListener;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.net.URL;\nimport java.text.MessageFormat;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.MissingResourceException;\nimport java.util.ResourceBundle;\nimport javax.swing.ImageIcon;\nimport javax.swing.JFrame;\nimport javax.swing.JMenuBar;\nimport javax.swing.JTabbedPane;\nimport javax.swing.SwingUtilities;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FollowApp}.\n* It contains ten unit test cases for the {@link FollowApp#getInstance()} method.\n*/\nclass FollowAppTest2 {"
	}
]